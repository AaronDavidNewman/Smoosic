(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["Smo"] = factory();
	else
		root["Smo"] = factory();
})(this, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/application/application.ts":
/*!****************************************!*\
  !*** ./src/application/application.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SuiApplication = exports.QueryParser = void 0;
// [Smoosic](https://github.com/AaronDavidNewman/Smoosic)
// Copyright (c) Aaron David Newman 2021.
const serializationHelpers_1 = __webpack_require__(/*! ../common/serializationHelpers */ "./src/common/serializationHelpers.js");
const midiWriter_1 = __webpack_require__(/*! ../common/midiWriter */ "./src/common/midiWriter.js");
const configuration_1 = __webpack_require__(/*! ./configuration */ "./src/application/configuration.ts");
const score_1 = __webpack_require__(/*! ../smo/data/score */ "./src/smo/data/score.ts");
const undo_1 = __webpack_require__(/*! ../smo/xform/undo */ "./src/smo/xform/undo.ts");
const xmlToSmo_1 = __webpack_require__(/*! ../smo/mxml/xmlToSmo */ "./src/smo/mxml/xmlToSmo.ts");
const scoreViewOperations_1 = __webpack_require__(/*! ../render/sui/scoreViewOperations */ "./src/render/sui/scoreViewOperations.ts");
const oscillator_1 = __webpack_require__(/*! ../render/audio/oscillator */ "./src/render/audio/oscillator.ts");
const samples_1 = __webpack_require__(/*! ../render/audio/samples */ "./src/render/audio/samples.ts");
const arial_metrics_1 = __webpack_require__(/*! ../styles/font_metrics/arial_metrics */ "./src/styles/font_metrics/arial_metrics.js");
const times_metrics_1 = __webpack_require__(/*! ../styles/font_metrics/times_metrics */ "./src/styles/font_metrics/times_metrics.js");
const Commissioner_Medium_Metrics_1 = __webpack_require__(/*! ../styles/font_metrics/Commissioner-Medium-Metrics */ "./src/styles/font_metrics/Commissioner-Medium-Metrics.js");
const ConcertOne_Regular_1 = __webpack_require__(/*! ../styles/font_metrics/ConcertOne-Regular */ "./src/styles/font_metrics/ConcertOne-Regular.js");
const Merriweather_Regular_1 = __webpack_require__(/*! ../styles/font_metrics/Merriweather-Regular */ "./src/styles/font_metrics/Merriweather-Regular.js");
const ssp_sans_metrics_1 = __webpack_require__(/*! ../styles/font_metrics/ssp-sans-metrics */ "./src/styles/font_metrics/ssp-sans-metrics.js");
const ssp_serif_metrics_1 = __webpack_require__(/*! ../styles/font_metrics/ssp-serif-metrics */ "./src/styles/font_metrics/ssp-serif-metrics.js");
const xhrLoader_1 = __webpack_require__(/*! ../ui/fileio/xhrLoader */ "./src/ui/fileio/xhrLoader.ts");
const manager_1 = __webpack_require__(/*! ../ui/menus/manager */ "./src/ui/menus/manager.ts");
const eventSource_1 = __webpack_require__(/*! ../ui/eventSource */ "./src/ui/eventSource.ts");
const translationEditor_1 = __webpack_require__(/*! ../ui/i18n/translationEditor */ "./src/ui/i18n/translationEditor.ts");
const language_1 = __webpack_require__(/*! ../ui/i18n/language */ "./src/ui/i18n/language.ts");
const ribbon_1 = __webpack_require__(/*! ../ui/buttons/ribbon */ "./src/ui/buttons/ribbon.ts");
const promiseHelpers_1 = __webpack_require__(/*! ../common/promiseHelpers */ "./src/common/promiseHelpers.ts");
const dom_1 = __webpack_require__(/*! ./dom */ "./src/application/dom.ts");
const keyCommands_1 = __webpack_require__(/*! ./keyCommands */ "./src/application/keyCommands.ts");
const eventHandler_1 = __webpack_require__(/*! ./eventHandler */ "./src/application/eventHandler.ts");
const common_1 = __webpack_require__(/*! ./common */ "./src/application/common.ts");
const typedoc_1 = __webpack_require__(/*! ../../typedoc */ "./typedoc.ts");
const htmlHelpers_1 = __webpack_require__(/*! ../common/htmlHelpers */ "./src/common/htmlHelpers.ts");
const help_1 = __webpack_require__(/*! ../ui/help */ "./src/ui/help.ts");
const VF = eval('Vex.Flow');
/**
 * Parse query string for application
 * @category AppUtil
 */
class QueryParser {
    constructor() {
        this.pairs = [];
        let i = 0;
        if (window.location.search) {
            const cmd = window.location.search.substring(1, window.location.search.length);
            const cmds = cmd.split('&');
            for (i = 0; i < cmds.length; ++i) {
                const cmd = cmds[i];
                this.pairs.push(this.queryPair(cmd));
            }
        }
    }
    queryPair(str) {
        var i = 0;
        const ar = str.split('=');
        const rv = {};
        for (i = 0; i < ar.length - 1; i += 2) {
            const name = decodeURIComponent(ar[i]);
            rv[name] = decodeURIComponent(ar[i + 1]);
        }
        return rv;
    }
}
exports.QueryParser = QueryParser;
/** SuiApplication
 * main entry point of application.  Based on the configuration,
 * either start the default UI, or initialize library mode and
 * await further instructions.
 * @category SuiApplication
 */
class SuiApplication {
    constructor(config) {
        this.instance = null;
        this.score = null;
        this.view = null;
        this.config = config;
        this.domElement = this._getDomContainer();
    }
    static configure(params) {
        const config = new configuration_1.SmoConfiguration(params);
        window.SmoConfig = config;
        const application = new SuiApplication(config);
        SuiApplication.registerFonts();
        return application.initialize();
    }
    _getDomContainer() {
        const el = (0, htmlHelpers_1.getDomContainer)(this.config.scoreDomContainer);
        if (typeof (el) === 'undefined') {
            throw 'scoreDomContainer is a required config parameter';
        }
        return el;
    }
    /**
    // Different applications can create their own key bindings, these are the defaults.
    // Many editor commands can be reached by a single keystroke.  For more advanced things there
    // are menus.
    */
    static get keyBindingDefaults() {
        var editorKeys = eventHandler_1.SuiEventHandler.editorKeyBindingDefaults;
        editorKeys.forEach((key) => {
            key.module = 'keyCommands';
        });
        var trackerKeys = eventHandler_1.SuiEventHandler.trackerKeyBindingDefaults;
        trackerKeys.forEach((key) => {
            key.module = 'tracker';
        });
        return trackerKeys.concat(editorKeys);
    }
    /**
     * Initialize the library according to instruction in config object:
     * 1.  Try to load a new score
     * 2.  If in application mode, start the UI.  If in translation mode, start translation
     * @returns
     */
    initialize() {
        const samplePromise = samples_1.SuiSampleMedia.samplePromise(oscillator_1.SuiOscillator.audio);
        const self = this;
        // Hide header at the top of some applications
        $('#link-hdr button').off('click').on('click', () => {
            $('#link-hdr').addClass('hide');
        });
        const createScore = () => {
            return self.createScore();
        };
        const startApplication = () => {
            if (self.config.mode === 'translate') {
                self._startApplication();
            }
            else if (self.config.mode === 'application') {
                self._startApplication();
            }
            else { // library mode.
                self.createView(self.score);
            }
        };
        const render = () => {
            var _a;
            return (_a = self.view) === null || _a === void 0 ? void 0 : _a.renderer.renderPromise();
        };
        const rv = new Promise((resolve) => {
            samplePromise.then(createScore).then(startApplication).then(render)
                .then(() => {
                resolve(self);
            });
        });
        return rv;
    }
    /**
     * Create the initial score we use to populate the UI etc:
     * 0. if translation mode, return empty promise, it won't be used anyway
     * 1. if remoteScore is set in config, try to load from remote
     * 2. if initialScore is set, use that
     * 3. if a score is saved locally with quick save (browser local cache), use that
     * 4. if all else fails, return an 'empty' score.
     * @returns promise for a remote load.  If a local load, will resolve immediately
     */
    createScore() {
        if (this.config.mode === 'translate') {
            return promiseHelpers_1.PromiseHelpers.emptyPromise();
        }
        if (this.config.remoteScore) {
            const loader = new xhrLoader_1.SuiXhrLoader(this.config.remoteScore);
            const self = this;
            return new Promise((resolve) => {
                loader.loadAsync().then(() => {
                    self.score = this._tryParse(loader.value);
                    resolve(self);
                });
            });
        }
        else if (this.config.initialScore) {
            if (typeof (this.config.initialScore) === 'string') {
                this.score = this._tryParse(this.config.initialScore);
                return promiseHelpers_1.PromiseHelpers.emptyPromise();
            }
            else {
                this.score = this.config.initialScore;
                return promiseHelpers_1.PromiseHelpers.emptyPromise();
            }
        }
        else {
            const localScore = localStorage.getItem(serializationHelpers_1.smoSerialize.localScore);
            if (localScore) {
                this.score = this._tryParse(localScore);
            }
            else {
                this.score = score_1.SmoScore.getDefaultScore(score_1.SmoScore.defaults, null);
                if (this.config.mode === 'application') {
                    help_1.SuiHelp.displayHelp();
                }
            }
        }
        return promiseHelpers_1.PromiseHelpers.emptyPromise();
    }
    _tryParse(scoreJson) {
        try {
            if (scoreJson[0] === '<') {
                const parser = new DOMParser();
                const xml = parser.parseFromString(scoreJson, 'text/xml');
                return xmlToSmo_1.XmlToSmo.convert(xml);
            }
            return score_1.SmoScore.deserialize(scoreJson);
        }
        catch (exp) {
            console.warn('could not parse score');
            return score_1.SmoScore.getDefaultScore(score_1.SmoScore.defaults, typedoc_1.SmoMeasure.defaults);
        }
    }
    _startApplication() {
        var _a;
        // Initialize the midi writer library
        (0, midiWriter_1._MidiWriter)();
        const queryString = new QueryParser();
        const languageSelect = (_a = queryString.pairs.find((x) => x['language'])) !== null && _a !== void 0 ? _a : { 'language': 'en' };
        if (this.config.mode === 'translate') {
            this._deferCreateTranslator();
            return;
        }
        if (languageSelect) {
            SuiApplication._deferLanguageSelection(languageSelect.language);
        }
        this.createUi();
    }
    createView(score) {
        let sdc = this.domElement;
        const svgContainer = document.createElement('div');
        $(svgContainer).attr('id', 'boo').addClass('musicContainer');
        $(sdc).append(svgContainer);
        const undoBuffer = new undo_1.UndoBuffer();
        const view = new scoreViewOperations_1.SuiScoreViewOperations(this.config, svgContainer, score, sdc, undoBuffer);
        const eventSource = new eventSource_1.BrowserEventSource();
        eventSource.setRenderElement(svgContainer);
        this.view = view;
        view.startRenderingEngine();
        return {
            view, eventSource, undoBuffer, renderer: view.renderer
        };
    }
    /**
     * Convenience constructor, take the score and render it in the
     * configured rendering space.
     */
    createUi() {
        const viewObj = this.createView(this.score);
        if (!viewObj) {
            return;
        }
        const view = this.view;
        const tracker = view.tracker;
        const eventSource = new eventSource_1.BrowserEventSource(); // events come from the browser UI.
        const undoBuffer = viewObj.undoBuffer;
        const completeNotifier = new common_1.ModalEventHandlerProxy(eventSource);
        const menus = new manager_1.SuiMenuManager({
            view, eventSource, completeNotifier, undoBuffer
        });
        const ribbon = new ribbon_1.RibbonButtons({
            config: this.config,
            ribbons: this.config.ribbonLayout,
            ribbonButtons: this.config.buttonDefinition,
            menus: menus,
            completeNotifier,
            view: view,
            eventSource: eventSource,
            tracker: view.tracker
        });
        const keyCommands = new keyCommands_1.SuiKeyCommands({
            view, slashMode: true, completeNotifier, tracker, eventSource
        });
        const eventHandler = new eventHandler_1.SuiEventHandler({
            view, eventSource, tracker, keyCommands, menus, completeNotifier,
            keyBindings: SuiApplication.keyBindingDefaults, config: this.config
        });
        this.instance = {
            view, eventSource, eventHandler, undoBuffer,
            tracker, ribbon, keyCommands, menus
        };
        SuiApplication.instance = this.instance;
        completeNotifier.handler = eventHandler;
        eventSource.setRenderElement(view.renderer.elementId);
        // eslint-disable-next-line
        SuiApplication.instance = this.instance;
        ribbon.display();
        dom_1.SuiDom.splash(this.config);
    }
    static registerFonts() {
        VF.TextFormatter.registerInfo({
            name: arial_metrics_1.ArialFont.name,
            resolution: arial_metrics_1.ArialFont.resolution,
            glyphs: arial_metrics_1.ArialFont.glyphs,
            family: arial_metrics_1.ArialFont.fontFamily,
            serifs: false,
            monospaced: false,
            italic: true,
            bold: true,
            maxSizeGlyph: 'H',
            superscriptOffset: 0.66,
            subscriptOffset: 0.66,
            description: 'Built-in sans font',
        });
        VF.TextFormatter.registerInfo({
            name: times_metrics_1.TimesFont.name,
            resolution: times_metrics_1.TimesFont.resolution,
            glyphs: times_metrics_1.TimesFont.glyphs,
            family: times_metrics_1.TimesFont.fontFamily,
            serifs: false,
            monospaced: false,
            italic: true,
            bold: true,
            maxSizeGlyph: 'H',
            superscriptOffset: 0.66,
            subscriptOffset: 0.66,
            description: 'Built-in serif font',
        });
        VF.TextFormatter.registerInfo({
            name: Commissioner_Medium_Metrics_1.Commissioner_MediumFont.name,
            resolution: Commissioner_Medium_Metrics_1.Commissioner_MediumFont.resolution,
            glyphs: Commissioner_Medium_Metrics_1.Commissioner_MediumFont.glyphs,
            family: Commissioner_Medium_Metrics_1.Commissioner_MediumFont.fontFamily,
            serifs: false,
            monospaced: false,
            italic: false,
            bold: false,
            maxSizeGlyph: 'H',
            superscriptOffset: 0.66,
            subscriptOffset: 0.66,
            description: 'Low-contrast sans-serif text font',
        });
        VF.TextFormatter.registerInfo({
            name: ConcertOne_Regular_1.Concert_OneFont.name,
            resolution: ConcertOne_Regular_1.Concert_OneFont.resolution,
            glyphs: ConcertOne_Regular_1.Concert_OneFont.glyphs,
            family: ConcertOne_Regular_1.Concert_OneFont.fontFamily,
            serifs: false,
            monospaced: false,
            italic: false,
            bold: false,
            maxSizeGlyph: 'H',
            superscriptOffset: 0.66,
            subscriptOffset: 0.66,
            description: 'Rounded grotesque typeface inspired by 19th century 3D l',
        });
        VF.TextFormatter.registerInfo({
            name: Merriweather_Regular_1.MerriweatherFont.name,
            resolution: Merriweather_Regular_1.MerriweatherFont.resolution,
            glyphs: Merriweather_Regular_1.MerriweatherFont.glyphs,
            family: Merriweather_Regular_1.MerriweatherFont.fontFamily,
            serifs: true,
            monospaced: false,
            italic: false,
            bold: false,
            maxSizeGlyph: 'H',
            superscriptOffset: 0.66,
            subscriptOffset: 0.66,
            description: 'Serif screen font from Sorkin Type',
        });
        VF.TextFormatter.registerInfo({
            name: ssp_sans_metrics_1.SourceSansProFont.name,
            resolution: ssp_sans_metrics_1.SourceSansProFont.resolution,
            glyphs: ssp_sans_metrics_1.SourceSansProFont.glyphs,
            family: ssp_sans_metrics_1.SourceSansProFont.fontFamily,
            serifs: false,
            monospaced: false,
            italic: false,
            bold: false,
            maxSizeGlyph: 'H',
            superscriptOffset: 0.66,
            subscriptOffset: 0.66,
            description: 'Open source Sans screen font from Adobe',
        });
        VF.TextFormatter.registerInfo({
            name: ssp_serif_metrics_1.SourceSerifProFont.name,
            resolution: ssp_serif_metrics_1.SourceSerifProFont.resolution,
            glyphs: ssp_serif_metrics_1.SourceSerifProFont.glyphs,
            family: ssp_serif_metrics_1.SourceSerifProFont.fontFamily,
            serifs: false,
            monospaced: false,
            italic: false,
            bold: false,
            maxSizeGlyph: 'H',
            superscriptOffset: 0.66,
            subscriptOffset: 0.66,
            description: 'Open source Serif screen font from Adobe',
        });
    }
    _deferCreateTranslator() {
        dom_1.SuiDom.createUiDom(this.config.scoreDomContainer);
        setTimeout(() => {
            translationEditor_1.SmoTranslationEditor.startEditor(this.config.language);
        }, 1);
    }
    static _deferLanguageSelection(lang) {
        setTimeout(() => {
            language_1.SmoTranslator.setLanguage(lang);
        }, 1);
    }
}
exports.SuiApplication = SuiApplication;


/***/ }),

/***/ "./src/application/common.ts":
/*!***********************************!*\
  !*** ./src/application/common.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ModalEventHandlerProxy = exports.SimpleEventHandler = exports.ModalEventHandler = void 0;
/**
 * Shared interface for menus, dialogs, etc that can
 * accept UI events
 * @category SuiUiBase
 */
class ModalEventHandler {
}
exports.ModalEventHandler = ModalEventHandler;
class SimpleEventHandler extends ModalEventHandler {
    constructor(mouseMove, mouseClick, keyHandler) {
        super();
        this.mouseMoveHandler = mouseMove;
        this.mouseClickHandler = mouseClick;
        this.evKeyHandler = keyHandler;
    }
    ;
    mouseMove(ev) {
        this.mouseMove(ev);
    }
    mouseClick(ev) {
        this.mouseClick(ev);
    }
    evKey(ev) {
        this.evKeyHandler(ev);
    }
}
exports.SimpleEventHandler = SimpleEventHandler;
/**
 * Dependency injection, sends events to a proxy object, gets around some
 * cyclic dependencies when bootstrapping the application.
 * @category AppUtil
 */
class ModalEventHandlerProxy {
    constructor(evSource) {
        this._handler = null;
        this.unbound = true;
        this.keydownHandler = null;
        this.mouseMoveHandler = null;
        this.mouseClickHandler = null;
        this.eventSource = evSource;
        this.bindEvents();
    }
    set handler(value) {
        this._handler = value;
        this.unbound = false;
    }
    evKey(ev) {
        if (this._handler) {
            this._handler.evKey(ev);
        }
    }
    mouseMove(ev) {
        if (this._handler) {
            this._handler.mouseMove(ev);
        }
    }
    mouseClick(ev) {
        if (this._handler) {
            this._handler.mouseClick(ev);
        }
    }
    bindEvents() {
        this.mouseMoveHandler = this.eventSource.bindMouseMoveHandler(this, 'mouseMove');
        this.mouseClickHandler = this.eventSource.bindMouseClickHandler(this, 'mouseClick');
        this.keydownHandler = this.eventSource.bindKeydownHandler(this, 'evKey');
    }
    unbindKeyboardForModal(dialog) {
        if (this.unbound) {
            console.log('received duplicate bind event');
            return;
        }
        if (!this.keydownHandler || !this.mouseMoveHandler || !this.mouseClickHandler) {
            console.log('received bind with no handlers');
            return;
        }
        this.unbound = true;
        const rebind = () => {
            this.unbound = false;
            this.bindEvents();
        };
        this.eventSource.unbindKeydownHandler(this.keydownHandler);
        this.eventSource.unbindMouseMoveHandler(this.mouseMoveHandler);
        this.eventSource.unbindMouseClickHandler(this.mouseClickHandler);
        dialog.closeModalPromise.then(rebind);
    }
}
exports.ModalEventHandlerProxy = ModalEventHandlerProxy;


/***/ }),

/***/ "./src/application/configuration.ts":
/*!******************************************!*\
  !*** ./src/application/configuration.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SmoConfiguration = exports.ConfigurationNumberOptions = exports.ConfigurationStringOptions = void 0;
const editorKeys_1 = __webpack_require__(/*! ../ui/keyBindings/default/editorKeys */ "./src/ui/keyBindings/default/editorKeys.ts");
const trackerKeys_1 = __webpack_require__(/*! ../ui/keyBindings/default/trackerKeys */ "./src/ui/keyBindings/default/trackerKeys.ts");
const defaultRibbon_1 = __webpack_require__(/*! ../ui/ribbonLayout/default/defaultRibbon */ "./src/ui/ribbonLayout/default/defaultRibbon.ts");
const musicCursor_1 = __webpack_require__(/*! ../render/audio/musicCursor */ "./src/render/audio/musicCursor.ts");
exports.ConfigurationStringOptions = ['language', 'libraryUrl', 'remoteScore'];
exports.ConfigurationNumberOptions = ['demonPollTime', 'idleRedrawTime'];
/**
 * Configures smoosic library or application. It is a union of UI, rendering and application configuration parameters
 * @param mode - score mode `'library' | 'application' | 'translate'`
 *   Library mode starts the view but not the UI.  application mode starts the UI and expects UI parameters.
 *   translation mode is the translation editor, for creating translations for dialog/menu components
 * @param language - startup language
 * @param initialScore? - the library score JSON, if you are loading from a JSON string, or a SmoScore object
 * @param remoteScore? - path to a remote score, if loading from an URL
 * @param scoreDomContainer - the parent of the svg container (required)
 * @param leftControls - the location of the vertical button control, applies if mode is 'application'
 * @param topControls - the location of the horizontal button control, applies if mode is 'application'
 * @param libraryUrl - loader URL for Smo libraries, applies if application mode
 * @param demonPollTime - how often we poll the score to see if it's changed
 * @param idleRedrawTime - how often the entire score re-renders
 * @category SuiApplication
 */
class SmoConfiguration {
    constructor(params) {
        var _a, _b, _c;
        this.language = '';
        this.demonPollTime = 0; // how often we poll the score to see if it changed
        this.idleRedrawTime = 0;
        const defs = SmoConfiguration.defaults;
        exports.ConfigurationStringOptions.forEach((param) => {
            var _a;
            const sp = (_a = params[param]) !== null && _a !== void 0 ? _a : defs[param];
            this[param] = sp !== null && sp !== void 0 ? sp : '';
        });
        this.scoreDomContainer = (_a = params.scoreDomContainer) !== null && _a !== void 0 ? _a : defs.scoreDomContainer;
        this.initialScore = (_b = params.initialScore) !== null && _b !== void 0 ? _b : undefined;
        exports.ConfigurationNumberOptions.forEach((param) => {
            var _a;
            this[param] = (_a = params[param]) !== null && _a !== void 0 ? _a : defs[param];
        });
        this.mode = (_c = params.mode) !== null && _c !== void 0 ? _c : defs.mode;
        if (this.mode === 'application') {
            this.leftControls = params.leftControls;
            this.topControls = params.topControls;
        }
        this.ribbonLayout = params.ribbonLayout ? params.ribbonLayout : defaultRibbon_1.defaultRibbonLayout.ribbons;
        this.buttonDefinition = params.buttonDefinition ? params.buttonDefinition : defaultRibbon_1.defaultRibbonLayout.ribbonButtons;
        if (!params.ribbonLayout) {
            this.ribbonLayout = defaultRibbon_1.defaultRibbonLayout.ribbons;
        }
        if (!params.buttonDefinition) {
            this.buttonDefinition = defaultRibbon_1.defaultRibbonLayout.ribbonButtons;
        }
        if (!params.audioAnimation) {
            this.audioAnimation = SmoConfiguration.defaults.audioAnimation;
        }
        else {
            this.audioAnimation = params.audioAnimation;
        }
    }
    static get defaults() {
        return {
            mode: 'application',
            language: 'en',
            scoreDomContainer: 'boo',
            libraryUrl: 'https://aarondavidnewman.github.io/Smoosic/release/library/links/smoLibrary.json',
            demonPollTime: 50,
            idleRedrawTime: 1000,
            ribbonLayout: defaultRibbon_1.defaultRibbonLayout.ribbons,
            buttonDefinition: defaultRibbon_1.defaultRibbonLayout.ribbonButtons,
            audioAnimation: {
                audioAnimationHandler: musicCursor_1.defaultAudioAnimationHandler,
                clearAudioAnimationHandler: musicCursor_1.defaultClearAudioAnimationHandler
            }
        };
    }
    static get keyBindingDefaults() {
        const editorKeys = editorKeys_1.defaultEditorKeys.keys;
        const trackerKeys = trackerKeys_1.defaultTrackerKeys.keys;
        editorKeys.forEach((key) => {
            key.module = 'keyCommands';
        });
        trackerKeys.forEach((key) => {
            key.module = 'tracker';
        });
        return { editorKeys, trackerKeys };
    }
}
exports.SmoConfiguration = SmoConfiguration;


/***/ }),

/***/ "./src/application/dom.ts":
/*!********************************!*\
  !*** ./src/application/dom.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SuiDom = void 0;
// [Smoosic](https://github.com/AaronDavidNewman/Smoosic)
// Copyright (c) Aaron David Newman 2021.
const htmlHelpers_1 = __webpack_require__(/*! ../common/htmlHelpers */ "./src/common/htmlHelpers.ts");
const svgHelpers_1 = __webpack_require__(/*! ../render/sui/svgHelpers */ "./src/render/sui/svgHelpers.ts");
const piano_1 = __webpack_require__(/*! ../render/sui/piano */ "./src/render/sui/piano.ts");
class SuiDom {
    static splash(config) {
        var b = htmlHelpers_1.buildDom;
        var logoPath = '../styles/images/logo.png';
        var r = b('div').classes('bug-modal').append(b('img').attr('src', logoPath).classes('splash-logo').attr('width', '300px').attr('height', '300px'))
            .append(b('button').classes('icon icon-cross bug-dismiss-button'))
            .append(b('div').classes('splash-div')
            .append(b('span').classes('splash-title').text('Sm'))
            .append(b('span').classes('splash-shine').text('ooooooooo'))
            .append(b('span').classes('splash-title').text('sic')));
        $('body').append(r.dom());
        $('body').addClass('splashScreen modal');
        setTimeout(function () {
            $('body').removeClass('splashScreen modal');
        }, 1000);
    }
    static createUiDom(uiDomContainer) {
        var _a;
        if (!uiDomContainer) {
            return;
        }
        if (typeof (uiDomContainer) === 'string') {
            uiDomContainer = (_a = document.getElementById(uiDomContainer)) !== null && _a !== void 0 ? _a : undefined;
        }
        if (!uiDomContainer) {
            return;
        }
        var b = htmlHelpers_1.buildDom;
        var r = b('div').classes('dom-container')
            .append(b('div').classes('workspace language-dir').attr('dir', 'ltr')
            .append(b('div').classes('control-bar')
            .append(b('div').classes('titleText').text('Smoosic'))
            .append(b('div').classes('piano-container')
            .append(b('div').classes('key-left-ctrl'))
            .append(b('div').classes('piano-keys'))
            .append(b('div').classes('key-right-ctrl')))
            .append(b('div').classes('controls-top').attr('id', 'controls-top')))
            .append(b('div').classes('media')
            .append(b('div').classes('controls-left').attr('id', 'controls-left'))));
        uiDomContainer.append(r.dom()[0]);
        const scrollRegion = document.createElement('div');
        $(scrollRegion).attr('id', 'smo-scroll-region').addClass('musicRelief');
        $('.dom-container .media').append(scrollRegion);
        var pianoDom = $('.piano-keys')[0];
        var svg = document.createElementNS(svgHelpers_1.SvgHelpers.namespace, 'svg');
        svg.id = 'piano-svg';
        svg.setAttributeNS('', 'width', '' + piano_1.SuiPiano.owidth * piano_1.SuiPiano.dimensions.octaves);
        svg.setAttributeNS('', 'height', '' + piano_1.SuiPiano.dimensions.wheight);
        svg.setAttributeNS('', 'viewBox', '0 0 ' + piano_1.SuiPiano.owidth * piano_1.SuiPiano.dimensions.octaves + ' ' + piano_1.SuiPiano.dimensions.wheight);
        pianoDom.appendChild(svg);
    }
}
exports.SuiDom = SuiDom;


/***/ }),

/***/ "./src/application/eventHandler.ts":
/*!*****************************************!*\
  !*** ./src/application/eventHandler.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


// [Smoosic](https://github.com/AaronDavidNewman/Smoosic)
// Copyright (c) Aaron David Newman 2021.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SuiEventHandler = void 0;
const exceptions_1 = __webpack_require__(/*! ../ui/exceptions */ "./src/ui/exceptions.ts");
const qwerty_1 = __webpack_require__(/*! ../ui/qwerty */ "./src/ui/qwerty.ts");
const factory_1 = __webpack_require__(/*! ../ui/dialogs/factory */ "./src/ui/dialogs/factory.ts");
const piano_1 = __webpack_require__(/*! ../render/sui/piano */ "./src/render/sui/piano.ts");
const help_1 = __webpack_require__(/*! ../ui/help */ "./src/ui/help.ts");
const tracker_1 = __webpack_require__(/*! ../render/sui/tracker */ "./src/render/sui/tracker.ts");
const editorKeys_1 = __webpack_require__(/*! ../ui/keyBindings/default/editorKeys */ "./src/ui/keyBindings/default/editorKeys.ts");
const trackerKeys_1 = __webpack_require__(/*! ../ui/keyBindings/default/trackerKeys */ "./src/ui/keyBindings/default/trackerKeys.ts");
const svgHelpers_1 = __webpack_require__(/*! ../render/sui/svgHelpers */ "./src/render/sui/svgHelpers.ts");
/**
 * this is the default keyboard/mouse handler for smoosic in application mode.
 * It diverts key events to tracker or key commmands as appropriate, and mouse events to
 * tracker.  Modal elements take this control away temporarily.
 *
 * It also handles some global events such as window resize and scroll of the music region.
 * @category SuiApplication
*/
class SuiEventHandler {
    constructor(params) {
        this.resizing = false;
        this.undoStatus = 0;
        this.trackScrolling = false;
        this.keyHandlerObj = null;
        this.piano = null;
        SuiEventHandler.instance = this;
        this.view = params.view;
        this.config = params.config;
        this.menus = params.menus;
        this.completeNotifier = params.completeNotifier;
        this.eventSource = params.eventSource;
        this.tracker = params.tracker; // needed for key event handling
        this.keyBind = params.keyBindings;
        this.keyCommands = params.keyCommands;
        this.keyCommands.view = this.view;
        this.resizing = false;
        this.undoStatus = 0;
        this.trackScrolling = false;
        this.keyHandlerObj = null;
        // create global exception instance
        this.exhandler = new exceptions_1.SuiExceptionHandler(this);
        this.bindEvents();
        this.bindResize();
        this.createPiano();
    }
    static showQwerty() {
        SuiEventHandler.keyboardUi = qwerty_1.Qwerty;
        qwerty_1.Qwerty.displayKb();
    }
    static get scrollable() {
        return '.musicRelief';
    }
    handleScrollEvent() {
        const self = this;
        if (self.trackScrolling) {
            return;
        }
        self.trackScrolling = true;
        setTimeout(function () {
            try {
                // wait until redraw is done to track scroll events.
                self.trackScrolling = false;
                // Thisi s a WIP...
                self.view.tracker.scroller.handleScroll($(SuiEventHandler.scrollable)[0].scrollLeft, $(SuiEventHandler.scrollable)[0].scrollTop);
            }
            catch (e) {
                exceptions_1.SuiExceptionHandler.instance.exceptionHandler(e);
            }
        }, 500);
    }
    createPiano() {
        this.piano = new piano_1.SuiPiano(this.view);
    }
    resizeEvent() {
        var self = this;
        if (this.resizing) {
            return;
        }
        if (!this.piano) {
            return;
        }
        if ($('body').hasClass('printing')) {
            return;
        }
        this.resizing = true;
        setTimeout(function () {
            console.log('resizing');
            self.resizing = false;
            self.piano.handleResize();
            self.view.refreshViewport();
        }, 1);
    }
    createModifierDialog(modifierSelection) {
        var parameters = {
            modifier: modifierSelection.modifier,
            view: this.view, eventSource: this.eventSource,
            completeNotifier: this.completeNotifier, keyCommands: this.keyCommands,
            ctor: '',
            tracker: this.tracker,
            startPromise: null,
            id: 'modifier-dialog',
            config: this.config
        };
        return factory_1.SuiModifierDialogFactory.createModifierDialog(modifierSelection.modifier, parameters);
    }
    // If the user has selected a modifier via the mouse/touch, bring up mod dialog
    // for that modifier
    trackerModifierSelect(ev) {
        var modSelection = this.view.tracker.getSelectedModifier();
        if (modSelection) {
            var dialog = this.createModifierDialog(modSelection);
            if (dialog) {
                // this.view.tracker.selectSuggestion(ev);
                return;
                // this.unbindKeyboardForModal(dialog);
            }
            else {
                this.view.tracker.advanceModifierSelection(this.view.score, ev);
            }
        }
        else {
            this.view.tracker.selectSuggestion(this.view.score, ev);
        }
        return;
    }
    // ### bindResize
    // This handles both resizing of the music area (scrolling) and resizing of the window.
    // The latter results in a redraw, the former just resets the client/logical map of elements
    // in the tracker.
    bindResize() {
        const self = this;
        const el = $(SuiEventHandler.scrollable)[0];
        // unit test programs don't have resize html
        if (!el) {
            return;
        }
        window.addEventListener('resize', function () {
            self.resizeEvent();
        });
        let scrollCallback = () => {
            self.handleScrollEvent();
        };
        el.onscroll = scrollCallback;
    }
    // ### renderElement
    // return render element that is the DOM parent of the svg
    get renderElement() {
        return this.view.renderer.renderElement;
    }
    // ## editorKeyBindingDefaults
    // ## Description:
    // execute a simple command on the editor, based on a keystroke.
    static get editorKeyBindingDefaults() {
        return editorKeys_1.defaultEditorKeys.keys;
    }
    // ## trackerKeyBindingDefaults
    // ### Description:
    // Key bindings for the tracker.  The tracker is the 'cursor' in the music
    // that lets you select and edit notes.
    static get trackerKeyBindingDefaults() {
        return trackerKeys_1.defaultTrackerKeys.keys;
    }
    helpControls() {
        var self = this;
        var rebind = function () {
            self.bindEvents();
        };
    }
    menuHelp() {
        help_1.SuiHelp.displayHelp();
    }
    evKey(evdata) {
        if ($('body').hasClass('translation-mode')) {
            return;
        }
        console.log("KeyboardEvent: key='" + evdata.key + "' | code='" +
            evdata.code + "'"
            + " shift='" + evdata.shiftKey + "' control='" + evdata.ctrlKey + "'" + " alt='" + evdata.altKey + "'");
        evdata.preventDefault();
        if (SuiEventHandler.keyboardUi) {
            qwerty_1.Qwerty.handleKeyEvent(evdata);
        }
        const dataCopy = tracker_1.SuiTracker.serializeEvent(evdata);
        this.view.renderer.updatePromise().then(() => {
            if (dataCopy.key == '?') {
                help_1.SuiHelp.displayHelp();
            }
            if (dataCopy.key == '/') {
                // set up menu DOM.
                this.menus.slashMenuMode(this.completeNotifier);
            }
            if (dataCopy.key == 'Enter') {
                this.trackerModifierSelect(dataCopy);
            }
            var binding = this.keyBind.find((ev) => ev.event === 'keydown' && ev.key === dataCopy.key &&
                ev.ctrlKey === dataCopy.ctrlKey &&
                ev.altKey === dataCopy.altKey && dataCopy.shiftKey === ev.shiftKey);
            if (binding) {
                try {
                    if (binding.module === 'tracker') {
                        this.tracker[binding.action](this.view.score, dataCopy);
                    }
                    else {
                        this.keyCommands[binding.action](dataCopy);
                    }
                }
                catch (e) {
                    if (typeof (e) === 'string') {
                        console.error(e);
                    }
                    this.exhandler.exceptionHandler(e);
                }
            }
        });
    }
    mouseMove(ev) {
        this.view.tracker.intersectingArtifact(svgHelpers_1.SvgHelpers.smoBox({
            x: ev.clientX,
            y: ev.clientY
        }));
    }
    mouseClick(ev) {
        const dataCopy = tracker_1.SuiTracker.serializeEvent(ev);
        this.view.renderer.updatePromise().then(() => {
            this.view.tracker.selectSuggestion(this.view.score, dataCopy);
            var modifier = this.view.tracker.getSelectedModifier();
            if (modifier) {
                this.createModifierDialog(modifier);
            }
        });
    }
    bindEvents() {
        const self = this;
        const tracker = this.view.tracker;
        $('body').off('forceScrollEvent').on('forceScrollEvent', function () {
            self.handleScrollEvent();
        });
        $('body').off('forceResizeEvent').on('forceResizeEvent', function () {
            self.resizeEvent();
        });
        this.helpControls();
    }
}
exports.SuiEventHandler = SuiEventHandler;
SuiEventHandler.reentry = false;


/***/ }),

/***/ "./src/application/exports.ts":
/*!************************************!*\
  !*** ./src/application/exports.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Smo = void 0;
// Smoosic relies on dynamic creation of almost everything.  This class exports all the symbols
// that need to be created via reflection.
// ui application components
const application_1 = __webpack_require__(/*! ./application */ "./src/application/application.ts");
const eventHandler_1 = __webpack_require__(/*! ./eventHandler */ "./src/application/eventHandler.ts");
const exceptions_1 = __webpack_require__(/*! ../ui/exceptions */ "./src/ui/exceptions.ts");
const qwerty_1 = __webpack_require__(/*! ../ui/qwerty */ "./src/ui/qwerty.ts");
const piano_1 = __webpack_require__(/*! ../render/sui/piano */ "./src/render/sui/piano.ts");
const dom_1 = __webpack_require__(/*! ./dom */ "./src/application/dom.ts");
const help_1 = __webpack_require__(/*! ../ui/help */ "./src/ui/help.ts");
const articulation_1 = __webpack_require__(/*! ../ui/buttons/articulation */ "./src/ui/buttons/articulation.ts");
const beam_1 = __webpack_require__(/*! ../ui/buttons/beam */ "./src/ui/buttons/beam.ts");
const chord_1 = __webpack_require__(/*! ../ui/buttons/chord */ "./src/ui/buttons/chord.ts");
const collapsable_1 = __webpack_require__(/*! ../ui/buttons/collapsable */ "./src/ui/buttons/collapsable.ts");
const display_1 = __webpack_require__(/*! ../ui/buttons/display */ "./src/ui/buttons/display.ts");
const duration_1 = __webpack_require__(/*! ../ui/buttons/duration */ "./src/ui/buttons/duration.ts");
const measure_1 = __webpack_require__(/*! ../ui/buttons/measure */ "./src/ui/buttons/measure.ts");
const microtone_1 = __webpack_require__(/*! ../ui/buttons/microtone */ "./src/ui/buttons/microtone.ts");
const navigation_1 = __webpack_require__(/*! ../ui/buttons/navigation */ "./src/ui/buttons/navigation.ts");
const note_1 = __webpack_require__(/*! ../ui/buttons/note */ "./src/ui/buttons/note.ts");
const player_1 = __webpack_require__(/*! ../ui/buttons/player */ "./src/ui/buttons/player.ts");
const stave_1 = __webpack_require__(/*! ../ui/buttons/stave */ "./src/ui/buttons/stave.ts");
const text_1 = __webpack_require__(/*! ../ui/buttons/text */ "./src/ui/buttons/text.ts");
const voice_1 = __webpack_require__(/*! ../ui/buttons/voice */ "./src/ui/buttons/voice.ts");
const translationEditor_1 = __webpack_require__(/*! ../ui/i18n/translationEditor */ "./src/ui/i18n/translationEditor.ts");
const configuration_1 = __webpack_require__(/*! ./configuration */ "./src/application/configuration.ts");
const ribbon_1 = __webpack_require__(/*! ../ui/buttons/ribbon */ "./src/ui/buttons/ribbon.ts");
const tabletRibbon_1 = __webpack_require__(/*! ../ui/ribbonLayout/default/tabletRibbon */ "./src/ui/ribbonLayout/default/tabletRibbon.ts");
const common_1 = __webpack_require__(/*! ./common */ "./src/application/common.ts");
// Language strings
const language_en_1 = __webpack_require__(/*! ../ui/i18n/language_en */ "./src/ui/i18n/language_en.js");
// ui dialogs and menus
// Dialogs
const dialog_1 = __webpack_require__(/*! ../ui/dialogs/dialog */ "./src/ui/dialogs/dialog.ts");
const factory_1 = __webpack_require__(/*! ../ui/dialogs/factory */ "./src/ui/dialogs/factory.ts");
const measureFormat_1 = __webpack_require__(/*! ../ui/dialogs/measureFormat */ "./src/ui/dialogs/measureFormat.ts");
const addMeasure_1 = __webpack_require__(/*! ../ui/dialogs/addMeasure */ "./src/ui/dialogs/addMeasure.ts");
const instrument_1 = __webpack_require__(/*! ../ui/dialogs/instrument */ "./src/ui/dialogs/instrument.ts");
const timeSignature_1 = __webpack_require__(/*! ../ui/dialogs/timeSignature */ "./src/ui/dialogs/timeSignature.ts");
const tempo_1 = __webpack_require__(/*! ../ui/dialogs/tempo */ "./src/ui/dialogs/tempo.ts");
const scoreId_1 = __webpack_require__(/*! ../ui/dialogs/scoreId */ "./src/ui/dialogs/scoreId.ts");
const preferences_1 = __webpack_require__(/*! ../ui/dialogs/preferences */ "./src/ui/dialogs/preferences.ts");
const pageLayout_1 = __webpack_require__(/*! ../ui/dialogs/pageLayout */ "./src/ui/dialogs/pageLayout.ts");
const textBracket_1 = __webpack_require__(/*! ../ui/dialogs/textBracket */ "./src/ui/dialogs/textBracket.ts");
const fonts_1 = __webpack_require__(/*! ../ui/dialogs/fonts */ "./src/ui/dialogs/fonts.ts");
const globalLayout_1 = __webpack_require__(/*! ../ui/dialogs/globalLayout */ "./src/ui/dialogs/globalLayout.ts");
const scoreView_1 = __webpack_require__(/*! ../ui/dialogs/scoreView */ "./src/ui/dialogs/scoreView.ts");
const library_1 = __webpack_require__(/*! ../ui/dialogs/library */ "./src/ui/dialogs/library.ts");
const chordChange_1 = __webpack_require__(/*! ../ui/dialogs/chordChange */ "./src/ui/dialogs/chordChange.ts");
const lyric_1 = __webpack_require__(/*! ../ui/dialogs/lyric */ "./src/ui/dialogs/lyric.ts");
const textBlock_1 = __webpack_require__(/*! ../ui/dialogs/textBlock */ "./src/ui/dialogs/textBlock.ts");
const dynamics_1 = __webpack_require__(/*! ../ui/dialogs/dynamics */ "./src/ui/dialogs/dynamics.ts");
const slur_1 = __webpack_require__(/*! ../ui/dialogs/slur */ "./src/ui/dialogs/slur.ts");
const tie_1 = __webpack_require__(/*! ../ui/dialogs/tie */ "./src/ui/dialogs/tie.ts");
const volta_1 = __webpack_require__(/*! ../ui/dialogs/volta */ "./src/ui/dialogs/volta.ts");
const hairpin_1 = __webpack_require__(/*! ../ui/dialogs/hairpin */ "./src/ui/dialogs/hairpin.ts");
const staffGroup_1 = __webpack_require__(/*! ../ui/dialogs/staffGroup */ "./src/ui/dialogs/staffGroup.ts");
const partInfo_1 = __webpack_require__(/*! ../ui/dialogs/partInfo */ "./src/ui/dialogs/partInfo.ts");
const fileDialogs_1 = __webpack_require__(/*! ../ui/dialogs/fileDialogs */ "./src/ui/dialogs/fileDialogs.ts");
// Dialog components
const textInput_1 = __webpack_require__(/*! ../ui/dialogs/components/textInput */ "./src/ui/dialogs/components/textInput.ts");
const dropdown_1 = __webpack_require__(/*! ../ui/dialogs/components/dropdown */ "./src/ui/dialogs/components/dropdown.ts");
const button_1 = __webpack_require__(/*! ../ui/dialogs/components/button */ "./src/ui/dialogs/components/button.ts");
const toggle_1 = __webpack_require__(/*! ../ui/dialogs/components/toggle */ "./src/ui/dialogs/components/toggle.ts");
const fileDownload_1 = __webpack_require__(/*! ../ui/dialogs/components/fileDownload */ "./src/ui/dialogs/components/fileDownload.ts");
const rocker_1 = __webpack_require__(/*! ../ui/dialogs/components/rocker */ "./src/ui/dialogs/components/rocker.ts");
const fontComponent_1 = __webpack_require__(/*! ../ui/dialogs/components/fontComponent */ "./src/ui/dialogs/components/fontComponent.ts");
const textInPlace_1 = __webpack_require__(/*! ../ui/dialogs/components/textInPlace */ "./src/ui/dialogs/components/textInPlace.ts");
const tree_1 = __webpack_require__(/*! ../ui/dialogs/components/tree */ "./src/ui/dialogs/components/tree.ts");
const noteText_1 = __webpack_require__(/*! ../ui/dialogs/components/noteText */ "./src/ui/dialogs/components/noteText.ts");
const dragText_1 = __webpack_require__(/*! ../ui/dialogs/components/dragText */ "./src/ui/dialogs/components/dragText.ts");
const textInPlace_2 = __webpack_require__(/*! ../ui/dialogs/components/textInPlace */ "./src/ui/dialogs/components/textInPlace.ts");
const checkdrop_1 = __webpack_require__(/*! ../ui/dialogs/components/checkdrop */ "./src/ui/dialogs/components/checkdrop.ts");
const tie_2 = __webpack_require__(/*! ../ui/dialogs/components/tie */ "./src/ui/dialogs/components/tie.ts");
const staffComponents_1 = __webpack_require__(/*! ../ui/dialogs/components/staffComponents */ "./src/ui/dialogs/components/staffComponents.ts");
const textCheck_1 = __webpack_require__(/*! ../ui/dialogs/components/textCheck */ "./src/ui/dialogs/components/textCheck.ts");
// menus
const manager_1 = __webpack_require__(/*! ../ui/menus/manager */ "./src/ui/menus/manager.ts");
const menu_1 = __webpack_require__(/*! ../ui/menus/menu */ "./src/ui/menus/menu.ts");
const score_1 = __webpack_require__(/*! ../ui/menus/score */ "./src/ui/menus/score.ts");
const parts_1 = __webpack_require__(/*! ../ui/menus/parts */ "./src/ui/menus/parts.ts");
const partSelection_1 = __webpack_require__(/*! ../ui/menus/partSelection */ "./src/ui/menus/partSelection.ts");
const dynamics_2 = __webpack_require__(/*! ../ui/menus/dynamics */ "./src/ui/menus/dynamics.ts");
const timeSignature_2 = __webpack_require__(/*! ../ui/menus/timeSignature */ "./src/ui/menus/timeSignature.ts");
const keySignature_1 = __webpack_require__(/*! ../ui/menus/keySignature */ "./src/ui/menus/keySignature.ts");
const staffModifier_1 = __webpack_require__(/*! ../ui/menus/staffModifier */ "./src/ui/menus/staffModifier.ts");
const file_1 = __webpack_require__(/*! ../ui/menus/file */ "./src/ui/menus/file.ts");
const language_1 = __webpack_require__(/*! ../ui/menus/language */ "./src/ui/menus/language.ts");
const language_2 = __webpack_require__(/*! ../ui/i18n/language */ "./src/ui/i18n/language.ts");
const measure_2 = __webpack_require__(/*! ../ui/menus/measure */ "./src/ui/menus/measure.ts");
const note_2 = __webpack_require__(/*! ../ui/menus/note */ "./src/ui/menus/note.ts");
const xhrLoader_1 = __webpack_require__(/*! ../ui/fileio/xhrLoader */ "./src/ui/fileio/xhrLoader.ts");
const promiseHelpers_1 = __webpack_require__(/*! ../common/promiseHelpers */ "./src/common/promiseHelpers.ts");
// render library
const scoreView_2 = __webpack_require__(/*! ../render/sui/scoreView */ "./src/render/sui/scoreView.ts");
const scoreViewOperations_1 = __webpack_require__(/*! ../render/sui/scoreViewOperations */ "./src/render/sui/scoreViewOperations.ts");
const scoreRender_1 = __webpack_require__(/*! ../render/sui/scoreRender */ "./src/render/sui/scoreRender.ts");
const layoutDebug_1 = __webpack_require__(/*! ../render/sui/layoutDebug */ "./src/render/sui/layoutDebug.ts");
const mapper_1 = __webpack_require__(/*! ../render/sui/mapper */ "./src/render/sui/mapper.ts");
const scroller_1 = __webpack_require__(/*! ../render/sui/scroller */ "./src/render/sui/scroller.ts");
const svgHelpers_1 = __webpack_require__(/*! ../render/sui/svgHelpers */ "./src/render/sui/svgHelpers.ts");
// audio library
const player_2 = __webpack_require__(/*! ../render/audio/player */ "./src/render/audio/player.ts");
const oscillator_1 = __webpack_require__(/*! ../render/audio/oscillator */ "./src/render/audio/oscillator.ts");
const samples_1 = __webpack_require__(/*! ../render/audio/samples */ "./src/render/audio/samples.ts");
// SMO object model
const score_2 = __webpack_require__(/*! ../smo/data/score */ "./src/smo/data/score.ts");
const undo_1 = __webpack_require__(/*! ../smo/xform/undo */ "./src/smo/xform/undo.ts");
const note_3 = __webpack_require__(/*! ../smo/data/note */ "./src/smo/data/note.ts");
const tickDuration_1 = __webpack_require__(/*! ../smo/xform/tickDuration */ "./src/smo/xform/tickDuration.ts");
const file_load_1 = __webpack_require__(/*! ../../tests/file-load */ "./tests/file-load.ts");
const staffModifiers_1 = __webpack_require__(/*! ../smo/data/staffModifiers */ "./src/smo/data/staffModifiers.ts");
const measure_3 = __webpack_require__(/*! ../smo/data/measure */ "./src/smo/data/measure.ts");
const music_1 = __webpack_require__(/*! ../smo/data/music */ "./src/smo/data/music.ts");
const music_2 = __webpack_require__(/*! ../smo/data/music */ "./src/smo/data/music.ts");
const selections_1 = __webpack_require__(/*! ../smo/xform/selections */ "./src/smo/xform/selections.ts");
const noteModifiers_1 = __webpack_require__(/*! ../smo/data/noteModifiers */ "./src/smo/data/noteModifiers.ts");
const systemStaff_1 = __webpack_require__(/*! ../smo/data/systemStaff */ "./src/smo/data/systemStaff.ts");
const scoreModifiers_1 = __webpack_require__(/*! ../smo/data/scoreModifiers */ "./src/smo/data/scoreModifiers.ts");
const scoreText_1 = __webpack_require__(/*! ../smo/data/scoreText */ "./src/smo/data/scoreText.ts");
const operations_1 = __webpack_require__(/*! ../smo/xform/operations */ "./src/smo/xform/operations.ts");
const measureModifiers_1 = __webpack_require__(/*! ../smo/data/measureModifiers */ "./src/smo/data/measureModifiers.ts");
const smoToXml_1 = __webpack_require__(/*! ../smo/mxml/smoToXml */ "./src/smo/mxml/smoToXml.ts");
const midiToSmo_1 = __webpack_require__(/*! ../smo/midi/midiToSmo */ "./src/smo/midi/midiToSmo.ts");
const smoToMidi_1 = __webpack_require__(/*! ../smo/midi/smoToMidi */ "./src/smo/midi/smoToMidi.ts");
const xmlToSmo_1 = __webpack_require__(/*! ../smo/mxml/xmlToSmo */ "./src/smo/mxml/xmlToSmo.ts");
const toVex_1 = __webpack_require__(/*! ../smo/xform/toVex */ "./src/smo/xform/toVex.ts");
// utilities
const htmlHelpers_1 = __webpack_require__(/*! ../common/htmlHelpers */ "./src/common/htmlHelpers.ts");
const getClass = (jsonString) => {
    return eval('Smo.' + jsonString);
};
exports.Smo = {
    // Application-level classes
    SmoConfiguration: configuration_1.SmoConfiguration,
    SuiApplication: application_1.SuiApplication,
    SuiDom: dom_1.SuiDom, SuiEventHandler: eventHandler_1.SuiEventHandler, SuiExceptionHandler: exceptions_1.SuiExceptionHandler,
    Qwerty: qwerty_1.Qwerty, SuiHelp: help_1.SuiHelp, SmoTranslationEditor: translationEditor_1.SmoTranslationEditor, SimpleEventHandler: common_1.SimpleEventHandler, ModalEventHandler: common_1.ModalEventHandler,
    // Ribbon buttons
    simpleRibbonLayout: tabletRibbon_1.simpleRibbonLayout,
    RibbonButtons: ribbon_1.RibbonButtons, NoteButtons: note_1.NoteButtons, TextButtons: text_1.TextButtons, ChordButtons: chord_1.ChordButtons, MicrotoneButtons: microtone_1.MicrotoneButtons,
    StaveButtons: stave_1.StaveButtons, BeamButtons: beam_1.BeamButtons, MeasureButtons: measure_1.MeasureButtons, DurationButtons: duration_1.DurationButtons,
    VoiceButtons: voice_1.VoiceButtons, PlayerButtons: player_1.PlayerButtons, ArticulationButtons: articulation_1.ArticulationButtons, NavigationButtons: navigation_1.NavigationButtons,
    DisplaySettings: display_1.DisplaySettings, ExtendedCollapseParent: collapsable_1.ExtendedCollapseParent, CollapseRibbonControl: collapsable_1.CollapseRibbonControl,
    // Menus
    SuiMenuManager: manager_1.SuiMenuManager, SuiMenuBase: menu_1.SuiMenuBase, SuiScoreMenu: score_1.SuiScoreMenu, SuiFileMenu: file_1.SuiFileMenu,
    SuiDynamicsMenu: dynamics_2.SuiDynamicsMenu, SuiTimeSignatureMenu: timeSignature_2.SuiTimeSignatureMenu, SuiKeySignatureMenu: keySignature_1.SuiKeySignatureMenu, SuiStaffModifierMenu: staffModifier_1.SuiStaffModifierMenu,
    SuiLanguageMenu: language_1.SuiLanguageMenu, SuiMeasureMenu: measure_2.SuiMeasureMenu, SuiNoteMenu: note_2.SuiNoteMenu, SmoLanguage: language_2.SmoLanguage, SmoTranslator: language_2.SmoTranslator, SuiPartMenu: parts_1.SuiPartMenu,
    SuiPartSelectionMenu: partSelection_1.SuiPartSelectionMenu,
    // Dialogs
    SuiTempoDialog: tempo_1.SuiTempoDialog, SuiInstrumentDialog: instrument_1.SuiInstrumentDialog, SuiModifierDialogFactory: factory_1.SuiModifierDialogFactory, SuiLibraryDialog: library_1.SuiLibraryDialog,
    SuiTextBracketDialog: textBracket_1.SuiTextBracketDialog,
    SuiScoreViewDialog: scoreView_1.SuiScoreViewDialog, SuiGlobalLayoutDialog: globalLayout_1.SuiGlobalLayoutDialog, SuiScoreIdentificationDialog: scoreId_1.SuiScoreIdentificationDialog,
    SuiScoreFontDialog: fonts_1.SuiScoreFontDialog, SuiPageLayoutDialog: pageLayout_1.SuiPageLayoutDialog, SuiMeasureDialog: measureFormat_1.SuiMeasureDialog, SuiInsertMeasures: addMeasure_1.SuiInsertMeasures,
    SuiTimeSignatureDialog: timeSignature_1.SuiTimeSignatureDialog, SuiTextBlockDialog: textBlock_1.SuiTextBlockDialog, SuiLyricDialog: lyric_1.SuiLyricDialog, SuiChordChangeDialog: chordChange_1.SuiChordChangeDialog,
    SuiSlurAttributesDialog: slur_1.SuiSlurAttributesDialog, SuiTieAttributesDialog: tie_1.SuiTieAttributesDialog, SuiVoltaAttributeDialog: volta_1.SuiVoltaAttributeDialog,
    SuiHairpinAttributesDialog: hairpin_1.SuiHairpinAttributesDialog, SuiStaffGroupDialog: staffGroup_1.SuiStaffGroupDialog, helpModal: textBlock_1.helpModal,
    SuiLoadFileDialog: fileDialogs_1.SuiLoadFileDialog, SuiLoadMxmlDialog: fileDialogs_1.SuiLoadMxmlDialog, SuiScorePreferencesDialog: preferences_1.SuiScorePreferencesDialog,
    SuiPartInfoDialog: partInfo_1.SuiPartInfoDialog,
    /* SuiLoadActionsDialog, SuiSaveActionsDialog, */
    SuiPrintFileDialog: fileDialogs_1.SuiPrintFileDialog, SuiSaveFileDialog: fileDialogs_1.SuiSaveFileDialog, SuiSaveXmlDialog: fileDialogs_1.SuiSaveXmlDialog,
    SuiSaveMidiDialog: fileDialogs_1.SuiSaveMidiDialog, SuiDialogBase: dialog_1.SuiDialogBase,
    // Dialog components
    SuiTreeComponent: tree_1.SuiTreeComponent,
    SuiDropdownComponent: dropdown_1.SuiDropdownComponent,
    SuiRockerComponent: rocker_1.SuiRockerComponent, SuiFileDownloadComponent: fileDownload_1.SuiFileDownloadComponent,
    SuiToggleComponent: toggle_1.SuiToggleComponent, SuiButtonComponent: button_1.SuiButtonComponent, SuiDropdownComposite: dropdown_1.SuiDropdownComposite,
    SuiToggleComposite: toggle_1.SuiToggleComposite, SuiButtonComposite: button_1.SuiButtonComposite, SuiRockerComposite: rocker_1.SuiRockerComposite, SuiTextInputComposite: textInput_1.SuiTextInputComposite,
    SuiFontComponent: fontComponent_1.SuiFontComponent, SuiTextInPlace: textInPlace_2.SuiTextInPlace, SuiLyricComponent: noteText_1.SuiLyricComponent, SuiChordComponent: noteText_1.SuiChordComponent, SuiDragText: dragText_1.SuiDragText,
    SuiNoteTextComponent: noteText_1.SuiNoteTextComponent, SuiTextBlockComponent: textInPlace_1.SuiTextBlockComponent, SuiTextInputComponent: textInput_1.SuiTextInputComponent,
    SuiDynamicModifierDialog: dynamics_1.SuiDynamicModifierDialog, CheckboxDropdownComponent: checkdrop_1.CheckboxDropdownComponent, TieMappingComponent: tie_2.TieMappingComponent, StaffAddRemoveComponent: staffComponents_1.StaffAddRemoveComponent,
    StaffCheckComponent: staffComponents_1.StaffCheckComponent, TextCheckComponent: textCheck_1.TextCheckComponent,
    SuiXhrLoader: xhrLoader_1.SuiXhrLoader, PromiseHelpers: promiseHelpers_1.PromiseHelpers,
    // Rendering components
    SuiPiano: piano_1.SuiPiano, layoutDebug: layoutDebug_1.layoutDebug, SuiScoreView: scoreView_2.SuiScoreView, SuiScroller: scroller_1.SuiScroller, SvgHelpers: svgHelpers_1.SvgHelpers, SuiMapper: mapper_1.SuiMapper, SuiScoreRender: scoreRender_1.SuiScoreRender,
    SuiScoreViewOperations: scoreViewOperations_1.SuiScoreViewOperations,
    // Audio components
    SuiAudioPlayer: player_2.SuiAudioPlayer, SuiOscillator: oscillator_1.SuiOscillator, SuiSampleMedia: samples_1.SuiSampleMedia, SuiSampler: oscillator_1.SuiSampler, SuiReverb: oscillator_1.SuiReverb,
    // Smo Music Objects
    SmoScore: score_2.SmoScore,
    SmoScorePreferences: score_2.SmoScorePreferences,
    engravingFontTypes: score_2.engravingFontTypes, isEngravingFont: score_2.isEngravingFont,
    XmlToSmo: xmlToSmo_1.XmlToSmo,
    SmoToXml: smoToXml_1.SmoToXml,
    MidiToSmo: midiToSmo_1.MidiToSmo,
    SmoToMidi: smoToMidi_1.SmoToMidi,
    SmoMusic: music_1.SmoMusic,
    SmoAudioPitch: music_2.SmoAudioPitch,
    SmoMeasure: measure_3.SmoMeasure,
    SmoSystemStaff: systemStaff_1.SmoSystemStaff,
    SmoNote: note_3.SmoNote,
    // staff modifier
    SmoStaffHairpin: staffModifiers_1.SmoStaffHairpin, StaffModifierBase: staffModifiers_1.StaffModifierBase,
    SmoStaffTextBracket: staffModifiers_1.SmoStaffTextBracket,
    SmoInstrument: staffModifiers_1.SmoInstrument, SmoSlur: staffModifiers_1.SmoSlur, SmoTie: staffModifiers_1.SmoTie,
    // score modifiers
    SmoSystemGroup: scoreModifiers_1.SmoSystemGroup, SmoAudioPlayerSettings: scoreModifiers_1.SmoAudioPlayerSettings, SmoTextGroup: scoreText_1.SmoTextGroup,
    // measure modifiers
    SmoRehearsalMark: measureModifiers_1.SmoRehearsalMark, SmoMeasureFormat: measureModifiers_1.SmoMeasureFormat, SmoBarline: measureModifiers_1.SmoBarline, SmoRepeatSymbol: measureModifiers_1.SmoRepeatSymbol,
    SmoVolta: measureModifiers_1.SmoVolta, SmoMeasureText: measureModifiers_1.SmoMeasureText, SmoTempoText: measureModifiers_1.SmoTempoText,
    // note modifiers
    SmoOrnament: noteModifiers_1.SmoOrnament,
    SmoArticulation: noteModifiers_1.SmoArticulation, SmoDynamicText: noteModifiers_1.SmoDynamicText, SmoGraceNote: noteModifiers_1.SmoGraceNote, SmoMicrotone: noteModifiers_1.SmoMicrotone, SmoLyric: noteModifiers_1.SmoLyric,
    // Smo Transformers
    SmoSelection: selections_1.SmoSelection, SmoSelector: selections_1.SmoSelector, SmoDuration: tickDuration_1.SmoDuration, UndoBuffer: undo_1.UndoBuffer, SmoToVex: toVex_1.SmoToVex, SmoOperation: operations_1.SmoOperation,
    // new score bootstrap
    // help strings
    cardKeysHtmlEn: language_en_1.cardKeysHtmlEn, cardNotesLetterHtmlEn: language_en_1.cardNotesLetterHtmlEn, cardNotesChromaticHtmlEn: language_en_1.cardNotesChromaticHtmlEn, cardNotesChordsHtmlEn: language_en_1.cardNotesChordsHtmlEn,
    cardNotesRestsHtmlEn: language_en_1.cardNotesRestsHtmlEn, cardDurationNotesHtmlEn: language_en_1.cardDurationNotesHtmlEn, cardDurationTupletsHtmlEn: language_en_1.cardDurationTupletsHtmlEn,
    cardSelectionsNotesHtmlEn: language_en_1.cardSelectionsNotesHtmlEn, cardSelectionsModifiersHtmlEn: language_en_1.cardSelectionsModifiersHtmlEn, cardSelectionsNonSelectableHtmlEn: language_en_1.cardSelectionsNonSelectableHtmlEn, cardSelectionsSlashHtmlEn: language_en_1.cardSelectionsSlashHtmlEn,
    cardBeamsAndStemsDirectionHtmlEn: language_en_1.cardBeamsAndStemsDirectionHtmlEn, cardBeamsAndStemsGroupingHtmlEn: language_en_1.cardBeamsAndStemsGroupingHtmlEn,
    cardMeasuresAddDeleteHtmlEn: language_en_1.cardMeasuresAddDeleteHtmlEn, cardVoicesCreateDeleteHtmlEn: language_en_1.cardVoicesCreateDeleteHtmlEn, cardPartAddDeleteHtmlEn: language_en_1.cardPartAddDeleteHtmlEn,
    getClass,
    createLoadTests: file_load_1.createLoadTests,
    // utilities
    buildDom: htmlHelpers_1.buildDom, addFileLink: htmlHelpers_1.addFileLink, InputTrapper: htmlHelpers_1.InputTrapper, draggable: htmlHelpers_1.draggable, closeDialogPromise: htmlHelpers_1.closeDialogPromise, getDomContainer: htmlHelpers_1.getDomContainer, createTopDomContainer: htmlHelpers_1.createTopDomContainer
};
exports["default"] = exports.Smo;


/***/ }),

/***/ "./src/application/keyCommands.ts":
/*!****************************************!*\
  !*** ./src/application/keyCommands.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SuiKeyCommands = void 0;
// [Smoosic](https://github.com/AaronDavidNewman/Smoosic)
// Copyright (c) Aaron David Newman 2021.
const tempo_1 = __webpack_require__(/*! ../ui/dialogs/tempo */ "./src/ui/dialogs/tempo.ts");
const dialog_1 = __webpack_require__(/*! ../ui/dialogs/dialog */ "./src/ui/dialogs/dialog.ts");
const player_1 = __webpack_require__(/*! ../render/audio/player */ "./src/render/audio/player.ts");
const noteModifiers_1 = __webpack_require__(/*! ../smo/data/noteModifiers */ "./src/smo/data/noteModifiers.ts");
const common_1 = __webpack_require__(/*! ../smo/data/common */ "./src/smo/data/common.ts");
/**
 * KeyCommands object handles key events and converts them into commands, updating the score and
 * display
 * @category SuiApplication
 * */
class SuiKeyCommands {
    constructor(params) {
        this.slashMode = false;
        this.slashMode = false;
        this.view = params.view;
        this.tracker = params.view.tracker;
        this.completeNotifier = params.completeNotifier;
        this.eventSource = params.eventSource;
    }
    tempoDialog() {
        const tempo = this.tracker.selections[0].measure.getTempo();
        (0, dialog_1.createAndDisplayDialog)(tempo_1.SuiTempoDialog, {
            id: 'tempoDialog',
            ctor: 'SuiTempoDialog',
            completeNotifier: this.completeNotifier,
            view: this.view,
            eventSource: this.eventSource,
            tracker: this.tracker,
            startPromise: null,
            modifier: tempo
        });
    }
    get score() {
        return this.view.score;
    }
    undo() {
        this.view.undo();
    }
    copy() {
        this.view.copy();
    }
    paste() {
        this.view.paste();
    }
    toggleBeamGroup() {
        this.view.toggleBeamGroup();
    }
    beamSelections() {
        this.view.beamSelections();
    }
    toggleBeamDirection() {
        this.view.toggleBeamDirection();
    }
    collapseChord() {
        this.view.collapseChord();
    }
    playScore() {
        this.view.playFromSelection();
    }
    stopPlayer() {
        this.view.stopPlayer();
    }
    pausePlayer() {
        player_1.SuiAudioPlayer.pausePlayer();
    }
    intervalAdd(interval, direction) {
        this.view.setInterval(direction * interval);
    }
    interval(keyEvent) {
        // code='Digit3'
        var interval = parseInt(keyEvent.keyCode, 10) - 49; // 48 === '0', 0 indexed
        if (isNaN(interval) || interval < 1 || interval > 7) {
            return;
        }
        this.intervalAdd(interval, keyEvent.shiftKey ? -1 : 1);
    }
    transpose(offset) {
        this.view.transposeSelections(offset);
    }
    transposeDown() {
        this.transpose(-1);
    }
    transposeUp() {
        this.transpose(1);
    }
    upOctave() {
        this.transpose(12);
    }
    downOctave() {
        this.transpose(-12);
    }
    makeRest() {
        this.view.makeRest();
    }
    setPitchCommand(letter) {
        this.view.setPitch(letter);
    }
    setPitch(keyEvent) {
        const letter = keyEvent.key.toLowerCase();
        if ((0, common_1.IsPitchLetter)(letter)) {
            this.setPitchCommand(letter);
        }
    }
    dotDuration() {
        this.view.batchDurationOperation('dotDuration');
    }
    undotDuration() {
        this.view.batchDurationOperation('undotDuration');
    }
    doubleDuration() {
        this.view.batchDurationOperation('doubleDuration');
    }
    halveDuration() {
        this.view.batchDurationOperation('halveDuration');
    }
    addMeasure(keyEvent) {
        this.view.addMeasure(keyEvent.shiftKey);
    }
    deleteNote() {
        this.view.deleteNote();
    }
    toggleCourtesyAccidental() {
        this.view.toggleCourtesyAccidentals();
    }
    toggleEnharmonic() {
        this.view.toggleEnharmonic();
    }
    makeTupletCommand(numNotes) {
        this.view.makeTuplet(numNotes);
    }
    makeTuplet(keyEvent) {
        const numNotes = parseInt(keyEvent.key, 10);
        this.makeTupletCommand(numNotes);
    }
    unmakeTuplet() {
        this.view.unmakeTuplet();
    }
    setNoteHead() {
        this.view.setNoteHead('x2');
    }
    removeGraceNote() {
        this.view.removeGraceNote();
    }
    addGraceNote() {
        this.view.addGraceNote();
    }
    slashGraceNotes() {
        this.view.slashGraceNotes();
    }
    toggleArticulationCommand(articulation, ctor) {
        this.view.toggleArticulation(articulation, ctor);
    }
    addRemoveAccent() {
        this.toggleArticulationCommand(noteModifiers_1.SmoArticulation.articulations.accent, 'SmoArticulation');
    }
    addRemoveTenuto() {
        this.toggleArticulationCommand(noteModifiers_1.SmoArticulation.articulations.tenuto, 'SmoArticulation');
    }
    addRemoveStaccato() {
        this.toggleArticulationCommand(noteModifiers_1.SmoArticulation.articulations.staccato, 'SmoArticulation');
    }
    addRemoveMarcato() {
        this.toggleArticulationCommand(noteModifiers_1.SmoArticulation.articulations.marcato, 'SmoArticulation');
    }
    addRemovePizzicato() {
        this.toggleArticulationCommand(noteModifiers_1.SmoArticulation.articulations.pizzicato, 'SmoArticulation');
    }
}
exports.SuiKeyCommands = SuiKeyCommands;


/***/ }),

/***/ "./src/common/htmlHelpers.ts":
/*!***********************************!*\
  !*** ./src/common/htmlHelpers.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports) => {


// [Smoosic](https://github.com/AaronDavidNewman/Smoosic)
// Copyright (c) Aaron David Newman 2021.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Draggable = exports.draggable = exports.createTopDomContainer = exports.getDomContainer = exports.closeDialogPromise = exports.InputTrapper = exports.addFileLink = exports.focusableElements = exports.buildDom = exports.DomBuilder = void 0;
/**
* returns an object that  lets you build a DOM in a somewhat readable way.
*
* ## Usage
* ``` javascript
* var b = buildDom;
* var r =
*   b('tr').classes('jsSharingMember').data('entitykey', key).data('name', name).data('entitytype', entityType).append(
*     b('td').classes('noSideBorderRight').append(
*    ...
* $(parent).append(r.dom());
* ```
* Don't forget the '.dom()' !  That is the actual jquery element object
* @returns
**/
class DomBuilder {
    constructor(el) {
        this.e = $('<' + el + '/>');
    }
    classes(cl) {
        $(this.e).addClass(cl);
        return this;
    }
    html(value) {
        $(this.e).html(value);
        return this;
    }
    data(name, value) {
        $(this.e).attr('data-' + name, value);
        return this;
    }
    attr(name, value) {
        $(this.e).attr(name, value);
        return this;
    }
    prop(name, value) {
        $(this.e).prop(name, value);
        return this;
    }
    css(name, value) {
        $(this.e).css(name, value);
        return this;
    }
    append(el) {
        $(this.e).append(el.e);
        return this;
    }
    text(tx) {
        $(this.e).append(document.createTextNode(tx));
        return this;
    }
    dom() {
        return this.e;
    }
}
exports.DomBuilder = DomBuilder;
function buildDom(e) {
    return new DomBuilder(e);
}
exports.buildDom = buildDom;
function focusableElements() {
    return ['a', 'input', 'select', 'textarea', 'button', 'li[tabindex]', 'div[tabindex]'];
}
exports.focusableElements = focusableElements;
function addFileLink(filename, txt, parent, mimeType = 'application/octet-stream') {
    var anchor = $('<a></a>');
    var url = URL.createObjectURL(new Blob([txt], { type: mimeType }));
    $(anchor).attr('href', url);
    $(anchor).attr('download', filename);
    $(anchor).text('save');
    $(parent).html('');
    $(parent).append(anchor);
}
exports.addFileLink = addFileLink;
class InputTrapper {
    constructor(selector) {
        this.selector = selector;
        this.modalInputs = [];
        this.disabledInputs = [];
        this.siblingInputs = [];
        this.parent = $(this.selector);
        this.id = $(this.parent).attr('id');
        this.parentId = $(this.parent).parent().attr('id');
        var idstr = Math.round(Math.random() * (999999 - 1) + 1);
        if (!this.id) {
            $(this.parent).attr('id', idstr + '-element');
            this.id = $(this.parent).attr('id');
        }
        if (!this.parentId) {
            $(this.parent).parent().attr('id', idstr + '-parent');
            this.parentId = $(this.parent).parent().attr('id');
        }
    }
    trap() {
        // aria-hide peers of dialog and peers of parent that are not the parent.
        var peers = $(this.parent).parent().children().toArray();
        peers.forEach((node) => {
            var ptag = $(node)[0].tagName;
            if (ptag === 'SCRIPT' || ptag === 'LINK' || ptag === 'STYLE') {
                ;
            }
            else if ($(node).attr('id') === this.parentId ||
                $(node).attr('id') === this.id ||
                $(node).hasClass('helpDialog')) { // help dialog can be shown with modal dialog
                ;
            }
            else {
                var hidden = $(node).attr('aria-hidden');
                if (!hidden || hidden != 'true') {
                    $(node).attr('aria-hidden', 'true');
                    this.siblingInputs.push(node);
                }
            }
        });
        focusableElements().forEach((etype) => {
            var elements = $(etype).toArray();
            elements.forEach((element) => {
                var tagName = $(element)[0].tagName;
                if ($(element).attr('id') === this.id) {
                    ;
                }
                else if ($(element).closest('.helpDialog').length) {
                    ;
                }
                else if ($(element).prop('disabled')) {
                    ;
                }
                else if ($(element).hasClass('hide')) {
                    ;
                }
                else if ($(element).closest(this.selector).length) {
                    // inside
                    this.modalInputs.push(element);
                }
                else if ((tagName === 'A' || tagName === 'DIV' || tagName === 'LI') && $(element).attr('tabIndex') === '-1') {
                    ;
                }
                else {
                    this.disabledInputs.push(element);
                    if (tagName === 'A' || tagName === 'DIV' || tagName === 'LI') {
                        $(element).attr('tabIndex', '-1');
                    }
                    else {
                        $(element).prop('disabled', true);
                    }
                }
            });
        });
    }
    close() {
        this.disabledInputs.forEach(function (element) {
            var tagName = $(element)[0].tagName;
            if (tagName === 'A' || tagName === 'DIV' || tagName === 'LI') {
                $(element).attr('tabIndex', '0');
            }
            else {
                $(element).prop('disabled', false);
            }
        });
        this.siblingInputs.forEach((el) => {
            $(el).removeAttr('aria-hidden');
        });
    }
}
exports.InputTrapper = InputTrapper;
function closeDialogPromise() {
    return new Promise((resolve) => {
        $('body').off('dialogDismiss').on('dialogDismiss', function () {
            resolve();
        });
    });
}
exports.closeDialogPromise = closeDialogPromise;
/**
 * Extract an HTMLElement from a Jquery id, DOM element ID, or HTMLELement.  If
 * an HTMLElement can't be created, return null
 * @param selector
 * @returns HTMLElement
 */
function getDomContainer(selector) {
    if (typeof (selector) === 'string') {
        if (selector[0] === '#') {
            const el = $(selector)[0];
            if (!(el instanceof HTMLElement)) {
                return undefined;
            }
            return el;
        }
        else {
            const el = document.getElementById(selector);
            if (!el) {
                return undefined;
            }
            return el;
        }
    }
    else if (selector instanceof HTMLElement) {
        return selector;
    }
    else {
        return undefined;
    }
}
exports.getDomContainer = getDomContainer;
/**
 * Create a top-level HTML element for modal containers - dialogs etc.
 * from a jquery selector, or just return same if it exists
 * @param selector
 * @returns
 */
function createTopDomContainer(selector, elementType) {
    const container = $(selector);
    if (!elementType) {
        elementType = 'div';
    }
    if (container.length > 0) {
        return container[0];
    }
    else {
        const ndiv = document.createElement(elementType);
        if (typeof (selector) === 'string') {
            const cl = (selector[0] === '.' || selector[0] === '#') ? selector.substring(1) : selector;
            $(ndiv).addClass(cl);
            if (selector[0] === '#') {
                $(ndiv).attr('id', selector.substring(1));
            }
        }
        $('body').append(ndiv);
        return $(ndiv)[0];
    }
}
exports.createTopDomContainer = createTopDomContainer;
/**
 *
 * @param parameters
 * @returns
 */
function draggable(parameters) {
    return new Draggable(parameters);
}
exports.draggable = draggable;
class Draggable {
    constructor(parameters) {
        this.dragging = false;
        this.parent = parameters.parent;
        this.handle = parameters.handle;
        this.animeClass = parameters.animateDiv;
        this.dragParent = parameters.dragParent;
        // TODO: make '.dom-container' a part of the configuration
        this.domOffset = $('.dom-container').offset();
        this.svg = parameters['svg'];
        this.width = $(this.parent).outerWidth();
        this.height = $(this.parent).outerHeight();
        this.lastX = $(this.handle).offset().left - this.domOffset.left;
        this.lastY = $(this.handle).offset().top - this.domOffset.top;
        this.cb = parameters.cb;
        this.moveParent = parameters.moveParent;
        var self = this;
        // $('.itemMenu input[name="itemTitle"]').css('width','60%');
        $(this.handle)
            .off('mousedown').on('mousedown', function (e) {
            self.mousedown(e);
        });
        $(document)
            .on('mousemove', function (e) {
            self.mousemove(e);
        })
            .on('mouseup', function (e) {
            self.mouseup(e);
        });
    }
    _animate(e) {
        this.lastX = e.clientX;
        this.lastY = e.clientY;
        $(this.animeClass).css('left', this.lastX - this.domOffset.left);
        $(this.animeClass).css('top', this.lastY - this.domOffset.top);
        if (this.dragParent) {
            $(this.parent).css('left', this.lastX + 'px');
            $(this.parent).css('top', this.lastY + 'px');
        }
    }
    mousedown(e) {
        if (!this.dragging) {
            $(this.animeClass).removeClass('hide');
            $(this.animeClass).css('width', this.width);
            $(this.animeClass).css('height', this.height);
        }
        this.dragging = true;
        this._animate(e);
    }
    enddrag() {
        this.lastX = Math.max(this.lastX - this.domOffset.left, 0);
        this.lastY = Math.max(this.lastY - this.domOffset.top, 0);
        if (this.moveParent) {
            $(this.parent).css('left', this.lastX + 'px');
            $(this.parent).css('top', this.lastY + 'px');
        }
        $(this.animeClass).addClass('hide');
        this.cb(this.lastX, this.lastY);
    }
    mouseup(e) {
        // stop resizing
        if (this.dragging) {
            this.dragging = false;
            this.lastX = e.clientX;
            this.lastY = e.clientY;
            this.enddrag();
        }
    }
    mousemove(e) {
        // we don't want to do anything if we aren't resizing.
        if (!this.dragging)
            return;
        this._animate(e);
    }
}
exports.Draggable = Draggable;


/***/ }),

/***/ "./src/common/midiWriter.js":
/*!**********************************!*\
  !*** ./src/common/midiWriter.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports._MidiWriter = void 0;
// Credit for Midi functionality goes to:
// https://github.com/grimmdude/MidiWriterJS
const music_1 = __webpack_require__(/*! ../smo/data/music */ "./src/smo/data/music.ts");
var _MidiWriter = function () {
    /**
     * MIDI file format constants.
     * @return {Constants}
     */
    var Constants = {
        VERSION: 1,
        HEADER_CHUNK_TYPE: [0x4d, 0x54, 0x68, 0x64],
        // Mthd
        HEADER_CHUNK_LENGTH: [0x00, 0x00, 0x00, 0x06],
        // Header size for SMF
        HEADER_CHUNK_FORMAT0: [0x00, 0x00],
        // Midi Type 0 id
        HEADER_CHUNK_FORMAT1: [0x00, 0x01],
        // Midi Type 1 id
        HEADER_CHUNK_DIVISION: [0x00, 0x80],
        // Defaults to 128 ticks per beat
        TRACK_CHUNK_TYPE: [0x4d, 0x54, 0x72, 0x6b],
        // MTrk,
        META_EVENT_ID: 0xFF,
        META_TEXT_ID: 0x01,
        META_COPYRIGHT_ID: 0x02,
        META_TRACK_NAME_ID: 0x03,
        META_INSTRUMENT_NAME_ID: 0x04,
        META_LYRIC_ID: 0x05,
        META_MARKER_ID: 0x06,
        META_CUE_POINT: 0x07,
        META_TEMPO_ID: 0x51,
        META_SMTPE_OFFSET: 0x54,
        META_TIME_SIGNATURE_ID: 0x58,
        META_KEY_SIGNATURE_ID: 0x59,
        META_END_OF_TRACK_ID: [0x2F, 0x00],
        CONTROLLER_CHANGE_STATUS: 0xB0,
        // includes channel number (0)
        PROGRAM_CHANGE_STATUS: 0xC0,
        // includes channel number (0)
        PITCH_BEND_STATUS: 0xE0 // includes channel number (0)
    };
    function _typeof(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
            _typeof = function (obj) {
                return typeof obj;
            };
        }
        else {
            _typeof = function (obj) {
                return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
            };
        }
        return _typeof(obj);
    }
    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }
    function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor)
                descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
        }
    }
    function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps)
            _defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
            _defineProperties(Constructor, staticProps);
        return Constructor;
    }
    function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
                value: subClass,
                writable: true,
                configurable: true
            }
        });
        if (superClass)
            _setPrototypeOf(subClass, superClass);
    }
    function _getPrototypeOf(o) {
        _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
            return o.__proto__ || Object.getPrototypeOf(o);
        };
        return _getPrototypeOf(o);
    }
    function _setPrototypeOf(o, p) {
        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
            o.__proto__ = p;
            return o;
        };
        return _setPrototypeOf(o, p);
    }
    function _isNativeReflectConstruct() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
            return false;
        if (Reflect.construct.sham)
            return false;
        if (typeof Proxy === "function")
            return true;
        try {
            Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () { }));
            return true;
        }
        catch (e) {
            return false;
        }
    }
    function _construct(Parent, args, Class) {
        if (_isNativeReflectConstruct()) {
            _construct = Reflect.construct;
        }
        else {
            _construct = function _construct(Parent, args, Class) {
                var a = [null];
                a.push.apply(a, args);
                var Constructor = Function.bind.apply(Parent, a);
                var instance = new Constructor();
                if (Class)
                    _setPrototypeOf(instance, Class.prototype);
                return instance;
            };
        }
        return _construct.apply(null, arguments);
    }
    function _isNativeFunction(fn) {
        return Function.toString.call(fn).indexOf("[native code]") !== -1;
    }
    function _wrapNativeSuper(Class) {
        var _cache = typeof Map === "function" ? new Map() : undefined;
        _wrapNativeSuper = function _wrapNativeSuper(Class) {
            if (Class === null || !_isNativeFunction(Class))
                return Class;
            if (typeof Class !== "function") {
                throw new TypeError("Super expression must either be null or a function");
            }
            if (typeof _cache !== "undefined") {
                if (_cache.has(Class))
                    return _cache.get(Class);
                _cache.set(Class, Wrapper);
            }
            function Wrapper() {
                return _construct(Class, arguments, _getPrototypeOf(this).constructor);
            }
            Wrapper.prototype = Object.create(Class.prototype, {
                constructor: {
                    value: Wrapper,
                    enumerable: false,
                    writable: true,
                    configurable: true
                }
            });
            return _setPrototypeOf(Wrapper, Class);
        };
        return _wrapNativeSuper(Class);
    }
    function _wrapRegExp(re, groups) {
        _wrapRegExp = function (re, groups) {
            return new BabelRegExp(re, undefined, groups);
        };
        var _RegExp = _wrapNativeSuper(RegExp);
        var _super = RegExp.prototype;
        var _groups = new WeakMap();
        function BabelRegExp(re, flags, groups) {
            var _this = _RegExp.call(this, re, flags);
            _groups.set(_this, groups || _groups.get(re));
            return _this;
        }
        _inherits(BabelRegExp, _RegExp);
        BabelRegExp.prototype.exec = function (str) {
            var result = _super.exec.call(this, str);
            if (result)
                result.groups = buildGroups(result, this);
            return result;
        };
        BabelRegExp.prototype[Symbol.replace] = function (str, substitution) {
            if (typeof substitution === "string") {
                var groups = _groups.get(this);
                return _super[Symbol.replace].call(this, str, substitution.replace(/\$<([^>]+)>/g, function (_, name) {
                    return "$" + groups[name];
                }));
            }
            else if (typeof substitution === "function") {
                var _this = this;
                return _super[Symbol.replace].call(this, str, function () {
                    var args = [];
                    args.push.apply(args, arguments);
                    if (typeof args[args.length - 1] !== "object") {
                        args.push(buildGroups(args, _this));
                    }
                    return substitution.apply(this, args);
                });
            }
            else {
                return _super[Symbol.replace].call(this, str, substitution);
            }
        };
        function buildGroups(result, re) {
            var g = _groups.get(re);
            return Object.keys(g).reduce(function (groups, name) {
                groups[name] = result[g[name]];
                return groups;
            }, Object.create(null));
        }
        return _wrapRegExp.apply(this, arguments);
    }
    /**
     * Static utility functions used throughout the library.
     */
    var Utils = /*#__PURE__*/ function () {
        function Utils() {
            _classCallCheck(this, Utils);
        }
        _createClass(Utils, null, [{
                key: "version",
                value: 
                /**
                 * Gets MidiWriterJS version number.
                 * @return {string}
                 */
                function version() {
                    return Constants.VERSION;
                }
                /**
                 * Convert a string to an array of bytes
                 * @param {string} string
                 * @return {array}
                 */
            }, {
                key: "stringToBytes",
                value: function stringToBytes(string) {
                    return string.split('').map(function (_char) {
                        return _char.charCodeAt();
                    });
                }
                /**
                 * Checks if argument is a valid number.
                 * @param {*} n - Value to check
                 * @return {boolean}
                 */
            }, {
                key: "isNumeric",
                value: function isNumeric(n) {
                    return !isNaN(parseFloat(n)) && isFinite(n);
                }
                /**
                 * Returns the correct MIDI number for the specified pitch.
                 * Uses Tonal Midi - https://github.com/danigb/tonal/tree/master/packages/midi
                 * @param {(string|number)} pitch - 'C#4' or midi note code
                 * @return {number}
                 */
            }, {
                key: "getPitch",
                value: function getPitch(pitch) {
                    return music_1.SmoMusic.midiPitchToMidiNumber(pitch);
                }
                /**
                 * Translates number of ticks to MIDI timestamp format, returning an array of
                 * hex strings with the time values. Midi has a very particular time to express time,
                 * take a good look at the spec before ever touching this function.
                 * Thanks to https://github.com/sergi/jsmidi
                 *
                 * @param {number} ticks - Number of ticks to be translated
                 * @return {array} - Bytes that form the MIDI time value
                 */
            }, {
                key: "numberToVariableLength",
                value: function numberToVariableLength(ticks) {
                    ticks = Math.round(ticks);
                    var buffer = ticks & 0x7F;
                    while (ticks = ticks >> 7) {
                        buffer <<= 8;
                        buffer |= ticks & 0x7F | 0x80;
                    }
                    var bList = [];
                    while (true) {
                        bList.push(buffer & 0xff);
                        if (buffer & 0x80)
                            buffer >>= 8;
                        else {
                            break;
                        }
                    }
                    return bList;
                }
                /**
                 * Counts number of bytes in string
                 * @param {string} s
                 * @return {array}
                 */
            }, {
                key: "stringByteCount",
                value: function stringByteCount(s) {
                    return encodeURI(s).split(/%..|./).length - 1;
                }
                /**
                 * Get an int from an array of bytes.
                 * @param {array} bytes
                 * @return {number}
                 */
            }, {
                key: "numberFromBytes",
                value: function numberFromBytes(bytes) {
                    var hex = '';
                    var stringResult;
                    bytes.forEach(function (_byte) {
                        stringResult = _byte.toString(16); // ensure string is 2 chars
                        if (stringResult.length == 1)
                            stringResult = "0" + stringResult;
                        hex += stringResult;
                    });
                    return parseInt(hex, 16);
                }
                /**
                 * Takes a number and splits it up into an array of bytes.  Can be padded by passing a number to bytesNeeded
                 * @param {number} number
                 * @param {number} bytesNeeded
                 * @return {array} - Array of bytes
                 */
            }, {
                key: "numberToBytes",
                value: function numberToBytes(number, bytesNeeded) {
                    bytesNeeded = bytesNeeded || 1;
                    var hexString = number.toString(16);
                    if (hexString.length & 1) {
                        // Make sure hex string is even number of chars
                        hexString = '0' + hexString;
                    } // Split hex string into an array of two char elements
                    var hexArray = hexString.match(/.{2}/g); // Now parse them out as integers
                    hexArray = hexArray.map(function (item) {
                        return parseInt(item, 16);
                    }); // Prepend empty bytes if we don't have enough
                    if (hexArray.length < bytesNeeded) {
                        while (bytesNeeded - hexArray.length > 0) {
                            hexArray.unshift(0);
                        }
                    }
                    return hexArray;
                }
                /**
                 * Converts value to array if needed.
                 * @param {string} value
                 * @return {array}
                 */
            }, {
                key: "toArray",
                value: function toArray(value) {
                    if (Array.isArray(value))
                        return value;
                    return [value];
                }
                /**
                 * Converts velocity to value 0-127
                 * @param {number} velocity - Velocity value 1-100
                 * @return {number}
                 */
            }, {
                key: "convertVelocity",
                value: function convertVelocity(velocity) {
                    // Max passed value limited to 100
                    velocity = velocity > 100 ? 100 : velocity;
                    return Math.round(velocity / 100 * 127);
                }
                /**
                 * Gets the total number of ticks of a specified duration.
                 * Note: type=='note' defaults to quarter note, type==='rest' defaults to 0
                 * @param {(string|array)} duration
                 * @return {number}
                 */
            }, {
                key: "getTickDuration",
                value: function getTickDuration(duration) {
                    if (Array.isArray(duration)) {
                        // Recursively execute this method for each item in the array and return the sum of tick durations.
                        return duration.map(function (value) {
                            return Utils.getTickDuration(value);
                        }).reduce(function (a, b) {
                            return a + b;
                        }, 0);
                    }
                    duration = duration.toString();
                    if (duration.toLowerCase().charAt(0) === 't') {
                        // If duration starts with 't' then the number that follows is an explicit tick count
                        return parseInt(duration.substring(1));
                    } // Need to apply duration here.  Quarter note == Constants.HEADER_CHUNK_DIVISION
                    var quarterTicks = Utils.numberFromBytes(Constants.HEADER_CHUNK_DIVISION);
                    var tickDuration = quarterTicks * Utils.getDurationMultiplier(duration);
                    return Utils.getRoundedIfClose(tickDuration);
                }
                /**
                 * Due to rounding errors in JavaScript engines,
                 * it's safe to round when we're very close to the actual tick number
                 *
                 * @static
                 * @param {number} tick
                 * @return {number}
                 */
            }, {
                key: "getRoundedIfClose",
                value: function getRoundedIfClose(tick) {
                    var roundedTick = Math.round(tick);
                    return Math.abs(roundedTick - tick) < 0.000001 ? roundedTick : tick;
                }
                /**
                 * Due to low precision of MIDI,
                 * we need to keep track of rounding errors in deltas.
                 * This function will calculate the rounding error for a given duration.
                 *
                 * @static
                 * @param {number} tick
                 * @return {number}
                 */
            }, {
                key: "getPrecisionLoss",
                value: function getPrecisionLoss(tick) {
                    var roundedTick = Math.round(tick);
                    return roundedTick - tick;
                }
                /**
                 * Gets what to multiple ticks/quarter note by to get the specified duration.
                 * Note: type=='note' defaults to quarter note, type==='rest' defaults to 0
                 * @param {string} duration
                 * @return {number}
                 */
            }, {
                key: "getDurationMultiplier",
                value: function getDurationMultiplier(duration) {
                    // Need to apply duration here.
                    // Quarter note == Constants.HEADER_CHUNK_DIVISION ticks.
                    if (duration === '0')
                        return 0;
                    var match = duration.match(/*#__PURE__*/ _wrapRegExp(/^(d+)?([0-9]+)(?:t([0-9]*))?/, {
                        dotted: 1,
                        base: 2,
                        tuplet: 3
                    }));
                    if (match) {
                        var base = Number(match.groups.base); // 1 or any power of two:
                        var isValidBase = base === 1 || (base & base - 1) === 0;
                        if (isValidBase) {
                            // how much faster or slower is this note compared to a quarter?
                            var ratio = base / 4;
                            var durationInQuarters = 1 / ratio;
                            var _match$groups = match.groups, dotted = _match$groups.dotted, tuplet = _match$groups.tuplet;
                            if (dotted) {
                                var thisManyDots = dotted.length;
                                var divisor = Math.pow(2, thisManyDots);
                                durationInQuarters = durationInQuarters + durationInQuarters * ((divisor - 1) / divisor);
                            }
                            if (typeof tuplet === 'string') {
                                var fitInto = durationInQuarters * 2; // default to triplet:
                                var thisManyNotes = Number(tuplet || '3');
                                durationInQuarters = fitInto / thisManyNotes;
                            }
                            return durationInQuarters;
                        }
                    }
                    throw new Error(duration + ' is not a valid duration.');
                }
            }]);
        return Utils;
    }();
    /**
     * Holds all data for a "note on" MIDI event
     * @param {object} fields {data: []}
     * @return {NoteOnEvent}
     */
    var NoteOnEvent = /*#__PURE__*/ function () {
        function NoteOnEvent(fields) {
            _classCallCheck(this, NoteOnEvent);
            // Set default fields
            fields = Object.assign({
                channel: 1,
                startTick: null,
                velocity: 50,
                wait: 0
            }, fields);
            this.type = 'note-on';
            this.channel = fields.channel;
            this.pitch = fields.pitch;
            this.wait = fields.wait;
            this.velocity = fields.velocity;
            this.startTick = fields.startTick;
            this.midiNumber = Utils.getPitch(this.pitch);
            this.tick = null;
            this.delta = null;
            this.data = fields.data;
        }
        /**
         * Builds int array for this event.
         * @param {Track} track - parent track
         * @return {NoteOnEvent}
         */
        _createClass(NoteOnEvent, [{
                key: "buildData",
                value: function buildData(track, precisionDelta) {
                    this.data = []; // Explicitly defined startTick event
                    if (this.startTick) {
                        this.tick = Utils.getRoundedIfClose(this.startTick); // If this is the first event in the track then use event's starting tick as delta.
                        if (track.tickPointer == 0) {
                            this.delta = this.tick;
                        }
                    }
                    else {
                        this.delta = Utils.getTickDuration(this.wait);
                        this.tick = Utils.getRoundedIfClose(track.tickPointer + this.delta);
                    }
                    this.deltaWithPrecisionCorrection = Utils.getRoundedIfClose(this.delta - precisionDelta);
                    this.data = Utils.numberToVariableLength(this.deltaWithPrecisionCorrection).concat(this.getStatusByte(), this.midiNumber, Utils.convertVelocity(this.velocity));
                    return this;
                }
                /**
                 * Gets the note on status code based on the selected channel. 0x9{0-F}
                 * Note on at channel 0 is 0x90 (144)
                 * 0 = Ch 1
                 * @return {number}
                 */
            }, {
                key: "getStatusByte",
                value: function getStatusByte() {
                    return 144 + this.channel - 1;
                }
            }]);
        return NoteOnEvent;
    }();
    /**
     * Holds all data for a "note off" MIDI event
     * @param {object} fields {data: []}
     * @return {NoteOffEvent}
     */
    var NoteOffEvent = /*#__PURE__*/ function () {
        function NoteOffEvent(fields) {
            _classCallCheck(this, NoteOffEvent);
            // Set default fields
            fields = Object.assign({
                channel: 1,
                velocity: 50,
                tick: null
            }, fields);
            this.type = 'note-off';
            this.channel = fields.channel;
            this.pitch = fields.pitch;
            this.duration = fields.duration;
            this.velocity = fields.velocity;
            this.midiNumber = Utils.getPitch(this.pitch);
            this.tick = fields.tick;
            this.delta = Utils.getTickDuration(this.duration);
            this.data = fields.data;
        }
        /**
         * Builds int array for this event.
         * @param {Track} track - parent track
         * @return {NoteOffEvent}
         */
        _createClass(NoteOffEvent, [{
                key: "buildData",
                value: function buildData(track, precisionDelta) {
                    if (this.tick === null) {
                        this.tick = Utils.getRoundedIfClose(this.delta + track.tickPointer);
                    }
                    this.deltaWithPrecisionCorrection = Utils.getRoundedIfClose(this.delta - precisionDelta);
                    this.data = Utils.numberToVariableLength(this.deltaWithPrecisionCorrection).concat(this.getStatusByte(), this.midiNumber, Utils.convertVelocity(this.velocity));
                    return this;
                }
                /**
                 * Gets the note off status code based on the selected channel. 0x8{0-F}
                 * Note off at channel 0 is 0x80 (128)
                 * 0 = Ch 1
                 * @return {number}
                 */
            }, {
                key: "getStatusByte",
                value: function getStatusByte() {
                    return 128 + this.channel - 1;
                }
            }]);
        return NoteOffEvent;
    }();
    /**
     * Wrapper for noteOnEvent/noteOffEvent objects that builds both events.
     * @param {object} fields - {pitch: '[C4]', duration: '4', wait: '4', velocity: 1-100}
     * @return {NoteEvent}
     */
    var NoteEvent = /*#__PURE__*/ function () {
        function NoteEvent(fields) {
            _classCallCheck(this, NoteEvent);
            // Set default fields
            fields = Object.assign({
                channel: 1,
                repeat: 1,
                sequential: false,
                startTick: null,
                velocity: 50,
                wait: 0
            }, fields);
            this.data = [];
            this.type = 'note';
            this.pitch = Utils.toArray(fields.pitch);
            this.channel = fields.channel;
            this.duration = fields.duration;
            this.grace = fields.grace;
            this.repeat = fields.repeat;
            this.sequential = fields.sequential;
            this.startTick = fields.startTick;
            this.velocity = fields.velocity;
            this.wait = fields.wait;
            this.tickDuration = Utils.getTickDuration(this.duration);
            this.restDuration = Utils.getTickDuration(this.wait);
            this.events = []; // Hold actual NoteOn/NoteOff events
        }
        /**
         * Builds int array for this event.
         * @return {NoteEvent}
         */
        _createClass(NoteEvent, [{
                key: "buildData",
                value: function buildData() {
                    var _this = this;
                    // Reset data array
                    this.data = [];
                    this.tickDuration;
                    this.restDuration; // Apply grace note(s) and subtract ticks (currently 1 tick per grace note) from tickDuration so net value is the same
                    if (this.grace) {
                        var graceDuration = 1;
                        this.grace = Utils.toArray(this.grace);
                        this.grace.forEach(function (pitch) {
                            var noteEvent = new NoteEvent({
                                pitch: _this.grace,
                                duration: 'T' + graceDuration
                            });
                            _this.data = _this.data.concat(noteEvent.data);
                        });
                    } // fields.pitch could be an array of pitches.
                    // If this.sequential === true then it's a sequential string of notes that requires separate NoteOnEvents.
                    if (!this.sequential) {
                        // Handle repeat
                        for (var j = 0; j < this.repeat; j++) {
                            // Note on
                            this.pitch.forEach(function (p, i) {
                                if (i == 0) {
                                    var noteOnNew = new NoteOnEvent({
                                        channel: _this.channel,
                                        wait: _this.wait,
                                        velocity: _this.velocity,
                                        pitch: p,
                                        startTick: _this.startTick
                                    });
                                }
                                else {
                                    // Running status (can ommit the note on status)
                                    //noteOn = new NoteOnEvent({data: [0, Utils.getPitch(p), Utils.convertVelocity(this.velocity)]});
                                    var noteOnNew = new NoteOnEvent({
                                        channel: _this.channel,
                                        wait: 0,
                                        velocity: _this.velocity,
                                        pitch: p,
                                        startTick: _this.startTick
                                    });
                                }
                                _this.events.push(noteOnNew);
                            }); // Note off
                            this.pitch.forEach(function (p, i) {
                                if (i == 0) {
                                    //noteOff = new NoteOffEvent({data: Utils.numberToVariableLength(tickDuration).concat(this.getNoteOffStatus(), Utils.getPitch(p), Utils.convertVelocity(this.velocity))});
                                    var noteOffNew = new NoteOffEvent({
                                        channel: _this.channel,
                                        duration: _this.duration,
                                        velocity: _this.velocity,
                                        pitch: p,
                                        tick: _this.startTick !== null ? Utils.getTickDuration(_this.duration) - _this.startTick : null
                                    });
                                }
                                else {
                                    // Running status (can ommit the note off status)
                                    //noteOff = new NoteOffEvent({data: [0, Utils.getPitch(p), Utils.convertVelocity(this.velocity)]});
                                    var noteOffNew = new NoteOffEvent({
                                        channel: _this.channel,
                                        duration: 0,
                                        velocity: _this.velocity,
                                        pitch: p,
                                        tick: _this.startTick !== null ? Utils.getTickDuration(_this.duration) - _this.startTick : null
                                    });
                                }
                                _this.events.push(noteOffNew);
                            });
                        }
                    }
                    else {
                        // Handle repeat
                        for (var j = 0; j < this.repeat; j++) {
                            this.pitch.forEach(function (p, i) {
                                var noteOnNew = new NoteOnEvent({
                                    channel: _this.channel,
                                    wait: i > 0 ? 0 : _this.wait,
                                    // wait only applies to first note in repetition
                                    velocity: _this.velocity,
                                    pitch: p,
                                    startTick: _this.startTick
                                });
                                var noteOffNew = new NoteOffEvent({
                                    channel: _this.channel,
                                    duration: _this.duration,
                                    velocity: _this.velocity,
                                    pitch: p
                                });
                                _this.events.push(noteOnNew, noteOffNew);
                            });
                        }
                    }
                    return this;
                }
            }]);
        return NoteEvent;
    }();
    /**
     * Holds all data for a "Pitch Bend" MIDI event
     * [ -1.0, 0, 1.0 ] ->  [ 0, 8192, 16383]
     * @param {object} fields { bend : float, channel : int }
     * @return {PitchBendEvent}
     */
    var scale14bits = function scale14bits(zeroOne) {
        if (zeroOne <= 0) {
            return Math.floor(16384 * (zeroOne + 1) / 2);
        }
        return Math.floor(16383 * (zeroOne + 1) / 2);
    };
    var PitchBendEvent = function PitchBendEvent(fields) {
        _classCallCheck(this, PitchBendEvent);
        this.type = 'pitch-bend';
        var bend14 = scale14bits(fields.bend);
        var channel = fields.channel || 0;
        var lsbValue = bend14 & 0x7f;
        var msbValue = bend14 >> 7 & 0x7f;
        this.data = Utils.numberToVariableLength(0x00).concat(Constants.PITCH_BEND_STATUS | channel, lsbValue, msbValue);
    };
    /**
     * Holds all data for a "program change" MIDI event
     * @param {object} fields {instrument: integer}
     * @return {ProgramChangeEvent}
     */
    var ProgramChangeEvent = function ProgramChangeEvent(fields) {
        _classCallCheck(this, ProgramChangeEvent);
        this.type = 'program'; // delta time defaults to 0.
        this.data = Utils.numberToVariableLength(0x00).concat(Constants.PROGRAM_CHANGE_STATUS, fields.instrument);
    };
    /**
     * Holds all data for a "controller change" MIDI event
     * @param {object} fields {controllerNumber: integer, controllerValue: integer}
     * @return {ControllerChangeEvent}
     */
    var ControllerChangeEvent = function ControllerChangeEvent(fields) {
        _classCallCheck(this, ControllerChangeEvent);
        this.type = 'controller'; // delta time defaults to 0.
        this.data = Utils.numberToVariableLength(0x00).concat(Constants.CONTROLLER_CHANGE_STATUS, fields.controllerNumber, fields.controllerValue);
    };
    /**
     * Object representation of a tempo meta event.
     * @param {string} text - Copyright text
     * @return {CopyrightEvent}
     */
    var CopyrightEvent = function CopyrightEvent(text) {
        _classCallCheck(this, CopyrightEvent);
        this.type = 'copyright';
        var textBytes = Utils.stringToBytes(text); // Start with zero time delta
        this.data = Utils.numberToVariableLength(0x00).concat(Constants.META_EVENT_ID, Constants.META_COPYRIGHT_ID, Utils.numberToVariableLength(textBytes.length), // Size
        textBytes // Text
        );
    };
    /**
     * Object representation of a cue point meta event.
     * @param {string} text - Cue point text
     * @return {CuePointEvent}
     */
    var CuePointEvent = function CuePointEvent(text) {
        _classCallCheck(this, CuePointEvent);
        this.type = 'marker';
        var textBytes = Utils.stringToBytes(text); // Start with zero time delta
        this.data = Utils.numberToVariableLength(0x00).concat(Constants.META_EVENT_ID, Constants.META_CUE_POINT, Utils.numberToVariableLength(textBytes.length), // Size
        textBytes // Text
        );
    };
    /**
     * Object representation of a end track meta event.
     * @return {EndTrackEvent}
     */
    var EndTrackEvent = function EndTrackEvent() {
        _classCallCheck(this, EndTrackEvent);
        this.type = 'end-track'; // Start with zero time delta
        this.data = Utils.numberToVariableLength(0x00).concat(Constants.META_EVENT_ID, Constants.META_END_OF_TRACK_ID);
    };
    /**
     * Object representation of an instrument name meta event.
     * @param {number} bpm - Beats per minute
     * @return {InstrumentNameEvent}
     */
    var InstrumentNameEvent = function InstrumentNameEvent(text) {
        _classCallCheck(this, InstrumentNameEvent);
        this.type = 'instrument-name';
        var textBytes = Utils.stringToBytes(text); // Start with zero time delta
        this.data = Utils.numberToVariableLength(0x00).concat(Constants.META_EVENT_ID, Constants.META_INSTRUMENT_NAME_ID, Utils.numberToVariableLength(textBytes.length), // Size
        textBytes // Instrument name
        );
    };
    /**
     * Object representation of a key signature meta event.
     * @return {KeySignatureEvent}
     */
    var KeySignatureEvent = function KeySignatureEvent(sf, mi) {
        _classCallCheck(this, KeySignatureEvent);
        this.type = 'key-signature';
        var mode = mi || 0;
        sf = sf || 0; //	Function called with string notation
        if (typeof mi === 'undefined') {
            var fifths = [['Cb', 'Gb', 'Db', 'Ab', 'Eb', 'Bb', 'F', 'C', 'G', 'D', 'A', 'E', 'B', 'F#', 'C#'], ['ab', 'eb', 'bb', 'f', 'c', 'g', 'd', 'a', 'e', 'b', 'f#', 'c#', 'g#', 'd#', 'a#']];
            var _sflen = sf.length;
            var note = sf || 'C';
            if (sf[0] === sf[0].toLowerCase())
                mode = 1;
            if (_sflen > 1) {
                switch (sf.charAt(_sflen - 1)) {
                    case 'm':
                        mode = 1;
                        note = sf.charAt(0).toLowerCase();
                        note = note.concat(sf.substring(1, _sflen - 1));
                        break;
                    case '-':
                        mode = 1;
                        note = sf.charAt(0).toLowerCase();
                        note = note.concat(sf.substring(1, _sflen - 1));
                        break;
                    case 'M':
                        mode = 0;
                        note = sf.charAt(0).toUpperCase();
                        note = note.concat(sf.substring(1, _sflen - 1));
                        break;
                    case '+':
                        mode = 0;
                        note = sf.charAt(0).toUpperCase();
                        note = note.concat(sf.substring(1, _sflen - 1));
                        break;
                }
            }
            var fifthindex = fifths[mode].indexOf(note);
            sf = fifthindex === -1 ? 0 : fifthindex - 7;
        } // Start with zero time delta
        this.data = Utils.numberToVariableLength(0x00).concat(Constants.META_EVENT_ID, Constants.META_KEY_SIGNATURE_ID, [0x02], // Size
        Utils.numberToBytes(sf, 1), // Number of sharp or flats ( < 0 flat; > 0 sharp)
        Utils.numberToBytes(mode, 1) // Mode: 0 major, 1 minor
        );
    };
    /**
     * Object representation of a lyric meta event.
     * @param {string} text - Lyric text
     * @return {LyricEvent}
     */
    var LyricEvent = function LyricEvent(text) {
        _classCallCheck(this, LyricEvent);
        this.type = 'marker';
        var textBytes = Utils.stringToBytes(text); // Start with zero time delta
        this.data = Utils.numberToVariableLength(0x00).concat(Constants.META_EVENT_ID, Constants.META_LYRIC_ID, Utils.numberToVariableLength(textBytes.length), // Size
        textBytes // Text
        );
    };
    /**
     * Object representation of a marker meta event.
     * @param {string} text - Marker text
     * @return {MarkerEvent}
     */
    var MarkerEvent = function MarkerEvent(text) {
        _classCallCheck(this, MarkerEvent);
        this.type = 'marker';
        var textBytes = Utils.stringToBytes(text); // Start with zero time delta
        this.data = Utils.numberToVariableLength(0x00).concat(Constants.META_EVENT_ID, Constants.META_MARKER_ID, Utils.numberToVariableLength(textBytes.length), // Size
        textBytes // Text
        );
    };
    /**
     * Object representation of a tempo meta event.
     * @param {number} bpm - Beats per minute
     * @return {TempoEvent}
     */
    var TempoEvent = function TempoEvent(bpm) {
        _classCallCheck(this, TempoEvent);
        this.type = 'tempo';
        var tempo = Math.round(60000000 / bpm); // Start with zero time delta
        this.data = Utils.numberToVariableLength(0x00).concat(Constants.META_EVENT_ID, Constants.META_TEMPO_ID, [0x03], // Size
        Utils.numberToBytes(tempo, 3) // Tempo, 3 bytes
        );
    };
    /**
     * Object representation of a tempo meta event.
     * @param {number} bpm - Beats per minute
     * @return {TextEvent}
     */
    var TextEvent = function TextEvent(text) {
        _classCallCheck(this, TextEvent);
        this.type = 'text';
        var textBytes = Utils.stringToBytes(text); // Start with zero time delta
        this.data = Utils.numberToVariableLength(0x00).concat(Constants.META_EVENT_ID, Constants.META_TEXT_ID, Utils.numberToVariableLength(textBytes.length), // Size
        textBytes // Text
        );
    };
    /**
     * Object representation of a time signature meta event.
     * @return {TimeSignatureEvent}
     */
    var TimeSignatureEvent = function TimeSignatureEvent(numerator, denominator, midiclockspertick, notespermidiclock) {
        _classCallCheck(this, TimeSignatureEvent);
        this.type = 'time-signature'; // Start with zero time delta
        this.data = Utils.numberToVariableLength(0x00).concat(Constants.META_EVENT_ID, Constants.META_TIME_SIGNATURE_ID, [0x04], // Size
        Utils.numberToBytes(numerator, 1), // Numerator, 1 bytes
        Utils.numberToBytes(Math.log2(denominator), 1), // Denominator is expressed as pow of 2, 1 bytes
        Utils.numberToBytes(midiclockspertick || 24, 1), // MIDI Clocks per tick, 1 bytes
        Utils.numberToBytes(notespermidiclock || 8, 1) // Number of 1/32 notes per MIDI clocks, 1 bytes
        );
    };
    /**
     * Object representation of a tempo meta event.
     * @param {number} bpm - Beats per minute
     * @return {TrackNameEvent}
     */
    var TrackNameEvent = function TrackNameEvent(text) {
        _classCallCheck(this, TrackNameEvent);
        this.type = 'track-name';
        var textBytes = Utils.stringToBytes(text); // Start with zero time delta
        this.data = Utils.numberToVariableLength(0x00).concat(Constants.META_EVENT_ID, Constants.META_TRACK_NAME_ID, Utils.numberToVariableLength(textBytes.length), // Size
        textBytes // Text
        );
    };
    /**
     * Holds all data for a track.
     * @param {object} fields {type: number, data: array, size: array, events: array}
     * @return {Track}
     */
    var Track = /*#__PURE__*/ function () {
        function Track() {
            _classCallCheck(this, Track);
            this.type = Constants.TRACK_CHUNK_TYPE;
            this.data = [];
            this.size = [];
            this.events = [];
            this.explicitTickEvents = []; // If there are any events with an explicit tick defined then we will create a "sub" track for those
            // and merge them in and the end.
            this.tickPointer = 0; // Each time an event is added this will increase
        }
        /**
         * Adds any event type to the track.
         * Events without a specific startTick property are assumed to be added in order of how they should output.
         * Events with a specific startTick property are set aside for now will be merged in during build process.
         * @param {(NoteEvent|ProgramChangeEvent)} events - Event object or array of Event objects.
         * @param {function} mapFunction - Callback which can be used to apply specific properties to all events.
         * @return {Track}
         */
        _createClass(Track, [{
                key: "addEvent",
                value: function addEvent(events, mapFunction) {
                    var _this = this;
                    Utils.toArray(events).forEach(function (event, i) {
                        if (event instanceof NoteEvent) {
                            // Handle map function if provided
                            if (typeof mapFunction === 'function') {
                                var properties = mapFunction(i, event);
                                if (_typeof(properties) === 'object') {
                                    for (var j in properties) {
                                        switch (j) {
                                            case 'channel':
                                                event.channel = properties[j];
                                                break;
                                            case 'duration':
                                                event.duration = properties[j];
                                                break;
                                            case 'sequential':
                                                event.sequential = properties[j];
                                                break;
                                            case 'velocity':
                                                event.velocity = Utils.convertVelocity(properties[j]);
                                                break;
                                        }
                                    }
                                }
                            } // If this note event has an explicit startTick then we need to set aside for now
                            if (event.startTick !== null) {
                                _this.explicitTickEvents.push(event);
                            }
                            else {
                                // Push each on/off event to track's event stack
                                event.buildData().events.forEach(function (e) {
                                    return _this.events.push(e);
                                });
                            }
                        }
                        else {
                            _this.events.push(event);
                        }
                    });
                    return this;
                }
                /**
                 * Builds int array of all events.
                 * @return {Track}
                 */
            }, {
                key: "buildData",
                value: function buildData() {
                    var _this2 = this;
                    // Remove existing end track event and add one.
                    // This makes sure it's at the very end of the event list.
                    this.removeEventsByType('end-track').addEvent(new EndTrackEvent()); // Reset
                    this.data = [];
                    this.size = [];
                    this.tickPointer = 0;
                    var precisionLoss = 0;
                    this.events.forEach(function (event, eventIndex) {
                        // Build event & add to total tick duration
                        if (event instanceof NoteOnEvent || event instanceof NoteOffEvent) {
                            var built = event.buildData(_this2, precisionLoss);
                            precisionLoss = Utils.getPrecisionLoss(event.deltaWithPrecisionCorrection || 0);
                            _this2.data = _this2.data.concat(built.data);
                            _this2.tickPointer = Utils.getRoundedIfClose(event.tick);
                        }
                        else {
                            _this2.data = _this2.data.concat(event.data);
                        }
                    });
                    this.mergeExplicitTickEvents();
                    this.size = Utils.numberToBytes(this.data.length, 4); // 4 bytes long
                    return this;
                }
            }, {
                key: "mergeExplicitTickEvents",
                value: function mergeExplicitTickEvents() {
                    var _this3 = this;
                    if (!this.explicitTickEvents.length)
                        return; // First sort asc list of events by startTick
                    this.explicitTickEvents.sort(function (a, b) {
                        return a.startTick - b.startTick;
                    }); // Now this.explicitTickEvents is in correct order, and so is this.events naturally.
                    // For each explicit tick event, splice it into the main list of events and
                    // adjust the delta on the following events so they still play normally.
                    this.explicitTickEvents.forEach(function (noteEvent) {
                        // Convert NoteEvent to it's respective NoteOn/NoteOff events
                        // Note that as we splice in events the delta for the NoteOff ones will
                        // Need to change based on what comes before them after the splice.
                        noteEvent.buildData().events.forEach(function (e) {
                            return e.buildData(_this3);
                        }); // Merge each event indivually into this track's event list.
                        noteEvent.events.forEach(function (event) {
                            return _this3.mergeSingleEvent(event);
                        });
                    }); // Hacky way to rebuild track with newly spliced events.  Need better solution.
                    this.explicitTickEvents = [];
                    this.buildData();
                }
                /**
                 * Merges another track's events with this track.
                 * @param {Track} track
                 * @return {Track}
                 */
            }, {
                key: "mergeTrack",
                value: function mergeTrack(track) {
                    var _this4 = this;
                    // First build this track to populate each event's tick property
                    this.buildData(); // Then build track to be merged so that tick property is populated on all events & merge each event.
                    track.buildData().events.forEach(function (event) {
                        return _this4.mergeSingleEvent(event);
                    });
                }
                /**
                 * Merges a single event into this track's list of events based on event.tick property.
                 * @param {NoteOnEvent|NoteOffEvent} - event
                 * @return {Track}
                 */
            }, {
                key: "mergeSingleEvent",
                value: function mergeSingleEvent(event) {
                    // Find index of existing event we need to follow with
                    var lastEventIndex = 0;
                    for (var i = 0; i < this.events.length; i++) {
                        if (this.events[i].tick > event.tick)
                            break;
                        lastEventIndex = i;
                    }
                    var splicedEventIndex = lastEventIndex + 1; // Need to adjust the delta of this event to ensure it falls on the correct tick.
                    event.delta = event.tick - this.events[lastEventIndex].tick; // Splice this event at lastEventIndex + 1
                    this.events.splice(splicedEventIndex, 0, event); // Now adjust delta of all following events
                    for (var i = splicedEventIndex + 1; i < this.events.length; i++) {
                        // Since each existing event should have a tick value at this point we just need to
                        // adjust delta to that the event still falls on the correct tick.
                        this.events[i].delta = this.events[i].tick - this.events[i - 1].tick;
                    }
                }
                /**
                 * Removes all events matching specified type.
                 * @param {string} eventType - Event type
                 * @return {Track}
                 */
            }, {
                key: "removeEventsByType",
                value: function removeEventsByType(eventType) {
                    var _this5 = this;
                    this.events.forEach(function (event, index) {
                        if (event.type === eventType) {
                            _this5.events.splice(index, 1);
                        }
                    });
                    return this;
                }
                /**
                 * Sets tempo of the MIDI file.
                 * @param {number} bpm - Tempo in beats per minute.
                 * @return {Track}
                 */
            }, {
                key: "setTempo",
                value: function setTempo(bpm) {
                    return this.addEvent(new TempoEvent(bpm));
                }
                /**
                 * Sets time signature.
                 * @param {number} numerator - Top number of the time signature.
                 * @param {number} denominator - Bottom number of the time signature.
                 * @param {number} midiclockspertick - Defaults to 24.
                 * @param {number} notespermidiclock - Defaults to 8.
                 * @return {Track}
                 */
            }, {
                key: "setTimeSignature",
                value: function setTimeSignature(numerator, denominator, midiclockspertick, notespermidiclock) {
                    return this.addEvent(new TimeSignatureEvent(numerator, denominator, midiclockspertick, notespermidiclock));
                }
                /**
                 * Sets key signature.
                 * @param {*} sf -
                 * @param {*} mi -
                 * @return {Track}
                 */
            }, {
                key: "setKeySignature",
                value: function setKeySignature(sf, mi) {
                    return this.addEvent(new KeySignatureEvent(sf, mi));
                }
                /**
                 * Adds text to MIDI file.
                 * @param {string} text - Text to add.
                 * @return {Track}
                 */
            }, {
                key: "addText",
                value: function addText(text) {
                    return this.addEvent(new TextEvent(text));
                }
                /**
                 * Adds copyright to MIDI file.
                 * @param {string} text - Text of copyright line.
                 * @return {Track}
                 */
            }, {
                key: "addCopyright",
                value: function addCopyright(text) {
                    return this.addEvent(new CopyrightEvent(text));
                }
                /**
                 * Adds Sequence/Track Name.
                 * @param {string} text - Text of track name.
                 * @return {Track}
                 */
            }, {
                key: "addTrackName",
                value: function addTrackName(text) {
                    return this.addEvent(new TrackNameEvent(text));
                }
                /**
                 * Sets instrument name of track.
                 * @param {string} text - Name of instrument.
                 * @return {Track}
                 */
            }, {
                key: "addInstrumentName",
                value: function addInstrumentName(text) {
                    return this.addEvent(new InstrumentNameEvent(text));
                }
                /**
                 * Adds marker to MIDI file.
                 * @param {string} text - Marker text.
                 * @return {Track}
                 */
            }, {
                key: "addMarker",
                value: function addMarker(text) {
                    return this.addEvent(new MarkerEvent(text));
                }
                /**
                 * Adds cue point to MIDI file.
                 * @param {string} text - Text of cue point.
                 * @return {Track}
                 */
            }, {
                key: "addCuePoint",
                value: function addCuePoint(text) {
                    return this.addEvent(new CuePointEvent(text));
                }
                /**
                 * Adds lyric to MIDI file.
                 * @param {string} text - Lyric text to add.
                 * @return {Track}
                 */
            }, {
                key: "addLyric",
                value: function addLyric(text) {
                    return this.addEvent(new LyricEvent(text));
                }
                /**
                 * Channel mode messages
                 * @return {Track}
                 */
            }, {
                key: "polyModeOn",
                value: function polyModeOn() {
                    var event = new NoteOnEvent({
                        data: [0x00, 0xB0, 0x7E, 0x00]
                    });
                    return this.addEvent(event);
                }
                /**
                 * Sets a pitch bend.
                 * @param {float} bend - Bend value ranging [-1,1], zero meaning no bend.
                 * @return {Track}
                 */
            }, {
                key: "setPitchBend",
                value: function setPitchBend(bend) {
                    return this.addEvent(new PitchBendEvent({
                        bend: bend
                    }));
                }
                /**
                 * Adds a controller change event
                 * @param {number} number - Control number.
                 * @param {number} value - Control value.
                 * @return {Track}
                 */
            }, {
                key: "controllerChange",
                value: function controllerChange(number, value) {
                    return this.addEvent(new ControllerChangeEvent({
                        controllerNumber: number,
                        controllerValue: value
                    }));
                }
            }]);
        return Track;
    }();
    var VexFlow = /*#__PURE__*/ function () {
        function VexFlow() {
            _classCallCheck(this, VexFlow);
        }
        _createClass(VexFlow, [{
                key: "trackFromVoice",
                value: 
                /**
                 * Support for converting VexFlow voice into MidiWriterJS track
                 * @return MidiWriter.Track object
                 */
                function trackFromVoice(voice) {
                    var _this = this;
                    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
                        addRenderedAccidentals: false
                    };
                    var track = new Track();
                    var wait = [];
                    voice.tickables.forEach(function (tickable) {
                        if (tickable.noteType === 'n') {
                            track.addEvent(new NoteEvent({
                                pitch: tickable.keys.map(function (pitch, index) {
                                    return _this.convertPitch(pitch, index, tickable, options.addRenderedAccidentals);
                                }),
                                duration: _this.convertDuration(tickable),
                                wait: wait
                            })); // reset wait
                            wait = [];
                        }
                        else if (tickable.noteType === 'r') {
                            // move on to the next tickable and add this to the stack
                            // of the `wait` property for the next note event
                            wait.push(_this.convertDuration(tickable));
                            return;
                        }
                    }); // There may be outstanding rests at the end of the track,
                    // pad with a ghost note (zero duration and velocity), just to capture the wait.
                    if (wait.length > 0) {
                        track.addEvent(new NoteEvent({
                            pitch: '[c4]',
                            duration: '0',
                            wait: wait,
                            velocity: '0'
                        }));
                    }
                    return track;
                }
                /**
                 * Converts VexFlow pitch syntax to MidiWriterJS syntax
                 * @param pitch string
                 * @param index pitch index
                 * @param note struct from Vexflow
                 * @param addRenderedAccidentals adds Vexflow rendered accidentals
                 */
            }, {
                key: "convertPitch",
                value: function convertPitch(pitch, index, note) {
                    var addRenderedAccidentals = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
                    // Splits note name from octave
                    var pitchParts = pitch.split('/'); // Retrieves accidentals from pitch
                    // Removes natural accidentals since they are not accepted in Tonal Midi
                    var accidentals = pitchParts[0].substring(1).replace('n', '');
                    if (addRenderedAccidentals) {
                        var _note$getAccidentals;
                        (_note$getAccidentals = note.getAccidentals()) === null || _note$getAccidentals === void 0 ? void 0 : _note$getAccidentals.forEach(function (accidental) {
                            if (accidental.index === index) {
                                if (accidental.type === 'n') {
                                    accidentals = '';
                                }
                                else {
                                    accidentals += accidental.type;
                                }
                            }
                        });
                    }
                    return pitchParts[0][0] + accidentals + pitchParts[1];
                }
                /**
                 * Converts VexFlow duration syntax to MidiWriterJS syntax
                 * @param note struct from VexFlow
                 */
            }, {
                key: "convertDuration",
                value: function convertDuration(note) {
                    return 'd'.repeat(note.dots) + this.convertBaseDuration(note.duration) + (note.tuplet ? 't' + note.tuplet.num_notes : '');
                }
                /**
                 * Converts VexFlow base duration syntax to MidiWriterJS syntax
                 * @param duration Vexflow duration
                 * @returns MidiWriterJS duration
                 */
            }, {
                key: "convertBaseDuration",
                value: function convertBaseDuration(duration) {
                    switch (duration) {
                        case 'w':
                            return '1';
                        case 'h':
                            return '2';
                        case 'q':
                            return '4';
                        default:
                            return duration;
                    }
                }
            }]);
        return VexFlow;
    }();
    /**
     * Object representation of a header chunk section of a MIDI file.
     * @param {number} numberOfTracks - Number of tracks
     * @return {HeaderChunk}
     */
    var HeaderChunk = function HeaderChunk(numberOfTracks) {
        _classCallCheck(this, HeaderChunk);
        this.type = Constants.HEADER_CHUNK_TYPE;
        var trackType = numberOfTracks > 1 ? Constants.HEADER_CHUNK_FORMAT1 : Constants.HEADER_CHUNK_FORMAT0;
        this.data = trackType.concat(Utils.numberToBytes(numberOfTracks, 2), // two bytes long,
        Constants.HEADER_CHUNK_DIVISION);
        this.size = [0, 0, 0, this.data.length];
    };
    /**
     * Object that puts together tracks and provides methods for file output.
     * @param {array|Track} tracks - A single {Track} object or an array of {Track} objects.
     * @return {Writer}
     */
    var Writer = /*#__PURE__*/ function () {
        function Writer(tracks) {
            var _this = this;
            _classCallCheck(this, Writer);
            // Ensure track is an array
            tracks = Utils.toArray(tracks);
            this.data = [];
            this.data.push(new HeaderChunk(tracks.length)); // For each track add final end of track event and build data
            tracks.forEach(function (track, i) {
                _this.data.push(track.buildData());
            });
        }
        /**
         * Builds the file into a Uint8Array
         * @return {Uint8Array}
         */
        _createClass(Writer, [{
                key: "buildFile",
                value: function buildFile() {
                    var build = []; // Data consists of chunks which consists of data
                    this.data.forEach(function (d) {
                        return build = build.concat(d.type, d.size, d.data);
                    });
                    return new Uint8Array(build);
                }
                /**
                 * Convert file buffer to a base64 string.  Different methods depending on if browser or node.
                 * @return {string}
                 */
            }, {
                key: "base64",
                value: function base64() {
                    if (typeof btoa === 'function')
                        return btoa(String.fromCharCode.apply(null, this.buildFile()));
                    return Buffer.from(this.buildFile()).toString('base64');
                }
                /**
                 * Get the data URI.
                 * @return {string}
                 */
            }, {
                key: "dataUri",
                value: function dataUri() {
                    return 'data:audio/midi;base64,' + this.base64();
                }
                /**
                 * Output to stdout
                 * @return {string}
                 */
            }, {
                key: "stdout",
                value: function stdout() {
                    return process.stdout.write(new Buffer(this.buildFile()));
                }
                /**
                 * Save to MIDI file
                 * @param {string} filename
                 */
            }, /* {
              key: "saveMIDI",
              value: function saveMIDI(filename) {
                var fs = require('fs');
          
                var buffer = new Buffer.from(this.buildFile());
                fs.writeFile(filename + '.mid', buffer, function (err) {
                  if (err) throw err;
                });
              }
            }  */
        ]);
        return Writer;
    }();
    var main = {
        Constants: Constants,
        NoteOnEvent: NoteOnEvent,
        NoteOffEvent: NoteOffEvent,
        NoteEvent: NoteEvent,
        PitchBendEvent: PitchBendEvent,
        ProgramChangeEvent: ProgramChangeEvent,
        Track: Track,
        Utils: Utils,
        VexFlow: VexFlow,
        Writer: Writer
    };
    window.MidiWriter = main;
};
exports._MidiWriter = _MidiWriter;


/***/ }),

/***/ "./src/common/promiseHelpers.ts":
/*!**************************************!*\
  !*** ./src/common/promiseHelpers.ts ***!
  \**************************************/
/***/ (function(__unused_webpack_module, exports) {


var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PromiseHelpers = exports.TEmptyPromise = void 0;
function TEmptyPromise(obj) {
    return new Promise((resolve) => {
        setTimeout(() => {
            resolve(obj);
        }, 1);
    });
}
exports.TEmptyPromise = TEmptyPromise;
class PromiseHelpers {
    // ### makePromise
    // poll on endCondition at a rate of pollTime.  Resolve the promise
    // when endCondition is met, calling preResolveMethod first.   On
    // polls where the end condition is not met, call pollMethod
    // Resolve method and pollMethod are optional
    static makePromise(endCondition, preResolveMethod, pollMethod, pollTime) {
        return new Promise((resolve) => {
            const checkit = () => {
                setTimeout(() => {
                    if (endCondition()) {
                        if (preResolveMethod) {
                            preResolveMethod();
                        }
                        resolve();
                    }
                    else {
                        if (pollMethod) {
                            pollMethod();
                        }
                        checkit();
                    }
                }, pollTime);
            };
            checkit();
        });
    }
    static makePromiseObj(endCondition, preResolveMethod, pollMethod, pollTime) {
        return {
            endCondition,
            preResolveMethod,
            pollMethod,
            pollTime
        };
    }
    // ### promiseChainThen
    // Call a chain of promises in array order, with parameters of makePromise
    static promiseChainThen(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const promiseArray = [];
            params.forEach((param) => {
                promiseArray.push(() => __awaiter(this, void 0, void 0, function* () {
                    return PromiseHelpers.makePromise(param.endCondition, param.preResolveMethod, param.pollMethod, param.pollTime);
                }));
            });
            let result;
            for (const f of promiseArray) {
                result = yield f();
            }
            return result;
        });
    }
    static emptyPromise() {
        return new Promise((resolve) => {
            setTimeout(() => {
                resolve();
            }, 1);
        });
    }
}
exports.PromiseHelpers = PromiseHelpers;


/***/ }),

/***/ "./src/common/serializationHelpers.js":
/*!********************************************!*\
  !*** ./src/common/serializationHelpers.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports) => {


// [Smoosic](https://github.com/AaronDavidNewman/Smoosic)
// Copyright (c) Aaron David Newman 2021.
// ## smoSerialize
// Helper functions that perform serialized merges, general JSON
// types of routines.
// ---
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.smoSerialize = void 0;
Vex.Merge = (dest, src) => {
    if (typeof (src) === 'undefined') {
        return;
    }
    const keys = Object.keys(src);
    keys.forEach((key) => {
        dest[key] = src[key];
    });
};
class smoSerialize {
    static tryParseUnicode(text) {
        let rv = text;
        try {
            eval('rv="' + text + '"');
        }
        catch (ex) {
            console.log('bad unicode');
        }
        return rv;
    }
    // ### filteredMerge
    // Like vexMerge, but only for specific attributes.
    static filteredMerge(attrs, src, dest) {
        attrs.forEach(function (attr) {
            if (typeof (src[attr]) != 'undefined') {
                dest[attr] = src[attr];
            }
        });
    }
    static get localScore() {
        return '_smoosicScore';
    }
    static loadRemoteFile(path) {
        const req = new XMLHttpRequest();
        req.addEventListener('load', () => {
            callback(req.responseText);
        });
        req.open('GET', path);
        req.send();
    }
    // This is the token map we use to reduce the size of
    // serialized data.
    static get tokenMap() {
        var _tm = `{
      "a": "score",
      "b": "layout",
      "c": "leftMargin",
      "d": "rightMargin",
      "e": "topMargin",
      "f": "bottomMargin",
      "g": "pageWidth",
      "h": "pageHeight",
      "i": "orientation",
      "j": "interGap",
      "k": "intraGap",
      "l": "svgScale",
      "m": "zoomScale",
      "n": "zoomMode",
      "o": "pages",
      "p": "pageSize",
      "q": "startIndex",
      "r": "renumberingMap",
      "s": "staves",
      "t": "staffId",
      "u": "staffX",
      "v": "staffY",
      "w": "adjY",
      "x": "staffWidth",
      "y": "staffHeight",
      "z": "keySignatureMap",
      "aa": "instrumentInfo",
      "ba": "instrumentName",
      "ca": "keyOffset",
      "da": "clef",
      "ea": "modifiers",
      "fa": "startSelector",
      "ga": "staff",
      "ha": "measure",
      "ia": "voice",
      "ja": "tick",
      "ka": "pitches",
      "la": "endSelector",
      "ma": "xOffset",
      "na": "cp1y",
      "oa": "cp2y",
      "pa": "attrs",
      "qa": "id",
      "ra": "type",
      "sa": "ctor",
      "ta": "yOffset",
      "ua": "position",
      "va": "measures",
      "wa": "timeSignature",
      "xa": "keySignature",
      "ya": "measureNumber",
      "za": "measureIndex",
      "ab": "systemIndex",
      "bb": "adjX",
      "cb": "tuplets",
      "db": "voices",
      "eb": "notes",
      "fb": "ticks",
      "gb": "numerator",
      "hb": "denominator",
      "ib": "remainder",
      "jb": "letter",
      "kb": "octave",
      "lb": "accidental",
      "mb": "symbol",
      "nb": "bpm",
      "ob": "display",
      "pb": "beatDuration",
      "qb": "beamBeats",
      "rb": "endBeam",
      "sb": "textModifiers",
      "tb": "text",
      "ub": "endChar",
      "vb": "fontInfo",
      "wb": "size",
      "xb": "family",
      "yb": "style",
      "zb": "weight",
      "ac": "classes",
      "bc": "verse",
      "cc": "fill",
      "dc": "scaleX",
      "ec": "scaleY",
      "fc": "translateX",
      "gc": "translateY",
      "hc": "selector",
      "ic": "renderedBox",
      "jc": "x",
      "kc": "y",
      "lc": "width",
      "mc": "height",
      "nc": "logicalBox",
      "oc": "noteType",
      "pc": "cautionary",
      "qc": "articulations",
      "rc": "articulation",
      "sc": "activeVoice",
      "tc": "flagState",
      "uc": "invert",
      "vc": "fontSize",
      "wc": "yOffsetLine",
      "xc": "yOffsetPixels",
      "yc": "scoreText",
      "zc": "backup",
      "ad": "edited",
      "bd": "pagination",
      "cd": "boxModel",
      "dd": "justification",
      "ed": "autoLayout",
      "fd": "ornaments",
      "gd": "offset",
      "hd": "ornament",
      "id": "tempoMode",
      "jd": "tempoText",
      "kd": "barline",
      "ld": "systemBreak",
      "md": "graceNotes",
      "nd": "tones",
      "od": "tuplet",
      "pd": "beam_group",
      "qd": "renderId",
      "rd": "numNotes",
      "sd": "totalTicks",
      "td": "stemTicks",
      "ud": "durationMap",
      "vd": "bracketed",
      "wd": "ratioed",
      "xd": "location",
      "yd": "systemGroups",
      "zd": "leftConnector",
      "ae": "padLeft",
      "be": "customStretch",
      "ce": "engravingFont",
      "de": "customProportion",
      "ee": "columnAttributeMap",
      "fe": "tempo",
      "ge": "textGroups",
      "he": "textBlocks",
      "ie": "backupBlocks",
      "je": "blocks",
      "ke": "_text",
      "le": "parser",
      "me": "fonts",
      "ne": "name",
      "oe": "purpose",
      "pe": "custom",
      "qe": "transposeIndex",
      "re": "noteHead",
      "se": "slash",
      "te": "pointSize",
      "ue": "spacing",
      "ve": "relativePosition",
      "we": "activeText",
      "xe": "attachToSelector",
      "ye": "musicXOffset",
      "ze": "musicYOffset",
      "af": "formattingIterations",
      "bf": "startBar",
      "cf": "endBar",
      "df": "endingId",
      "ef": "autoJustify",
      "ff": "thickness",
      "gf": "number",
      "hf": "preferences",
      "if": "autoPlay",
      "jf": "autoAdvance",
      "kf": "defaultDupleDuration",
      "lf": "defaultTripleDuration",
      "mf": "scoreInfo",
      "nf": "version",
      "of": "title",
      "pf": "subTitle",
      "qf": "composer",
      "rf": "copyright",
      "sf": "localIndex",
      "tf": "hairpinType",
      "uf": "customText",
      "vf": "noteSpacing",
      "wf": "lines",
      "xf": "from",
      "yf": "layoutManager",
      "zf": "pageLayouts",
      "ag": "fillStyle",
      "bg": "hidden",
      "cg": "adjustNoteWidthLyric",
      "dg": "xOffsetStart",
      "eg": "xOffsetEnd",
      "fg": "measureFormats",
      "gg": "format",
      "hg": "pageBreak",
      "ig": "xOffsetLeft",
      "jg": "xOffsetRight",
      "kg": "padAllInSystem",
      "lg": "rotate",
      "mg": "actualBeats",
      "ng": "useSymbol",
      "og": "showPiano",
      "pg": "globalLayout",
      "qg": "measureInstrumentMap",
      "rg": "partInfo",
      "sg": "partName",
      "tg": "partAbbreviation",
      "ug": "stavesAfter",
      "vg": "stavesBefore",
      "wg": "measureFormatting",
      "xg": "preserveTextGroups",
      "yg": "cueInScore",
      "zg": "tie_spacing",
      "ah": "position_end",
      "bh": "transposingScore",
      "ch": "proportionality",
      "dh": "maxMeasureSystem",
      "eh": "cp2x",
      "fh": "restBreak",
      "gh": "expandMultimeasureRests",
      "hh": "midiInstrument",
      "ih": "channel",
      "jh": "program",
      "kh": "volume",
      "lh": "pan",
      "mh": "midiDevice"
      }`;
        return JSON.parse(_tm);
    }
    static get valueTokens() {
        var vm = `{"@sn","SmoNote"}`;
        return JSON.parse(vm);
    }
    static reverseMap(map) {
        const rv = {};
        const keys = Object.keys(map);
        keys.forEach((key) => {
            rv[map[key]] = key;
        });
        return rv;
    }
    static get tokenValues() {
        return smoSerialize.reverseMap(smoSerialize.tokenMap);
    }
    // ## detokenize
    // If we are saving, replace token values with keys, since the keys are smaller.
    // if we are loading, replace the token keys with values so the score can
    // deserialize it
    static detokenize(json, dictionary) {
        const rv = {};
        const smoKey = (key) => {
            return typeof (dictionary[key]) !== 'undefined' ? dictionary[key] : key;
        };
        const _tokenRecurse = (input, output) => {
            if (input === null) {
                return;
            }
            const keys = Object.keys(input);
            keys.forEach((key) => {
                const val = input[key];
                const dkey = smoKey(key);
                if (typeof (val) == 'string' || typeof (val) == 'number' || typeof (val) == 'boolean') {
                    output[dkey] = val;
                    // console.log('240: output[' + dkey + '] = ' + val);
                }
                if (typeof (val) == 'object' && key != 'dictionary') {
                    if (Array.isArray(val)) {
                        output[dkey] = [];
                        // console.log('245: processing array ' + dkey);
                        val.forEach((arobj) => {
                            if (typeof (arobj) === 'string' || typeof (arobj) === 'number' || typeof (arobj) === 'boolean') {
                                output[dkey].push(arobj);
                                // console.log('249: ar element ' + arobj);
                            }
                            else if (arobj && typeof (arobj) === 'object') {
                                const nobj = {};
                                _tokenRecurse(arobj, nobj);
                                output[dkey].push(nobj);
                            }
                        });
                    }
                    else {
                        const nobj = {};
                        // console.log('259: processing child object of ' + dkey);
                        _tokenRecurse(val, nobj);
                        output[dkey] = nobj;
                    }
                }
            });
        };
        _tokenRecurse(json, rv);
        // console.log(JSON.stringify(rv,null,' '));
        return rv;
    }
    static incrementIdentifier(label) {
        const increcurse = (ar, ix) => {
            const n1 = (ar[ix].charCodeAt(0) - 97) + 1;
            if (n1 > 25) {
                ar[ix] = 'a';
                if (ar.length <= ix + 1) {
                    ar.push('a');
                }
                else {
                    increcurse(ar, ix + 1);
                }
            }
            else {
                ar[ix] = String.fromCharCode(97 + n1);
            }
        };
        if (!label) {
            label = 'a';
        }
        const ar = label.split('');
        increcurse(ar, 0);
        label = ar.join('');
        return label;
    }
    // used to generate a tokenization scheme that I will use to make
    // saved files smaller
    static jsonTokens(json) {
        const map = {};
        const valmap = {};
        const startKeys = Object.keys(smoSerialize.tokenMap);
        let keyLabel = startKeys[startKeys.length - 1];
        keyLabel = smoSerialize.incrementIdentifier(keyLabel);
        const exist = smoSerialize.tokenValues;
        const addMap = (key) => {
            if (!exist[key] && !map[key] && key.length > keyLabel.length) {
                map[key] = keyLabel;
                keyLabel = smoSerialize.incrementIdentifier(keyLabel);
            }
        };
        const _tokenRecurse = (obj) => {
            if (!obj) {
                console.warn('failure to parse');
                return;
            }
            const keys = Object.keys(obj);
            keys.forEach((key) => {
                const val = obj[key];
                if (val !== null) {
                    if (typeof (val) === 'string' || typeof (val) === 'number'
                        || typeof (val) === 'boolean') {
                        addMap(key);
                    }
                    if (typeof (val) == 'object') {
                        if (Array.isArray(val)) {
                            addMap(key);
                            val.forEach((arobj) => {
                                if (arobj && typeof (arobj) === 'object') {
                                    _tokenRecurse(arobj);
                                }
                            });
                        }
                        else {
                            addMap(key);
                            _tokenRecurse(val);
                        }
                    }
                }
            });
        };
        _tokenRecurse(json);
        const mkar = Object.keys(map);
        const m2 = {};
        mkar.forEach((mk) => {
            m2[map[mk]] = mk;
        });
        console.log(JSON.stringify(m2, null, ' '));
    }
    // ### serializedMerge
    // serialization-friendly, so merged, copied objects are deep-copied
    static serializedMerge(attrs, src, dest) {
        attrs.forEach(function (attr) {
            if (typeof (src[attr]) !== 'undefined') {
                // copy the number 0
                if (typeof (src[attr]) === 'number' ||
                    typeof (src[attr]) === 'boolean' ||
                    typeof (src[attr]) === 'string') {
                    dest[attr] = src[attr];
                    // copy the empty array
                }
                else if (Array.isArray(src[attr])) {
                    dest[attr] = JSON.parse(JSON.stringify(src[attr]));
                }
                else {
                    // but don't copy empty/null objects
                    if (src[attr]) {
                        if (typeof (src[attr]) == 'object') {
                            dest[attr] = JSON.parse(JSON.stringify(src[attr]));
                        }
                        else {
                            dest[attr] = src[attr];
                        }
                    }
                }
            }
        });
    }
    // ### serializedMergeNonDefault
    // Used to reduce size of serializations.  Create a serialzation of
    // the object, but don't serialize attributes that are already the default
    // since the default will be set when the object is deserialized
    // #### parameters:
    //     defaults - default Array
    //     attrs - array of attributes to save
    //     src - the object to serialize
    //     dest - the json object that is the target.
    static serializedMergeNonDefault(defaults, attrs, src, dest) {
        attrs.forEach(function (attr) {
            if (typeof (src[attr]) != 'undefined') {
                // copy the number 0
                if (typeof (src[attr]) === 'number' ||
                    typeof (src[attr]) === 'boolean' ||
                    typeof (src[attr]) === 'string') {
                    // always persist object type so it can be deserialized
                    if (src[attr] !== defaults[attr] || attr === 'ctor') {
                        dest[attr] = src[attr];
                    }
                    // copy the empty array
                }
                else if (Array.isArray(src[attr])) {
                    const defval = JSON.stringify(defaults[attr]);
                    const srcval = JSON.stringify(src[attr]);
                    if (defval != srcval) {
                        dest[attr] = JSON.parse(srcval);
                    }
                }
                else {
                    // but don't copy empty/null objects
                    if (src[attr]) {
                        if (typeof (src[attr]) == 'object') {
                            const defval = JSON.stringify(defaults[attr]);
                            const srcval = JSON.stringify(src[attr]);
                            if (defval != srcval) {
                                dest[attr] = JSON.parse(srcval);
                            }
                        }
                        else {
                            if (src[attr] != defaults[attr]) {
                                dest[attr] = src[attr];
                            }
                        }
                    }
                }
            }
        });
    }
    static stringifyAttrs(attrs, obj) {
        let rv = '';
        attrs.forEach((attr) => {
            if (obj[attr]) {
                rv += attr + ':' + obj[attr] + ', ';
            }
            else {
                rv += attr + ': null,';
            }
        });
        return rv;
    }
    // ### printXlate
    // print json with string labels to use as a translation file seed.
    static printTranslate(_class) {
        const xxx = Smo.getClass(_class + '.printTranslate');
        if (typeof (xxx) === 'function') {
            xxx();
        }
    }
}
exports.smoSerialize = smoSerialize;


/***/ }),

/***/ "./src/render/audio/musicCursor.ts":
/*!*****************************************!*\
  !*** ./src/render/audio/musicCursor.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.defaultAudioAnimationHandler = exports.defaultClearAudioAnimationHandler = void 0;
const selections_1 = __webpack_require__(/*! ../../smo/xform/selections */ "./src/smo/xform/selections.ts");
const svgHelpers_1 = __webpack_require__(/*! ../sui/svgHelpers */ "./src/render/sui/svgHelpers.ts");
const layoutDebug_1 = __webpack_require__(/*! ../sui/layoutDebug */ "./src/render/sui/layoutDebug.ts");
const defaultClearAudioAnimationHandler = (delay) => {
    if (delay < 1) {
        const ell = document.getElementById('vf-music-cursor');
        if (ell) {
            ell.remove();
        }
    }
    else {
        setTimeout(() => {
            (0, exports.defaultClearAudioAnimationHandler)(0);
        }, delay);
    }
};
exports.defaultClearAudioAnimationHandler = defaultClearAudioAnimationHandler;
/**
  * default implementation of playback animation.
  * @param selector
  * @returns
  */
const defaultAudioAnimationHandler = (view, selector, offsetPct, durationPct) => {
    var _a, _b;
    const score = view.renderer.score;
    if (!score) {
        return;
    }
    const scroller = view.scroller;
    const renderer = view.renderer;
    // Get note from 0th staff if we can
    const measureSel = selections_1.SmoSelection.measureSelection(score, score.staves.length - 1, selector.measure);
    const zmeasureSel = selections_1.SmoSelection.measureSelection(score, 0, selector.measure);
    const measure = measureSel === null || measureSel === void 0 ? void 0 : measureSel.measure;
    if (measure.svg.logicalBox && ((_b = (_a = zmeasureSel === null || zmeasureSel === void 0 ? void 0 : zmeasureSel.measure) === null || _a === void 0 ? void 0 : _a.svg) === null || _b === void 0 ? void 0 : _b.logicalBox)) {
        const context = renderer.pageMap.getRenderer(measure.svg.logicalBox);
        const topBox = svgHelpers_1.SvgHelpers.smoBox(zmeasureSel.measure.svg.logicalBox);
        topBox.y -= context.box.y;
        const botBox = svgHelpers_1.SvgHelpers.smoBox(measure.svg.logicalBox);
        botBox.y -= context.box.y;
        const height = (botBox.y + botBox.height) - topBox.y;
        const measureWidth = botBox.width - measure.svg.adjX;
        const nhWidth = 10 / score.layoutManager.getGlobalLayout().svgScale;
        let width = measureWidth * durationPct - 10 / score.layoutManager.getGlobalLayout().svgScale;
        width = Math.max(nhWidth, width);
        const y = topBox.y;
        let x = topBox.x + measure.svg.adjX + offsetPct * measureWidth;
        const noteBox = score.staves[selector.staff].measures[selector.measure].voices[selector.voice].notes[selector.tick];
        if (noteBox && noteBox.logicalBox) {
            x = noteBox.logicalBox.x;
        }
        const screenBox = svgHelpers_1.SvgHelpers.boxPoints(x, y, width, height);
        const fillParams = {};
        fillParams['fill-opacity'] = '0.5';
        fillParams['fill'] = '#4444ff';
        const ctx = context.getContext();
        (0, exports.defaultClearAudioAnimationHandler)(0);
        ctx.save();
        ctx.openGroup('music-cursor', 'music-cursor');
        ctx.rect(x, screenBox.y, width, screenBox.height, fillParams);
        ctx.closeGroup();
        ctx.restore();
        layoutDebug_1.layoutDebug.updatePlayDebug(selector, measure.svg.logicalBox);
        scroller.scrollVisibleBox(zmeasureSel.measure.svg.logicalBox);
    }
};
exports.defaultAudioAnimationHandler = defaultAudioAnimationHandler;


/***/ }),

/***/ "./src/render/audio/oscillator.ts":
/*!****************************************!*\
  !*** ./src/render/audio/oscillator.ts ***!
  \****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SuiSampler = exports.SuiWavetable = exports.SuiOscillator = exports.SynthWavetable = exports.SuiReverb = void 0;
// [Smoosic](https://github.com/AaronDavidNewman/Smoosic)
// Copyright (c) Aaron David Newman 2021.
const serializationHelpers_1 = __webpack_require__(/*! ../../common/serializationHelpers */ "./src/common/serializationHelpers.js");
const music_1 = __webpack_require__(/*! ../../smo/data/music */ "./src/smo/data/music.ts");
const samples_1 = __webpack_require__(/*! ./samples */ "./src/render/audio/samples.ts");
/**
 * Create audio reverb node.
 * @category SuiAudio
 */
class SuiReverb {
    constructor(context) {
        this.damp = 1.0;
        this.reverse = false;
        this.input = this.output = context.createConvolver();
        this.length = SuiReverb.defaults.length;
        this.decay = SuiReverb.defaults.decay;
        this._context = context;
        this._buildImpulse();
    }
    static get defaults() {
        return { length: 0.2, decay: 2 };
    }
    connect(destination) {
        this.output.connect(destination);
    }
    disconnect() {
        this.output.disconnect();
        this.input.disconnect();
    }
    // credit: https://github.com/nick-thompson
    _buildImpulse() {
        let n = 0;
        let i = 0;
        if (SuiReverb.impulse) {
            this.input.buffer = SuiReverb.impulse;
            return;
        }
        const rate = this._context.sampleRate;
        const length = rate * this.length;
        const decay = this.decay;
        const impulse = this._context.createBuffer(2, length, rate);
        const impulseL = impulse.getChannelData(0);
        const impulseR = impulse.getChannelData(1);
        for (i = 0; i < length; i++) {
            n = this.reverse ? length - i : i;
            impulseL[i] = (Math.random() * 2 - 1) * Math.pow(1 - n / length, decay) * this.damp;
            impulseR[i] = (Math.random() * 2 - 1) * Math.pow(1 - n / length, decay) * this.damp;
        }
        SuiReverb.impulse = impulse;
        this.input.buffer = impulse;
    }
}
exports.SuiReverb = SuiReverb;
exports.SynthWavetable = {
    real: [0,
        0.3, 0.3, 0, 0, 0,
        0.1, 0, 0, 0, 0,
        0.05, 0, 0, 0, 0,
        0.01, 0, 0, 0, 0,
        0.01, 0, 0, 0, 0,
        0, 0, 0, 0, 0,
        0, 0],
    imaginary: [0,
        0, 0.05, 0, 0, 0,
        0, 0.01, 0, 0, 0,
        0, 0, 0, 0, 0,
        0, 0, 0, 0, 0,
        0, 0, 0, 0, 0,
        0, 0, 0, 0, 0,
        0, 0]
};
/**
 * Simple waveform synthesizer thing that plays notes.  Oscillator works in either
 * analog synthisizer or sampler mode.
 * @category SuiAudio
 */
class SuiOscillator {
    constructor(parameters) {
        this.attackEnv = -1;
        this.duration = -1;
        this.decayEnv = -1;
        this.sustainEnv = -1;
        this.releaseEnv = -1;
        this.gain = 1.0;
        this.sustainLevel = 0;
        this.releaseLevel = 0;
        this.frequency = -1;
        this.wavetable = null;
        serializationHelpers_1.smoSerialize.serializedMerge(SuiOscillator.attributes, parameters, this);
        this.reverb = null;
        // this.reverb = null;
        this.attack = this.attackEnv * SuiOscillator.attackTime;
        this.decay = this.decayEnv * SuiOscillator.decayTime;
        this.sustain = this.sustainEnv * this.duration;
        this.release = this.releaseEnv * this.duration;
        this.instrument = parameters.instrument;
        if (parameters.wavetable) {
            this.wavetable = parameters.wavetable;
        }
        this.useReverb = parameters.useReverb;
        // this.frequency = this.frequency / 2;  // Overtones below partial
        this.waveform = parameters.waveform;
        if (!parameters.wavetable && this.waveform === 'custom') {
            this.waveform = 'sine';
        }
    }
    static get defaults() {
        const wavetable = {
            real: [], imaginary: []
        };
        const obj = {
            duration: 1000,
            frequency: 440,
            attackEnv: 0.05,
            decayEnv: 0.4,
            sustainEnv: 0.8,
            releaseEnv: 0.25,
            sustainLevel: 0.5,
            releaseLevel: 0.1,
            waveform: 'custom',
            gain: 0.2,
            wavetable,
            useReverb: false,
            instrument: 'piano'
        };
        return JSON.parse(JSON.stringify(obj));
    }
    static playSelectionNow(selection, score, gain) {
        // In the midst of re-rendering...
        if (!selection.note) {
            return;
        }
        if (selection.note.isRest() || selection.note.isSlash() || selection.note.isHidden()) {
            return;
        }
        const soundInfo = selection.staff.getStaffInstrument(selection.selector.measure);
        const oscInfo = samples_1.SuiSampleMedia.getSmoOscillatorInfo(soundInfo.instrument);
        setTimeout(() => {
            const ar = SuiOscillator.fromNote(selection.measure, selection.note, score, oscInfo[0], gain);
            ar.forEach((osc) => {
                osc.play();
            });
        }, 1);
    }
    static get attackTime() {
        return 25;
    }
    static get decayTime() {
        return 15;
    }
    // ### fromNote
    // Create an areray of oscillators for each pitch in a note
    static fromNote(measure, note, score, soundInfo, gain) {
        let frequency = 0;
        let duration = 0;
        const tempo = measure.getTempo();
        const bpm = tempo.bpm;
        const beats = note.tickCount / 4096;
        duration = (beats / bpm) * 60000;
        // adjust if bpm is over something other than 1/4 note
        duration = duration * (4096 / tempo.beatDuration);
        if (soundInfo.waveform === 'sample') {
            duration = 250;
        }
        const ar = [];
        gain = isNaN(gain) ? 0.2 : gain;
        gain = gain / note.pitches.length;
        if (note.noteType === 'r') {
            gain = 0.001;
        }
        note.pitches.forEach((pitch, pitchIx) => {
            var _a;
            const mtone = (_a = note.getMicrotone(pitchIx)) !== null && _a !== void 0 ? _a : null;
            frequency = music_1.SmoAudioPitch.smoPitchToFrequency(pitch, -1 * measure.transposeIndex, mtone);
            const def = SuiOscillator.defaults;
            def.instrument = soundInfo.instrument;
            def.frequency = frequency;
            def.duration = duration;
            def.gain = gain;
            if (soundInfo.waveform !== 'sample') {
                def.waveform = soundInfo.waveform;
                if (def.waveform === 'custom') {
                    def.wavetable = exports.SynthWavetable;
                }
                const osc = new SuiWavetable(def);
                ar.push(osc);
            }
            else {
                const osc = new SuiSampler(def);
                ar.push(osc);
            }
        });
        return ar;
    }
    static get attributes() {
        return ['duration', 'frequency', 'pitch', 'attackEnv', 'sustainEnv', 'decayEnv',
            'releaseEnv', 'sustainLevel', 'releaseLevel', 'waveform', 'wavetable', 'gain'];
    }
    static resolveAfter(time) {
        return new Promise((resolve) => {
            const timerFunc = () => {
                resolve();
            };
            setTimeout(() => {
                timerFunc();
            }, time);
        });
    }
    _playPromise(duration, gain) {
        const audio = SuiOscillator.audio;
        const promise = new Promise((resolve) => {
            if (this.osc) {
                this.osc.start(0);
            }
            setTimeout(() => {
                resolve();
            }, duration);
            setTimeout(() => {
                if (this.osc) {
                    this.osc.stop(0);
                }
                this.disconnect();
            }, duration + 500);
        });
        return promise;
    }
    static toFloatArray(ar) {
        const rv = new Float32Array(ar.length);
        let i = 0;
        for (i = 0; i < ar.length; ++i) {
            rv[i] = ar[i];
        }
        return rv;
    }
    disconnect() {
        if (this.osc) {
            this.osc.disconnect();
        }
        if (this.gainNode) {
            this.gainNode.disconnect();
        }
        if (this.delayNode) {
            this.delayNode.disconnect();
        }
        if (this.reverb) {
            this.reverb.disconnect();
        }
        SuiOscillator.created -= 1;
    }
    /**
     * Connect the audio sound source to the output, combining other
     * nodes in the mix such as convolver (reverb), delay, and gain.
     * Also set up the envelope
     * @returns - a promise that tis resolved when `duration` time has expired
     */
    createAudioGraph() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.frequency === 0) {
                return SuiSampler.resolveAfter(this.duration);
            }
            const audio = SuiOscillator.audio;
            const attack = this.attack / 1000;
            const decay = this.decay / 1000;
            const sustain = this.sustain / 1000;
            const release = this.release / 1000;
            this.gainNode = audio.createGain();
            const gp1 = this.gain;
            if (this.useReverb) {
                this.reverb = new SuiReverb(SuiOscillator.audio);
            }
            if (this.useReverb && this.reverb) {
                this.delayNode = audio.createDelay(this.reverb.length);
            }
            this.gainNode.gain.exponentialRampToValueAtTime(gp1, audio.currentTime + attack);
            this.gainNode.gain.exponentialRampToValueAtTime(this.sustainLevel * gp1, audio.currentTime + attack + decay);
            this.gainNode.gain.exponentialRampToValueAtTime(this.releaseLevel * gp1, audio.currentTime + attack + decay + sustain);
            this.gainNode.gain.exponentialRampToValueAtTime(0.001, audio.currentTime + attack + decay + sustain + release);
            this.osc = this.createAudioNode();
            // osc.connect(gain1);
            if (this.useReverb && this.reverb && this.osc) {
                this.osc.connect(this.reverb.input);
            }
            this.osc.connect(this.gainNode);
            if (this.delayNode && this.reverb) {
                this.reverb.connect(this.delayNode);
                this.delayNode.connect(audio.destination);
            }
            this.gainNode.connect(audio.destination);
            SuiOscillator.created += 1;
            return this.playPromise(this.duration);
        });
    }
    playPromise(duration) {
        const promise = new Promise((resolve) => {
            if (this.osc) {
                this.osc.start(0);
            }
            setTimeout(() => {
                resolve();
            }, duration);
            setTimeout(() => {
                if (this.osc) {
                    this.osc.stop(0);
                }
                this.disconnect();
            }, Math.round(duration * 1.05));
        });
        return promise;
    }
}
exports.SuiOscillator = SuiOscillator;
SuiOscillator.audio = new AudioContext();
SuiOscillator.created = 0;
SuiOscillator.sampleFiles = ['bb4', 'cn4'];
SuiOscillator.samples = [];
/**
 * An audio output that uses browser audio api OscillatorNode as a sound source
 * @category SuiAudio
 */
class SuiWavetable extends SuiOscillator {
    createAudioNode() {
        const node = SuiOscillator.audio.createOscillator();
        if (this.wavetable && this.wavetable.imaginary.length > 0 && this.wavetable.real.length > 0 && this.waveform === 'custom') {
            const wave = SuiOscillator.audio.createPeriodicWave(SuiOscillator.toFloatArray(this.wavetable.real), SuiOscillator.toFloatArray(this.wavetable.imaginary), { disableNormalization: false });
            node.setPeriodicWave(wave);
        }
        else {
            node.type = this.waveform;
        }
        node.frequency.value = this.frequency;
        return node;
    }
    // play the audio oscillator for the specified duration.  Return a promise that
    // resolves after the duration.  Also dispose of the audio resources after the play is complete.
    play() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.createAudioGraph();
        });
    }
}
exports.SuiWavetable = SuiWavetable;
/**
 * An audio output primitive that uses frequency-adjusted sampled sounds
 */
class SuiSampler extends SuiOscillator {
    constructor(params) {
        super(params);
        if (samples_1.SuiSampleMedia.sampleOscMap[this.instrument]) {
            const sampleInfo = samples_1.SuiSampleMedia.sampleOscMap[this.instrument];
            if (sampleInfo.length) {
                if (sampleInfo[0].sustain === 'sustained') {
                    this.attack = 0.1 * this.duration;
                }
            }
        }
    }
    // Note: samplePromise must be complete before you call this  
    createAudioNode() {
        const node = SuiOscillator.audio.createBufferSource();
        const chooserParams = {
            instrument: this.instrument,
            frequency: this.frequency,
            duration: this.duration,
            gain: this.gain
        };
        const sample = samples_1.SuiSampleMedia.matchedSample(chooserParams);
        if (!sample) {
            return node;
        }
        const cents = 1200 * (Math.log(this.frequency / sample.frequency))
            / Math.log(2);
        node.buffer = sample.sample;
        node.detune.value = cents;
        return node;
    }
    play() {
        return __awaiter(this, void 0, void 0, function* () {
            const self = this;
            return samples_1.SuiSampleMedia.samplePromise(SuiOscillator.audio).then(() => {
                self.createAudioGraph();
            });
        });
    }
}
exports.SuiSampler = SuiSampler;


/***/ }),

/***/ "./src/render/audio/player.ts":
/*!************************************!*\
  !*** ./src/render/audio/player.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SuiAudioPlayer = exports.CuedAudioContexts = void 0;
// [Smoosic](https://github.com/AaronDavidNewman/Smoosic)
// Copyright (c) Aaron David Newman 2021.
const oscillator_1 = __webpack_require__(/*! ./oscillator */ "./src/render/audio/oscillator.ts");
const audioTrack_1 = __webpack_require__(/*! ../../smo/xform/audioTrack */ "./src/smo/xform/audioTrack.ts");
const selections_1 = __webpack_require__(/*! ../../smo/xform/selections */ "./src/smo/xform/selections.ts");
const music_1 = __webpack_require__(/*! ../../smo/data/music */ "./src/smo/data/music.ts");
/**
 * Maintain a list of buffers ready to play, since this is a
 * system resource.
 * @category SuiAudio
 */
class CuedAudioContexts {
    constructor() {
        this.soundHead = null;
        this.soundTail = null;
        this.paramLinkHead = null;
        this.paramLinkTail = null;
        this.soundListLength = 0;
        this.playWaitTimer = 0;
        this.playMeasureIndex = 0; // index of the measure we are playing
        this.cueMeasureIndex = 0; // measure index we are populating
        this.complete = false;
    }
    addToTail(cuedSound) {
        const tail = { sound: cuedSound, next: null };
        if (this.soundTail === null) {
            this.soundTail = tail;
            this.soundHead = tail;
        }
        else {
            this.soundTail.next = { sound: cuedSound, next: null };
            this.soundTail = this.soundTail.next;
        }
        this.soundListLength += cuedSound.oscs.length;
    }
    advanceHead() {
        if (this.soundHead === null) {
            return null;
        }
        const cuedSound = this.soundHead.sound;
        this.soundHead = this.soundHead.next;
        this.soundListLength -= cuedSound.oscs.length;
        return cuedSound;
    }
    get soundCount() {
        return this.soundListLength;
    }
    reset() {
        this.soundHead = null;
        this.soundTail = null;
        this.paramLinkHead = null;
        this.paramLinkTail = null;
        this.soundListLength = 0;
        this.playWaitTimer = 0;
        this.playMeasureIndex = 0;
        this.cueMeasureIndex = 0;
        this.complete = false;
    }
}
exports.CuedAudioContexts = CuedAudioContexts;
/**
 * Play the music, ja!
 * @category SuiAudio
 */
class SuiAudioPlayer {
    constructor(parameters) {
        this.audioDefaults = oscillator_1.SuiOscillator.defaults;
        this.openTies = {};
        this.instanceId = SuiAudioPlayer.incrementInstanceId();
        this.paused = false;
        this.view = parameters.view;
        this.score = parameters.score;
        // Assume tempo is same for all measures
        this.cuedSounds = new CuedAudioContexts();
        this.audioAnimation = parameters.audioAnimation;
    }
    static set playing(val) {
        SuiAudioPlayer._playing = val;
    }
    static get audioBufferSize() {
        return 512;
    }
    static incrementInstanceId() {
        const id = SuiAudioPlayer.instanceId + 1;
        SuiAudioPlayer.instanceId = id;
        return id;
    }
    static get playing() {
        if (typeof (SuiAudioPlayer._playing) === 'undefined') {
            SuiAudioPlayer._playing = false;
        }
        return SuiAudioPlayer._playing;
    }
    static pausePlayer() {
        if (SuiAudioPlayer._playingInstance) {
            const a = SuiAudioPlayer._playingInstance;
            a.paused = true;
            a.audioAnimation.clearAudioAnimationHandler(0);
        }
        SuiAudioPlayer.playing = false;
    }
    getNoteSoundData(measureIndex) {
        const measureNotes = {};
        let measureTicks = this.score.staves[0].measures[measureIndex].getMaxTicksVoice();
        const freqDuplicates = {};
        const voiceCount = {};
        this.score.staves.forEach((staff, staffIx) => {
            const measure = staff.measures[measureIndex];
            measure.voices.forEach((voice, voiceIx) => {
                let curTick = 0;
                const instrument = staff.getStaffInstrument(measure.measureNumber.measureIndex);
                voice.notes.forEach((smoNote, tickIx) => {
                    const frequencies = [];
                    const xpose = -1 * measure.transposeIndex;
                    const selector = selections_1.SmoSelector.default;
                    selector.measure = measureIndex;
                    selector.staff = staffIx;
                    selector.voice = voiceIx;
                    selector.tick = tickIx;
                    let ties = [];
                    const tieIx = '' + staffIx + '-' + measureIndex + '-' + voiceIx;
                    if (smoNote.noteType === 'n' && !smoNote.isHidden()) {
                        ties = staff.getTiesStartingAt(selector);
                        smoNote.pitches.forEach((pitch, pitchIx) => {
                            var _a;
                            const freq = music_1.SmoAudioPitch.smoPitchToFrequency(pitch, xpose, (_a = smoNote.getMicrotone(pitchIx)) !== null && _a !== void 0 ? _a : null);
                            const freqRound = Math.round(freq);
                            if (!freqDuplicates[curTick]) {
                                freqDuplicates[curTick] = {};
                                voiceCount[curTick] = 0;
                            }
                            const freqBeat = freqDuplicates[curTick];
                            if (!freqBeat[freqRound]) {
                                freqBeat[freqRound] = 0;
                            }
                            if (freqBeat[freqRound] < SuiAudioPlayer.duplicatePitchThresh && voiceCount[curTick] < SuiAudioPlayer.voiceThresh) {
                                frequencies.push(freq);
                                freqBeat[freqRound] += 1;
                                voiceCount[curTick] += 1;
                            }
                        });
                        const duration = smoNote.tickCount;
                        const volume = audioTrack_1.SmoAudioScore.volumeFromNote(smoNote, audioTrack_1.SmoAudioScore.dynamicVolumeMap.mf);
                        if (!measureNotes[curTick]) {
                            measureNotes[curTick] = [];
                        }
                        const soundData = {
                            frequencies,
                            volume,
                            offsetPct: curTick / measureTicks,
                            durationPct: duration / measureTicks,
                            noteType: smoNote.noteType,
                            duration,
                            instrument: instrument.instrument,
                            selector
                        };
                        // If this is continuation of tied note, just change duration
                        if (this.openTies[tieIx]) {
                            this.openTies[tieIx].duration += duration;
                            if (ties.length === 0) {
                                this.openTies[tieIx] = null;
                            }
                        }
                        else if (ties.length) {
                            // If start of tied note, record the tie note, the next note in this voice
                            // will adjust duration
                            this.openTies[tieIx] = soundData;
                            measureNotes[curTick].push(soundData);
                        }
                        else {
                            measureNotes[curTick].push(soundData);
                        }
                    }
                    curTick += Math.round(smoNote.tickCount);
                });
            });
        });
        const keys = Object.keys(measureNotes).map((x) => parseInt(x, 10));
        if (keys.length) {
            measureTicks -= keys.reduce((a, b) => a > b ? a : b);
        }
        return { endTicks: measureTicks, measureNotes };
    }
    createCuedSound(measureIndex) {
        let i = 0;
        let j = 0;
        let measureBeat = 0;
        if (!SuiAudioPlayer.playing || this.cuedSounds.paramLinkHead === null) {
            return;
        }
        // TODO base on the selection start.
        const { endTicks, measureNotes } = { endTicks: this.cuedSounds.paramLinkHead.endTicks, measureNotes: this.cuedSounds.paramLinkHead.soundParams };
        this.cuedSounds.paramLinkHead = this.cuedSounds.paramLinkHead.next;
        const maxMeasures = this.score.staves[0].measures.length;
        const smoTemp = this.score.staves[0].measures[measureIndex].getTempo();
        const tempo = smoTemp.bpm * (smoTemp.beatDuration / 4096);
        const keys = [];
        Object.keys(measureNotes).forEach((key) => {
            keys.push(parseInt(key, 10));
        });
        // There is a key for each note in the measure.  The value is the number of ticks before that note is played
        for (j = 0; j < keys.length; ++j) {
            const beatTime = keys[j];
            const soundData = measureNotes[beatTime];
            let durationPct = 0;
            let offsetPct = 0;
            if (soundData.length === 0) {
                console.log('empty sound measure');
                continue;
            }
            soundData.forEach((ss) => {
                if (durationPct === 0) {
                    durationPct = ss.durationPct;
                    offsetPct = ss.offsetPct;
                }
                durationPct = Math.min(durationPct, ss.durationPct);
                offsetPct = Math.min(offsetPct, ss.offsetPct);
            });
            const cuedSound = { oscs: [], waitTime: 0, playMeasureIndex: measureIndex, playTickIndex: j,
                offsetPct, durationPct, selector: soundData[0].selector };
            const timeRatio = 60000 / (tempo * 4096);
            // If there is complete silence here, put a silent beat
            if (beatTime > measureBeat) {
                const params = this.audioDefaults;
                params.frequency = 0;
                params.duration = (beatTime - measureBeat) * timeRatio;
                params.gain = 0;
                params.useReverb = false;
                const silence = { oscs: [], waitTime: params.duration, playMeasureIndex: measureIndex, playTickIndex: j,
                    offsetPct, durationPct, selector: soundData[0].selector };
                silence.oscs.push(new oscillator_1.SuiSampler(params));
                this.cuedSounds.addToTail(silence);
                measureBeat = beatTime;
            }
            this.cuedSounds.addToTail(cuedSound);
            soundData.forEach((sound) => {
                const adjDuration = Math.round(sound.duration * timeRatio) + 150;
                for (i = 0; i < sound.frequencies.length && sound.noteType === 'n'; ++i) {
                    const freq = sound.frequencies[i];
                    const params = this.audioDefaults;
                    params.frequency = freq;
                    params.duration = adjDuration;
                    params.gain = sound.volume;
                    params.instrument = sound.instrument;
                    params.useReverb = this.score.audioSettings.reverbEnable;
                    if (this.score.audioSettings.playerType === 'synthesizer') {
                        params.wavetable = oscillator_1.SynthWavetable;
                        params.waveform = this.score.audioSettings.waveform;
                        cuedSound.oscs.push(new oscillator_1.SuiWavetable(params));
                    }
                    else {
                        cuedSound.oscs.push(new oscillator_1.SuiSampler(params));
                    }
                }
            });
            if (j + 1 < keys.length) {
                const diff = (keys[j + 1] - keys[j]);
                cuedSound.waitTime = diff * timeRatio;
                measureBeat += diff;
            }
            else if (measureIndex + 1 < maxMeasures) {
                // If the next measure, calculate the frequencies for the next track.
                this.cuedSounds.cueMeasureIndex += 1;
                cuedSound.waitTime = endTicks * timeRatio;
            }
            else {
                this.cuedSounds.complete = true;
            }
            // }, 1);
        }
    }
    populateSounds(measureIndex) {
        if (!SuiAudioPlayer.playing) {
            return;
        }
        const interval = 20;
        let draining = false;
        const buffer = SuiAudioPlayer.audioBufferSize;
        const timer = setInterval(() => {
            if (this.cuedSounds.complete || SuiAudioPlayer.playing === false) {
                clearInterval(timer);
                return;
            }
            if (this.cuedSounds.paramLinkHead === null) {
                this.cuedSounds.complete = true;
                return;
            }
            if (draining && this.cuedSounds.soundCount > buffer / 4) {
                return;
            }
            if (this.cuedSounds.soundCount > buffer) {
                draining = true;
                return;
            }
            draining = false;
            this.createCuedSound(measureIndex);
            measureIndex += 1;
        }, interval);
    }
    playSounds() {
        this.cuedSounds.playMeasureIndex = 0;
        this.cuedSounds.playWaitTimer = 0;
        let previousDuration = 0;
        const timer = () => {
            setTimeout(() => {
                const cuedSound = this.cuedSounds.advanceHead();
                if (cuedSound === null) {
                    SuiAudioPlayer._playing = false;
                    this.audioAnimation.clearAudioAnimationHandler(previousDuration);
                    return;
                }
                if (SuiAudioPlayer._playing === false) {
                    this.audioAnimation.clearAudioAnimationHandler(previousDuration);
                    return;
                }
                if (cuedSound.oscs.length === 0) {
                    this.cuedSounds.playMeasureIndex += 1;
                    this.cuedSounds.playWaitTimer = cuedSound.waitTime;
                    console.warn('empty oscs in playback');
                    timer();
                    return;
                }
                previousDuration = cuedSound.oscs[0].duration;
                SuiAudioPlayer._playChord(cuedSound.oscs);
                this.audioAnimation.audioAnimationHandler(this.view, cuedSound.selector, cuedSound.offsetPct, cuedSound.durationPct);
                this.cuedSounds.playMeasureIndex += 1;
                this.cuedSounds.playWaitTimer = cuedSound.waitTime;
                timer();
            }, this.cuedSounds.playWaitTimer);
        };
        timer();
    }
    playAfter(milliseconds, oscs) {
        setTimeout(() => {
            SuiAudioPlayer._playChord(oscs);
        }, milliseconds);
    }
    startPlayer(measureIndex) {
        this.openTies = {};
        this.cuedSounds.reset();
        this.cuedSounds.cueMeasureIndex = measureIndex;
        this.cuedSounds.playMeasureIndex = this.cuedSounds.cueMeasureIndex;
        this.cuedSounds.paramLinkHead = null;
        this.cuedSounds.paramLinkTail = null;
        const endMeasure = this.score.staves[0].measures.length;
        let i = 0;
        for (i = this.cuedSounds.cueMeasureIndex; i < endMeasure; ++i) {
            const { endTicks, measureNotes } = this.getNoteSoundData(i);
            const node = {
                soundParams: measureNotes,
                endTicks,
                next: null
            };
            if (this.cuedSounds.paramLinkHead === null) {
                this.cuedSounds.paramLinkHead = node;
                this.cuedSounds.paramLinkTail = node;
            }
            else {
                this.cuedSounds.paramLinkTail.next = node;
                this.cuedSounds.paramLinkTail = this.cuedSounds.paramLinkTail.next;
            }
        }
        setTimeout(() => {
            this.populateSounds(measureIndex);
        }, 1);
        const bufferThenPlay = () => {
            setTimeout(() => {
                if (this.cuedSounds.soundListLength >= SuiAudioPlayer.audioBufferSize || this.cuedSounds.complete) {
                    this.playSounds();
                }
                else {
                    bufferThenPlay();
                }
            }, 50);
        };
        bufferThenPlay();
    }
    static stopPlayer() {
        if (SuiAudioPlayer._playingInstance) {
            const a = SuiAudioPlayer._playingInstance;
            a.audioAnimation.clearAudioAnimationHandler(0);
            a.paused = false;
            a.cuedSounds.reset();
        }
        SuiAudioPlayer.playing = false;
    }
    static get playingInstance() {
        if (!SuiAudioPlayer._playingInstance) {
            return null;
        }
        return SuiAudioPlayer._playingInstance;
    }
    // the oscAr contains an oscillator for each pitch in the chord.
    // each inner oscillator is a promise, the combined promise is resolved when all
    // the beats have completed.
    static _playChord(oscAr) {
        var par = [];
        oscAr.forEach((osc) => {
            par.push(osc.play());
        });
        return Promise.all(par);
    }
    // Starts the player.
    play() {
        var _a, _b;
        let i = 0;
        if (SuiAudioPlayer.playing) {
            return;
        }
        SuiAudioPlayer._playingInstance = this;
        SuiAudioPlayer.playing = true;
        const startIndex = (_b = (_a = this.view.tracker.getFirstMeasureOfSelection()) === null || _a === void 0 ? void 0 : _a.measureNumber.measureIndex) !== null && _b !== void 0 ? _b : 0;
        //for (i = this.startIndex; i < this.score.staves[0].measures.length; ++i) {
        //   this.tracks.push(SuiAudioPlayer.getTrackSounds(this.audio.tracks, i));
        // }
        // const sounds = SuiAudioPlayer.getTrackSounds(this.audio.tracks, this.startIndex);
        // this.playSoundsAtOffset(sounds, 0);
        this.startPlayer(startIndex);
    }
}
exports.SuiAudioPlayer = SuiAudioPlayer;
SuiAudioPlayer._playing = false;
SuiAudioPlayer.instanceId = 0;
SuiAudioPlayer.duplicatePitchThresh = 4;
SuiAudioPlayer.voiceThresh = 16;
SuiAudioPlayer._playingInstance = null;


/***/ }),

/***/ "./src/render/audio/samples.ts":
/*!*************************************!*\
  !*** ./src/render/audio/samples.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SuiSampleMedia = exports.sampleFromFrequency = exports.sampleFromMinDuration = exports.sampleForPercussion = void 0;
// [Smoosic](https://github.com/AaronDavidNewman/Smoosic)
// Copyright (c) Aaron David Newman 2021.
const music_1 = __webpack_require__(/*! ../../smo/data/music */ "./src/smo/data/music.ts");
const promiseHelpers_1 = __webpack_require__(/*! ../../common/promiseHelpers */ "./src/common/promiseHelpers.ts");
const staffModifiers_1 = __webpack_require__(/*! ../../smo/data/staffModifiers */ "./src/smo/data/staffModifiers.ts");
const sampleForPercussion = (params, samples) => {
    const longSamples = samples.filter((ss) => ss.instrument === 'percussion');
    let sample = null;
    if (longSamples.length) {
        sample = (0, exports.sampleFromFrequency)(params, longSamples);
        if (sample) {
            return sample;
        }
    }
    return (0, exports.sampleFromFrequency)(params, samples);
};
exports.sampleForPercussion = sampleForPercussion;
/**
 * For instruments like violin that require different samples depending on note duration
 * @param params
 * @param samples
 * @returns
 * @category SuiAudio
 */
const sampleFromMinDuration = (params, samples) => {
    const longSamples = samples.filter((ss) => ss.minDuration < params.duration && ss.minDuration > 0);
    if (longSamples.length) {
        return (0, exports.sampleFromFrequency)(params, longSamples);
    }
    return (0, exports.sampleFromFrequency)(params, samples.filter((ss) => ss.minDuration === 0));
};
exports.sampleFromMinDuration = sampleFromMinDuration;
/**
 * Give a set of samples, return the one that closest matches the frequency
 * @param params
 * @param samples
 * @returns
 * @category SuiAudio
*/
const sampleFromFrequency = (params, samples) => {
    let min = 9999;
    let rv = null;
    let i = 0;
    const f = params.frequency;
    for (i = 0; i < samples.length; ++i) {
        const oscInfo = samples[i];
        if (!oscInfo.sample || !SuiSampleMedia.sampleBufferMap[oscInfo.sample]) {
            continue;
        }
        const buffer = SuiSampleMedia.sampleBufferMap[oscInfo.sample];
        if (Math.abs(f - oscInfo.nativeFrequency) < min) {
            min = Math.abs(f - oscInfo.nativeFrequency);
            rv = {
                sample: buffer,
                frequency: oscInfo.nativeFrequency,
                patch: oscInfo.sample
            };
        }
    }
    return rv;
};
exports.sampleFromFrequency = sampleFromFrequency;
/**
 * Logic to create audio nodes out of HTML5 media elements
 * @category SuiAudio
 */
class SuiSampleMedia {
    static insertIntoMap(sample) {
        const oscInfo = staffModifiers_1.SmoInstrument.defaultOscillatorParam;
        const populatePartial = (partial, full, param) => {
            full[param] = typeof (partial[param]) === 'undefined' ? full[param] : partial[param];
        };
        staffModifiers_1.SmoOscillatorInfoAllTypes.forEach((paramType) => {
            populatePartial(sample, oscInfo, paramType);
        });
        if (!this.sampleOscMap[oscInfo.instrument]) {
            this.sampleOscMap[oscInfo.instrument] = [];
        }
        this.sampleOscMap[oscInfo.instrument].push(oscInfo);
        SuiSampleMedia.sampleFiles.push(oscInfo);
    }
    static populateSampleMap() {
        SuiSampleMedia.insertIntoMap({
            sustain: 'percussive',
            sample: 'samplecn4',
            family: 'keyboard',
            instrument: 'piano',
            nativeFrequency: music_1.SmoAudioPitch.smoPitchToFrequency({ letter: 'c', accidental: 'n', octave: 4 }, 0, null),
        });
        SuiSampleMedia.insertIntoMap({
            sustain: 'percussive',
            realOvertones: [],
            imaginaryOvertones: [],
            sample: 'samplebb4',
            family: 'keyboard',
            instrument: 'piano',
            nativeFrequency: music_1.SmoAudioPitch.smoPitchToFrequency({ letter: 'b', accidental: 'b', octave: 4 }, 0, null),
        });
        SuiSampleMedia.insertIntoMap({
            sustain: 'percussive',
            sample: 'basspizz-c2-sso',
            family: 'strings',
            instrument: 'jazzBass',
            nativeFrequency: music_1.SmoAudioPitch.smoPitchToFrequency({ letter: 'c', accidental: '#', octave: 3 }, 0, null),
        });
        SuiSampleMedia.insertIntoMap({
            sustain: 'percussive',
            sample: 'basspizz-c3-sso',
            family: 'strings',
            instrument: 'jazzBass',
            nativeFrequency: music_1.SmoAudioPitch.smoPitchToFrequency({ letter: 'c', accidental: '#', octave: 4 }, 0, null),
        });
        SuiSampleMedia.insertIntoMap({
            sustain: 'sustained',
            sample: 'eguitar-e3',
            family: 'strings',
            instrument: 'eGuitar',
            nativeFrequency: music_1.SmoAudioPitch.smoPitchToFrequency({ letter: 'e', accidental: 'n', octave: 3 }, 0, null),
        });
        SuiSampleMedia.insertIntoMap({
            sustain: 'sustained',
            sample: 'eguitar-d4',
            family: 'strings',
            instrument: 'eGuitar',
            nativeFrequency: music_1.SmoAudioPitch.smoPitchToFrequency({ letter: 'd', accidental: 'n', octave: 4 }, 0, null),
        });
        SuiSampleMedia.insertIntoMap({
            sustain: 'sustained',
            sample: 'sample-bass-a1',
            family: 'strings',
            instrument: 'bass',
            nativeFrequency: music_1.SmoAudioPitch.smoPitchToFrequency({ letter: 'a', accidental: 'n', octave: 1 }, 0, null),
        });
        SuiSampleMedia.insertIntoMap({
            sustain: 'sustained',
            sample: 'sample-bass-a3',
            family: 'strings',
            instrument: 'bass',
            nativeFrequency: music_1.SmoAudioPitch.smoPitchToFrequency({ letter: 'a', accidental: 'n', octave: 3 }, 0, null),
        });
        SuiSampleMedia.insertIntoMap({
            sustain: 'sustained',
            sample: 'sample-violinshort-c4',
            family: 'strings',
            instrument: 'violin',
            minDuration: 0,
            nativeFrequency: music_1.SmoAudioPitch.smoPitchToFrequency({ letter: 'c', accidental: 'n', octave: 5 }, 0, null),
        });
        SuiSampleMedia.insertIntoMap({
            sustain: 'sustained',
            sample: 'sample-violinshort-b5',
            family: 'strings',
            instrument: 'violin',
            minDuration: 0,
            nativeFrequency: music_1.SmoAudioPitch.smoPitchToFrequency({ letter: 'b', accidental: 'n', octave: 6 }, 0, null),
        });
        SuiSampleMedia.insertIntoMap({
            sustain: 'sustained',
            sample: 'sample-violinshort-e5',
            family: 'strings',
            instrument: 'violin',
            minDuration: 0,
            nativeFrequency: music_1.SmoAudioPitch.smoPitchToFrequency({ letter: 'e', accidental: 'n', octave: 6 }, 0, null),
        });
        SuiSampleMedia.insertIntoMap({
            sustain: 'sustained',
            sample: 'sample-violin-e6',
            family: 'strings',
            instrument: 'violin',
            minDuration: 400,
            nativeFrequency: music_1.SmoAudioPitch.smoPitchToFrequency({ letter: 'e', accidental: 'n', octave: 6 }, 0, null),
        });
        SuiSampleMedia.insertIntoMap({
            sustain: 'sustained',
            sample: 'sample-violin-e5',
            family: 'strings',
            instrument: 'violin',
            minDuration: 400,
            nativeFrequency: music_1.SmoAudioPitch.smoPitchToFrequency({ letter: 'e', accidental: 'n', octave: 5 }, 0, null),
        });
        SuiSampleMedia.insertIntoMap({
            sustain: 'sustained',
            sample: 'sample-violin-e4',
            family: 'strings',
            instrument: 'violin',
            minDuration: 400,
            nativeFrequency: music_1.SmoAudioPitch.smoPitchToFrequency({ letter: 'e', accidental: 'n', octave: 4 }, 0, null),
        });
        SuiSampleMedia.insertIntoMap({
            sustain: 'sustained',
            sample: 'sample-cello-bb3',
            family: 'strings',
            instrument: 'cello',
            nativeFrequency: music_1.SmoAudioPitch.smoPitchToFrequency({ letter: 'b', accidental: 'n', octave: 3 }, 0, null),
        });
        SuiSampleMedia.insertIntoMap({
            sustain: 'sustained',
            sample: 'sample-cello-c4',
            family: 'strings',
            instrument: 'cello',
            nativeFrequency: music_1.SmoAudioPitch.smoPitchToFrequency({ letter: 'c', accidental: 'n', octave: 4 }, 0, null),
        });
        SuiSampleMedia.insertIntoMap({
            sustain: 'sustained',
            sample: 'trumpet-g5-sso',
            family: 'brass',
            instrument: 'trumpet',
            nativeFrequency: music_1.SmoAudioPitch.smoPitchToFrequency({ letter: 'g', accidental: 'n', octave: 5 }, 0, null),
        });
        SuiSampleMedia.insertIntoMap({
            sustain: 'sustained',
            sample: 'trumpet-e4-sso',
            family: 'brass',
            instrument: 'trumpet',
            nativeFrequency: music_1.SmoAudioPitch.smoPitchToFrequency({ letter: 'e', accidental: 'n', octave: 4 }, 0, null),
        });
        SuiSampleMedia.insertIntoMap({
            sustain: 'sustained',
            sample: 'sample-horn-c4',
            family: 'brass',
            instrument: 'horn',
            nativeFrequency: music_1.SmoAudioPitch.smoPitchToFrequency({ letter: 'c', accidental: 'n', octave: 4 }, 0, null),
            dynamic: 100
        });
        SuiSampleMedia.insertIntoMap({
            sustain: 'sustained',
            sample: 'sample-horn-c3',
            family: 'brass',
            instrument: 'horn',
            nativeFrequency: music_1.SmoAudioPitch.smoPitchToFrequency({ letter: 'c', accidental: 'n', octave: 3 }, 0, null),
        });
        SuiSampleMedia.insertIntoMap({
            sustain: 'sustained',
            sample: 'trombone-g3-sso',
            family: 'brass',
            instrument: 'trombone',
            nativeFrequency: music_1.SmoAudioPitch.smoPitchToFrequency({ letter: 'g', accidental: 'n', octave: 3 }, 0, null),
        });
        SuiSampleMedia.insertIntoMap({
            sustain: 'sustained',
            sample: 'trombone-g4-sso',
            family: 'brass',
            instrument: 'trombone',
            nativeFrequency: music_1.SmoAudioPitch.smoPitchToFrequency({ letter: 'g', accidental: 'n', octave: 4 }, 0, null),
        });
        SuiSampleMedia.insertIntoMap({
            sustain: 'sustained',
            sample: 'sample-tuba-c2',
            family: 'brass',
            instrument: 'tuba',
            nativeFrequency: music_1.SmoAudioPitch.smoPitchToFrequency({ letter: 'c', accidental: 'n', octave: 2 }, 0, null),
        });
        SuiSampleMedia.insertIntoMap({
            sustain: 'sustained',
            sample: 'sample-tuba-c3',
            family: 'brass',
            instrument: 'tuba',
            nativeFrequency: music_1.SmoAudioPitch.smoPitchToFrequency({ letter: 'c', accidental: 'n', octave: 3 }, 0, null),
        });
        SuiSampleMedia.insertIntoMap({
            sustain: 'sustained',
            sample: 'sample-clarinet-c4',
            family: 'woodwind',
            instrument: 'clarinet',
            nativeFrequency: music_1.SmoAudioPitch.smoPitchToFrequency({ letter: 'c', accidental: 'n', octave: 4 }, 0, null),
        });
        SuiSampleMedia.insertIntoMap({
            sustain: 'sustained',
            sample: 'sample-clarinet-c5',
            family: 'woodwind',
            instrument: 'clarinet',
            nativeFrequency: music_1.SmoAudioPitch.smoPitchToFrequency({ letter: 'c', accidental: 'n', octave: 5 }, 0, null),
        });
        SuiSampleMedia.insertIntoMap({
            sustain: 'sustained',
            sample: 'sample-asax-a3',
            family: 'woodwind',
            instrument: 'altoSax',
            nativeFrequency: music_1.SmoAudioPitch.smoPitchToFrequency({ letter: 'a', accidental: 'n', octave: 3 }, 12, null),
        });
        SuiSampleMedia.insertIntoMap({
            sustain: 'sustained',
            sample: 'sample-asax-c4',
            family: 'woodwind',
            instrument: 'altoSax',
            nativeFrequency: music_1.SmoAudioPitch.smoPitchToFrequency({ letter: 'c', accidental: 'n', octave: 4 }, 12, null),
        });
        SuiSampleMedia.insertIntoMap({
            sustain: 'sustained',
            sample: 'sample-asax-a3',
            family: 'woodwind',
            instrument: 'tenorSax',
            nativeFrequency: music_1.SmoAudioPitch.smoPitchToFrequency({ letter: 'a', accidental: 'n', octave: 3 }, 24, null),
        });
        SuiSampleMedia.insertIntoMap({
            sustain: 'sustained',
            sample: 'sample-asax-c4',
            family: 'woodwind',
            instrument: 'tenorSax',
            nativeFrequency: music_1.SmoAudioPitch.smoPitchToFrequency({ letter: 'c', accidental: 'n', octave: 4 }, 24, null),
        });
        SuiSampleMedia.insertIntoMap({
            sustain: 'sustained',
            sample: 'barisax-d2-nz10',
            family: 'woodwind',
            instrument: 'bariSax',
            nativeFrequency: music_1.SmoAudioPitch.smoPitchToFrequency({ letter: 'd', accidental: 'n', octave: 2 }, 12, null),
        });
        SuiSampleMedia.insertIntoMap({
            sustain: 'sustained',
            sample: 'barisax-c3-nz10',
            family: 'woodwind',
            instrument: 'bariSax',
            nativeFrequency: music_1.SmoAudioPitch.smoPitchToFrequency({ letter: 'c', accidental: 'n', octave: 3 }, 12, null) - 5,
        });
        SuiSampleMedia.insertIntoMap({
            sustain: 'sustained',
            sample: 'pad-c4-vita',
            family: 'synth',
            instrument: 'pad',
            nativeFrequency: music_1.SmoAudioPitch.smoPitchToFrequency({ letter: 'c', accidental: 'n', octave: 3 }, 0, null),
            dynamic: 100
        });
        SuiSampleMedia.insertIntoMap({
            sustain: 'sustained',
            sample: 'pad-c5-vita',
            family: 'synth',
            instrument: 'pad',
            nativeFrequency: music_1.SmoAudioPitch.smoPitchToFrequency({ letter: 'c', accidental: 'n', octave: 4 }, 0, null),
            dynamic: 100
        });
        SuiSampleMedia.insertIntoMap({
            sustain: 'percussive',
            sample: 'drum-hh-closed',
            family: 'drums',
            instrument: 'percussion',
            nativeFrequency: music_1.SmoAudioPitch.smoPitchToFrequency({ letter: 'g', accidental: 'n', octave: 5 }, 0, null),
            dynamic: 100
        });
        SuiSampleMedia.insertIntoMap({
            sustain: 'percussive',
            sample: 'drum-drumset-snare',
            family: 'drums',
            instrument: 'percussion',
            nativeFrequency: music_1.SmoAudioPitch.smoPitchToFrequency({ letter: 'f', accidental: 'n', octave: 4 }, 0, null),
            dynamic: 100
        });
        SuiSampleMedia.insertIntoMap({
            sustain: 'percussive',
            sample: 'drum-drumset-tom1',
            family: 'drums',
            instrument: 'percussion',
            nativeFrequency: music_1.SmoAudioPitch.smoPitchToFrequency({ letter: 'a', accidental: 'n', octave: 4 }, 0, null),
            dynamic: 100
        });
        SuiSampleMedia.insertIntoMap({
            sustain: 'percussive',
            sample: 'drum-drumset-tom2',
            family: 'drums',
            instrument: 'percussion',
            nativeFrequency: music_1.SmoAudioPitch.smoPitchToFrequency({ letter: 'e', accidental: 'n', octave: 5 }, 0, null),
            dynamic: 100
        });
        SuiSampleMedia.insertIntoMap({
            sustain: 'percussive',
            sample: 'drum-drumset-kick',
            family: 'drums',
            instrument: 'percussion',
            nativeFrequency: music_1.SmoAudioPitch.smoPitchToFrequency({ letter: 'c', accidental: 'n', octave: 4 }, 0, null),
            dynamic: 100
        });
        const instrumentMap = Object.keys(SuiSampleMedia.sampleOscMap);
        instrumentMap.forEach((instrumentKey) => {
            SuiSampleMedia.instrumentChooser[instrumentKey] = {
                instrument: instrumentKey,
                samples: SuiSampleMedia.sampleOscMap[instrumentKey],
                sampleChooser: exports.sampleFromFrequency
            };
        });
        SuiSampleMedia.instrumentChooser['violin'].sampleChooser = exports.sampleFromMinDuration;
        SuiSampleMedia.instrumentChooser['percussion'].sampleChooser = exports.sampleForPercussion;
    }
    static getSmoOscillatorInfo(instrument) {
        if (!SuiSampleMedia.sampleOscMap[instrument]) {
            return SuiSampleMedia.sampleOscMap['piano'];
        }
        return SuiSampleMedia.sampleOscMap[instrument];
    }
    /**
    * Load samples so we can play the music
    * @returns - promise, resolved when loaded
    */
    static samplePromise(audio) {
        const mediaElements = [];
        let i = 0;
        if (SuiSampleMedia.receivedBuffer) {
            return promiseHelpers_1.PromiseHelpers.emptyPromise();
        }
        SuiSampleMedia.populateSampleMap();
        const loadedSamples = {};
        for (i = 0; i < SuiSampleMedia.sampleFiles.length; ++i) {
            const file = SuiSampleMedia.sampleFiles[i];
            if (!file.sample) {
                continue;
            }
            const sampleName = file.sample;
            const audioElement = document.getElementById(file.sample);
            if (!loadedSamples[file.sample] && audioElement) {
                loadedSamples[file.sample] = true;
                const media = audio.createMediaElementSource(audioElement);
                mediaElements.push(audioElement);
                const req = new XMLHttpRequest();
                req.open('GET', media.mediaElement.src, true);
                req.responseType = 'arraybuffer';
                req.send();
                req.onload = () => {
                    const audioData = req.response;
                    audio.decodeAudioData(audioData, (decoded) => {
                        SuiSampleMedia.sampleBufferMap[sampleName] = decoded;
                        SuiSampleMedia.receivedBuffer = true;
                    });
                };
            }
            if (mediaElements.length < 1) {
                return promiseHelpers_1.PromiseHelpers.emptyPromise();
            }
        }
        const rv = new Promise((resolve) => {
            const checkSample = () => {
                setTimeout(() => {
                    if (!SuiSampleMedia.receivedBuffer) {
                        checkSample();
                    }
                    else {
                        resolve();
                    }
                }, 100);
            };
            checkSample();
        });
        return rv;
    }
    static sampleForFrequency(f, oscs) {
        let min = 9999;
        let rv = null;
        let i = 0;
        for (i = 0; i < oscs.length; ++i) {
            const oscInfo = oscs[i];
            if (!oscInfo.sample || !SuiSampleMedia.sampleBufferMap[oscInfo.sample]) {
                continue;
            }
            const buffer = SuiSampleMedia.sampleBufferMap[oscInfo.sample];
            if (Math.abs(f - oscInfo.nativeFrequency) < min) {
                min = Math.abs(f - oscInfo.nativeFrequency);
                rv = {
                    sample: buffer,
                    frequency: oscInfo.nativeFrequency,
                    patch: oscInfo.sample
                };
            }
        }
        return rv;
    }
    static matchedSample(params) {
        let instrumentKey = params.instrument;
        if (!SuiSampleMedia.instrumentChooser[instrumentKey]) {
            instrumentKey = 'piano';
        }
        if (!SuiSampleMedia.instrumentChooser[instrumentKey]) {
            const keys = Object.keys(SuiSampleMedia.sampleOscMap);
            if (keys.length === 0) {
                return null;
            }
            instrumentKey = keys[0];
        }
        return SuiSampleMedia.instrumentChooser[instrumentKey].sampleChooser(params, SuiSampleMedia.instrumentChooser[instrumentKey].samples);
    }
}
exports.SuiSampleMedia = SuiSampleMedia;
SuiSampleMedia.sampleFiles = [];
SuiSampleMedia.sampleBufferMap = {};
SuiSampleMedia.sampleOscMap = {};
SuiSampleMedia.instrumentChooser = {};
SuiSampleMedia.receivedBuffer = false;


/***/ }),

/***/ "./src/render/sui/configuration.ts":
/*!*****************************************!*\
  !*** ./src/render/sui/configuration.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ "./src/render/sui/formatter.ts":
/*!*************************************!*\
  !*** ./src/render/sui/formatter.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SuiLayoutFormatter = void 0;
// [Smoosic](https://github.com/AaronDavidNewman/Smoosic)
// Copyright (c) Aaron David Newman 2021.
/**
 * Utilities for formatting the music by estimating the geometry of the music.
 * @module /render/sui/formatter
 */
const svgHelpers_1 = __webpack_require__(/*! ./svgHelpers */ "./src/render/sui/svgHelpers.ts");
const music_1 = __webpack_require__(/*! ../../smo/data/music */ "./src/smo/data/music.ts");
const glyphDimensions_1 = __webpack_require__(/*! ../vex/glyphDimensions */ "./src/render/vex/glyphDimensions.ts");
const noteModifiers_1 = __webpack_require__(/*! ../../smo/data/noteModifiers */ "./src/smo/data/noteModifiers.ts");
const note_1 = __webpack_require__(/*! ../../smo/data/note */ "./src/smo/data/note.ts");
const beamers_1 = __webpack_require__(/*! ../../smo/xform/beamers */ "./src/smo/xform/beamers.ts");
const staffModifiers_1 = __webpack_require__(/*! ../../smo/data/staffModifiers */ "./src/smo/data/staffModifiers.ts");
const layoutDebug_1 = __webpack_require__(/*! ./layoutDebug */ "./src/render/sui/layoutDebug.ts");
const measure_1 = __webpack_require__(/*! ../../smo/data/measure */ "./src/smo/data/measure.ts");
const measureModifiers_1 = __webpack_require__(/*! ../../smo/data//measureModifiers */ "./src/smo/data/measureModifiers.ts");
const VF = eval('Vex.Flow');
/**
 * Utilities for estimating measure/system/page width and height
 * @category SuiRender
 */
class SuiLayoutFormatter {
    constructor(score, svg, renderedPages) {
        this.systems = {};
        this.currentPage = 0;
        this.lines = [];
        this.score = score;
        this.svg = svg;
        this.columnMeasureMap = {};
        this.renderedPages = renderedPages;
        this.score.staves.forEach((staff) => {
            staff.measures.forEach((measure) => {
                if (!this.columnMeasureMap[measure.measureNumber.measureIndex]) {
                    this.columnMeasureMap[measure.measureNumber.measureIndex] = [];
                }
                this.columnMeasureMap[measure.measureNumber.measureIndex].push(measure);
            });
        });
    }
    /**
     * Once we know which line a measure is going on, make a map for it for easy
     * looking during rendering
     * @param measures
     * @param lineIndex
     * @param systemIndex
     */
    updateSystemMap(measures, lineIndex, systemIndex) {
        if (!this.systems[lineIndex]) {
            const nextLr = {
                systems: {}
            };
            this.systems[lineIndex] = nextLr;
        }
        const systemRender = this.systems[lineIndex];
        if (!systemRender.systems[systemIndex]) {
            systemRender.systems[systemIndex] = measures;
        }
    }
    trimPages(startPageCount) {
        var _a, _b, _c, _d;
        let pl = (_b = (_a = this.score) === null || _a === void 0 ? void 0 : _a.layoutManager) === null || _b === void 0 ? void 0 : _b.pageLayouts;
        if (pl) {
            if (this.currentPage < pl.length - 1) {
                this.score.layoutManager.trimPages(this.currentPage);
                pl = (_d = (_c = this.score) === null || _c === void 0 ? void 0 : _c.layoutManager) === null || _d === void 0 ? void 0 : _d.pageLayouts;
            }
            if (pl && pl.length !== startPageCount) {
                return true;
            }
        }
        return false;
    }
    /**
     * see if page breaks this boundary.  If it does, bump the current page and move the system down
     * to the new page
     * @param scoreLayout
     * @param currentLine
     * @param bottomMeasure
     * @returns
     */
    checkPageBreak(scoreLayout, currentLine, bottomMeasure) {
        let pageAdj = 0;
        const lm = this.score.layoutManager;
        // See if this measure breaks a page.
        const maxY = bottomMeasure.svg.logicalBox.y + bottomMeasure.svg.logicalBox.height;
        if (maxY > ((this.currentPage + 1) * scoreLayout.pageHeight) - scoreLayout.bottomMargin) {
            this.currentPage += 1;
            // If this is a new page, make sure there is a layout for it.
            lm.addToPageLayouts(this.currentPage);
            scoreLayout = lm.getScaledPageLayout(this.currentPage);
            // When adjusting the page, make it so the top staff of the system
            // clears the bottom of the page.
            const topMeasure = currentLine.reduce((a, b) => a.svg.logicalBox.y < b.svg.logicalBox.y ? a : b);
            const minMaxY = topMeasure.svg.logicalBox.y;
            pageAdj = (this.currentPage * scoreLayout.pageHeight) - minMaxY;
            pageAdj = pageAdj + scoreLayout.topMargin;
            // For each measure on the current line, move it down past the page break;
            currentLine.forEach((measure) => {
                measure.setBox(svgHelpers_1.SvgHelpers.boxPoints(measure.svg.logicalBox.x, measure.svg.logicalBox.y + pageAdj, measure.svg.logicalBox.width, measure.svg.logicalBox.height), '_checkPageBreak');
                measure.setY(measure.staffY + pageAdj, '_checkPageBreak');
                measure.svg.pageIndex = this.currentPage;
            });
        }
        return scoreLayout;
    }
    measureToLeft(measure) {
        const j = measure.measureNumber.staffId;
        const i = measure.measureNumber.measureIndex;
        return (i > 0 ? this.score.staves[j].measures[i - 1] : null);
    }
    // {measures,y,x}  the x and y at the left/bottom of the render
    /**
     * Estimate the dimensions of a column when it's rendered.
     * @param scoreLayout
     * @param measureIx
     * @param systemIndex
     * @param lineIndex
     * @param x
     * @param y
     * @returns { MeasureEstimate } - the measures in the column and the x, y location
     */
    estimateColumn(scoreLayout, measureIx, systemIndex, lineIndex, x, y) {
        const s = {};
        const measures = this.columnMeasureMap[measureIx];
        let rowInSystem = 0;
        let voiceCount = 0;
        let unalignedCtxCount = 0;
        let wsum = 0;
        let dsum = 0;
        let maxCfgWidth = 0;
        let isPickup = false;
        // Keep running tab of accidental widths for justification
        const contextMap = {};
        let forceClefCount = 0;
        let measureToSkip = false;
        measures.forEach((measure) => {
            beamers_1.SmoBeamer.applyBeams(measure);
            voiceCount += measure.voices.length;
            if (measure.isPickup()) {
                isPickup = true;
            }
            if (measure.format.skipMeasureCount) {
                measureToSkip = true;
            }
            measure.measureNumber.systemIndex = systemIndex;
            measure.svg.rowInSystem = rowInSystem;
            measure.svg.lineIndex = lineIndex;
            measure.svg.pageIndex = this.currentPage;
            // use measure to left to figure out whether I need to render key signature, etc.
            // If I am the first measure, just use self and we always render them on the first measure.
            let measureToLeft = this.measureToLeft(measure);
            if (!measureToLeft) {
                measureToLeft = measure;
            }
            s.measureKeySig = music_1.SmoMusic.vexKeySignatureTranspose(measure.keySignature, 0);
            s.keySigLast = music_1.SmoMusic.vexKeySignatureTranspose(measureToLeft.keySignature, 0);
            s.tempoLast = measureToLeft.getTempo();
            s.timeSigLast = measureToLeft.timeSignature;
            s.clefLast = measureToLeft.clef;
            this.calculateBeginningSymbols(systemIndex, measure, s.clefLast, s.keySigLast, s.timeSigLast, s.tempoLast);
            if (measure.svg.forceClef) {
                forceClefCount += 1;
            }
            // calculate vertical offsets from the baseline
            const offsets = this.estimateMeasureHeight(measure);
            measure.setYTop(offsets.aboveBaseline, 'render:estimateColumn');
            measure.setY(y - measure.yTop, 'estimateColumns height');
            measure.setX(x, 'render:estimateColumn');
            // Add custom width to measure:
            measure.setBox(svgHelpers_1.SvgHelpers.boxPoints(measure.staffX, y, measure.staffWidth, offsets.belowBaseline - offsets.aboveBaseline), 'render: estimateColumn');
            this.estimateMeasureWidth(measure, scoreLayout, contextMap);
            y = y + measure.svg.logicalBox.height + scoreLayout.intraGap;
            maxCfgWidth = Math.max(maxCfgWidth, measure.staffWidth);
            rowInSystem += 1;
        });
        if (forceClefCount > 0 && forceClefCount < measures.length) {
            measures.forEach((mm) => {
                // If there are other clefs in this column, compensate for the width here.
                if (!mm.svg.forceClef) {
                    mm.svg.adjX += glyphDimensions_1.vexGlyph.width(glyphDimensions_1.vexGlyph.clef('treble'));
                }
            });
        }
        // justify this column to the maximum width.
        const startX = measures[0].staffX;
        const adjX = measures.reduce((a, b) => a.svg.adjX > b.svg.adjX ? a : b).svg.adjX;
        const contexts = Object.keys(contextMap);
        const widths = [];
        const durations = [];
        let minTotalWidth = 0;
        contexts.forEach((strIx) => {
            const ix = parseInt(strIx);
            let tickWidth = 0;
            const context = contextMap[ix];
            if (context.tickCounts.length < voiceCount) {
                unalignedCtxCount += 1;
            }
            context.widths.forEach((w, ix) => {
                wsum += w;
                dsum += context.tickCounts[ix];
                widths.push(w);
                durations.push(context.tickCounts[ix]);
                tickWidth = Math.max(tickWidth, w);
            });
            minTotalWidth += tickWidth;
        });
        // Vex formatter adjusts location of ticks based to keep the justified music aligned.  It does this
        // by moving notes to the right.  We try to add padding to each tick context based on the 'entropy' of the 
        // music.   4 quarter notes with no accidentals in all voices will have 0 entropy.  All the notes need the same
        // amount of space, so they don't need additional space to align.
        // wvar - the std deviation in the widths or 'width entropy'
        // dvar - the std deviation in the duration between voices or 'duration entropy'
        const sumArray = (arr) => arr.reduce((a, b) => a + b, 0);
        const wavg = wsum > 0 ? wsum / widths.length : 1 / widths.length;
        const wvar = sumArray(widths.map((ll) => Math.pow(ll - wavg, 2)));
        const wpads = Math.pow(wvar / widths.length, 0.5) / wavg;
        const davg = dsum / durations.length;
        const dvar = sumArray(durations.map((ll) => Math.pow(ll - davg, 2)));
        const dpads = Math.pow(dvar / durations.length, 0.5) / davg;
        const unalignedPadding = 5;
        const padmax = Math.max(dpads, wpads) * contexts.length * unalignedPadding;
        const unalignedPad = unalignedPadding * unalignedCtxCount;
        let maxWidth = Math.max(adjX + minTotalWidth + Math.max(unalignedPad, padmax), maxCfgWidth);
        if (scoreLayout.maxMeasureSystem > 0 && !isPickup && !measureToSkip) {
            // Add 1 because there is some overhead in each measure, 
            // so there can never be (width/max) measures in the system
            const defaultWidth = (scoreLayout.pageWidth / (scoreLayout.maxMeasureSystem + 1));
            maxWidth = Math.max(maxWidth, defaultWidth);
        }
        const maxX = startX + maxWidth;
        measures.forEach((measure) => {
            measure.setWidth(maxWidth, 'render:estimateColumn');
            // measure.svg.adjX = adjX;
        });
        const rv = { measures, y, x: maxX };
        return rv;
    }
    /**
     * return true if this is the last measure, taking into account multimeasure rest
     * @param measureIx
     * @returns
     */
    isLastVisibleMeasure(measureIx) {
        if (measureIx >= this.score.staves[0].measures.length) {
            return true;
        }
        let i = 0;
        for (i = measureIx; i < this.score.staves[0].measures.length; ++i) {
            const mm = this.score.staves[0].measures[i];
            if (!mm.svg.hideMultimeasure) {
                return false;
            }
        }
        return true;
    }
    /**
     * Calculate the geometry for the entire score, based on estimated measure width and height.
     * @returns
     */
    layout() {
        let measureIx = 0;
        let systemIndex = 0;
        if (!this.score.layoutManager) {
            return;
        }
        let scoreLayout = this.score.layoutManager.getScaledPageLayout(0);
        let y = 0;
        let x = 0;
        let lineIndex = 0;
        this.lines = [];
        let pageCheck = 0;
        // let firstMeasureOnPage = 0;
        this.lines.push(lineIndex);
        let currentLine = []; // the system we are esimating
        let measureEstimate = null;
        layoutDebug_1.layoutDebug.clearDebugBoxes(layoutDebug_1.layoutDebug.values.pre);
        layoutDebug_1.layoutDebug.clearDebugBoxes(layoutDebug_1.layoutDebug.values.system);
        const timestamp = new Date().valueOf();
        y = scoreLayout.topMargin;
        x = scoreLayout.leftMargin;
        while (measureIx < this.score.staves[0].measures.length) {
            if (this.score.isPartExposed()) {
                if (this.score.staves[0].measures[measureIx].svg.hideMultimeasure) {
                    measureIx += 1;
                    continue;
                }
            }
            measureEstimate = this.estimateColumn(scoreLayout, measureIx, systemIndex, lineIndex, x, y);
            x = measureEstimate.x;
            if (systemIndex > 0 &&
                (measureEstimate.measures[0].format.systemBreak || measureEstimate.x > (scoreLayout.pageWidth - scoreLayout.leftMargin))) {
                this.justifyY(scoreLayout, measureEstimate.measures.length, currentLine, false);
                // find the measure with the lowest y extend (greatest y value), not necessarily one with lowest
                // start of staff.
                const bottomMeasure = currentLine.reduce((a, b) => a.svg.logicalBox.y + a.svg.logicalBox.height > b.svg.logicalBox.y + b.svg.logicalBox.height ? a : b);
                this.checkPageBreak(scoreLayout, currentLine, bottomMeasure);
                const renderedPage = this.renderedPages[pageCheck];
                if (renderedPage) {
                    if (pageCheck !== this.currentPage) {
                        // The last measure in the last system of the previous page
                        const previousSystem = currentLine[0].measureNumber.measureIndex - 1;
                        if (renderedPage.endMeasure !== previousSystem) {
                            this.renderedPages[pageCheck] = null;
                        }
                        const nextPage = this.renderedPages[this.currentPage];
                        if (nextPage && nextPage.startMeasure !== previousSystem + 1) {
                            this.renderedPages[this.currentPage] = null;
                        }
                    }
                }
                pageCheck = this.currentPage;
                const ld = layoutDebug_1.layoutDebug;
                const sh = svgHelpers_1.SvgHelpers;
                if (layoutDebug_1.layoutDebug.mask & layoutDebug_1.layoutDebug.values.system) {
                    currentLine.forEach((measure) => {
                        if (measure.svg.logicalBox) {
                            const context = this.svg.getRenderer(measure.svg.logicalBox);
                            if (context) {
                                ld.debugBox(context.svg, measure.svg.logicalBox, layoutDebug_1.layoutDebug.values.system);
                            }
                        }
                    });
                }
                // Now start rendering on the next system.
                y = bottomMeasure.svg.logicalBox.height + bottomMeasure.svg.logicalBox.y + scoreLayout.interGap;
                currentLine = [];
                systemIndex = 0;
                x = scoreLayout.leftMargin;
                lineIndex += 1;
                this.lines.push(lineIndex);
                measureEstimate = this.estimateColumn(scoreLayout, measureIx, systemIndex, lineIndex, x, y);
                x = measureEstimate.x;
            }
            measureEstimate === null || measureEstimate === void 0 ? void 0 : measureEstimate.measures.forEach((measure) => {
                const context = this.svg.getRenderer(measure.svg.logicalBox);
                if (context) {
                    layoutDebug_1.layoutDebug.debugBox(context.svg, measure.svg.logicalBox, layoutDebug_1.layoutDebug.values.pre);
                }
            });
            this.updateSystemMap(measureEstimate.measures, lineIndex, systemIndex);
            currentLine = currentLine.concat(measureEstimate.measures);
            measureIx += 1;
            systemIndex += 1;
            // If this is the last measure but we have not filled the x extent,
            // still justify the vertical staves and check for page break.
            if (this.isLastVisibleMeasure(measureIx) && measureEstimate !== null) {
                this.justifyY(scoreLayout, measureEstimate.measures.length, currentLine, true);
                const bottomMeasure = currentLine.reduce((a, b) => a.svg.logicalBox.y + a.svg.logicalBox.height > b.svg.logicalBox.y + b.svg.logicalBox.height ? a : b);
                scoreLayout = this.checkPageBreak(scoreLayout, currentLine, bottomMeasure);
            }
        }
        // If a measure was added to the last page, make sure we re-render the page
        const renderedPage = this.renderedPages[this.currentPage];
        if (renderedPage) {
            if (renderedPage.endMeasure !== currentLine[0].measureNumber.measureIndex) {
                this.renderedPages[this.currentPage] = null;
            }
        }
        layoutDebug_1.layoutDebug.setTimestamp(layoutDebug_1.layoutDebug.codeRegions.COMPUTE, new Date().valueOf() - timestamp);
    }
    static estimateMusicWidth(smoMeasure, noteSpacing, tickContexts) {
        const widths = [];
        // Add up the widths of the music glyphs for each voice, including accidentals etc.  We save the widths in a hash by duration
        // and later consider overlapping/colliding ticks in each voice
        const tmObj = smoMeasure.createMeasureTickmaps();
        smoMeasure.voices.forEach((voice) => {
            let width = 0;
            let duration = 0;
            voice.notes.forEach((note) => {
                let noteWidth = 0;
                const dots = (note.dots ? note.dots : 0);
                let headWidth = glyphDimensions_1.vexGlyph.width(glyphDimensions_1.vexGlyph.dimensions.noteHead);
                // Maybe not the best place for this...ideally we'd get the note head glyph from
                // the ntoe.
                if (note.tickCount >= 4096 * 4 && note.noteType === 'n') {
                    headWidth *= 2;
                }
                const dotWidth = glyphDimensions_1.vexGlyph.width(glyphDimensions_1.vexGlyph.dimensions.dot);
                noteWidth += headWidth +
                    glyphDimensions_1.vexGlyph.dimensions.noteHead.spacingRight * noteSpacing;
                // TODO: Consider engraving font and adjust grace note size?
                noteWidth += (headWidth + glyphDimensions_1.vexGlyph.dimensions.noteHead.spacingRight) * note.graceNotes.length;
                noteWidth += dotWidth * dots + glyphDimensions_1.vexGlyph.dimensions.dot.spacingRight * dots;
                note.pitches.forEach((pitch) => {
                    const keyAccidental = music_1.SmoMusic.getAccidentalForKeySignature(pitch, smoMeasure.keySignature);
                    const accidentals = tmObj.accidentalArray.filter((ar) => ar.duration < duration && ar.pitches[pitch.letter]);
                    const acLen = accidentals.length;
                    const declared = acLen > 0 ?
                        accidentals[acLen - 1].pitches[pitch.letter].pitch.accidental : keyAccidental;
                    if (declared !== pitch.accidental || pitch.cautionary) {
                        noteWidth += glyphDimensions_1.vexGlyph.accidentalWidth(pitch.accidental);
                    }
                });
                let verse = 0;
                let lyricBase = note.getLyricForVerse(verse, noteModifiers_1.SmoLyric.parsers.lyric);
                while (lyricBase.length) {
                    let lyric = lyricBase[0];
                    let lyricWidth = 0;
                    let i = 0;
                    // TODO: kerning and all that...
                    if (!lyric._text.length) {
                        break;
                    }
                    // why did I make this return an array?
                    // oh...because of voices
                    const textFont = VF.TextFormatter.create({ family: lyric.fontInfo.family,
                        size: lyric.fontInfo.size, weight: 'normal' });
                    const lyricText = lyric.getText();
                    for (i = 0; i < lyricText.length; ++i) {
                        lyricWidth += textFont.getWidthForTextInPx(lyricText[i]);
                    }
                    if (lyric.isHyphenated()) {
                        lyricWidth += 2 * textFont.getWidthForTextInPx('-');
                    }
                    else {
                        lyricWidth += 2 * textFont.getWidthForTextInPx('H');
                    }
                    noteWidth = Math.max(lyricWidth, noteWidth);
                    verse += 1;
                    lyricBase = note.getLyricForVerse(verse, noteModifiers_1.SmoLyric.parsers.lyric);
                }
                if (!tickContexts[duration]) {
                    tickContexts[duration] = {
                        widths: [],
                        tickCounts: []
                    };
                }
                tickContexts[duration].widths.push(noteWidth);
                tickContexts[duration].tickCounts.push(note.tickCount);
                duration += Math.round(note.tickCount);
                width += noteWidth;
            });
            widths.push(width);
        });
        widths.sort((a, b) => a > b ? -1 : 1);
        return widths[0];
    }
    static estimateStartSymbolWidth(smoMeasure) {
        let width = 0;
        // the variables starts and digits used to be in the if statements. I moved them here to fix the resulting error
        var starts = smoMeasure.getStartBarline();
        var digits = smoMeasure.timeSignature.timeSignature.split('/')[0].length;
        if (smoMeasure.svg.forceKeySignature) {
            if (smoMeasure.canceledKeySignature) {
                width += glyphDimensions_1.vexGlyph.keySignatureLength(smoMeasure.canceledKeySignature);
            }
            width += glyphDimensions_1.vexGlyph.keySignatureLength(smoMeasure.keySignature);
        }
        if (smoMeasure.svg.forceClef) {
            const clefGlyph = glyphDimensions_1.vexGlyph.clef(smoMeasure.clef);
            width += clefGlyph.width + clefGlyph.spacingRight;
        }
        if (smoMeasure.svg.forceTimeSignature) {
            width += glyphDimensions_1.vexGlyph.width(glyphDimensions_1.vexGlyph.dimensions.timeSignature) * digits + glyphDimensions_1.vexGlyph.dimensions.timeSignature.spacingRight;
        }
        if (starts) {
            width += glyphDimensions_1.vexGlyph.barWidth(starts);
        }
        return width;
    }
    static estimateEndSymbolWidth(smoMeasure) {
        var width = 0;
        var ends = smoMeasure.getEndBarline();
        if (ends) {
            width += glyphDimensions_1.vexGlyph.barWidth(ends);
        }
        return width;
    }
    estimateMeasureWidth(measure, scoreLayout, tickContexts) {
        const noteSpacing = scoreLayout.noteSpacing;
        // Calculate the existing staff width, based on the notes and what we expect to be rendered.
        let measureWidth = SuiLayoutFormatter.estimateMusicWidth(measure, noteSpacing, tickContexts);
        measure.svg.adjX = SuiLayoutFormatter.estimateStartSymbolWidth(measure);
        measure.svg.adjRight = SuiLayoutFormatter.estimateEndSymbolWidth(measure);
        measureWidth += measure.svg.adjX + measure.svg.adjRight + measure.format.customStretch + measure.format.padLeft;
        const y = measure.svg.logicalBox.y;
        // For systems that start with padding, add width for the padding
        measure.setWidth(measureWidth, 'estimateMeasureWidth adjX adjRight');
        // Calculate the space for left/right text which displaces the measure.
        // measure.setX(measure.staffX  + textOffsetBox.x,'estimateMeasureWidth');
        measure.setBox(svgHelpers_1.SvgHelpers.boxPoints(measure.staffX, y, measure.staffWidth, measure.svg.logicalBox.height), 'estimate measure width');
    }
    static _beamGroupForNote(measure, note) {
        let rv = null;
        if (!note.beam_group) {
            return null;
        }
        measure.beamGroups.forEach((bg) => {
            if (!rv) {
                if (bg.notes.findIndex((note) => note.beam_group && note.beam_group.id === bg.attrs.id) >= 0) {
                    rv = bg;
                }
            }
        });
        return rv;
    }
    /**
     * A system has gone beyond the page width.  Lop the last measure off the end and move it to the first measure of the
     * next system.  Then seal the last system by justifying the measures vertically and horinzontally
     * @param scoreLayout
     * @param measureEstimate
     * @param currentLine
     * @param columnCount
     * @param lastSystem
     */
    justifyY(scoreLayout, rowCount, currentLine, lastSystem) {
        let i = 0;
        const sh = svgHelpers_1.SvgHelpers;
        // If there are fewer measures in the system than the max, don't justify.
        // We estimate the staves at the same absolute y value.
        // Now, move them down so the top of the staves align for all measures in a  row.
        const measuresToHide = [];
        let anyNotes = false;
        for (i = 0; i < rowCount; ++i) {
            // lowest staff has greatest staffY value.
            const rowAdj = currentLine.filter((mm) => mm.svg.rowInSystem === i);
            const lowestStaff = rowAdj.reduce((a, b) => a.staffY > b.staffY ? a : b);
            const hasNotes = rowAdj.findIndex((x) => x.isRest() === false) >= 0;
            if (hasNotes) {
                anyNotes = true;
            }
            rowAdj.forEach((measure) => {
                measure.svg.hideEmptyMeasure = false;
                if (this.score.preferences.hideEmptyLines && !hasNotes && !this.score.isPartExposed()) {
                    measuresToHide.push(measure);
                }
                const adj = lowestStaff.staffY - measure.staffY;
                measure.setY(measure.staffY + adj, 'justifyY');
                measure.setBox(sh.boxPoints(measure.svg.logicalBox.x, measure.svg.logicalBox.y + adj, measure.svg.logicalBox.width, measure.svg.logicalBox.height), 'justifyY');
            });
            const rightStaff = rowAdj.reduce((a, b) => a.staffX + a.staffWidth > b.staffX + b.staffWidth ? a : b);
            const ld = layoutDebug_1.layoutDebug;
            let justifyX = 0;
            let columnCount = rowAdj.length;
            // missing offset is for systems that have fewer measures than the default (due to section break or score ending)
            let missingOffset = 0;
            if (scoreLayout.maxMeasureSystem > 1 &&
                columnCount < scoreLayout.maxMeasureSystem
                && lastSystem) {
                missingOffset = (scoreLayout.pageWidth / (scoreLayout.maxMeasureSystem + 1)) * (scoreLayout.maxMeasureSystem - columnCount);
                columnCount = scoreLayout.maxMeasureSystem;
            }
            if (scoreLayout.maxMeasureSystem > 1 || !lastSystem) {
                justifyX = Math.round((scoreLayout.pageWidth - (scoreLayout.leftMargin + scoreLayout.rightMargin + rightStaff.staffX + rightStaff.staffWidth + missingOffset))
                    / columnCount);
            }
            let justOffset = 0;
            rowAdj.forEach((measure) => {
                measure.setWidth(measure.staffWidth + justifyX, '_estimateMeasureDimensions justify');
                measure.setX(measure.staffX + justOffset, 'justifyY');
                measure.setBox(sh.boxPoints(measure.svg.logicalBox.x + justOffset, measure.svg.logicalBox.y, measure.staffWidth, measure.svg.logicalBox.height), 'justifyY');
                const context = this.svg.getRenderer(measure.svg.logicalBox);
                if (context) {
                    ld.debugBox(context.svg, measure.svg.logicalBox, layoutDebug_1.layoutDebug.values.adjust);
                }
                justOffset += justifyX;
            });
        }
        if (this.score.preferences.hideEmptyLines && anyNotes) {
            let adjY = 0;
            for (i = 0; i < rowCount; ++i) {
                const rowAdj = measuresToHide.filter((mm) => mm.svg.rowInSystem === i);
                if (rowAdj.length) {
                    adjY += rowAdj[0].svg.logicalBox.height;
                    rowAdj.forEach((mm) => {
                        mm.svg.logicalBox.height = 0;
                        mm.svg.hideEmptyMeasure = true;
                    });
                }
                else {
                    const rowAdj = currentLine.filter((mm) => mm.svg.rowInSystem === i);
                    rowAdj.forEach((row) => {
                        row.setY(row.svg.staffY - adjY, 'format-hide');
                    });
                }
            }
        }
    }
    // ### _highestLowestHead
    // highest value is actually the one lowest on the page
    static _highestLowestHead(measure, note) {
        const hilo = { hi: 0, lo: 9999999 };
        note.pitches.forEach((pitch) => {
            // 10 pixels per line
            const ledger = music_1.SmoMusic.pitchToLedgerLine(measure.clef, pitch);
            const noteHeight = ledger > 0 ? 10 : -10;
            const px = (10 * ledger) + noteHeight;
            hilo.lo = Math.min(hilo.lo, px);
            hilo.hi = Math.max(hilo.hi, px);
        });
        return hilo;
    }
    static textFont(lyric) {
        return VF.TextFormatter.create(lyric.fontInfo);
    }
    /**
     * Calculate the dimensions of symbols based on where in a system we are, like whether we need to show
     * the key signature, clef etc.
     * @param systemIndex
     * @param measure
     * @param clefLast
     * @param keySigLast
     * @param timeSigLast
     * @param tempoLast
     * @param score
     */
    calculateBeginningSymbols(systemIndex, measure, clefLast, keySigLast, timeSigLast, tempoLast) {
        var _a, _b, _c;
        // The key signature is set based on the transpose index already, i.e. an Eb part in concert C already has 3 sharps.
        const xposeScore = ((_b = (_a = this.score) === null || _a === void 0 ? void 0 : _a.preferences) === null || _b === void 0 ? void 0 : _b.transposingScore) && (((_c = this.score) === null || _c === void 0 ? void 0 : _c.isPartExposed()) === false);
        const xposeOffset = xposeScore ? measure.transposeIndex : 0;
        const measureKeySig = music_1.SmoMusic.vexKeySignatureTranspose(measure.keySignature, xposeOffset);
        measure.svg.forceClef = (systemIndex === 0 || measure.clef !== clefLast);
        measure.svg.forceTimeSignature = (measure.measureNumber.measureIndex === 0 ||
            (!measure_1.SmoMeasure.timeSigEqual(timeSigLast, measure.timeSignature)) || measure.timeSignatureString.length > 0);
        if (measure.timeSignature.display === false) {
            measure.svg.forceTimeSignature = false;
        }
        measure.svg.forceTempo = false;
        const tempo = measure.getTempo();
        if (tempo && measure.measureNumber.measureIndex === 0) {
            measure.svg.forceTempo = tempo.display && measure.svg.rowInSystem === 0;
        }
        else if (tempo && tempoLast) {
            if (!measureModifiers_1.SmoTempoText.eq(tempo, tempoLast) && measure.svg.rowInSystem === 0) {
                measure.svg.forceTempo = tempo.display;
            }
        }
        else if (tempo) {
            measure.svg.forceTempo = tempo.display && measure.svg.rowInSystem === 0;
        }
        if (measureKeySig !== keySigLast && measure.measureNumber.measureIndex > 0) {
            measure.canceledKeySignature = music_1.SmoMusic.vexKeySigWithOffset(keySigLast, xposeOffset);
            measure.svg.forceKeySignature = true;
        }
        else if (systemIndex === 0 && measureKeySig !== 'C') {
            measure.svg.forceKeySignature = true;
        }
        else {
            measure.svg.forceKeySignature = false;
        }
    }
    /**
     * The baseline is the top line of the staff.  aboveBaseline is a negative number
     * that indicates how high above the baseline the measure goes.  belowBaseline
     * is a positive number that indicates how far below the baseline the measure goes.
     * the height of the measure is below-above.  Vex always renders a staff such that
     * the y coordinate passed in for the stave is on the baseline.
     *
     * Note to past self: this was a really useful comment.  Thank you.
     * **/
    estimateMeasureHeight(measure) {
        let yTop = 0; // highest point, smallest Y value
        let yBottom = measure.lines * 10; // lowest point, largest Y value.
        let flag = -1;
        let lyricOffset = 0;
        const measureIndex = measure.measureNumber.measureIndex;
        const staffIndex = measure.measureNumber.staffId;
        const stave = this.score.staves[staffIndex];
        stave.renderableModifiers.forEach((mm) => {
            if (mm.startSelector.staff === staffIndex && (mm.startSelector.measure <= measureIndex && mm.endSelector.measure >= measureIndex) ||
                mm.endSelector.staff === staffIndex &&
                    (mm.endSelector.measure <= measureIndex && mm.endSelector.measure >= measureIndex && mm.endSelector.measure !== mm.startSelector.measure)) {
                if (mm.ctor === 'SmoHairpin') {
                    const hp = mm;
                    if (hp.position === staffModifiers_1.SmoStaffHairpin.positions.ABOVE) {
                        yTop = yTop - hp.height;
                    }
                    else {
                        yBottom = yBottom + hp.height;
                    }
                }
                else if (mm.ctor === 'SmoStaffTextBracket') {
                    const tb = mm;
                    const tbHeight = 14 + (10 * Math.abs(tb.line - 1)); // 14 default font size
                    if (tb.position === staffModifiers_1.SmoStaffTextBracket.positions.TOP) {
                        yTop = yTop - tbHeight;
                    }
                    else {
                        yBottom = yBottom + tbHeight;
                    }
                }
            }
        });
        if (measure.svg.forceClef) {
            yBottom += glyphDimensions_1.vexGlyph.clef(measure.clef).yTop + glyphDimensions_1.vexGlyph.clef(measure.clef).yBottom;
            yTop = yTop - glyphDimensions_1.vexGlyph.clef(measure.clef).yTop;
        }
        if (measure.svg.forceTempo) {
            yTop = Math.min(-1 * glyphDimensions_1.vexGlyph.tempo.yTop, yTop);
        }
        measure.voices.forEach((voice) => {
            voice.notes.forEach((note) => {
                const bg = SuiLayoutFormatter._beamGroupForNote(measure, note);
                flag = note_1.SmoNote.flagStates.auto;
                if (bg && note.noteType === 'n') {
                    flag = bg.notes[0].flagState;
                    // an  auto-flag note is up if the 1st note is middle line
                    if (flag === note_1.SmoNote.flagStates.auto) {
                        const pitch = bg.notes[0].pitches[0];
                        flag = music_1.SmoMusic.pitchToLedgerLine(measure.clef, pitch)
                            >= 2 ? note_1.SmoNote.flagStates.up : note_1.SmoNote.flagStates.down;
                    }
                }
                else {
                    flag = note.flagState;
                    // an  auto-flag note is up if the 1st note is middle line
                    if (flag === note_1.SmoNote.flagStates.auto) {
                        const pitch = note.pitches[0];
                        flag = music_1.SmoMusic.pitchToLedgerLine(measure.clef, pitch)
                            >= 2 ? note_1.SmoNote.flagStates.up : note_1.SmoNote.flagStates.down;
                    }
                }
                const hiloHead = SuiLayoutFormatter._highestLowestHead(measure, note);
                if (flag === note_1.SmoNote.flagStates.down) {
                    yTop = Math.min(hiloHead.lo, yTop);
                    yBottom = Math.max(hiloHead.hi + glyphDimensions_1.vexGlyph.stem.height, yBottom);
                }
                else {
                    yTop = Math.min(hiloHead.lo - glyphDimensions_1.vexGlyph.stem.height, yTop);
                    yBottom = Math.max(hiloHead.hi, yBottom);
                }
                // Lyrics will be rendered below the lowest thing on the staff, so add to
                // belowBaseline value based on the max number of verses and font size
                // it will extend
                const lyrics = note.getTrueLyrics();
                if (lyrics.length) {
                    const maxLyric = lyrics.reduce((a, b) => a.verse > b.verse ? a : b);
                    const fontInfo = SuiLayoutFormatter.textFont(maxLyric);
                    lyricOffset = Math.max((maxLyric.verse + 2) * fontInfo.maxHeight, lyricOffset);
                }
                const dynamics = note.getModifiers('SmoDynamicText');
                dynamics.forEach((dyn) => {
                    yBottom = Math.max((10 * dyn.yOffsetLine - 50) + 11, yBottom);
                    yTop = Math.min(10 * dyn.yOffsetLine - 50, yTop);
                });
                note.articulations.forEach((articulation) => {
                    if (articulation.position === noteModifiers_1.SmoArticulation.positions.above) {
                        yTop -= 10;
                    }
                    else {
                        yBottom += 10;
                    }
                });
                note.ornaments.forEach((ornament) => {
                    if (ornament.position === noteModifiers_1.SmoOrnament.positions.above) {
                        yTop -= 10;
                    }
                    else {
                        yBottom += 10;
                    }
                });
            });
        });
        yBottom += lyricOffset;
        return { belowBaseline: yBottom, aboveBaseline: yTop };
    }
}
exports.SuiLayoutFormatter = SuiLayoutFormatter;


/***/ }),

/***/ "./src/render/sui/layoutDebug.ts":
/*!***************************************!*\
  !*** ./src/render/sui/layoutDebug.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.layoutDebug = void 0;
// [Smoosic](https://github.com/AaronDavidNewman/Smoosic)
// Copyright (c) Aaron David Newman 2021.
const svgHelpers_1 = __webpack_require__(/*! ./svgHelpers */ "./src/render/sui/svgHelpers.ts");
const VF = eval('Vex.Flow');
class layoutDebug {
    static get values() {
        return {
            pre: 1,
            play: 2,
            adjust: 4,
            system: 8,
            scroll: 16,
            artifactMap: 32,
            mouseDebug: 64,
            dragDebug: 128,
            dialogEvents: 256,
            cursor: 512
        };
    }
    static get classes() {
        return {
            1: 'measure-place-dbg',
            2: 'measure-play-dbg',
            4: 'measure-adjust-dbg',
            8: 'system-place-dbg',
            16: 'scroll-box-debug',
            32: 'measure-adjustHeight-dbg',
            64: 'mouse-debug',
            128: 'drag-debug',
            256: '',
            512: 'cursor-adj-dbg',
        };
    }
    static get codeRegions() {
        return {
            COMPUTE: 0,
            PREFORMATA: 1,
            PREFORMATB: 2,
            PREFORMATC: 3,
            FORMAT: 4,
            RENDER: 5,
            UPDATE_MAP: 6,
            POST_RENDER: 7,
            MAP: 8,
            LAST: 8
        };
    }
    static get codeRegionStrings() {
        return ['COMPUTE', 'PREFORMATA', 'PREFORMATB', 'PREFORMATC', 'FORMAT', 'RENDER', 'UPDATE_MAP', 'POST_RENDER', 'MAP'];
    }
    static clearTimestamps() {
        for (var i = 0; i <= layoutDebug.codeRegions.LAST; ++i) {
            layoutDebug.timestampHash[i] = 0;
        }
    }
    static setTimestamp(region, millis) {
        layoutDebug.timestampHash[region] += millis;
    }
    static printTimeReport() {
        let total = 0;
        let report = {};
        let i = 0;
        for (i = 0; i <= layoutDebug.codeRegions.LAST; ++i) {
            total += layoutDebug.timestampHash[i];
            report[layoutDebug.codeRegionStrings[i]] = {
                time: layoutDebug.timestampHash[i], percent: 0
            };
        }
        report['total'] = { time: total, percent: 100 };
        for (i = 0; i <= layoutDebug.codeRegions.LAST; ++i) {
            report[layoutDebug.codeRegionStrings[i]].percent =
                Math.round((report[layoutDebug.codeRegionStrings[i]].time * 100) / report.total.time);
        }
        console.log(JSON.stringify(report, null, ' '));
    }
    static flagSet(value) {
        return layoutDebug.mask & value;
    }
    static clearAll() {
        layoutDebug.mask = 0;
    }
    static setAll() {
        layoutDebug.mask = 1 + 2 + 4 + 8 + 16 + 32 + 64 + 128 + 256;
    }
    static setRenderFlags() {
        layoutDebug.mask = 1 + 2 + 4 + 8 + 16 + 32;
    }
    static clearDebugBoxes(value) {
        if (layoutDebug.flagSet(value)) {
            var selector = 'g.' + layoutDebug.classes[value];
            $(selector).remove();
        }
    }
    static debugBox(svg, box, flag) {
        if (!box) {
            return;
        }
        if (!box.height) {
            box.height = 1;
        }
        if (layoutDebug.flagSet(flag)) {
            svgHelpers_1.SvgHelpers.debugBox(svg, box, layoutDebug.classes[flag], 0);
        }
    }
    static setFlag(value) {
        var flag = layoutDebug.values[value];
        if (typeof (layoutDebug.mask) == 'undefined') {
            layoutDebug.mask = flag;
            return;
        }
        layoutDebug.mask |= flag;
        layoutDebug.setFlagDivs();
    }
    static setFlagDivs() {
        $('.scroll-box-debug').remove();
        $('.drag-debug').remove();
        $('.mouse-debug').remove();
        $('.play-debug').remove();
        if (layoutDebug.mask & layoutDebug.values.scroll) {
            const dbgDiv = $('<div class="scroll-box-debug"/>');
            $('body').append(dbgDiv);
        }
        if (layoutDebug.mask & layoutDebug.values.mouseDebug) {
            const dbgDiv = $('<div class="mouse-debug"/>');
            $('body').append(dbgDiv);
        }
        if (layoutDebug.mask & layoutDebug.values.dragDebug) {
            const dbgDiv = $('<div class="drag-debug"/>');
            $('body').append(dbgDiv);
        }
        if (layoutDebug.mask & layoutDebug.values.play) {
            const dbgDiv = $('<div class="play-debug"/>');
            $('body').append(dbgDiv);
        }
    }
    static updateScrollDebug(point) {
        const displayString = 'X: ' + point.x + ' Y: ' + point.y;
        $('.scroll-box-debug').text(displayString);
        $('.scroll-box-debug').css('left', '2%').css('top', '20px');
    }
    static updateMouseDebug(client, logical, offset) {
        const displayString = `clientX: ${client.x} clientY: ${client.y} svg: (${logical.x},${logical.y}) offset (${offset.x}, ${offset.y})`;
        $('.mouse-debug').text(displayString);
        $('.mouse-debug').css('left', '2%').css('top', '60px').css('position', 'absolute').css('font-size', '11px');
    }
    static updateDragDebug(client, logical, state) {
        const displayString = `clientX: ${client.x} clientY: ${client.y} svg: (${logical.x},${logical.y}) state ${state})`;
        $('.drag-debug').text(displayString);
        $('.drag-debug').css('left', '2%').css('top', '80px').css('position', 'absolute').css('font-size', '11px');
    }
    static updatePlayDebug(selector, logical) {
        const displayString = `mm: ${selector.measure} tick: ${selector.tick} svg: (${logical.x},${logical.y}, ${logical.width}, ${logical.height})`;
        $('.play-debug').text(displayString);
        $('.play-debug').css('left', '2%').css('top', '100px').css('position', 'absolute').css('font-size', '11px');
    }
    static addTextDebug(value) {
        layoutDebug._textDebug.push(value);
        console.log(value);
    }
    static addDialogDebug(value) {
        layoutDebug._dialogEvents.push(value);
        console.log(value);
    }
    static measureHistory(measure, oldVal, newVal, description) {
        if (layoutDebug.flagSet(layoutDebug.values.measureHistory)) {
            var oldExp = (typeof (measure.svg[oldVal]) == 'object') ?
                JSON.stringify(measure.svg[oldVal]).replace(/"/g, '') : measure.svg[oldVal];
            var newExp = (typeof (newVal) == 'object') ? JSON.stringify(newVal).replace(/"/g, '') : newVal;
            measure.svg.history.push(oldVal + ': ' + oldExp + '=> ' + newExp + ' ' + description);
        }
    }
}
exports.layoutDebug = layoutDebug;
layoutDebug.mask = 0;
layoutDebug._textDebug = [];
layoutDebug.timestampHash = {};
layoutDebug._dialogEvents = [];


/***/ }),

/***/ "./src/render/sui/mapper.ts":
/*!**********************************!*\
  !*** ./src/render/sui/mapper.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SuiMapper = void 0;
// [Smoosic](https://github.com/AaronDavidNewman/Smoosic)
// Copyright (c) Aaron David Newman 2021.
const selections_1 = __webpack_require__(/*! ../../smo/xform/selections */ "./src/smo/xform/selections.ts");
const svgHelpers_1 = __webpack_require__(/*! ./svgHelpers */ "./src/render/sui/svgHelpers.ts");
const layoutDebug_1 = __webpack_require__(/*! ./layoutDebug */ "./src/render/sui/layoutDebug.ts");
const common_1 = __webpack_require__(/*! ../../smo/data/common */ "./src/smo/data/common.ts");
const svgPageMap_1 = __webpack_require__(/*! ./svgPageMap */ "./src/render/sui/svgPageMap.ts");
/**
 * Map the notes in the svg so they can respond to events and interact
 * with the mouse/keyboard
 * @category SuiRender
 */
class SuiMapper {
    constructor(renderer, scroller, pasteBuffer) {
        // measure to selector map
        this.measureNoteMap = {};
        // notes currently selected.  Something is always selected
        // modifiers (text etc.) that have been selected
        this.modifierSelections = [];
        this.selections = [];
        // The list of modifiers near the current selection
        this.localModifiers = [];
        this.modifierIndex = -1;
        this.modifierSuggestion = null;
        this.pitchIndex = -1;
        // By default, defer highlights for performance.
        this.deferHighlightMode = true;
        this.suggestion = null;
        this.mouseHintBox = null;
        this.selectionRects = {};
        this.outlines = {};
        this.mapping = false;
        // renderer renders the music when it changes
        this.renderer = renderer;
        this.scroller = scroller;
        this.modifierIndex = -1;
        this.localModifiers = [];
        // index if a single pitch of a chord is selected
        this.pitchIndex = -1;
        // the current selection, which is also the copy/paste destination
        this.pasteBuffer = pasteBuffer;
        this.highlightQueue = { selectionCount: 0, deferred: false };
    }
    updateHighlight() {
        const self = this;
        if (this.selections.length === 0) {
            this.highlightQueue.deferred = false;
            this.highlightQueue.selectionCount = 0;
            return;
        }
        if (this.highlightQueue.selectionCount === this.selections.length) {
            this.highlightSelection();
            this.highlightQueue.deferred = false;
        }
        else {
            this.highlightQueue.selectionCount = this.selections.length;
            setTimeout(() => {
                self.updateHighlight();
            }, 50);
        }
    }
    deferHighlight() {
        if (!this.deferHighlightMode) {
            this.highlightSelection();
        }
        const self = this;
        if (!this.highlightQueue.deferred) {
            this.highlightQueue.deferred = true;
            setTimeout(() => {
                self.updateHighlight();
            }, 50);
        }
    }
    _createLocalModifiersList() {
        this.localModifiers = [];
        let index = 0;
        this.selections.forEach((sel) => {
            var _a, _b;
            (_a = sel.note) === null || _a === void 0 ? void 0 : _a.getGraceNotes().forEach((gg) => {
                var _a;
                this.localModifiers.push({ index, selection: sel, modifier: gg, box: (_a = gg.logicalBox) !== null && _a !== void 0 ? _a : common_1.SvgBox.default });
                index += 1;
            });
            (_b = sel.note) === null || _b === void 0 ? void 0 : _b.getModifiers('SmoDynamicText').forEach((dyn) => {
                var _a;
                this.localModifiers.push({ index, selection: sel, modifier: dyn, box: (_a = dyn.logicalBox) !== null && _a !== void 0 ? _a : common_1.SvgBox.default });
                index += 1;
            });
            sel.measure.getModifiersByType('SmoVolta').forEach((volta) => {
                var _a;
                this.localModifiers.push({ index, selection: sel, modifier: volta, box: (_a = volta.logicalBox) !== null && _a !== void 0 ? _a : common_1.SvgBox.default });
                index += 1;
            });
            sel.measure.getModifiersByType('SmoTempoText').forEach((tempo) => {
                var _a;
                this.localModifiers.push({ index, selection: sel, modifier: tempo, box: (_a = tempo.logicalBox) !== null && _a !== void 0 ? _a : common_1.SvgBox.default });
                index += 1;
            });
            sel.staff.getModifiers().forEach((mod) => {
                if (selections_1.SmoSelector.gteq(sel.selector, mod.startSelector) &&
                    selections_1.SmoSelector.lteq(sel.selector, mod.endSelector) && mod.logicalBox) {
                    const exists = this.localModifiers.find((mm) => mm.modifier.ctor === mod.ctor);
                    if (!exists) {
                        this.localModifiers.push({ index, selection: sel, modifier: mod, box: mod.logicalBox });
                        index += 1;
                    }
                }
            });
        });
    }
    /**
     * When a modifier is selected graphically, update the selection list
     * and create a local modifier list
     * @param modifierTabs
     */
    createLocalModifiersFromModifierTabs(modifierTabs) {
        const selections = [];
        const modMap = {};
        modifierTabs.forEach((mt) => {
            if (mt.selection) {
                const key = selections_1.SmoSelector.getNoteKey(mt.selection.selector);
                if (!modMap[key]) {
                    selections.push(mt.selection);
                    modMap[key] = true;
                }
            }
        });
        if (selections.length) {
            this.selections = selections;
            this._createLocalModifiersList();
            this.deferHighlight();
        }
    }
    // used by remove dialogs to clear removed thing
    clearModifierSelections() {
        this.modifierSelections = [];
        this._createLocalModifiersList();
        this.modifierIndex = -1;
        if (this.outlines['staffModifier'] && this.outlines['staffModifier'].element) {
            this.outlines['staffModifier'].element.remove();
            this.outlines['staffModifier'].element = undefined;
        }
        // this.eraseRect('staffModifier');  not sure where this should go
    }
    // ### loadScore
    // We are loading a new score.  clear the maps so we can rebuild them after
    // rendering
    loadScore() {
        this.measureNoteMap = {};
        this.clearModifierSelections();
        this.selections = [];
        this.highlightQueue = { selectionCount: 0, deferred: false };
    }
    // ### _clearMeasureArtifacts
    // clear the measure from the measure and note maps so we can rebuild it.
    clearMeasureMap(measure) {
        const selector = { staff: measure.measureNumber.staffId, measure: measure.measureNumber.measureIndex, voice: 0, tick: 0, pitches: [] };
        // Unselect selections in this measure so we can reselect them when re-tracked
        const ar = [];
        this.selections.forEach((selection) => {
            if (selection.selector.staff !== selector.staff || selection.selector.measure !== selector.measure) {
                ar.push(selection);
            }
        });
        this.selections = ar;
    }
    _copySelectionsByMeasure(staffIndex, measureIndex) {
        const rv = this.selections.filter((sel) => sel.selector.staff === staffIndex && sel.selector.measure === measureIndex);
        const ticks = rv.length < 1 ? 0 : rv.map((sel) => sel.note.tickCount).reduce((a, b) => a + b);
        const selectors = [];
        rv.forEach((sel) => {
            const nsel = JSON.parse(JSON.stringify(sel.selector));
            if (!nsel.pitches) {
                nsel.pitches = [];
            }
            selectors.push(nsel);
        });
        return { ticks, selectors };
    }
    deleteMeasure(selection) {
        const selCopy = this._copySelectionsByMeasure(selection.selector.staff, selection.selector.measure)
            .selectors;
        this.clearMeasureMap(selection.measure);
        if (selCopy.length) {
            selCopy.forEach((selector) => {
                const nsel = JSON.parse(JSON.stringify(selector));
                if (selector.measure === 0) {
                    nsel.measure += 1;
                }
                else {
                    nsel.measure -= 1;
                }
                this.selections.push(this._getClosestTick(nsel));
            });
        }
    }
    _updateNoteModifier(selection, modMap, modifier, ix) {
        if (!modMap[modifier.attrs.id] && modifier.logicalBox) {
            this.renderer.pageMap.addModifierTab({
                modifier,
                selection,
                box: modifier.logicalBox,
                index: ix
            });
            ix += 1;
            const context = this.renderer.pageMap.getRendererFromModifier(modifier);
            modMap[modifier.attrs.id] = true;
        }
        return ix;
    }
    _updateModifiers() {
        let ix = 0;
        const modMap = {};
        if (!this.renderer.score) {
            return;
        }
        this.renderer.score.textGroups.forEach((modifier) => {
            if (!modMap[modifier.attrs.id] && modifier.logicalBox) {
                this.renderer.pageMap.addModifierTab({
                    modifier,
                    selection: null,
                    box: modifier.logicalBox,
                    index: ix
                });
                ix += 1;
            }
        });
        const keys = Object.keys(this.measureNoteMap);
        keys.forEach((selKey) => {
            var _a, _b;
            const selection = this.measureNoteMap[selKey];
            selection.staff.renderableModifiers.forEach((modifier) => {
                if (selections_1.SmoSelector.contains(selection.selector, modifier.startSelector, modifier.endSelector)) {
                    if (!modMap[modifier.attrs.id]) {
                        if (modifier.logicalBox) {
                            this.renderer.pageMap.addModifierTab({
                                modifier,
                                selection,
                                box: modifier.logicalBox,
                                index: ix
                            });
                            ix += 1;
                            modMap[modifier.attrs.id] = true;
                        }
                    }
                }
            });
            selection.measure.modifiers.forEach((modifier) => {
                if (modifier.attrs.id
                    && !modMap[modifier.attrs.id]
                    && modifier.logicalBox) {
                    this.renderer.pageMap.addModifierTab({
                        modifier,
                        selection,
                        box: svgHelpers_1.SvgHelpers.smoBox(modifier.logicalBox),
                        index: ix
                    });
                    ix += 1;
                    modMap[modifier.attrs.id] = true;
                }
            });
            (_a = selection.note) === null || _a === void 0 ? void 0 : _a.textModifiers.forEach((modifier) => {
                if (modifier.logicalBox) {
                    ix = this._updateNoteModifier(selection, modMap, modifier, ix);
                }
            });
            (_b = selection.note) === null || _b === void 0 ? void 0 : _b.graceNotes.forEach((modifier) => {
                ix = this._updateNoteModifier(selection, modMap, modifier, ix);
            });
        });
    }
    // ### _getClosestTick
    // given a musical selector, find the note artifact that is closest to it,
    // if an exact match is not available
    _getClosestTick(selector) {
        let tickKey = '';
        const measureKey = Object.keys(this.measureNoteMap).find((k) => selections_1.SmoSelector.sameMeasure(this.measureNoteMap[k].selector, selector)
            && this.measureNoteMap[k].selector.tick === 0);
        tickKey = Object.keys(this.measureNoteMap).find((k) => selections_1.SmoSelector.sameNote(this.measureNoteMap[k].selector, selector));
        const firstObj = this.measureNoteMap[Object.keys(this.measureNoteMap)[0]];
        if (tickKey) {
            return this.measureNoteMap[tickKey];
        }
        if (measureKey) {
            return this.measureNoteMap[measureKey];
        }
        return firstObj;
    }
    // ### _setModifierBoxes
    // Create the DOM modifiers for the lyrics and other modifiers
    _setModifierBoxes(measure) {
        const context = this.renderer.pageMap.getRenderer(measure.svg.logicalBox);
        measure.voices.forEach((voice) => {
            voice.notes.forEach((smoNote) => {
                if (context) {
                    const el = context.svg.getElementById(smoNote.renderId);
                    if (el) {
                        svgHelpers_1.SvgHelpers.updateArtifactBox(context, el, smoNote);
                        // TODO: fix this, only works on the first line.
                        smoNote.getModifiers('SmoLyric').forEach((lyrict) => {
                            const lyric = lyrict;
                            if (lyric.getText().length || lyric.isHyphenated()) {
                                const lyricElement = context.svg.getElementById('vf-' + lyric.attrs.id);
                                if (lyricElement) {
                                    svgHelpers_1.SvgHelpers.updateArtifactBox(context, lyricElement, lyric);
                                }
                            }
                        });
                    }
                    smoNote.graceNotes.forEach((g) => {
                        if (g.element) {
                        }
                        var gel = context.svg.getElementById('vf-' + g.renderId);
                        svgHelpers_1.SvgHelpers.updateArtifactBox(context, gel, g);
                    });
                    smoNote.textModifiers.forEach((modifier) => {
                        if (modifier.logicalBox && modifier.element) {
                            svgHelpers_1.SvgHelpers.updateArtifactBox(context, modifier.element, modifier);
                        }
                    });
                }
            });
        });
    }
    /**
     * returns true of the selections are adjacent
     * @param s1 a selections
     * @param s2 another election
     * @returns
     */
    isAdjacentSelection(s1, s2) {
        if (!this.renderer.score) {
            return false;
        }
        const nextSel = selections_1.SmoSelection.advanceTicks(this.renderer.score, s1, 1);
        if (!nextSel) {
            return false;
        }
        return selections_1.SmoSelector.eq(nextSel.selector, s2.selector);
    }
    areSelectionsAdjacent() {
        let selectionIx = 0;
        for (selectionIx = 0; this.selections.length > 1 && selectionIx < this.selections.length - 1; ++selectionIx) {
            if (!this.isAdjacentSelection(this.selections[selectionIx], this.selections[selectionIx + 1])) {
                return false;
            }
        }
        return true;
    }
    // ### updateMeasure
    // A measure has changed.  Update the music geometry for it
    mapMeasure(staff, measure, printing) {
        let voiceIx = 0;
        let selectedTicks = 0;
        // We try to restore block selections. If all the selections in this block are not adjacent, only restore individual selections
        // if possible
        let adjacentSels = this.areSelectionsAdjacent();
        const lastResortSelection = [];
        let selectionChanged = false;
        let vix = 0;
        let replacedSelectors = 0;
        if (!measure.svg.logicalBox) {
            return;
        }
        this._setModifierBoxes(measure);
        const timestamp = new Date().valueOf();
        // Keep track of any current selections in this measure, we will try to restore them.
        const sels = this._copySelectionsByMeasure(staff.staffId, measure.measureNumber.measureIndex);
        this.clearMeasureMap(measure);
        if (sels.selectors.length) {
            vix = sels.selectors[0].voice;
        }
        sels.selectors.forEach((sel) => {
            sel.voice = vix;
        });
        measure.voices.forEach((voice) => {
            let tick = 0;
            voice.notes.forEach((note) => {
                const selector = {
                    staff: staff.staffId,
                    measure: measure.measureNumber.measureIndex,
                    voice: voiceIx,
                    tick,
                    pitches: []
                };
                if (typeof (note.logicalBox) === 'undefined') {
                    console.warn('note has no box');
                }
                // create a selection for the newly rendered note
                const selection = new selections_1.SmoSelection({
                    selector,
                    _staff: staff,
                    _measure: measure,
                    _note: note,
                    _pitches: [],
                    box: svgHelpers_1.SvgHelpers.smoBox(svgHelpers_1.SvgHelpers.smoBox(note.logicalBox)),
                    type: 'rendered'
                });
                // and add it to the map
                this._updateMeasureNoteMap(selection, printing);
                // If this note is the same location as something that was selected, reselect it
                if (replacedSelectors < sels.selectors.length && selection.selector.tick === sels.selectors[replacedSelectors].tick &&
                    selection.selector.voice === vix) {
                    this.selections.push(selection);
                    // Reselect any pitches.
                    if (sels.selectors[replacedSelectors].pitches.length > 0) {
                        sels.selectors[replacedSelectors].pitches.forEach((pitchIx) => {
                            if (selection.note && selection.note.pitches.length > pitchIx) {
                                selection.selector.pitches.push(pitchIx);
                            }
                        });
                    }
                    const note = selection.note;
                    selectedTicks += note.tickCount;
                    replacedSelectors += 1;
                    selectionChanged = true;
                }
                else if (adjacentSels && selectedTicks > 0 && selectedTicks < sels.ticks && selection.selector.voice === vix) {
                    // try to select the same length of music as was previously selected.  So a 1/4 to 2 1/8, both
                    // are selected
                    replacedSelectors += 1;
                    this.selections.push(selection);
                    selectedTicks += note.tickCount;
                }
                else if (this.selections.length === 0 && sels.selectors.length === 0 && lastResortSelection.length === 0) {
                    lastResortSelection.push(selection);
                }
                tick += 1;
            });
            voiceIx += 1;
        });
        // We deleted all the notes that were selected, select something else
        if (this.selections.length === 0) {
            selectionChanged = true;
            this.selections = lastResortSelection;
        }
        // If there were selections on this measure, highlight them.
        if (selectionChanged) {
            this.deferHighlight();
        }
        layoutDebug_1.layoutDebug.setTimestamp(layoutDebug_1.layoutDebug.codeRegions.MAP, new Date().valueOf() - timestamp);
    }
    _getTicksFromSelections() {
        let rv = 0;
        this.selections.forEach((sel) => {
            if (sel.note) {
                rv += sel.note.tickCount;
            }
        });
        return rv;
    }
    _copySelections() {
        const rv = [];
        this.selections.forEach((sel) => {
            rv.push(sel.selector);
        });
        return rv;
    }
    // ### getExtremeSelection
    // Get the rightmost (1) or leftmost (-1) selection
    getExtremeSelection(sign) {
        let i = 0;
        let rv = this.selections[0];
        for (i = 1; i < this.selections.length; ++i) {
            const sa = this.selections[i].selector;
            if (sa.measure * sign > rv.selector.measure * sign) {
                rv = this.selections[i];
            }
            else if (sa.measure === rv.selector.measure && sa.tick * sign > rv.selector.tick * sign) {
                rv = this.selections[i];
            }
        }
        return rv;
    }
    _selectClosest(selector) {
        var artifact = this._getClosestTick(selector);
        if (!artifact) {
            return;
        }
        if (this.selections.find((sel) => JSON.stringify(sel.selector)
            === JSON.stringify(artifact.selector))) {
            return;
        }
        const note = artifact.note;
        if (selector.pitches && selector.pitches.length && selector.pitches.length <= note.pitches.length) {
            // If the old selection had only a single pitch, try to recreate that.
            artifact.selector.pitches = JSON.parse(JSON.stringify(selector.pitches));
        }
        this.selections.push(artifact);
    }
    // ### updateMap
    // This should be called after rendering the score.  It updates the score to
    // graphics map and selects the first object.
    updateMap() {
        var _a;
        const ts = new Date().valueOf();
        this.mapping = true;
        let tickSelected = 0;
        const selCopy = this._copySelections();
        const ticksSelectedCopy = this._getTicksFromSelections();
        const firstSelection = this.getExtremeSelection(-1);
        this._updateModifiers();
        // Try to restore selection.  If there were none, just select the fist
        // thing in the score
        const firstKey = selections_1.SmoSelector.getNoteKey(selections_1.SmoSelector.default);
        if (!selCopy.length && this.renderer.score) {
            // If there is nothing rendered, don't update tracker
            if (typeof (this.measureNoteMap[firstKey]) !== 'undefined' && !firstSelection)
                this.selections = [this.measureNoteMap[firstKey]];
        }
        else if (this.areSelectionsAdjacent() && this.selections.length > 1) {
            // If there are adjacent selections, restore selections to the ticks that are in the score now
            if (!firstSelection) {
                layoutDebug_1.layoutDebug.setTimestamp(layoutDebug_1.layoutDebug.codeRegions.UPDATE_MAP, new Date().valueOf() - ts);
                return;
            }
            this.selections = [];
            this._selectClosest(firstSelection.selector);
            const first = this.selections[0];
            tickSelected = (_a = first.note.tickCount) !== null && _a !== void 0 ? _a : 0;
            while (tickSelected < ticksSelectedCopy && first) {
                let delta = this._growSelectionRight(true);
                if (!delta) {
                    break;
                }
                tickSelected += delta;
            }
        }
        this.deferHighlight();
        this._createLocalModifiersList();
        this.mapping = false;
        layoutDebug_1.layoutDebug.setTimestamp(layoutDebug_1.layoutDebug.codeRegions.UPDATE_MAP, new Date().valueOf() - ts);
    }
    createMousePositionBox(logicalBox) {
        const pageMap = this.renderer.pageMap;
        const page = pageMap.getRendererFromPoint(logicalBox);
        if (page) {
            const cof = (pageMap.zoomScale * pageMap.renderScale);
            const debugBox = svgHelpers_1.SvgHelpers.smoBox(logicalBox);
            debugBox.y -= (page.box.y + 5 / cof);
            debugBox.x -= (page.box.x + 5 / cof);
            debugBox.width = 10 / cof;
            debugBox.height = 10 / cof;
            if (!this.mouseHintBox) {
                this.mouseHintBox = {
                    stroke: svgPageMap_1.SvgPageMap.strokes['debug-mouse-box'],
                    classes: 'hide-print',
                    box: debugBox,
                    scroll: { x: 0, y: 0 },
                    context: page,
                    timeOff: 1000
                };
            }
            this.mouseHintBox.context = page;
            this.mouseHintBox.box = debugBox;
            svgHelpers_1.SvgHelpers.outlineRect(this.mouseHintBox);
        }
    }
    eraseMousePositionBox() {
        if (this.mouseHintBox && this.mouseHintBox.element) {
            this.mouseHintBox.element.remove();
            this.mouseHintBox.element = undefined;
        }
    }
    /**
     * Find any musical elements at the supplied screen coordinates and set them as the selection
     * @param bb
     * @returns
     */
    intersectingArtifact(bb) {
        const scrollState = this.scroller.scrollState;
        bb = svgHelpers_1.SvgHelpers.boxPoints(bb.x + scrollState.x, bb.y + scrollState.y, bb.width ? bb.width : 1, bb.height ? bb.height : 1);
        const logicalBox = this.renderer.pageMap.clientToSvg(bb);
        const { selections, page } = this.renderer.pageMap.findArtifact(logicalBox);
        if (page) {
            const artifacts = selections;
            // const artifacts = SvgHelpers.findIntersectingArtifactFromMap(bb, this.measureNoteMap, SvgHelpers.smoBox(this.scroller.scrollState.scroll));
            // TODO: handle overlapping suggestions
            if (!artifacts.length) {
                const sel = this.renderer.pageMap.findModifierTabs(logicalBox);
                if (sel.length) {
                    this._setModifierAsSuggestion(sel[0]);
                    this.eraseMousePositionBox();
                }
                else {
                    // no intersection, show mouse hint          
                    this.createMousePositionBox(logicalBox);
                }
                return;
            }
            const artifact = artifacts[0];
            this.eraseMousePositionBox();
            this._setArtifactAsSuggestion(artifact);
        }
    }
    _getRectangleChain(selection) {
        const rv = [];
        if (!selection.note) {
            return rv;
        }
        rv.push(selection.measure.svg.pageIndex);
        rv.push(selection.measure.svg.lineIndex);
        rv.push(selection.measure.measureNumber.measureIndex);
        return rv;
    }
    _updateMeasureNoteMap(artifact, printing) {
        const note = artifact.note;
        const noteKey = selections_1.SmoSelector.getNoteKey(artifact.selector);
        const activeVoice = artifact.measure.getActiveVoice();
        // not has not been drawn yet.
        if ((!artifact.box) || (!artifact.measure.svg.logicalBox)) {
            return;
        }
        this.measureNoteMap[noteKey] = artifact;
        this.renderer.pageMap.addArtifact(artifact);
        artifact.scrollBox = { x: artifact.box.x,
            y: artifact.measure.svg.logicalBox.y };
    }
}
exports.SuiMapper = SuiMapper;


/***/ }),

/***/ "./src/render/sui/piano.ts":
/*!*********************************!*\
  !*** ./src/render/sui/piano.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SuiPiano = void 0;
// [Smoosic](https://github.com/AaronDavidNewman/Smoosic)
// Copyright (c) Aaron David Newman 2021.
const svgHelpers_1 = __webpack_require__(/*! ./svgHelpers */ "./src/render/sui/svgHelpers.ts");
const htmlHelpers_1 = __webpack_require__(/*! ../../common/htmlHelpers */ "./src/common/htmlHelpers.ts");
class SuiPiano {
    constructor(view) {
        this.octaveOffset = 0;
        this.chordPedal = false;
        this.objects = [];
        this.suggestFadeTimer = null;
        this.elementId = 'piano-svg';
        this.renderElement = document.getElementById(this.elementId);
        this.view = view;
        this.render();
    }
    static get dimensions() {
        return {
            wwidth: 23,
            bwidth: 13,
            wheight: 120,
            bheight: 80,
            octaves: 1
        };
    }
    // 7 white keys per octave
    static get wkeysPerOctave() {
        return 7;
    }
    static get owidth() {
        return SuiPiano.dimensions.wwidth * SuiPiano.wkeysPerOctave;
    }
    static createAndDisplay() {
        // Called by ribbon button.
        $('body').trigger('show-piano-event');
        $('body').trigger('forceScrollEvent');
    }
    _mapKeys() {
        this.objects = [];
        var keys = [].slice.call(this.renderElement.getElementsByClassName('piano-key'));
        keys.forEach((key) => {
            var rect = svgHelpers_1.SvgHelpers.smoBox(key.getBoundingClientRect());
            var id = key.getAttributeNS('', 'id');
            var artifact = {
                keyElement: key,
                box: rect,
                id: id
            };
            this.objects.push(artifact);
        });
    }
    _removeClass(classes) {
        Array.from(this.renderElement.getElementsByClassName('piano-key')).forEach((el) => {
            $(el).removeClass(classes);
        });
    }
    _removeGlow() {
        this._removeClass('glow-key');
    }
    _fadeGlow(el) {
        if (this.suggestFadeTimer) {
            clearTimeout(this.suggestFadeTimer);
        }
        // Make selection fade if there is a selection.
        this.suggestFadeTimer = setTimeout(() => {
            $(el).removeClass('glow-key');
        }, 1000);
    }
    bind() {
        // The menu option to toggle piano state
        $('body').off('show-piano-event').on('show-piano-event', () => {
            const isVisible = $('body').hasClass('show-piano');
            $('body').toggleClass('show-piano');
            this._mapKeys();
        });
        $('#piano-8va-button').off('click').on('click', (ev) => {
            $('#piano-8vb-button').removeClass('activated');
            if (this.octaveOffset === 0) {
                $(ev.currentTarget).addClass('activated');
                this.octaveOffset = 1;
            }
            else {
                $(ev.currentTarget).removeClass('activated');
                this.octaveOffset = 0;
            }
        });
        $('#piano-8vb-button').off('click').on('click', (ev) => {
            $('#piano-8va-button').removeClass('activated');
            if (this.octaveOffset === 0) {
                $(ev.currentTarget).addClass('activated');
                this.octaveOffset = -1;
            }
            else {
                $(ev.currentTarget).removeClass('activated');
                this.octaveOffset = 0;
            }
        });
        $('#piano-xpose-up').off('click').on('click', () => {
            this.view.transposeSelections(1);
        });
        $('#piano-xpose-down').off('click').on('click', () => {
            this.view.transposeSelections(-1);
        });
        $('#piano-enharmonic').off('click').on('click', () => {
            this.view.toggleEnharmonic();
        });
        $('button.jsLeft').off('click').on('click', () => {
            this.view.tracker.moveSelectionLeft();
        });
        $('button.jsRight').off('click').on('click', () => {
            this.view.tracker.moveSelectionRight(this.view.score, null, false);
        });
        $('button.jsGrowDuration').off('click').on('click', () => {
            this.view.batchDurationOperation('doubleDuration');
        });
        $('button.jsGrowDot').off('click').on('click', () => {
            this.view.batchDurationOperation('dotDuration');
        });
        $('button.jsShrinkDuration').off('click').on('click', () => {
            this.view.batchDurationOperation('halveDuration');
        });
        $('button.jsShrinkDot').off('click').on('click', () => {
            this.view.batchDurationOperation('undotDuration');
        });
        $('button.jsChord').off('click').on('click', (ev) => {
            $(ev.currentTarget).toggleClass('activated');
            this.chordPedal = !this.chordPedal;
        });
        $(this.renderElement).off('mousemove').on('mousemove', (ev) => {
            if (Math.abs(this.objects[0].box.x - this.objects[0].keyElement.getBoundingClientRect().x)
                > this.objects[0].box.width / 2) {
                console.log('remap piano');
                this._mapKeys();
            }
            if (!this.renderElement) {
                return;
            }
            const clientBox = svgHelpers_1.SvgHelpers.smoBox(svgHelpers_1.SvgHelpers.boxPoints(ev.clientX, ev.clientY, 1, 1)); // last param is scroll offset
            var keyPressed = svgHelpers_1.SvgHelpers.findSmallestIntersection(clientBox, this.objects);
            if (!keyPressed) {
                return;
            }
            const el = this.renderElement.getElementById(keyPressed.keyElement.id);
            if ($(el).hasClass('glow-key')) {
                return;
            }
            this._removeGlow();
            $(el).addClass('glow-key');
            this._fadeGlow(el);
        });
        $(this.renderElement).off('blur').on('blur', () => {
            this._removeGlow();
        });
        $(this.renderElement).off('click').on('click', (ev) => {
            this._updateSelections(ev);
        });
        // the close button on piano itself
        $('.close-piano').off('click').on('click', () => {
            this.view.score.preferences.showPiano = false;
            this.view.updateScorePreferences(this.view.score.preferences);
        });
    }
    static hidePiano() {
        if ($('body').hasClass('show-piano')) {
            $('body').removeClass('show-piano');
        }
    }
    static showPiano() {
        if ($('body').hasClass('show-piano') === false) {
            $('body').addClass('show-piano');
            // resize the work area.
            // $('body').trigger('forceResizeEvent');
        }
    }
    static get isShowing() {
        return $('body').hasClass('show-piano');
    }
    _updateSelections(ev) {
        // fake a scroller (piano scroller w/b cool tho...)
        if (!this.renderElement) {
            return;
        }
        const logicalBox = svgHelpers_1.SvgHelpers.smoBox({ x: ev.clientX, y: ev.clientY });
        var keyPressed = svgHelpers_1.SvgHelpers.findSmallestIntersection(logicalBox, this.objects);
        if (!keyPressed) {
            return;
        }
        if (!ev.shiftKey && !this.chordPedal) {
            this._removeClass('glow-key pressed-key');
        }
        else {
            var el = this.renderElement.getElementById(keyPressed.keyElement.id);
            $(el).addClass('pressed-key');
        }
        const key = keyPressed.keyElement.id.substr(6, keyPressed.keyElement.id.length - 6);
        const pitch = {
            letter: key[0].toLowerCase(),
            octave: this.octaveOffset,
            accidental: key.length > 1 ? key[1] : 'n'
        };
        this.view.setPitchPiano(pitch, this.chordPedal);
    }
    _renderControls() {
        var b = htmlHelpers_1.buildDom;
        var r = b('button').classes('icon icon-cross close close-piano');
        $('.piano-container .key-right-ctrl').append(r.dom());
        r = b('button').classes('piano-ctrl jsGrowDuration').append(b('span').classes('icon icon-duration_grow'));
        $('.piano-container .key-right-ctrl').append(r.dom());
        r = b('button').classes('piano-ctrl jsShrinkDuration').append(b('span').classes('icon icon-duration_less'));
        $('.piano-container .key-right-ctrl').append(r.dom());
        r = b('button').classes('piano-ctrl jsGrowDot').append(b('span').classes('icon icon-duration_grow_dot'));
        $('.piano-container .key-right-ctrl').append(r.dom());
        r = b('button').classes('piano-ctrl jsShrinkDot').append(b('span').classes('icon icon-duration_less_dot'));
        $('.piano-container .key-right-ctrl').append(r.dom());
        r = b('button').classes('key-ctrl jsLeft').append(b('span').classes('icon icon-arrow-left'));
        $('.piano-container .piano-keys').prepend(r.dom());
        r = b('button').classes('key-ctrl jsRight').append(b('span').classes('icon icon-arrow-right'));
        $('.piano-container .piano-keys').append(r.dom());
        r = b('button').classes('piano-ctrl').attr('id', 'piano-8va-button').append(b('span').classes('bold-italic').text('8')).append(b('sup').classes('italic').text('va'));
        $('.piano-container .key-left-ctrl').append(r.dom());
        r = b('button').classes('piano-ctrl ').attr('id', 'piano-8vb-button').append(b('span').classes('bold-italic').text('8')).append(b('sup').classes('italic').text('vb'));
        $('.piano-container .key-left-ctrl').append(r.dom());
        r = b('button').classes('piano-ctrl jsXposeUp').attr('id', 'piano-xpose-up').append(b('span').classes('bold').text('+'));
        $('.piano-container .key-left-ctrl').append(r.dom());
        r = b('button').classes('piano-ctrl jsXposeDown').attr('id', 'piano-xpose-down').append(b('span').classes('bold').text('-'));
        $('.piano-container .key-left-ctrl').append(r.dom());
        r = b('button').classes('piano-ctrl jsEnharmonic').attr('id', 'piano-enharmonic').append(b('span').classes('bold icon icon-accident'));
        $('.piano-container .key-left-ctrl').append(r.dom());
        r = b('button').classes('piano-ctrl jsChord')
            .append(b('span').classes('icon icon-chords'));
        $('.piano-container .key-left-ctrl').append(r.dom());
    }
    handleResize() {
        this._mapKeys();
    }
    playNote() {
    }
    render() {
        $('body').addClass('show-piano');
        var b = svgHelpers_1.SvgBuilder.b;
        var d = SuiPiano.dimensions;
        // https://www.mathpages.com/home/kmath043.htm
        // Width of white key at back for C,D,E
        var b1off = d.wwidth - (d.bwidth * 2 / 3);
        // Width of other white keys at the back.
        var b2off = d.wwidth - (d.bwidth * 3) / 4;
        var xwhite = [{
                note: 'C',
                x: 0
            }, {
                note: 'D',
                x: d.wwidth
            }, {
                note: 'E',
                x: 2 * d.wwidth
            }, {
                note: 'F',
                x: 3 * d.wwidth
            }, {
                note: 'G',
                x: 4 * d.wwidth
            }, {
                note: 'A',
                x: 5 * d.wwidth
            }, {
                note: 'B',
                x: 6 * d.wwidth
            }
        ];
        var xblack = [{
                note: 'Db',
                x: b1off
            }, {
                note: 'Eb',
                x: 2 * b1off + d.bwidth
            }, {
                note: 'Gb',
                x: 3 * d.wwidth + b2off
            }, {
                note: 'Ab',
                x: (3 * d.wwidth + b2off) + b2off + d.bwidth
            }, {
                note: 'Bb',
                x: SuiPiano.owidth - (b2off + d.bwidth)
            }
        ];
        var wwidth = d.wwidth;
        var bwidth = d.bwidth;
        var wheight = d.wheight;
        var bheight = d.bheight;
        var owidth = SuiPiano.wkeysPerOctave * wwidth;
        // Start on C2 to C6 to reduce space
        var octaveOff = 7 - d.octaves;
        var x = 0;
        var y = 0;
        var r = b('g');
        for (var i = 0; i < d.octaves; ++i) {
            x = i * owidth;
            xwhite.forEach((key) => {
                var nt = key.note;
                var classes = 'piano-key white-key';
                if (nt == 'C4') {
                    classes += ' middle-c';
                }
                var rect = b('rect').attr('id', 'keyId-' + nt).rect(x + key.x, y, wwidth, wheight, classes);
                r.append(rect);
                var tt = b('text').text(x + key.x + (wwidth / 5), bheight + 16, 'note-text', nt);
                r.append(tt);
            });
            xblack.forEach((key) => {
                var nt = key.note;
                var classes = 'piano-key black-key';
                var rect = b('rect').attr('id', 'keyId-' + nt).attr('fill', 'url(#piano-grad)').rect(x + key.x, 0, bwidth, bheight, classes);
                r.append(rect);
            });
        }
        var el = document.getElementById(this.elementId);
        svgHelpers_1.SvgHelpers.gradient(el, 'piano-grad', 'vertical', [{ color: '#000', offset: '0%', opacity: 1 },
            { color: '#777', offset: '50%', opacity: 1 }, { color: '#ddd', offset: '100%', opacity: 1 }]);
        el.appendChild(r.dom());
        this._renderControls();
        this._mapKeys();
        this.bind();
    }
}
exports.SuiPiano = SuiPiano;


/***/ }),

/***/ "./src/render/sui/renderState.ts":
/*!***************************************!*\
  !*** ./src/render/sui/renderState.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SuiRenderState = exports.scoreChangeEvent = void 0;
const undo_1 = __webpack_require__(/*! ../../smo/xform/undo */ "./src/smo/xform/undo.ts");
const promiseHelpers_1 = __webpack_require__(/*! ../../common/promiseHelpers */ "./src/common/promiseHelpers.ts");
const selections_1 = __webpack_require__(/*! ../../smo/xform/selections */ "./src/smo/xform/selections.ts");
const scoreRender_1 = __webpack_require__(/*! ./scoreRender */ "./src/render/sui/scoreRender.ts");
const exceptions_1 = __webpack_require__(/*! ../../ui/exceptions */ "./src/ui/exceptions.ts");
const VF = eval('Vex.Flow');
exports.scoreChangeEvent = 'smoScoreChangeEvent';
/**
 * Manage the state of the score rendering.  The score can be rendered either completely,
 * or partially for editing.  This class works with the RenderDemon to decide when to
 * render the score after it has been modified, and keeps track of what the current
 * render state is (dirty, etc.)
 * @category SuiRender
 * */
class SuiRenderState {
    constructor(config) {
        this.passState = SuiRenderState.passStates.initial;
        this._score = null;
        this._backupZoomScale = 0;
        this.idleLayoutTimer = 0; // how long the score has been idle
        this.handlingRedraw = false;
        // signal to render demon that we have suspended background
        // rendering because we are recording or playing actions.
        this.suspendRendering = false;
        this.undoStatus = 0;
        this.dirty = true;
        this.replaceQ = [];
        this.stateRepCount = 0;
        this.setPassState(SuiRenderState.passStates.initial, 'ctor');
        this.viewportChanged = false;
        this._resetViewport = false;
        this.measureMapper = null;
        this.renderer = new scoreRender_1.SuiScoreRender(config);
        this.idleRedrawTime = config.config.idleRedrawTime;
        this.demonPollTime = config.config.demonPollTime;
        this.undoBuffer = config.undoBuffer;
    }
    get elementId() {
        return this.renderer.elementId;
    }
    get pageMap() {
        return this.renderer.vexContainers;
    }
    // ### setMeasureMapper
    // DI/notifier pattern.  The measure mapper/tracker is updated when the score is rendered
    // so the UI stays in sync with the location of elements in the score.
    setMeasureMapper(mapper) {
        this.measureMapper = mapper;
        this.renderer.measureMapper = mapper;
    }
    set stepMode(value) {
        this.suspendRendering = value;
        this.renderer.autoAdjustRenderTime = !value;
        if (this.measureMapper) {
            this.measureMapper.deferHighlightMode = !value;
        }
    }
    // ### createScoreRenderer
    // ### Description;
    // to get the score to appear, a div and a score object are required.  The layout takes care of creating the
    // svg element in the dom and interacting with the vex library.
    static createScoreRenderer(config, renderElement, score, undoBuffer) {
        const ctorObj = {
            config,
            elementId: renderElement,
            score,
            undoBuffer
        };
        const renderer = new SuiRenderState(ctorObj);
        return renderer;
    }
    static get setFontStack() {
        return {
            Bravura: () => { VF.setMusicFont('Bravura', 'Gonville', 'Custom'); },
            Gonville: () => { VF.setMusicFont('Gonville', 'Bravura', 'Custom'); },
            Petaluma: () => { VF.setMusicFont('Petaluma', 'Bravura', 'Custom'); },
            Leland: () => { VF.setMusicFont('Leland', 'Bravura', 'Gonville', 'Custom'); }
        };
    }
    static get passStates() {
        return { initial: 0, clean: 2, replace: 3 };
    }
    get renderElement() {
        return this.elementId;
    }
    notifyFontChange() {
        SuiRenderState.setFontStack[this.score.engravingFont]();
    }
    addToReplaceQueue(selection) {
        if (this.passState === SuiRenderState.passStates.clean ||
            this.passState === SuiRenderState.passStates.replace) {
            if (Array.isArray(selection)) {
                this.replaceQ = this.replaceQ.concat(selection);
            }
            else {
                this.replaceQ.push(selection);
            }
            this.setDirty();
        }
    }
    setDirty() {
        if (!this.dirty) {
            this.dirty = true;
            if (this.passState === SuiRenderState.passStates.clean) {
                this.setPassState(SuiRenderState.passStates.replace, 'setDirty');
            }
        }
    }
    setRefresh() {
        this.dirty = true;
        this.setPassState(SuiRenderState.passStates.initial, 'setRefresh');
    }
    rerenderAll() {
        this.dirty = true;
        this.setPassState(SuiRenderState.passStates.initial, 'rerenderAll');
        this._resetViewport = true;
    }
    clearLine(measure) {
        const page = measure.svg.pageIndex;
        this.renderer.clearRenderedPage(page);
    }
    get renderStateClean() {
        return this.passState === SuiRenderState.passStates.clean && this.renderer.backgroundRender === false;
    }
    get renderStateRendered() {
        return (this.passState === SuiRenderState.passStates.clean && this.renderer.backgroundRender === false) ||
            (this.passState === SuiRenderState.passStates.replace && this.replaceQ.length === 0 && this.renderer.backgroundRender === false);
    }
    /**
     * Do a quick re-render of a measure that has changed, defer the whole score.
     * @returns
     */
    replaceMeasures() {
        const staffMap = {};
        if (this.score === null || this.measureMapper === null) {
            return;
        }
        this.replaceQ.forEach((change) => {
            this.renderer.replaceSelection(staffMap, change);
        });
        Object.keys(staffMap).forEach((key) => {
            const obj = staffMap[key];
            this.renderer.renderModifiers(obj.staff, obj.system);
            obj.system.renderEndings(this.measureMapper.scroller);
            obj.system.updateLyricOffsets();
        });
        this.replaceQ = [];
    }
    preserveScroll() {
        const scrollState = this.measureMapper.scroller.scrollState;
        return this.renderPromise().then(() => {
            this.measureMapper.scroller.restoreScrollState(scrollState);
        });
    }
    _renderStatePromise(condition) {
        const oldSuspend = this.suspendRendering;
        this.suspendRendering = false;
        const self = this;
        const endAction = () => {
            self.suspendRendering = oldSuspend;
        };
        return promiseHelpers_1.PromiseHelpers.makePromise(condition, endAction, null, this.demonPollTime);
    }
    // ### renderPromise
    // return a promise that resolves when the score is in a fully rendered state.
    renderPromise() {
        return this._renderStatePromise(() => this.renderStateClean);
    }
    // ### renderPromise
    // return a promise that resolves when the score is in a fully rendered state.
    updatePromise() {
        this.replaceMeasures();
        return this._renderStatePromise(() => this.renderStateRendered);
    }
    handleRedrawTimer() {
        if (this.handlingRedraw) {
            return;
        }
        if (this.suspendRendering) {
            return;
        }
        this.handlingRedraw = true;
        const redrawTime = Math.max(this.renderer.renderTime, this.idleRedrawTime);
        // If there has been a change, redraw the score
        if (this.passState === SuiRenderState.passStates.initial) {
            this.dirty = true;
            this.undoStatus = this.undoBuffer.opCount;
            this.idleLayoutTimer = Date.now();
            // indicate the display is 'dirty' and we will be refreshing it.
            $('body').addClass('refresh-1');
            try {
                // Sort of a hack.  If the viewport changed, the scroll state is already reset
                // so we can't preserver the scroll state.
                if (!this.renderer.viewportChanged) {
                    this.preserveScroll();
                }
                this.render();
            }
            catch (ex) {
                console.error(ex);
                exceptions_1.SuiExceptionHandler.instance.exceptionHandler(ex);
                this.handlingRedraw = false;
            }
        }
        else if (this.passState === SuiRenderState.passStates.replace && this.undoStatus === this.undoBuffer.opCount) {
            // Consider navigation as activity when deciding to refresh
            this.idleLayoutTimer = Math.max(this.idleLayoutTimer, this.measureMapper.getIdleTime());
            $('body').addClass('refresh-1');
            // Do we need to refresh the score?
            if (this.renderer.backgroundRender === false && Date.now() - this.idleLayoutTimer > redrawTime) {
                this.passState = SuiRenderState.passStates.initial;
                if (!this.renderer.viewportChanged) {
                    this.preserveScroll();
                }
                this.render();
            }
        }
        else {
            this.idleLayoutTimer = Date.now();
            this.undoStatus = this.undoBuffer.opCount;
            if (this.replaceQ.length > 0) {
                this.render();
            }
        }
        this.handlingRedraw = false;
    }
    pollRedraw() {
        setTimeout(() => {
            this.handleRedrawTimer();
            this.pollRedraw();
        }, this.demonPollTime);
    }
    startDemon() {
        this.pollRedraw();
    }
    renderTextGroup(gg) {
        this.renderer.renderTextGroup(gg);
    }
    /**
     * Set the SVG viewport
     * @param reset whether to re-render the entire SVG DOM
     * @returns
     */
    setViewport() {
        if (!this.score || !this.renderer) {
            return;
        }
        this.renderer.setViewport();
        this.score.staves.forEach((staff) => {
            staff.measures.forEach((measure) => {
                if (measure.svg.logicalBox) {
                    measure.svg.history = ['reset'];
                }
            });
        });
    }
    renderForPrintPromise() {
        $('body').addClass('print-render');
        const self = this;
        if (!this.score) {
            return promiseHelpers_1.PromiseHelpers.emptyPromise();
        }
        const layoutMgr = this.score.layoutManager;
        const layout = layoutMgr.getGlobalLayout();
        this._backupZoomScale = layout.zoomScale;
        layout.zoomScale = 1.0;
        layoutMgr.updateGlobalLayout(layout);
        this.setViewport();
        this.setRefresh();
        const promise = new Promise((resolve) => {
            const poll = () => {
                setTimeout(() => {
                    if (!self.dirty && !self.renderer.backgroundRender) {
                        // tracker.highlightSelection();
                        $('body').removeClass('print-render');
                        $('.vf-selection').remove();
                        $('body').addClass('printing');
                        $('.musicRelief').css('height', '');
                        resolve();
                    }
                    else {
                        poll();
                    }
                }, 500);
            };
            poll();
        });
        return promise;
    }
    restoreLayoutAfterPrint() {
        const layout = this.score.layoutManager.getGlobalLayout();
        layout.zoomScale = this._backupZoomScale;
        this.score.layoutManager.updateGlobalLayout(layout);
        this.setViewport();
        this.setRefresh();
    }
    setPassState(st, location) {
        const oldState = this.passState;
        let msg = '';
        if (oldState !== st) {
            this.stateRepCount = 0;
        }
        else {
            this.stateRepCount += 1;
        }
        msg = location + ': passState ' + this.passState + '=>' + st;
        if (this.stateRepCount > 0) {
            msg += ' (' + this.stateRepCount + ')';
        }
        console.log(msg);
        this.passState = st;
    }
    get score() {
        return this._score;
    }
    // used for debugging and drawing dots.
    dbgDrawDot(x, y, radius, startAngle, endAngle, counterclockwise) {
        const context = this.renderer.getRenderer({ x, y });
        if (context) {
            context.getContext().beginPath();
            context.getContext().arc(x, y, radius, startAngle, endAngle, counterclockwise);
            context.getContext().closePath();
            context.getContext().fill();
        }
    }
    set score(score) {
        if (score === null) {
            return;
        }
        /* if (this._score) {
          shouldReset = true;
        } */
        this.setPassState(SuiRenderState.passStates.initial, 'load score');
        const font = score.engravingFont;
        this.dirty = true;
        this._score = score;
        this.renderer.score = score;
        this.notifyFontChange();
        // if (shouldReset) {
        this.setViewport();
        if (this.measureMapper) {
            this.measureMapper.loadScore();
        }
    }
    // ### undo
    // Undo is handled by the render state machine, because the layout has to first
    // delete areas of the viewport that may have changed,
    // then create the modified score, then render the 'new' score.
    undo(undoBuffer, staffMap) {
        let op = 'setDirty';
        const buffer = undoBuffer.peek();
        // Unrender the modified music because the IDs may change and normal unrender won't work
        if (buffer) {
            const sel = buffer.selector;
            if (buffer.type === undo_1.UndoBuffer.bufferTypes.MEASURE) {
                if (typeof (staffMap[sel.staff]) === 'number') {
                    const mSelection = selections_1.SmoSelection.measureSelection(this.score, staffMap[sel.staff], sel.measure);
                    if (mSelection !== null) {
                        this.renderer.unrenderMeasure(mSelection.measure);
                    }
                }
            }
            else if (buffer.type === undo_1.UndoBuffer.bufferTypes.STAFF) {
                if (typeof (staffMap[sel.staff]) === 'number') {
                    const sSelection = selections_1.SmoSelection.measureSelection(this.score, staffMap[sel.staff], 0);
                    if (sSelection !== null) {
                        this.renderer.unrenderStaff(sSelection.staff);
                    }
                }
                op = 'setRefresh';
            }
            else {
                this.renderer.unrenderAll();
                op = 'setRefresh';
            }
            this._score = undoBuffer.undo(this._score, staffMap, false);
            // Broken encapsulation - we need to know if we are 'undoing' an entire score
            // so we can change the score pointed to by the renderer.
            if (buffer.type === undo_1.UndoBuffer.bufferTypes.SCORE) {
                this.renderer.score = this._score;
            }
            this[op]();
        }
        if (!this._score) {
            throw ('no score when undo');
        }
        return this._score;
    }
    unrenderColumn(measure) {
        this.score.staves.forEach((staff) => {
            this.renderer.unrenderMeasure(staff.measures[measure.measureNumber.measureIndex]);
        });
    }
    // ### forceRender
    // For unit test applictions that want to render right-away
    forceRender() {
        this.setRefresh();
        this.render();
    }
    unrenderMeasure(measure) {
        this.renderer.unrenderMeasure(measure);
    }
    renderScoreModifiers() {
        this.renderer.renderScoreModifiers();
    }
    render() {
        if (this._resetViewport) {
            this.setViewport();
            this._resetViewport = false;
        }
        try {
            if (SuiRenderState.passStates.replace === this.passState) {
                this.replaceMeasures();
            }
            else if (SuiRenderState.passStates.initial === this.passState) {
                if (this.renderer.backgroundRender) {
                    return;
                }
                this.renderer.layout();
                this.renderer.drawPageLines();
                this.setPassState(SuiRenderState.passStates.clean, 'rs: complete render');
            }
        }
        catch (excp) {
            console.warn('exception in render: ' + excp);
        }
        this.dirty = false;
    }
}
exports.SuiRenderState = SuiRenderState;


/***/ }),

/***/ "./src/render/sui/scoreRender.ts":
/*!***************************************!*\
  !*** ./src/render/sui/scoreRender.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SuiScoreRender = void 0;
const scoreText_1 = __webpack_require__(/*! ../../smo/data/scoreText */ "./src/smo/data/scoreText.ts");
const selections_1 = __webpack_require__(/*! ../../smo/xform/selections */ "./src/smo/xform/selections.ts");
const vxSystem_1 = __webpack_require__(/*! ../vex/vxSystem */ "./src/render/vex/vxSystem.ts");
const svgHelpers_1 = __webpack_require__(/*! ./svgHelpers */ "./src/render/sui/svgHelpers.ts");
const piano_1 = __webpack_require__(/*! ./piano */ "./src/render/sui/piano.ts");
const formatter_1 = __webpack_require__(/*! ./formatter */ "./src/render/sui/formatter.ts");
const beamers_1 = __webpack_require__(/*! ../../smo/xform/beamers */ "./src/smo/xform/beamers.ts");
const textRender_1 = __webpack_require__(/*! ./textRender */ "./src/render/sui/textRender.ts");
const layoutDebug_1 = __webpack_require__(/*! ./layoutDebug */ "./src/render/sui/layoutDebug.ts");
const ssp_sans_metrics_1 = __webpack_require__(/*! ../../styles/font_metrics/ssp-sans-metrics */ "./src/styles/font_metrics/ssp-sans-metrics.js");
const htmlHelpers_1 = __webpack_require__(/*! ../../common/htmlHelpers */ "./src/common/htmlHelpers.ts");
const svgPageMap_1 = __webpack_require__(/*! ./svgPageMap */ "./src/render/sui/svgPageMap.ts");
const VF = eval('Vex.Flow');
/**
 * This module renders the entire score.  It calculates the layout first based on the
 * computed dimensions.
  * @category SuiRender
**/
class SuiScoreRender {
    constructor(params) {
        this.startRenderTime = 0;
        this.formatter = null;
        // vexRenderer: any = null;
        this.score = null;
        this.measureMapper = null;
        this.measuresToMap = [];
        this.viewportChanged = false;
        this.renderTime = 0;
        this.backgroundRender = false;
        this.renderedPages = {};
        this._autoAdjustRenderTime = true;
        this.lyricsToOffset = new Map();
        this.renderingPage = -1;
        this.elementId = params.elementId;
        this.score = params.score;
        this.vexContainers = new svgPageMap_1.SvgPageMap(this.score.layoutManager.globalLayout, this.elementId, this.score.layoutManager.pageLayouts);
        this.setViewport();
    }
    get autoAdjustRenderTime() {
        return this._autoAdjustRenderTime;
    }
    set autoAdjustRenderTime(value) {
        this._autoAdjustRenderTime = value;
    }
    getRenderer(box) {
        return this.vexContainers.getRenderer(box);
    }
    renderTextGroup(gg) {
        let ix = 0;
        let jj = 0;
        if (gg.skipRender || this.score === null || this.measureMapper === null) {
            return;
        }
        gg.elements.forEach((element) => {
            element.remove();
        });
        gg.elements = [];
        const layoutManager = this.score.layoutManager;
        const scaledScoreLayout = layoutManager.getScaledPageLayout(0);
        // If this text hasn't been rendered before, estimate the logical box.
        const dummyContainer = this.vexContainers.getRendererFromModifier(gg);
        if (dummyContainer && !gg.logicalBox) {
            const dummyBlock = textRender_1.SuiTextBlock.fromTextGroup(gg, dummyContainer, this.vexContainers, this.measureMapper.scroller);
            gg.logicalBox = dummyBlock.getLogicalBox();
        }
        // If this is a per-page score text, get a text group copy for each page.
        // else the array contains the original.
        const groupAr = scoreText_1.SmoTextGroup.getPagedTextGroups(gg, this.score.layoutManager.pageLayouts.length, scaledScoreLayout.pageHeight);
        groupAr.forEach((newGroup) => {
            var _a, _b;
            let container = this.vexContainers.getRendererFromModifier(newGroup);
            // If this text is attached to the measure, base the block location on the rendered measure location.
            if (newGroup.attachToSelector) {
                // If this text is attached to a staff that is not visible, don't draw it.
                const mappedStaff = this.score.staves.find((staff) => staff.getMappedStaffId() === newGroup.selector.staff);
                if (!mappedStaff) {
                    return;
                }
                // Indicate the new map;
                // newGroup.selector.staff = mappedStaff.staffId;        
                const mmSel = selections_1.SmoSelection.measureSelection(this.score, mappedStaff.staffId, newGroup.selector.measure);
                if (mmSel) {
                    const mm = mmSel.measure;
                    if (mm.svg.logicalBox.width > 0) {
                        const xoff = mm.svg.logicalBox.x + newGroup.musicXOffset;
                        const yoff = mm.svg.logicalBox.y + newGroup.musicYOffset;
                        newGroup.textBlocks[0].text.x = xoff;
                        newGroup.textBlocks[0].text.y = yoff;
                    }
                }
            }
            if (container) {
                const block = textRender_1.SuiTextBlock.fromTextGroup(newGroup, container, this.vexContainers, this.measureMapper.scroller);
                block.render();
                if ((_a = block.currentBlock) === null || _a === void 0 ? void 0 : _a.text.element) {
                    gg.elements.push((_b = block.currentBlock) === null || _b === void 0 ? void 0 : _b.text.element);
                }
                // For the first one we render, use that as the bounding box for all the text, for
                // purposes of mapper/tracker
                if (ix === 0) {
                    gg.logicalBox = JSON.parse(JSON.stringify(block.logicalBox));
                    // map all the child scoreText objects, too.
                    for (jj = 0; jj < gg.textBlocks.length; ++jj) {
                        gg.textBlocks[jj].text.logicalBox = JSON.parse(JSON.stringify(block.inlineBlocks[jj].text.logicalBox));
                    }
                }
                ix += 1;
            }
        });
    }
    // ### unrenderAll
    // ### Description:
    // Delete all the svg elements associated with the score.
    unrenderAll() {
        if (!this.score) {
            return;
        }
        this.score.staves.forEach((staff) => {
            this.unrenderStaff(staff);
        });
        // $(this.context.svg).find('g.lineBracket').remove();
    }
    // ### unrenderStaff
    // ### Description:
    // See unrenderMeasure.  Like that, but with a staff.
    unrenderStaff(staff) {
        staff.measures.forEach((measure) => {
            this.unrenderMeasure(measure);
        });
        staff.modifiers.forEach((modifier) => {
            if (modifier.element) {
                modifier.element.remove();
                modifier.element = null;
            }
        });
    }
    clearRenderedPage(pg) {
        if (this.renderedPages[pg]) {
            this.renderedPages[pg] = null;
        }
    }
    // ### _setViewport
    // Create (or recrate) the svg viewport, considering the dimensions of the score.
    setViewport() {
        if (this.score === null) {
            return;
        }
        const layoutManager = this.score.layoutManager;
        // All pages have same width/height, so use that
        const layout = layoutManager.getGlobalLayout();
        this.vexContainers.updateLayout(layout, layoutManager.pageLayouts);
        this.renderedPages = {};
        this.viewportChanged = true;
        if (this.measureMapper) {
            this.measureMapper.scroller.scrollAbsolute(0, 0);
        }
        if (this.measureMapper) {
            this.measureMapper.scroller.updateViewport();
        }
        // this.context.setFont(this.font.typeface, this.font.pointSize, "").setBackgroundFillStyle(this.font.fillStyle);
        console.log('layout setViewport: pstate initial');
    }
    renderScoreModifiers() {
        // remove existing modifiers, and also remove parent group for 'extra'
        // groups associated with pagination (once per page etc)
        this.score.textGroups.forEach((tg) => {
            tg.elements.forEach((element) => {
                element.remove();
            });
            tg.elements = [];
        });
        // group.classList.add('all-score-text');
        this.score.textGroups.forEach((tg) => {
            this.renderTextGroup(tg);
        });
    }
    _getMeasuresInColumn(ix) {
        const rv = [];
        if (!this.score) {
            return [];
        }
        this.score.staves.forEach((staff) => {
            const inst = staff.measures.find((ss) => ss.measureNumber.measureIndex === ix);
            if (inst) {
                rv.push(inst);
            }
        });
        return rv;
    }
    /**
     * for music we've just rendered, get the bounding boxes.  We defer this step so we don't force
     * a reflow, which can slow rendering.
     * @param vxSystem
     * @param measures
     * @param modifiers
     * @param printing
     */
    measureRenderedElements(vxSystem, measures, modifiers, printing) {
        const pageContext = vxSystem.context;
        measures.forEach((smoMeasure) => {
            const element = smoMeasure.svg.element;
            if (element) {
                smoMeasure.setBox(pageContext.offsetBbox(element), 'vxMeasure bounding box');
            }
            const vxMeasure = vxSystem.getVxMeasure(smoMeasure);
            if (vxMeasure) {
                vxMeasure.modifiersToBox.forEach((modifier) => {
                    if (modifier.element) {
                        modifier.logicalBox = pageContext.offsetBbox(modifier.element);
                    }
                });
            }
            // unit test codes don't have tracker.
            if (this.measureMapper) {
                const tmpStaff = this.score.staves.find((ss) => ss.staffId === smoMeasure.measureNumber.staffId);
                if (tmpStaff) {
                    this.measureMapper.mapMeasure(tmpStaff, smoMeasure, printing);
                }
            }
        });
        modifiers.forEach((modifier) => {
            if (modifier.element) {
                modifier.logicalBox = pageContext.offsetBbox(modifier.element);
            }
        });
    }
    _renderSystem(lineIx, printing) {
        if (this.score === null || this.formatter === null) {
            return;
        }
        const measuresToBox = [];
        const modifiersToBox = [];
        const columns = this.formatter.systems[lineIx].systems;
        // If this page hasn't changed since rendered
        const pageIndex = columns[0][0].svg.pageIndex;
        if (this.renderingPage !== pageIndex && this.renderedPages[pageIndex]) {
            console.log(`skipping render on page ${pageIndex}`);
            return;
        }
        const context = this.vexContainers.getRendererForPage(pageIndex);
        if (this.renderingPage !== pageIndex) {
            context.clearMap();
            this.renderingPage = pageIndex;
        }
        const vxSystem = new vxSystem_1.VxSystem(context, 0, lineIx, this.score);
        const colKeys = Object.keys(columns);
        colKeys.forEach((colKey) => {
            columns[parseInt(colKey, 10)].forEach((measure) => {
                if (this.measureMapper !== null) {
                    const modId = 'mod-' + measure.measureNumber.staffId + '-' + measure.measureNumber.measureIndex;
                    svgHelpers_1.SvgHelpers.removeElementsByClass(context.svg, modId);
                    vxSystem.renderMeasure(measure, printing);
                    const pageIndex = measure.svg.pageIndex;
                    const renderMeasures = this.renderedPages[pageIndex];
                    if (!renderMeasures) {
                        this.renderedPages[pageIndex] = {
                            startMeasure: measure.measureNumber.measureIndex,
                            endMeasure: measure.measureNumber.measureIndex
                        };
                    }
                    else {
                        renderMeasures.endMeasure = measure.measureNumber.measureIndex;
                    }
                    measuresToBox.push(measure);
                    if (!printing && !measure.format.isDefault) {
                        const at = [];
                        at.push({ y: measure.svg.logicalBox.y - 5 });
                        at.push({ x: measure.svg.logicalBox.x + 25 });
                        at.push({ 'font-family': ssp_sans_metrics_1.SourceSansProFont.fontFamily });
                        at.push({ 'font-size': '12pt' });
                        svgHelpers_1.SvgHelpers.placeSvgText(context.svg, at, 'measure-format', '*');
                    }
                }
            });
        });
        this.score.staves.forEach((stf) => {
            this.renderModifiers(stf, vxSystem).forEach((modifier) => {
                modifiersToBox.push(modifier);
            });
        });
        if (this.measureMapper !== null) {
            vxSystem.renderEndings(this.measureMapper.scroller);
        }
        this.measuresToMap.push({ vxSystem, measuresToBox, modifiersToBox, printing });
        // this.measureRenderedElements(vxSystem, measuresToBox, modifiersToBox, printing);
        const timestamp = new Date().valueOf();
        if (!this.lyricsToOffset.has(vxSystem.lineIndex)) {
            this.lyricsToOffset.set(vxSystem.lineIndex, vxSystem);
        }
        // vxSystem.updateLyricOffsets();
        layoutDebug_1.layoutDebug.setTimestamp(layoutDebug_1.layoutDebug.codeRegions.POST_RENDER, new Date().valueOf() - timestamp);
    }
    _renderNextSystemPromise(systemIx, keys, printing) {
        return new Promise((resolve) => {
            // const sleepDate = new Date().valueOf();
            this._renderSystem(keys[systemIx], printing);
            requestAnimationFrame(() => resolve());
        });
    }
    _renderNextSystem(lineIx, keys, printing) {
        var _a;
        (0, htmlHelpers_1.createTopDomContainer)('#renderProgress', 'progress');
        if (lineIx < keys.length) {
            const progress = Math.round((100 * lineIx) / keys.length);
            $('#renderProgress').attr('max', 100);
            $('#renderProgress').val(progress);
            this._renderNextSystemPromise(lineIx, keys, printing).then(() => {
                lineIx++;
                this._renderNextSystem(lineIx, keys, printing);
            });
        }
        else {
            this.renderScoreModifiers();
            this.numberMeasures();
            this.measuresToMap.forEach((mm) => {
                this.measureRenderedElements(mm.vxSystem, mm.measuresToBox, mm.modifiersToBox, mm.printing);
            });
            this.lyricsToOffset.forEach((vv) => {
                vv.updateLyricOffsets();
            });
            this.measuresToMap = [];
            this.lyricsToOffset = new Map();
            // We pro-rate the background render timer on how long it takes
            // to actually render the score, so we are not thrashing on a large
            // score.
            if (this._autoAdjustRenderTime) {
                this.renderTime = new Date().valueOf() - this.startRenderTime;
            }
            $('body').removeClass('show-render-progress');
            // indicate the display is 'clean' and up-to-date with the score
            $('body').removeClass('refresh-1');
            if (this.measureMapper !== null) {
                this.measureMapper.updateMap();
                if (layoutDebug_1.layoutDebug.mask & layoutDebug_1.layoutDebug.values['artifactMap']) {
                    (_a = this.score) === null || _a === void 0 ? void 0 : _a.staves.forEach((staff) => {
                        staff.measures.forEach((mm) => {
                            mm.voices.forEach((voice) => {
                                voice.notes.forEach((note) => {
                                    if (note.logicalBox) {
                                        const page = this.vexContainers.getRendererFromPoint(note.logicalBox);
                                        if (page) {
                                            const noteBox = svgHelpers_1.SvgHelpers.smoBox(note.logicalBox);
                                            noteBox.y -= page.box.y;
                                            svgHelpers_1.SvgHelpers.debugBox(page.svg, noteBox, 'measure-place-dbg', 0);
                                        }
                                    }
                                });
                            });
                        });
                    });
                }
            }
            this.backgroundRender = false;
        }
    }
    // ### unrenderMeasure
    // All SVG elements are associated with a logical SMO element.  We need to erase any SVG element before we change a SMO
    // element in such a way that some of the logical elements go away (e.g. when deleting a measure).
    unrenderMeasure(measure) {
        if (!measure) {
            return;
        }
        const modId = 'mod-' + measure.measureNumber.staffId + '-' + measure.measureNumber.measureIndex;
        const context = this.vexContainers.getRenderer(measure.svg.logicalBox);
        if (!context) {
            return;
        }
        svgHelpers_1.SvgHelpers.removeElementsByClass(context.svg, modId);
        if (measure.svg.element) {
            measure.svg.element.remove();
            measure.svg.element = null;
        }
        const renderPage = this.renderedPages[measure.svg.pageIndex];
        if (renderPage) {
            this.renderedPages[measure.svg.pageIndex] = null;
        }
        measure.setYTop(0, 'unrender');
    }
    // ### _renderModifiers
    // ### Description:
    // Render staff modifiers (modifiers straddle more than one measure, like a slur).  Handle cases where the destination
    // is on a different system due to wrapping.
    renderModifiers(staff, system) {
        let nextNote = null;
        let lastNote = null;
        let testNote = null;
        let vxStart = null;
        let vxEnd = null;
        const modifiersToBox = [];
        const removedModifiers = [];
        if (this.score === null || this.measureMapper === null) {
            return [];
        }
        const renderedId = {};
        staff.renderableModifiers.forEach((modifier) => {
            const startNote = selections_1.SmoSelection.noteSelection(this.score, modifier.startSelector.staff, modifier.startSelector.measure, modifier.startSelector.voice, modifier.startSelector.tick);
            const endNote = selections_1.SmoSelection.noteSelection(this.score, modifier.endSelector.staff, modifier.endSelector.measure, modifier.endSelector.voice, modifier.endSelector.tick);
            if (!startNote || !endNote) {
                // If the modifier doesn't have score endpoints, delete it from the score
                removedModifiers.push(modifier);
                return;
            }
            if (startNote.note !== null) {
                vxStart = system.getVxNote(startNote.note);
            }
            if (endNote.note !== null) {
                vxEnd = system.getVxNote(endNote.note);
            }
            // If the modifier goes to the next staff, draw what part of it we can on this staff.
            if (vxStart && !vxEnd) {
                nextNote = selections_1.SmoSelection.nextNoteSelection(this.score, modifier.startSelector.staff, modifier.startSelector.measure, modifier.startSelector.voice, modifier.startSelector.tick);
                if (nextNote === null) {
                    console.warn('bad selector ' + JSON.stringify(modifier.startSelector, null, ' '));
                }
                else {
                    if (nextNote.note !== null) {
                        testNote = system.getVxNote(nextNote.note);
                    }
                    while (testNote) {
                        vxEnd = testNote;
                        nextNote = selections_1.SmoSelection.nextNoteSelection(this.score, nextNote.selector.staff, nextNote.selector.measure, nextNote.selector.voice, nextNote.selector.tick);
                        if (!nextNote) {
                            break;
                        }
                        if (nextNote.note !== null) {
                            testNote = system.getVxNote(nextNote.note);
                        }
                        else {
                            testNote = null;
                        }
                    }
                }
            }
            if (vxEnd && !vxStart) {
                lastNote = selections_1.SmoSelection.lastNoteSelection(this.score, modifier.endSelector.staff, modifier.endSelector.measure, modifier.endSelector.voice, modifier.endSelector.tick);
                if (lastNote !== null && lastNote.note !== null) {
                    testNote = system.getVxNote(lastNote.note);
                    while (testNote !== null) {
                        vxStart = testNote;
                        lastNote = selections_1.SmoSelection.lastNoteSelection(this.score, lastNote.selector.staff, lastNote.selector.measure, lastNote.selector.voice, lastNote.selector.tick);
                        if (!lastNote) {
                            break;
                        }
                        if (lastNote.note !== null) {
                            testNote = system.getVxNote(lastNote.note);
                        }
                        else {
                            testNote = null;
                        }
                    }
                }
            }
            if (!vxStart && !vxEnd || renderedId[modifier.attrs.id]) {
                return;
            }
            renderedId[modifier.attrs.id] = true;
            system.renderModifier(this.measureMapper.scroller, modifier, vxStart, vxEnd, startNote, endNote);
            modifiersToBox.push(modifier);
        });
        // Silently remove modifiers from the score if the endpoints no longer exist
        removedModifiers.forEach((mod) => {
            staff.removeStaffModifier(mod);
        });
        return modifiersToBox;
    }
    drawPageLines() {
        let i = 0;
        const printing = $('body').hasClass('print-render');
        const layoutMgr = this.score.layoutManager;
        if (printing || !layoutMgr) {
            return;
        }
        for (i = 1; i < layoutMgr.pageLayouts.length; ++i) {
            const context = this.vexContainers.getRendererForPage(i - 1);
            if (context) {
                $(context.svg).find('.pageLine').remove();
                const scaledPage = layoutMgr.getScaledPageLayout(i);
                const y = scaledPage.pageHeight * i - context.box.y;
                svgHelpers_1.SvgHelpers.line(context.svg, 0, y, scaledPage.pageWidth, y, { strokeName: 'line', stroke: '#321', strokeWidth: '2', strokeDasharray: '4,1', fill: 'none', opacity: 1.0 }, 'pageLine');
            }
        }
    }
    replaceSelection(staffMap, change) {
        let system = null;
        if (this.renderedPages[change.measure.svg.pageIndex]) {
            this.renderedPages[change.measure.svg.pageIndex] = null;
        }
        beamers_1.SmoBeamer.applyBeams(change.measure);
        // Defer modifier update until all selected measures are drawn.
        if (!staffMap[change.staff.staffId]) {
            const context = this.vexContainers.getRenderer(change.measure.svg.logicalBox);
            if (context) {
                system = new vxSystem_1.VxSystem(context, change.measure.staffY, change.measure.svg.lineIndex, this.score);
                staffMap[change.staff.staffId] = { system, staff: change.staff };
            }
        }
        else {
            system = staffMap[change.staff.staffId].system;
        }
        const selections = selections_1.SmoSelection.measuresInColumn(this.score, change.measure.measureNumber.measureIndex);
        const measuresToMeasure = [];
        selections.forEach((selection) => {
            if (system !== null && this.measureMapper !== null) {
                this.unrenderMeasure(selection.measure);
                system.renderMeasure(selection.measure, false);
                measuresToMeasure.push(selection.measure);
            }
        });
        if (system) {
            this.measureRenderedElements(system, measuresToMeasure, [], false);
        }
    }
    renderAllMeasures(lines) {
        if (!this.score) {
            return;
        }
        const printing = $('body').hasClass('print-render');
        $('.measure-format').remove();
        if (!printing) {
            $('body').addClass('show-render-progress');
            const isShowing = piano_1.SuiPiano.isShowing;
            if (this.score.preferences.showPiano && !isShowing) {
                piano_1.SuiPiano.showPiano();
                this.measureMapper.scroller.updateViewport();
            }
            else if (isShowing && !this.score.preferences.showPiano) {
                piano_1.SuiPiano.hidePiano();
                this.measureMapper.scroller.updateViewport();
            }
        }
        this.backgroundRender = true;
        this.startRenderTime = new Date().valueOf();
        this.renderingPage = -1;
        this.vexContainers.updateContainerOffset(this.measureMapper.scroller.scrollState);
        this._renderNextSystem(0, lines, printing);
    }
    // Number the measures at the first measure in each system.
    numberMeasures() {
        const printing = $('body').hasClass('print-render');
        const staff = this.score.staves[0];
        const measures = staff.measures.filter((measure) => measure.measureNumber.systemIndex === 0);
        $('.measure-number').remove();
        measures.forEach((measure) => {
            const context = this.vexContainers.getRenderer(measure.svg.logicalBox);
            if (measure.measureNumber.localIndex > 0 && measure.measureNumber.systemIndex === 0 && measure.svg.logicalBox && context) {
                const numAr = [];
                const modBox = context.offsetSvgPoint(measure.svg.logicalBox);
                numAr.push({ y: modBox.y - 10 });
                numAr.push({ x: modBox.x });
                numAr.push({ 'font-family': ssp_sans_metrics_1.SourceSansProFont.fontFamily });
                numAr.push({ 'font-size': '10pt' });
                svgHelpers_1.SvgHelpers.placeSvgText(context.svg, numAr, 'measure-number', (measure.measureNumber.localIndex + 1).toString());
                // Show line-feed symbol
                if (measure.format.systemBreak && !printing) {
                    const starAr = [];
                    const symbol = '\u21b0';
                    starAr.push({ y: modBox.y - 5 });
                    starAr.push({ x: modBox.x + 25 });
                    starAr.push({ 'font-family': ssp_sans_metrics_1.SourceSansProFont.fontFamily });
                    starAr.push({ 'font-size': '12pt' });
                    svgHelpers_1.SvgHelpers.placeSvgText(context.svg, starAr, 'measure-format', symbol);
                }
            }
        });
    }
    /**
     * This calculates the position of all the elements in the score, then renders the score
     * @returns
     */
    layout() {
        if (!this.score) {
            return;
        }
        const score = this.score;
        $('head title').text(this.score.scoreInfo.name);
        const formatter = new formatter_1.SuiLayoutFormatter(score, this.vexContainers, this.renderedPages);
        Object.keys(this.renderedPages).forEach((key) => {
            this.vexContainers.clearModifiersForPage(parseInt(key));
        });
        const startPageCount = this.score.layoutManager.pageLayouts.length;
        this.formatter = formatter;
        formatter.layout();
        if (this.formatter.trimPages(startPageCount)) {
            this.setViewport();
        }
        this.measuresToMap = [];
        this.lyricsToOffset = new Map();
        this.renderAllMeasures(formatter.lines);
    }
}
exports.SuiScoreRender = SuiScoreRender;


/***/ }),

/***/ "./src/render/sui/scoreView.ts":
/*!*************************************!*\
  !*** ./src/render/sui/scoreView.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SuiScoreView = void 0;
// [Smoosic](https://github.com/AaronDavidNewman/Smoosic)
// Copyright (c) Aaron David Newman 2021.
const score_1 = __webpack_require__(/*! ../../smo/data/score */ "./src/smo/data/score.ts");
const systemStaff_1 = __webpack_require__(/*! ../../smo/data/systemStaff */ "./src/smo/data/systemStaff.ts");
const staffModifiers_1 = __webpack_require__(/*! ../../smo/data/staffModifiers */ "./src/smo/data/staffModifiers.ts");
const selections_1 = __webpack_require__(/*! ../../smo/xform/selections */ "./src/smo/xform/selections.ts");
const undo_1 = __webpack_require__(/*! ../../smo/xform/undo */ "./src/smo/xform/undo.ts");
const copypaste_1 = __webpack_require__(/*! ../../smo/xform/copypaste */ "./src/smo/xform/copypaste.ts");
const scroller_1 = __webpack_require__(/*! ./scroller */ "./src/render/sui/scroller.ts");
const svgHelpers_1 = __webpack_require__(/*! ./svgHelpers */ "./src/render/sui/svgHelpers.ts");
const tracker_1 = __webpack_require__(/*! ./tracker */ "./src/render/sui/tracker.ts");
const htmlHelpers_1 = __webpack_require__(/*! ../../common/htmlHelpers */ "./src/common/htmlHelpers.ts");
const renderState_1 = __webpack_require__(/*! ./renderState */ "./src/render/sui/renderState.ts");
const operations_1 = __webpack_require__(/*! ../../smo/xform/operations */ "./src/smo/xform/operations.ts");
const player_1 = __webpack_require__(/*! ../audio/player */ "./src/render/audio/player.ts");
const measureModifiers_1 = __webpack_require__(/*! ../../smo/data/measureModifiers */ "./src/smo/data/measureModifiers.ts");
const measureModifiers_2 = __webpack_require__(/*! ../../smo/data/measureModifiers */ "./src/smo/data/measureModifiers.ts");
/**
 * Base class for all operations on the rendered score.  The base class handles the following:
 * 1. Undo and recording actions for the operation
 * 2. Maintain/change which staves in the score are displayed (staff map)
 * 3. Mapping between the displayed score and the data representation
 * @category SuiRender
 */
class SuiScoreView {
    constructor(config, svgContainer, score, scrollSelector, undoBuffer) {
        this.score = score;
        const renderParams = {
            elementId: svgContainer,
            score,
            config,
            undoBuffer
        };
        this.audioAnimation = config.audioAnimation;
        this.renderer = new renderState_1.SuiRenderState(renderParams);
        this.config = config;
        const scoreJson = score.serialize();
        this.scroller = new scroller_1.SuiScroller(scrollSelector, this.renderer.renderer.vexContainers);
        this.pasteBuffer = new copypaste_1.PasteBuffer();
        this.storePaste = new copypaste_1.PasteBuffer();
        this.tracker = new tracker_1.SuiTracker(this.renderer, this.scroller, this.pasteBuffer);
        this.renderer.setMeasureMapper(this.tracker);
        this.storeScore = score_1.SmoScore.deserialize(JSON.stringify(scoreJson));
        this.synchronizeTextGroups();
        this.storeUndo = new undo_1.UndoBuffer();
        this.staffMap = this.defaultStaffMap;
        SuiScoreView.Instance = this; // for debugging
        this.setMappedStaffIds();
        (0, htmlHelpers_1.createTopDomContainer)('.saveLink'); // for file upload
    }
    synchronizeTextGroups() {
        // Synchronize the score text IDs so cut/paste/undo works transparently
        this.score.textGroups.forEach((tg, ix) => {
            this.storeScore.textGroups[ix].attrs.id = tg.attrs.id;
        });
    }
    /**
     * Await on the full update of the score
     * @returns
     */
    renderPromise() {
        return this.renderer.renderPromise();
    }
    /**
     * Await on the partial update of the score in the view
     * @returns
     */
    updatePromise() {
        return this.renderer.updatePromise();
    }
    /**
     * await on the full update of the score, also resetting the viewport (to reflect layout changes)
     * @returns
     */
    refreshViewport() {
        this.renderer.preserveScroll();
        this.renderer.setViewport();
        this.renderer.setRefresh();
        return this.renderer.renderPromise();
    }
    getPartMap() {
        let keepNext = false;
        let partCount = 0;
        let partMap = {};
        const keys = [];
        this.storeScore.staves.forEach((staff) => {
            const partInfo = staff.partInfo;
            partInfo.associatedStaff = staff.staffId;
            if (!keepNext) {
                partMap[partCount] = partInfo;
                keys.push(partCount);
                partCount += 1;
                if (partInfo.stavesAfter > 0) {
                    keepNext = true;
                }
            }
            else {
                keepNext = false;
            }
        });
        return { keys, partMap };
    }
    /**
     * This is used in some Smoosic demos and pens.
     * @param action any action, but most usefully a SuiScoreView method
     * @param repetition number of times to repeat, waiting on render promise between
     * if not specified, defaults to 1
     * @returns promise, resolved action has been completed and score is updated.
     */
    waitableAction(action, repetition) {
        const rep = repetition !== null && repetition !== void 0 ? repetition : 1;
        const self = this;
        const promise = new Promise((resolve) => {
            const fc = (count) => {
                if (count > 0) {
                    action();
                    self.renderer.updatePromise().then(() => {
                        fc(count - 1);
                    });
                }
                else {
                    resolve();
                }
            };
            fc(rep);
        });
        return promise;
    }
    /**
     * The plural form of _getEquivalentSelection
     * @param selections
     * @returns
     */
    _getEquivalentSelections(selections) {
        const rv = [];
        selections.forEach((selection) => {
            const sel = this._getEquivalentSelection(selection);
            if (sel !== null) {
                rv.push(sel);
            }
        });
        return rv;
    }
    /**
     * A staff modifier has changed, create undo operations for the measures affected
     * @param label
     * @param staffModifier
     * @param subtype
     */
    _undoStaffModifier(label, staffModifier, subtype) {
        const copy = staffModifiers_1.StaffModifierBase.deserialize(staffModifier.serialize());
        copy.startSelector = this._getEquivalentSelector(copy.startSelector);
        copy.endSelector = this._getEquivalentSelector(copy.endSelector);
        this.storeUndo.addBuffer(label, undo_1.UndoBuffer.bufferTypes.STAFF_MODIFIER, selections_1.SmoSelector.default, copy.serialize(), subtype);
    }
    /**
     * Return the index of the page that is in the center of the client screen.
     */
    getFocusedPage() {
        if (this.score.layoutManager === undefined) {
            return 0;
        }
        const scrollAvg = this.tracker.scroller.netScroll.y + (this.tracker.scroller.viewport.height / 2);
        const midY = scrollAvg;
        const layoutManager = this.score.layoutManager.getGlobalLayout();
        const lh = layoutManager.pageHeight / layoutManager.svgScale;
        const lw = layoutManager.pageWidth / layoutManager.svgScale;
        const pt = this.renderer.pageMap.svgToClient(svgHelpers_1.SvgHelpers.smoBox({ x: lw, y: lh }));
        return Math.round(midY / pt.y);
    }
    /**
     * Create a rectangle undo, like a multiple columns but not necessarily the whole
     * score.
     */
    _undoColumn(label, measureIndex) {
        this.storeUndo.addBuffer(label, undo_1.UndoBuffer.bufferTypes.COLUMN, selections_1.SmoSelector.default, { score: this.storeScore, measureIndex }, undo_1.UndoBuffer.bufferSubtypes.NONE);
    }
    /**
     * Score preferences don't affect the display, but they do have an undo
     * @param label
     */
    _undoScorePreferences(label) {
        this.storeUndo.addBuffer(label, undo_1.UndoBuffer.bufferTypes.SCORE_ATTRIBUTES, selections_1.SmoSelector.default, this.storeScore, undo_1.UndoBuffer.bufferSubtypes.NONE);
    }
    /**
     * Add to the undo buffer the current set of measures selected.
     * @param label
     * @returns
     */
    _undoTrackerMeasureSelections(label) {
        const measureSelections = selections_1.SmoSelection.getMeasureList(this.tracker.selections);
        measureSelections.forEach((measureSelection) => {
            const equiv = this._getEquivalentSelection(measureSelection);
            if (equiv !== null) {
                this.storeUndo.addBuffer(label, undo_1.UndoBuffer.bufferTypes.MEASURE, equiv.selector, equiv.measure, undo_1.UndoBuffer.bufferSubtypes.NONE);
            }
        });
        return measureSelections;
    }
    /**
     * operation that only affects the first selection.  Setup undo for the measure
     */
    _undoFirstMeasureSelection(label) {
        const sel = this.tracker.selections[0];
        const equiv = this._getEquivalentSelection(sel);
        if (equiv !== null) {
            this.storeUndo.addBuffer(label, undo_1.UndoBuffer.bufferTypes.MEASURE, equiv.selector, equiv.measure, undo_1.UndoBuffer.bufferSubtypes.NONE);
        }
        return sel;
    }
    /**
     * Add the selection to the undo buffer
     * @param label
     * @param selection
     */
    _undoSelection(label, selection) {
        const equiv = this._getEquivalentSelection(selection);
        if (equiv !== null) {
            this.storeUndo.addBuffer(label, undo_1.UndoBuffer.bufferTypes.MEASURE, equiv.selector, equiv.measure, undo_1.UndoBuffer.bufferSubtypes.NONE);
        }
    }
    /**
     * Add multiple selections to the undo buffer as a group
     * @param label
     * @param selections
     */
    _undoSelections(label, selections) {
        this.storeUndo.grouping = true;
        selections.forEach((selection) => {
            this._undoSelection(label, selection);
        });
        this.storeUndo.grouping = false;
    }
    /**
     * Update renderer for measures that have changed
    */
    _renderChangedMeasures(measureSelections) {
        if (!Array.isArray(measureSelections)) {
            measureSelections = [measureSelections];
        }
        measureSelections.forEach((measureSelection) => {
            this.renderer.addToReplaceQueue(measureSelection);
        });
    }
    /**
     * Update renderer for some columns
     * @param fromSelector
     * @param toSelector
     */
    _renderRectangle(fromSelector, toSelector) {
        this._getRectangleSelections(fromSelector, toSelector).forEach((s) => {
            this.renderer.addToReplaceQueue(s);
        });
    }
    /**
     * Setup undo for operation that affects the whole score
     * @param label
     */
    _undoScore(label) {
        this.storeUndo.addBuffer(label, undo_1.UndoBuffer.bufferTypes.SCORE, selections_1.SmoSelector.default, this.storeScore, undo_1.UndoBuffer.bufferSubtypes.NONE);
    }
    /**
     * Get the selector from this.storeScore that maps to the displayed selector from this.score
     * @param selector
     * @returns
     */
    _getEquivalentSelector(selector) {
        const rv = JSON.parse(JSON.stringify(selector));
        rv.staff = this.staffMap[selector.staff];
        return rv;
    }
    /**
     * Get the equivalent staff id from this.storeScore that maps to the displayed selector from this.score
     * @param staffId
     * @returns
     */
    _getEquivalentStaff(staffId) {
        return this.staffMap[staffId];
    }
    /**
     * Get the equivalent selection from this.storeScore that maps to the displayed selection from this.score
     * @param selection
     * @returns
     */
    _getEquivalentSelection(selection) {
        try {
            if (typeof (selection.selector.tick) === 'undefined') {
                return selections_1.SmoSelection.measureSelection(this.storeScore, this.staffMap[selection.selector.staff], selection.selector.measure);
            }
            if (typeof (selection.selector.pitches) === 'undefined') {
                return selections_1.SmoSelection.noteSelection(this.storeScore, this.staffMap[selection.selector.staff], selection.selector.measure, selection.selector.voice, selection.selector.tick);
            }
            return selections_1.SmoSelection.pitchSelection(this.storeScore, this.staffMap[selection.selector.staff], selection.selector.measure, selection.selector.voice, selection.selector.tick, selection.selector.pitches);
        }
        catch (ex) {
            console.warn(ex);
            return null;
        }
    }
    /**
     * Get the equivalent selection from this.storeScore that maps to the displayed selection from this.score
     * @param selection
     * @returns
     */
    _getEquivalentGraceNote(selection, gn) {
        if (selection.note !== null) {
            const rv = selection.note.getGraceNotes().find((gg) => gg.attrs.id === gn.attrs.id);
            if (rv) {
                return rv;
            }
        }
        return gn;
    }
    /**
     * Get the rectangle of selections indicated by the parameters from the score
     * @param startSelector
     * @param endSelector
     * @param score
     * @returns
     */
    _getRectangleSelections(startSelector, endSelector) {
        const rv = [];
        let i = 0;
        let j = 0;
        for (i = startSelector.staff; i <= endSelector.staff; i++) {
            for (j = startSelector.measure; j <= endSelector.measure; j++) {
                const target = selections_1.SmoSelection.measureSelection(this.score, i, j);
                if (target !== null) {
                    rv.push(target);
                }
            }
        }
        return rv;
    }
    /**
     * set the grouping flag for undo operations
     * @param val
     */
    groupUndo(val) {
        this.storeUndo.grouping = val;
    }
    /**
     * Show all staves, 1:1 mapping of view score staff to stored score staff
     */
    get defaultStaffMap() {
        let i = 0;
        const rv = [];
        for (i = 0; i < this.storeScore.staves.length; ++i) {
            rv.push(i);
        }
        return rv;
    }
    /**
     * Bootstrapping function, creates the renderer and associated timers
     */
    startRenderingEngine() {
        if (!this.renderer.score) {
            // If there is only one part, display the part.
            if (this.storeScore.isPartExposed()) {
                this.exposePart(this.score.staves[0]);
            }
            // If the score is transposing, hide the instrument xpose settings
            this._setTransposing();
            this.renderer.score = this.score;
            this.renderer.setViewport();
        }
        this.renderer.startDemon();
    }
    /**
     * Gets the current mapping of displayed staves to score staves (this.storeScore)
     * @returns
     */
    getView() {
        const rv = [];
        let i = 0;
        for (i = 0; i < this.storeScore.staves.length; ++i) {
            const show = this.staffMap.indexOf(i) >= 0;
            rv.push({ show });
        }
        return rv;
    }
    /**
     * Update the staff ID when the view changes
     */
    setMappedStaffIds() {
        this.score.staves.forEach((staff) => {
            if (!this.isPartExposed()) {
                staff.partInfo.displayCues = staff.partInfo.cueInScore;
            }
            else {
                staff.partInfo.displayCues = false;
            }
            staff.setMappedStaffId(this.staffMap[staff.staffId]);
        });
    }
    /**
     * Exposes a part:  hides non-part staves, shows part staves.
     * Note this will reset the view.  After this operation, staff 0 will
     * be the selected part.
     * @param staff
     */
    exposePart(staff) {
        let i = 0;
        const exposeMap = [];
        let pushNext = false;
        for (i = 0; i < this.storeScore.staves.length; ++i) {
            const tS = this.storeScore.staves[i];
            const show = tS.staffId === staff.staffId;
            if (pushNext) {
                exposeMap.push({ show: true });
                pushNext = false;
            }
            else {
                exposeMap.push({ show });
                if (tS.partInfo.stavesAfter > 0 && show) {
                    pushNext = true;
                }
            }
        }
        this.setView(exposeMap);
    }
    /**
     * Indicates if the score is displaying in part-mode vs. score mode.
     * @returns
     */
    isPartExposed() {
        return this.score.isPartExposed();
    }
    /**
     * Parts have different formatting options from the parent score, indluding layout.  Reset
     * them when exposing a part.
     */
    _mapPartFormatting() {
        this.score.layoutManager = this.score.staves[0].partInfo.layoutManager;
        let replacedText = false;
        this.score.staves.forEach((staff) => {
            staff.updateMeasureFormatsForPart();
            if (staff.partInfo.preserveTextGroups && !replacedText) {
                const tga = [];
                replacedText = true;
                staff.partInfo.textGroups.forEach((tg) => {
                    tga.push(tg);
                });
                this.score.textGroups = tga;
            }
        });
    }
    /**
     * Update the list of staves in the score that are displayed.
    */
    setView(rows) {
        let i = 0;
        const any = rows.find((row) => row.show === true);
        if (!any) {
            return;
        }
        const nscore = score_1.SmoScore.deserialize(JSON.stringify(this.storeScore.serialize(true)));
        const staffMap = [];
        for (i = 0; i < rows.length; ++i) {
            const row = rows[i];
            if (row.show) {
                const srcStave = this.storeScore.staves[i];
                const jsonObj = srcStave.serialize();
                jsonObj.staffId = staffMap.length;
                const nStave = systemStaff_1.SmoSystemStaff.deserialize(jsonObj);
                nStave.mapStaffFromTo(i, nscore.staves.length);
                nscore.staves.push(nStave);
                if (srcStave.keySignatureMap) {
                    nStave.keySignatureMap = JSON.parse(JSON.stringify(srcStave.keySignatureMap));
                }
                nStave.measures.forEach((measure, ix) => {
                    const srcMeasure = srcStave.measures[ix];
                    measure.tempo = new measureModifiers_1.SmoTempoText(srcMeasure.tempo.serialize());
                    measure.timeSignature = new measureModifiers_2.TimeSignature(srcMeasure.timeSignature);
                    measure.keySignature = srcMeasure.keySignature;
                });
                staffMap.push(i);
            }
        }
        nscore.numberStaves();
        this.staffMap = staffMap;
        this.score = nscore;
        // Indicate which score staff view staves are mapped to, to decide to display
        // modifiers.
        this.setMappedStaffIds();
        // TODO: add part-specific measure formatting, etc.
        this._setTransposing();
        this.renderer.score = nscore;
        // If this current view is a part, show the part layout
        if (this.isPartExposed()) {
            this._mapPartFormatting();
            this.score.staves.forEach((staff) => {
                staff.partInfo.displayCues = false;
            });
            operations_1.SmoOperation.computeMultipartRest(nscore);
        }
        else {
            this.score.staves.forEach((staff) => {
                staff.partInfo.displayCues = staff.partInfo.cueInScore;
            });
        }
        window.dispatchEvent(new CustomEvent(renderState_1.scoreChangeEvent, { detail: { view: this } }));
        this.renderer.setViewport();
    }
    /**
     * view all the staffs in score mode.
     */
    viewAll() {
        this.score = score_1.SmoScore.deserialize(JSON.stringify(this.storeScore.serialize()));
        this.staffMap = this.defaultStaffMap;
        this.setMappedStaffIds();
        this._setTransposing();
        this.synchronizeTextGroups();
        this.renderer.score = this.score;
        window.dispatchEvent(new CustomEvent(renderState_1.scoreChangeEvent, { detail: { view: this } }));
        this.renderer.setViewport();
    }
    /**
     * Update score based on transposing flag.
     */
    _setTransposing() {
        var _a;
        if (!this.isPartExposed()) {
            const xpose = (_a = this.score.preferences) === null || _a === void 0 ? void 0 : _a.transposingScore;
            if (xpose) {
                this.score.setTransposing();
            }
        }
    }
    /**
     * Update the view after loading or restoring a completely new score
     * @param score
     * @returns
     */
    changeScore(score) {
        this.storeUndo.reset();
        player_1.SuiAudioPlayer.stopPlayer();
        this.renderer.score = score;
        this.renderer.setViewport();
        this.storeScore = score_1.SmoScore.deserialize(JSON.stringify(score.serialize()));
        this.score = score;
        // If the score is non-transposing, hide the instrument xpose settings
        this._setTransposing();
        this.staffMap = this.defaultStaffMap;
        this.setMappedStaffIds();
        this.synchronizeTextGroups();
        if (this.storeScore.isPartExposed()) {
            this.exposePart(this.score.staves[0]);
        }
        const rv = this.renderPromise();
        window.dispatchEvent(new CustomEvent(renderState_1.scoreChangeEvent, { detail: { view: this } }));
        return rv;
    }
    /**
     * for the view score, the renderer decides what to render
     * depending on what is undone.
     * @returns
     */
    undo() {
        if (!this.renderer.score) {
            return;
        }
        // A score-level undo might have changed the score.
        if (this.storeUndo.buffer.length < 1) {
            return;
        }
        const staffMap = {};
        const identityMap = {};
        this.defaultStaffMap.forEach((nn) => identityMap[nn] = nn);
        this.staffMap.forEach((mm, ix) => staffMap[mm] = ix);
        this.score = this.renderer.undo(this.storeUndo, staffMap);
        this.storeScore = this.storeUndo.undo(this.storeScore, identityMap, true);
    }
}
exports.SuiScoreView = SuiScoreView;
SuiScoreView.Instance = null;


/***/ }),

/***/ "./src/render/sui/scoreViewOperations.ts":
/*!***********************************************!*\
  !*** ./src/render/sui/scoreViewOperations.ts ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SuiScoreViewOperations = void 0;
// [Smoosic](https://github.com/AaronDavidNewman/Smoosic)
// Copyright (c) Aaron David Newman 2021.
const scoreView_1 = __webpack_require__(/*! ./scoreView */ "./src/render/sui/scoreView.ts");
const score_1 = __webpack_require__(/*! ../../smo/data/score */ "./src/smo/data/score.ts");
const systemStaff_1 = __webpack_require__(/*! ../../smo/data/systemStaff */ "./src/smo/data/systemStaff.ts");
const partInfo_1 = __webpack_require__(/*! ../../smo/data/partInfo */ "./src/smo/data/partInfo.ts");
const measure_1 = __webpack_require__(/*! ../../smo/data/measure */ "./src/smo/data/measure.ts");
const common_1 = __webpack_require__(/*! ../../smo/data/common */ "./src/smo/data/common.ts");
const scoreModifiers_1 = __webpack_require__(/*! ../../smo/data/scoreModifiers */ "./src/smo/data/scoreModifiers.ts");
const scoreText_1 = __webpack_require__(/*! ../../smo/data/scoreText */ "./src/smo/data/scoreText.ts");
const noteModifiers_1 = __webpack_require__(/*! ../../smo/data/noteModifiers */ "./src/smo/data/noteModifiers.ts");
const measureModifiers_1 = __webpack_require__(/*! ../../smo/data/measureModifiers */ "./src/smo/data/measureModifiers.ts");
const undo_1 = __webpack_require__(/*! ../../smo/xform/undo */ "./src/smo/xform/undo.ts");
const operations_1 = __webpack_require__(/*! ../../smo/xform/operations */ "./src/smo/xform/operations.ts");
const serializationHelpers_1 = __webpack_require__(/*! ../../common/serializationHelpers */ "./src/common/serializationHelpers.js");
const music_1 = __webpack_require__(/*! ../../smo/data/music */ "./src/smo/data/music.ts");
const oscillator_1 = __webpack_require__(/*! ../audio/oscillator */ "./src/render/audio/oscillator.ts");
const xmlToSmo_1 = __webpack_require__(/*! ../../smo/mxml/xmlToSmo */ "./src/smo/mxml/xmlToSmo.ts");
const player_1 = __webpack_require__(/*! ../audio/player */ "./src/render/audio/player.ts");
const xhrLoader_1 = __webpack_require__(/*! ../../ui/fileio/xhrLoader */ "./src/ui/fileio/xhrLoader.ts");
const selections_1 = __webpack_require__(/*! ../../smo/xform/selections */ "./src/smo/xform/selections.ts");
const staffModifiers_1 = __webpack_require__(/*! ../../smo/data/staffModifiers */ "./src/smo/data/staffModifiers.ts");
const piano_1 = __webpack_require__(/*! ./piano */ "./src/render/sui/piano.ts");
const svgHelpers_1 = __webpack_require__(/*! ./svgHelpers */ "./src/render/sui/svgHelpers.ts");
const promiseHelpers_1 = __webpack_require__(/*! ../../common/promiseHelpers */ "./src/common/promiseHelpers.ts");
/**
 * MVVM-like operations on the displayed score.
 *
 * All operations that can be performed on a 'live' score go through this
 * module.  It maps the score view to the actual score and makes sure the
 * model and view stay in sync.
 *
 * Because this object operates on the current selections,
 * all operations return promise so applications can wait for the
 * operation to complete and update the selection list.
 * @category SuiRender
 */
class SuiScoreViewOperations extends scoreView_1.SuiScoreView {
    /**
     * Add a new text group to the score
     * @param textGroup a new text group
     * @returns
     */
    addTextGroup(textGroup) {
        const altNew = scoreText_1.SmoTextGroup.deserializePreserveId(textGroup.serialize());
        undo_1.SmoUndoable.changeTextGroup(this.storeScore, this.storeUndo, altNew, undo_1.UndoBuffer.bufferSubtypes.ADD);
        if (this.isPartExposed()) {
            this.score.updateTextGroup(textGroup, true);
            const partInfo = this.storeScore.staves[this._getEquivalentStaff(0)].partInfo;
            partInfo.updateTextGroup(altNew, true);
        }
        else {
            this.score.addTextGroup(textGroup);
            this.storeScore.addTextGroup(altNew);
        }
        this.renderer.renderScoreModifiers();
        return this.renderer.updatePromise();
    }
    /**
     * Remove the text group from the score
     * @param textGroup
     * @returns
     */
    removeTextGroup(textGroup) {
        this.score.updateTextGroup(textGroup, false);
        const altGroup = scoreText_1.SmoTextGroup.deserializePreserveId(textGroup.serialize());
        textGroup.elements.forEach((el) => el.remove());
        textGroup.elements = [];
        const isPartExposed = this.isPartExposed();
        if (!isPartExposed) {
            undo_1.SmoUndoable.changeTextGroup(this.storeScore, this.storeUndo, altGroup, undo_1.UndoBuffer.bufferSubtypes.REMOVE);
            this.storeScore.updateTextGroup(altGroup, false);
        }
        else {
            const stave = this.storeScore.staves[this._getEquivalentStaff(0)];
            stave.partInfo.updateTextGroup(altGroup, false);
            undo_1.SmoUndoable.changeTextGroup(this.storeScore, this.storeUndo, altGroup, undo_1.UndoBuffer.bufferSubtypes.REMOVE);
        }
        this.renderer.renderScoreModifiers();
        return this.renderer.updatePromise();
    }
    /**
     * UPdate an existing text group.  The original is passed in, because since TG not tied to a musical
     * element, we need to find the one we're updating.
     * @param oldVersion
     * @param newVersion
     * @returns
     */
    updateTextGroup(oldVersion, newVersion) {
        const isPartExposed = this.isPartExposed();
        const altNew = scoreText_1.SmoTextGroup.deserializePreserveId(newVersion.serialize());
        this.score.updateTextGroup(newVersion, true);
        // If this is part text, don't store it in the score text, except for the displayed score
        if (!isPartExposed) {
            undo_1.SmoUndoable.changeTextGroup(this.storeScore, this.storeUndo, altNew, undo_1.UndoBuffer.bufferSubtypes.UPDATE);
            this.storeScore.updateTextGroup(altNew, true);
        }
        else {
            this.storeScore.staves[this._getEquivalentStaff(0)].partInfo.updateTextGroup(altNew, true);
        }
        // TODO: only render the one TG.
        this.renderer.renderScoreModifiers();
        // return this.renderer.updatePromise();
    }
    /**
     * load an mxml score remotely, return a promise that
     * completes when the file is loaded
     * @param url where to find the xml file
     * @returns
     */
    loadRemoteXml(url) {
        return __awaiter(this, void 0, void 0, function* () {
            const req = new xhrLoader_1.SuiXhrLoader(url);
            const self = this;
            // Shouldn't we return promise of actually displaying the score?
            yield req.loadAsync();
            const parser = new DOMParser();
            const xml = parser.parseFromString(req.value, 'text/xml');
            const score = xmlToSmo_1.XmlToSmo.convert(xml);
            score.layoutManager.zoomToWidth($('body').width());
            self.changeScore(score);
        });
    }
    /**
     * load a remote score in SMO format
     * @param url url to find the score
     * @returns
     */
    loadRemoteJson(url) {
        return __awaiter(this, void 0, void 0, function* () {
            const req = new xhrLoader_1.SuiXhrLoader(url);
            const self = this;
            return req.loadAsync().then(() => {
                const score = score_1.SmoScore.deserialize(req.value);
                self.changeScore(score);
            });
        });
    }
    /**
     * Load a remote score, return promise when it's been loaded
     * from afar.
     * @param pref
     * @returns
     */
    loadRemoteScore(url) {
        if (url.endsWith('xml') || url.endsWith('mxl')) {
            return this.loadRemoteXml(url);
        }
        else {
            return this.loadRemoteJson(url);
        }
    }
    updateAudioSettings(pref) {
        this._undoScorePreferences('Update preferences');
        this.score.audioSettings = pref;
        this.storeScore.audioSettings = new scoreModifiers_1.SmoAudioPlayerSettings(pref);
        // No rendering to be done
        return this.renderer.updatePromise();
    }
    /**
     * Global settings that control how the score editor behaves
     * @param pref
     * @returns
     */
    updateScorePreferences(pref) {
        this._undoScorePreferences('Update preferences');
        const oldXpose = this.score.preferences.transposingScore;
        const curXpose = pref.transposingScore;
        this.score.updateScorePreferences(new score_1.SmoScorePreferences(pref));
        this.storeScore.updateScorePreferences(new score_1.SmoScorePreferences(pref));
        if (curXpose === false && oldXpose === true) {
            this.score.setNonTransposing();
        }
        else if (curXpose === true && oldXpose === false) {
            this.score.setTransposing();
        }
        this.renderer.setDirty();
        return this.renderer.updatePromise();
    }
    /**
     * Update information about the score, composer etc.
     * @param scoreInfo
     * @returns
     */
    updateScoreInfo(scoreInfo) {
        this._undoScorePreferences('Update preferences');
        this.score.scoreInfo = scoreInfo;
        this.storeScore.scoreInfo = JSON.parse(JSON.stringify(scoreInfo));
        return this.renderer.updatePromise();
    }
    /**
     * Add a specific microtone modifier to the selected notes
     * @param tone
     * @returns
     */
    addRemoveMicrotone(tone) {
        const selections = this.tracker.selections;
        const altSelections = this._getEquivalentSelections(selections);
        const measureSelections = this._undoTrackerMeasureSelections('add/remove microtone');
        operations_1.SmoOperation.addRemoveMicrotone(null, selections, tone);
        operations_1.SmoOperation.addRemoveMicrotone(null, altSelections, tone);
        this._renderChangedMeasures(measureSelections);
        return this.renderer.updatePromise();
    }
    /**
     * Modify the dynamics assoicated with the specific selection
     * @param selection
     * @param dynamic
     * @returns
     */
    addDynamic(selection, dynamic) {
        this._undoFirstMeasureSelection('add dynamic');
        this._removeDynamic(selection, dynamic);
        const equiv = this._getEquivalentSelection(selection);
        operations_1.SmoOperation.addDynamic(selection, dynamic);
        operations_1.SmoOperation.addDynamic(equiv, noteModifiers_1.SmoNoteModifierBase.deserialize(dynamic.serialize()));
        this.renderer.addToReplaceQueue(selection);
        return this.renderer.updatePromise();
    }
    /**
     * Remove dynamics from the selection
     * @param selection
     * @param dynamic
     * @returns
     */
    _removeDynamic(selection, dynamic) {
        const equiv = this._getEquivalentSelection(selection);
        if (equiv !== null && equiv.note !== null) {
            const altModifiers = equiv.note.getModifiers('SmoDynamicText');
            operations_1.SmoOperation.removeDynamic(selection, dynamic);
            if (altModifiers.length) {
                operations_1.SmoOperation.removeDynamic(equiv, altModifiers[0]);
            }
        }
        return this.renderer.updatePromise();
    }
    /**
     * Remove dynamics from the current selection
     * @param dynamic
     * @returns
     */
    removeDynamic(dynamic) {
        const sel = this.tracker.modifierSelections[0];
        if (!sel.selection) {
            return promiseHelpers_1.PromiseHelpers.emptyPromise();
        }
        this.tracker.selections = [sel.selection];
        this._undoFirstMeasureSelection('remove dynamic');
        this._removeDynamic(sel.selection, dynamic);
        this.renderer.addToReplaceQueue(sel.selection);
        return this.renderer.updatePromise();
    }
    /**
     * we never really delete a note, but we will convert it into a rest and if it's
     * already a rest we will try to hide it.
     * Operates on current selections
     * */
    deleteNote() {
        const measureSelections = this._undoTrackerMeasureSelections('delete note');
        this.tracker.selections.forEach((sel) => {
            if (sel.note) {
                const altSel = this._getEquivalentSelection(sel);
                // set the pitch to be a good position for the rest
                const pitch = JSON.parse(JSON.stringify(measure_1.SmoMeasure.defaultPitchForClef[sel.measure.clef]));
                const altPitch = JSON.parse(JSON.stringify(measure_1.SmoMeasure.defaultPitchForClef[altSel.measure.clef]));
                sel.note.pitches = [pitch];
                altSel.note.pitches = [altPitch];
                // If the note is a note, make it into a rest.  If the note is a rest already,
                // make it invisible.  If it is invisible already, make it back into a rest.
                if (sel.note.isRest() && !sel.note.isHidden()) {
                    sel.note.makeHidden(true);
                    altSel.note.makeHidden(true);
                }
                else {
                    sel.note.makeRest();
                    altSel.note.makeRest();
                    sel.note.makeHidden(false);
                    altSel.note.makeHidden(false);
                }
            }
        });
        this._renderChangedMeasures(measureSelections);
        return this.renderer.updatePromise();
    }
    /**
    * The lyric editor moves around, so we can't depend on the tracker for the
    * correct selection.  We get it directly from the editor.
    *
    * @param selector - the selector of the note with the lyric to remove
    * @param lyric - a copy of the lyric to remove.  We use the verse, parser to identify it
    * @returns render promise
    */
    removeLyric(selector, lyric) {
        const selection = selections_1.SmoSelection.noteFromSelector(this.score, selector);
        if (selection === null) {
            return promiseHelpers_1.PromiseHelpers.emptyPromise();
        }
        this._undoSelection('remove lyric', selection);
        selection.note.removeLyric(lyric);
        const equiv = this._getEquivalentSelection(selection);
        const storeLyric = equiv.note.getLyricForVerse(lyric.verse, lyric.parser);
        if (typeof (storeLyric) !== 'undefined') {
            equiv.note.removeLyric(lyric);
        }
        this.renderer.addToReplaceQueue(selection);
        lyric.deleted = true;
        return this.renderer.updatePromise();
    }
    /**
     * @param selector where to add or update the lyric
     * @param lyric a copy of the lyric to remove
     * @returns
     */
    addOrUpdateLyric(selector, lyric) {
        const selection = selections_1.SmoSelection.noteFromSelector(this.score, selector);
        if (selection === null) {
            return promiseHelpers_1.PromiseHelpers.emptyPromise();
        }
        this._undoSelection('update lyric', selection);
        selection.note.addLyric(lyric);
        const equiv = this._getEquivalentSelection(selection);
        const altLyric = noteModifiers_1.SmoNoteModifierBase.deserialize(lyric.serialize());
        equiv.note.addLyric(altLyric);
        this.renderer.addToReplaceQueue(selection);
        return this.renderer.updatePromise();
    }
    /**
     * Delete all the notes for the currently selected voice
     * @returns
     */
    depopulateVoice() {
        const measureSelections = this._undoTrackerMeasureSelections('depopulate voice');
        measureSelections.forEach((selection) => {
            const ix = selection.measure.getActiveVoice();
            if (ix !== 0) {
                operations_1.SmoOperation.depopulateVoice(selection, ix);
                const equiv = this._getEquivalentSelection(selection);
                operations_1.SmoOperation.depopulateVoice(equiv, ix);
            }
        });
        operations_1.SmoOperation.setActiveVoice(this.score, 0);
        this._renderChangedMeasures(measureSelections);
        return this.renderer.updatePromise();
    }
    /**
     * Change the active voice in a multi-voice measure.
     * @param index
     * @returns
     */
    _changeActiveVoice(index) {
        const measuresToAdd = [];
        const measureSelections = selections_1.SmoSelection.getMeasureList(this.tracker.selections);
        measureSelections.forEach((measureSelection) => {
            if (index === measureSelection.measure.voices.length) {
                measuresToAdd.push(measureSelection);
            }
        });
        return measuresToAdd;
    }
    /**
     * Populate a new voice with default notes
     * @param index the voice to populate
     * @returns
     */
    populateVoice(index) {
        const measuresToAdd = this._changeActiveVoice(index);
        if (measuresToAdd.length === 0) {
            operations_1.SmoOperation.setActiveVoice(this.score, index);
            this.tracker.selectActiveVoice();
            return this.renderer.updatePromise();
        }
        measuresToAdd.forEach((selection) => {
            this._undoSelection('popualteVoice', selection);
            operations_1.SmoOperation.populateVoice(selection, index);
            const equiv = this._getEquivalentSelection(selection);
            operations_1.SmoOperation.populateVoice(equiv, index);
        });
        operations_1.SmoOperation.setActiveVoice(this.score, index);
        this._renderChangedMeasures(measuresToAdd);
        return this.renderer.updatePromise();
    }
    /**
     * Assign an instrument to a set of measures
     * @param instrument the instrument to assign to the selections
     * @param selections
     * @returns
     */
    changeInstrument(instrument, selections) {
        if (typeof (selections) === 'undefined') {
            selections = this.tracker.selections;
        }
        this._undoSelections('change instrument', selections);
        const altSelections = this._getEquivalentSelections(selections);
        operations_1.SmoOperation.changeInstrument(instrument, selections);
        operations_1.SmoOperation.changeInstrument(instrument, altSelections);
        this._renderChangedMeasures(selections);
        return this.renderer.updatePromise();
    }
    /**
     * Set the time signature for a selection
     * @param timeSignature actual time signature
     * @param timeSignatureString display time signature if different, as in for pickup notes
     */
    setTimeSignature(timeSignature, timeSignatureString) {
        this._undoScore('Set time signature');
        const selections = this.tracker.selections;
        const altSelections = this._getEquivalentSelections(selections);
        operations_1.SmoOperation.setTimeSignature(this.score, selections, timeSignature, timeSignatureString);
        operations_1.SmoOperation.setTimeSignature(this.storeScore, altSelections, timeSignature, timeSignatureString);
        this._renderChangedMeasures(selections_1.SmoSelection.getMeasureList(this.tracker.selections));
        return this.renderer.updatePromise();
    }
    /**
     * Move selected staff up or down in the score.
     * @param index direction to move
     * @returns
     */
    moveStaffUpDown(index) {
        this._undoScore('re-order staves');
        // Get staff to move
        const selection = this._getEquivalentSelection(this.tracker.selections[0]);
        // Make the move in the model, and reset the view so we can see the new
        // arrangement
        operations_1.SmoOperation.moveStaffUpDown(this.storeScore, selection, index);
        this.viewAll();
        return this.renderer.updatePromise();
    }
    /**
     * Update the staff group for a score, which determines how the staves
     * are justified and bracketed
     * @param staffGroup
     */
    addOrUpdateStaffGroup(staffGroup) {
        this._undoScore('group staves');
        // Assume that the view is now set to full score
        this.score.addOrReplaceSystemGroup(staffGroup);
        this.storeScore.addOrReplaceSystemGroup(staffGroup);
        this.renderer.setDirty();
        return this.renderer.updatePromise();
    }
    /**
     * UPdate tempo for all or part of the score
     * @param measure the measure with the tempo.  Tempo is measure-wide parameter
     * @param scoreMode if true, update whole score.  Else selections
     * @returns
     */
    updateTempoScore(measure, tempo, scoreMode, selectionMode) {
        let measureIndex = 0;
        const originalTempo = new measureModifiers_1.SmoTempoText(measure.tempo);
        this._undoColumn('update tempo', measure.measureNumber.measureIndex);
        let startMeasure = measure.measureNumber.measureIndex;
        let endMeasure = this.score.staves[0].measures.length;
        let displayed = false;
        if (selectionMode) {
            const endSel = this.tracker.getExtremeSelection(1);
            if (endSel.selector.measure > startMeasure) {
                endMeasure = endSel.selector.measure;
            }
        }
        // If we are only changing the position of the text, it only affects the tempo measure.
        if (measureModifiers_1.SmoTempoText.eq(originalTempo, tempo) && tempo.yOffset !== originalTempo.yOffset && endMeasure > startMeasure) {
            endMeasure = startMeasure + 1;
        }
        for (measureIndex = startMeasure; measureIndex < endMeasure; ++measureIndex) {
            if (!scoreMode && !selectionMode) {
                // If not whole score or selections, change until the tempo doesn't match previous measure's tempo (next tempo change)
                const compMeasure = this.score.staves[0].measures[measureIndex];
                if (measureModifiers_1.SmoTempoText.eq(originalTempo, compMeasure.tempo) || displayed === false) {
                    const sel = selections_1.SmoSelection.measureSelection(this.score, 0, measureIndex);
                    const altSel = selections_1.SmoSelection.measureSelection(this.storeScore, 0, measureIndex);
                    if (sel && sel.measure.tempo.display && !displayed) {
                        this.renderer.addToReplaceQueue(sel);
                        displayed = true;
                    }
                    if (sel) {
                        operations_1.SmoOperation.addTempo(this.score, sel, tempo);
                    }
                    if (altSel) {
                        operations_1.SmoOperation.addTempo(this.storeScore, altSel, tempo);
                    }
                }
                else {
                    break;
                }
            }
            else {
                const sel = selections_1.SmoSelection.measureSelection(this.score, 0, measureIndex);
                const altSel = selections_1.SmoSelection.measureSelection(this.storeScore, 0, measureIndex);
                if (sel) {
                    operations_1.SmoOperation.addTempo(this.score, sel, tempo);
                    if (!displayed) {
                        this.renderer.addToReplaceQueue(sel);
                        displayed = true;
                    }
                }
                if (altSel) {
                    operations_1.SmoOperation.addTempo(this.storeScore, altSel, tempo);
                }
            }
        }
        return this.renderer.updatePromise();
    }
    /**
     * 'remove' tempo, which means either setting the bars to the
     * default tempo, or the previously-set tempo.
     * @param scoreMode whether to reset entire score
     */
    removeTempo(measure, tempo, scoreMode, selectionMode) {
        const startSelection = this.tracker.selections[0];
        if (startSelection.selector.measure > 0) {
            const measureIx = startSelection.selector.measure - 1;
            const target = startSelection.staff.measures[measureIx];
            const tempo = target.getTempo();
            const newTempo = new measureModifiers_1.SmoTempoText(tempo);
            newTempo.display = false;
            this.updateTempoScore(measure, newTempo, scoreMode, selectionMode);
        }
        else {
            this.updateTempoScore(measure, new measureModifiers_1.SmoTempoText(measureModifiers_1.SmoTempoText.defaults), scoreMode, selectionMode);
        }
        return this.renderer.updatePromise();
    }
    /**
     * Add a grace note to the selected real notes.
     */
    addGraceNote() {
        const selections = this.tracker.selections;
        const measureSelections = this._undoTrackerMeasureSelections('add grace note');
        selections.forEach((selection) => {
            const index = selection.note.getGraceNotes().length;
            const pitches = JSON.parse(JSON.stringify(selection.note.pitches));
            const grace = new noteModifiers_1.SmoGraceNote({
                pitches, ticks: { numerator: 2048, denominator: 1, remainder: 0 }
            });
            operations_1.SmoOperation.addGraceNote(selection, grace, index);
            const altPitches = JSON.parse(JSON.stringify(selection.note.pitches));
            const altGrace = new noteModifiers_1.SmoGraceNote({
                pitches: altPitches, ticks: { numerator: 2048, denominator: 1, remainder: 0 }
            });
            altGrace.attrs.id = grace.attrs.id;
            const altSelection = this._getEquivalentSelection(selection);
            operations_1.SmoOperation.addGraceNote(altSelection, altGrace, index);
        });
        this._renderChangedMeasures(measureSelections);
        return this.renderer.updatePromise();
    }
    /**
     * remove selected grace note
     * @returns
     */
    removeGraceNote() {
        const selections = this.tracker.selections;
        const measureSelections = this._undoTrackerMeasureSelections('remove grace note');
        selections.forEach((selection) => {
            // TODO: get the correct offset
            operations_1.SmoOperation.removeGraceNote(selection, 0);
            const altSel = (this._getEquivalentSelection(selection));
            operations_1.SmoOperation.removeGraceNote(altSel, 0);
        });
        this._renderChangedMeasures(measureSelections);
        return this.renderer.updatePromise();
    }
    /**
     * Toggle slash in stem of grace note
     */
    slashGraceNotes() {
        const grace = this.tracker.getSelectedGraceNotes();
        const measureSelections = this._undoTrackerMeasureSelections('slash grace note toggle');
        grace.forEach((gn) => {
            operations_1.SmoOperation.slashGraceNotes(gn);
            if (gn.selection !== null) {
                const altSelection = this._getEquivalentSelection(gn.selection);
                const altGn = this._getEquivalentGraceNote(altSelection, gn.modifier);
                operations_1.SmoOperation.slashGraceNotes({
                    selection: altSelection, modifier: altGn,
                    box: common_1.SvgBox.default, index: 0
                });
            }
        });
        this._renderChangedMeasures(measureSelections);
        return this.renderer.updatePromise();
    }
    /**
     * transpose selected notes
     * @param offset 1/2 steps
     * @returns
     */
    transposeSelections(offset) {
        const selections = this.tracker.selections;
        const measureSelections = this._undoTrackerMeasureSelections('transpose');
        const grace = this.tracker.getSelectedGraceNotes();
        if (grace.length) {
            grace.forEach((artifact) => {
                if (artifact.selection !== null && artifact.selection.note !== null) {
                    const gn1 = artifact.modifier;
                    const index = artifact.selection.note.graceNotes.findIndex((x) => x.attrs.id === gn1.attrs.id);
                    const altSelection = this._getEquivalentSelection(artifact.selection);
                    if (altSelection && altSelection.note !== null) {
                        const gn2 = altSelection.note.graceNotes[index];
                        operations_1.SmoOperation.transposeGraceNotes(altSelection, [gn2], offset);
                    }
                    operations_1.SmoOperation.transposeGraceNotes(artifact.selection, [gn1], offset);
                }
            });
        }
        else {
            selections.forEach((selected) => {
                operations_1.SmoOperation.transpose(selected, offset);
                const altSel = this._getEquivalentSelection(selected);
                operations_1.SmoOperation.transpose(altSel, offset);
            });
            if (selections.length === 1 && this.score.preferences.autoPlay) {
                oscillator_1.SuiOscillator.playSelectionNow(selections[0], this.score, 1);
            }
        }
        this._renderChangedMeasures(measureSelections);
        return this.renderer.updatePromise();
    }
    /**
     * toggle the accidental spelling of the selected notes
     * @returns
     */
    toggleEnharmonic() {
        const selections = this.tracker.selections;
        const measureSelections = this._undoTrackerMeasureSelections('toggle enharmonic');
        const grace = this.tracker.getSelectedGraceNotes();
        if (grace.length) {
            grace.forEach((artifact) => {
                operations_1.SmoOperation.toggleGraceNoteEnharmonic(artifact.selection, [artifact.modifier]);
                const altSelection = this._getEquivalentSelection(artifact.selection);
                const altGr = this._getEquivalentGraceNote(altSelection, artifact.modifier);
                operations_1.SmoOperation.toggleGraceNoteEnharmonic(altSelection, [altGr]);
            });
        }
        else {
            selections.forEach((selected) => {
                if (typeof (selected.selector.pitches) === 'undefined') {
                    selected.selector.pitches = [];
                }
                operations_1.SmoOperation.toggleEnharmonic(selected);
                const altSel = this._getEquivalentSelection(selected);
                operations_1.SmoOperation.toggleEnharmonic(altSel);
            });
        }
        this._renderChangedMeasures(measureSelections);
        return this.renderer.updatePromise();
    }
    /**
     * Toggle cautionary/courtesy accidentals
     */
    toggleCourtesyAccidentals() {
        const selections = this.tracker.selections;
        const measureSelections = this._undoTrackerMeasureSelections('toggle courtesy accidental');
        const grace = this.tracker.getSelectedGraceNotes();
        if (grace.length) {
            grace.forEach((artifact) => {
                const gn1 = [artifact.modifier];
                operations_1.SmoOperation.toggleGraceNoteCourtesy(artifact.selection, gn1);
                const altSel = this._getEquivalentSelection(artifact.selection);
                const gn2 = this._getEquivalentGraceNote(altSel, gn1[0]);
                operations_1.SmoOperation.toggleGraceNoteCourtesy(altSel, [gn2]);
            });
        }
        else {
            selections.forEach((selection) => {
                operations_1.SmoOperation.toggleCourtesyAccidental(selection);
                const altSel = this._getEquivalentSelection(selection);
                operations_1.SmoOperation.toggleCourtesyAccidental(altSel);
            });
        }
        this._renderChangedMeasures(measureSelections);
        return this.renderer.updatePromise();
    }
    /**
     * change the duration of notes for selected, creating more
     * or fewer notes.
     * After the change, reset the selection so it's as close as possible
     * to the original length
     * @param operation
     * @returns
     */
    batchDurationOperation(operation) {
        const selections = this.tracker.selections;
        const measureSelections = this._undoTrackerMeasureSelections('change duration');
        const grace = this.tracker.getSelectedGraceNotes();
        const graceMap = {
            doubleDuration: 'doubleGraceNoteDuration',
            halveDuration: 'halveGraceNoteDuration'
        };
        if (grace.length && typeof (graceMap[operation]) !== 'undefined') {
            operation = graceMap[operation];
            grace.forEach((artifact) => {
                operations_1.SmoOperation[operation](artifact.selection, artifact.modifier);
                const altSelection = this._getEquivalentSelection(artifact.selection);
                const gn2 = this._getEquivalentGraceNote(altSelection, artifact.modifier);
                operations_1.SmoOperation[operation](altSelection, gn2);
            });
        }
        else {
            const altAr = this._getEquivalentSelections(selections);
            operations_1.SmoOperation.batchSelectionOperation(this.score, selections, operation);
            operations_1.SmoOperation.batchSelectionOperation(this.storeScore, altAr, operation);
        }
        this._renderChangedMeasures(measureSelections);
        return this.renderer.updatePromise();
    }
    /**
     * Toggle selected modifier on selected notes
     * @param modifier
     * @param ctor parent class constructor (e.g. SmoOrnament)
     * @returns
     */
    toggleArticulation(modifier, ctor) {
        const measureSelections = this._undoTrackerMeasureSelections('toggle articulation');
        this.tracker.selections.forEach((sel) => {
            if (ctor === 'SmoArticulation') {
                const aa = new noteModifiers_1.SmoArticulation({ articulation: modifier });
                const altAa = new noteModifiers_1.SmoArticulation({ articulation: modifier });
                altAa.attrs.id = aa.attrs.id;
                operations_1.SmoOperation.toggleArticulation(sel, aa);
                const altSelection = this._getEquivalentSelection(sel);
                operations_1.SmoOperation.toggleArticulation(altSelection, altAa);
            }
            else {
                const aa = new noteModifiers_1.SmoOrnament({ ornament: modifier });
                const altAa = new noteModifiers_1.SmoOrnament({ ornament: modifier });
                altAa.attrs.id = aa.attrs.id;
                const altSelection = this._getEquivalentSelection(sel);
                operations_1.SmoOperation.toggleOrnament(sel, aa);
                operations_1.SmoOperation.toggleOrnament(altSelection, altAa);
            }
        });
        this._renderChangedMeasures(measureSelections);
        return this.renderer.updatePromise();
    }
    /**
     * convert non-tuplet not to a tuplet
     * @param numNotes 3 means triplet, etc.
     */
    makeTuplet(numNotes) {
        const selection = this.tracker.selections[0];
        const measureSelections = this._undoTrackerMeasureSelections('make tuplet');
        operations_1.SmoOperation.makeTuplet(selection, numNotes);
        const altSelection = this._getEquivalentSelection(selection);
        operations_1.SmoOperation.makeTuplet(altSelection, numNotes);
        this._renderChangedMeasures(measureSelections);
        return this.renderer.updatePromise();
    }
    /**
     * Convert selected tuplet to a single (if possible) non-tuplet
     */
    unmakeTuplet() {
        const selection = this.tracker.selections[0];
        const measureSelections = this._undoTrackerMeasureSelections('unmake tuplet');
        operations_1.SmoOperation.unmakeTuplet(selection);
        const altSelection = this._getEquivalentSelection(selection);
        operations_1.SmoOperation.unmakeTuplet(altSelection);
        this._renderChangedMeasures(measureSelections);
        return this.renderer.updatePromise();
    }
    /**
     * Create a chord by adding an interval to selected note
     * @param interval 1/2 steps
     * @returns
     */
    setInterval(interval) {
        const selections = this.tracker.selections;
        const measureSelections = this._undoTrackerMeasureSelections('set interval');
        selections.forEach((selected) => {
            operations_1.SmoOperation.interval(selected, interval);
            const altSelection = this._getEquivalentSelection(selected);
            operations_1.SmoOperation.interval(altSelection, interval);
        });
        this._renderChangedMeasures(measureSelections);
        return this.renderer.updatePromise();
    }
    /**
     * change the selected chord into a single note
     * @returns
     */
    collapseChord() {
        const selections = this.tracker.selections;
        const measureSelections = this._undoTrackerMeasureSelections('collapse chord');
        selections.forEach((selected) => {
            const note = selected.note;
            if (note) {
                const pp = JSON.parse(JSON.stringify(note.pitches[0]));
                const altpp = JSON.parse(JSON.stringify(note.pitches[0]));
                // No operation for this?
                note.pitches = [pp];
                const altSelection = this._getEquivalentSelection(selected);
                altSelection.note.pitches = [altpp];
            }
        });
        this._renderChangedMeasures(measureSelections);
        return this.renderer.updatePromise();
    }
    /**
     * Toggle chicken-scratches, for jazz improv, comping etc.
     */
    toggleSlash() {
        const selections = this.tracker.selections;
        const measureSelections = this._undoTrackerMeasureSelections('make slash');
        selections.forEach((selection) => {
            operations_1.SmoOperation.toggleSlash(selection);
            const altSel = this._getEquivalentSelection(selection);
            operations_1.SmoOperation.toggleSlash(altSel);
        });
        this._renderChangedMeasures(measureSelections);
        return this.renderer.updatePromise();
    }
    /**
     * make selected notes into a rest, or visa-versa
     * @returns
     */
    makeRest() {
        const selections = this.tracker.selections;
        const measureSelections = this._undoTrackerMeasureSelections('make rest');
        selections.forEach((selection) => {
            operations_1.SmoOperation.toggleRest(selection);
            const altSel = this._getEquivalentSelection(selection);
            operations_1.SmoOperation.toggleRest(altSel);
        });
        this._renderChangedMeasures(measureSelections);
        return this.renderer.updatePromise();
    }
    /**
     * toggle the 'end beam' flag for selected notes
     * @returns
     */
    toggleBeamGroup() {
        const selections = this.tracker.selections;
        const measureSelections = this._undoTrackerMeasureSelections('toggle beam group');
        selections.forEach((selection) => {
            operations_1.SmoOperation.toggleBeamGroup(selection);
            const altSel = this._getEquivalentSelection(selection);
            operations_1.SmoOperation.toggleBeamGroup(altSel);
        });
        this._renderChangedMeasures(measureSelections);
        return this.renderer.updatePromise();
    }
    toggleCue() {
        return __awaiter(this, void 0, void 0, function* () {
            const measureSelections = this._undoTrackerMeasureSelections('toggle note cue');
            this.tracker.selections.forEach((selection) => {
                const altSelection = this._getEquivalentSelection(selection);
                if (selection.note && selection.note.isRest() === false) {
                    selection.note.isCue = !selection.note.isCue;
                    if (altSelection && altSelection.note) {
                        altSelection.note.isCue = selection.note.isCue;
                    }
                }
            });
            this._renderChangedMeasures(measureSelections);
            yield this.renderer.updatePromise();
        });
    }
    /**
    * up or down
    * @returns
    */
    toggleBeamDirection() {
        const selections = this.tracker.selections;
        if (selections.length < 1) {
            return promiseHelpers_1.PromiseHelpers.emptyPromise();
        }
        const measureSelections = this._undoTrackerMeasureSelections('toggle beam direction');
        operations_1.SmoOperation.toggleBeamDirection(selections);
        operations_1.SmoOperation.toggleBeamDirection(this._getEquivalentSelections(selections));
        this._renderChangedMeasures(measureSelections);
        return this.renderer.updatePromise();
    }
    /**
     * Add the selected notes to a beam group
     */
    beamSelections() {
        const selections = this.tracker.selections;
        const measureSelections = this._undoTrackerMeasureSelections('beam selections');
        operations_1.SmoOperation.beamSelections(this.score, selections);
        operations_1.SmoOperation.beamSelections(this.storeScore, this._getEquivalentSelections(selections));
        this._renderChangedMeasures(measureSelections);
        return this.renderer.updatePromise();
    }
    /**
     * change key signature for selected measures
     * @param keySignature vex key signature
     */
    addKeySignature(keySignature) {
        const measureSelections = this._undoTrackerMeasureSelections('set key signature ' + keySignature);
        measureSelections.forEach((sel) => {
            operations_1.SmoOperation.addKeySignature(this.score, sel, keySignature);
            const altSel = this._getEquivalentSelection(sel);
            operations_1.SmoOperation.addKeySignature(this.storeScore, altSel, keySignature);
        });
        this._renderChangedMeasures(measureSelections);
        return this.renderer.updatePromise();
    }
    /**
     * Sets a pitch from the piano widget.
     * @param pitch {Pitch}
     * @param chordPedal {boolean} - indicates we are adding to a chord
     */
    setPitchPiano(pitch, chordPedal) {
        const measureSelections = this._undoTrackerMeasureSelections('setAbsolutePitch ' + pitch.letter + '/' + pitch.accidental);
        this.tracker.selections.forEach((selected) => {
            const npitch = {
                letter: pitch.letter,
                accidental: pitch.accidental, octave: pitch.octave
            };
            const octave = measure_1.SmoMeasure.defaultPitchForClef[selected.measure.clef].octave;
            npitch.octave += octave;
            const altSel = this._getEquivalentSelection(selected);
            if (chordPedal && selected.note) {
                selected.note.toggleAddPitch(npitch);
                altSel.note.toggleAddPitch(npitch);
            }
            else {
                operations_1.SmoOperation.setPitch(selected, [npitch]);
                operations_1.SmoOperation.setPitch(altSel, [npitch]);
            }
        });
        this._renderChangedMeasures(measureSelections);
        return this.renderer.updatePromise();
    }
    /**
     * show or hide the piano widget
     * @param value to show it
     */
    showPiano(value) {
        this.score.preferences.showPiano = value;
        this.storeScore.preferences.showPiano = value;
        if (value) {
            piano_1.SuiPiano.showPiano();
        }
        else {
            piano_1.SuiPiano.hidePiano();
        }
        return this.renderer.updatePromise();
    }
    /**
     * Render a pitch for each letter name-pitch in the string,
     * @param pitches letter names for pitches
     * @returns promise, resolved when all pitches rendered
     * @see setPitch
     */
    setPitchesPromise(pitches) {
        const self = this;
        const promise = new Promise((resolve) => {
            const fc = (index) => {
                if (index >= pitches.length) {
                    resolve();
                }
                else {
                    self.setPitch(pitches[index]).then(() => {
                        fc(index + 1);
                    });
                }
            };
            fc(0);
        });
        return promise;
    }
    /**
     * Add a pitch to the score at the cursor.  This tries to find the best pitch
     * to match the letter key (F vs F# for instance) based on key and surrounding notes
     * @param letter string
     */
    setPitch(letter) {
        const selections = this.tracker.selections;
        const measureSelections = this._undoTrackerMeasureSelections('set pitch ' + letter);
        selections.forEach((selected) => {
            const selector = selected.selector;
            let hintSel = selections_1.SmoSelection.lastNoteSelection(this.score, selector.staff, selector.measure, selector.voice, selector.tick);
            if (!hintSel) {
                hintSel = selections_1.SmoSelection.nextNoteSelection(this.score, selector.staff, selector.measure, selector.voice, selector.tick);
            }
            // The selection no longer exists, possibly deleted
            if (hintSel === null || hintSel.note === null) {
                return promiseHelpers_1.PromiseHelpers.emptyPromise();
            }
            const pitch = music_1.SmoMusic.getLetterNotePitch(hintSel.note.pitches[0], letter, hintSel.measure.keySignature);
            operations_1.SmoOperation.setPitch(selected, [pitch]);
            const altSel = this._getEquivalentSelection(selected);
            operations_1.SmoOperation.setPitch(altSel, [pitch]);
            if (this.score.preferences.autoAdvance) {
                this.tracker.moveSelectionRight(this.score, null, true);
            }
        });
        if (selections.length === 1 && this.score.preferences.autoPlay) {
            oscillator_1.SuiOscillator.playSelectionNow(selections[0], this.score, 1);
        }
        this._renderChangedMeasures(measureSelections);
        return this.renderer.updatePromise();
    }
    /**
     * Generic clipboard copy action
     */
    copy() {
        this.pasteBuffer.setSelections(this.score, this.tracker.selections);
        const altAr = [];
        this.tracker.selections.forEach((sel) => {
            const noteSelection = this._getEquivalentSelection(sel);
            if (noteSelection !== null) {
                altAr.push(noteSelection);
            }
        });
        this.storePaste.setSelections(this.storeScore, altAr);
        return this.renderer.updatePromise();
    }
    /**
     * clipboard paste action
     * @returns
     */
    paste() {
        // We undo the whole score on a paste, since we don't yet know the
        // extent of the overlap
        this._undoScore('paste');
        this.renderer.preserveScroll();
        const firstSelection = this.tracker.selections[0];
        const pasteTarget = firstSelection.selector;
        const altSelection = this._getEquivalentSelection(firstSelection);
        const altTarget = altSelection.selector;
        this.pasteBuffer.pasteSelections(pasteTarget);
        this.storePaste.pasteSelections(altTarget);
        this._renderChangedMeasures(this.pasteBuffer.replacementMeasures);
        return this.renderer.updatePromise();
    }
    /**
     * specify a note head other than the default for the duration
     * @param head
     */
    setNoteHead(head) {
        const selections = this.tracker.selections;
        const measureSelections = this._undoTrackerMeasureSelections('set note head');
        operations_1.SmoOperation.setNoteHead(selections, head);
        operations_1.SmoOperation.setNoteHead(this._getEquivalentSelections(selections), head);
        this._renderChangedMeasures(measureSelections);
        return this.renderer.updatePromise();
    }
    /**
     * Add a volta for selected measures
     */
    addEnding() {
        // TODO: we should have undo for columns
        this._undoScore('Add Volta');
        const ft = this.tracker.getExtremeSelection(-1);
        const tt = this.tracker.getExtremeSelection(1);
        const params = measureModifiers_1.SmoVolta.defaults;
        params.startBar = ft.selector.measure;
        params.endBar = tt.selector.measure;
        params.number = 1;
        const volta = new measureModifiers_1.SmoVolta(params);
        const altVolta = new measureModifiers_1.SmoVolta(params);
        this._renderChangedMeasures([ft, tt]);
        operations_1.SmoOperation.addEnding(this.storeScore, altVolta);
        operations_1.SmoOperation.addEnding(this.score, volta);
        this.renderer.setRefresh();
        return this.renderer.updatePromise();
    }
    /**
     * @param ending volta settings
     * @returns
     */
    updateEnding(ending) {
        this._undoScore('Change Volta');
        ending.elements.forEach((el) => {
            $(el).find('g.' + ending.attrs.id).remove();
        });
        ending.elements = [];
        operations_1.SmoOperation.removeEnding(this.storeScore, ending);
        operations_1.SmoOperation.removeEnding(this.score, ending);
        const altVolta = new measureModifiers_1.SmoVolta(ending);
        operations_1.SmoOperation.addEnding(this.storeScore, altVolta);
        operations_1.SmoOperation.addEnding(this.score, ending);
        this.renderer.setRefresh();
        return this.renderer.updatePromise();
    }
    /**
     *
     * @param ending volta to remove
     * @returns
     */
    removeEnding(ending) {
        this._undoScore('Remove Volta');
        ending.elements.forEach((el) => {
            $(el).find('g.' + ending.attrs.id).remove();
        });
        ending.elements = [];
        operations_1.SmoOperation.removeEnding(this.storeScore, ending);
        operations_1.SmoOperation.removeEnding(this.score, ending);
        this.renderer.setRefresh();
        return this.renderer.updatePromise();
    }
    /**
     *
     * @param position begin or end
     * @param barline barline type
     * @returns
     */
    setBarline(position, barline) {
        const obj = new measureModifiers_1.SmoBarline({ position, barline });
        const altObj = new measureModifiers_1.SmoBarline({ position, barline });
        const selection = this.tracker.selections[0];
        this._undoColumn('set barline', selection.selector.measure);
        operations_1.SmoOperation.setMeasureBarline(this.score, selection, obj);
        const altSel = this._getEquivalentSelection(selection);
        operations_1.SmoOperation.setMeasureBarline(this.storeScore, altSel, altObj);
        this._renderChangedMeasures([selection]);
        return this.renderer.updatePromise();
    }
    /**
     *
     * @param position start or end
     * @param symbol coda, etc.
     */
    setRepeatSymbol(position, symbol) {
        const params = measureModifiers_1.SmoRepeatSymbol.defaults;
        params.position = position;
        params.symbol = symbol;
        const obj = new measureModifiers_1.SmoRepeatSymbol(params);
        const altObj = new measureModifiers_1.SmoRepeatSymbol(params);
        const selection = this.tracker.selections[0];
        this._undoColumn('set repeat symbol', selection.selector.measure);
        operations_1.SmoOperation.setRepeatSymbol(this.score, selection, obj);
        const altSel = this._getEquivalentSelection(selection);
        operations_1.SmoOperation.setRepeatSymbol(this.storeScore, altSel, altObj);
        this._renderChangedMeasures([selection]);
        return this.renderer.updatePromise();
    }
    /**
     *  toggle rehearsal mark on first selected measure
     * @returns
     */
    toggleRehearsalMark() {
        const selection = this.tracker.getExtremeSelection(-1);
        const altSelection = this._getEquivalentSelection(selection);
        const cmd = selection.measure.getRehearsalMark() ? 'removeRehearsalMark' : 'addRehearsalMark';
        operations_1.SmoOperation[cmd](this.score, selection, new measureModifiers_1.SmoRehearsalMark(measureModifiers_1.SmoRehearsalMark.defaults));
        operations_1.SmoOperation[cmd](this.storeScore, altSelection, new measureModifiers_1.SmoRehearsalMark(measureModifiers_1.SmoRehearsalMark.defaults));
        this._renderChangedMeasures([selection]);
        return this.renderer.updatePromise();
    }
    _removeStaffModifier(modifier) {
        this.score.staves[modifier.associatedStaff].removeStaffModifier(modifier);
        const altModifier = staffModifiers_1.StaffModifierBase.deserialize(modifier.serialize());
        altModifier.startSelector = this._getEquivalentSelector(altModifier.startSelector);
        altModifier.endSelector = this._getEquivalentSelector(altModifier.endSelector);
        this.storeScore.staves[this._getEquivalentStaff(modifier.associatedStaff)].removeStaffModifier(altModifier);
    }
    /**
     * Remove selected modifier
     * @param modifier slur, hairpin, etc.
     * @returns
     */
    removeStaffModifier(modifier) {
        this._undoStaffModifier('Set measure proportion', modifier, undo_1.UndoBuffer.bufferSubtypes.REMOVE);
        this._removeStaffModifier(modifier);
        this._renderRectangle(modifier.startSelector, modifier.endSelector);
        return this.renderer.updatePromise();
    }
    /**
     * Change a staff modifier
     * @param original original version
     * @param modifier modified version
     * @returns
     */
    addOrUpdateStaffModifier(original, modifier) {
        if (!modifier) {
            if (original) {
                // Handle legacy API changed
                modifier = staffModifiers_1.StaffModifierBase.deserialize(original);
            }
            else {
                console.warn('update modifier: bad modifier');
                return promiseHelpers_1.PromiseHelpers.emptyPromise();
            }
        }
        const existing = this.score.staves[modifier.startSelector.staff]
            .getModifier(modifier);
        const subtype = existing === null ? undo_1.UndoBuffer.bufferSubtypes.ADD :
            undo_1.UndoBuffer.bufferSubtypes.UPDATE;
        this._undoStaffModifier('Set measure proportion', original, subtype);
        this._removeStaffModifier(modifier);
        const copy = staffModifiers_1.StaffModifierBase.deserialize(modifier.serialize());
        copy.startSelector = this._getEquivalentSelector(copy.startSelector);
        copy.endSelector = this._getEquivalentSelector(copy.endSelector);
        const sel = selections_1.SmoSelection.noteFromSelector(this.score, modifier.startSelector);
        if (sel !== null) {
            const altSel = this._getEquivalentSelection(sel);
            operations_1.SmoOperation.addStaffModifier(sel, modifier);
            operations_1.SmoOperation.addStaffModifier(altSel, copy);
            const modId = 'mod-' + sel.selector.staff + '-' + sel.selector.measure;
            const context = this.renderer.renderer.getRenderer(sel.measure.svg.logicalBox);
            if (context) {
                svgHelpers_1.SvgHelpers.removeElementsByClass(context.svg, modId);
            }
        }
        this._renderRectangle(modifier.startSelector, modifier.endSelector);
        return this.renderer.updatePromise();
    }
    _lineOperation(op) {
        // if (this.tracker.selections.length < 2) {
        //   return;
        // }
        const measureSelections = this._undoTrackerMeasureSelections(op);
        const ft = this.tracker.getExtremeSelection(-1);
        const tt = this.tracker.getExtremeSelection(1);
        const ftAlt = this._getEquivalentSelection(ft);
        const ttAlt = this._getEquivalentSelection(tt);
        const modifier = operations_1.SmoOperation[op](ft, tt);
        operations_1.SmoOperation[op](ftAlt, ttAlt);
        this._undoStaffModifier('add ' + op, modifier, undo_1.UndoBuffer.bufferSubtypes.ADD);
        this._renderChangedMeasures(measureSelections);
    }
    /**
     * Add crescendo to selection
     */
    crescendo() {
        this._lineOperation('crescendo');
        return this.renderer.updatePromise();
    }
    /**
     * Add crescendo to selection
     */
    crescendoBracket() {
        this._lineOperation('crescendoBracket');
        return this.renderer.updatePromise();
    }
    /**
     * Add crescendo to selection
     */
    dimenuendo() {
        this._lineOperation('dimenuendo');
        return this.renderer.updatePromise();
    }
    /**
     * Add crescendo to selection
     */
    accelerando() {
        this._lineOperation('accelerando');
        return this.renderer.updatePromise();
    }
    /**
     * Add crescendo to selection
     */
    ritard() {
        this._lineOperation('ritard');
        return this.renderer.updatePromise();
    }
    /**
     * diminuendo selections
     * @returns
     */
    decrescendo() {
        this._lineOperation('decrescendo');
        return this.renderer.updatePromise();
    }
    removeTextBracket(bracket) {
        return this.removeStaffModifier(bracket);
    }
    addOrReplaceTextBracket(modifier) {
        const from1 = selections_1.SmoSelection.noteFromSelector(this.score, modifier.startSelector);
        const to1 = selections_1.SmoSelection.noteFromSelector(this.score, modifier.endSelector);
        if (from1 === null || to1 === null) {
            return;
        }
        const altFrom = this._getEquivalentSelection(from1);
        const altTo = this._getEquivalentSelection(to1);
        if (altFrom === null || altTo === null) {
            return;
        }
        operations_1.SmoOperation.addOrReplaceBracket(modifier, from1, to1);
        operations_1.SmoOperation.addOrReplaceBracket(modifier, altFrom, altTo);
        const redraw = selections_1.SmoSelection.getMeasuresBetween(this.score, from1.selector, to1.selector);
        this._undoStaffModifier('add repl text bracket', modifier, undo_1.UndoBuffer.bufferSubtypes.ADD);
        this._renderChangedMeasures(redraw);
        return this.renderer.updatePromise();
    }
    /**
     * Slur selected notes
     * @returns
     */
    slur() {
        const measureSelections = this._undoTrackerMeasureSelections('slur');
        const ft = this.tracker.getExtremeSelection(-1);
        const tt = this.tracker.getExtremeSelection(1);
        const ftAlt = this._getEquivalentSelection(ft);
        const ttAlt = this._getEquivalentSelection(tt);
        const modifier = operations_1.SmoOperation.slur(this.score, ft, tt);
        const altModifier = operations_1.SmoOperation.slur(this.storeScore, ftAlt, ttAlt);
        this._undoStaffModifier('add ' + 'op', new staffModifiers_1.SmoSlur(modifier), undo_1.UndoBuffer.bufferSubtypes.ADD);
        this._renderChangedMeasures(measureSelections);
        return this.renderer.updatePromise();
    }
    /**
     * tie selected notes
     * @returns
     */
    tie() {
        this._lineOperation('tie');
        return this.renderer.updatePromise();
    }
    updateZoom(zoomFactor) {
        const original = this.score.layoutManager.getGlobalLayout();
        original.zoomScale = zoomFactor;
        this.score.layoutManager.globalLayout.zoomScale = zoomFactor;
        this.renderer.pageMap.updateZoom(zoomFactor);
        this.renderer.pageMap.updateContainerOffset(this.scroller.scrollState);
    }
    /**
     * set global page for score, zoom etc.
     * @param layout global SVG settings
     * @returns
     */
    setGlobalLayout(layout) {
        this._undoScore('Set Global Layout');
        const original = this.score.layoutManager.getGlobalLayout().svgScale;
        this.score.layoutManager.updateGlobalLayout(layout);
        this.score.scaleTextGroups(original / layout.svgScale);
        this.storeScore.layoutManager.updateGlobalLayout(layout);
        this.renderer.rerenderAll();
        return this.renderer.preserveScroll();
    }
    /**
     * Set the layout of a single page
     * @param layout page layout
     * @param pageIndex which page to change
     * @returns
     */
    _setPageLayout(layout, pageIndex) {
        this.score.layoutManager.updatePage(layout, pageIndex);
        this.storeScore.layoutManager.updatePage(layout, pageIndex);
        // If we are in part mode, save the page layout in the part so it is there next time
        // the part is exposed.
        if (this.isPartExposed()) {
            this.score.staves.forEach((staff, staffIx) => {
                staff.partInfo.layoutManager.updatePage(layout, pageIndex);
                const altStaff = this.storeScore.staves[this.staffMap[staffIx]];
                altStaff.partInfo.layoutManager.updatePage(layout, pageIndex);
            });
        }
    }
    setPageLayouts(layout, startIndex, endIndex) {
        this._undoScore('Set Page Layout');
        let i = 0;
        for (i = startIndex; i <= endIndex; ++i) {
            this._setPageLayout(layout, i);
        }
        this.renderer.rerenderAll();
        return this.renderer.updatePromise();
    }
    /**
     * Update the music font
     * @param family
     * @returns
     */
    setEngravingFontFamily(family) {
        this.score.engravingFont = family;
        this.storeScore.engravingFont = family;
        this.renderer.notifyFontChange();
        this.renderer.setRefresh();
        return this.renderer.updatePromise();
    }
    /**
     * Upate global font used for chord changes
     * @param fontInfo
     * @returns
     */
    setChordFont(fontInfo) {
        this._undoScore('Set Chord Font');
        this.score.setChordFont(fontInfo);
        this.storeScore.setChordFont(fontInfo);
        this.renderer.setRefresh();
        return this.renderer.updatePromise();
    }
    /**
     * Update font used for lyrics
     * @param fontInfo
     * @returns
     */
    setLyricFont(fontInfo) {
        this._undoScore('Set Lyric Font');
        this.score.setLyricFont(fontInfo);
        this.storeScore.setLyricFont(fontInfo);
        this.renderer.setRefresh();
        return this.renderer.updatePromise();
    }
    /**
     * @param value if false, lyric widths don't affect measure width
     * @returns
     */
    setLyricAdjustWidth(value) {
        this._undoScore('Set Lyric Adj Width');
        this.score.setLyricAdjustWidth(value);
        this.storeScore.setLyricAdjustWidth(value);
        this.renderer.setRefresh();
        return this.renderer.updatePromise();
    }
    /**
     * delete selected measures
     * @returns
     */
    deleteMeasure() {
        this._undoScore('Delete Measure');
        if (this.storeScore.staves[0].measures.length < 2) {
            return promiseHelpers_1.PromiseHelpers.emptyPromise();
        }
        const selections = selections_1.SmoSelection.getMeasureList(this.tracker.selections);
        // THe measures get renumbered, so keep the index at 0
        const index = selections[0].selector.measure;
        selections.forEach((selection) => {
            // Unrender the deleted measure
            this.score.staves.forEach((staff) => {
                this.tracker.clearMeasureMap(staff.measures[index]);
                this.renderer.unrenderMeasure(staff.measures[index]);
                this.renderer.unrenderMeasure(staff.measures[staff.measures.length - 1]);
                // A little hacky - delete the modifiers if they start or end on
                // the measure
                staff.modifiers.forEach((modifier) => {
                    if (modifier.startSelector.measure === index || modifier.endSelector.measure === index) {
                        if (modifier.logicalBox) {
                            const context = this.renderer.renderer.getRenderer(modifier.logicalBox);
                            if (context) {
                                $(context.svg).find('g.' + modifier.attrs.id).remove();
                            }
                        }
                    }
                });
            });
            // Remove the SVG artifacts mapped to this measure.
            this.score.deleteMeasure(index);
            this.storeScore.deleteMeasure(index);
        });
        this.renderer.setRefresh();
        return this.renderer.updatePromise();
    }
    /**
     * add number of measures, with default notes selections
     * @param append
     * @param numberToAdd
     * @returns
     */
    addMeasures(append, numberToAdd) {
        let pos = 0;
        let ix = 0;
        this._undoScore('Add Measure');
        for (ix = 0; ix < numberToAdd; ++ix) {
            const measure = this.tracker.getFirstMeasureOfSelection();
            if (measure) {
                const nmeasure = measure_1.SmoMeasure.getDefaultMeasureWithNotes(measure);
                pos = measure.measureNumber.measureIndex;
                if (append) {
                    pos += 1;
                }
                nmeasure.measureNumber.measureIndex = pos;
                nmeasure.setActiveVoice(0);
                this.score.addMeasure(pos);
                this.storeScore.addMeasure(pos);
            }
        }
        this.renderer.setRefresh();
        return this.renderer.updatePromise();
    }
    /**
     * add a single measure before or after selection
     * @param append
     * @returns
     */
    addMeasure(append) {
        this._undoScore('Add Measure');
        let pos = 0;
        const measure = this.tracker.getFirstMeasureOfSelection();
        if (!measure) {
            return promiseHelpers_1.PromiseHelpers.emptyPromise();
        }
        const nmeasure = measure_1.SmoMeasure.getDefaultMeasureWithNotes(measure);
        pos = measure.measureNumber.measureIndex;
        if (append) {
            pos += 1;
        }
        nmeasure.measureNumber.measureIndex = pos;
        nmeasure.setActiveVoice(0);
        this.score.addMeasure(pos);
        this.storeScore.addMeasure(pos);
        this.renderer.clearLine(measure);
        this.renderer.setRefresh();
        return this.renderer.updatePromise();
    }
    /**
     * remove an entire line of music
     * @returns
     */
    removeStaff() {
        this._undoScore('Remove Instrument');
        if (this.storeScore.staves.length < 2 || this.score.staves.length < 2) {
            return promiseHelpers_1.PromiseHelpers.emptyPromise();
        }
        // if we are looking at a subset of the score,
        // revert to the full score view before removing the staff.
        const sel = this.tracker.selections[0];
        const scoreSel = this._getEquivalentSelection(sel);
        const staffIndex = scoreSel.selector.staff;
        operations_1.SmoOperation.removeStaff(this.storeScore, staffIndex);
        this.viewAll();
        this.renderer.setRefresh();
        return this.renderer.updatePromise();
    }
    addStaff(instrument) {
        this._undoScore('Add Instrument');
        // if we are looking at a subset of the score, we won't see the new staff.  So
        // revert to the full view
        operations_1.SmoOperation.addStaff(this.storeScore, instrument);
        if (instrument.alignWithPrevious && instrument.staffId > 0) {
            const sel = selections_1.SmoSelector.default;
            sel.staff = instrument.staffId - 1;
            const selection = selections_1.SmoSelection.measureSelection(this.storeScore, instrument.staffId - 1, 0);
            if (selection) {
                let grp = this.storeScore.getSystemGroupForStaff(selection);
                if (grp) {
                    grp.endSelector.staff = instrument.staffId;
                }
                else {
                    let grp = new scoreModifiers_1.SmoSystemGroup(scoreModifiers_1.SmoSystemGroup.defaults);
                    grp.startSelector.staff = instrument.staffId - 1;
                    grp.endSelector.staff = instrument.staffId;
                    this.storeScore.systemGroups.push(grp);
                }
            }
        }
        this.viewAll();
        return this.renderer.updatePromise();
    }
    /**
     * Update part info assumes that the part is currently exposed - that
     * staff 0 is the first staff in the part prior to editing.
     * @param info
     */
    updatePartInfo(info) {
        let i = 0;
        this._undoScore('Update part info');
        const storeStaff = this.staffMap[0] - info.stavesBefore;
        const partLength = info.stavesBefore + info.stavesAfter + 1;
        const resetView = !scoreModifiers_1.SmoLayoutManager.areLayoutsEqual(info.layoutManager.getGlobalLayout(), this.score.layoutManager.getGlobalLayout());
        const restChange = this.score.staves[0].partInfo.expandMultimeasureRests != info.expandMultimeasureRests;
        for (i = 0; i < partLength; ++i) {
            const nStaffIndex = storeStaff + i;
            const nInfo = new partInfo_1.SmoPartInfo(info);
            nInfo.stavesBefore = i;
            nInfo.stavesAfter = partLength - i - 1;
            this.storeScore.staves[nStaffIndex].partInfo = nInfo;
            // If the staff index is currently displayed, 
            const displayedIndex = this.staffMap.findIndex((x) => x === nStaffIndex);
            if (displayedIndex >= 0) {
                this.score.staves[displayedIndex].partInfo = new partInfo_1.SmoPartInfo(nInfo);
                this.score.layoutManager = nInfo.layoutManager;
            }
        }
        if (resetView || restChange) {
            this.renderer.rerenderAll();
        }
        return this.renderer.updatePromise();
    }
    /**
     * A simpler API for applications to add a new staff to the score.
     * @param params - the instrument, which determines clef, etc.
     * @returns
     */
    addStaffSimple(params) {
        var _a;
        const instrumentParams = staffModifiers_1.SmoInstrument.defaults;
        instrumentParams.startSelector.staff = instrumentParams.endSelector.staff = this.score.staves.length;
        instrumentParams.clef = (_a = params.clef) !== null && _a !== void 0 ? _a : instrumentParams.clef;
        const staffParams = systemStaff_1.SmoSystemStaff.defaults;
        staffParams.measureInstrumentMap[0] = new staffModifiers_1.SmoInstrument(instrumentParams);
        this.addStaff(staffParams);
        return this.renderer.updatePromise();
    }
    /**
     * Save the score to local storage.
     */
    quickSave() {
        const scoreStr = JSON.stringify(this.storeScore.serialize());
        localStorage.setItem(serializationHelpers_1.smoSerialize.localScore, scoreStr);
    }
    updateRepeatCount(count) {
        const measureSelections = this._undoTrackerMeasureSelections('repeat bar');
        const symbol = count > 0 ? true : false;
        measureSelections.forEach((ms) => {
            const store = this._getEquivalentSelection(ms);
            ms.measure.repeatCount = count;
            ms.measure.repeatSymbol = symbol;
            if (store) {
                store.measure.repeatCount = count;
                store.measure.repeatSymbol = symbol;
            }
        });
        this._renderChangedMeasures(measureSelections);
        return this.updatePromise();
    }
    /**
     * Update the measure formatting parameters for the current selection
     * @param format generic measure formatting parameters
     * @returns
     */
    setMeasureFormat(format) {
        const label = 'set measure format';
        const fromSelector = this.tracker.getExtremeSelection(-1).selector;
        const toSelector = this.tracker.getExtremeSelection(1).selector;
        const measureSelections = this.tracker.getSelectedMeasures();
        // If the formatting is on a part, preserve it in the part's info
        const isPart = this.isPartExposed();
        measureSelections.forEach((m) => {
            this._undoColumn(label, m.selector.measure);
            operations_1.SmoOperation.setMeasureFormat(this.score, m, format);
            if (isPart) {
                m.staff.partInfo.measureFormatting[m.measure.measureNumber.measureIndex] = new measureModifiers_1.SmoMeasureFormat(format);
            }
            const alt = this._getEquivalentSelection(m);
            operations_1.SmoOperation.setMeasureFormat(this.storeScore, alt, format);
            if (isPart) {
                alt.staff.partInfo.measureFormatting[m.measure.measureNumber.measureIndex] = new measureModifiers_1.SmoMeasureFormat(format);
            }
        });
        this._renderRectangle(fromSelector, toSelector);
        return this.renderer.updatePromise();
    }
    /**
     * Remove system breaks from the measure formatting for selected measures
     * @returns
     */
    removeSystemBreaks() {
        const label = 'set measure format';
        const fromSelector = this.tracker.getExtremeSelection(-1).selector;
        const toSelector = this.tracker.getExtremeSelection(1).selector;
        const measureSelections = this.tracker.getSelectedMeasures();
        // If the formatting is on a part, preserve it in the part's info
        const isPart = this.isPartExposed();
        measureSelections.forEach((m) => {
            this._undoColumn(label, m.selector.measure);
            const format = new measureModifiers_1.SmoMeasureFormat(m.measure.format);
            format.systemBreak = false;
            operations_1.SmoOperation.setMeasureFormat(this.score, m, format);
            if (isPart) {
                m.staff.partInfo.measureFormatting[m.measure.measureNumber.measureIndex] = new measureModifiers_1.SmoMeasureFormat(format);
            }
            const alt = this._getEquivalentSelection(m);
            operations_1.SmoOperation.setMeasureFormat(this.storeScore, alt, format);
            if (isPart) {
                alt.staff.partInfo.measureFormatting[m.measure.measureNumber.measureIndex] = new measureModifiers_1.SmoMeasureFormat(format);
            }
        });
        this._renderRectangle(fromSelector, toSelector);
        return this.renderer.updatePromise();
    }
    /**
     * Play the music from the starting selection
     * @returns
     */
    playFromSelection() {
        var mm = this.tracker.getExtremeSelection(-1);
        if (player_1.SuiAudioPlayer.playingInstance && player_1.SuiAudioPlayer.playingInstance.paused) {
            player_1.SuiAudioPlayer.playingInstance.play();
            return;
        }
        if (player_1.SuiAudioPlayer.playing) {
            return;
        }
        new player_1.SuiAudioPlayer({ audioAnimation: this.audioAnimation, score: this.score, startIndex: mm.selector.measure, view: this }).play();
    }
    stopPlayer() {
        player_1.SuiAudioPlayer.stopPlayer();
    }
    pausePlayer() {
        player_1.SuiAudioPlayer.pausePlayer();
    }
    /**
     * Proxy calls to move the tracker parameters according to the
     * rules of the 'Home' key (depending on shift/ctrl/alt)
     * @param ev
     * @returns
     */
    moveHome(ev) {
        this.tracker.moveHome(this.score, ev);
        return this.renderer.updatePromise();
    }
    /**
     * Proxy calls to move the tracker parameters according to the
     * rules of the 'End' key (depending on shift/ctrl/alt)
     * @param ev
     * @returns
     */
    moveEnd(ev) {
        this.tracker.moveEnd(this.score, ev);
        return this.renderer.updatePromise();
    }
    /**
     * Grow the current selection by one to the left, if possible
     * @param ev
     * @returns
     */
    growSelectionLeft() {
        this.tracker.growSelectionLeft();
        return this.renderer.updatePromise();
    }
    /**
     * Grow the current selection by one to the right, if possible
     * @param ev
     * @returns
     */
    growSelectionRight() {
        this.tracker.growSelectionRight();
        return this.renderer.updatePromise();
    }
    /**
     * Select the next tabbable modifier near one of the selected notes
     * @param keyEv
     * @returns
     */
    advanceModifierSelection(keyEv) {
        this.tracker.advanceModifierSelection(this.score, keyEv);
        return this.renderer.updatePromise();
    }
    /**
     * Select the next entire measure, if possible
     * @returns
     */
    growSelectionRightMeasure() {
        this.tracker.growSelectionRightMeasure();
        return this.renderer.updatePromise();
    }
    /**
     * Advance cursor forwards, if possible
     * @param ev
     * @returns
     */
    moveSelectionRight(ev) {
        this.tracker.moveSelectionRight(this.score, ev, true);
        return this.renderer.updatePromise();
    }
    /**
     * Advance cursor backwards, if possible
     * @param ev
     * @returns
     */
    moveSelectionLeft() {
        this.tracker.moveSelectionLeft();
        return this.renderer.updatePromise();
    }
    /**
     * Advance cursor back entire measure, if possible
     * @returns
     */
    moveSelectionLeftMeasure() {
        this.tracker.moveSelectionLeftMeasure();
        return this.renderer.updatePromise();
    }
    /**
     * Advance cursor forward one measure, if possible
     * @returns
     */
    moveSelectionRightMeasure() {
        this.tracker.moveSelectionRightMeasure();
        return this.renderer.updatePromise();
    }
    /**
     * Move cursor to a higher pitch in the current chord, with wrap
     * @returns
     */
    moveSelectionPitchUp() {
        this.tracker.moveSelectionPitchUp();
        return this.renderer.updatePromise();
    }
    /**
     * Move cursor to a lower pitch in the current chord, with wrap
     */
    moveSelectionPitchDown() {
        this.tracker.moveSelectionPitchDown();
        return this.renderer.updatePromise();
    }
    /**
     * Move cursor up a staff in the system, if possible
     * @returns
     */
    moveSelectionUp() {
        this.tracker.moveSelectionUp();
        return this.renderer.updatePromise();
    }
    /**
     * Move cursor down a staff in the system, if possible
     * @returns
     */
    moveSelectionDown() {
        this.tracker.moveSelectionDown();
        return this.renderer.updatePromise();
    }
    /**
     * Set the current suggestions (hover element) as the selection
     * @returns
     */
    selectSuggestion(evData) {
        this.tracker.selectSuggestion(this.score, evData);
        return this.renderer.updatePromise();
    }
    /**
     * Find an element at the given box, and make it the current selection
     *  */
    intersectingArtifact(evData) {
        this.tracker.intersectingArtifact(evData);
        return this.renderer.updatePromise();
    }
}
exports.SuiScoreViewOperations = SuiScoreViewOperations;


/***/ }),

/***/ "./src/render/sui/scroller.ts":
/*!************************************!*\
  !*** ./src/render/sui/scroller.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SuiScroller = void 0;
// [Smoosic](https://github.com/AaronDavidNewman/Smoosic)
// Copyright (c) Aaron David Newman 2021.
const svgHelpers_1 = __webpack_require__(/*! ./svgHelpers */ "./src/render/sui/svgHelpers.ts");
const common_1 = __webpack_require__(/*! ../../smo/data/common */ "./src/smo/data/common.ts");
const layoutDebug_1 = __webpack_require__(/*! ./layoutDebug */ "./src/render/sui/layoutDebug.ts");
const VF = eval('Vex.Flow');
/**
 * Respond to scroll events in music DOM, and handle the scroll of the viewport
 * @category SuiRender
 */
class SuiScroller {
    // ### constructor
    // selector is the scrollable DOM container of the music container
    // (grandparent of svg element)
    constructor(selector, svgPages) {
        this.viewport = common_1.SvgBox.default;
        this.logicalViewport = common_1.SvgBox.default;
        this.scrolling = false;
        const self = this;
        this.selector = selector;
        this._scroll = { x: 0, y: 0 };
        this.svgPages = svgPages;
        const scroller = $(selector);
        this._offsetInitial = { x: $(scroller).offset().left, y: $(scroller).offset().top };
    }
    get scrollState() {
        return { x: this._scroll.x, y: this._scroll.y };
    }
    restoreScrollState(state) {
        this.scrollOffset(state.x - this._scroll.x, state.y - this._scroll.y);
        this.deferUpdateDebug();
    }
    // ### handleScroll
    // update viewport in response to scroll events
    handleScroll(x, y) {
        this._scroll = { x, y };
        this.deferUpdateDebug();
    }
    updateDebug() {
        layoutDebug_1.layoutDebug.updateScrollDebug(this._scroll);
    }
    deferUpdateDebug() {
        if (layoutDebug_1.layoutDebug.mask & layoutDebug_1.layoutDebug.values.scroll) {
            setTimeout(() => {
                this.updateDebug();
            }, 1);
        }
    }
    scrollAbsolute(x, y) {
        $(this.selector)[0].scrollLeft = x;
        $(this.selector)[0].scrollTop = y;
        this.netScroll.x = this._scroll.x = x;
        this.netScroll.y = this._scroll.y = y;
        this.deferUpdateDebug();
    }
    /**
     * Scroll such that the box is fully visible, if possible (if it is
     * not larger than the screen)
     **/
    scrollVisibleBox(box) {
        let yoff = 0;
        let xoff = 0;
        const screenBox = this.svgPages.svgToClientNoOffset(box);
        const scrollState = this.scrollState;
        const scrollDown = () => screenBox.y + screenBox.height > scrollState.y + this.viewport.height;
        const scrollUp = () => screenBox.y < scrollState.y;
        const scrollLeft = () => screenBox.x < scrollState.x;
        const scrollRight = () => screenBox.x + screenBox.width > scrollState.x + this.viewport.width;
        // Math: make sure we don't scroll down if scrollUp is indicated, etc.
        if (scrollUp()) {
            yoff = Math.min(screenBox.y - scrollState.y, 0);
        }
        if (scrollDown()) {
            yoff = Math.max(screenBox.y - (scrollState.y - screenBox.height), 0);
        }
        if (scrollLeft()) {
            xoff = Math.min(screenBox.x - scrollState.x, 0);
        }
        if (scrollRight()) {
            xoff = Math.max(screenBox.x - (scrollState.x - screenBox.height), 0);
        }
        this.scrollOffset(xoff, yoff);
    }
    // Update viewport size, and also fix height of scroll region.
    updateViewport() {
        $(this.selector).css('height', (window.innerHeight - $(this.selector).offset().top).toString() + 'px');
        this.viewport = svgHelpers_1.SvgHelpers.boxPoints($(this.selector).offset().left, $(this.selector).offset().top, $(this.selector).width(), $(this.selector).height());
        this.deferUpdateDebug();
    }
    // ### scrollBox
    // get the current viewport, in scrolled coordinates.  When tracker maps the
    // music element to client coordinates, these are the coordinates used in the
    // map
    get scrollBox() {
        return svgHelpers_1.SvgHelpers.boxPoints(this.viewport.x + this.netScroll.x, this.viewport.y + this.netScroll.y, this.viewport.width, this.viewport.height);
    }
    // ### scrollOffset
    // scroll the offset from the starting scroll point
    scrollOffset(x, y) {
        const xScreen = Math.max(this._scroll.x + x, 0);
        const yScreen = Math.max(this._scroll.y + y, 0);
        this.scrollAbsolute(xScreen, yScreen);
    }
    // ### netScroll
    // return the net amount we've scrolled, based on when the maps were make (initial)
    // , the offset of the container, and the absolute coordinates of the scrollbar.
    get netScroll() {
        var xoffset = $(this.selector).offset().left - this._offsetInitial.x;
        var yoffset = $(this.selector).offset().top - this._offsetInitial.y;
        return { x: this._scroll.x - xoffset, y: this._scroll.y - yoffset };
    }
}
exports.SuiScroller = SuiScroller;


/***/ }),

/***/ "./src/render/sui/svgHelpers.ts":
/*!**************************************!*\
  !*** ./src/render/sui/svgHelpers.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


// [Smoosic](https://github.com/AaronDavidNewman/Smoosic)
// Copyright (c) Aaron David Newman 2021.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SvgHelpers = exports.SvgBuilder = void 0;
const common_1 = __webpack_require__(/*! ../../smo/data/common */ "./src/smo/data/common.ts");
class SvgBuilder {
    constructor(el) {
        const ns = SvgHelpers.namespace;
        this.e = document.createElementNS(ns, el);
    }
    classes(cl) {
        this.e.setAttributeNS('', 'class', cl);
        return this;
    }
    attr(name, value) {
        this.e.setAttributeNS('', name, value);
        return this;
    }
    text(x, y, classes, text) {
        x = typeof (x) == 'string' ? x : x.toString();
        y = typeof (y) == 'string' ? y : y.toString();
        this.e.setAttributeNS('', 'class', classes);
        this.e.setAttributeNS('', 'x', x);
        this.e.setAttributeNS('', 'y', y);
        this.e.textContent = text;
        return this;
    }
    rect(x, y, width, height, classes) {
        x = typeof (x) == 'string' ? x : x.toString();
        y = typeof (y) == 'string' ? y : y.toString();
        width = typeof (width) == 'string' ? width : width.toString();
        height = typeof (height) == 'string' ? height : height.toString();
        this.e.setAttributeNS('', 'x', x);
        this.e.setAttributeNS('', 'y', y);
        this.e.setAttributeNS('', 'width', width);
        this.e.setAttributeNS('', 'height', height);
        if (classes) {
            this.e.setAttributeNS('', 'class', classes);
        }
        return this;
    }
    line(x1, y1, x2, y2, classes) {
        x1 = typeof (x1) == 'string' ? x1 : x1.toString();
        y1 = typeof (y1) == 'string' ? y1 : y1.toString();
        x2 = typeof (x2) == 'string' ? x2 : x2.toString();
        y2 = typeof (y2) == 'string' ? y2 : y2.toString();
        this.e.setAttributeNS('', 'x1', x1);
        this.e.setAttributeNS('', 'y1', y1);
        this.e.setAttributeNS('', 'x2', x2);
        this.e.setAttributeNS('', 'y2', y2);
        if (classes) {
            this.e.setAttributeNS('', 'class', classes);
        }
        return this;
    }
    append(el) {
        this.e.appendChild(el.e);
        return this;
    }
    dom() {
        return this.e;
    }
    static b(element) {
        return new SvgBuilder(element);
    }
}
exports.SvgBuilder = SvgBuilder;
// ## SvgHelpers
// Mostly utilities for converting coordinate spaces based on transforms, etc.
// ### static class methods:
// ---
class SvgHelpers {
    static get namespace() {
        return "http://www.w3.org/2000/svg";
    }
    // ### gradient
    // Create an svg linear gradient.
    // Stops look like this:
    // `[{color:"#eee", offset:"0%",opacity:0.5}]`
    // orientation is horizontal or vertical
    static gradient(svg, id, orientation, stops) {
        var ns = SvgHelpers.namespace;
        var x2 = orientation === 'vertical' ? 0 : 1;
        var y2 = orientation === 'vertical' ? 1 : 0;
        var e = document.createElementNS(ns, 'linearGradient');
        e.setAttributeNS('', 'id', id);
        e.setAttributeNS('', 'x1', '0');
        e.setAttributeNS('', 'x2', x2.toString());
        e.setAttributeNS('', 'y1', '0');
        e.setAttributeNS('', 'y2', y2.toString());
        stops.forEach((stop) => {
            var s = document.createElementNS(ns, 'stop');
            s.setAttributeNS('', 'stop-opacity', stop.opacity.toString());
            s.setAttributeNS('', 'stop-color', stop.color);
            s.setAttributeNS('', 'offset', stop.offset);
            e.appendChild(s);
        });
        svg.appendChild(e);
    }
    static renderCursor(svg, x, y, height) {
        var ns = SvgHelpers.namespace;
        const width = height * 0.4;
        x = x - (width / 2);
        var mcmd = (d, x, y) => {
            return d + 'M ' + x.toString() + ' ' + y.toString() + ' ';
        };
        var qcmd = (d, x1, y1, x2, y2) => {
            return d + 'q ' + x1.toString() + ' ' + y1.toString() + ' ' + x2.toString() + ' ' + y2.toString() + ' ';
        };
        var lcmd = (d, x, y) => {
            return d + 'L ' + x.toString() + ' ' + y.toString() + ' ';
        };
        var x1 = (width / 2) * .333;
        var y1 = -1 * (x1 / 4);
        var x2 = (width / 2);
        var y2 = x2 / 4;
        var ns = SvgHelpers.namespace;
        var e = document.createElementNS(ns, 'path');
        var d = '';
        d = mcmd(d, x, y);
        d = qcmd(d, x1, y1, x2, y2);
        d = lcmd(d, x + (width / 2), y + height - (width / 8));
        d = mcmd(d, x + width, y);
        d = qcmd(d, -1 * x1, y1, -1 * x2, y2);
        d = mcmd(d, x, y + height);
        d = qcmd(d, x1, -1 * y1, x2, -1 * y2);
        d = mcmd(d, x + width, y + height);
        d = qcmd(d, -1 * x1, -1 * y1, -1 * x2, -1 * y2);
        e.setAttributeNS('', 'd', d);
        e.setAttributeNS('', 'stroke-width', '1');
        e.setAttributeNS('', 'stroke', '#555');
        e.setAttributeNS('', 'fill', 'none');
        svg.appendChild(e);
    }
    // ### boxNote
    // update the note geometry based on current viewbox conditions.
    // This may not be the appropriate place for this...maybe in layout
    static updateArtifactBox(context, element, artifact) {
        if (!element) {
            console.log('updateArtifactBox: undefined element!');
            return;
        }
        artifact.logicalBox = context.offsetBbox(element);
    }
    // ### eraseOutline
    // Erases old outlineRects.
    static eraseOutline(params) {
        // Hack:  Assume a stroke style, should just take a stroke param.
        if (params.element) {
            params.element.remove();
            params.element = undefined;
        }
    }
    static outlineRect(params) {
        const context = params.context;
        if (params.element && params.timer) {
            clearTimeout(params.timer);
            params.timer = undefined;
            params.element.remove();
            params.element = undefined;
        }
        if (params.timeOff) {
            params.timer = window.setTimeout(() => {
                if (params.element) {
                    params.element.remove();
                    params.element = undefined;
                    params.timer = undefined;
                }
            }, params.timeOff);
        }
        // Don't highlight in print mode.
        if ($('body').hasClass('printing')) {
            return;
        }
        const classes = params.classes.length > 0 ? params.classes + ' ' + params.stroke.strokeName : params.stroke.strokeName;
        var grp = context.getContext().openGroup(classes, classes + '-outline');
        params.element = grp;
        const boxes = Array.isArray(params.box) ? params.box : [params.box];
        boxes.forEach((box) => {
            if (box) {
                var strokeObj = params.stroke;
                strokeObj['stroke-width'] = params.stroke.strokeWidth;
                var margin = 5;
                /* if (params.clientCoordinates === true) {
                  box = SvgHelpers.smoBox(SvgHelpers.clientToLogical(context.svg, SvgHelpers.smoBox(SvgHelpers.adjustScroll(box, scroll))));
                } */
                context.getContext().rect(box.x - margin, box.y - margin, box.width + margin * 2, box.height + margin * 2, strokeObj);
            }
        });
        context.getContext().closeGroup(grp);
    }
    static setSvgStyle(element, attrs) {
        element.setAttributeNS('', 'stroke', attrs.stroke);
        if (attrs.strokeDasharray) {
            element.setAttributeNS('', 'stroke-dasharray', attrs.strokeDasharray.toString());
        }
        if (attrs.strokeWidth) {
            element.setAttributeNS('', 'stroke-width', attrs.strokeWidth.toString());
        }
        if (attrs.fill) {
            element.setAttributeNS('', 'fill', attrs.fill);
        }
    }
    static rect(svg, box, attrs, classes) {
        var rect = document.createElementNS(SvgHelpers.namespace, 'rect');
        SvgHelpers.setSvgStyle(rect, attrs);
        if (classes) {
            rect.setAttributeNS('', 'class', classes);
        }
        svg.appendChild(rect);
        return rect;
    }
    static line(svg, x1, y1, x2, y2, attrs, classes) {
        var line = document.createElementNS(SvgHelpers.namespace, 'line');
        x1 = typeof (x1) == 'string' ? x1 : x1.toString();
        y1 = typeof (y1) == 'string' ? y1 : y1.toString();
        x2 = typeof (x2) == 'string' ? x2 : x2.toString();
        y2 = typeof (y2) == 'string' ? y2 : y2.toString();
        line.setAttributeNS('', 'x1', x1);
        line.setAttributeNS('', 'y1', y1);
        line.setAttributeNS('', 'x2', x2);
        line.setAttributeNS('', 'y2', y2);
        SvgHelpers.setSvgStyle(line, attrs);
        if (classes) {
            line.setAttributeNS('', 'class', classes);
        }
        svg.appendChild(line);
    }
    static arrowDown(svg, box) {
        const arrowStroke = { strokeName: 'arrow-stroke', stroke: '#321', strokeWidth: '2', strokeDasharray: '4,1', fill: 'none', opacity: 1.0 };
        SvgHelpers.line(svg, box.x + box.width / 2, box.y, box.x + box.width / 2, box.y + box.height, arrowStroke, '');
        var arrowY = box.y + box.height / 4;
        SvgHelpers.line(svg, box.x, arrowY, box.x + box.width / 2, box.y + box.height, arrowStroke, '');
        SvgHelpers.line(svg, box.x + box.width, arrowY, box.x + box.width / 2, box.y + box.height, arrowStroke, '');
    }
    static debugBox(svg, box, classes, voffset) {
        voffset = voffset !== null && voffset !== void 0 ? voffset : 0;
        classes = classes !== null && classes !== void 0 ? classes : '';
        if (!box)
            return;
        classes += ' svg-debug-box';
        var b = SvgBuilder.b;
        var mid = box.x + box.width / 2;
        var xtext = 'x1: ' + Math.round(box.x);
        var wtext = 'x2: ' + Math.round(box.width + box.x);
        var ytext = 'y1: ' + Math.round(box.y);
        var htext = 'y2: ' + Math.round(box.height + box.y);
        var ytextp = Math.round(box.y + box.height);
        var ytextp2 = Math.round(box.y + box.height - 30);
        var r = b('g').classes(classes)
            .append(b('text').text(box.x + 20, box.y - 14 + voffset, 'svg-debug-text', xtext))
            .append(b('text').text(mid - 20, box.y - 14 + voffset, 'svg-debug-text', wtext))
            .append(b('line').line(box.x, box.y - 2, box.x + box.width, box.y - 2, ''))
            .append(b('line').line(box.x, box.y - 8, box.x, box.y + 5, ''))
            .append(b('line').line(box.x + box.width, box.y - 8, box.x + box.width, box.y + 5, ''))
            .append(b('text').text(Math.round(box.x - 14 + voffset), ytextp, 'svg-vdebug-text', ytext)
            .attr('transform', 'rotate(-90,' + Math.round(box.x - 14 + voffset) + ',' + ytextp + ')'));
        if (box.height > 2) {
            r.append(b('text').text(Math.round(box.x - 14 + voffset), ytextp2, 'svg-vdebug-text', htext)
                .attr('transform', 'rotate(-90,' + Math.round(box.x - 14 + voffset) + ',' + (ytextp2) + ')'))
                .append(b('line').line(Math.round(box.x - 2), Math.round(box.y + box.height), box.x - 2, box.y, ''))
                .append(b('line').line(Math.round(box.x - 8), Math.round(box.y + box.height), box.x + 6, Math.round(box.y + box.height), ''))
                .append(b('line').line(Math.round(box.x - 8), Math.round(box.y), Math.round(box.x + 6), Math.round(box.y), ''));
        }
        svg.appendChild(r.dom());
    }
    static debugBoxNoText(svg, box, classes, voffset) {
        voffset = voffset !== null && voffset !== void 0 ? voffset : 0;
        classes = classes !== null && classes !== void 0 ? classes : '';
        if (!box)
            return;
        classes += ' svg-debug-box';
        var b = SvgBuilder.b;
        var r = b('g').classes(classes)
            .append(b('line').line(box.x, box.y - 2, box.x + box.width, box.y - 2, ''))
            .append(b('line').line(box.x, box.y - 8, box.x, box.y + 5, ''))
            .append(b('line').line(box.x + box.width, box.y - 8, box.x + box.width, box.y + 5, ''));
        if (box.height > 2) {
            r.append(b('line').line(Math.round(box.x - 2), Math.round(box.y + box.height), box.x - 2, box.y, ''))
                .append(b('line').line(Math.round(box.x - 8), Math.round(box.y + box.height), box.x + 6, Math.round(box.y + box.height), ''))
                .append(b('line').line(Math.round(box.x - 8), Math.round(box.y), Math.round(box.x + 6), Math.round(box.y), ''));
        }
        svg.appendChild(r.dom());
    }
    static placeSvgText(svg, attributes, classes, text) {
        var ns = SvgHelpers.namespace;
        var e = document.createElementNS(ns, 'text');
        attributes.forEach((attr) => {
            var key = Object.keys(attr)[0];
            e.setAttributeNS('', key, attr[key].toString());
        });
        if (classes) {
            e.setAttributeNS('', 'class', classes);
        }
        var tn = document.createTextNode(text);
        e.appendChild(tn);
        svg.appendChild(e);
        return e;
    }
    static doesBox1ContainBox2(box1, box2) {
        if (!box1 || !box2) {
            return false;
        }
        const i1 = box2.x - box1.x;
        const i2 = box2.y - box1.y;
        return (i1 > 0 && i1 < box1.width && i2 > 0 && i2 < box1.height);
    }
    // ### findIntersectionArtifact
    // find all object that intersect with the rectangle
    static findIntersectingArtifact(clientBox, objects) {
        var box = SvgHelpers.smoBox(clientBox); //svgHelpers.untransformSvgPoint(this.context.svg,clientBox);
        // box.y = box.y - this.renderElement.offsetTop;
        // box.x = box.x - this.renderElement.offsetLeft;
        var rv = [];
        objects.forEach((object) => {
            // Measure has been updated, but not drawn.
            if (!object.box) {
                // console.log('there is no box');
            }
            else {
                var obox = SvgHelpers.smoBox(object.box);
                if (SvgHelpers.doesBox1ContainBox2(obox, box)) {
                    rv.push(object);
                }
            }
        });
        return rv;
    }
    static findSmallestIntersection(clientBox, objects) {
        var ar = SvgHelpers.findIntersectingArtifact(clientBox, objects);
        if (!ar.length) {
            return null;
        }
        var rv = ar[0];
        var min = ar[0].box.width * ar[0].box.height;
        ar.forEach((obj) => {
            var tst = obj.box.width * obj.box.height;
            if (tst < min) {
                rv = obj;
                min = tst;
            }
        });
        return rv;
    }
    static translateElement(g, x, y) {
        g.setAttributeNS('', 'transform', 'translate(' + x + ' ' + y + ')');
    }
    static stringify(box) {
        if (box['width']) {
            return JSON.stringify({
                x: box.x,
                y: box.y,
                width: box.width,
                height: box.height
            }, null, ' ');
        }
        else {
            return JSON.stringify({
                x: box.x,
                y: box.y
            }, null, ' ');
        }
    }
    static log(box) {
        if (box['width']) {
            console.log(JSON.stringify({
                x: box.x,
                y: box.y,
                width: box.width,
                height: box.height
            }, null, ' '));
        }
        else {
            console.log('{}');
        }
    }
    // ### smoBox:
    // return a simple box object that can be serialized, copied
    // (from svg DOM box)
    static smoBox(box) {
        if (typeof (box) === "undefined" || box === null) {
            return common_1.SvgBox.default;
        }
        let testBox = box;
        if (Array.isArray(box)) {
            testBox = box[0];
        }
        const hround = (f) => {
            return Math.round((f + Number.EPSILON) * 100) / 100;
        };
        const x = typeof (testBox.x) == 'undefined' ? hround(testBox.left) : hround(testBox.x);
        const y = typeof (testBox.y) == 'undefined' ? hround(testBox.top) : hround(testBox.y);
        return ({
            x: hround(x),
            y: hround(y),
            width: hround(testBox.width),
            height: hround(testBox.height)
        });
    }
    // ### unionRect
    // grow the bounding box two objects to include both.
    static unionRect(b1, b2) {
        const x = Math.min(b1.x, b2.x);
        const y = Math.min(b1.y, b2.y);
        const width = Math.max(b1.x + b1.width, b2.x + b2.width) - x;
        const height = Math.max(b1.y + b1.height, b2.y + b2.height) - y;
        return {
            x: x,
            y: y,
            width: width,
            height: height
        };
    }
    static boxPoints(x, y, w, h) {
        return ({
            x: x,
            y: y,
            width: w,
            height: h
        });
    }
    // ### svgViewport
    // set `svg` element to `width`,`height` and viewport `scale`
    static svgViewport(svg, xOffset, yOffset, width, height, scale) {
        svg.setAttributeNS('', 'width', '' + width);
        svg.setAttributeNS('', 'height', '' + height);
        svg.setAttributeNS('', 'viewBox', '' + xOffset + ' ' + yOffset + ' ' + Math.round(width / scale) + ' ' +
            Math.round(height / scale));
    }
    static removeElementsByClass(svg, className) {
        const els = svg.getElementsByClassName(className);
        const ellength = els.length;
        for (var xxx = 0; xxx < ellength; ++xxx) {
            els[0].remove();
        }
    }
}
exports.SvgHelpers = SvgHelpers;


/***/ }),

/***/ "./src/render/sui/svgPageMap.ts":
/*!**************************************!*\
  !*** ./src/render/sui/svgPageMap.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SvgPageMap = exports.SvgPage = exports.MappedSystems = exports.MappedMeasures = exports.MappedNotes = exports.SelectionMap = void 0;
const svgHelpers_1 = __webpack_require__(/*! ./svgHelpers */ "./src/render/sui/svgHelpers.ts");
const common_1 = __webpack_require__(/*! ../../smo/data/common */ "./src/smo/data/common.ts");
const layoutDebug_1 = __webpack_require__(/*! ./layoutDebug */ "./src/render/sui/layoutDebug.ts");
const scoreText_1 = __webpack_require__(/*! ../../smo/data/scoreText */ "./src/smo/data/scoreText.ts");
const selections_1 = __webpack_require__(/*! ../../smo/xform/selections */ "./src/smo/xform/selections.ts");
const VF = eval('Vex.Flow');
/**
 * A selection map maps a sub-section of music (a measure, for instance) to a region
 * on the screen.  SelectionMap can contain other SelectionMaps with
 * different 'T', for instance, notes in a measure, in a 'Russian Dolls' kind of model.
 * This allows us to search for elements in < O(n) time and avoid
 * expensive geometry operations.
 */
class SelectionMap {
    constructor() {
        /**
         * the outer bounding box of these selections
         */
        this.box = common_1.SvgBox.default;
        /**
         * map of key to child SelectionMaps or SmoSelections
         */
        this.systemMap = new Map();
    }
    /**
     * Given a bounding box (or point), find all the musical elements contained
     * in that point
     * @param box
     * @returns SmoSelection[]
     */
    findArtifact(box) {
        let rv = [];
        for (const [key, value] of this.systemMap) {
            rv = rv.concat(this.findValueInMap(value, box));
        }
        return rv;
    }
    /**
     * Add a rendered element to the map, and update the bounding box
     * @param selection
     * @returns
     */
    addArtifact(selection) {
        if (!selection.note || !selection.note.logicalBox) {
            return;
        }
        const bounds = this.boxFromSelection(selection);
        if (this.systemMap.size === 0) {
            this.box = JSON.parse(JSON.stringify(bounds));
        }
        const ix = this.createKey(selection);
        this.addKeyToMap(ix, selection);
        this.box = svgHelpers_1.SvgHelpers.unionRect(bounds, this.box);
    }
}
exports.SelectionMap = SelectionMap;
/**
 * logic to map a set of notes to a region on the screen, for searching
 */
class MappedNotes extends SelectionMap {
    createKey(selection) {
        return `${selection.selector.voice}-${selection.selector.tick}`;
    }
    boxFromSelection(selection) {
        var _a, _b;
        return (_b = (_a = selection.note) === null || _a === void 0 ? void 0 : _a.logicalBox) !== null && _b !== void 0 ? _b : common_1.SvgBox.default;
    }
    addKeyToMap(key, selection) {
        this.systemMap.set(key, selection);
    }
    findValueInMap(value, box) {
        const rv = [];
        const note = value.note;
        if (note && note.logicalBox && svgHelpers_1.SvgHelpers.doesBox1ContainBox2(note.logicalBox, box)) {
            rv.push(value);
        }
        return rv;
    }
}
exports.MappedNotes = MappedNotes;
/**
 * Map of measures to a region on the page.
 */
class MappedMeasures extends SelectionMap {
    constructor() {
        super(...arguments);
        this.box = common_1.SvgBox.default;
        this.systemMap = new Map();
    }
    createKey(selection) {
        return `${selection.selector.staff}-${selection.selector.measure}`;
    }
    boxFromSelection(selection) {
        var _a, _b;
        const noteBox = (_b = (_a = selection.note) === null || _a === void 0 ? void 0 : _a.logicalBox) !== null && _b !== void 0 ? _b : common_1.SvgBox.default;
        return svgHelpers_1.SvgHelpers.unionRect(noteBox, selection.measure.svg.logicalBox);
    }
    addKeyToMap(key, selection) {
        var _a;
        if (!this.systemMap.has(key)) {
            const nnote = new MappedNotes();
            this.systemMap.set(key, nnote);
        }
        (_a = this.systemMap.get(key)) === null || _a === void 0 ? void 0 : _a.addArtifact(selection);
    }
    findValueInMap(value, box) {
        let rv = [];
        if (svgHelpers_1.SvgHelpers.doesBox1ContainBox2(value.box, box)) {
            rv = rv.concat(value.findArtifact(box));
        }
        return rv;
    }
}
exports.MappedMeasures = MappedMeasures;
/**
 * Map of the systems on a page.  Each system has a unique line index
 * which is the hash
 */
class MappedSystems extends SelectionMap {
    constructor() {
        super(...arguments);
        this.box = common_1.SvgBox.default;
        this.systemMap = new Map();
    }
    createKey(selection) {
        return selection.measure.svg.lineIndex;
    }
    boxFromSelection(selection) {
        var _a, _b;
        const noteBox = (_b = (_a = selection.note) === null || _a === void 0 ? void 0 : _a.logicalBox) !== null && _b !== void 0 ? _b : common_1.SvgBox.default;
        return svgHelpers_1.SvgHelpers.unionRect(noteBox, selection.measure.svg.logicalBox);
    }
    addKeyToMap(selectionKey, selection) {
        var _a;
        if (!this.systemMap.has(selectionKey)) {
            const nmeasure = new MappedMeasures();
            this.systemMap.set(selectionKey, nmeasure);
        }
        (_a = this.systemMap.get(selectionKey)) === null || _a === void 0 ? void 0 : _a.addArtifact(selection);
    }
    findValueInMap(value, box) {
        let rv = [];
        if (svgHelpers_1.SvgHelpers.doesBox1ContainBox2(value.box, box)) {
            rv = rv.concat(value.findArtifact(box));
        }
        return rv;
    }
    clearMeasure(selection) {
        if (this.systemMap.has(selection.measure.svg.lineIndex)) {
            const mmap = this.systemMap.get(selection.measure.svg.lineIndex);
            if (mmap) {
                this.systemMap.delete(selection.measure.svg.lineIndex);
            }
        }
    }
}
exports.MappedSystems = MappedSystems;
/**
 * Each page is a different SVG element, with its own offset within the DOM. This
 * makes partial updates faster.  SvgPage keeps track of all musical elements in SelectionMaps.
 * staff and score modifiers are kept in seperate lists since they may span multiple
 * musical elements (e.g. slurs, text elements).
 */
class SvgPage {
    constructor(renderer, pageNumber, box) {
        this.systemMap = new MappedSystems();
        this.modifierYKeys = [];
        this.modifierTabDivs = {};
        this._renderer = renderer;
        this.pageNumber = pageNumber;
        this.box = box;
        let divEnd = this.divSize;
        for (let i = 0; i < SvgPage.modifierDivs; ++i) {
            this.modifierYKeys.push(divEnd);
            divEnd += this.divSize;
        }
    }
    static get defaultMap() {
        return {
            box: common_1.SvgBox.default,
            systemMap: new Map()
        };
    }
    /**
     * Modifiers are divided into `modifierDivs` vertical
     * rectangles for event lookup.
     */
    static get modifierDivs() {
        return 8;
    }
    /**
     * This is the VextFlow renderer context (SVGContext)
     * @returns
     */
    getContext() {
        return this._renderer.getContext();
    }
    get divSize() {
        return this.box.height / SvgPage.modifierDivs;
    }
    /**
     * Given SVG y, return the div for modifiers
     * @param y
     * @returns
     */
    divIndex(y) {
        return Math.round((y - this.box.y) / this.divSize);
    }
    /**
     * Remove all elements and modifiers in this page, for a redraw.
     */
    clearMap() {
        this.systemMap = new MappedSystems();
        this.modifierTabDivs = {};
    }
    /**
     * Clear mapped objects associated with a measure, including any
     * modifiers that span that measure.
     * @param selection
     */
    clearMeasure(selection) {
        this.systemMap.clearMeasure(selection);
        const div = this.divIndex(selection.measure.svg.logicalBox.y);
        if (div < this.modifierYKeys.length) {
            const mods = [];
            this.modifierTabDivs[div].forEach((mt) => {
                if (mt.selection) {
                    if (!selections_1.SmoSelector.sameMeasure(mt.selection.selector, selection.selector)) {
                        mods.push(mt);
                    }
                }
                else {
                    mods.push(mt);
                }
            });
            this.modifierTabDivs[div] = mods;
        }
    }
    /**
     * add a modifier to the page, indexed by its rectangle
     * @param modifier
     */
    addModifierTab(modifier) {
        const div = this.divIndex(modifier.box.y);
        if (div < this.modifierYKeys.length) {
            if (!this.modifierTabDivs[div]) {
                this.modifierTabDivs[div] = [];
            }
            this.modifierTabDivs[div].push(modifier);
        }
    }
    /**
     * Add a new selection to the page
     * @param selection
     */
    addArtifact(selection) {
        this.systemMap.addArtifact(selection);
    }
    /**
     * Try to find a selection on this page, based on the mouse event
     * @param box
     * @returns
     */
    findArtifact(box) {
        return this.systemMap.findArtifact(box);
    }
    /**
     * Try to find a modifier on this page, based on the mouse event
     * @param box
     * @returns
     */
    findModifierTabs(box) {
        const rv = [];
        const div = this.divIndex(box.y);
        if (div < this.modifierYKeys.length) {
            if (this.modifierTabDivs[div]) {
                this.modifierTabDivs[div].forEach((modTab) => {
                    if (svgHelpers_1.SvgHelpers.doesBox1ContainBox2(modTab.box, box)) {
                        rv.push(modTab);
                    }
                });
            }
        }
        return rv;
    }
    clearModifiers() {
        Object.keys(this.modifierTabDivs).forEach((key) => {
            const modifiers = this.modifierTabDivs[parseInt(key)];
            modifiers.forEach((mod) => {
                if (mod instanceof scoreText_1.SmoTextGroup) {
                    mod.elements.forEach((element) => {
                        element.remove();
                    });
                    mod.elements = [];
                }
            });
        });
        this.modifierTabDivs = {};
    }
    /**
     * Measure the bounding box of an element.  Return the box as if the top of the first page were 0,0.
     * Bounding boxes are stored in absolute coordinates from the top of the first page.  When rendering
     * elements, we adjust the coordinates for hte local page.
     * @param element
     * @returns
     */
    offsetBbox(element) {
        const yoff = this.box.y;
        const xoff = this.box.x;
        const lbox = element.getBBox();
        return ({ x: lbox.x + xoff, y: lbox.y + yoff, width: lbox.width, height: lbox.height });
    }
    /**
     * Adjust the bounding box to local coordinates for this page.
     * @param box
     * @returns
     */
    offsetSvgBox(box) {
        return { x: box.x - this.box.x, y: box.y - this.box.y, width: box.width, height: box.height };
    }
    /**
     * Adjust the point to local coordinates for this page.
     * @param box
     * @returns
     */
    offsetSvgPoint(box) {
        return { x: box.x - this.box.x, y: box.y - this.box.y };
    }
    get svg() {
        return this.getContext().svg;
    }
}
exports.SvgPage = SvgPage;
/**
 * A container for all the SVG elements, and methods to manage adding and finding elements.  Each
 * page of the score has its own SVG element.
 */
class SvgPageMap {
    /**
     *
     * @param layout - defines the page width/height and relative zoom common to all the pages
     * @param container - the parent DOM element that contains all the pages
     * @param pages - the layouts (margins, etc) for each pages.
     */
    constructor(layout, container, pages) {
        this.vfRenderers = [];
        this.containerOffset = common_1.SvgPoint.default;
        this._layout = layout;
        this._container = container;
        this._pageLayouts = pages;
    }
    static get strokes() {
        return {
            'debug-mouse-box': {
                strokeName: 'debug-mouse',
                stroke: '#7ce',
                strokeWidth: 3,
                strokeDasharray: '1,1',
                fill: 'none',
                opacity: 0.6
            }
        };
    }
    get container() {
        return this._container;
    }
    /**
     * Update the offset of the music container DOM element, in client coordinates. This is used
     * when converting absolute screen coordinates (like from a mouse event) to SVG coordinates
     * @param scrollPoint
     */
    updateContainerOffset(scrollPoint) {
        const rect = svgHelpers_1.SvgHelpers.smoBox(this.container.getBoundingClientRect());
        this.containerOffset = { x: rect.x + scrollPoint.x, y: rect.y + scrollPoint.y };
    }
    get layout() {
        return this._layout;
    }
    get pageLayouts() {
        return this._pageLayouts;
    }
    get zoomScale() {
        return this.layout.zoomScale;
    }
    get renderScale() {
        return this.layout.svgScale;
    }
    get pageDivHeight() {
        return this.layout.pageHeight * this.zoomScale;
    }
    get pageDivWidth() {
        return this.layout.pageWidth * this.zoomScale;
    }
    get pageHeight() {
        return this.layout.pageHeight / this.layout.svgScale;
    }
    get pageWidth() {
        return this.layout.pageWidth / this.layout.svgScale;
    }
    get totalHeight() {
        return this.pageDivHeight * this.pageLayouts.length;
    }
    /**
     * create/re-create all the page SVG elements
     */
    createRenderers() {
        // $(this.container).html('');
        $(this.container).css('width', '' + Math.round(this.pageDivWidth) + 'px');
        $(this.container).css('height', '' + Math.round(this.totalHeight) + 'px');
        const toRemove = [];
        this.vfRenderers.forEach((renderer) => {
            const container = renderer.svg.parentElement;
            if (container) {
                toRemove.push(container);
            }
        });
        toRemove.forEach((tt) => {
            tt.remove();
        });
        this.vfRenderers = [];
        this.pageLayouts.forEach(() => {
            this.addPage();
        });
    }
    addPage() {
        const ix = this.vfRenderers.length;
        const container = document.createElement('div');
        container.setAttribute('id', 'smoosic-svg-div-' + ix.toString());
        this._container.append(container);
        const vexRenderer = new VF.Renderer(container, VF.Renderer.Backends.SVG);
        const svg = vexRenderer.getContext().svg;
        svgHelpers_1.SvgHelpers.svgViewport(svg, 0, 0, this.pageDivWidth, this.pageDivHeight, this.renderScale * this.zoomScale);
        const topY = this.pageHeight * ix;
        const box = svgHelpers_1.SvgHelpers.boxPoints(0, topY, this.pageWidth, this.pageHeight);
        this.vfRenderers.push(new SvgPage(vexRenderer, ix, box));
    }
    updateZoom(zoomScale) {
        this.layout.zoomScale = zoomScale;
        this.vfRenderers.forEach((pp) => {
            svgHelpers_1.SvgHelpers.svgViewport(pp.svg, 0, 0, this.pageDivWidth, this.pageDivHeight, this.renderScale * this.zoomScale);
        });
        $(this.container).css('width', '' + Math.round(this.pageDivWidth) + 'px');
        $(this.container).css('height', '' + Math.round(this.totalHeight) + 'px');
    }
    /**
     * Convert from screen/client event to SVG space.  We assume the scroll offset is already added to `box`
     * @param box
     * @returns
     */
    clientToSvg(box) {
        const cof = (this.zoomScale * this.renderScale);
        const x = (box.x - this.containerOffset.x) / cof;
        const y = (box.y - this.containerOffset.y) / cof;
        const logicalBox = svgHelpers_1.SvgHelpers.boxPoints(x, y, Math.max(box.width / cof, 1), Math.max(box.height / cof, 1));
        logicalBox.y -= Math.round(logicalBox.y / this.layout.pageHeight) / this.layout.svgScale;
        if (layoutDebug_1.layoutDebug.mask | layoutDebug_1.layoutDebug.values['mouseDebug']) {
            layoutDebug_1.layoutDebug.updateMouseDebug(box, logicalBox, this.containerOffset);
        }
        return logicalBox;
    }
    /**
     * Convert from SVG bounding box to screen coordinates
     * @param box
     * @returns
     */
    svgToClient(box) {
        const cof = (this.zoomScale * this.renderScale);
        const x = (box.x * cof) + this.containerOffset.x;
        const y = (box.y * cof) + this.containerOffset.y;
        const clientBox = svgHelpers_1.SvgHelpers.boxPoints(x, y, box.width * cof, box.height * cof);
        return clientBox;
    }
    /**
     * Convert from SVG bounding box to screen coordinates
     * @param box
     * @returns
    */
    svgToClientNoOffset(box) {
        const cof = (this.zoomScale * this.renderScale);
        const x = (box.x * cof);
        const y = (box.y * cof);
        const clientBox = svgHelpers_1.SvgHelpers.boxPoints(x, y, box.width * cof, box.height * cof);
        return clientBox;
    }
    /**
     * Find a selection from a mouse event
     * @param box - location of a mouse event or specific screen coordinates
     * @returns
     */
    findArtifact(logicalBox) {
        const selections = [];
        const page = this.getRenderer(logicalBox);
        if (page) {
            return { selections: page.findArtifact(logicalBox), page };
        }
        return { selections, page: this.vfRenderers[0] };
    }
    /**
     * Find any modifiers intersecting with `box`
     * @param box
     * @returns
     */
    findModifierTabs(logicalBox) {
        const page = this.getRenderer(logicalBox);
        if (page) {
            return page.findModifierTabs(logicalBox);
        }
        return [];
    }
    /**
     * add a rendered page to the page map
     * @param selection
     * @returns
     */
    addArtifact(selection) {
        if (!selection.note || !selection.note.logicalBox) {
            return;
        }
        const page = this.getRenderer(selection.note.logicalBox);
        if (page) {
            page.addArtifact(selection);
        }
    }
    /**
     * add a rendered modifier to the page map
     * @param modifier
     */
    addModifierTab(modifier) {
        const page = this.getRenderer(modifier.box);
        if (page) {
            page.addModifierTab(modifier);
        }
    }
    clearModifiersForPage(page) {
        if (this.vfRenderers.length > page) {
            this.vfRenderers[page].clearModifiers();
        }
    }
    /**
     * The number of pages is changing, remove the last page
     * @returns
     */
    removePage() {
        let i = 0;
        // Don't remove the only page
        if (this.vfRenderers.length < 2) {
            return;
        }
        // Remove last page div
        const elementId = 'smoosic-svg-div-' + (this.vfRenderers.length - 1).toString();
        const container = document.getElementById(elementId);
        if (container) {
            container.remove();
        }
        // pop last renderer off the stack.
        const renderers = [];
        const layouts = [];
        for (i = 0; i < this.vfRenderers.length - 1; ++i) {
            renderers.push(this.vfRenderers[i]);
            layouts.push(this.pageLayouts[i]);
        }
        this.vfRenderers = renderers;
        this._pageLayouts = layouts;
        // update page height
        const totalHeight = this.pageDivHeight * this.pageLayouts.length;
        $(this.container).css('width', '' + Math.round(this.pageDivWidth) + 'px');
        $(this.container).css('height', '' + Math.round(totalHeight) + 'px');
    }
    /**
     * The score dimensions have changed, clear maps and recreate the pages.
     * @param layout
     * @param pageLayouts
     */
    updateLayout(layout, pageLayouts) {
        this._layout = layout;
        this._pageLayouts = pageLayouts;
        this.createRenderers();
    }
    /**
     * Return the page by index
     * @param page
     * @returns
     */
    getRendererForPage(page) {
        if (this.vfRenderers.length > page) {
            return this.vfRenderers[page];
        }
        return this.vfRenderers[this.vfRenderers.length - 1];
    }
    /**
     * Return the SvgPage based on SVG point (conversion from client coordinates already done)
     * @param point
     * @returns
     */
    getRendererFromPoint(point) {
        const ix = Math.floor(point.y / (this.layout.pageHeight / this.layout.svgScale));
        if (ix < this.vfRenderers.length) {
            return this.vfRenderers[ix];
        }
        return null;
    }
    /**
     * Return the SvgPage based on SVG point (conversion from client coordinates already done)
     * @param box
     * @returns
     */
    getRenderer(box) {
        const rv = this.getRendererFromPoint({ x: box.x, y: box.y });
        if (rv) {
            return rv;
        }
        return this.vfRenderers[0];
    }
    /**
     * Return the page based on the coordinates of a modifier
     * @param modifier
     * @returns
     */
    getRendererFromModifier(modifier) {
        let rv = this.vfRenderers[0];
        if (modifier && modifier.logicalBox) {
            const context = this.getRenderer(modifier.logicalBox);
            if (context) {
                rv = context;
            }
        }
        return rv;
    }
}
exports.SvgPageMap = SvgPageMap;


/***/ }),

/***/ "./src/render/sui/textEdit.ts":
/*!************************************!*\
  !*** ./src/render/sui/textEdit.ts ***!
  \************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SuiChordSession = exports.SuiLyricSession = exports.SuiTextSession = exports.SuiDragSession = exports.SuiChordEditor = exports.SuiLyricEditor = exports.SuiTextBlockEditor = exports.SuiTextEditor = void 0;
// [Smoosic](https://github.com/AaronDavidNewman/Smoosic)
// Copyright (c) Aaron David Newman 2021.
const textRender_1 = __webpack_require__(/*! ./textRender */ "./src/render/sui/textRender.ts");
const renderState_1 = __webpack_require__(/*! ./renderState */ "./src/render/sui/renderState.ts");
const layoutDebug_1 = __webpack_require__(/*! ./layoutDebug */ "./src/render/sui/layoutDebug.ts");
const promiseHelpers_1 = __webpack_require__(/*! ../../common/promiseHelpers */ "./src/common/promiseHelpers.ts");
const svgHelpers_1 = __webpack_require__(/*! ./svgHelpers */ "./src/render/sui/svgHelpers.ts");
const scoreText_1 = __webpack_require__(/*! ../../smo/data/scoreText */ "./src/smo/data/scoreText.ts");
const noteModifiers_1 = __webpack_require__(/*! ../../smo/data/noteModifiers */ "./src/smo/data/noteModifiers.ts");
const common_1 = __webpack_require__(/*! ../../smo/data/common */ "./src/smo/data/common.ts");
const selections_1 = __webpack_require__(/*! ../../smo/xform/selections */ "./src/smo/xform/selections.ts");
const VF = eval('Vex.Flow');
/**
 * The heirarchy of text editing objects goes:
 *
 * `dialog -> component -> session -> editor`
 *
 * Editors and Sessions are defined in this module.
 * ### editor
 * handles low-level events and renders the preview using one
 * of the text layout objects.
 * ### session
 * creates and destroys editors, e.g. for lyrics that have a Different
 * editor instance for each note.
 *
 * ## SuiTextEditor
 * The base text editor handles the positioning and inserting
 * of text blocks into the text area.  The derived class shoud interpret key events.
 * A container class will manage the session for starting/stopping the editor
 * and retrieving the results into the target object.
 * */
class SuiTextEditor {
    constructor(params) {
        this.svgText = null;
        this.outlineInfo = null;
        this.x = 0;
        this.y = 0;
        this.textPos = 0;
        this.selectionStart = -1;
        this.selectionLength = -1;
        this.empty = true;
        this.suggestionIndex = -1;
        this.cursorState = false;
        this.cursorRunning = false;
        this.textType = textRender_1.SuiInlineText.textTypes.normal;
        this.fontWeight = 'normal';
        this.fontFamily = 'Merriweather';
        this.fontSize = 14;
        this.state = SuiTextEditor.States.RUNNING;
        this.suggestionRect = null;
        this.scroller = params.scroller;
        this.context = params.context;
        this.x = params.x;
        this.y = params.y;
        this.text = params.text;
        this.pageMap = params.pageMap;
    }
    static get States() {
        return { RUNNING: 1, STOPPING: 2, STOPPED: 4, PENDING_EDITOR: 8 };
    }
    // parsers use this convention to represent text types (superscript)
    static textTypeToChar(textType) {
        if (textType === textRender_1.SuiInlineText.textTypes.superScript) {
            return '^';
        }
        if (textType === textRender_1.SuiInlineText.textTypes.subScript) {
            return '%';
        }
        return '';
    }
    static textTypeFromChar(char) {
        if (char === '^') {
            return textRender_1.SuiInlineText.textTypes.superScript;
        }
        if (char === '%') {
            return textRender_1.SuiInlineText.textTypes.subScript;
        }
        return textRender_1.SuiInlineText.textTypes.normal;
    }
    static get strokes() {
        return {
            'text-suggestion': {
                strokeName: 'text-suggestion',
                stroke: '#cce',
                strokeWidth: 1,
                strokeDasharray: '4,1',
                fill: 'none',
                opacity: 1.0
            },
            'text-selection': {
                strokeName: 'text-selection',
                stroke: '#99d',
                strokeWidth: 1,
                fill: 'none',
                strokeDasharray: '',
                opacity: 1.0
            },
            'text-highlight': {
                strokeName: 'text-highlight',
                stroke: '#dd9',
                strokeWidth: 1,
                strokeDasharray: '4,1',
                fill: 'none',
                opacity: 1.0
            },
            'text-drag': {
                strokeName: 'text-drag',
                stroke: '#d99',
                strokeWidth: 1,
                strokeDasharray: '2,1',
                fill: '#eee',
                opacity: 0.3
            },
            'inactive-text': {
                strokeName: 'inactive-text',
                stroke: '#fff',
                strokeWidth: 1,
                strokeDasharray: '',
                fill: '#ddd',
                opacity: 0.3
            }
        };
    }
    // ### _suggestionParameters
    // Create the svg text outline parameters
    _suggestionParameters(box, strokeName) {
        const outlineStroke = SuiTextEditor.strokes[strokeName];
        if (!this.suggestionRect) {
            this.suggestionRect = {
                context: this.context, box, classes: '',
                stroke: outlineStroke, scroll: this.scroller.scrollState, timeOff: 1000
            };
        }
        ;
        this.suggestionRect.box = svgHelpers_1.SvgHelpers.smoBox(box);
        return this.suggestionRect;
    }
    // ### _expandSelectionToSuggestion
    // Expand the selection to include the character the user clicked on.
    _expandSelectionToSuggestion() {
        if (this.suggestionIndex < 0) {
            return;
        }
        if (this.selectionStart < 0) {
            this._setSelectionToSugggestion();
            return;
        }
        else if (this.selectionStart > this.suggestionIndex) {
            const oldStart = this.selectionStart;
            this.selectionStart = this.suggestionIndex;
            this.selectionLength = (oldStart - this.selectionStart) + this.selectionLength;
        }
        else if (this.selectionStart < this.suggestionIndex
            && this.selectionStart > this.selectionStart + this.selectionLength) {
            this.selectionLength = (this.suggestionIndex - this.selectionStart) + 1;
        }
        this._updateSelections();
    }
    // ### _setSelectionToSugggestion
    // Set the selection to the character the user clicked on.
    _setSelectionToSugggestion() {
        this.selectionStart = this.suggestionIndex;
        this.selectionLength = 1;
        this.suggestionIndex = -1;
        this._updateSelections();
    }
    rerender() {
        var _a, _b;
        (_a = this.svgText) === null || _a === void 0 ? void 0 : _a.unrender();
        (_b = this.svgText) === null || _b === void 0 ? void 0 : _b.render();
    }
    // ### handleMouseEvent
    // Handle hover/click behavior for the text under edit.
    // Returns: true if the event was handled here
    handleMouseEvent(ev) {
        let handled = false;
        if (this.svgText === null) {
            return false;
        }
        const clientBox = svgHelpers_1.SvgHelpers.boxPoints(ev.clientX + this.scroller.scrollState.x, ev.clientY + this.scroller.scrollState.y, 1, 1);
        const logicalBox = this.pageMap.clientToSvg(clientBox);
        var blocks = this.svgText.getIntersectingBlocks(logicalBox);
        // The mouse is not over the text
        if (!blocks.length) {
            if (this.suggestionRect) {
                svgHelpers_1.SvgHelpers.eraseOutline(this.suggestionRect);
            }
            // If the user clicks and there was a previous selection, treat it as selected
            if (ev.type === 'click' && this.suggestionIndex >= 0) {
                if (ev.shiftKey) {
                    this._expandSelectionToSuggestion();
                }
                else {
                    this._setSelectionToSugggestion();
                }
                handled = true;
                this.rerender();
            }
            return handled;
        }
        handled = true;
        // outline the text that is hovered.  Since mouse is a point
        // there should only be 1
        blocks.forEach((block) => {
            svgHelpers_1.SvgHelpers.outlineRect(this._suggestionParameters(block.box, 'text-suggestion'));
            this.suggestionIndex = block.index;
        });
        // if the user clicked on it, add it to the selection.
        if (ev.type === 'click') {
            if (this.suggestionRect) {
                svgHelpers_1.SvgHelpers.eraseOutline(this.suggestionRect);
            }
            if (ev.shiftKey) {
                this._expandSelectionToSuggestion();
            }
            else {
                this._setSelectionToSugggestion();
            }
            const npos = this.selectionStart + this.selectionLength;
            if (npos >= 0 && npos <= this.svgText.blocks.length) {
                this.textPos = npos;
            }
            this.rerender();
        }
        return handled;
    }
    // ### _serviceCursor
    // Flash the cursor as a background task
    _serviceCursor() {
        var _a, _b;
        if (this.cursorState) {
            (_a = this.svgText) === null || _a === void 0 ? void 0 : _a.renderCursorAt(this.textPos - 1, this.textType);
        }
        else {
            (_b = this.svgText) === null || _b === void 0 ? void 0 : _b.removeCursor();
        }
        this.cursorState = !this.cursorState;
    }
    // ### _refreshCursor
    // If the text position changes, update the cursor position right away
    // don't wait for blink.
    _refreshCursor() {
        var _a;
        (_a = this.svgText) === null || _a === void 0 ? void 0 : _a.removeCursor();
        this.cursorState = true;
        this._serviceCursor();
    }
    get _endCursorCondition() {
        return this.cursorRunning === false;
    }
    _cursorPreResolve() {
        var _a;
        (_a = this.svgText) === null || _a === void 0 ? void 0 : _a.removeCursor();
    }
    _cursorPoll() {
        this._serviceCursor();
    }
    // ### startCursorPromise
    // Used by the calling logic to start the cursor.
    // returns a promise that can be pended when the editing ends.
    startCursorPromise() {
        var _a;
        var self = this;
        this.cursorRunning = true;
        this.cursorState = true;
        (_a = self.svgText) === null || _a === void 0 ? void 0 : _a.renderCursorAt(this.textPos, textRender_1.SuiInlineText.textTypes.normal);
        return promiseHelpers_1.PromiseHelpers.makePromise(() => this._endCursorCondition, () => this._cursorPreResolve(), () => this._cursorPoll(), 333);
    }
    stopCursor() {
        this.cursorRunning = false;
    }
    // ### setTextPos
    // Set the text position within the editor space and update the cursor
    setTextPos(val) {
        this.textPos = val;
        this._refreshCursor();
    }
    // ### moveCursorRight
    // move cursor right within the block of text.
    moveCursorRight() {
        if (this.svgText === null) {
            return;
        }
        if (this.textPos <= this.svgText.blocks.length) {
            this.setTextPos(this.textPos + 1);
        }
    }
    // ### moveCursorRight
    // move cursor left within the block of text.
    moveCursorLeft() {
        if (this.textPos > 0) {
            this.setTextPos(this.textPos - 1);
        }
    }
    // ### moveCursorRight
    // highlight the text selections
    _updateSelections() {
        var _a;
        let i = 0;
        const end = this.selectionStart + this.selectionLength;
        const start = this.selectionStart;
        (_a = this.svgText) === null || _a === void 0 ? void 0 : _a.blocks.forEach((block) => {
            const val = start >= 0 && i >= start && i < end;
            this.svgText.setHighlight(block, val);
            ++i;
        });
    }
    // ### _checkGrowSelectionLeft
    // grow selection within the bounds
    _checkGrowSelectionLeft() {
        if (this.selectionStart > 0) {
            this.selectionStart -= 1;
            this.selectionLength += 1;
        }
    }
    // ### _checkGrowSelectionRight
    // grow selection within the bounds
    _checkGrowSelectionRight() {
        if (this.svgText === null) {
            return;
        }
        const end = this.selectionStart + this.selectionLength;
        if (end < this.svgText.blocks.length) {
            this.selectionLength += 1;
        }
    }
    // ### growSelectionLeft
    // handle the selection keys
    growSelectionLeft() {
        if (this.selectionStart === -1) {
            this.moveCursorLeft();
            this.selectionStart = this.textPos;
            this.selectionLength = 1;
        }
        else if (this.textPos === this.selectionStart) {
            this.moveCursorLeft();
            this._checkGrowSelectionLeft();
        }
        this._updateSelections();
    }
    // ### growSelectionRight
    // handle the selection keys
    growSelectionRight() {
        if (this.selectionStart === -1) {
            this.selectionStart = this.textPos;
            this.selectionLength = 1;
            this.moveCursorRight();
        }
        else if (this.selectionStart + this.selectionLength === this.textPos) {
            this._checkGrowSelectionRight();
            this.moveCursorRight();
        }
        this._updateSelections();
    }
    // ### _clearSelections
    // Clear selected text
    _clearSelections() {
        this.selectionStart = -1;
        this.selectionLength = 0;
    }
    // ### deleteSelections
    // delete the selected blocks of text/glyphs
    deleteSelections() {
        var _a;
        let i = 0;
        const blockPos = this.selectionStart;
        for (i = 0; i < this.selectionLength; ++i) {
            (_a = this.svgText) === null || _a === void 0 ? void 0 : _a.removeBlockAt(blockPos); // delete shifts blocks so keep index the same.
        }
        this.setTextPos(blockPos);
        this.selectionStart = -1;
        this.selectionLength = 0;
    }
    // ### parseBlocks
    // THis can be overridden by the base class to create the correct combination
    // of text and glyph blocks based on the underlying text
    parseBlocks() {
        let i = 0;
        this.svgText = new textRender_1.SuiInlineText({
            context: this.context, startX: this.x, startY: this.y,
            fontFamily: this.fontFamily, fontSize: this.fontSize, fontWeight: this.fontWeight, scroller: this.scroller,
            purpose: textRender_1.SuiInlineText.textPurposes.edit,
            fontStyle: 'normal', pageMap: this.pageMap
        });
        for (i = 0; i < this.text.length; ++i) {
            const def = textRender_1.SuiInlineText.blockDefaults;
            def.text = this.text[i];
            this.svgText.addTextBlockAt(i, def);
            this.empty = false;
        }
        this.textPos = this.text.length;
        this.state = SuiTextEditor.States.RUNNING;
        this.rerender();
    }
    // ### evKey
    // Handle key events that filter down to the editor
    evKey(evdata) {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            const removeCurrent = () => {
                var _a;
                if (this.svgText) {
                    (_a = this.svgText.element) === null || _a === void 0 ? void 0 : _a.remove();
                    this.svgText.element = null;
                }
            };
            if (evdata.code === 'ArrowRight') {
                if (evdata.shiftKey) {
                    this.growSelectionRight();
                }
                else {
                    this.moveCursorRight();
                }
                this.rerender();
                return true;
            }
            if (evdata.code === 'ArrowLeft') {
                if (evdata.shiftKey) {
                    this.growSelectionLeft();
                }
                else {
                    this.moveCursorLeft();
                }
                this.rerender();
                return true;
            }
            if (evdata.code === 'Backspace') {
                removeCurrent();
                if (this.selectionStart >= 0) {
                    this.deleteSelections();
                }
                else {
                    if (this.textPos > 0) {
                        this.selectionStart = this.textPos - 1;
                        this.selectionLength = 1;
                        this.deleteSelections();
                    }
                }
                this.rerender();
                return true;
            }
            if (evdata.code === 'Delete') {
                removeCurrent();
                if (this.selectionStart >= 0) {
                    this.deleteSelections();
                }
                else {
                    if (this.textPos > 0 && this.svgText !== null && this.textPos < this.svgText.blocks.length) {
                        this.selectionStart = this.textPos;
                        this.selectionLength = 1;
                        this.deleteSelections();
                    }
                }
                this.rerender();
                return true;
            }
            if (evdata.key.charCodeAt(0) >= 33 && evdata.key.charCodeAt(0) <= 126 && evdata.key.length === 1) {
                removeCurrent();
                const isPaste = evdata.ctrlKey && evdata.key === 'v';
                let text = evdata.key;
                if (isPaste) {
                    text = yield navigator.clipboard.readText();
                }
                if (this.empty) {
                    (_a = this.svgText) === null || _a === void 0 ? void 0 : _a.removeBlockAt(0);
                    this.empty = false;
                    const def = textRender_1.SuiInlineText.blockDefaults;
                    def.text = text;
                    (_b = this.svgText) === null || _b === void 0 ? void 0 : _b.addTextBlockAt(0, def);
                    this.setTextPos(1);
                }
                else {
                    if (this.selectionStart >= 0) {
                        this.deleteSelections();
                    }
                    const def = textRender_1.SuiInlineText.blockDefaults;
                    def.text = text;
                    def.textType = this.textType;
                    (_c = this.svgText) === null || _c === void 0 ? void 0 : _c.addTextBlockAt(this.textPos, def);
                    this.setTextPos(this.textPos + 1);
                }
                this.rerender();
                return true;
            }
            return false;
        });
    }
}
exports.SuiTextEditor = SuiTextEditor;
class SuiTextBlockEditor extends SuiTextEditor {
    // ### ctor
    // ### args
    // params: {lyric: SmoLyric,...}
    constructor(params) {
        super(params);
        $(this.context.svg).find('g.vf-text-highlight').remove();
        this.parseBlocks();
    }
    _highlightEditor() {
        if (this.svgText === null || this.svgText.blocks.length === 0) {
            return;
        }
        const bbox = this.svgText.getLogicalBox();
        const outlineStroke = SuiTextEditor.strokes['text-highlight'];
        if (this.outlineInfo && this.outlineInfo.element) {
            this.outlineInfo.element.remove();
        }
        this.outlineInfo = {
            context: this.context, box: bbox, classes: '',
            stroke: outlineStroke, scroll: this.scroller.scrollState,
            timeOff: 0
        };
        svgHelpers_1.SvgHelpers.outlineRect(this.outlineInfo);
    }
    getText() {
        if (this.svgText !== null) {
            return this.svgText.getText();
        }
        return '';
    }
    evKey(evdata) {
        const _super = Object.create(null, {
            evKey: { get: () => super.evKey }
        });
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            if (evdata.key.charCodeAt(0) === 32) {
                if (this.empty) {
                    (_a = this.svgText) === null || _a === void 0 ? void 0 : _a.removeBlockAt(0);
                    this.empty = false;
                    const def = textRender_1.SuiInlineText.blockDefaults;
                    def.text = ' ';
                    (_b = this.svgText) === null || _b === void 0 ? void 0 : _b.addTextBlockAt(0, def);
                    this.setTextPos(1);
                }
                else {
                    if (this.selectionStart >= 0) {
                        this.deleteSelections();
                    }
                    const def = textRender_1.SuiInlineText.blockDefaults;
                    def.text = ' ';
                    def.textType = this.textType;
                    (_c = this.svgText) === null || _c === void 0 ? void 0 : _c.addTextBlockAt(this.textPos, def);
                    this.setTextPos(this.textPos + 1);
                }
                this.rerender();
                return true;
            }
            const rv = _super.evKey.call(this, evdata);
            this._highlightEditor();
            return rv;
        });
    }
    stopEditor() {
        var _a;
        this.state = SuiTextEditor.States.STOPPING;
        $(this.context.svg).find('g.vf-text-highlight').remove();
        this.stopCursor();
        (_a = this.svgText) === null || _a === void 0 ? void 0 : _a.unrender();
    }
}
exports.SuiTextBlockEditor = SuiTextBlockEditor;
class SuiLyricEditor extends SuiTextEditor {
    // ### ctor
    // ### args
    // params: {lyric: SmoLyric,...}
    constructor(params) {
        super(params);
        this.state = SuiTextEditor.States.PENDING_EDITOR;
        this.text = params.lyric.getText();
        if (params.lyric.isHyphenated()) {
            this.text += '-';
        }
        this.lyric = params.lyric;
        this.parseBlocks();
    }
    static get States() {
        return { RUNNING: 1, STOPPING: 2, STOPPED: 4 };
    }
    parseBlocks() {
        let i = 0;
        const def = textRender_1.SuiInlineText.defaults;
        def.context = this.context;
        def.startX = this.x;
        def.startY = this.y;
        def.scroller = this.scroller;
        this.svgText = new textRender_1.SuiInlineText(def);
        for (i = 0; i < this.text.length; ++i) {
            const blockP = textRender_1.SuiInlineText.blockDefaults;
            blockP.text = this.text[i];
            this.svgText.addTextBlockAt(i, blockP);
            this.empty = false;
        }
        this.textPos = this.text.length;
        this.state = SuiTextEditor.States.RUNNING;
        this.rerender();
    }
    getText() {
        if (this.svgText !== null) {
            return this.svgText.getText();
        }
        return '';
    }
    stopEditor() {
        this.state = SuiTextEditor.States.STOPPING;
        this.stopCursor();
        if (this.svgText !== null) {
            this.svgText.unrender();
        }
    }
}
exports.SuiLyricEditor = SuiLyricEditor;
class SuiChordEditor extends SuiTextEditor {
    // ### ctor
    // ### args
    // params: {lyric: SmoLyric,...}
    constructor(params) {
        super(params);
        this.text = params.lyric._text;
        this.lyric = params.lyric;
        this.textType = textRender_1.SuiInlineText.textTypes.normal;
        this.parseBlocks();
    }
    static get States() {
        return { RUNNING: 1, STOPPING: 2, STOPPED: 4 };
    }
    static get SymbolModifiers() {
        return {
            NONE: 1,
            SUBSCRIPT: 2,
            SUPERSCRIPT: 3
        };
    }
    // ### toTextTypeChar
    // Given an old text type and a desited new text type,
    // return what the new text type character should be
    static toTextTypeChar(oldTextType, newTextType) {
        const tt = textRender_1.SuiInlineText.getTextTypeResult(oldTextType, newTextType);
        return SuiTextEditor.textTypeToChar(tt);
    }
    static toTextTypeTransition(oldTextType, result) {
        const tt = textRender_1.SuiInlineText.getTextTypeTransition(oldTextType, result);
        return SuiTextEditor.textTypeToChar(tt);
    }
    setTextType(textType) {
        this.textType = textType;
    }
    // Handle the case where user changed super/subscript in the middle of the
    // string.
    _updateSymbolModifiers() {
        let change = this.textPos;
        let render = false;
        let i = 0;
        for (i = this.textPos; this.svgText !== null && i < this.svgText.blocks.length; ++i) {
            const block = this.svgText.blocks[i];
            if (block.textType !== this.textType &&
                block.textType !== change) {
                change = block.textType;
                block.textType = this.textType;
                render = true;
            }
            else {
                break;
            }
        }
        if (render) {
            this.rerender();
        }
    }
    _setSymbolModifier(char) {
        if (['^', '%'].indexOf(char) < 0) {
            return false;
        }
        const currentTextType = this.textType;
        const transitionType = SuiTextEditor.textTypeFromChar(char);
        this.textType = textRender_1.SuiInlineText.getTextTypeResult(currentTextType, transitionType);
        this._updateSymbolModifiers();
        return true;
    }
    parseBlocks() {
        let readGlyph = false;
        let curGlyph = '';
        let blockIx = 0; // so we skip modifier characters
        let i = 0;
        const params = textRender_1.SuiInlineText.defaults;
        params.context = this.context;
        params.startX = this.x;
        params.startY = this.y;
        params.scroller = this.scroller;
        this.svgText = new textRender_1.SuiInlineText(params);
        for (i = 0; i < this.text.length; ++i) {
            const char = this.text[i];
            const isSymbolModifier = this._setSymbolModifier(char);
            if (char === '@') {
                if (!readGlyph) {
                    readGlyph = true;
                    curGlyph = '';
                }
                else {
                    this._addGlyphAt(blockIx, curGlyph);
                    blockIx += 1;
                    readGlyph = false;
                }
            }
            else if (!isSymbolModifier) {
                if (readGlyph) {
                    curGlyph = curGlyph + char;
                }
                else {
                    const blockP = textRender_1.SuiInlineText.blockDefaults;
                    blockP.text = char;
                    blockP.textType = this.textType;
                    this.svgText.addTextBlockAt(blockIx, blockP);
                    blockIx += 1;
                }
            }
            this.empty = false;
        }
        this.textPos = blockIx;
        this.state = SuiTextEditor.States.RUNNING;
        this.rerender();
    }
    // ### getText
    // Get the text value that we persist
    getText() {
        if (this.svgText === null || this.svgText.blocks.length < 1) {
            return '';
        }
        let text = '';
        let textType = this.svgText.blocks[0].textType;
        this.svgText.blocks.forEach((block) => {
            if (block.textType !== textType) {
                text += SuiChordEditor.toTextTypeTransition(textType, block.textType);
                textType = block.textType;
            }
            if (block.symbolType === textRender_1.SuiInlineText.symbolTypes.GLYPH) {
                text += '@' + block.glyphCode + '@';
            }
            else {
                text += block.text;
            }
        });
        return text;
    }
    _addGlyphAt(ix, code) {
        var _a;
        if (this.selectionStart >= 0) {
            this.deleteSelections();
        }
        const blockP = textRender_1.SuiInlineText.blockDefaults;
        blockP.glyphCode = code;
        blockP.textType = this.textType;
        (_a = this.svgText) === null || _a === void 0 ? void 0 : _a.addGlyphBlockAt(ix, blockP);
        this.textPos += 1;
    }
    unrender() {
        var _a;
        if (this.svgText) {
            (_a = this.svgText.element) === null || _a === void 0 ? void 0 : _a.remove();
        }
    }
    evKey(evdata) {
        const _super = Object.create(null, {
            evKey: { get: () => super.evKey }
        });
        return __awaiter(this, void 0, void 0, function* () {
            let edited = false;
            if (this._setSymbolModifier(evdata.key)) {
                return true;
            }
            // Dialog gives us a specific glyph code
            if (evdata.key[0] === '@' && evdata.key.length > 2) {
                this.unrender();
                const glyph = evdata.key.substr(1, evdata.key.length - 2);
                this._addGlyphAt(this.textPos, glyph);
                this.rerender();
                edited = true;
            }
            else if (VF.ChordSymbol.glyphs[evdata.key[0]]) { // glyph shortcut like 'b'
                this.unrender();
                this._addGlyphAt(this.textPos, VF.ChordSymbol.glyphs[evdata.key[0]].code);
                this.rerender();
                edited = true;
            }
            else {
                // some ordinary key
                edited = yield _super.evKey.call(this, evdata);
            }
            if (this.svgText !== null && this.svgText.blocks.length > this.textPos && this.textPos >= 0) {
                this.textType = this.svgText.blocks[this.textPos].textType;
            }
            return edited;
        });
    }
    stopEditor() {
        var _a;
        this.state = SuiTextEditor.States.STOPPING;
        this.stopCursor();
        (_a = this.svgText) === null || _a === void 0 ? void 0 : _a.unrender();
    }
    // ### _markStopped
    // Indicate this editor session is done running
    _markStopped() {
        this.state = SuiTextEditor.States.STOPPED;
    }
}
exports.SuiChordEditor = SuiChordEditor;
class SuiDragSession {
    constructor(params) {
        this.dragging = false;
        this.outlineRect = null;
        this.textGroup = params.textGroup;
        this.pageMap = params.context;
        this.scroller = params.scroller;
        this.page = this.pageMap.getRendererFromModifier(this.textGroup);
        // create a temporary text object for dragging
        this.textObject = textRender_1.SuiTextBlock.fromTextGroup(this.textGroup, this.page, this.pageMap, this.scroller); // SuiTextBlock
        this.dragging = false;
        this.outlineBox = this.textObject.getLogicalBox();
    }
    _outlineBox() {
        const outlineStroke = SuiTextEditor.strokes['text-drag'];
        const x = this.outlineBox.x - this.page.box.x;
        const y = this.outlineBox.y - this.page.box.y;
        if (!this.outlineRect) {
            this.outlineRect = {
                context: this.page,
                box: svgHelpers_1.SvgHelpers.boxPoints(x, y + this.outlineBox.height, this.outlineBox.width, this.outlineBox.height),
                classes: 'text-drag',
                stroke: outlineStroke, scroll: this.scroller.scrollState, timeOff: 1000
            };
        }
        this.outlineRect.box = svgHelpers_1.SvgHelpers.boxPoints(x, y + this.outlineBox.height, this.outlineBox.width, this.outlineBox.height),
            svgHelpers_1.SvgHelpers.outlineRect(this.outlineRect);
    }
    unrender() {
        this.textGroup.elements.forEach((el) => {
            el.remove();
        });
        this.textGroup.elements = [];
        this.textObject.unrender();
    }
    scrolledClientBox(x, y) {
        return { x: x + this.scroller.scrollState.x, y: y + this.scroller.scrollState.y, width: 1, height: 1 };
    }
    checkBounds() {
        if (this.outlineBox.y < this.outlineBox.height) {
            this.outlineBox.y = this.outlineBox.height;
        }
        if (this.outlineBox.x < 0) {
            this.outlineBox.x = 0;
        }
        if (this.outlineBox.x > this.page.box.x + this.page.box.width - this.outlineBox.width) {
            this.outlineBox.x = this.page.box.x + this.page.box.width - this.outlineBox.width;
        }
        if (this.outlineBox.y > this.page.box.y + this.page.box.height) {
            this.outlineBox.y = this.page.box.y + this.page.box.height;
        }
    }
    startDrag(e) {
        const evBox = this.scrolledClientBox(e.clientX, e.clientY);
        const svgMouseBox = this.pageMap.clientToSvg(evBox);
        svgMouseBox.y -= this.outlineBox.height;
        if (layoutDebug_1.layoutDebug.mask & layoutDebug_1.layoutDebug.values['dragDebug']) {
            layoutDebug_1.layoutDebug.updateDragDebug(svgMouseBox, this.outlineBox, 'start');
        }
        if (!svgHelpers_1.SvgHelpers.doesBox1ContainBox2(this.outlineBox, svgMouseBox)) {
            return;
        }
        this.dragging = true;
        this.outlineBox = svgMouseBox;
        const currentBox = this.textObject.getLogicalBox();
        this.outlineBox.width = currentBox.width;
        this.outlineBox.height = currentBox.height;
        this.unrender();
        this.checkBounds();
        this._outlineBox();
    }
    mouseMove(e) {
        if (!this.dragging) {
            return;
        }
        const evBox = this.scrolledClientBox(e.clientX, e.clientY);
        const svgMouseBox = this.pageMap.clientToSvg(evBox);
        svgMouseBox.y -= this.outlineBox.height;
        this.outlineBox = svgHelpers_1.SvgHelpers.smoBox(svgMouseBox);
        const currentBox = this.textObject.getLogicalBox();
        this.outlineBox.width = currentBox.width;
        this.outlineBox.height = currentBox.height;
        this.checkBounds();
        this.textObject.offsetStartX(this.outlineBox.x - currentBox.x);
        this.textObject.offsetStartY(this.outlineBox.y - currentBox.y);
        this.textObject.render();
        if (layoutDebug_1.layoutDebug.mask & layoutDebug_1.layoutDebug.values['dragDebug']) {
            layoutDebug_1.layoutDebug.updateDragDebug(svgMouseBox, this.outlineBox, 'drag');
        }
        if (this.outlineRect) {
            svgHelpers_1.SvgHelpers.eraseOutline(this.outlineRect);
            this.outlineRect = null;
        }
        this._outlineBox();
    }
    endDrag() {
        var _a;
        // this.textObject.render();
        const newBox = this.textObject.getLogicalBox();
        const curBox = (_a = this.textGroup.logicalBox) !== null && _a !== void 0 ? _a : common_1.SvgBox.default;
        if (layoutDebug_1.layoutDebug.mask & layoutDebug_1.layoutDebug.values['dragDebug']) {
            layoutDebug_1.layoutDebug.updateDragDebug(curBox, newBox, 'end');
        }
        this.textGroup.offsetX(newBox.x - curBox.x);
        this.textGroup.offsetY(newBox.y - curBox.y + this.outlineBox.height);
        this.dragging = false;
        if (this.outlineRect) {
            svgHelpers_1.SvgHelpers.eraseOutline(this.outlineRect);
            this.outlineRect = null;
        }
    }
}
exports.SuiDragSession = SuiDragSession;
// ## SuiTextSession
// session for editing plain text
class SuiTextSession {
    constructor(params) {
        this.fontFamily = '';
        this.fontWeight = '';
        this.fontSize = 14;
        this.state = SuiTextEditor.States.PENDING_EDITOR;
        this.editor = null;
        this.cursorPromise = null;
        this.scroller = params.scroller;
        this.renderer = params.renderer;
        this.scoreText = params.scoreText;
        this.text = this.scoreText.text;
        this.x = params.x;
        this.y = params.y;
        this.textGroup = params.textGroup;
        this.renderer = params.renderer;
        // Create a text group if one was not a startup parameter
        if (!this.textGroup) {
            this.textGroup = new scoreText_1.SmoTextGroup(scoreText_1.SmoTextGroup.defaults);
        }
        // Create a scoreText if one was not a startup parameter, or
        // get it from the text group
        if (!this.scoreText) {
            if (this.textGroup && this.textGroup.textBlocks.length) {
                this.scoreText = this.textGroup.textBlocks[0].text;
            }
            else {
                const stDef = scoreText_1.SmoScoreText.defaults;
                stDef.x = this.x;
                stDef.y = this.y;
                this.scoreText = new scoreText_1.SmoScoreText(stDef);
                this.textGroup.addScoreText(this.scoreText, scoreText_1.SmoTextGroup.relativePositions.RIGHT);
            }
        }
        this.fontFamily = this.scoreText.fontInfo.family;
        this.fontWeight = this.scoreText.fontInfo.weight;
        this.fontSize = this.scoreText.fontInfo.size;
        this.text = this.scoreText.text;
    }
    static get States() {
        return { RUNNING: 1, STOPPING: 2, STOPPED: 4, PENDING_EDITOR: 8 };
    }
    // ### _isRefreshed
    // renderer has partially rendered text(promise condition)
    get _isRefreshed() {
        return this.renderer.dirty === false;
    }
    get isStopped() {
        return this.state === SuiTextEditor.States.STOPPED;
    }
    get isRunning() {
        return this.state === SuiTextEditor.States.RUNNING;
    }
    _markStopped() {
        this.state = SuiTextEditor.States.STOPPED;
    }
    // ### _isRendered
    // renderer has rendered text(promise condition)
    get _isRendered() {
        return this.renderer.passState === renderState_1.SuiRenderState.passStates.clean;
    }
    _removeScoreText() {
        const selector = '#' + this.scoreText.attrs.id;
        $(selector).remove();
    }
    // ### _startSessionForNote
    // Start the lyric session
    startSession() {
        const context = this.renderer.pageMap.getRenderer({ x: this.x, y: this.y });
        if (context) {
            this.editor = new SuiTextBlockEditor({
                x: this.x, y: this.y, scroller: this.scroller,
                context: context, text: this.scoreText.text, pageMap: this.renderer.pageMap
            });
            this.cursorPromise = this.editor.startCursorPromise();
            this.state = SuiTextEditor.States.RUNNING;
            this._removeScoreText();
        }
    }
    // ### _startSessionForNote
    // Stop the lyric session, return promise for done
    stopSession() {
        if (this.editor) {
            this.scoreText.text = this.editor.getText();
            this.scoreText.tryParseUnicode(); // convert unicode chars
            this.editor.stopEditor();
        }
        return promiseHelpers_1.PromiseHelpers.makePromise(() => this._isRendered, () => this._markStopped(), null, 100);
    }
    // ### evKey
    // Key handler (pass to editor)
    evKey(evdata) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.state !== SuiTextEditor.States.RUNNING || this.editor === null) {
                return false;
            }
            const rv = yield this.editor.evKey(evdata);
            if (rv) {
                this._removeScoreText();
            }
            return rv;
        });
    }
    handleMouseEvent(ev) {
        if (this.isRunning && this.editor !== null) {
            this.editor.handleMouseEvent(ev);
        }
    }
}
exports.SuiTextSession = SuiTextSession;
// ## SuiLyricSession
// Manage editor for lyrics, jupmping from note to note if asked
class SuiLyricSession {
    constructor(params) {
        this.note = null;
        this.lyric = null;
        this.text = '';
        this.editor = null;
        this.state = SuiTextEditor.States.PENDING_EDITOR;
        this.cursorPromise = null;
        this.score = params.score;
        this.renderer = params.renderer;
        this.scroller = params.scroller;
        this.view = params.view;
        this.parser = noteModifiers_1.SmoLyric.parsers.lyric;
        this.verse = params.verse;
        this.selector = params.selector;
        this.selection = selections_1.SmoSelection.noteFromSelector(this.score, this.selector);
        if (this.selection !== null) {
            this.note = this.selection.note;
        }
        this.originalText = '';
    }
    static get States() {
        return { RUNNING: 1, STOPPING: 2, STOPPED: 4, PENDING_EDITOR: 8 };
    }
    // ### _setLyricForNote
    // Get the text from the editor and update the lyric with it.
    _setLyricForNote() {
        this.lyric = null;
        if (!this.note) {
            return;
        }
        const lar = this.note.getLyricForVerse(this.verse, noteModifiers_1.SmoLyric.parsers.lyric);
        if (lar.length) {
            this.lyric = lar[0];
        }
        if (!this.lyric) {
            const scoreFont = this.score.fonts.find((fn) => fn.name === 'lyrics');
            const fontInfo = JSON.parse(JSON.stringify(scoreFont));
            const lyricD = noteModifiers_1.SmoLyric.defaults;
            lyricD._text = '';
            lyricD.verse = this.verse;
            lyricD.fontInfo = fontInfo;
            this.lyric = new noteModifiers_1.SmoLyric(lyricD);
        }
        this.text = this.lyric._text;
        this.originalText = this.text;
        // this.view.addOrUpdateLyric(this.selection.selector, this.lyric);
    }
    // ### _endLyricCondition
    // Lyric editor has stopped running (promise condition)
    get _endLyricCondition() {
        return this.editor !== null && this.editor.state !== SuiTextEditor.States.RUNNING;
    }
    // ### _endLyricCondition
    // renderer has partially rendered text(promise condition)
    get _isRefreshed() {
        return this.renderer.renderStateRendered;
    }
    // ### _isRendered
    // renderer has rendered text(promise condition)
    get _isRendered() {
        return this.renderer.renderStateClean;
    }
    get _pendingEditor() {
        return this.state !== SuiTextEditor.States.PENDING_EDITOR;
    }
    // ### _hideLyric
    // Hide the lyric so you only see the editor.
    _hideLyric() {
        if (this.lyric !== null && this.lyric.selector) {
            $(this.lyric.selector).remove();
        }
    }
    get isStopped() {
        return this.state === SuiTextEditor.States.STOPPED;
    }
    get isRunning() {
        return this.state === SuiTextEditor.States.RUNNING;
    }
    // ### _markStopped
    // Indicate this editor session is done running
    _markStopped() {
        this.state = SuiTextEditor.States.STOPPED;
    }
    // ### _startSessionForNote
    // Start the lyric editor for a note (current selected note)
    _startSessionForNote() {
        if (this.lyric === null || this.note === null || this.note.logicalBox === null) {
            return;
        }
        let startX = this.note.logicalBox.x;
        let startY = this.note.logicalBox.y + this.note.logicalBox.height + this.lyric.fontInfo.size;
        this.lyric.skipRender = true;
        const lyricRendered = this.lyric._text.length > 0;
        if (this.lyric.logicalBox !== null) {
            startX = this.lyric.logicalBox.x;
            startY = this.lyric.logicalBox.y + this.lyric.logicalBox.height;
        }
        const context = this.view.renderer.pageMap.getRenderer({ x: startX, y: startY });
        if (context) {
            this.editor = new SuiLyricEditor({
                context,
                lyric: this.lyric, x: startX, y: startY, scroller: this.scroller,
                text: this.lyric.getText(),
                pageMap: this.renderer.pageMap
            });
            this.state = SuiTextEditor.States.RUNNING;
            if (!lyricRendered && this.editor !== null && this.editor.svgText !== null) {
                const delta = 2 * this.editor.svgText.maxFontHeight(1.0) * (this.lyric.verse + 1);
                this.editor.svgText.offsetStartY(delta);
            }
            this.cursorPromise = this.editor.startCursorPromise();
            this._hideLyric();
        }
    }
    // ### _startSessionForNote
    // Start the lyric session
    startSession() {
        this._setLyricForNote();
        this._startSessionForNote();
        this.state = SuiTextEditor.States.RUNNING;
    }
    // ### _startSessionForNote
    // Stop the lyric session, return promise for done
    stopSession() {
        if (this.editor && !this._endLyricCondition) {
            this._updateLyricFromEditor();
            this.editor.stopEditor();
        }
        return promiseHelpers_1.PromiseHelpers.makePromise(() => this._isRendered, () => this._markStopped(), null, 100);
    }
    // ### _advanceSelection
    // Based on a skip character, move the editor forward/back one note.
    _advanceSelection(isShift) {
        const nextSelection = isShift ? selections_1.SmoSelection.lastNoteSelectionFromSelector(this.score, this.selector)
            : selections_1.SmoSelection.nextNoteSelectionFromSelector(this.score, this.selector);
        if (nextSelection) {
            this.selector = nextSelection.selector;
            this.selection = nextSelection;
            this.note = nextSelection.note;
            this._setLyricForNote();
            const conditionArray = [];
            this.state = SuiTextEditor.States.PENDING_EDITOR;
            conditionArray.push(promiseHelpers_1.PromiseHelpers.makePromiseObj(() => this._endLyricCondition, null, null, 100));
            conditionArray.push(promiseHelpers_1.PromiseHelpers.makePromiseObj(() => this._isRefreshed, () => this._startSessionForNote(), null, 100));
            promiseHelpers_1.PromiseHelpers.promiseChainThen(conditionArray);
        }
    }
    // ### advanceSelection
    // external interfoace to move to next/last note
    advanceSelection(isShift) {
        if (this.isRunning) {
            this._updateLyricFromEditor();
            this._advanceSelection(isShift);
        }
    }
    removeLyric() {
        if (this.selection && this.lyric) {
            this.view.removeLyric(this.selection.selector, this.lyric);
            this.lyric.skipRender = true;
            this.advanceSelection(false);
        }
    }
    // ### _updateLyricFromEditor
    // The editor is done running, so update the lyric now.
    _updateLyricFromEditor() {
        if (this.editor === null || this.lyric === null) {
            return;
        }
        const txt = this.editor.getText();
        this.lyric.setText(txt);
        this.lyric.skipRender = false;
        this.editor.stopEditor();
        if (!this.lyric.deleted && this.originalText !== txt && this.selection !== null) {
            this.view.addOrUpdateLyric(this.selection.selector, this.lyric);
        }
    }
    // ### evKey
    // Key handler (pass to editor)
    evKey(evdata) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.state !== SuiTextEditor.States.RUNNING) {
                return false;
            }
            if (evdata.key === '-' || evdata.key === ' ') {
                // skip
                const back = evdata.shiftKey && evdata.key === ' ';
                if (evdata.key === '-' && this.editor !== null) {
                    yield this.editor.evKey(evdata);
                }
                this._updateLyricFromEditor();
                this._advanceSelection(back);
            }
            else if (this.editor !== null) {
                yield this.editor.evKey(evdata);
                this._hideLyric();
            }
            return true;
        });
    }
    get textType() {
        if (this.isRunning && this.editor !== null) {
            return this.editor.textType;
        }
        return textRender_1.SuiInlineText.textTypes.normal;
    }
    set textType(type) {
        if (this.editor) {
            this.editor.textType = type;
        }
    }
    // ### handleMouseEvent
    // Mouse event (send to editor)
    handleMouseEvent(ev) {
        if (this.state !== SuiTextEditor.States.RUNNING || this.editor === null) {
            return;
        }
        this.editor.handleMouseEvent(ev);
    }
}
exports.SuiLyricSession = SuiLyricSession;
class SuiChordSession extends SuiLyricSession {
    constructor(params) {
        super(params);
        this.editor = null;
        this.parser = noteModifiers_1.SmoLyric.parsers.chord;
    }
    // ### evKey
    // Key handler (pass to editor)
    evKey(evdata) {
        return __awaiter(this, void 0, void 0, function* () {
            let edited = false;
            if (this.state !== SuiTextEditor.States.RUNNING) {
                return false;
            }
            if (evdata.code === 'Enter') {
                this._updateLyricFromEditor();
                this._advanceSelection(evdata.shiftKey);
                edited = true;
            }
            else if (this.editor !== null) {
                edited = yield this.editor.evKey(evdata);
            }
            this._hideLyric();
            return edited;
        });
    }
    // ### _setLyricForNote
    // Get the text from the editor and update the lyric with it.
    _setLyricForNote() {
        this.lyric = null;
        if (this.note === null) {
            return;
        }
        const lar = this.note.getLyricForVerse(this.verse, this.parser);
        if (lar.length) {
            this.lyric = lar[0];
        }
        if (!this.lyric) {
            const scoreFont = this.score.fonts.find((fn) => fn.name === 'chords');
            const fontInfo = JSON.parse(JSON.stringify(scoreFont));
            const ldef = noteModifiers_1.SmoLyric.defaults;
            ldef._text = '';
            ldef.verse = this.verse;
            ldef.parser = this.parser;
            ldef.fontInfo = fontInfo;
            this.lyric = new noteModifiers_1.SmoLyric(ldef);
            this.note.addLyric(this.lyric);
        }
        this.text = this.lyric._text;
    }
    // ### _startSessionForNote
    // Start the lyric editor for a note (current selected note)
    _startSessionForNote() {
        if (this.lyric === null) {
            return;
        }
        if (this.selection === null || this.note === null || this.note.logicalBox === null) {
            return;
        }
        let startX = this.note.logicalBox.x;
        let startY = this.selection.measure.svg.logicalBox.y;
        if (this.lyric.logicalBox !== null) {
            startX = this.lyric.logicalBox.x;
            startY = this.lyric.logicalBox.y + this.lyric.logicalBox.height;
        }
        this.selection.measure.svg.logicalBox.y + this.selection.measure.svg.logicalBox.height - 70;
        const context = this.renderer.pageMap.getRenderer({ x: startX, y: startY });
        if (context) {
            this.editor = new SuiChordEditor({
                context,
                lyric: this.lyric, x: startX, y: startY, scroller: this.scroller,
                text: this.lyric.getText(),
                pageMap: this.renderer.pageMap
            });
            this.state = SuiTextEditor.States.RUNNING;
            if (this.editor !== null && this.editor.svgText !== null) {
                const delta = (-1) * this.editor.svgText.maxFontHeight(1.0) * (this.lyric.verse + 1);
                this.editor.svgText.offsetStartY(delta);
            }
            this.cursorPromise = this.editor.startCursorPromise();
            this._hideLyric();
        }
    }
}
exports.SuiChordSession = SuiChordSession;


/***/ }),

/***/ "./src/render/sui/textRender.ts":
/*!**************************************!*\
  !*** ./src/render/sui/textRender.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SuiTextBlock = exports.SuiInlineText = void 0;
// [Smoosic](https://github.com/AaronDavidNewman/Smoosic)
// Copyright (c) Aaron David Newman 2021.
const svgHelpers_1 = __webpack_require__(/*! ./svgHelpers */ "./src/render/sui/svgHelpers.ts");
const scoreText_1 = __webpack_require__(/*! ../../smo/data/scoreText */ "./src/smo/data/scoreText.ts");
const textEdit_1 = __webpack_require__(/*! ./textEdit */ "./src/render/sui/textEdit.ts");
const common_1 = __webpack_require__(/*! ../../smo/data/common */ "./src/smo/data/common.ts");
const VF = eval('Vex.Flow');
// ## textRender.js
// Classes responsible for formatting and rendering text in SVG space.
/**
 * Inline text is a block of SVG text with the same font.  Each block can
 * contain either text or an svg (vex) glyph.  Each block in the text has its own
 * metrics so we can support inline svg text editors (cursor).
 * @category SuiRender
 */
class SuiInlineText {
    // ### constructor just creates an empty svg
    constructor(params) {
        this.width = -1;
        this.height = -1;
        this.blocks = [];
        this.updatedMetrics = false;
        this.artifacts = [];
        this.logicalBox = common_1.SvgBox.default;
        this.element = null;
        this.fontFamily = params.fontFamily;
        this.fontWeight = params.fontWeight;
        this.fontStyle = params.fontStyle;
        this.fontSize = params.fontSize;
        this.textFont = this.updateFontInfo();
        this.scroller = params.scroller;
        this.startX = params.startX;
        this.startY = params.startY;
        this.purpose = params.purpose;
        this.attrs = {
            id: VF.Element.newID(),
            type: 'SuiInlineText'
        };
        this.context = params.context;
        this.pageMap = params.pageMap;
    }
    static get textTypes() {
        return { normal: 0, superScript: 1, subScript: 2 };
    }
    static get symbolTypes() {
        return {
            GLYPH: 1,
            TEXT: 2,
            LINE: 3
        };
    }
    static get textPurposes() {
        return { render: 'sui-inline-render', edit: 'sui-inline-edit' };
    }
    // ### textTypeTransitions
    // Given a current text type and a type change request, what is the result
    // text type?  This truth table tells you.
    static get textTypeTransitions() {
        return [
            [1, 1, 0],
            [1, 0, 1],
            [1, 2, 2],
            [2, 2, 0],
            [2, 0, 2],
            [2, 1, 1],
            [0, 1, 1],
            [0, 0, 0],
            [0, 2, 2]
        ];
    }
    static getTextTypeResult(oldType, newType) {
        let rv = SuiInlineText.textTypes.normal;
        let i = 0;
        for (i = 0; i < SuiInlineText.textTypeTransitions.length; ++i) {
            const tt = SuiInlineText.textTypeTransitions[i];
            if (tt[0] === oldType && tt[1] === newType) {
                rv = tt[2];
                break;
            }
        }
        return rv;
    }
    static getTextTypeTransition(oldType, result) {
        let rv = SuiInlineText.textTypes.normal;
        let i = 0;
        for (i = 0; i < SuiInlineText.textTypeTransitions.length; ++i) {
            const tt = SuiInlineText.textTypeTransitions[i];
            if (tt[0] === oldType && tt[2] === result) {
                rv = tt[1];
                break;
            }
        }
        return rv;
    }
    static get superscriptOffset() {
        return VF.ChordSymbol.superscriptOffset / VF.ChordSymbol.engravingFontResolution;
    }
    static get subscriptOffset() {
        return VF.ChordSymbol.subscriptOffset / VF.ChordSymbol.engravingFontResolution;
    }
    get spacing() {
        return VF.ChordSymbol.spacingBetweenBlocks;
    }
    static get defaults() {
        return JSON.parse(JSON.stringify({
            blocks: [],
            fontFamily: 'Merriweather',
            fontSize: 14,
            startX: 100,
            startY: 100,
            fontWeight: 500,
            fontStyle: 'normal',
            scale: 1,
            activeBlock: -1,
            artifacts: [],
            purpose: 'render',
            classes: '',
            updatedMetrics: false
        }));
    }
    updateFontInfo() {
        return VF.TextFormatter.create({
            family: this.fontFamily,
            weight: this.fontWeight,
            size: this.fontSize,
            style: this.fontStyle
        });
    }
    static fromScoreText(scoreText, context, pageMap, scroller) {
        var _a;
        const params = {
            fontFamily: scoreText.fontInfo.family,
            fontWeight: scoreText.fontInfo.weight,
            fontStyle: (_a = scoreText.fontInfo.style) !== null && _a !== void 0 ? _a : 'normal',
            startX: scoreText.x, startY: scoreText.y,
            scroller,
            purpose: SuiInlineText.textPurposes.render,
            fontSize: scoreText.fontInfo.size, context,
            pageMap
        };
        const rv = new SuiInlineText(params);
        rv.attrs.id = scoreText.attrs.id;
        const blockParams = SuiInlineText.blockDefaults;
        blockParams.text = scoreText.text;
        rv.addTextBlockAt(0, blockParams);
        return rv;
    }
    static get blockDefaults() {
        return JSON.parse(JSON.stringify({
            symbolType: SuiInlineText.symbolTypes.TEXT,
            textType: SuiInlineText.textTypes.normal,
            highlighted: false,
            x: 0,
            y: 0,
            width: 0,
            height: 0,
            scale: 1.0,
            metrics: {},
            glyph: {},
            text: '',
            glyphCode: ''
        }));
    }
    // ### pointsToPixels
    // The font size is specified in points, convert to 'pixels' in the svg space
    get pointsToPixels() {
        return (this.textFont.size * 4) / 3;
    }
    offsetStartX(offset) {
        this.startX += offset;
        this.blocks.forEach((block) => {
            block.x += offset;
        });
    }
    offsetStartY(offset) {
        this.startY += offset;
        this.blocks.forEach((block) => {
            block.y += offset;
        });
    }
    maxFontHeight(scale) {
        return this.textFont.maxHeight * scale;
    }
    _glyphOffset(block) {
        return block.metrics.yOffset / VF.ChordSymbol.engravingFontResolution * this.pointsToPixels * block.scale;
    }
    /**
     * Based on the font metrics, compute the width of the strings and glyph that make up
     * this block
     */
    _calculateBlockIndex() {
        var curX = this.startX;
        var maxH = 0;
        let superXAlign = 0;
        let superXWidth = 0;
        let prevBlock = null;
        let i = 0;
        this.textFont.setFontSize(this.fontSize);
        this.blocks.forEach((block) => {
            // super/subscript
            const sp = this.isSuperscript(block);
            const sub = this.isSubcript(block);
            block.width = 0;
            block.height = 0;
            // coeff for sub/super script
            const subAdj = (sp || sub) ? VF.ChordSymbol.superSubRatio : 1.0;
            // offset for super/sub
            let subOffset = 0;
            if (sp) {
                subOffset = SuiInlineText.superscriptOffset * this.pointsToPixels;
            }
            else if (sub) {
                subOffset = SuiInlineText.subscriptOffset * this.pointsToPixels;
            }
            else {
                subOffset = 0;
            }
            block.x = curX;
            if (block.symbolType === SuiInlineText.symbolTypes.TEXT) {
                for (i = 0; i < block.text.length; ++i) {
                    const ch = block.text[i];
                    const glyph = this.textFont.getGlyphMetrics(ch);
                    block.width += ((glyph.advanceWidth) / this.textFont.resolution) * this.pointsToPixels * block.scale * subAdj;
                    const blockHeight = (glyph.ha / this.textFont.resolution) * this.pointsToPixels * block.scale;
                    block.height = block.height < blockHeight ? blockHeight : block.height;
                    block.y = this.startY + (subOffset * block.scale);
                }
            }
            else if (block.symbolType === SuiInlineText.symbolTypes.GLYPH) {
                block.width = (block.metrics.advanceWidth / VF.ChordSymbol.engravingFontResolution) * this.pointsToPixels * block.scale;
                block.height = (block.glyph.metrics.ha / VF.ChordSymbol.engravingFontResolution) * this.pointsToPixels * block.scale;
                block.x += block.metrics.leftSideBearing / VF.ChordSymbol.engravingFontResolution * this.pointsToPixels * block.scale;
                block.y = this.startY + this._glyphOffset(block) + subOffset;
            }
            // Line subscript up with super if the follow each other
            if (sp) {
                if (superXAlign === 0) {
                    superXAlign = block.x;
                }
            }
            else if (sub) {
                if (superXAlign > 0 && prevBlock !== null) {
                    block.x = superXAlign;
                    superXWidth = prevBlock.x + prevBlock.width;
                    curX = superXAlign;
                    superXAlign = 0;
                }
                else {
                    if (superXWidth > 0 && superXWidth < block.width + block.x) {
                        superXWidth = block.width + block.x;
                    }
                }
            }
            else if (superXWidth > 0) {
                block.x = superXWidth + VF.ChordSymbol.spacingBetweenBlocks;
                superXWidth = 0;
            }
            else {
                superXAlign = 0;
            }
            curX += block.width;
            maxH = block.height > maxH ? maxH : block.height;
            prevBlock = block;
        });
        this.width = curX - this.startX;
        this.height = maxH;
        this.updatedMetrics = true;
    }
    // ### getLogicalBox
    // return the calculated svg metrics.  In SMO parlance the
    // logical box is in SVG space, 'renderedBox' is in client space.
    getLogicalBox() {
        let rv = common_1.SvgBox.default;
        if (!this.updatedMetrics) {
            this._calculateBlockIndex();
        }
        const adjBox = (box) => {
            const nbox = svgHelpers_1.SvgHelpers.smoBox(box);
            nbox.y = nbox.y - nbox.height;
            return nbox;
        };
        this.blocks.forEach((block) => {
            if (!rv.x) {
                rv = svgHelpers_1.SvgHelpers.smoBox(adjBox(block));
            }
            else {
                rv = svgHelpers_1.SvgHelpers.unionRect(rv, adjBox(block));
            }
        });
        return rv;
    }
    // ### renderCursorAt
    // When we are using textLayout to render editor, create a cursor that adjusts it's size
    renderCursorAt(position, textType) {
        let adjH = 0;
        let adjY = 0;
        if (!this.updatedMetrics) {
            this._calculateBlockIndex();
        }
        const group = this.context.getContext().openGroup();
        group.id = 'inlineCursor';
        const h = this.fontSize;
        if (this.blocks.length <= position || position < 0) {
            const x = this.startX - this.context.box.x;
            const y = this.startY - this.context.box.y;
            svgHelpers_1.SvgHelpers.renderCursor(group, x, y - h, h);
            this.context.getContext().closeGroup();
            return;
        }
        const block = this.blocks[position];
        adjH = block.symbolType === SuiInlineText.symbolTypes.GLYPH ? h / 2 : h;
        // For glyph, add y adj back to the cursor since it's not a glyph
        adjY = block.symbolType === SuiInlineText.symbolTypes.GLYPH ? block.y - this._glyphOffset(block) :
            block.y;
        if (typeof (textType) === 'number' && textType !== SuiInlineText.textTypes.normal) {
            const ratio = textType !== SuiInlineText.textTypes.normal ? VF.ChordSymbol.superSubRatio : 1.0;
            adjH = adjH * ratio;
            if (textType !== block.textType) {
                if (textType === SuiInlineText.textTypes.superScript) {
                    adjY -= h / 2;
                }
                else {
                    adjY += h / 2;
                }
            }
        }
        const x = block.x + block.width - this.context.box.x;
        const y = adjY - (adjH * block.scale) - this.context.box.y;
        svgHelpers_1.SvgHelpers.renderCursor(group, x, y, adjH * block.scale);
        this.context.getContext().closeGroup();
    }
    removeCursor() {
        $('svg #inlineCursor').remove();
    }
    unrender() {
        var _a;
        (_a = this.element) === null || _a === void 0 ? void 0 : _a.remove();
        this.element = null;
    }
    getIntersectingBlocks(box) {
        if (!this.artifacts) {
            return [];
        }
        return svgHelpers_1.SvgHelpers.findIntersectingArtifact(box, this.artifacts);
    }
    _addBlockAt(position, block) {
        if (position >= this.blocks.length) {
            this.blocks.push(block);
        }
        else {
            this.blocks.splice(position, 0, block);
        }
    }
    removeBlockAt(position) {
        this.blocks.splice(position, 1);
        this.updatedMetrics = false;
    }
    // ### addTextBlockAt
    // Add a text block to the line of text.
    // params must contain at least:
    // {text:'xxx'}
    addTextBlockAt(position, params) {
        const block = JSON.parse(JSON.stringify(SuiInlineText.blockDefaults));
        Vex.Merge(block, params);
        block.text = params.text;
        block.scale = params.scale ? params.scale : 1;
        this._addBlockAt(position, block);
        this.updatedMetrics = false;
    }
    _getGlyphBlock(params) {
        const block = JSON.parse(JSON.stringify(SuiInlineText.blockDefaults));
        block.symbolType = SuiInlineText.symbolTypes.GLYPH;
        block.glyphCode = params.glyphCode;
        block.glyph = new VF.Glyph(block.glyphCode, this.fontSize);
        block.metrics = VF.ChordSymbol.getMetricForGlyph(block.glyphCode);
        block.scale = (params.textType && params.textType !== SuiInlineText.textTypes.normal) ?
            2 * VF.ChordSymbol.superSubRatio * block.metrics.scale : 2 * block.metrics.scale;
        block.textType = params.textType ? params.textType : SuiInlineText.textTypes.normal;
        block.glyph.scale = block.glyph.scale * block.scale;
        return block;
    }
    // ### addGlyphBlockAt
    // Add a glyph block to the line of text.  Params must include:
    // {glyphCode:'csymDiminished'}
    addGlyphBlockAt(position, params) {
        const block = this._getGlyphBlock(params);
        this._addBlockAt(position, block);
        this.updatedMetrics = false;
    }
    isSuperscript(block) {
        return block.textType === SuiInlineText.textTypes.superScript;
    }
    isSubcript(block) {
        return block.textType === SuiInlineText.textTypes.subScript;
    }
    getHighlight(block) {
        return block.highlighted;
    }
    setHighlight(block, value) {
        block.highlighted = value;
    }
    rescale(scale) {
        scale = (scale * this.fontSize < 6) ? 6 / this.fontSize : scale;
        scale = (scale * this.fontSize > 72) ? 72 / this.fontSize : scale;
        this.blocks.forEach((block) => {
            block.scale = scale;
        });
        this.updatedMetrics = false;
    }
    render() {
        if (!this.updatedMetrics) {
            this._calculateBlockIndex();
        }
        this.context.getContext().setFont({
            family: this.fontFamily, size: this.fontSize, weight: this.fontWeight, style: this.fontStyle
        });
        const group = this.context.getContext().openGroup();
        this.element = group;
        const mmClass = 'suiInlineText';
        let ix = 0;
        group.classList.add('vf-' + this.attrs.id);
        group.classList.add(this.attrs.id);
        group.classList.add(mmClass);
        group.classList.add(this.purpose);
        group.id = this.attrs.id;
        this.artifacts = [];
        this.blocks.forEach((block) => {
            var bg = this.context.getContext().openGroup();
            bg.classList.add('textblock-' + this.attrs.id + ix);
            this._drawBlock(block);
            this.context.getContext().closeGroup();
            const artifact = { block, box: common_1.SvgBox.default, index: 0 };
            artifact.box = this.context.offsetBbox(bg);
            artifact.index = ix;
            this.artifacts.push(artifact);
            ix += 1;
        });
        this.context.getContext().closeGroup();
        this.logicalBox = this.context.offsetBbox(group);
    }
    _drawBlock(block) {
        const sp = this.isSuperscript(block);
        const sub = this.isSubcript(block);
        const highlight = this.getHighlight(block);
        const y = block.y - this.context.box.y; // relative y into page
        if (highlight) {
            this.context.getContext().save();
            this.context.getContext().setFillStyle('#999');
        }
        // This is how svgcontext expects to get 'style'
        const weight = this.fontWeight;
        const style = this.fontStyle;
        const family = this.fontFamily;
        if (sp || sub) {
            this.context.getContext().save();
            this.context.getContext().setFont({
                family, size: this.fontSize * VF.ChordSymbol.superSubRatio * block.scale, weight, style
            });
        }
        else {
            this.context.getContext().setFont({ family, size: this.fontSize * block.scale, weight, style });
        }
        if (block.symbolType === SuiInlineText.symbolTypes.TEXT) {
            this.context.getContext().fillText(block.text, block.x, y);
        }
        else if (block.symbolType === SuiInlineText.symbolTypes.GLYPH) {
            block.glyph.render(this.context.getContext(), block.x, y);
        }
        if (sp || sub) {
            this.context.getContext().restore();
        }
        if (highlight) {
            this.context.getContext().restore();
        }
    }
    getText() {
        let rv = '';
        this.blocks.forEach((block) => {
            rv += block.text;
        });
        return rv;
    }
}
exports.SuiInlineText = SuiInlineText;
// ## SuiTextBlock
// A text block is a set of inline blocks that can be aligned/arranged in different ways.
class SuiTextBlock {
    constructor(params) {
        this.inlineBlocks = [];
        this.spacing = 0;
        this.currentBlockIndex = 0;
        this.outlineRect = null;
        this.currentBlock = null;
        this.logicalBox = common_1.SvgBox.default;
        this.inlineBlocks = [];
        this.scroller = params.scroller;
        this.spacing = params.spacing;
        this.context = params.context;
        this.skipRender = false; // used when editing the text
        if (params.blocks.length < 1) {
            const inlineParams = SuiInlineText.defaults;
            inlineParams.scroller = this.scroller;
            inlineParams.context = this.context;
            const inst = new SuiInlineText(inlineParams);
            params.blocks = [{ text: inst, position: scoreText_1.SmoTextGroup.relativePositions.RIGHT, activeText: true }];
        }
        params.blocks.forEach((block) => {
            if (!this.currentBlock) {
                this.currentBlock = block;
                this.currentBlockIndex = 0;
            }
            this.inlineBlocks.push(block);
        });
        this.justification = params.justification ? params.justification :
            scoreText_1.SmoTextGroup.justifications.LEFT;
    }
    static get relativePosition() {
        return {
            ABOVE: scoreText_1.SmoTextGroup.relativePositions.ABOVE,
            BELOW: scoreText_1.SmoTextGroup.relativePositions.BELOW,
            LEFT: scoreText_1.SmoTextGroup.relativePositions.LEFT,
            RIGHT: scoreText_1.SmoTextGroup.relativePositions.RIGHT
        };
    }
    render() {
        this.unrender();
        this.inlineBlocks.forEach((block) => {
            block.text.render();
            if (block.activeText) {
                this._outlineBox(this.context, block.text.logicalBox);
            }
            if (!this.logicalBox || this.logicalBox.width < 1) {
                this.logicalBox = svgHelpers_1.SvgHelpers.smoBox(block.text.logicalBox);
            }
            else {
                this.logicalBox = svgHelpers_1.SvgHelpers.unionRect(this.logicalBox, block.text.logicalBox);
            }
        });
    }
    _outlineBox(context, box) {
        const outlineStroke = textEdit_1.SuiTextEditor.strokes['text-highlight'];
        if (!this.outlineRect) {
            this.outlineRect = {
                context, box, classes: 'text-drag',
                stroke: outlineStroke, scroll: this.scroller.scrollState, timeOff: 1000
            };
        }
        this.outlineRect.box = box;
        this.outlineRect.context = context;
        this.outlineRect.scroll = this.scroller.scrollState;
        svgHelpers_1.SvgHelpers.outlineRect(this.outlineRect);
    }
    offsetStartX(offset) {
        this.inlineBlocks.forEach((block) => {
            block.text.offsetStartX(offset);
        });
    }
    offsetStartY(offset) {
        this.inlineBlocks.forEach((block) => {
            block.text.offsetStartY(offset);
        });
    }
    rescale(scale) {
        this.inlineBlocks.forEach((block) => {
            block.text.rescale(scale);
        });
    }
    get x() {
        return this.getLogicalBox().x;
    }
    get y() {
        return this.getLogicalBox().y;
    }
    maxFontHeight(scale) {
        let rv = 0;
        this.inlineBlocks.forEach((block) => {
            const blockHeight = block.text.maxFontHeight(scale);
            rv = blockHeight > rv ? blockHeight : rv;
        });
        return rv;
    }
    static blockFromScoreText(scoreText, context, pageMap, position, scroller) {
        var inlineText = SuiInlineText.fromScoreText(scoreText, context, pageMap, scroller);
        return { text: inlineText, position, activeText: true };
    }
    getLogicalBox() {
        return this._calculateBoundingClientRect();
    }
    _calculateBoundingClientRect() {
        let rv = common_1.SvgBox.default;
        this.inlineBlocks.forEach((block) => {
            if (!rv.x) {
                rv = block.text.getLogicalBox();
            }
            else {
                rv = svgHelpers_1.SvgHelpers.unionRect(rv, block.text.getLogicalBox());
            }
        });
        rv.y = rv.y - rv.height;
        return rv;
    }
    static fromTextGroup(tg, context, pageMap, scroller) {
        const blocks = [];
        // Create an inline block for each ScoreText
        tg.textBlocks.forEach((stBlock) => {
            const st = stBlock.text;
            const newText = SuiTextBlock.blockFromScoreText(st, context, pageMap, stBlock.position, scroller);
            newText.activeText = stBlock.activeText;
            blocks.push(newText);
        });
        const rv = new SuiTextBlock({
            blocks, justification: tg.justification, spacing: tg.spacing, context, scroller,
            skipRender: false
        });
        rv._justify();
        return rv;
    }
    unrender() {
        this.inlineBlocks.forEach((block) => {
            if (block.text.element) {
                block.text.element.remove();
                block.text.element = null;
            }
        });
    }
    // ### _justify
    // justify the blocks according to the group justify policy and the
    // relative position of the blocks
    _justify() {
        let hIx = 0;
        let left = 0;
        let minx = 0;
        let maxx = 0;
        let lvl = 0;
        let maxwidth = 0;
        let runningWidth = 0;
        let runningHeight = 0;
        if (!this.inlineBlocks.length) {
            return;
        }
        minx = this.inlineBlocks[0].text.startX;
        // We justify relative to first block x/y.
        const initialX = this.inlineBlocks[0].text.startX;
        const initialY = this.inlineBlocks[0].text.startY;
        const vert = {};
        this.inlineBlocks.forEach((inlineBlock) => {
            const block = inlineBlock.text;
            const blockBox = block.getLogicalBox();
            // If this is a horizontal positioning, reset to first blokc position
            //
            if (hIx > 0) {
                block.startX = initialX;
                block.startY = initialY;
            }
            minx = block.startX < minx ? block.startX : minx;
            maxx = (block.startX + blockBox.width) > maxx ? block.startX + blockBox.width : maxx;
            lvl = inlineBlock.position === scoreText_1.SmoTextGroup.relativePositions.ABOVE ? lvl + 1 : lvl;
            lvl = inlineBlock.position === scoreText_1.SmoTextGroup.relativePositions.BELOW ? lvl - 1 : lvl;
            if (inlineBlock.position === scoreText_1.SmoTextGroup.relativePositions.RIGHT) {
                block.startX += runningWidth;
                if (hIx > 0) {
                    block.startX += this.spacing;
                }
            }
            if (inlineBlock.position === scoreText_1.SmoTextGroup.relativePositions.LEFT) {
                if (hIx > 0) {
                    block.startX = minx - blockBox.width;
                    minx = block.startX;
                    block.startX -= this.spacing;
                }
            }
            if (inlineBlock.position === scoreText_1.SmoTextGroup.relativePositions.BELOW) {
                block.startY += runningHeight;
                if (hIx > 0) {
                    block.startY += this.spacing;
                }
            }
            if (inlineBlock.position === scoreText_1.SmoTextGroup.relativePositions.ABOVE) {
                block.startY -= runningHeight;
                if (hIx > 0) {
                    block.startY -= this.spacing;
                }
            }
            if (!vert[lvl]) {
                vert[lvl] = {
                    blocks: [block], minx: block.startX, maxx: block.startX + blockBox.width,
                    width: blockBox.width
                };
                maxwidth = vert[lvl].width;
                vert[lvl].blocks = [block];
                vert[lvl].minx = block.startX;
                vert[lvl].maxx = block.startX + blockBox.width;
                maxwidth = vert[lvl].width = blockBox.width;
            }
            else {
                vert[lvl].blocks.push(block);
                vert[lvl].minx = vert[lvl].minx < block.startX ? vert[lvl].minx : block.startX;
                vert[lvl].maxx = vert[lvl].maxx > (block.startX + blockBox.width) ?
                    vert[lvl].maxx : (block.startX + blockBox.width);
                vert[lvl].width += blockBox.width;
                maxwidth = maxwidth > vert[lvl].width ? maxwidth : vert[lvl].width;
            }
            runningWidth += blockBox.width;
            runningHeight += blockBox.height;
            hIx += 1;
            block.updatedMetrics = false;
        });
        const levels = Object.keys(vert);
        // Horizontal justify the vertical blocks
        levels.forEach((level) => {
            const vobj = vert[level];
            if (this.justification === scoreText_1.SmoTextGroup.justifications.LEFT) {
                left = minx - vobj.minx;
            }
            else if (this.justification === scoreText_1.SmoTextGroup.justifications.RIGHT) {
                left = maxx - vobj.maxx;
            }
            else {
                left = (maxwidth / 2) - (vobj.width / 2);
                left += minx - vobj.minx;
            }
            vobj.blocks.forEach((block) => {
                block.offsetStartX(left);
            });
        });
    }
}
exports.SuiTextBlock = SuiTextBlock;


/***/ }),

/***/ "./src/render/sui/tracker.ts":
/*!***********************************!*\
  !*** ./src/render/sui/tracker.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SuiTracker = void 0;
// [Smoosic](https://github.com/AaronDavidNewman/Smoosic)
// Copyright (c) Aaron David Newman 2021.
const mapper_1 = __webpack_require__(/*! ./mapper */ "./src/render/sui/mapper.ts");
const svgHelpers_1 = __webpack_require__(/*! ./svgHelpers */ "./src/render/sui/svgHelpers.ts");
const selections_1 = __webpack_require__(/*! ../../smo/xform/selections */ "./src/smo/xform/selections.ts");
const serializationHelpers_1 = __webpack_require__(/*! ../../common/serializationHelpers */ "./src/common/serializationHelpers.js");
const oscillator_1 = __webpack_require__(/*! ../audio/oscillator */ "./src/render/audio/oscillator.ts");
const common_1 = __webpack_require__(/*! ../../smo/data/common */ "./src/smo/data/common.ts");
/**
 * SuiTracker
 A tracker maps the UI elements to the logical elements ,and allows the user to
 move through the score and make selections, for navigation and editing.
 */
class SuiTracker extends mapper_1.SuiMapper {
    constructor(renderer, scroller, pasteBuffer) {
        super(renderer, scroller, pasteBuffer);
        this.idleTimer = Date.now();
        this.musicCursorGlyph = null;
    }
    static get strokes() {
        return {
            suggestion: {
                strokeName: 'suggestion',
                stroke: '#fc9',
                strokeWidth: 3,
                strokeDasharray: '4,1',
                fill: 'none',
                opacity: 1.0
            },
            selection: {
                strokeName: 'selection',
                stroke: '#99d',
                strokeWidth: 3,
                strokeDasharray: 2,
                fill: 'none',
                opacity: 1.0
            },
            staffModifier: {
                strokeName: 'staffModifier',
                stroke: '#933',
                strokeWidth: 3,
                fill: 'none',
                strokeDasharray: 0,
                opacity: 1.0
            }, pitchSelection: {
                strokeName: 'pitchSelection',
                stroke: '#933',
                strokeWidth: 3,
                fill: 'none',
                strokeDasharray: 0,
                opacity: 1.0
            }
        };
    }
    // ### renderElement
    // the element the score is rendered on
    get renderElement() {
        return this.renderer.renderElement;
    }
    get score() {
        return this.renderer.score;
    }
    getIdleTime() {
        return this.idleTimer;
    }
    getSelectedModifier() {
        if (this.modifierSelections.length) {
            return this.modifierSelections[0];
        }
        return null;
    }
    getSelectedModifiers() {
        return this.modifierSelections;
    }
    static serializeEvent(evKey) {
        if (!evKey) {
            return [];
        }
        const rv = {};
        serializationHelpers_1.smoSerialize.serializedMerge(['type', 'shiftKey', 'ctrlKey', 'altKey', 'key', 'keyCode'], evKey, rv);
        return rv;
    }
    advanceModifierSelection(score, keyEv) {
        if (!keyEv) {
            return;
        }
        this.idleTimer = Date.now();
        const offset = keyEv.key === 'ArrowLeft' ? -1 : 1;
        this.modifierIndex = this.modifierIndex + offset;
        this.modifierIndex = (this.modifierIndex === -2 && this.localModifiers.length) ?
            this.localModifiers.length - 1 : this.modifierIndex;
        if (this.modifierIndex >= this.localModifiers.length || this.modifierIndex < 0) {
            this.modifierIndex = -1;
            this.modifierSelections = [];
            return;
        }
        const local = this.localModifiers[this.modifierIndex];
        const box = svgHelpers_1.SvgHelpers.smoBox(local.box);
        this.modifierSelections = [{ index: 0, box, modifier: local.modifier, selection: local.selection }];
        this._highlightModifier();
    }
    static stringifyBox(box) {
        return '{x:' + box.x + ',y:' + box.y + ',width:' + box.width + ',height:' + box.height + '}';
    }
    // ### _getOffsetSelection
    // Get the selector that is the offset of the first existing selection
    _getOffsetSelection(offset) {
        if (!this.score) {
            return selections_1.SmoSelector.default;
        }
        let testSelection = this.getExtremeSelection(Math.sign(offset));
        const scopyTick = JSON.parse(JSON.stringify(testSelection.selector));
        const scopyMeasure = JSON.parse(JSON.stringify(testSelection.selector));
        scopyTick.tick += offset;
        scopyMeasure.measure += offset;
        const targetMeasure = selections_1.SmoSelection.measureSelection(this.score, testSelection.selector.staff, scopyMeasure.measure);
        if (targetMeasure && targetMeasure.measure && targetMeasure.measure.voices.length <= scopyMeasure.voice) {
            scopyMeasure.voice = 0;
        }
        if (targetMeasure && targetMeasure.measure) {
            scopyMeasure.tick = (offset < 0) ? targetMeasure.measure.voices[scopyMeasure.voice].notes.length - 1 : 0;
        }
        if (testSelection.measure.voices.length > scopyTick.voice &&
            testSelection.measure.voices[scopyTick.voice].notes.length > scopyTick.tick && scopyTick.tick >= 0) {
            if (testSelection.selector.voice !== testSelection.measure.getActiveVoice()) {
                scopyTick.voice = testSelection.measure.getActiveVoice();
                testSelection = this._getClosestTick(scopyTick);
                return testSelection.selector;
            }
            return scopyTick;
        }
        else if (targetMeasure &&
            scopyMeasure.measure < testSelection.staff.measures.length && scopyMeasure.measure >= 0) {
            return scopyMeasure;
        }
        return testSelection.selector;
    }
    getSelectedGraceNotes() {
        if (!this.modifierSelections.length) {
            return [];
        }
        const ff = this.modifierSelections.filter((mm) => { var _a, _b; return ((_b = (_a = mm.modifier) === null || _a === void 0 ? void 0 : _a.attrs) === null || _b === void 0 ? void 0 : _b.type) === 'SmoGraceNote'; });
        return ff;
    }
    isGraceNoteSelected() {
        if (this.modifierSelections.length) {
            const ff = this.modifierSelections.findIndex((mm) => mm.modifier.attrs.type === 'SmoGraceNote');
            return ff >= 0;
        }
        return false;
    }
    _growGraceNoteSelections(offset) {
        var _a;
        this.idleTimer = Date.now();
        const far = this.modifierSelections.filter((mm) => mm.modifier.attrs.type === 'SmoGraceNote');
        if (!far.length) {
            return;
        }
        const ix = (offset < 0) ? 0 : far.length - 1;
        const sel = far[ix];
        const left = this.localModifiers.filter((mt) => {
            var _a, _b;
            return ((_b = (_a = mt.modifier) === null || _a === void 0 ? void 0 : _a.attrs) === null || _b === void 0 ? void 0 : _b.type) === 'SmoGraceNote' && sel.selection && mt.selection &&
                selections_1.SmoSelector.sameNote(mt.selection.selector, sel.selection.selector);
        });
        if (ix + offset < 0 || ix + offset >= left.length) {
            return;
        }
        const leftSel = left[ix + offset];
        if (!leftSel) {
            console.warn('bad selector in _growGraceNoteSelections');
        }
        leftSel.box = (_a = leftSel.box) !== null && _a !== void 0 ? _a : common_1.SvgBox.default;
        this.modifierSelections.push(leftSel);
        this._highlightModifier();
    }
    get autoPlay() {
        return this.renderer.score ? this.renderer.score.preferences.autoPlay : false;
    }
    growSelectionRight() {
        this._growSelectionRight(false);
    }
    _growSelectionRight(skipPlay) {
        this.idleTimer = Date.now();
        if (this.isGraceNoteSelected()) {
            this._growGraceNoteSelections(1);
            return 0;
        }
        const nselect = this._getOffsetSelection(1);
        // already selected
        const artifact = this._getClosestTick(nselect);
        if (!artifact) {
            return 0;
        }
        if (this.selections.find((sel) => selections_1.SmoSelector.sameNote(sel.selector, artifact.selector))) {
            return 0;
        }
        if (!this.mapping && this.autoPlay && skipPlay === false && this.score) {
            oscillator_1.SuiOscillator.playSelectionNow(artifact, this.score, 1);
        }
        this.selections.push(artifact);
        this.deferHighlight();
        this._createLocalModifiersList();
        return artifact.note.tickCount;
    }
    moveHome(score, evKey) {
        var _a, _b;
        this.idleTimer = Date.now();
        const ls = this.selections[0].staff;
        if (evKey.ctrlKey) {
            const mm = ls.measures[0];
            const homeSel = this._getClosestTick({ staff: ls.staffId,
                measure: 0, voice: mm.getActiveVoice(), tick: 0, pitches: [] });
            if (evKey.shiftKey) {
                this._selectBetweenSelections(score, this.selections[0], homeSel);
            }
            else {
                this.selections = [homeSel];
                this.deferHighlight();
                this._createLocalModifiersList();
                if (homeSel.measure.svg.logicalBox) {
                    this.scroller.scrollVisibleBox(homeSel.measure.svg.logicalBox);
                }
            }
        }
        else {
            const system = this.selections[0].measure.svg.lineIndex;
            const lm = ls.measures.find((mm) => mm.svg.lineIndex === system && mm.measureNumber.systemIndex === 0);
            const mm = lm;
            const homeSel = this._getClosestTick({ staff: ls.staffId,
                measure: mm.measureNumber.measureIndex, voice: mm.getActiveVoice(),
                tick: 0, pitches: [] });
            if (evKey.shiftKey) {
                this._selectBetweenSelections(score, this.selections[0], homeSel);
            }
            else if ((_b = (_a = homeSel === null || homeSel === void 0 ? void 0 : homeSel.measure) === null || _a === void 0 ? void 0 : _a.svg) === null || _b === void 0 ? void 0 : _b.logicalBox) {
                this.selections = [homeSel];
                this.scroller.scrollVisibleBox(homeSel.measure.svg.logicalBox);
                this.deferHighlight();
                this._createLocalModifiersList();
            }
        }
    }
    moveEnd(score, evKey) {
        this.idleTimer = Date.now();
        const ls = this.selections[0].staff;
        if (evKey.ctrlKey) {
            const lm = ls.measures[ls.measures.length - 1];
            const voiceIx = lm.getActiveVoice();
            const voice = lm.voices[voiceIx];
            const endSel = this._getClosestTick({ staff: ls.staffId,
                measure: ls.measures.length - 1, voice: voiceIx, tick: voice.notes.length - 1, pitches: [] });
            if (evKey.shiftKey) {
                this._selectBetweenSelections(score, this.selections[0], endSel);
            }
            else {
                this.selections = [endSel];
                this.deferHighlight();
                this._createLocalModifiersList();
                if (endSel.measure.svg.logicalBox) {
                    this.scroller.scrollVisibleBox(endSel.measure.svg.logicalBox);
                }
            }
        }
        else {
            const system = this.selections[0].measure.svg.lineIndex;
            // find the largest measure index on this staff in this system
            const measures = ls.measures.filter((mm) => mm.svg.lineIndex === system);
            const lm = measures.reduce((a, b) => b.measureNumber.measureIndex > a.measureNumber.measureIndex ? b : a);
            const ticks = lm.voices[lm.getActiveVoice()].notes.length;
            const endSel = this._getClosestTick({ staff: ls.staffId,
                measure: lm.measureNumber.measureIndex, voice: lm.getActiveVoice(), tick: ticks - 1, pitches: [] });
            if (evKey.shiftKey) {
                this._selectBetweenSelections(score, this.selections[0], endSel);
            }
            else {
                this.selections = [endSel];
                this.deferHighlight();
                this._createLocalModifiersList();
                if (endSel.measure.svg.logicalBox) {
                    this.scroller.scrollVisibleBox(endSel.measure.svg.logicalBox);
                }
            }
        }
    }
    growSelectionRightMeasure() {
        let toSelect = 0;
        const rightmost = this.getExtremeSelection(1);
        const ticksLeft = rightmost.measure.voices[rightmost.measure.activeVoice]
            .notes.length - rightmost.selector.tick;
        if (ticksLeft === 0) {
            if (rightmost.selector.measure < rightmost.staff.measures.length) {
                const mix = rightmost.selector.measure + 1;
                rightmost.staff.measures[mix].setActiveVoice(rightmost.selector.voice);
                toSelect = rightmost.staff.measures[mix]
                    .voices[rightmost.staff.measures[mix].activeVoice].notes.length;
            }
        }
        else {
            toSelect = ticksLeft;
        }
        while (toSelect > 0) {
            this._growSelectionRight(true);
            toSelect -= 1;
        }
    }
    growSelectionLeft() {
        if (this.isGraceNoteSelected()) {
            this._growGraceNoteSelections(-1);
            return 0;
        }
        this.idleTimer = Date.now();
        const nselect = this._getOffsetSelection(-1);
        // already selected
        const artifact = this._getClosestTick(nselect);
        if (!artifact) {
            return 0;
        }
        if (this.selections.find((sel) => selections_1.SmoSelector.sameNote(sel.selector, artifact.selector))) {
            return 0;
        }
        artifact.measure.setActiveVoice(nselect.voice);
        this.selections.push(artifact);
        if (this.autoPlay && this.score) {
            oscillator_1.SuiOscillator.playSelectionNow(artifact, this.score, 1);
        }
        this.deferHighlight();
        this._createLocalModifiersList();
        return artifact.note.tickCount;
    }
    // if we are being moved right programmatically, avoid playing the selected note.
    moveSelectionRight(score, evKey, skipPlay) {
        if (this.selections.length === 0 || this.score === null) {
            return;
        }
        // const original = JSON.parse(JSON.stringify(this.getExtremeSelection(-1).selector));
        const nselect = this._getOffsetSelection(1);
        // skip any measures that are not displayed due to rest or repetition
        const mselect = selections_1.SmoSelection.measureSelection(this.score, nselect.staff, nselect.measure);
        if (mselect === null || mselect === void 0 ? void 0 : mselect.measure.svg.multimeasureLength) {
            nselect.measure += mselect === null || mselect === void 0 ? void 0 : mselect.measure.svg.multimeasureLength;
        }
        if (mselect) {
            mselect.measure.setActiveVoice(nselect.voice);
        }
        this._replaceSelection(nselect, skipPlay);
    }
    moveSelectionLeft() {
        if (this.selections.length === 0 || this.score === null) {
            return;
        }
        const nselect = this._getOffsetSelection(-1);
        // Skip multimeasure rests in parts
        const mselect = selections_1.SmoSelection.measureSelection(this.score, nselect.staff, nselect.measure);
        while (nselect.measure > 0 && mselect && (mselect.measure.svg.hideMultimeasure || mselect.measure.svg.multimeasureLength > 0)) {
            nselect.measure -= 1;
        }
        if (mselect) {
            mselect.measure.setActiveVoice(nselect.voice);
        }
        this._replaceSelection(nselect, false);
    }
    moveSelectionLeftMeasure() {
        this._moveSelectionMeasure(-1);
    }
    moveSelectionRightMeasure() {
        this._moveSelectionMeasure(1);
    }
    _moveSelectionMeasure(offset) {
        const selection = this.getExtremeSelection(Math.sign(offset));
        this.idleTimer = Date.now();
        const selector = JSON.parse(JSON.stringify(selection.selector));
        selector.measure += offset;
        selector.tick = 0;
        const selObj = this._getClosestTick(selector);
        if (selObj) {
            this.selections = [selObj];
        }
        this.deferHighlight();
        this._createLocalModifiersList();
    }
    _moveStaffOffset(offset) {
        if (this.selections.length === 0 || this.score === null) {
            return;
        }
        this.idleTimer = Date.now();
        const nselector = JSON.parse(JSON.stringify(this.selections[0].selector));
        nselector.staff = this.score.incrementActiveStaff(offset);
        this.selections = [this._getClosestTick(nselector)];
        this.deferHighlight();
        this._createLocalModifiersList();
    }
    removePitchSelection() {
        if (this.outlines['pitchSelection']) {
            if (this.outlines['pitchSelection'].element) {
                this.outlines['pitchSelection'].element.remove();
            }
            delete this.outlines['pitchSelection'];
        }
    }
    // ### _moveSelectionPitch
    // Suggest a specific pitch in a chord, so we can transpose just the one note vs. the whole chord.
    _moveSelectionPitch(index) {
        this.idleTimer = Date.now();
        if (!this.selections.length) {
            return;
        }
        const sel = this.selections[0];
        const note = sel.note;
        if (note.pitches.length < 2) {
            this.pitchIndex = -1;
            this.removePitchSelection();
            return;
        }
        this.pitchIndex = (this.pitchIndex + index) % note.pitches.length;
        sel.selector.pitches = [];
        sel.selector.pitches.push(this.pitchIndex);
        this._highlightPitchSelection(note, this.pitchIndex);
    }
    moveSelectionPitchUp() {
        this._moveSelectionPitch(1);
    }
    moveSelectionPitchDown() {
        if (!this.selections.length) {
            return;
        }
        this._moveSelectionPitch(this.selections[0].note.pitches.length - 1);
    }
    moveSelectionUp() {
        this._moveStaffOffset(-1);
    }
    moveSelectionDown() {
        this._moveStaffOffset(1);
    }
    containsArtifact() {
        return this.selections.length > 0;
    }
    _replaceSelection(nselector, skipPlay) {
        if (this.score === null) {
            return;
        }
        var artifact = selections_1.SmoSelection.noteSelection(this.score, nselector.staff, nselector.measure, nselector.voice, nselector.tick);
        if (!artifact) {
            artifact = selections_1.SmoSelection.noteSelection(this.score, nselector.staff, nselector.measure, 0, nselector.tick);
        }
        if (!artifact) {
            artifact = selections_1.SmoSelection.noteSelection(this.score, nselector.staff, nselector.measure, 0, 0);
        }
        if (!artifact) {
            // disappeared - default to start
            artifact = selections_1.SmoSelection.noteSelection(this.score, 0, 0, 0, 0);
        }
        if (!skipPlay && this.autoPlay && artifact) {
            oscillator_1.SuiOscillator.playSelectionNow(artifact, this.score, 1);
        }
        if (!artifact) {
            return;
        }
        artifact.measure.setActiveVoice(nselector.voice);
        // clear modifier selections
        this.clearModifierSelections();
        this.score.setActiveStaff(nselector.staff);
        const mapKey = Object.keys(this.measureNoteMap).find((k) => artifact && selections_1.SmoSelector.sameNote(this.measureNoteMap[k].selector, artifact.selector));
        if (!mapKey) {
            return;
        }
        const mapped = this.measureNoteMap[mapKey];
        // If this is a new selection, remove pitch-specific and replace with note-specific
        if (!nselector.pitches || nselector.pitches.length === 0) {
            this.pitchIndex = -1;
        }
        this.selections = [mapped];
        this.deferHighlight();
        this._createLocalModifiersList();
    }
    getFirstMeasureOfSelection() {
        if (this.selections.length) {
            return this.selections[0].measure;
        }
        return null;
    }
    // ## measureIterator
    // Description: iterate over the any measures that are part of the selection
    getSelectedMeasures() {
        const set = [];
        const rv = [];
        if (!this.score) {
            return [];
        }
        this.selections.forEach((sel) => {
            const measure = selections_1.SmoSelection.measureSelection(this.score, sel.selector.staff, sel.selector.measure);
            if (measure) {
                const ix = measure.selector.measure;
                if (set.indexOf(ix) === -1) {
                    set.push(ix);
                    rv.push(measure);
                }
            }
        });
        return rv;
    }
    _addSelection(selection) {
        const ar = this.selections.filter((sel) => selections_1.SmoSelector.neq(sel.selector, selection.selector));
        if (this.autoPlay && this.score) {
            oscillator_1.SuiOscillator.playSelectionNow(selection, this.score, 1);
        }
        ar.push(selection);
        this.selections = ar;
    }
    _selectFromToInStaff(score, sel1, sel2) {
        const selections = selections_1.SmoSelection.innerSelections(score, sel1.selector, sel2.selector);
        /* .filter((ff) =>
          ff.selector.voice === sel1.measure.activeVoice
        ); */
        this.selections = [];
        // Get the actual selections from our map, since the client bounding boxes are already computed
        selections.forEach((sel) => {
            const key = selections_1.SmoSelector.getNoteKey(sel.selector);
            sel.measure.setActiveVoice(sel.selector.voice);
            // Skip measures that are not rendered because they are part of a multi-rest
            if (this.measureNoteMap && this.measureNoteMap[key]) {
                this.selections.push(this.measureNoteMap[key]);
            }
        });
        if (this.selections.length === 0) {
            this.selections = [sel1];
        }
        this.idleTimer = Date.now();
    }
    _selectBetweenSelections(score, s1, s2) {
        const min = selections_1.SmoSelector.gt(s1.selector, s2.selector) ? s2 : s1;
        const max = selections_1.SmoSelector.lt(min.selector, s2.selector) ? s2 : s1;
        this._selectFromToInStaff(score, min, max);
        this._createLocalModifiersList();
        this.highlightQueue.selectionCount = this.selections.length;
        this.deferHighlight();
    }
    selectSuggestion(score, ev) {
        if (!this.suggestion || !this.suggestion.measure || this.score === null) {
            return;
        }
        this.idleTimer = Date.now();
        if (this.modifierSuggestion) {
            this.modifierIndex = -1;
            this.modifierSelections = [this.modifierSuggestion];
            this.modifierSuggestion = null;
            this.createLocalModifiersFromModifierTabs(this.modifierSelections);
            // If we selected due to a mouse click, move the selection to the
            // selected modifier
            this._highlightModifier();
            return;
        }
        else if (ev.type === 'click') {
            this.clearModifierSelections(); // if we click on a non-modifier, clear the
            // modifier selections
        }
        if (ev.shiftKey) {
            const sel1 = this.getExtremeSelection(-1);
            if (sel1.selector.staff === this.suggestion.selector.staff) {
                this._selectBetweenSelections(score, sel1, this.suggestion);
                return;
            }
        }
        if (ev.ctrlKey) {
            this._addSelection(this.suggestion);
            this._createLocalModifiersList();
            this.deferHighlight();
            return;
        }
        if (this.autoPlay) {
            oscillator_1.SuiOscillator.playSelectionNow(this.suggestion, this.score, 1);
        }
        const preselected = this.selections[0] ?
            selections_1.SmoSelector.sameNote(this.suggestion.selector, this.selections[0].selector) && this.selections.length === 1 : false;
        if (this.selections.length === 0) {
            this.selections.push(this.suggestion);
        }
        const note = this.selections[0].note;
        if (preselected && note.pitches.length > 1) {
            this.pitchIndex = (this.pitchIndex + 1) % note.pitches.length;
            this.selections[0].selector.pitches = [this.pitchIndex];
        }
        else {
            const selection = selections_1.SmoSelection.noteFromSelector(this.score, this.suggestion.selector);
            if (selection) {
                selection.box = JSON.parse(JSON.stringify(this.suggestion.box));
                selection.scrollBox = JSON.parse(JSON.stringify(this.suggestion.scrollBox));
                this.selections = [selection];
            }
        }
        if (preselected && this.modifierSelections.length) {
            const mods = this.modifierSelections.filter((mm) => mm.selection && selections_1.SmoSelector.sameNote(mm.selection.selector, this.selections[0].selector));
            if (mods.length) {
                const modToAdd = mods[0];
                if (!modToAdd) {
                    console.warn('bad modifier selection in selectSuggestion 2');
                }
                this.modifierSelections[0] = modToAdd;
                this.modifierIndex = mods[0].index;
                this._highlightModifier();
                return;
            }
        }
        this.score.setActiveStaff(this.selections[0].selector.staff);
        this.deferHighlight();
        this._createLocalModifiersList();
    }
    _setModifierAsSuggestion(artifact) {
        if (!artifact.box) {
            return;
        }
        this.modifierSuggestion = artifact;
        this._drawRect(artifact.box, 'suggestion');
    }
    _setArtifactAsSuggestion(artifact) {
        let sameSel = null;
        let i = 0;
        for (i = 0; i < this.selections.length; ++i) {
            const ss = this.selections[i];
            if (ss && selections_1.SmoSelector.sameNote(ss.selector, artifact.selector)) {
                sameSel = ss;
                break;
            }
        }
        if (sameSel || !artifact.box) {
            return;
        }
        this.modifierSuggestion = null;
        this.suggestion = artifact;
        this._drawRect(artifact.box, 'suggestion');
    }
    _highlightModifier() {
        let box = null;
        if (!this.modifierSelections.length) {
            return;
        }
        this.modifierSelections.forEach((artifact) => {
            var _a;
            if (box === null) {
                box = (_a = artifact.modifier.logicalBox) !== null && _a !== void 0 ? _a : null;
            }
            else {
                box = svgHelpers_1.SvgHelpers.unionRect(box, svgHelpers_1.SvgHelpers.smoBox(artifact.modifier.logicalBox));
            }
        });
        if (box === null) {
            return;
        }
        this._drawRect(box, 'staffModifier');
    }
    _highlightPitchSelection(note, index) {
        const noteDiv = $(this.renderElement).find('#' + note.renderId);
        const heads = noteDiv.find('.vf-notehead');
        if (!heads.length) {
            return;
        }
        const headEl = heads[index];
        const pageContext = this.renderer.pageMap.getRendererFromModifier(note);
        $(pageContext.svg).find('.vf-pitchSelection').remove();
        const box = pageContext.offsetBbox(headEl);
        this._drawRect(box, 'pitchSelection');
    }
    _highlightActiveVoice(selection) {
        let i = 0;
        const selector = selection.selector;
        for (i = 1; i <= 4; ++i) {
            const cl = 'v' + i.toString() + '-active';
            $('body').removeClass(cl);
        }
        const c2 = 'v' + (selector.voice + 1).toString() + '-active';
        $('body').addClass(c2);
    }
    // The user has just switched voices, select the active voice
    selectActiveVoice() {
        const selection = this.selections[0];
        const selector = JSON.parse(JSON.stringify(selection.selector));
        selector.voice = selection.measure.activeVoice;
        this.selections = [this._getClosestTick(selector)];
        this.deferHighlight();
    }
    highlightSelection() {
        let i = 0;
        let prevSel = null;
        let curBox = common_1.SvgBox.default;
        this.idleTimer = Date.now();
        const grace = this.getSelectedGraceNotes();
        // If this is not a note with grace notes, logically unselect the grace notes
        if (grace && grace.length && grace[0].selection && this.selections.length) {
            if (!selections_1.SmoSelector.sameNote(grace[0].selection.selector, this.selections[0].selector)) {
                this.clearModifierSelections();
            }
            else {
                this._highlightModifier();
                return;
            }
        }
        // If there is a race condition with a change, avoid referencing null note
        if (!this.selections[0].note) {
            return;
        }
        const note = this.selections[0].note;
        if (this.pitchIndex >= 0 && this.selections.length === 1 &&
            this.pitchIndex < note.pitches.length) {
            this._highlightPitchSelection(note, this.pitchIndex);
            this._highlightActiveVoice(this.selections[0]);
            return;
        }
        this.removePitchSelection();
        this.pitchIndex = -1;
        if (this.selections.length === 1 && note.logicalBox) {
            this._drawRect(note.logicalBox, 'selection');
            this._highlightActiveVoice(this.selections[0]);
            return;
        }
        const sorted = this.selections.sort((a, b) => selections_1.SmoSelector.gt(a.selector, b.selector) ? 1 : -1);
        prevSel = sorted[0];
        // rendered yet?
        if (!prevSel || !prevSel.box) {
            return;
        }
        curBox = svgHelpers_1.SvgHelpers.smoBox(prevSel.box);
        const boxes = [];
        for (i = 1; i < sorted.length; ++i) {
            const sel = sorted[i];
            if (!sel.box || !prevSel.box) {
                continue;
            }
            // const ydiff = Math.abs(prevSel.box.y - sel.box.y);
            if (sel.selector.staff === prevSel.selector.staff && sel.measure.svg.lineIndex === prevSel.measure.svg.lineIndex) {
                curBox = svgHelpers_1.SvgHelpers.unionRect(curBox, sel.box);
            }
            else if (curBox) {
                boxes.push(curBox);
                curBox = svgHelpers_1.SvgHelpers.smoBox(sel.box);
            }
            this._highlightActiveVoice(sel);
            prevSel = sel;
        }
        boxes.push(curBox);
        if (this.modifierSelections.length) {
            boxes.push(this.modifierSelections[0].box);
        }
        this._drawRect(boxes, 'selection');
    }
    /**
     * Boxes are divided up into lines/systems already.  But we need
     * to put the correct box on the correct page.
     * @param boxes
     */
    drawSelectionRects(boxes) {
        const keys = Object.keys(this.selectionRects);
        // erase any old selections
        keys.forEach((key) => {
            const oon = this.selectionRects[parseInt(key)];
            oon.forEach((outline) => {
                if (outline.element) {
                    outline.element.remove();
                    outline.element = undefined;
                }
            });
        });
        this.selectionRects = {};
        // Create an OutlineInfo for each page
        const pages = [];
        const stroke = SuiTracker.strokes['selection'];
        boxes.forEach((box) => {
            let testBox = svgHelpers_1.SvgHelpers.smoBox(box);
            let context = this.renderer.pageMap.getRenderer(testBox);
            testBox.y -= context.box.y;
            if (!this.selectionRects[context.pageNumber]) {
                this.selectionRects[context.pageNumber] = [];
                pages.push(context.pageNumber);
            }
            this.selectionRects[context.pageNumber].push({
                context: context, box: testBox, classes: '',
                stroke, scroll: this.scroller.scrollState,
                timeOff: 0
            });
        });
        pages.forEach((pageNo) => {
            const outlineInfos = this.selectionRects[pageNo];
            outlineInfos.forEach((info) => {
                svgHelpers_1.SvgHelpers.outlineRect(info);
            });
        });
    }
    _drawRect(pBox, strokeName) {
        const stroke = SuiTracker.strokes[strokeName];
        const boxes = Array.isArray(pBox) ? pBox : [pBox];
        if (strokeName === 'selection') {
            this.drawSelectionRects(boxes);
            return;
        }
        boxes.forEach((box) => {
            let testBox = svgHelpers_1.SvgHelpers.smoBox(box);
            let context = this.renderer.pageMap.getRenderer(testBox);
            const timeOff = strokeName === 'suggestion' ? 1000 : 0;
            if (context) {
                testBox.y -= context.box.y;
                if (!this.outlines[strokeName]) {
                    this.outlines[strokeName] = {
                        context: context, box: testBox, classes: '',
                        stroke, scroll: this.scroller.scrollState,
                        timeOff
                    };
                }
                this.outlines[strokeName].box = testBox;
                this.outlines[strokeName].context = context;
                svgHelpers_1.SvgHelpers.outlineRect(this.outlines[strokeName]);
            }
        });
    }
}
exports.SuiTracker = SuiTracker;


/***/ }),

/***/ "./src/render/vex/glyphDimensions.ts":
/*!*******************************************!*\
  !*** ./src/render/vex/glyphDimensions.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.vexGlyph = void 0;
// [Smoosic](https://github.com/AaronDavidNewman/Smoosic)
// Copyright (c) Aaron David Newman 2021.
const measureModifiers_1 = __webpack_require__(/*! ../../smo/data/measureModifiers */ "./src/smo/data/measureModifiers.ts");
const music_1 = __webpack_require__(/*! ../../smo/data/music */ "./src/smo/data/music.ts");
const VF = eval('Vex.Flow');
class vexGlyph {
    // ### glyphPixels
    // Used to convert vex glyph sizes to pixels for computation.
    // Vex glyph font size (points) is 38, convert to pixels (96 / 72)
    // and divide by glyph resolution
    static get glyphPixels() {
        return 96 * (38 / (VF.Glyph.MUSIC_FONT_STACK[0].getResolution() * 72));
    }
    static width(smoGlyph) {
        if (smoGlyph.vexGlyph) {
            const vf = VF.Glyph.MUSIC_FONT_STACK[0].getGlyphs()[smoGlyph.vexGlyph];
            return (vf.x_max - vf.x_min) * vexGlyph.glyphPixels;
        }
        return smoGlyph.width;
    }
    static accidental(a) {
        return vexGlyph.accidentals[a];
    }
    static barWidth(b) {
        const str = measureModifiers_1.SmoBarline.barlineString(b);
        const cc = vexGlyph.dimensions[str];
        return cc.width + cc.spacingRight;
    }
    static accidentalWidth(accidental) {
        return vexGlyph.width(vexGlyph.accidentals[accidental]);
    }
    static get accidentals() {
        return {
            'b': vexGlyph.dimensions.flat,
            '#': vexGlyph.dimensions.sharp,
            'bb': vexGlyph.dimensions.doubleFlat,
            '##': vexGlyph.dimensions.doubleSharp,
            'n': vexGlyph.dimensions.natural
        };
    }
    static get tempo() {
        return vexGlyph.dimensions.tempo;
    }
    static keySignatureLength(key) {
        return music_1.SmoMusic.getSharpsInKeySignature(key) * vexGlyph.width(vexGlyph.dimensions.sharp) +
            music_1.SmoMusic.getFlatsInKeySignature(key) * vexGlyph.width(vexGlyph.dimensions.flat) +
            vexGlyph.dimensions.keySignature.spacingRight;
    }
    static get timeSignature() {
        return vexGlyph.dimensions.timeSignature;
    }
    static get dot() {
        return vexGlyph.dimensions.dot;
    }
    static get tupletBeam() {
        return vexGlyph.dimensions.tupletBeam;
    }
    static get stem() {
        return vexGlyph.dimensions.stem;
    }
    static get flag() {
        return vexGlyph.dimensions.flag;
    }
    static clef(c) {
        const key = c.toLowerCase() + 'Clef';
        if (!vexGlyph.dimensions[key]) {
            return vexGlyph.dimensions.tenorClef;
        }
        if (vexGlyph.dimensions[key].vexGlyph) {
            const width = vexGlyph.width(vexGlyph.dimensions[key]);
            return {
                width,
                height: 68.32,
                yTop: 3,
                yBottom: 3,
                spacingRight: 10,
                vexGlyph: 'gClef'
            };
        }
        return vexGlyph.dimensions[key];
    }
    static get dimensions() {
        return {
            tupletBeam: {
                width: 5,
                height: 6,
                yTop: 0,
                yBottom: 0,
                spacingRight: 5,
                vexGlyph: null
            },
            singleBar: {
                width: 1,
                height: 41,
                yTop: 0,
                yBottom: 0,
                spacingRight: 1,
                vexGlyph: null
            },
            endBar: {
                width: 5.22,
                height: 40.99,
                yTop: 0,
                yBottom: 0,
                spacingRight: 5,
                vexGlyph: null
            },
            doubleBar: {
                width: 3.22,
                height: 40.99,
                yTop: 0,
                yBottom: 0,
                spacingRight: 0,
                vexGlyph: null
            },
            endRepeat: {
                width: 6,
                height: 40.99,
                yTop: 0,
                yBottom: 0,
                spacingRight: 0,
                vexGlyph: null
            },
            startRepeat: {
                width: 6,
                height: 40.99,
                yTop: 0,
                yBottom: 0,
                spacingRight: 5,
                vexGlyph: null
            },
            noteHead: {
                width: 15.3,
                height: 10.48,
                yTop: 0,
                yBottom: 0,
                spacingRight: 10.71,
                vexGlyph: 'noteheadBlack'
            },
            dot: {
                width: 15,
                height: 5,
                yTop: 0,
                yBottom: 0,
                spacingRight: 10,
                vexGlyph: 'augmentationDot'
            },
            // want to add extra space just for clef.
            trebleClef: {
                width: 35,
                height: 68.32,
                yTop: 3,
                yBottom: 3,
                spacingRight: 5,
                vexGlyph: 'gClef'
            },
            bassClef: {
                width: 36,
                height: 31.88,
                yTop: 0,
                yBottom: 0,
                spacingRight: 5,
                vexGlyph: 'fClef'
            },
            altoClef: {
                width: 31.5,
                yTop: 0,
                yBottom: 0,
                height: 85.5,
                spacingRight: 5,
                vexGlyph: 'cClef'
            },
            tenorClef: {
                width: 31.5,
                yTop: 10,
                yBottom: 0,
                height: 41,
                spacingRight: 5,
                vexGlyph: 'cClef'
            },
            timeSignature: {
                width: 22.36,
                height: 85,
                yTop: 0,
                yBottom: 0,
                spacingRight: 2,
                vexGlyph: 'timeSig4'
            },
            tempo: {
                width: 10,
                height: 37,
                yTop: 37,
                yBottom: 0,
                spacingRight: 0,
                vexGlyph: null
            },
            flat: {
                width: 15,
                height: 23.55,
                yTop: 0,
                yBottom: 0,
                spacingRight: 0,
                vexGlyph: 'accidentalFlat'
            },
            keySignature: {
                width: 0,
                height: 85.5,
                yTop: 0,
                yBottom: 0,
                spacingRight: 5,
                vexGlyph: null
            },
            sharp: {
                width: 17,
                height: 62,
                yTop: 0,
                yBottom: 0,
                spacingRight: 0,
                vexGlyph: 'accidentalSharp',
            },
            natural: {
                width: 15,
                height: 53.35,
                yTop: 0,
                yBottom: 0,
                spacingRight: 0,
                vexGlyph: 'accidentalNatural',
            },
            doubleSharp: {
                height: 10.04,
                width: 21.63,
                yTop: 0,
                yBottom: 0,
                spacingRight: 0,
                vexGlyph: 'accidentalDoubleSharp'
            },
            doubleFlat: {
                width: 13.79,
                height: 49.65,
                yTop: 0,
                yBottom: 0,
                spacingRight: 0,
                vexGlyph: 'accidentalDoubleFlat'
            }, stem: {
                width: 1,
                height: 35,
                yTop: 0,
                yBottom: 0,
                spacingRight: 0,
                vexGlyph: null
            }, flag: {
                width: 10,
                height: 35,
                yTop: 0,
                yBottom: 0,
                spacingRight: 0,
                vexGlyph: 'flag8thUp' // use for width measurements all flags
            }
        };
    }
}
exports.vexGlyph = vexGlyph;


/***/ }),

/***/ "./src/render/vex/vxMeasure.ts":
/*!*************************************!*\
  !*** ./src/render/vex/vxMeasure.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.VxMeasure = void 0;
// [Smoosic](https://github.com/AaronDavidNewman/Smoosic)
// Copyright (c) Aaron David Newman 2021.
// ## Description:
// This file calls the vexflow routines that actually render a
// measure of music.  If multiple measures are justified in a
// column, the rendering is deferred until all the measures have been
// preformatted.
const note_1 = __webpack_require__(/*! ../../smo/data/note */ "./src/smo/data/note.ts");
const music_1 = __webpack_require__(/*! ../../smo/data/music */ "./src/smo/data/music.ts");
const layoutDebug_1 = __webpack_require__(/*! ../sui/layoutDebug */ "./src/render/sui/layoutDebug.ts");
const measureModifiers_1 = __webpack_require__(/*! ../../smo/data/measureModifiers */ "./src/smo/data/measureModifiers.ts");
const ssp_serif_metrics_1 = __webpack_require__(/*! ../../styles/font_metrics/ssp-serif-metrics */ "./src/styles/font_metrics/ssp-serif-metrics.js");
const ssp_sans_metrics_1 = __webpack_require__(/*! ../../styles/font_metrics/ssp-sans-metrics */ "./src/styles/font_metrics/ssp-sans-metrics.js");
const noteModifiers_1 = __webpack_require__(/*! ../../smo/data/noteModifiers */ "./src/smo/data/noteModifiers.ts");
const svgHelpers_1 = __webpack_require__(/*! ../sui/svgHelpers */ "./src/render/sui/svgHelpers.ts");
const common_1 = __webpack_require__(/*! ../../smo/data/common */ "./src/smo/data/common.ts");
const VF = eval('Vex.Flow');
/**
 * This is the interface for VexFlow library that actually does the engraving.
 * @category SuiRender
 */
class VxMeasure {
    constructor(context, selection, printing, softmax) {
        this.rendered = false;
        this.noteToVexMap = {};
        this.beamToVexMap = {};
        this.tupletToVexMap = {};
        this.multimeasureRest = null;
        this.vexNotes = [];
        this.vexBeamGroups = [];
        this.vexTuplets = [];
        this.tickmapObject = null;
        this.voiceAr = [];
        this.formatter = null;
        this.allCues = false;
        this.modifiersToBox = [];
        this.collisionMap = {};
        this.dbgLeftX = 0;
        this.dbgWidth = 0;
        this.context = context;
        this.rendered = false;
        this.selection = selection;
        this.smoMeasure = this.selection.measure;
        this.printing = printing;
        this.allCues = selection.staff.partInfo.displayCues;
        this.tupletToVexMap = {};
        this.vexNotes = [];
        this.vexBeamGroups = [];
        this.vexBeamGroups = [];
        this.beamToVexMap = {};
        this.softmax = softmax;
    }
    static get fillStyle() {
        return '#000';
    }
    /**
     * decide whether to force stem direction for multi-voice, or use the default.
     * @param vxParams - params that go do the VX stem constructor
     * @param voiceIx
     * @param flagState
     * @todo use x position of ticks in other voices, pitch of note, to avoid collisions
     */
    applyStemDirection(vxParams, voiceIx, flagState) {
        if (this.smoMeasure.voices.length === 1 && flagState === note_1.SmoNote.flagStates.auto) {
            vxParams.auto_stem = true;
        }
        else if (flagState !== note_1.SmoNote.flagStates.auto) {
            vxParams.stem_direction = flagState === note_1.SmoNote.flagStates.up ? 1 : -1;
        }
        else if (voiceIx % 2) {
            vxParams.stem_direction = -1;
        }
        else {
            vxParams.stem_direction = 1;
        }
    }
    isWholeRest() {
        return (this.smoMeasure.voices.length === 1 &&
            this.smoMeasure.voices[0].notes.length === 1 &&
            this.smoMeasure.voices[0].notes[0].isRest());
    }
    // We add microtones to the notes, without regard really to how they interact
    _createMicrotones(smoNote, vexNote) {
        const tones = smoNote.getMicrotones();
        tones.forEach((tone) => {
            const acc = new VF.Accidental(tone.toVex);
            vexNote.addModifier(acc, tone.pitchIndex);
        });
    }
    /**
     * Create accidentals based on the active key and previous accidentals in this voice
     * @param smoNote
     * @param vexNote
     * @param tickIndex
     * @param voiceIx
     * @returns
     */
    _createAccidentals(smoNote, vexNote, tickIndex, voiceIx) {
        let i = 0;
        if (smoNote.noteType === '/') {
            return;
        }
        smoNote.accidentalsRendered = [];
        for (i = 0; i < smoNote.pitches.length && this.tickmapObject !== null; ++i) {
            const pitch = smoNote.pitches[i];
            const keyAccidental = music_1.SmoMusic.getAccidentalForKeySignature(pitch, this.smoMeasure.keySignature);
            const duration = this.tickmapObject.tickmaps[voiceIx].durationMap[tickIndex];
            const pitchOctave = pitch.letter + '-' + pitch.octave;
            const accidentals = this.tickmapObject.accidentalArray.filter((ar) => ar.duration < duration && ar.pitches[pitchOctave]);
            const acLen = accidentals.length;
            const declared = acLen > 0 ?
                accidentals[acLen - 1].pitches[pitchOctave].pitch.accidental : keyAccidental;
            if ((declared !== pitch.accidental
                || pitch.cautionary) && smoNote.noteType === 'n') {
                const acc = new VF.Accidental(pitch.accidental);
                if (pitch.cautionary) {
                    acc.setAsCautionary();
                }
                smoNote.accidentalsRendered.push(pitch.accidental);
                vexNote.addModifier(acc, i);
            }
            else {
                smoNote.accidentalsRendered.push('');
            }
        }
        for (i = 0; i < smoNote.dots; ++i) {
            for (var j = 0; j < smoNote.pitches.length; ++j) {
                if (!this.isWholeRest()) {
                    vexNote.addModifier(new VF.Dot(), j);
                }
            }
        }
        this._createMicrotones(smoNote, vexNote);
    }
    _createJazzOrnaments(smoNote, vexNote) {
        const o = smoNote.getJazzOrnaments();
        o.forEach((ll) => {
            const mod = new VF.Ornament(ll.toVex());
            vexNote.addModifier(mod, 0);
        });
    }
    _createOrnaments(smoNote, vexNote) {
        const o = smoNote.getOrnaments();
        o.forEach((ll) => {
            const mod = new VF.Ornament(ll.ornament);
            if (ll.offset === noteModifiers_1.SmoOrnament.offsets.after) {
                mod.setDelayed(true);
            }
            vexNote.addModifier(mod, 0);
        });
    }
    _addLyricAnnotationToNote(vexNote, lyric) {
        let classString = 'lyric lyric-' + lyric.verse;
        let text = lyric.getText();
        if (lyric.skipRender) {
            return;
        }
        if (!text.length && lyric.isHyphenated()) {
            text = '-';
        }
        // no text, no hyphen, don't add it.
        if (!text.length) {
            return;
        }
        const vexL = new VF.Annotation(text); // .setReportWidth(lyric.adjustNoteWidth);
        vexL.setAttribute('id', lyric.attrs.id); //
        // If we adjusted this note for the lyric, adjust the lyric as well.
        vexL.setFont(lyric.fontInfo.family, lyric.fontInfo.size, lyric.fontInfo.weight);
        vexL.setVerticalJustification(VF.Annotation.VerticalJustify.BOTTOM);
        vexNote.addModifier(vexL);
        if (lyric.isHyphenated()) {
            classString += ' lyric-hyphen';
        }
        vexL.addClass(classString);
    }
    _addChordChangeToNote(vexNote, lyric) {
        const cs = new VF.ChordSymbol();
        cs.setAttribute('id', lyric.attrs.id);
        const blocks = lyric.getVexChordBlocks();
        blocks.forEach((block) => {
            if (block.glyph) {
                cs.addGlyph(block.glyph, block);
            }
            else {
                cs.addGlyphOrText(block.text, block);
            }
        });
        cs.setFont(lyric.fontInfo.family, lyric.fontInfo.size).setReportWidth(lyric.adjustNoteWidth);
        vexNote.addModifier(cs, 0);
        const classString = 'chord chord-' + lyric.verse;
        cs.addClass(classString);
    }
    _createLyric(smoNote, vexNote) {
        const lyrics = smoNote.getTrueLyrics();
        if (smoNote.noteType !== '/') {
            lyrics.forEach((bll) => {
                const ll = bll;
                this._addLyricAnnotationToNote(vexNote, ll);
            });
        }
        const chords = smoNote.getChords();
        chords.forEach((chord) => {
            this._addChordChangeToNote(vexNote, chord);
        });
    }
    _createGraceNotes(smoNote, vexNote) {
        let i = 0;
        const gar = smoNote.getGraceNotes();
        var toBeam = true;
        if (gar && gar.length) {
            const group = [];
            gar.forEach((g) => {
                const gr = new VF.GraceNote(g.toVexGraceNote());
                gr.setAttribute('id', g.attrs.id);
                for (i = 0; i < g.pitches.length; ++i) {
                    const pitch = g.pitches[i];
                    if (!pitch.accidental) {
                        console.warn('no accidental in grace note');
                    }
                    if (pitch.accidental && pitch.accidental !== 'n' || pitch.cautionary) {
                        const accidental = new VF.Accidental(pitch.accidental);
                        if (pitch.cautionary) {
                            accidental.setAsCautionary();
                        }
                        gr.addModifier(accidental, i);
                    }
                }
                if (g.tickCount() >= 4096) {
                    toBeam = false;
                }
                gr.addClass('grace-note'); // note: this doesn't work :(
                g.renderId = gr.attrs.id;
                group.push(gr);
            });
            const grace = new VF.GraceNoteGroup(group);
            if (toBeam) {
                grace.beamNotes();
            }
            vexNote.addModifier(grace, 0);
        }
    }
    createCollisionTickmap() {
        let i = 0;
        let j = 0;
        if (!this.tickmapObject) {
            return;
        }
        for (i = 0; i < this.smoMeasure.voices.length; ++i) {
            const tm = this.tickmapObject.tickmaps[i];
            for (j = 0; j < tm.durationMap.length; ++j) {
                if (typeof (this.collisionMap[tm.durationMap[j]]) === 'undefined') {
                    this.collisionMap[tm.durationMap[j]] = [];
                }
                this.collisionMap[tm.durationMap[j]].push(this.smoMeasure.voices[i].notes[j]);
            }
        }
    }
    isCollision(voiceIx, tickIx) {
        let i = 0;
        let j = 0;
        let k = 0;
        let staffLines = [];
        if (!this.tickmapObject) {
            return false;
        }
        const tick = this.tickmapObject.tickmaps[voiceIx].durationMap[tickIx];
        // Just one note, no collision
        if (this.collisionMap[tick].length < 2) {
            return false;
        }
        for (i = 0; i < this.collisionMap[tick].length; ++i) {
            const note = this.collisionMap[tick][i];
            for (j = 0; j < note.pitches.length; ++j) {
                const clef = (0, common_1.IsClef)(note.clef) ? note.clef : 'treble';
                const pitch = note.pitches[j];
                const curLine = music_1.SmoMusic.pitchToStaffLine(clef, pitch);
                for (k = 0; k < staffLines.length; ++k) {
                    if (Math.abs(curLine - staffLines[k]) < 1) {
                        return true;
                    }
                }
                staffLines.push(curLine);
            }
        }
        return false;
    }
    /**
     * convert a smoNote into a vxNote so it can be rasterized
     * @param smoNote
     * @param tickIndex - used to calculate accidental
     * @param voiceIx
     * @returns
     */
    _createVexNote(smoNote, tickIndex, voiceIx) {
        let vexNote = {};
        let timestamp = new Date().valueOf();
        // If this is a tuplet, we only get the duration so the appropriate stem
        // can be rendered.  Vex calculates the actual ticks later when the tuplet is made
        var duration = smoNote.isTuplet ?
            music_1.SmoMusic.closestVexDuration(smoNote.tickCount) :
            music_1.SmoMusic.ticksToDuration[smoNote.tickCount];
        if (typeof (duration) === 'undefined') {
            console.warn('bad duration in measure ' + this.smoMeasure.measureNumber.measureIndex);
            duration = '8';
        }
        // transpose for instrument-specific keys
        const noteHead = smoNote.isRest() ? 'r' : smoNote.noteHead;
        const keys = music_1.SmoMusic.smoPitchesToVexKeys(smoNote.pitches, 0, noteHead);
        const noteParams = {
            clef: smoNote.clef,
            keys,
            duration: duration + smoNote.noteType,
            glyph_font_scale: VxMeasure.musicFontScaleNote
        };
        if (smoNote.noteType === '/') {
            vexNote = new VF.GlyphNote(new VF.Glyph('repeatBarSlash', 40), { duration });
            smoNote.renderId = 'vf-' + vexNote.attrs.id; // where does 'vf' come from?
        }
        else {
            this.applyStemDirection(noteParams, voiceIx, smoNote.flagState);
            layoutDebug_1.layoutDebug.setTimestamp(layoutDebug_1.layoutDebug.codeRegions.PREFORMATA, new Date().valueOf() - timestamp);
            timestamp = new Date().valueOf();
            if (smoNote.isCue || this.allCues) {
                noteParams.glyph_font_scale = VxMeasure.musicFontScaleCue;
            }
            vexNote = new VF.StaveNote(noteParams);
            if (voiceIx > 0 && this.isCollision(voiceIx, tickIndex)) {
                vexNote.setXShift(-10);
            }
            if (this.isWholeRest()) {
                noteParams.duration = 'wr';
                vexNote = new VF.StaveNote(noteParams);
                vexNote.setCenterAlignment(true);
            }
            layoutDebug_1.layoutDebug.setTimestamp(layoutDebug_1.layoutDebug.codeRegions.PREFORMATB, new Date().valueOf() - timestamp);
            timestamp = new Date().valueOf();
            if (smoNote.fillStyle && !this.printing) {
                vexNote.setStyle({ fillStyle: smoNote.fillStyle });
            }
            else if (voiceIx > 0 && !this.printing) {
                vexNote.setStyle({ fillStyle: "#115511" });
            }
            else if (smoNote.isHidden() && this.printing) {
                vexNote.setStyle({ fillStyle: "#ffffff00" });
            }
            smoNote.renderId = 'vf-' + vexNote.attrs.id; // where does 'vf' come from?
        }
        this._createAccidentals(smoNote, vexNote, tickIndex, voiceIx);
        this._createLyric(smoNote, vexNote);
        this._createOrnaments(smoNote, vexNote);
        this._createJazzOrnaments(smoNote, vexNote);
        this._createGraceNotes(smoNote, vexNote);
        layoutDebug_1.layoutDebug.setTimestamp(layoutDebug_1.layoutDebug.codeRegions.PREFORMATC, new Date().valueOf() - timestamp);
        return vexNote;
    }
    _renderArticulations(vix) {
        const i = 0;
        this.smoMeasure.voices[vix].notes.forEach((smoNote) => {
            smoNote.articulations.forEach((art) => {
                const vx = this.noteToVexMap[smoNote.attrs.id];
                const position = noteModifiers_1.SmoArticulation.positionToVex[art.position];
                const vexArt = noteModifiers_1.SmoArticulation.articulationToVex[art.articulation];
                const vxArt = new VF.Articulation(vexArt).setPosition(position);
                vx.addModifier(vxArt, i);
            });
        });
    }
    _renderNoteGlyph(smoNote, textObj) {
        var x = this.noteToVexMap[smoNote.attrs.id].getAbsoluteX() + textObj.xOffset;
        // the -3 is copied from vexflow textDynamics
        var y = this.stave.getYForLine(textObj.yOffsetLine - 3) + textObj.yOffsetPixels;
        var group = this.context.getContext().openGroup();
        group.classList.add(textObj.attrs.id + '-' + smoNote.attrs.id);
        group.classList.add(textObj.attrs.id);
        textObj.text.split('').forEach((ch) => {
            const glyphCode = VF.TextDynamics.GLYPHS[ch];
            if (glyphCode) {
                const glyph = new VF.Glyph(glyphCode.code, textObj.fontSize);
                glyph.render(this.context.getContext(), x, y);
                x += VF.TextDynamics.GLYPHS[ch].width;
                const metrics = glyph.getMetrics();
                textObj.logicalBox = svgHelpers_1.SvgHelpers.boxPoints(x, y + this.context.box.y, metrics.width, metrics.height);
            }
        });
        textObj.element = group;
        this.modifiersToBox.push(textObj);
        this.context.getContext().closeGroup();
    }
    renderDynamics() {
        this.smoMeasure.voices.forEach((voice) => {
            voice.notes.forEach((smoNote) => {
                const mods = smoNote.textModifiers.filter((mod) => mod.attrs.type === 'SmoDynamicText');
                mods.forEach((btm) => {
                    const tm = btm;
                    this._renderNoteGlyph(smoNote, tm);
                });
            });
        });
    }
    createRepeatSymbol() {
        this.voiceNotes = [];
        const vexNote = new VF.GlyphNote(new VF.Glyph('repeat1Bar', 38), { duration: 'w' }, { line: 2 });
        vexNote.setCenterAlignment(true);
        this.vexNotes.push(vexNote);
        this.voiceNotes.push(vexNote);
    }
    /**
     * create an a array of VF.StaveNote objects to render the active voice.
     * @param voiceIx
     */
    createVexNotes(voiceIx) {
        let i = 0;
        this.voiceNotes = [];
        const voice = this.smoMeasure.voices[voiceIx];
        for (i = 0; i < voice.notes.length; ++i) {
            const smoNote = voice.notes[i];
            const vexNote = this._createVexNote(smoNote, i, voiceIx);
            this.noteToVexMap[smoNote.attrs.id] = vexNote;
            this.vexNotes.push(vexNote);
            this.voiceNotes.push(vexNote);
            if (isNaN(smoNote.ticks.numerator) || isNaN(smoNote.ticks.denominator)
                || isNaN(smoNote.ticks.remainder)) {
                throw ('vxMeasure: NaN in ticks');
            }
        }
        this._renderArticulations(voiceIx);
    }
    /**
     * Group the notes for beaming and create Vex beam objects
     * @param vix - voice index
     * @returns
     */
    createVexBeamGroups(vix) {
        let keyNoteIx = -1;
        let i = 0;
        let j = 0;
        let stemDirection = VF.Stem.DOWN;
        for (i = 0; i < this.smoMeasure.beamGroups.length; ++i) {
            const bg = this.smoMeasure.beamGroups[i];
            if (bg.voice !== vix) {
                continue;
            }
            const vexNotes = [];
            keyNoteIx = bg.notes.findIndex((nn) => nn.noteType === 'n');
            // Fix stem bug: key off first non-rest note.
            keyNoteIx = (keyNoteIx >= 0) ? keyNoteIx : 0;
            for (j = 0; j < bg.notes.length; ++j) {
                const note = bg.notes[j];
                if (note.noteType === '/') {
                    continue;
                }
                const vexNote = this.noteToVexMap[note.attrs.id];
                // some type of redraw condition?
                if (typeof (vexNote) === 'undefined') {
                    return;
                }
                if (keyNoteIx === j) {
                    stemDirection = note.flagState === note_1.SmoNote.flagStates.auto ?
                        vexNote.getStemDirection() : note.toVexStemDirection();
                }
                vexNote.setStemDirection(stemDirection);
                vexNotes.push(this.noteToVexMap[note.attrs.id]);
            }
            const vexBeam = new VF.Beam(vexNotes);
            this.beamToVexMap[bg.attrs.id] = vexBeam;
            this.vexBeamGroups.push(vexBeam);
        }
    }
    /**
     * Create the VF tuplet objects based on the smo tuplet objects
     * @param vix
     */
    // 
    createVexTuplets(vix) {
        var j = 0;
        var i = 0;
        this.vexTuplets = [];
        this.tupletToVexMap = {};
        for (i = 0; i < this.smoMeasure.tuplets.length; ++i) {
            const tp = this.smoMeasure.tuplets[i];
            if (tp.voice !== vix) {
                continue;
            }
            const vexNotes = [];
            for (j = 0; j < tp.notes.length; ++j) {
                const smoNote = tp.notes[j];
                vexNotes.push(this.noteToVexMap[smoNote.attrs.id]);
            }
            const direction = tp.getStemDirection(this.smoMeasure.clef) === note_1.SmoNote.flagStates.up ?
                VF.Tuplet.LOCATION_TOP : VF.Tuplet.LOCATION_BOTTOM;
            const vexTuplet = new VF.Tuplet(vexNotes, {
                num_notes: tp.num_notes,
                notes_occupied: tp.notes_occupied,
                ratioed: false,
                bracketed: true,
                location: direction
            });
            this.tupletToVexMap[tp.attrs.id] = vexTuplet;
            this.vexTuplets.push(vexTuplet);
        }
    }
    /**
     * create the modifiers for the stave itself, bar lines etc.
     */
    createMeasureModifiers() {
        const sb = this.smoMeasure.getStartBarline();
        const eb = this.smoMeasure.getEndBarline();
        const sym = this.smoMeasure.getRepeatSymbol();
        // don't create a begin bar for any but the 1st measure.
        if (this.smoMeasure.measureNumber.systemIndex !== 0 && sb.barline === measureModifiers_1.SmoBarline.barlines.singleBar
            && this.smoMeasure.format.padLeft === 0) {
            this.stave.setBegBarType(VF.Barline.type.NONE);
        }
        else {
            this.stave.setBegBarType(sb.toVexBarline());
        }
        if (this.smoMeasure.svg.multimeasureLength > 0 && !this.smoMeasure.svg.hideMultimeasure) {
            this.stave.setEndBarType(measureModifiers_1.SmoBarline.toVexBarline[this.smoMeasure.svg.multimeasureEndBarline]);
        }
        else if (eb.barline !== measureModifiers_1.SmoBarline.barlines.singleBar) {
            this.stave.setEndBarType(eb.toVexBarline());
        }
        if (sym && sym.symbol !== measureModifiers_1.SmoRepeatSymbol.symbols.None) {
            const rep = new VF.Repetition(sym.toVexSymbol(), sym.xOffset + this.smoMeasure.staffX, sym.yOffset);
            this.stave.modifiers.push(rep);
        }
        const tms = this.smoMeasure.getMeasureText();
        // TODO: set font
        tms.forEach((tmb) => {
            const tm = tmb;
            const offset = tm.position === measureModifiers_1.SmoMeasureText.positions.left ? this.smoMeasure.format.padLeft : 0;
            this.stave.setText(tm.text, tm.toVexPosition(), {
                shift_x: tm.adjustX + offset, shift_y: tm.adjustY, justification: tm.toVexJustification()
            });
            // hack - we can't create staveText directly so this is the only way I could set the font
            const ar = this.stave.getModifiers();
            const vm = ar[ar.length - 1];
            vm.setFont(tm.fontInfo);
        });
        if (this.smoMeasure.svg.rowInSystem === 0) {
            const rmb = this.smoMeasure.getRehearsalMark();
            const rm = rmb;
            if (rm) {
                this.stave.setSection(rm.symbol, 0);
            }
        }
        const tempo = this.smoMeasure.getTempo();
        if (tempo && this.smoMeasure.svg.forceTempo) {
            this.stave.setTempo(tempo.toVexTempo(), -1 * tempo.yOffset);
            const vexTempo = this.stave.modifiers.find((mod) => mod.attrs.type === 'StaveTempo');
            vexTempo.font = { family: ssp_serif_metrics_1.SourceSerifProFont.fontFamily, size: 13, weight: 'bold' };
        }
    }
    /**
     * Create all Vex notes and modifiers.  We defer the format and rendering so
     * we can align across multiple staves
     */
    preFormat() {
        var j = 0;
        if (this.smoMeasure.svg.element !== null) {
            this.smoMeasure.svg.element.remove();
            this.smoMeasure.svg.element = null;
        }
        if (this.smoMeasure.svg.hideEmptyMeasure) {
            return;
        }
        // Note: need to do this to get it into VEX KS format
        const key = music_1.SmoMusic.vexKeySignatureTranspose(this.smoMeasure.keySignature, 0);
        const canceledKey = music_1.SmoMusic.vexKeySignatureTranspose(this.smoMeasure.canceledKeySignature, 0);
        const staffX = this.smoMeasure.staffX + this.smoMeasure.format.padLeft;
        const staffY = this.smoMeasure.staffY - this.context.box.y;
        this.stave = new VF.Stave(staffX, staffY, this.smoMeasure.staffWidth - this.smoMeasure.format.padLeft, { font: { family: ssp_sans_metrics_1.SourceSansProFont.fontFamily, size: '12pt' }, fill_style: VxMeasure.fillStyle });
        // If there is padLeft, draw an invisible box so the padding is included in the measure box
        if (this.smoMeasure.format.padLeft) {
            this.context.getContext().rect(this.smoMeasure.staffX, staffY, this.smoMeasure.format.padLeft, 50, {
                fill: 'none', 'stroke-width': 1, stroke: 'white'
            });
        }
        this.stave.options.space_above_staff_ln = 0; // don't let vex place the staff, we want to.
        // Add a clef and time signature.
        if (this.smoMeasure.svg.forceClef) {
            this.stave.addClef(this.smoMeasure.clef);
        }
        if (this.smoMeasure.svg.forceKeySignature) {
            const sig = new VF.KeySignature(key);
            if (this.smoMeasure.canceledKeySignature) {
                sig.cancelKey(canceledKey);
            }
            sig.addToStave(this.stave);
        }
        if (this.smoMeasure.svg.forceTimeSignature) {
            const ts = this.smoMeasure.timeSignature;
            let tsString = ts.timeSignature;
            if (this.smoMeasure.timeSignature.useSymbol && ts.actualBeats === 4 && ts.beatDuration === 4) {
                tsString = 'C';
            }
            else if (this.smoMeasure.timeSignature.useSymbol && ts.actualBeats === 2 && ts.beatDuration === 4) {
                tsString = 'C|';
            }
            else if (this.smoMeasure.timeSignatureString.length) {
                tsString = this.smoMeasure.timeSignatureString;
            }
            this.stave.addTimeSignature(tsString);
        }
        // Connect it to the rendering context and draw!
        this.stave.setContext(this.context.getContext());
        this.createMeasureModifiers();
        this.tickmapObject = this.smoMeasure.createMeasureTickmaps();
        this.createCollisionTickmap();
        this.voiceAr = [];
        this.vexNotes = [];
        this.noteToVexMap = {};
        // If there are multiple voices, add them all to the formatter at the same time so they don't collide
        for (j = 0; j < this.smoMeasure.voices.length; ++j) {
            if (!this.smoMeasure.svg.multimeasureLength && !this.smoMeasure.repeatSymbol) {
                this.createVexNotes(j);
                this.createVexTuplets(j);
                this.createVexBeamGroups(j);
                // Create a voice in 4/4 and add above notes
                const voice = new VF.Voice({
                    num_beats: this.smoMeasure.timeSignature.actualBeats,
                    beat_value: this.smoMeasure.timeSignature.beatDuration
                }).setMode(VF.Voice.Mode.SOFT);
                voice.addTickables(this.voiceNotes);
                this.voiceAr.push(voice);
            }
            if (this.smoMeasure.repeatSymbol) {
                this.createRepeatSymbol();
                // Create a voice in 4/4 and add above notes
                const voice = new VF.Voice({
                    num_beats: this.smoMeasure.timeSignature.actualBeats,
                    beat_value: this.smoMeasure.timeSignature.beatDuration
                }).setMode(VF.Voice.Mode.SOFT);
                voice.addTickables(this.voiceNotes);
                this.voiceAr.push(voice);
            }
        }
        // Need to format for x position, then set y position before drawing dynamics.
        this.formatter = new VF.Formatter({ softmaxFactor: this.softmax, globalSoftmax: false });
        this.voiceAr.forEach((voice) => {
            this.formatter.joinVoices([voice]);
        });
    }
    /**
     * Create the Vex formatter that calculates the X and Y positions of the notes.  A formatter
     * may actually span multiple staves for justified staves.  The notes are drawn in their
     * individual vxMeasure objects but formatting is done once for all justified staves
     * @param voices Voice objects from VexFlow
     * @returns
     */
    format(voices) {
        if (this.smoMeasure.svg.hideEmptyMeasure) {
            return;
        }
        if (this.smoMeasure.svg.multimeasureLength > 0) {
            this.multimeasureRest = new VF.MultiMeasureRest(this.smoMeasure.svg.multimeasureLength, { number_of_measures: this.smoMeasure.svg.multimeasureLength });
            this.multimeasureRest.setContext(this.context.getContext());
            this.multimeasureRest.setStave(this.stave);
            return;
        }
        const timestamp = new Date().valueOf();
        const staffWidth = this.smoMeasure.staffWidth -
            (this.smoMeasure.svg.adjX + this.smoMeasure.svg.adjRight + this.smoMeasure.format.padLeft) - 10;
        this.dbgLeftX = this.smoMeasure.staffX + this.smoMeasure.format.padLeft + this.smoMeasure.svg.adjX;
        this.dbgWidth = staffWidth;
        this.formatter.format(voices, staffWidth);
        layoutDebug_1.layoutDebug.setTimestamp(layoutDebug_1.layoutDebug.codeRegions.FORMAT, new Date().valueOf() - timestamp);
    }
    /**
     * render is called after format.  Actually draw the things.
     */
    render() {
        if (this.smoMeasure.svg.hideEmptyMeasure) {
            return;
        }
        var group = this.context.getContext().openGroup();
        this.smoMeasure.svg.element = group;
        var mmClass = this.smoMeasure.getClassId();
        var j = 0;
        try {
            // bound each measure in its own SVG group for easy deletion and mapping to screen coordinate
            group.classList.add(this.smoMeasure.attrs.id);
            group.classList.add(mmClass);
            group.id = this.smoMeasure.attrs.id;
            this.stave.draw();
            this.smoMeasure.svg.element = group;
            for (j = 0; j < this.voiceAr.length; ++j) {
                this.voiceAr[j].draw(this.context.getContext(), this.stave);
            }
            this.vexBeamGroups.forEach((b) => {
                b.setContext(this.context.getContext()).draw();
            });
            this.vexTuplets.forEach((tuplet) => {
                tuplet.setContext(this.context.getContext()).draw();
            });
            if (this.multimeasureRest) {
                this.multimeasureRest.draw();
            }
            // this._updateLyricDomSelectors();
            this.renderDynamics();
            // this.smoMeasure.adjX = this.stave.start_x - (this.smoMeasure.staffX);
            this.context.getContext().closeGroup();
            // layoutDebug.setTimestamp(layoutDebug.codeRegions.RENDER, new Date().valueOf() - timestamp);
            this.rendered = true;
            if (layoutDebug_1.layoutDebug.mask & layoutDebug_1.layoutDebug.values['adjust']) {
                svgHelpers_1.SvgHelpers.debugBoxNoText(this.context.getContext().svg, svgHelpers_1.SvgHelpers.boxPoints(this.dbgLeftX, this.smoMeasure.svg.staffY, this.dbgWidth, 40), 'render-x-dbg', 0);
            }
        }
        catch (exc) {
            console.warn('unable to render measure ' + this.smoMeasure.measureNumber.measureIndex);
            this.context.getContext().closeGroup();
        }
    }
}
exports.VxMeasure = VxMeasure;
VxMeasure.musicFontScaleNote = 38;
VxMeasure.musicFontScaleCue = 28;


/***/ }),

/***/ "./src/render/vex/vxSystem.ts":
/*!************************************!*\
  !*** ./src/render/vex/vxSystem.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.VxSystem = void 0;
// [Smoosic](https://github.com/AaronDavidNewman/Smoosic)
// Copyright (c) Aaron David Newman 2021.
const vxMeasure_1 = __webpack_require__(/*! ./vxMeasure */ "./src/render/vex/vxMeasure.ts");
const selections_1 = __webpack_require__(/*! ../../smo/xform/selections */ "./src/smo/xform/selections.ts");
const svgHelpers_1 = __webpack_require__(/*! ../sui/svgHelpers */ "./src/render/sui/svgHelpers.ts");
const noteModifiers_1 = __webpack_require__(/*! ../../smo/data/noteModifiers */ "./src/smo/data/noteModifiers.ts");
const staffModifiers_1 = __webpack_require__(/*! ../../smo/data/staffModifiers */ "./src/smo/data/staffModifiers.ts");
const common_1 = __webpack_require__(/*! ../../smo/data/common */ "./src/smo/data/common.ts");
const measureModifiers_1 = __webpack_require__(/*! ../../smo/data/measureModifiers */ "./src/smo/data/measureModifiers.ts");
const VF = eval('Vex.Flow');
/**
 * Create a system of staves and draw music on it.  This calls the Vex measure
 * rendering methods, and also draws all the score and system level stuff like slurs,
 * text, aligns the lyrics.
 * */
class VxSystem {
    constructor(context, topY, lineIndex, score) {
        this.leftConnector = [null, null];
        this.vxMeasures = [];
        this.smoMeasures = [];
        this.minMeasureIndex = -1;
        this.maxMeasureIndex = 0;
        this.staves = [];
        this.box = common_1.SvgBox.default;
        this.ys = [];
        this.measures = [];
        this.modifiers = [];
        this.context = context;
        this.lineIndex = lineIndex;
        this.score = score;
        this.maxStaffIndex = -1;
        this.maxSystemIndex = -1;
        this.width = -1;
        this.staves = [];
        this.currentY = 0;
        this.topY = topY;
        this.clefWidth = 70;
        this.ys = [];
    }
    getVxMeasure(smoMeasure) {
        let i = 0;
        for (i = 0; i < this.vxMeasures.length; ++i) {
            const vm = this.vxMeasures[i];
            if (vm.smoMeasure.attrs.id === smoMeasure.attrs.id) {
                return vm;
            }
        }
        return null;
    }
    getVxNote(smoNote) {
        let i = 0;
        if (!smoNote) {
            return null;
        }
        for (i = 0; i < this.measures.length; ++i) {
            const mm = this.measures[i];
            if (mm.noteToVexMap[smoNote.attrs.id]) {
                return mm.noteToVexMap[smoNote.attrs.id];
            }
        }
        return null;
    }
    _updateChordOffsets(note) {
        var i = 0;
        for (i = 0; i < 3; ++i) {
            const chords = note.getLyricForVerse(i, noteModifiers_1.SmoLyric.parsers.chord);
            chords.forEach((bchord) => {
                const chord = bchord;
                const dom = this.context.svg.getElementById('vf-' + chord.attrs.id);
                if (dom) {
                    dom.setAttributeNS('', 'transform', 'translate(' + chord.translateX + ' ' + (-1 * chord.translateY) + ')');
                }
            });
        }
    }
    _lowestYLowestVerse(lyrics) {
        let lowVerse = 5;
        let lowestY = 0;
        lyrics.forEach((lyric) => {
            if (lyric.logicalBox && lyric.verse < lowVerse) {
                lowestY = lyric.logicalBox.y;
                lowVerse = lyric.verse;
            }
            if (lyric.verse === lowVerse && lyric.logicalBox && lyric.logicalBox.y > lowestY) {
                lowestY = lyric.logicalBox.y;
            }
        });
        this.vxMeasures.forEach((vxMeasure) => {
            vxMeasure.smoMeasure.voices.forEach((voice) => {
                voice.notes.forEach((note) => {
                    const lyrics = note.getTrueLyrics();
                    if (lyrics.length) {
                        const topVerse = lyrics.reduce((a, b) => a.verse < b.verse ? a : b);
                        if (topVerse && topVerse.logicalBox) {
                            const offset = lowestY - topVerse.logicalBox.y;
                            lyrics.forEach((lyric) => {
                                lyric.adjY = offset + lyric.translateY;
                            });
                        }
                    }
                });
            });
        });
    }
    // ### updateLyricOffsets
    // Adjust the y position for all lyrics in the line so they are even.
    // Also replace '-' with a longer dash do indicate 'until the next measure'
    updateLyricOffsets() {
        let i = 0;
        for (i = 0; i < this.score.staves.length; ++i) {
            const tmpI = i;
            const lyricsDash = [];
            const lyricHyphens = [];
            const lyricVerseMap = {};
            const lyrics = [];
            // is this necessary? They should all be from the current line
            const vxMeasures = this.vxMeasures.filter((vx) => vx.smoMeasure.measureNumber.staffId === tmpI);
            // All the lyrics on this line
            // The vertical bounds on each line
            vxMeasures.forEach((mm) => {
                var smoMeasure = mm.smoMeasure;
                // Get lyrics from any voice.
                smoMeasure.voices.forEach((voice) => {
                    voice.notes.forEach((note) => {
                        this._updateChordOffsets(note);
                        note.getTrueLyrics().forEach((ll) => {
                            const hasLyric = ll.getText().length > 0 || ll.isHyphenated();
                            if (hasLyric && ll.logicalBox && !lyricVerseMap[ll.verse]) {
                                lyricVerseMap[ll.verse] = [];
                            }
                            else if (hasLyric && !ll.logicalBox) {
                                console.warn(`unrendered lyric for note ${note.attrs.id} measure ${smoMeasure.measureNumber.staffId}-${smoMeasure.measureNumber.measureIndex}`);
                            }
                            if (hasLyric && ll.logicalBox) {
                                lyricVerseMap[ll.verse].push(ll);
                                lyrics.push(ll);
                            }
                        });
                    });
                });
            });
            // calculate y offset so the lyrics all line up
            this._lowestYLowestVerse(lyrics);
            const vkey = Object.keys(lyricVerseMap).sort((a, b) => parseInt(a, 10) - parseInt(b, 10));
            vkey.forEach((sverse) => {
                const verse = parseInt(sverse, 10);
                let hyphenLyric = null;
                const lastVerse = lyricVerseMap[verse][lyricVerseMap[verse].length - 1].attrs.id;
                lyricVerseMap[verse].forEach((ll) => {
                    if (hyphenLyric !== null && hyphenLyric.logicalBox !== null && ll.logicalBox !== null) {
                        const x = ll.logicalBox.x - (ll.logicalBox.x -
                            (hyphenLyric.logicalBox.x + hyphenLyric.logicalBox.width)) / 2;
                        ll.hyphenX = x;
                        lyricHyphens.push(ll);
                    }
                    if (ll.isHyphenated() && ll.logicalBox !== null) {
                        if (ll.attrs.id === lastVerse) {
                            // Last word on the system, place the hyphen after the word
                            ll.hyphenX = ll.logicalBox.x + ll.logicalBox.width + ll.fontInfo.size / 2;
                            lyricHyphens.push(ll);
                        }
                        else if (ll.getText().length) {
                            // place the hyphen 1/2 between next word and this one.
                            hyphenLyric = ll;
                        }
                    }
                    else {
                        hyphenLyric = null;
                    }
                });
            });
            lyrics.forEach((lyric) => {
                const dom = this.context.svg.getElementById('vf-' + lyric.attrs.id);
                if (dom) {
                    dom.setAttributeNS('', 'transform', 'translate(' + lyric.adjX + ' ' + lyric.adjY + ')');
                    // Keep track of lyrics that are 'dash'
                    if (lyric.isDash()) {
                        lyricsDash.push(lyric);
                    }
                }
            });
            lyricHyphens.forEach((lyric) => {
                const parent = this.context.svg.getElementById('vf-' + lyric.attrs.id);
                if (parent && lyric.logicalBox !== null) {
                    const text = document.createElementNS(svgHelpers_1.SvgHelpers.namespace, 'text');
                    text.textContent = '-';
                    text.setAttributeNS('', 'x', lyric.hyphenX.toString());
                    text.setAttributeNS('', 'y', (lyric.logicalBox.y + (lyric.logicalBox.height * 2) / 3).toString());
                    const fontSize = lyric.fontInfo.size * 1.2;
                    text.setAttributeNS('', 'fontSize', '' + fontSize + 'pt');
                    parent.appendChild(text);
                }
            });
            lyricsDash.forEach((lyric) => {
                const parent = this.context.svg.getElementById('vf-' + lyric.attrs.id);
                if (parent && lyric.logicalBox !== null) {
                    const line = document.createElementNS(svgHelpers_1.SvgHelpers.namespace, 'line');
                    const ymax = Math.round(lyric.logicalBox.y + lyric.logicalBox.height / 2);
                    const offset = Math.round(lyric.logicalBox.width / 2);
                    line.setAttributeNS('', 'x1', (lyric.logicalBox.x - offset).toString());
                    line.setAttributeNS('', 'y1', ymax.toString());
                    line.setAttributeNS('', 'x2', (lyric.logicalBox.x + lyric.logicalBox.width + offset).toString());
                    line.setAttributeNS('', 'y2', ymax.toString());
                    line.setAttributeNS('', 'stroke-width', '1');
                    line.setAttributeNS('', 'fill', 'none');
                    line.setAttributeNS('', 'stroke', '#999999');
                    parent.appendChild(line);
                    const texts = parent.getElementsByTagName('text');
                    // hide hyphen and replace with dash
                    if (texts && texts.length) {
                        const text = texts[0];
                        text.setAttributeNS('', 'fill', '#fff');
                    }
                }
            });
        }
    }
    // ### renderModifier
    // render a line-type modifier that is associated with a staff (e.g. slur)
    renderModifier(scroller, modifier, vxStart, vxEnd, smoStart, smoEnd) {
        let xoffset = 0;
        const setSameIfNull = (a, b) => {
            if (typeof (a) === 'undefined' || a === null) {
                return b;
            }
            return a;
        };
        if (smoStart && smoStart.note && smoStart.note.noteType === '/') {
            return;
        }
        if (smoEnd && smoEnd.note && smoEnd.note.noteType === '/') {
            return;
        }
        // if it is split between lines, render one artifact for each line, with a common class for
        // both if it is removed.
        if (vxStart) {
            const toRemove = this.context.svg.getElementById('vf-' + modifier.attrs.id);
            if (toRemove) {
                toRemove.remove();
            }
        }
        const artifactId = modifier.attrs.id + '-' + this.lineIndex;
        const group = this.context.getContext().openGroup('slur', artifactId);
        group.classList.add(modifier.attrs.id);
        const measureMod = 'mod-' + smoStart.selector.staff + '-' + smoStart.selector.measure;
        const staffMod = 'mod-' + smoStart.selector.staff;
        group.classList.add(measureMod);
        group.classList.add(staffMod);
        if (modifier.ctor === 'SmoStaffHairpin') {
            const hp = modifier;
            if (!vxStart && !vxEnd) {
                this.context.getContext().closeGroup();
            }
            vxStart = setSameIfNull(vxStart, vxEnd);
            vxEnd = setSameIfNull(vxEnd, vxStart);
            const hairpin = new VF.StaveHairpin({
                first_note: vxStart,
                last_note: vxEnd
            }, hp.hairpinType);
            hairpin.setRenderOptions({
                height: hp.height,
                y_shift: hp.yOffset,
                left_shift_px: hp.xOffsetLeft,
                right_shift_px: hp.xOffsetRight
            });
            hairpin.setContext(this.context.getContext()).setPosition(hp.position).draw();
        }
        else if (modifier.ctor === 'SmoSlur') {
            const startNote = smoStart.note;
            const slur = modifier;
            let slurX = slur.xOffset;
            const svgPoint = JSON.parse(JSON.stringify(slur.controlPoints));
            const lyric = startNote.longestLyric();
            if (lyric && lyric.getText()) {
                // If there is a lyric, the bounding box of the start note is stretched to the right.
                // slide the slur left, and also make it a bit wider.
                const xtranslate = (-1 * lyric.getText().length * 6);
                xoffset += (xtranslate / 2) - staffModifiers_1.SmoSlur.defaults.xOffset;
            }
            if (vxStart === null || vxEnd === null) {
                slurX = -5;
                svgPoint[0].y = 10;
                svgPoint[1].y = 10;
            }
            const curve = new VF.Curve(vxStart, vxEnd, {
                thickness: slur.thickness,
                x_shift: slurX,
                y_shift: slur.yOffset,
                spacing: slur.spacing,
                cps: svgPoint,
                invert: slur.invert,
                position: slur.position,
                position_end: slur.position_end
            });
            curve.setContext(this.context.getContext()).draw();
        }
        else if (modifier.ctor === 'SmoTie') {
            const ctie = modifier;
            const startNote = smoStart.note;
            const endNote = smoEnd.note;
            if (ctie.lines.length > 0) {
                // Hack: if a chord changed, the ties may no longer be valid.  We should check
                // this when it changes.
                ctie.checkLines(startNote, endNote);
                const fromLines = ctie.lines.map((ll) => ll.from);
                const toLines = ctie.lines.map((ll) => ll.to);
                const tie = new VF.StaveTie({
                    first_note: vxStart,
                    last_note: vxEnd,
                    first_indices: fromLines,
                    last_indices: toLines,
                    options: {
                        cp1: ctie.cp1,
                        cp2: ctie.cp2
                    }
                });
                Vex.Merge(tie.render_options, ctie.vexOptions);
                tie.setContext(this.context.getContext()).draw();
            }
        }
        else if (modifier.ctor === 'SmoStaffTextBracket') {
            if (vxStart && !vxEnd) {
                vxEnd = vxStart;
            }
            else if (vxEnd && !vxStart) {
                vxStart = vxEnd;
            }
            if (vxStart && vxEnd) {
                const smoBracket = modifier;
                const bracket = new VF.TextBracket({
                    start: vxStart, stop: vxEnd, text: smoBracket.text, superscript: smoBracket.superscript, position: smoBracket.position
                });
                bracket.setLine(smoBracket.line).setContext(this.context.getContext()).draw();
            }
        }
        this.context.getContext().closeGroup();
        if (xoffset) {
            const slurBox = this.context.svg.getElementById('vf-' + artifactId);
            if (slurBox) {
                svgHelpers_1.SvgHelpers.translateElement(slurBox, xoffset, 0);
            }
        }
        modifier.element = group;
    }
    renderEndings(scroller) {
        let j = 0;
        let i = 0;
        if (this.staves.length < 1) {
            return;
        }
        const voltas = this.staves[0].getVoltaMap(this.minMeasureIndex, this.maxMeasureIndex);
        voltas.forEach((ending) => {
            ending.elements.forEach((element) => {
                element.remove();
            });
            ending.elements = [];
        });
        for (j = 0; j < this.smoMeasures.length; ++j) {
            let pushed = false;
            const smoMeasure = this.smoMeasures[j];
            // Only draw volta on top staff of system
            if (smoMeasure.svg.rowInSystem > 0) {
                continue;
            }
            const vxMeasure = this.getVxMeasure(smoMeasure);
            const voAr = [];
            for (i = 0; i < voltas.length && vxMeasure !== null; ++i) {
                const ending = voltas[i];
                const mix = smoMeasure.measureNumber.measureIndex;
                if ((ending.startBar <= mix) && (ending.endBar >= mix) && vxMeasure.stave !== null) {
                    const group = this.context.getContext().openGroup(null, ending.attrs.id);
                    group.classList.add(ending.attrs.id);
                    group.classList.add(ending.endingId);
                    ending.elements.push(group);
                    const vtype = ending.toVexVolta(smoMeasure.measureNumber.measureIndex);
                    const vxVolta = new VF.Volta(vtype, ending.number, smoMeasure.staffX + ending.xOffsetStart, ending.yOffset);
                    vxVolta.setContext(this.context.getContext()).draw(vxMeasure.stave, -1 * ending.xOffsetEnd);
                    this.context.getContext().closeGroup();
                    // ending.logicalBox = this.context.offsetBbox(group);
                    if (!pushed) {
                        voAr.push({ smoMeasure, ending });
                        pushed = true;
                    }
                    vxMeasure.stave.modifiers.push(vxVolta);
                }
            }
            // Adjust real height of measure to match volta height
            for (i = 0; i < voAr.length; ++i) {
                const mm = voAr[i].smoMeasure;
                const ending = voAr[i].ending;
                if (ending.logicalBox !== null) {
                    const delta = mm.svg.logicalBox.y - ending.logicalBox.y;
                    if (delta > 0) {
                        mm.setBox(svgHelpers_1.SvgHelpers.boxPoints(mm.svg.logicalBox.x, mm.svg.logicalBox.y - delta, mm.svg.logicalBox.width, mm.svg.logicalBox.height + delta), 'vxSystem adjust for volta');
                    }
                }
            }
        }
    }
    getMeasureByIndex(measureIndex, staffId) {
        let i = 0;
        for (i = 0; i < this.smoMeasures.length; ++i) {
            const mm = this.smoMeasures[i];
            if (measureIndex === mm.measureNumber.measureIndex && staffId === mm.measureNumber.staffId) {
                return mm;
            }
        }
        return null;
    }
    // ## renderMeasure
    // ## Description:
    // Create the graphical (VX) notes and render them on svg.  Also render the tuplets and beam
    // groups
    renderMeasure(smoMeasure, printing) {
        var _a, _b;
        if (smoMeasure.svg.hideMultimeasure) {
            return;
        }
        const measureIndex = smoMeasure.measureNumber.measureIndex;
        if (this.minMeasureIndex < 0 || this.minMeasureIndex > measureIndex) {
            this.minMeasureIndex = measureIndex;
        }
        if (this.maxMeasureIndex < measureIndex) {
            this.maxMeasureIndex = measureIndex;
        }
        let brackets = false;
        const staff = this.score.staves[smoMeasure.measureNumber.staffId];
        const staffId = staff.staffId;
        const systemIndex = smoMeasure.measureNumber.systemIndex;
        const selection = selections_1.SmoSelection.measureSelection(this.score, staff.staffId, smoMeasure.measureNumber.measureIndex);
        this.smoMeasures.push(smoMeasure);
        if (this.staves.length <= staffId) {
            this.staves.push(staff);
        }
        if (selection === null) {
            return;
        }
        let softmax = selection.measure.format.proportionality;
        if (softmax === measureModifiers_1.SmoMeasureFormat.defaultProportionality) {
            softmax = (_b = (_a = this.score.layoutManager) === null || _a === void 0 ? void 0 : _a.getGlobalLayout().proportionality) !== null && _b !== void 0 ? _b : 0;
        }
        const vxMeasure = new vxMeasure_1.VxMeasure(this.context, selection, printing, softmax);
        // create the vex notes, beam groups etc. for the measure
        vxMeasure.preFormat();
        this.vxMeasures.push(vxMeasure);
        const lastStaff = (staffId === this.score.staves.length - 1);
        const smoGroupMap = {};
        const adjXMap = {};
        const vxMeasures = this.vxMeasures.filter((mm) => !mm.smoMeasure.svg.hideEmptyMeasure);
        // If this is the last staff in the column, render the column with justification
        if (lastStaff) {
            vxMeasures.forEach((mm) => {
                if (typeof (adjXMap[mm.smoMeasure.measureNumber.systemIndex]) === 'undefined') {
                    adjXMap[mm.smoMeasure.measureNumber.systemIndex] = mm.smoMeasure.svg.adjX;
                }
                adjXMap[mm.smoMeasure.measureNumber.systemIndex] = Math.max(adjXMap[mm.smoMeasure.measureNumber.systemIndex], mm.smoMeasure.svg.adjX);
            });
            vxMeasures.forEach((vv) => {
                if (!vv.rendered && !vv.smoMeasure.svg.hideEmptyMeasure) {
                    vv.vexNotes.forEach((vnote) => {
                        vnote.setXShift(vnote.getXShift() + adjXMap[vv.smoMeasure.measureNumber.systemIndex] - vv.smoMeasure.svg.adjX);
                    });
                    const systemGroup = this.score.getSystemGroupForStaff(vv.selection);
                    const justifyGroup = (systemGroup && vv.smoMeasure.format.autoJustify) ? systemGroup.attrs.id : vv.selection.staff.attrs.id;
                    if (!smoGroupMap[justifyGroup]) {
                        smoGroupMap[justifyGroup] = { firstMeasure: vv, voices: [] };
                    }
                    smoGroupMap[justifyGroup].voices =
                        smoGroupMap[justifyGroup].voices.concat(vv.voiceAr);
                }
            });
        }
        const keys = Object.keys(smoGroupMap);
        keys.forEach((key) => {
            smoGroupMap[key].firstMeasure.format(smoGroupMap[key].voices);
        });
        if (lastStaff) {
            vxMeasures.forEach((vv) => {
                if (!vv.rendered) {
                    vv.render();
                }
            });
        }
        // Keep track of the y coordinate for the nth staff
        const renderedConnection = {};
        if (systemIndex === 0 && lastStaff) {
            if (staff.bracketMap[this.lineIndex]) {
                staff.bracketMap[this.lineIndex].forEach((element) => {
                    element.remove();
                });
            }
            staff.bracketMap[this.lineIndex] = [];
            const group = this.context.getContext().openGroup();
            group.classList.add('lineBracket-' + this.lineIndex);
            group.classList.add('lineBracket');
            staff.bracketMap[this.lineIndex].push(group);
            vxMeasures.forEach((vv) => {
                const systemGroup = this.score.getSystemGroupForStaff(vv.selection);
                if (systemGroup && !renderedConnection[systemGroup.attrs.id] &&
                    !vv.smoMeasure.svg.hideEmptyMeasure) {
                    renderedConnection[systemGroup.attrs.id] = 1;
                    const startSel = this.vxMeasures[systemGroup.startSelector.staff];
                    const endSel = this.vxMeasures[systemGroup.endSelector.staff];
                    if (startSel && startSel.rendered &&
                        endSel && endSel.rendered) {
                        const c1 = new VF.StaveConnector(startSel.stave, endSel.stave)
                            .setType(systemGroup.leftConnectorVx());
                        c1.setContext(this.context.getContext()).draw();
                        brackets = true;
                    }
                }
            });
            if (!brackets && vxMeasures.length > 1) {
                const c2 = new VF.StaveConnector(vxMeasures[0].stave, vxMeasures[vxMeasures.length - 1].stave, VF.StaveConnector.type.SINGLE_LEFT);
                c2.setContext(this.context.getContext()).draw();
            }
            // draw outer brace on parts with multiple staves (e.g. keyboards)
            vxMeasures.forEach((vv) => {
                if (vv.selection.staff.partInfo.stavesAfter > 0) {
                    if (this.vxMeasures.length > vv.selection.selector.staff + 1) {
                        const endSel = this.vxMeasures[vv.selection.selector.staff + 1];
                        const startSel = vv;
                        if (startSel && startSel.rendered &&
                            endSel && endSel.rendered) {
                            const c1 = new VF.StaveConnector(startSel.stave, endSel.stave)
                                .setType(VF.StaveConnector.type.BRACE);
                            c1.setContext(this.context.getContext()).draw();
                        }
                    }
                }
                ;
            });
            this.context.getContext().closeGroup();
        }
        else if (lastStaff && smoMeasure.measureNumber.measureIndex + 1 < staff.measures.length) {
            if (staff.measures[smoMeasure.measureNumber.measureIndex + 1].measureNumber.systemIndex === 0) {
                const endMeasure = vxMeasure;
                const startMeasure = vxMeasures.find((vv) => vv.selection.selector.staff === 0 &&
                    vv.selection.selector.measure === vxMeasure.selection.selector.measure &&
                    vv.smoMeasure.svg.hideEmptyMeasure === false);
                if (endMeasure && endMeasure.stave && startMeasure && startMeasure.stave) {
                    const group = this.context.getContext().openGroup();
                    group.classList.add('endBracket-' + this.lineIndex);
                    group.classList.add('endBracket');
                    staff.bracketMap[this.lineIndex].push(group);
                    const c2 = new VF.StaveConnector(startMeasure.stave, endMeasure.stave)
                        .setType(VF.StaveConnector.type.SINGLE_RIGHT);
                    c2.setContext(this.context.getContext()).draw();
                    this.context.getContext().closeGroup();
                }
            }
        }
        // keep track of left-hand side for system connectors
        if (systemIndex === 0) {
            if (staffId === 0) {
                this.leftConnector[0] = vxMeasure.stave;
            }
            else if (staffId > this.maxStaffIndex) {
                this.maxStaffIndex = staffId;
                this.leftConnector[1] = vxMeasure.stave;
            }
        }
        else if (smoMeasure.measureNumber.systemIndex > this.maxSystemIndex) {
            this.maxSystemIndex = smoMeasure.measureNumber.systemIndex;
        }
        this.measures.push(vxMeasure);
    }
}
exports.VxSystem = VxSystem;


/***/ }),

/***/ "./src/smo/data/common.ts":
/*!********************************!*\
  !*** ./src/smo/data/common.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IsClef = exports.Clefs = exports.SvgBox = exports.SvgPoint = exports.IsPitchLetter = void 0;
function IsPitchLetter(letter) {
    return letter.length === 1 && letter[0] >= 'a' && letter[0] <= 'g';
}
exports.IsPitchLetter = IsPitchLetter;
/**
 * musical artifacts can contain temporary svg information for
 * mapping the UI.
 */
class SvgPoint {
    constructor() {
        this.x = 0;
        this.y = 0;
    }
    static get default() {
        return { x: 0, y: 0 };
    }
}
exports.SvgPoint = SvgPoint;
/**
 * musical artifacts can contain temporary svg information for
 * mapping the UI.
 */
class SvgBox {
    constructor() {
        this.x = 0;
        this.y = 0;
        this.width = -1;
        this.height = -1;
    }
    static get default() {
        return { x: 0, y: 0, width: -1, height: -1 };
    }
}
exports.SvgBox = SvgBox;
exports.Clefs = ['treble', 'bass', 'tenor', 'alto', 'soprano', 'percussion',
    'mezzo-soprano', 'baritone-c', 'baritone-f', 'subbass', 'french'];
function IsClef(clef) {
    return exports.Clefs.findIndex((x) => clef === x) >= 0;
}
exports.IsClef = IsClef;


/***/ }),

/***/ "./src/smo/data/measure.ts":
/*!*********************************!*\
  !*** ./src/smo/data/measure.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SmoMeasure = exports.SmoMeasureStringParams = exports.SmoMeasureNumberParams = void 0;
// [Smoosic](https://github.com/AaronDavidNewman/Smoosic)
// Copyright (c) Aaron David Newman 2021.
/**
 * Contains definition and supporting classes for {@link SmoMeasure}.
 * Most of the engraving is done at the measure level.  Measure contains multiple (at least 1)
 * voices, which in turn contain notes.  Each measure also contains formatting information.  This
 * is mostly serialized outside of measure (in score), since columns and often an entire region
 * share measure formatting.  Measures also contain modifiers like barlines.  Tuplets and beam groups
 * are contained at the measure level.
 * @module /smo/data/measure
 */
const serializationHelpers_1 = __webpack_require__(/*! ../../common/serializationHelpers */ "./src/common/serializationHelpers.js");
const music_1 = __webpack_require__(/*! ./music */ "./src/smo/data/music.ts");
const measureModifiers_1 = __webpack_require__(/*! ./measureModifiers */ "./src/smo/data/measureModifiers.ts");
const note_1 = __webpack_require__(/*! ./note */ "./src/smo/data/note.ts");
const tuplet_1 = __webpack_require__(/*! ./tuplet */ "./src/smo/data/tuplet.ts");
const layoutDebug_1 = __webpack_require__(/*! ../../render/sui/layoutDebug */ "./src/render/sui/layoutDebug.ts");
const svgHelpers_1 = __webpack_require__(/*! ../../render/sui/svgHelpers */ "./src/render/sui/svgHelpers.ts");
const tickMap_1 = __webpack_require__(/*! ../xform/tickMap */ "./src/smo/xform/tickMap.ts");
const selections_1 = __webpack_require__(/*! ../xform/selections */ "./src/smo/xform/selections.ts");
// @internal
const VF = eval('Vex.Flow');
// @internal
exports.SmoMeasureNumberParams = ['padRight', 'transposeIndex', 'activeVoice', 'lines', 'repeatCount'];
// @internal
exports.SmoMeasureStringParams = ['timeSignatureString', 'keySignature'];
/**
 * Data for a measure of music.  Many rules of musical engraving are
 * enforced at a measure level: the duration of notes, accidentals, etc.
 *
 * Measures contain {@link SmoNote}, {@link SmoTuplet}, and {@link SmoBeamGroup}
 * Measures are contained in {@link SmoSystemStaff}
 * @category SmoObject
 */
class SmoMeasure {
    /**
     * Fill in components.  We assume the modifiers are already constructed,
     * e.g. by deserialize or the calling function.
     * @param params
     */
    constructor(params) {
        this.timeSignature = SmoMeasure.timeSignatureDefault;
        /**
         * Overrides display of actual time signature, in the case of
         * pick-up notes where the actual and displayed durations are different
         */
        this.timeSignatureString = '';
        this.keySignature = '';
        this.canceledKeySignature = '';
        this.padRight = 10;
        this.tuplets = [];
        this.repeatSymbol = false;
        this.repeatCount = 0;
        /**
         * Adjust for non-concert pitch intstruments
         */
        this.transposeIndex = 0;
        this.modifiers = [];
        /**
         * Row, column, and custom numbering information about this measure.
         */
        this.measureNumber = {
            localIndex: 0,
            systemIndex: 0,
            measureIndex: 0,
            staffId: 0
        };
        this.clef = 'treble';
        this.voices = [];
        /**
         * the active voice in the editor, if there are multiple voices
         *  */
        this.activeVoice = 0;
        this.beamGroups = [];
        this.lines = 5;
        this.tempo = new measureModifiers_1.SmoTempoText(measureModifiers_1.SmoTempoText.defaults);
        this.svg = {
            staffWidth: 0,
            unjustifiedWidth: 0,
            staffX: 0,
            staffY: 0,
            logicalBox: {
                x: 0, y: 0, width: 0, height: 0
            },
            yTop: 0,
            adjX: 0,
            adjRight: 0,
            history: [],
            lineIndex: 0,
            pageIndex: 0,
            rowInSystem: 0,
            forceClef: false,
            forceKeySignature: false,
            forceTimeSignature: false,
            forceTempo: false,
            hideEmptyMeasure: false,
            hideMultimeasure: false,
            multimeasureLength: 0,
            multimeasureEndBarline: measureModifiers_1.SmoBarline.barlines['singleBar'],
            element: null
        };
        const defaults = SmoMeasure.defaults;
        exports.SmoMeasureNumberParams.forEach((param) => {
            if (typeof (params[param]) !== 'undefined') {
                this[param] = params[param];
            }
        });
        exports.SmoMeasureStringParams.forEach((param) => {
            this[param] = params[param] ? params[param] : defaults[param];
        });
        this.clef = params.clef;
        this.repeatSymbol = params.repeatSymbol;
        this.measureNumber = JSON.parse(JSON.stringify(params.measureNumber));
        if (params.tempo) {
            this.tempo = new measureModifiers_1.SmoTempoText(params.tempo);
        }
        // Handle legacy time signature format
        if (params.timeSignature) {
            const tsAny = params.timeSignature;
            if (typeof (tsAny) === 'string') {
                this.timeSignature = SmoMeasure.convertLegacyTimeSignature(tsAny);
            }
            else {
                this.timeSignature = new measureModifiers_1.TimeSignature(tsAny);
            }
        }
        this.voices = params.voices ? params.voices : [];
        this.tuplets = params.tuplets ? params.tuplets : [];
        this.modifiers = params.modifiers ? params.modifiers : defaults.modifiers;
        this.setDefaultBarlines();
        this.keySignature = music_1.SmoMusic.vexKeySigWithOffset(this.keySignature, this.transposeIndex);
        if (!(params.format)) {
            this.format = new measureModifiers_1.SmoMeasureFormat(measureModifiers_1.SmoMeasureFormat.defaults);
            this.format.measureIndex = this.measureNumber.measureIndex;
        }
        else {
            this.format = new measureModifiers_1.SmoMeasureFormat(params.format);
        }
        this.attrs = {
            id: VF.Element.newID(),
            type: 'SmoMeasure'
        };
    }
    static get timeSignatureDefault() {
        return new measureModifiers_1.TimeSignature({
            actualBeats: 4,
            beatDuration: 4,
            useSymbol: false,
            display: true
        });
    }
    /**
     * Default constructor parameters.  Defaults are always copied so the
     * caller can modify them to create a new measure.
     * @returns constructor params for a new measure
     */
    static get defaults() {
        const proto = JSON.parse(JSON.stringify(SmoMeasure._defaults));
        proto.format = new measureModifiers_1.SmoMeasureFormat(measureModifiers_1.SmoMeasureFormat.defaults);
        proto.tempo = new measureModifiers_1.SmoTempoText(measureModifiers_1.SmoTempoText.defaults);
        proto.modifiers.push(new measureModifiers_1.SmoBarline({
            position: measureModifiers_1.SmoBarline.positions.start,
            barline: measureModifiers_1.SmoBarline.barlines.singleBar
        }));
        proto.modifiers.push(new measureModifiers_1.SmoBarline({
            position: measureModifiers_1.SmoBarline.positions.end,
            barline: measureModifiers_1.SmoBarline.barlines.singleBar
        }));
        return proto;
    }
    // @ignore
    static convertLegacyTimeSignature(ts) {
        const rv = new measureModifiers_1.TimeSignature(measureModifiers_1.TimeSignature.defaults);
        rv.timeSignature = ts;
        return rv;
    }
    // @internal
    // used for serialization
    static get defaultAttributes() {
        return [
            'keySignature', 'timeSignatureString',
            'measureNumber',
            'activeVoice', 'clef', 'transposeIndex',
            'format', 'rightMargin', 'lines', 'repeatSymbol', 'repeatCount'
        ];
    }
    // @internal
    // used for serialization
    static get formattingOptions() {
        return ['customStretch', 'customProportion', 'autoJustify', 'systemBreak',
            'pageBreak', 'padLeft'];
    }
    // @internal
    // used for serialization
    static get columnMappedAttributes() {
        return ['timeSignature', 'keySignature', 'tempo'];
    }
    static get serializableAttributes() {
        const rv = [];
        SmoMeasure.defaultAttributes.forEach((attr) => {
            if (SmoMeasure.columnMappedAttributes.indexOf(attr) < 0) {
                rv.push(attr);
            }
        });
        return rv;
    }
    /**
    // Return true if the time signatures are the same, for display purposes (e.g. if a time sig change
    // is required)
    */
    static timeSigEqual(o1, o2) {
        return o1.timeSignature === o2.timeSignature && o1.useSymbol === o2.useSymbol;
    }
    /**
     * @internal
     * @returns column mapped parameters, serialized.  caller will
     * decide if the parameters need to be persisted
     */
    serializeColumnMapped() {
        //
        return {
            timeSignature: this.timeSignature.serialize(),
            keySignature: this.keySignature,
            tempo: this.tempo.serialize()
        };
    }
    /**
     * Convert this measure object to a JSON object, recursively serializing all the notes,
     * note modifiers, etc.
     */
    serialize() {
        const params = {};
        let ser = true;
        const defaults = SmoMeasure.defaults;
        serializationHelpers_1.smoSerialize.serializedMergeNonDefault(SmoMeasure.defaults, SmoMeasure.serializableAttributes, this, params);
        // measure number can't be defaulted b/c tempos etc. can map to default measure
        params.measureNumber = JSON.parse(JSON.stringify(this.measureNumber));
        params.tuplets = [];
        params.voices = [];
        params.modifiers = [];
        this.tuplets.forEach((tuplet) => {
            params.tuplets.push(tuplet.serialize());
        });
        this.voices.forEach((voice) => {
            const obj = {
                notes: []
            };
            voice.notes.forEach((note) => {
                obj.notes.push(note.serialize());
            });
            params.voices.push(obj);
        });
        this.modifiers.forEach((modifier) => {
            ser = true;
            /* don't serialize default modifiers */
            if (modifier.ctor === 'SmoBarline' && modifier.position === measureModifiers_1.SmoBarline.positions.start &&
                modifier.barline === measureModifiers_1.SmoBarline.barlines.singleBar) {
                ser = false;
            }
            else if (modifier.ctor === 'SmoBarline' && modifier.position === measureModifiers_1.SmoBarline.positions.end
                && modifier.barline === measureModifiers_1.SmoBarline.barlines.singleBar) {
                ser = false;
            }
            else if (modifier.ctor === 'SmoTempoText') {
                // we don't save tempo text as a modifier anymore
                ser = false;
            }
            else if (modifier.ctor === 'SmoRepeatSymbol' && modifier.position === measureModifiers_1.SmoRepeatSymbol.positions.start
                && modifier.symbol === measureModifiers_1.SmoRepeatSymbol.symbols.None) {
                ser = false;
            }
            if (ser) {
                params.modifiers.push(modifier.serialize());
            }
        });
        // ['timeSignature', 'keySignature', 'tempo']
        return params;
    }
    /**
     * restore a serialized measure object.  Usually called as part of deserializing a score,
     * but can also be used to restore a measure due to an undo operation.  Recursively
     * deserialize all the notes and modifiers to construct a new measure.
     * @param jsonObj the serialized SmoMeasure
     * @returns
     */
    static deserialize(jsonObj) {
        let j = 0;
        let i = 0;
        const voices = [];
        const noteSum = [];
        for (j = 0; j < jsonObj.voices.length; ++j) {
            const voice = jsonObj.voices[j];
            const notes = [];
            voices.push({
                notes
            });
            for (i = 0; i < voice.notes.length; ++i) {
                const noteParams = voice.notes[i];
                const smoNote = note_1.SmoNote.deserialize(noteParams);
                notes.push(smoNote);
                noteSum.push(smoNote);
            }
        }
        const tuplets = [];
        for (j = 0; j < jsonObj.tuplets.length; ++j) {
            const tupJson = jsonObj.tuplets[j];
            const noteAr = noteSum.filter((nn) => nn.isTuplet && nn.tuplet.id === tupJson.attrs.id);
            // Bug fix:  A tuplet with no notes may be been overwritten
            // in a copy/paste operation
            if (noteAr.length > 0) {
                tupJson.notes = noteAr;
                const tuplet = new tuplet_1.SmoTuplet(tupJson);
                tuplets.push(tuplet);
            }
        }
        const modifiers = [];
        jsonObj.modifiers.forEach((modParams) => {
            const modifier = measureModifiers_1.SmoMeasureModifierBase.deserialize(modParams);
            modifiers.push(modifier);
        });
        const params = SmoMeasure.defaults;
        serializationHelpers_1.smoSerialize.serializedMerge(SmoMeasure.defaultAttributes, jsonObj, params);
        // explode column-mapped
        params.tempo = jsonObj.tempo;
        params.timeSignature = jsonObj.timeSignature;
        params.keySignature = jsonObj.keySignature;
        params.voices = voices;
        params.tuplets = tuplets;
        params.modifiers = modifiers;
        const rv = new SmoMeasure(params);
        // Handle migration for measure-mapped parameters
        rv.modifiers.forEach((mod) => {
            if (mod.ctor === 'SmoTempoText') {
                rv.tempo = mod;
            }
        });
        if (!rv.tempo) {
            rv.tempo = new measureModifiers_1.SmoTempoText(measureModifiers_1.SmoTempoText.defaults);
        }
        return rv;
    }
    /**
     * When creating a new measure, the 'default' settings can vary depending on
     * what comes before/after the measure.  This determines the default pitch
     * for a clef (appears on 3rd line)
     */
    static get defaultPitchForClef() {
        return {
            'treble': {
                letter: 'b',
                accidental: 'n',
                octave: 4
            },
            'bass': {
                letter: 'd',
                accidental: 'n',
                octave: 3
            },
            'tenor': {
                letter: 'a',
                accidental: 'n',
                octave: 3
            },
            'alto': {
                letter: 'c',
                accidental: 'n',
                octave: 4
            },
            'soprano': {
                letter: 'b',
                accidental: 'n',
                octave: 4
            },
            'percussion': {
                letter: 'b',
                accidental: 'n',
                octave: 4
            },
            'mezzo-soprano': {
                letter: 'b',
                accidental: 'n',
                octave: 4
            },
            'baritone-c': {
                letter: 'b',
                accidental: 'n',
                octave: 3
            },
            'baritone-f': {
                letter: 'e',
                accidental: 'n',
                octave: 3
            },
            'subbass': {
                letter: 'd',
                accidental: '',
                octave: 2
            },
            'french': {
                letter: 'b',
                accidental: '',
                octave: 4
            } // no idea
        };
    }
    static set emptyMeasureNoteType(tt) {
        SmoMeasure._emptyMeasureNoteType = tt;
    }
    static get emptyMeasureNoteType() {
        return SmoMeasure._emptyMeasureNoteType;
    }
    static timeSignatureNotes(timeSignature, clef) {
        const pitch = SmoMeasure.defaultPitchForClef[clef];
        const maxTicks = music_1.SmoMusic.timeSignatureToTicks(timeSignature.timeSignature);
        const noteTick = 8192 / (timeSignature.beatDuration / 2);
        let ticks = 0;
        let beamBeats = 2;
        if (timeSignature.beatDuration === 8 && (timeSignature.actualBeats % 3 === 0 || timeSignature.actualBeats % 2 !== 0)) {
            beamBeats = 3;
        }
        if (timeSignature.beatDuration === 16) {
            beamBeats = 4;
        }
        const pnotes = [];
        while (ticks < maxTicks) {
            const nextNote = note_1.SmoNote.defaults;
            nextNote.pitches = [JSON.parse(JSON.stringify(pitch))];
            nextNote.noteType = 'r';
            nextNote.clef = clef;
            nextNote.ticks.numerator = noteTick;
            pnotes.push(new note_1.SmoNote(nextNote));
            ticks += noteTick;
        }
        if (timeSignature.beatDuration === 8 && (timeSignature.actualBeats % 3 === 0 || timeSignature.actualBeats % 2 !== 0)) {
            let ix = 0;
            pnotes.forEach((pnote) => {
                if ((ix + 1) % 3 === 0) {
                    pnote.endBeam = true;
                }
                pnote.beamBeats = 2048 * 3;
                ix += 1;
            });
        }
        return pnotes;
    }
    /**
     * Get a measure full of default notes for a given timeSignature/clef.
     * returns 8th notes for triple-time meters, etc.
     * @param params
     * @returns
     */
    static getDefaultNotes(params) {
        return SmoMeasure.timeSignatureNotes(new measureModifiers_1.TimeSignature(params.timeSignature), params.clef);
    }
    /**
     * When creating a new measure, the 'default' settings can vary depending on
     * what comes before/after the measure.  This determines the defaults from the
     * parameters that are passed in, which could be another measure in the score.
     * This version returns params with no notes, for callers that want to use their own notes.
     * If you want the default notes, see {@link getDefaultMeasureWithNotes}
     *
     * @param params
     * @returns
     */
    static getDefaultMeasure(params) {
        const obj = {};
        serializationHelpers_1.smoSerialize.serializedMerge(SmoMeasure.defaultAttributes, SmoMeasure.defaults, obj);
        serializationHelpers_1.smoSerialize.serializedMerge(SmoMeasure.defaultAttributes, params, obj);
        // Don't copy column-formatting options to new measure in new column
        serializationHelpers_1.smoSerialize.serializedMerge(SmoMeasure.formattingOptions, SmoMeasure.defaults, obj);
        obj.timeSignature = new measureModifiers_1.TimeSignature(params.timeSignature);
        // The measure expects to get concert KS in constructor and adjust for instrument.  So do the
        // opposite.
        obj.keySignature = music_1.SmoMusic.vexKeySigWithOffset(obj.keySignature, -1 * obj.transposeIndex);
        // Don't redisplay tempo for a new measure
        const rv = new SmoMeasure(obj);
        if (rv.tempo && rv.tempo.display) {
            rv.tempo.display = false;
        }
        return rv;
    }
    /**
     * When creating a new measure, the 'default' settings can vary depending on
     * what comes before/after the measure.  This determines the defaults from the
     * parameters that are passed in, which could be another measure in the score.
     *
     * @param params
     * @returns
     */
    static getDefaultMeasureWithNotes(params) {
        var measure = SmoMeasure.getDefaultMeasure(params);
        measure.voices.push({
            notes: SmoMeasure.getDefaultNotes(params)
        });
        // fix a bug.
        // new measures only have 1 voice, make sure active voice is 0
        measure.activeVoice = 0;
        return measure;
    }
    /**
     * used by xml export
     * @internal
     * @param val
     */
    getForceSystemBreak() {
        return this.format.systemBreak;
    }
    // @internal
    setDefaultBarlines() {
        if (!this.getStartBarline()) {
            this.modifiers.push(new measureModifiers_1.SmoBarline({
                position: measureModifiers_1.SmoBarline.positions.start,
                barline: measureModifiers_1.SmoBarline.barlines.singleBar
            }));
        }
        if (!this.getEndBarline()) {
            this.modifiers.push(new measureModifiers_1.SmoBarline({
                position: measureModifiers_1.SmoBarline.positions.end,
                barline: measureModifiers_1.SmoBarline.barlines.singleBar
            }));
        }
    }
    get containsSound() {
        let i = 0;
        for (i = 0; i < this.voices.length; ++i) {
            let j = 0;
            const voice = this.voices[i];
            for (j = 0; j < this.voices.length; ++j) {
                if (voice.notes[j].noteType === 'n') {
                    return true;
                }
            }
        }
        return false;
    }
    /**
     * The rendered width of the measure, or estimate of same
     */
    get staffWidth() {
        return this.svg.staffWidth;
    }
    /**
     * set the rendered width of the measure, or estimate of same
     */
    setWidth(width, description) {
        if (layoutDebug_1.layoutDebug.flagSet(layoutDebug_1.layoutDebug.values.measureHistory)) {
            this.svg.history.push('setWidth ' + this.staffWidth + '=> ' + width + ' ' + description);
        }
        if (isNaN(width)) {
            throw ('NAN in setWidth');
        }
        this.svg.staffWidth = width;
    }
    /**
     * Get rendered or estimated start x
     */
    get staffX() {
        return this.svg.staffX;
    }
    /**
     * Set rendered or estimated start x
     */
    setX(x, description) {
        if (isNaN(x)) {
            throw ('NAN in setX');
        }
        layoutDebug_1.layoutDebug.measureHistory(this, 'staffX', x, description);
        this.svg.staffX = Math.round(x);
    }
    /**
     * Get rendered or estimated start y
     */
    get staffY() {
        return this.svg.staffY;
    }
    /**
     * Set rendered or estimated start y
     */
    setY(y, description) {
        if (isNaN(y)) {
            throw ('NAN in setY');
        }
        layoutDebug_1.layoutDebug.measureHistory(this, 'staffY', y, description);
        this.svg.staffY = Math.round(y);
    }
    /**
     * Return actual or estimated highest point in score
     */
    get yTop() {
        return this.svg.yTop;
    }
    /**
     * WHen setting an instrument, offset the pitches to match the instrument key
     * @param offset
     * @param newClef
     */
    transposeToOffset(offset, targetKey, newClef) {
        const diff = offset - this.transposeIndex;
        this.voices.forEach((voice) => {
            voice.notes.forEach((note) => {
                const pitches = [...Array(note.pitches.length).keys()];
                // when the note is a rest, preserve the rest but match the new clef.
                if (newClef && note.noteType === 'r') {
                    const defp = JSON.parse(JSON.stringify(SmoMeasure.defaultPitchForClef[newClef]));
                    note.pitches = [defp];
                }
                else {
                    note.transpose(pitches, diff, this.keySignature, targetKey);
                    note.getGraceNotes().forEach((gn) => {
                        const gpitch = [...Array(gn.pitches.length).keys()];
                        const xpose = note_1.SmoNote.transpose(gn, gpitch, diff, this.keySignature, targetKey);
                        gn.pitches = xpose.pitches;
                    });
                }
            });
        });
    }
    /**
     * Return actual or estimated highest point in score
     */
    setYTop(y, description) {
        layoutDebug_1.layoutDebug.measureHistory(this, 'yTop', y, description);
        this.svg.yTop = y;
    }
    /**
     * Return actual or estimated bounding box
     */
    setBox(box, description) {
        layoutDebug_1.layoutDebug.measureHistory(this, 'logicalBox', box, description);
        this.svg.logicalBox = svgHelpers_1.SvgHelpers.smoBox(box);
    }
    /**
     * @returns the DOM identifier for this measure when rendered
     */
    getClassId() {
        return 'mm-' + this.measureNumber.staffId + '-' + this.measureNumber.measureIndex;
    }
    /**
     *
     * @param id
     * @returns
     */
    getRenderedNote(id) {
        let j = 0;
        let i = 0;
        for (j = 0; j < this.voices.length; ++j) {
            const voice = this.voices[j];
            for (i = 0; i < voice.notes.length; ++i) {
                const note = voice.notes[i];
                if (note.renderId === id) {
                    return {
                        smoNote: note,
                        voice: j,
                        tick: i
                    };
                }
            }
        }
        return null;
    }
    getNotes() {
        return this.voices[this.activeVoice].notes;
    }
    getActiveVoice() {
        return this.activeVoice;
    }
    setActiveVoice(vix) {
        if (vix >= 0 && vix < this.voices.length) {
            this.activeVoice = vix;
        }
    }
    tickmapForVoice(voiceIx) {
        return new tickMap_1.TickMap(this, voiceIx);
    }
    // ### createMeasureTickmaps
    // A tickmap is a map of notes to ticks for the measure.  It is speciifc per-voice
    // since each voice may have different numbers of ticks.  The accidental map is
    // overall since accidentals in one voice apply to accidentals in the other
    // voices.  So we return the tickmaps and the overall accidental map.
    createMeasureTickmaps() {
        let i = 0;
        const tickmapArray = [];
        const accidentalMap = {};
        for (i = 0; i < this.voices.length; ++i) {
            tickmapArray.push(this.tickmapForVoice(i));
        }
        for (i = 0; i < this.voices.length; ++i) {
            const tickmap = tickmapArray[i];
            const durationKeys = Object.keys((tickmap.durationAccidentalMap));
            durationKeys.forEach((durationKey) => {
                if (!accidentalMap[durationKey]) {
                    accidentalMap[durationKey] = tickmap.durationAccidentalMap[durationKey];
                }
                else {
                    const amap = accidentalMap[durationKey];
                    const tickable = tickmap.durationAccidentalMap[durationKey];
                    const letterKeys = Object.keys(tickable);
                    letterKeys.forEach((pitchKey) => {
                        if (!amap[pitchKey]) {
                            amap[pitchKey] = tickmap.durationAccidentalMap[durationKey][pitchKey];
                        }
                    });
                }
            });
        }
        // duration: duration, pitches: Record<PitchLetter,TickAccidental>
        const accidentalArray = [];
        Object.keys(accidentalMap).forEach((durationKey) => {
            accidentalArray.push({ duration: durationKey, pitches: accidentalMap[durationKey] });
        });
        return {
            tickmaps: tickmapArray,
            accidentalMap,
            accidentalArray
        };
    }
    // ### createRestNoteWithDuration
    // pad some duration of music with rests.
    static createRestNoteWithDuration(duration, clef) {
        const pitch = JSON.parse(JSON.stringify(SmoMeasure.defaultPitchForClef[clef]));
        const note = new note_1.SmoNote(note_1.SmoNote.defaults);
        note.pitches = [pitch];
        note.noteType = 'r';
        note.hidden = true;
        note.ticks = { numerator: duration, denominator: 1, remainder: 0 };
        return note;
    }
    /**
     * Count the number of ticks in each voice and return max
     * @returns
     */
    getMaxTicksVoice() {
        let i = 0;
        let max = 0;
        for (i = 0; i < this.voices.length; ++i) {
            const voiceTicks = this.getTicksFromVoice(i);
            max = Math.max(voiceTicks, max);
        }
        return max;
    }
    /**
     * Count the number of ticks in a specific voice
     * @param voiceIndex
     * @returns
     */
    getTicksFromVoice(voiceIndex) {
        let ticks = 0;
        this.voices[voiceIndex].notes.forEach((note) => {
            ticks += note.tickCount;
        });
        return ticks;
    }
    getClosestTickCountIndex(voiceIndex, tickCount) {
        let i = 0;
        let rv = 0;
        for (i = 0; i < this.voices[voiceIndex].notes.length; ++i) {
            const note = this.voices[voiceIndex].notes[i];
            if (note.tickCount + rv > tickCount) {
                return rv;
            }
            rv += note.tickCount;
        }
        return rv;
    }
    isPickup() {
        const ticks = this.getTicksFromVoice(0);
        const goal = music_1.SmoMusic.timeSignatureToTicks(this.timeSignature.timeSignature);
        return (ticks < goal);
    }
    clearBeamGroups() {
        this.beamGroups = [];
    }
    // ### updateLyricFont
    // Update the lyric font, which is the same for all lyrics.
    setLyricFont(fontInfo) {
        this.voices.forEach((voice) => {
            voice.notes.forEach((note) => {
                note.setLyricFont(fontInfo);
            });
        });
    }
    setLyricAdjustWidth(adjustNoteWidth) {
        this.voices.forEach((voice) => {
            voice.notes.forEach((note) => {
                note.setLyricAdjustWidth(adjustNoteWidth);
            });
        });
    }
    setChordAdjustWidth(adjustNoteWidth) {
        this.voices.forEach((voice) => {
            voice.notes.forEach((note) => {
                note.setChordAdjustWidth(adjustNoteWidth);
            });
        });
    }
    // ### updateLyricFont
    // Update the lyric font, which is the same for all lyrics.
    setChordFont(fontInfo) {
        this.voices.forEach((voice) => {
            voice.notes.forEach((note) => {
                note.setChordFont(fontInfo);
            });
        });
    }
    // ### tuplet methods.
    //
    // #### tupletNotes
    tupletNotes(tuplet) {
        let j = 0;
        let i = 0;
        const tnotes = [];
        for (j = 0; j < this.voices.length; ++j) {
            const vnotes = this.voices[j].notes;
            for (i = 0; i < vnotes.length; ++i) {
                const note = vnotes[i];
                if (note.tuplet && note.tuplet.id === tuplet.attrs.id) {
                    tnotes.push(vnotes[i]);
                }
            }
        }
        return tnotes;
    }
    // #### tupletIndex
    // return the index of the given tuplet
    tupletIndex(tuplet) {
        let j = 0;
        let i = 0;
        for (j = 0; j < this.voices.length; ++j) {
            const notes = this.voices[j].notes;
            for (i = 0; i < notes.length; ++i) {
                const note = notes[i];
                if (note.tuplet && note.tuplet.id === tuplet.attrs.id) {
                    return i;
                }
            }
        }
        return -1;
    }
    // #### getTupletForNote
    // Finds the tuplet for a given note, or null if there isn't one.
    getTupletForNote(note) {
        let i = 0;
        if (!note) {
            return null;
        }
        if (!note.isTuplet) {
            return null;
        }
        for (i = 0; i < this.tuplets.length; ++i) {
            const tuplet = this.tuplets[i];
            if (note.tuplet !== null && tuplet.attrs.id === note.tuplet.id) {
                return tuplet;
            }
        }
        return null;
    }
    removeTupletForNote(note) {
        let i = 0;
        const tuplets = [];
        for (i = 0; i < this.tuplets.length; ++i) {
            const tuplet = this.tuplets[i];
            if (note.tuplet !== null && note.tuplet.id !== tuplet.attrs.id) {
                tuplets.push(tuplet);
            }
        }
        this.tuplets = tuplets;
    }
    setClef(clef) {
        const oldClef = this.clef;
        this.clef = clef;
        this.voices.forEach((voice) => {
            voice.notes.forEach((note) => {
                note.clef = clef;
            });
        });
    }
    isRest() {
        let i = 0;
        for (i = 0; i < this.voices.length; ++i) {
            const voice = this.voices[i];
            for (var j = 0; j < voice.notes.length; ++j) {
                if (!voice.notes[j].isRest()) {
                    return false;
                }
            }
        }
        return true;
    }
    // ### populateVoice
    // Create a new voice in this measure, and populate it with the default note
    // for this measure/key/clef
    populateVoice(index) {
        if (index !== this.voices.length) {
            return;
        }
        this.voices.push({ notes: SmoMeasure.getDefaultNotes(this) });
        this.activeVoice = index;
    }
    _removeSingletonModifier(name) {
        const ar = this.modifiers.filter(obj => obj.attrs.type !== name);
        this.modifiers = ar;
    }
    addRehearsalMark(parameters) {
        this._removeSingletonModifier('SmoRehearsalMark');
        this.modifiers.push(new measureModifiers_1.SmoRehearsalMark(parameters));
    }
    removeRehearsalMark() {
        this._removeSingletonModifier('SmoRehearsalMark');
    }
    getRehearsalMark() {
        return this.modifiers.find(obj => obj.attrs.type === 'SmoRehearsalMark');
    }
    getModifiersByType(type) {
        return this.modifiers.filter((mm) => type === mm.attrs.type);
    }
    setTempo(params) {
        this.tempo = new measureModifiers_1.SmoTempoText(params);
    }
    /**
     * Set measure tempo to the default {@link SmoTempoText}
     */
    resetTempo() {
        this.tempo = new measureModifiers_1.SmoTempoText(measureModifiers_1.SmoTempoText.defaults);
    }
    getTempo() {
        if (typeof (this.tempo) === 'undefined') {
            this.tempo = new measureModifiers_1.SmoTempoText(measureModifiers_1.SmoTempoText.defaults);
        }
        return this.tempo;
    }
    /**
     * Measure text is deprecated, and may not be supported in the future.
     * Better to use SmoTextGroup and attach to the measure.
     * @param mod
     * @returns
     */
    addMeasureText(mod) {
        var exist = this.modifiers.filter((mm) => mm.attrs.id === mod.attrs.id);
        if (exist.length) {
            return;
        }
        this.modifiers.push(mod);
    }
    getMeasureText() {
        return this.modifiers.filter(obj => obj.ctor === 'SmoMeasureText');
    }
    removeMeasureText(id) {
        var ar = this.modifiers.filter(obj => obj.attrs.id !== id);
        this.modifiers = ar;
    }
    setRepeatSymbol(rs) {
        const ar = [];
        let toAdd = true;
        const exSymbol = this.getRepeatSymbol();
        if (exSymbol && exSymbol.symbol === rs.symbol) {
            toAdd = false;
        }
        this.modifiers.forEach((modifier) => {
            if (modifier.ctor !== 'SmoRepeatSymbol') {
                ar.push(modifier);
            }
        });
        this.modifiers = ar;
        if (toAdd) {
            ar.push(rs);
        }
    }
    getRepeatSymbol() {
        const rv = this.modifiers.filter(obj => obj.ctor === 'SmoRepeatSymbol');
        if (rv.length > 0) {
            return rv[0];
        }
        return null;
    }
    clearRepeatSymbols() {
        const ar = [];
        this.modifiers.forEach((modifier) => {
            if (modifier.ctor !== 'SmoRepeatSymbol') {
                ar.push(modifier);
            }
        });
        this.modifiers = ar;
    }
    setBarline(barline) {
        var ar = [];
        this.modifiers.forEach((modifier) => {
            if (modifier.ctor === 'SmoBarline') {
                const o = modifier;
                if (o.position !== barline.position) {
                    ar.push(o);
                }
            }
            else {
                ar.push(modifier);
            }
        });
        this.modifiers = ar;
        ar.push(barline);
    }
    _getBarline(pos) {
        let rv = null;
        this.modifiers.forEach((modifier) => {
            if (modifier.ctor === 'SmoBarline' && modifier.position === pos) {
                rv = modifier;
            }
        });
        if (rv === null) {
            return new measureModifiers_1.SmoBarline(measureModifiers_1.SmoBarline.defaults);
        }
        return rv;
    }
    getEndBarline() {
        return this._getBarline(measureModifiers_1.SmoBarline.positions.end);
    }
    getStartBarline() {
        return this._getBarline(measureModifiers_1.SmoBarline.positions.start);
    }
    addNthEnding(ending) {
        const mods = [];
        this.modifiers.forEach((modifier) => {
            if (modifier.ctor !== 'SmoVolta' || modifier.startBar !== ending.startBar ||
                modifier.endBar !== ending.endBar) {
                mods.push(modifier);
            }
        });
        mods.push(ending);
        this.modifiers = mods;
    }
    removeNthEnding(ending) {
        const mods = [];
        this.modifiers.forEach((modifier) => {
            if (modifier.ctor === 'SmoVolta') {
                const volta = modifier;
                if (ending.startSelector === null || ending.endSelector === null || volta.startSelector === null || volta.endSelector === null) {
                    return;
                }
                if (!selections_1.SmoSelector.sameMeasure(ending.startSelector, volta.startSelector) || !selections_1.SmoSelector.sameMeasure(ending.endSelector, volta.endSelector)
                    && ending.number !== volta.number) {
                    mods.push(modifier);
                }
            }
            else {
                mods.push(modifier);
            }
        });
        this.modifiers = mods;
    }
    getNthEndings() {
        const rv = [];
        this.modifiers.forEach((modifier) => {
            if (modifier.ctor === 'SmoVolta') {
                rv.push(modifier);
            }
        });
        return rv;
    }
    getEndEndings() {
        const rv = [];
        this.modifiers.forEach((modifier) => {
            if (modifier.ctor === 'SmoVolta' && modifier.endBar === this.measureNumber.systemIndex
                && modifier.startBar !== this.measureNumber.systemIndex) {
                rv.push(modifier);
            }
        });
        return rv;
    }
    getMidEndings() {
        const rv = [];
        this.modifiers.forEach((modifier) => {
            if (modifier.ctor === 'SmoVolta' && modifier.endBar > this.measureNumber.systemIndex
                && modifier.startBar < this.measureNumber.systemIndex) {
                rv.push(modifier);
            }
        });
        return rv;
    }
    setKeySignature(sig) {
        this.keySignature = sig;
        this.voices.forEach((voice) => {
            voice.notes.forEach((note) => {
                note.keySignature = sig;
            });
        });
    }
    setMeasureNumber(num) {
        this.measureNumber = num;
    }
    getBeamGroupForNote(note) {
        let i = 0;
        let j = 0;
        for (i = 0; i < this.beamGroups.length; ++i) {
            const bg = this.beamGroups[i];
            for (j = 0; j < bg.notes.length; ++j) {
                if (bg.notes[j].attrs.id === note.attrs.id) {
                    return bg;
                }
            }
        }
        return null;
    }
}
exports.SmoMeasure = SmoMeasure;
SmoMeasure.defaultDupleDuration = 4096;
SmoMeasure.defaultTripleDuration = 2048 * 3;
// @internal
SmoMeasure._defaults = {
    timeSignature: SmoMeasure.timeSignatureDefault,
    timeSignatureString: '',
    keySignature: 'C',
    padRight: 10,
    tuplets: [],
    transposeIndex: 0,
    modifiers: [],
    staffY: 40,
    // bars: [1, 1], // follows enumeration in VF.Barline
    measureNumber: {
        localIndex: 0,
        systemIndex: 0,
        measureIndex: 0,
        staffId: 0
    },
    clef: 'treble',
    lines: 5,
    voices: [],
    format: new measureModifiers_1.SmoMeasureFormat(measureModifiers_1.SmoMeasureFormat.defaults),
    activeVoice: 0,
    tempo: new measureModifiers_1.SmoTempoText(measureModifiers_1.SmoTempoText.defaults),
    repeatSymbol: false,
    repeatCount: 0
};
SmoMeasure._emptyMeasureNoteType = 'r';


/***/ }),

/***/ "./src/smo/data/measureModifiers.ts":
/*!******************************************!*\
  !*** ./src/smo/data/measureModifiers.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TimeSignature = exports.SmoTempoText = exports.SmoRehearsalMark = exports.SmoMeasureText = exports.SmoVolta = exports.SmoRepeatSymbol = exports.SmoBarline = exports.SmoMeasureFormat = exports.SmoMeasureFormatBooleanKeys = exports.SmoMeasureFormatNumberKeys = exports.SmoMeasureModifierBase = void 0;
// [Smoosic](https://github.com/AaronDavidNewman/Smoosic)
// Copyright (c) Aaron David Newman 2021.
/**
 * @module /smo/data/measureModifiers
 * **/
const serializationHelpers_1 = __webpack_require__(/*! ../../common/serializationHelpers */ "./src/common/serializationHelpers.js");
const music_1 = __webpack_require__(/*! ./music */ "./src/smo/data/music.ts");
const VF = eval('Vex.Flow');
/**
 * Measure modifiers are attached to the measure itself.  Each instance has a
 * `serialize()` method and a `ctor` attribute for deserialization.
 * @category SmoModifier
 */
class SmoMeasureModifierBase {
    constructor(ctor) {
        this.logicalBox = null;
        this.ctor = ctor;
        this.attrs = {
            id: VF.Element.newID(),
            type: ctor
        };
    }
    static deserialize(jsonObj) {
        const ctor = eval('globalThis.Smo.' + jsonObj.ctor);
        const rv = new ctor(jsonObj);
        return rv;
    }
}
exports.SmoMeasureModifierBase = SmoMeasureModifierBase;
exports.SmoMeasureFormatNumberKeys = ['customStretch', 'proportionality', 'padLeft', 'measureIndex'];
exports.SmoMeasureFormatBooleanKeys = ['autoJustify', 'skipMeasureCount', 'systemBreak', 'pageBreak', 'padAllInSystem', 'restBreak', 'forceRest'];
/**
 * Measure format holds parameters about the automatic formatting of the measure itself, such as the witch and
 * how the durations are proportioned.  Note that measure formatting is also controlled by the justification
 * between voices and staves.  For instance, 2 measures in different staves will have to have the same width
 * @category SmoModifier
 */
class SmoMeasureFormat extends SmoMeasureModifierBase {
    constructor(parameters) {
        super('SmoMeasureFormat');
        this.customStretch = SmoMeasureFormat.defaultProportionality;
        this.proportionality = 0;
        this.systemBreak = false;
        this.pageBreak = false;
        this.restBreak = false;
        this.skipMeasureCount = false;
        this.forceRest = false;
        this.padLeft = 0;
        this.padAllInSystem = true;
        this.autoJustify = true;
        this.measureIndex = 0;
        const def = SmoMeasureFormat.defaults;
        exports.SmoMeasureFormatNumberKeys.forEach((param) => {
            this[param] = parameters[param] ? parameters[param] : def[param];
        });
        exports.SmoMeasureFormatBooleanKeys.forEach((param) => {
            this[param] = parameters[param] ? parameters[param] : def[param];
        });
    }
    static get attributes() {
        return ['customStretch', 'proportionality', 'autoJustify', 'systemBreak', 'pageBreak',
            'padLeft', 'measureIndex', 'padAllInSystem', 'skipMeasureCount', 'restBreak', 'forceRest'];
    }
    static get formatAttributes() {
        return ['customStretch', 'skipMeasureCount', 'proportionality', 'autoJustify', 'systemBreak', 'pageBreak', 'padLeft'];
    }
    static get defaultProportionality() {
        return 0;
    }
    static get legacyProportionality() {
        return 0;
    }
    static fromLegacyMeasure(measure) {
        const o = {};
        SmoMeasureFormat.formatAttributes.forEach((attr) => {
            if (typeof (measure[attr]) !== 'undefined') {
                o[attr] = measure[attr];
            }
            else {
                const rhs = SmoMeasureFormat.defaults[attr];
                o[attr] = rhs;
            }
            o.measureIndex = measure.measureNumber.measureIndex;
        });
        return new SmoMeasureFormat(o);
    }
    static get defaults() {
        return JSON.parse(JSON.stringify({
            customStretch: 0,
            proportionality: SmoMeasureFormat.defaultProportionality,
            systemBreak: false,
            pageBreak: false,
            restBreak: false,
            forceRest: false,
            padLeft: 0,
            padAllInSystem: true,
            skipMeasureCount: false,
            autoJustify: true,
            measureIndex: 0,
        }));
    }
    eq(o) {
        let rv = true;
        exports.SmoMeasureFormatBooleanKeys.forEach((attr) => {
            if (o[attr] !== this[attr]) {
                rv = false;
            }
        });
        exports.SmoMeasureFormatNumberKeys.forEach((attr) => {
            if (o[attr] !== this[attr] && attr !== 'measureIndex') {
                rv = false;
            }
        });
        return rv;
    }
    get isDefault() {
        return this.eq(SmoMeasureFormat.defaults);
    }
    formatMeasure(mm) {
        mm.format = new SmoMeasureFormat(this);
        mm.format.measureIndex = mm.measureNumber.measureIndex;
    }
    serialize() {
        const params = { ctor: 'SmoMeasureFormat' };
        serializationHelpers_1.smoSerialize.serializedMergeNonDefault(SmoMeasureFormat.defaults, SmoMeasureFormat.attributes, this, params);
        return params;
    }
}
exports.SmoMeasureFormat = SmoMeasureFormat;
/**
 * Barline is just that, there is a start and end in each measure, which defaults to 'single'.
 * @category SmoModifier
 */
class SmoBarline extends SmoMeasureModifierBase {
    constructor(parameters) {
        super('SmoBarline');
        this.barline = SmoBarline.barlines.singleBar;
        this.position = SmoBarline.positions.start;
        let ops = parameters;
        if (typeof (parameters) === 'undefined' || parameters === null) {
            ops = {};
        }
        serializationHelpers_1.smoSerialize.serializedMerge(SmoBarline.attributes, SmoBarline.defaults, this);
        serializationHelpers_1.smoSerialize.serializedMerge(SmoBarline.attributes, ops, this);
    }
    static get _barlineToString() {
        return ['singleBar', 'doubleBar', 'endBar', 'startRepeat', 'endRepeat', 'noBar'];
    }
    static barlineString(inst) {
        return SmoBarline._barlineToString[inst.barline];
    }
    static get defaults() {
        return JSON.parse(JSON.stringify({
            position: SmoBarline.positions.end,
            barline: SmoBarline.barlines.singleBar
        }));
    }
    static get attributes() {
        return ['position', 'barline'];
    }
    serialize() {
        const params = {};
        serializationHelpers_1.smoSerialize.serializedMergeNonDefault(SmoBarline.defaults, SmoBarline.attributes, this, params);
        params.ctor = 'SmoBarline';
        return params;
    }
    static get toVexBarline() {
        return [VF.Barline.type.SINGLE, VF.Barline.type.DOUBLE, VF.Barline.type.END,
            VF.Barline.type.REPEAT_BEGIN, VF.Barline.type.REPEAT_END, VF.Barline.type.NONE];
    }
    static get toVexPosition() {
        return [VF.StaveModifier.BEGIN, VF.StaveModifier.END];
    }
    toVexBarline() {
        return SmoBarline.toVexBarline[this.barline];
    }
    toVexPosition() {
        return SmoBarline.toVexPosition[this.position];
    }
}
exports.SmoBarline = SmoBarline;
SmoBarline.positions = {
    start: 0,
    end: 1
};
SmoBarline.barlines = {
    singleBar: 0,
    doubleBar: 1,
    endBar: 2,
    startRepeat: 3,
    endRepeat: 4,
    noBar: 5
};
/**
 * Repeat symbols like DC, Fine etc.  Note: voltas are their own thing,
 * and repeats are types of barlines.
 * @category SmoModifier
 */
class SmoRepeatSymbol extends SmoMeasureModifierBase {
    constructor(parameters) {
        super('SmoRepeatSymbol');
        this.symbol = SmoRepeatSymbol.symbols.Coda;
        this.xOffset = 0;
        this.yOffset = 30;
        this.position = SmoRepeatSymbol.positions.end;
        serializationHelpers_1.smoSerialize.serializedMerge(SmoRepeatSymbol.attributes, SmoRepeatSymbol.defaults, this);
        this.xOffset = SmoRepeatSymbol.defaultXOffset[parameters.symbol];
        serializationHelpers_1.smoSerialize.serializedMerge(SmoRepeatSymbol.attributes, parameters, this);
    }
    static get defaults() {
        return JSON.parse(JSON.stringify({
            symbol: SmoRepeatSymbol.symbols.Coda,
            xOffset: 0,
            yOffset: 30,
            position: SmoRepeatSymbol.positions.end
        }));
    }
    static get toVexSymbol() {
        return [VF.Repetition.type.NONE, VF.Repetition.type.CODA_LEFT, VF.Repetition.type.SEGNO_LEFT, VF.Repetition.type.DC,
            VF.Repetition.type.DC_AL_CODA, VF.Repetition.type.DC_AL_FINE, VF.Repetition.type.DS,
            VF.Repetition.type.DS_AL_CODA, VF.Repetition.type.DS_AL_FINE, VF.Repetition.type.FINE];
    }
    static get attributes() {
        return ['symbol', 'xOffset', 'yOffset', 'position'];
    }
    toVexSymbol() {
        return SmoRepeatSymbol.toVexSymbol[this.symbol];
    }
    serialize() {
        const params = {};
        serializationHelpers_1.smoSerialize.serializedMergeNonDefault(SmoRepeatSymbol.defaults, SmoRepeatSymbol.attributes, this, params);
        params.ctor = 'SmoRepeatSymbol';
        return params;
    }
}
exports.SmoRepeatSymbol = SmoRepeatSymbol;
SmoRepeatSymbol.symbols = {
    None: 0,
    Coda: 1,
    Segno: 2,
    Dc: 3,
    ToCoda: 1,
    DcAlCoda: 4,
    DcAlFine: 5,
    Ds: 6,
    DsAlCoda: 7,
    DsAlFine: 8,
    Fine: 9
};
SmoRepeatSymbol.defaultXOffset = [0, 0, 0, -20, -60, -60, -50, -60, -50, -40];
SmoRepeatSymbol.positions = {
    start: 0,
    end: 1
};
/**
 * Voltas (2nd endings) behave more like staff modifiers, but they are associated with the measure
 * since each measure has it's own rules for displaying part of the volta.
 * @category SmoModifier
 */
class SmoVolta extends SmoMeasureModifierBase {
    constructor(parameters) {
        super('SmoVolta');
        this.startBar = 1;
        this.endBar = 1;
        this.xOffsetStart = 0;
        this.xOffsetEnd = 0;
        this.yOffset = 20;
        this.number = 1;
        this.endingId = null;
        this.startSelector = null;
        this.endSelector = null;
        this.elements = [];
        serializationHelpers_1.smoSerialize.serializedMerge(SmoVolta.attributes, SmoVolta.defaults, this);
        serializationHelpers_1.smoSerialize.serializedMerge(SmoVolta.attributes, parameters, this);
    }
    get id() {
        return this.attrs.id;
    }
    get type() {
        return this.attrs.type;
    }
    static get attributes() {
        return ['startBar', 'endBar', 'endingId', 'startSelector', 'endSelector', 'xOffsetStart', 'xOffsetEnd', 'yOffset', 'number'];
    }
    static get editableAttributes() {
        return ['xOffsetStart', 'xOffsetEnd', 'yOffset', 'number'];
    }
    serialize() {
        const params = {};
        serializationHelpers_1.smoSerialize.serializedMergeNonDefault(SmoVolta.defaults, SmoVolta.attributes, this, params);
        params.ctor = 'SmoVolta';
        return params;
    }
    static get defaults() {
        return JSON.parse(JSON.stringify({
            startBar: 1,
            endBar: 1,
            xOffsetStart: 0,
            xOffsetEnd: 0,
            yOffset: 20,
            number: 1
        }));
    }
    toVexVolta(measureNumber) {
        if (this.startBar === measureNumber && this.startBar === this.endBar) {
            return VF.Volta.type.BEGIN_END;
        }
        if (this.startBar === measureNumber) {
            return VF.Volta.type.BEGIN;
        }
        if (this.endBar === measureNumber) {
            return VF.Volta.type.END;
        }
        if (this.startBar < measureNumber && this.endBar > measureNumber) {
            return VF.Volta.type.MID;
        }
        return VF.Volta.type.NONE;
    }
}
exports.SmoVolta = SmoVolta;
/**
 * Measure text is just that.  Now that score text can be associated with musical elements, this
 * class has falled into disrepair.  It may be used for part notations in the score later.
 * @category SmoModifier
 */
class SmoMeasureText extends SmoMeasureModifierBase {
    constructor(parameters) {
        super('SmoMeasureText');
        this.justification = SmoMeasureText.justifications.center;
        this.position = SmoMeasureText.positions.above;
        this.text = '';
        this.adjustX = 0;
        this.adjustY = 0;
        this.fontInfo = {
            size: 9,
            family: 'times',
            style: 'normal',
            weight: 'normal'
        };
        let pobj = parameters;
        if (pobj === null) {
            pobj = SmoMeasureText.defaults;
        }
        serializationHelpers_1.smoSerialize.serializedMerge(SmoMeasureText.attributes, SmoMeasureText.defaults, this);
        serializationHelpers_1.smoSerialize.serializedMerge(SmoMeasureText.attributes, pobj, this);
        // right-justify left text and left-justify right text by default
        if (!pobj.justification) {
            // eslint-disable-next-line
            this.justification = (this.position === SmoMeasureText.positions.left) ? SmoMeasureText.justifications.right :
                (this.position === SmoMeasureText.positions.right ? SmoMeasureText.justifications.left : this.justification);
        }
    }
    static get toVexPosition() {
        return [VF.Modifier.Position.ABOVE, VF.Modifier.Position.BELOW, VF.Modifier.Position.LEFT, VF.Modifier.Position.RIGHT];
    }
    static get toVexJustification() {
        return [VF.TextNote.LEFT, VF.TextNote.RIGHT, VF.TextNote.CENTER];
    }
    toVexJustification() {
        return SmoMeasureText.toVexJustification[this.justification];
    }
    toVexPosition() {
        return SmoMeasureText.toVexPosition[parseInt(this.position, 10)];
    }
    static get attributes() {
        return ['position', 'fontInfo', 'text', 'adjustX', 'adjustY', 'justification'];
    }
    serialize() {
        var params = {};
        serializationHelpers_1.smoSerialize.serializedMergeNonDefault(SmoMeasureText.defaults, SmoMeasureText.attributes, this, params);
        params.ctor = 'SmoMeasureText';
        return params;
    }
}
exports.SmoMeasureText = SmoMeasureText;
SmoMeasureText.positions = {
    above: 0, below: 1, left: 2, right: 3, none: 4
};
SmoMeasureText.justifications = {
    left: 0, right: 1, center: 2
};
SmoMeasureText._positionToString = ['above', 'below', 'left', 'right'];
SmoMeasureText.defaults = {
    position: SmoMeasureText.positions.above,
    fontInfo: {
        size: 9,
        family: 'times',
        style: 'normal',
        weight: 'normal'
    },
    text: 'Smo',
    adjustX: 0,
    adjustY: 0,
    justification: SmoMeasureText.justifications.center
};
/**
 * Rehearsal marks are some type of auto-incrementing markers on a measure index.
 * @category SmoModifier
 */
class SmoRehearsalMark extends SmoMeasureModifierBase {
    constructor(parameters) {
        super('SmoRehearsalMark');
        this.position = SmoRehearsalMark.positions.above;
        this.cardinality = SmoRehearsalMark.cardinalities.capitals;
        this.symbol = 'A';
        this.increment = true;
        let pobj = parameters;
        if (typeof (pobj) === 'undefined' || pobj === null) {
            pobj = SmoRehearsalMark.defaults;
        }
        serializationHelpers_1.smoSerialize.serializedMerge(SmoRehearsalMark.attributes, SmoRehearsalMark.defaults, this);
        serializationHelpers_1.smoSerialize.serializedMerge(SmoRehearsalMark.attributes, pobj, this);
        if (!pobj.symbol) {
            this.symbol = this.getInitial();
        }
    }
    static get _positionToString() {
        return ['above', 'below', 'left', 'right'];
    }
    // TODO: positions don't work.
    static get defaults() {
        return JSON.parse(JSON.stringify({
            position: SmoRehearsalMark.positions.above,
            cardinality: SmoRehearsalMark.cardinalities.capitals,
            symbol: 'A',
            increment: true
        }));
    }
    static get attributes() {
        return ['cardinality', 'symbol', 'position', 'increment'];
    }
    getIncrement() {
        if (this.cardinality !== 'number') {
            const code = this.symbol.charCodeAt(0) + 1;
            const symbol = String.fromCharCode(code);
            return symbol;
        }
        else {
            return (parseInt(this.symbol, 10) + 1).toString();
        }
    }
    getInitial() {
        // eslint-disable-next-line
        return this.cardinality === SmoRehearsalMark.cardinalities.capitals ? 'A' :
            (this.cardinality === SmoRehearsalMark.cardinalities.lowerCase ? 'a' : '1');
    }
    serialize() {
        var params = {};
        serializationHelpers_1.smoSerialize.serializedMergeNonDefault(SmoRehearsalMark.defaults, SmoRehearsalMark.attributes, this, params);
        params.ctor = 'SmoRehearsalMark';
        return params;
    }
}
exports.SmoRehearsalMark = SmoRehearsalMark;
SmoRehearsalMark.cardinalities = {
    capitals: 'capitals', lowerCase: 'lowerCase', numbers: 'numbers'
};
SmoRehearsalMark.positions = {
    above: 0, below: 1, left: 2, right: 3
};
/**
 * Information about both playback tempo and how the tempo is notated.
 * @category SmoModifier
 */
class SmoTempoText extends SmoMeasureModifierBase {
    constructor(parameters) {
        super('SmoTempoText');
        this.tempoMode = SmoTempoText.tempoModes.durationMode;
        this.bpm = 120;
        this.beatDuration = 4096;
        this.tempoText = 'Allegro';
        this.yOffset = 0;
        this.display = false;
        this.customText = '';
        let pobj = parameters;
        if (typeof (pobj) === 'undefined' || pobj === null) {
            pobj = {};
        }
        serializationHelpers_1.smoSerialize.serializedMerge(SmoTempoText.attributes, SmoTempoText.defaults, this);
        serializationHelpers_1.smoSerialize.serializedMerge(SmoTempoText.attributes, pobj, this);
    }
    static get tempoModes() {
        return {
            durationMode: 'duration',
            textMode: 'text',
            customMode: 'custom'
        };
    }
    static get tempoTexts() {
        return {
            larghissimo: 'Larghissimo',
            grave: 'Grave',
            lento: 'Lento',
            largo: 'Largo',
            larghetto: 'Larghetto',
            adagio: 'Adagio',
            adagietto: 'Adagietto',
            andante_moderato: 'Andante moderato',
            andante: 'Andante',
            andantino: 'Andantino',
            moderator: 'Moderato',
            allegretto: 'Allegretto',
            allegro: 'Allegro',
            vivace: 'Vivace',
            presto: 'Presto',
            prestissimo: 'Prestissimo'
        };
    }
    static get defaults() {
        return JSON.parse(JSON.stringify({
            tempoMode: SmoTempoText.tempoModes.durationMode,
            bpm: 120,
            beatDuration: 4096,
            tempoText: SmoTempoText.tempoTexts.allegro,
            yOffset: 0,
            display: false,
            customText: ''
        }));
    }
    static get attributes() {
        return ['tempoMode', 'bpm', 'display', 'beatDuration', 'tempoText', 'yOffset', 'customText'];
    }
    _toVexTextTempo() {
        return { name: this.tempoText };
    }
    /**
     * Return equality wrt the tempo marking, e.g. 2 allegro in textMode will be equal but
     * an allegro and duration 120bpm will not.
     * @param t1
     * @param t2
     * @returns
     */
    static eq(t1, t2) {
        if (t1.tempoMode !== t2.tempoMode) {
            return false;
        }
        if (t1.tempoMode === SmoTempoText.tempoModes.durationMode) {
            return t1.bpm === t2.bpm && t1.beatDuration === t2.beatDuration;
        }
        if (t1.tempoMode === SmoTempoText.tempoModes.textMode) {
            return t1.tempoText === t2.tempoText;
        }
        else {
            return t1.bpm === t2.bpm && t1.beatDuration === t2.beatDuration &&
                t1.tempoText === t2.tempoText;
        }
    }
    static get bpmFromText() {
        const rv = {};
        rv[SmoTempoText.tempoTexts.larghissimo] = 24;
        rv[SmoTempoText.tempoTexts.grave] = 40;
        rv[SmoTempoText.tempoTexts.lento] = 45;
        rv[SmoTempoText.tempoTexts.largo] = 40;
        rv[SmoTempoText.tempoTexts.larghetto] = 60;
        rv[SmoTempoText.tempoTexts.adagio] = 72;
        rv[SmoTempoText.tempoTexts.adagietto] = 72;
        rv[SmoTempoText.tempoTexts.andante_moderato] = 72;
        rv[SmoTempoText.tempoTexts.andante] = 84;
        rv[SmoTempoText.tempoTexts.andantino] = 92;
        rv[SmoTempoText.tempoTexts.moderator] = 96;
        rv[SmoTempoText.tempoTexts.allegretto] = 96;
        rv[SmoTempoText.tempoTexts.allegro] = 120;
        rv[SmoTempoText.tempoTexts.vivace] = 144;
        rv[SmoTempoText.tempoTexts.presto] = 168;
        rv[SmoTempoText.tempoTexts.prestissimo] = 240;
        return rv;
    }
    _toVexDurationTempo() {
        var vd = music_1.SmoMusic.ticksToDuration[this.beatDuration];
        var dots = (vd.match(/d/g) || []).length;
        vd = vd.replace(/d/g, '');
        const rv = { duration: vd, dots, bpm: this.bpm };
        if (this.customText.length) {
            rv.name = this.customText;
        }
        return rv;
    }
    toVexTempo() {
        if (this.tempoMode === SmoTempoText.tempoModes.durationMode ||
            this.tempoMode === SmoTempoText.tempoModes.customMode) {
            return this._toVexDurationTempo();
        }
        return this._toVexTextTempo();
    }
    serialize() {
        var params = {};
        serializationHelpers_1.smoSerialize.serializedMergeNonDefault(SmoTempoText.defaults, SmoTempoText.attributes, this, params);
        params.ctor = 'SmoTempoText';
        return params;
    }
}
exports.SmoTempoText = SmoTempoText;
/**
 * Time signatures contain duration information for a measure, and information
 * about the display of the time signature.  Note: measures also have a time signature
 * string that can be displayed in cases like pickup measure, where the actual time doesn't
 * match the time signature.
 * @category SmoModifier
 */
class TimeSignature extends SmoMeasureModifierBase {
    constructor(params) {
        super('TimeSignature');
        // timeSignature: string = '4/4';
        this.actualBeats = 4;
        this.beatDuration = 4;
        this.useSymbol = false;
        this.display = true;
        this.actualBeats = params.actualBeats;
        this.beatDuration = params.beatDuration;
        this.useSymbol = params.useSymbol;
        this.display = params.display;
    }
    static get defaults() {
        return {
            actualBeats: 4,
            beatDuration: 4,
            useSymbol: false,
            display: true
        };
    }
    static equal(ts1, ts2) {
        return (ts1.actualBeats === ts2.actualBeats && ts1.beatDuration === ts2.beatDuration);
    }
    get timeSignature() {
        return this.actualBeats.toString() + '/' + this.beatDuration.toString();
    }
    set timeSignature(value) {
        const ar = value.split('/');
        this.actualBeats = parseInt(ar[0], 10);
        this.beatDuration = parseInt(ar[1], 10);
    }
    serialize() {
        return JSON.parse(JSON.stringify(this));
    }
}
exports.TimeSignature = TimeSignature;


/***/ }),

/***/ "./src/smo/data/music.ts":
/*!*******************************!*\
  !*** ./src/smo/data/music.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/**
 * shared music theory and audio frequency routines, helper functions etc.
 * @module /smo/data/music
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SmoMusic = exports.SmoAudioPitch = void 0;
// [Smoosic](https://github.com/AaronDavidNewman/Smoosic)
// Copyright (c) Aaron David Newman 2021.
const note_1 = __webpack_require__(/*! ./note */ "./src/smo/data/note.ts");
/**
 * calculate the pitch frequency, just temperment a=440, etc.
 * @category SmoUtilities
 */
class SmoAudioPitch {
    // ### _frequencies
    // Compute the equal-temperment frequencies of the notes.
    static _computeFrequencies() {
        const map = {};
        let lix = 0;
        const octaves = [1, 2, 3, 4, 5, 6, 7];
        const letters = ['cn', 'c#', 'dn', 'd#', 'en', 'fn', 'f#', 'gn', 'g#', 'an', 'a#', 'bn'];
        const just = Math.pow(2, (1.0 / 12));
        const baseFrequency = (440 / 16) * Math.pow(just, 3);
        octaves.forEach((octave) => {
            const base = baseFrequency * Math.pow(2, octave - 1);
            lix = 0;
            letters.forEach((letter) => {
                const freq = base * Math.pow(just, lix);
                var enharmonics = SmoMusic.getEnharmonics(letter);
                enharmonics.forEach((en) => {
                    // Adjust for B4 higher than C4
                    const adjOctave = (letter[0] === 'b' && en[0] === 'c') ?
                        octave + 1 : octave;
                    map[en + adjOctave.toString()] = freq;
                });
                lix += 1;
            });
        });
        return map;
    }
    static get pitchFrequencyMap() {
        if (!SmoAudioPitch.frequencies) {
            SmoAudioPitch.frequencies = SmoAudioPitch._computeFrequencies();
        }
        return SmoAudioPitch.frequencies;
    }
    static _rawPitchToFrequency(smoPitch, offset) {
        const npitch = SmoMusic.smoIntToPitch(SmoMusic.smoPitchToInt(smoPitch) + offset);
        const vx = npitch.letter.toLowerCase() + npitch.accidental + npitch.octave.toString();
        return SmoAudioPitch.pitchFrequencyMap[vx];
    }
    /**
     *
     * @param smoPitch - pitch from the SMO object
     * @param offset - transpose 1/2 steps, 0 means no transpose
     * @param tone - optional transpose microtone
     * @returns
     */
    static smoPitchToFrequency(smoPitch, offset, tone) {
        let pitchInt = 0;
        let rv = SmoAudioPitch._rawPitchToFrequency(smoPitch, offset);
        if (tone) {
            const coeff = tone.toPitchCoeff;
            pitchInt = SmoMusic.smoPitchToInt(smoPitch);
            pitchInt += (coeff > 0) ? 1 : -1;
            const otherSmo = SmoMusic.smoIntToPitch(pitchInt);
            const otherPitch = SmoAudioPitch._rawPitchToFrequency(otherSmo, offset);
            rv += Math.abs(rv - otherPitch) * coeff;
        }
        return rv;
    }
}
exports.SmoAudioPitch = SmoAudioPitch;
SmoAudioPitch.frequencies = null;
const VF = eval('Vex.Flow');
;
;
/**
 * Helper functions that build on the VX music theory routines, and other
 * utilities I wish were in VF.Music but aren't
 * ## Note on pitch and duration format
 * We use some VEX music theory routines and frequently need to convert
 * formats from SMO format.  We also use the same 'ticks' abstraction for
 * durations.
 *
 * `Smo` uses pitch JSON:
 * ```javascript
 *     {note:'c',accidental:'#',octave:4}
 * ```
 *
 * `Vex` usually uses a canonical string:
 *
 *     `'c#/4'`
 *
 * Depending on the operation, the octave might be omitted
 *
 * `Smo` uses a JSON for duration always:
 * ```javascript
 *     {numerator:4096,denominator:1,remainder:0}
 * ```
 * `Vex` uses a letter duration (`'4'` or `'q'`for 1/4 note) and `'d'` for dot.
 *
 * I try to indicate whether I am using vex or smo notation in the function name.
 * Duration methods start around line 1100
 * @category SmoUtilities
 */
class SmoMusic {
    /**
     * Ported from vex, used to convert pitches to numerical values
     * */
    static get noteValues() {
        return {
            c: { root_index: 0, int_val: 0 },
            cn: { root_index: 0, int_val: 0 },
            'c#': { root_index: 0, int_val: 1 },
            'c##': { root_index: 0, int_val: 2 },
            cb: { root_index: 0, int_val: 11 },
            cbb: { root_index: 0, int_val: 10 },
            d: { root_index: 1, int_val: 2 },
            dn: { root_index: 1, int_val: 2 },
            'd#': { root_index: 1, int_val: 3 },
            'd##': { root_index: 1, int_val: 4 },
            db: { root_index: 1, int_val: 1 },
            dbb: { root_index: 1, int_val: 0 },
            e: { root_index: 2, int_val: 4 },
            en: { root_index: 2, int_val: 4 },
            'e#': { root_index: 2, int_val: 5 },
            'e##': { root_index: 2, int_val: 6 },
            eb: { root_index: 2, int_val: 3 },
            ebb: { root_index: 2, int_val: 2 },
            f: { root_index: 3, int_val: 5 },
            fn: { root_index: 3, int_val: 5 },
            'f#': { root_index: 3, int_val: 6 },
            'f##': { root_index: 3, int_val: 7 },
            fb: { root_index: 3, int_val: 4 },
            fbb: { root_index: 3, int_val: 3 },
            g: { root_index: 4, int_val: 7 },
            gn: { root_index: 4, int_val: 7 },
            'g#': { root_index: 4, int_val: 8 },
            'g##': { root_index: 4, int_val: 9 },
            gb: { root_index: 4, int_val: 6 },
            gbb: { root_index: 4, int_val: 5 },
            a: { root_index: 5, int_val: 9 },
            an: { root_index: 5, int_val: 9 },
            'a#': { root_index: 5, int_val: 10 },
            'a##': { root_index: 5, int_val: 11 },
            ab: { root_index: 5, int_val: 8 },
            abb: { root_index: 5, int_val: 7 },
            b: { root_index: 6, int_val: 11 },
            bn: { root_index: 6, int_val: 11 },
            'b#': { root_index: 6, int_val: 0 },
            'b##': { root_index: 6, int_val: 1 },
            bb: { root_index: 6, int_val: 10 },
            bbb: { root_index: 6, int_val: 9 },
        };
    }
    /**
     * return Vex canonical note enharmonic - e.g. Bb to A#
     * */
    static vexToCannonical(vexKey) {
        vexKey = SmoMusic.stripVexOctave(vexKey);
        return VF.Music.canonical_notes[SmoMusic.noteValues[vexKey].int_val];
    }
    /**
    * A note array (sans octave) in key-signature order
    */
    static get circleOfFifths() {
        return [{
                letter: 'c',
                accidental: 'n'
            }, {
                letter: 'g',
                accidental: 'n'
            }, {
                letter: 'd',
                accidental: 'n'
            }, {
                letter: 'a',
                accidental: 'n'
            }, {
                letter: 'e',
                accidental: 'n'
            }, {
                letter: 'b',
                accidental: 'n'
            }, {
                letter: 'f',
                accidental: '#'
            }, {
                letter: 'c',
                accidental: '#'
            }, {
                letter: 'a',
                accidental: 'b'
            }, {
                letter: 'e',
                accidental: 'b'
            }, {
                letter: 'b',
                accidental: 'b'
            }, {
                letter: 'f',
                accidental: 'n'
            }
        ];
    }
    /**
     * gives the index into circle-of-fifths array for a pitch, considering enharmonics.
     * */
    static circleOfFifthsIndex(smoPitch) {
        const en1 = SmoMusic.vexToSmoKey(SmoMusic.getEnharmonic(SmoMusic.pitchToVexKey(smoPitch)));
        const en2 = SmoMusic.vexToSmoKey(SmoMusic.getEnharmonic(SmoMusic.getEnharmonic(SmoMusic.pitchToVexKey(smoPitch))));
        const ix = SmoMusic.circleOfFifths.findIndex((el) => (el.letter === smoPitch.letter && el.accidental === smoPitch.accidental) ||
            (el.letter === en1.letter && el.accidental === en1.accidental) ||
            (el.letter === en2.letter && el.accidental === en2.accidental));
        return ix;
    }
    /**
     * Get pitch to the right in circle of fifths
     * */
    static addSharp(smoPitch) {
        const rv = SmoMusic.circleOfFifths[(SmoMusic.circleOfFifthsIndex(smoPitch) + 1) % SmoMusic.circleOfFifths.length];
        return { letter: rv.letter, accidental: rv.accidental, octave: smoPitch.octave };
    }
    /**
     * Get pitch to the left in circle of fifths
     */
    static addFlat(smoPitch) {
        const rv = SmoMusic.circleOfFifths[((SmoMusic.circleOfFifths.length - 1) + SmoMusic.circleOfFifthsIndex(smoPitch)) % SmoMusic.circleOfFifths.length];
        return { letter: rv.letter, accidental: rv.accidental, octave: smoPitch.octave };
    }
    /**
     * Add @param {number} - sharps
     */
    static addSharps(smoPitch, distance) {
        let i = 0;
        let rv = {};
        if (distance === 0) {
            return JSON.parse(JSON.stringify(smoPitch));
        }
        rv = SmoMusic.addSharp(smoPitch);
        for (i = 1; i < distance; ++i) {
            rv = SmoMusic.addSharp(rv);
        }
        const octaveAdj = SmoMusic.letterPitchIndex[smoPitch.letter] > SmoMusic.letterPitchIndex[rv.letter] ? 1 : 0;
        rv.octave += octaveAdj;
        return rv;
    }
    /**
     * Add *distance* sharps/flats to given key
     */
    static addFlats(smoPitch, distance) {
        let i = 0;
        let rv = {};
        if (distance === 0) {
            return JSON.parse(JSON.stringify(smoPitch));
        }
        rv = SmoMusic.addFlat(smoPitch);
        for (i = 1; i < distance; ++i) {
            rv = SmoMusic.addFlat(rv);
        }
        const octaveAdj = SmoMusic.letterPitchIndex[smoPitch.letter] > SmoMusic.letterPitchIndex[rv.letter] ? 1 : 0;
        rv.octave += octaveAdj;
        return rv;
    }
    /**
     * Convert array of smo pitches to vex keys, with adjustment for transpose and notehead
     * @param pitchAr
     * @param keyOffset
     * @param noteHead
     * @returns {string[]} - array of vex keyx
     */
    static smoPitchesToVexKeys(pitchAr, keyOffset, noteHead) {
        const noopFunc = keyOffset > 0 ? 'addSharps' : 'addFlats';
        const rv = [];
        pitchAr.forEach((pitch) => {
            rv.push(SmoMusic.pitchToVexKey(SmoMusic[noopFunc](pitch, keyOffset), noteHead));
        });
        return rv;
    }
    static get scaleIntervals() {
        return {
            up: [2, 2, 1, 2, 2, 2, 1],
            down: [1, 2, 2, 2, 1, 2, 2]
        };
    }
    /**
     * return true if the pitches match, except for octave.
     * `{ letter: 'a', accidental: '#'}, { letter: 'a', accidental: '#'}` returns true
     * `{ letter: 'a', accidental: '#'}, { letter: 'b', accidental: 'b'}` returns false
     * */
    static smoScalePitchMatch(p1, p2) {
        const pp1 = JSON.parse(JSON.stringify(p1));
        const pp2 = JSON.parse(JSON.stringify(p2));
        pp1.octave = 0;
        pp2.octave = 0;
        return SmoMusic.smoPitchToInt(pp1) === SmoMusic.smoPitchToInt(pp2);
    }
    /**
     * Return the number of ledger lines based on the pitch and clef
     * @param clef
     * @param pitch
     * @returns number where 0 is the top staff line
     */
    static pitchToLedgerLine(clef, pitch) {
        // return the distance from the top ledger line, as 0.5 per line/space
        return -1.0 * (VF.keyProperties(SmoMusic.pitchToVexKey(pitch, clef)).line - 4.5)
            - VF.clefProperties(clef).line_shift;
    }
    /**
     * Return the number of ledger lines based on the pitch and clef
     * @param clef
     * @param pitch
     * @returns number where 0 is the top staff line
     */
    static pitchToStaffLine(clef, pitch) {
        // return the distance from the top ledger line, as 0.5 per line/space
        return VF.keyProperties(SmoMusic.pitchToVexKey(pitch, clef)).line;
    }
    /**
     * return flag state (up === 1 or down === 2) based on pitch and clef if auto
     * */
    static flagStateFromNote(clef, note) {
        let fs = note.flagState;
        if (fs === note_1.SmoNote.flagStates.auto) {
            fs = SmoMusic.pitchToStaffLine(clef, note.pitches[0])
                >= 3 ? note_1.SmoNote.flagStates.down : note_1.SmoNote.flagStates.up;
        }
        return fs;
    }
    /**
     * The purpose of this table is to keep consistent enharmonic spelling when transposing
     * instruments in different keys.  It is not theoritically complete, e.g.
     * there is no reason to distinguish between #5 used as a leading tone for vi- or
     * as an augmented chord, the spelling is the same.  It does not show a preference
     * for notes that don't have an obvious purpose in the key, e.g. it does not try to compute the
     * equivalent to 'e#' in the key of 'c'.  The computation of the 'intended key area' is
     * beyond the scope of a music program to interpret.
     */
    static get enharmonicRoles() {
        const tbl = { 'c': [
                { letter: 'c', accidental: 'n', role: 'tonic' },
                { letter: 'c', accidental: '#', role: '7/2' },
                { letter: 'd', accidental: 'b', role: 'b9' },
                { letter: 'd', accidental: 'n', role: '2' },
                { letter: 'd', accidental: '#', role: '7/3' },
                { letter: 'e', accidental: 'b', role: 'b3' },
                { letter: 'e', accidental: 'n', role: '3' },
                { letter: 'f', accidental: 'n', role: '4' },
                { letter: 'f', accidental: '#', role: '#11' },
                { letter: 'g', accidental: 'b', role: 'b5' },
                { letter: 'g', accidental: 'n', role: '5' },
                { letter: 'g', accidental: '#', role: '7/6' },
                { letter: 'a', accidental: 'b', role: 'b6' },
                { letter: 'a', accidental: 'n', role: '6' },
                { letter: 'a', accidental: '#', role: '7/7' },
                { letter: 'b', accidental: 'b', role: 'b7' },
                { letter: 'b', accidental: 'n', role: '7' }
            ], 'c#': [
                { letter: 'c', accidental: '#', role: 'tonic' },
                { letter: 'c', accidental: '##', role: '7/2' },
                { letter: 'd', accidental: 'n', role: 'b9' },
                { letter: 'd', accidental: '#', role: '2' },
                { letter: 'd', accidental: '##', role: '#2' },
                { letter: 'f', accidental: 'b', role: 'b3' },
                { letter: 'e', accidental: '#', role: '3' },
                { letter: 'f', accidental: '#', role: '4' },
                { letter: 'f', accidental: '##', role: '#11' },
                { letter: 'g', accidental: 'n', role: 'b5' },
                { letter: 'g', accidental: '#', role: '5' },
                { letter: 'g', accidental: '##', role: '7/6' },
                { letter: 'a', accidental: 'n', role: 'b6' },
                { letter: 'a', accidental: '#', role: '6' },
                { letter: 'a', accidental: '##', role: '7/7' },
                { letter: 'b', accidental: 'n', role: 'b7' },
                { letter: 'b', accidental: '#', role: '7' }
            ], 'db': [
                { letter: 'd', accidental: 'b', role: 'tonic' },
                { letter: 'd', accidental: 'n', role: '7/2' },
                { letter: 'e', accidental: 'bb', role: 'b9' },
                { letter: 'e', accidental: 'b', role: '2' },
                { letter: 'e', accidental: 'n', role: '7/3' },
                { letter: 'f', accidental: 'b', role: 'b3' },
                { letter: 'f', accidental: 'n', role: '3' },
                { letter: 'g', accidental: 'b', role: '4' },
                { letter: 'g', accidental: 'n', role: '#11' },
                { letter: 'a', accidental: 'bb', role: 'b5' },
                { letter: 'a', accidental: 'b', role: '5' },
                { letter: 'a', accidental: 'n', role: '7/6' },
                { letter: 'b', accidental: 'bb', role: 'b6' },
                { letter: 'b', accidental: 'b', role: '6' },
                { letter: 'b', accidental: 'n', role: '7/7' },
                { letter: 'c', accidental: 'b', role: 'b7' },
                { letter: 'b', accidental: '#', role: '7' }
            ], 'd': [
                { letter: 'd', accidental: 'n', role: 'tonic' },
                { letter: 'd', accidental: '#', role: '7/2' },
                { letter: 'e', accidental: 'b', role: 'b9' },
                { letter: 'e', accidental: 'n', role: '2' },
                { letter: 'e', accidental: '#', role: '7/3' },
                { letter: 'f', accidental: 'n', role: 'b3' },
                { letter: 'f', accidental: '#', role: '3' },
                { letter: 'g', accidental: 'n', role: '4' },
                { letter: 'g', accidental: '#', role: '#11' },
                { letter: 'a', accidental: 'b', role: 'b5' },
                { letter: 'a', accidental: 'n', role: '5' },
                { letter: 'a', accidental: '#', role: '7/6' },
                { letter: 'b', accidental: 'b', role: 'b6' },
                { letter: 'b', accidental: 'n', role: '6' },
                { letter: 'b', accidental: '#', role: '7/7' },
                { letter: 'c', accidental: 'n', role: 'b7' },
                { letter: 'c', accidental: '#', role: '7' }
            ], 'eb': [
                { letter: 'e', accidental: 'b', role: 'tonic' },
                { letter: 'e', accidental: 'n', role: '7/2' },
                { letter: 'f', accidental: 'b', role: 'b9' },
                { letter: 'f', accidental: 'n', role: '2' },
                { letter: 'f', accidental: '#', role: '7/3' },
                { letter: 'g', accidental: 'b', role: 'b3' },
                { letter: 'g', accidental: 'n', role: '3' },
                { letter: 'a', accidental: 'b', role: '4' },
                { letter: 'a', accidental: 'n', role: '#11' },
                { letter: 'b', accidental: 'bb', role: 'b5' },
                { letter: 'b', accidental: 'b', role: '5' },
                { letter: 'b', accidental: 'n', role: '7/6' },
                { letter: 'c', accidental: 'b', role: '6' },
                { letter: 'c', accidental: 'n', role: '6' },
                { letter: 'c', accidental: '#', role: '7/7' },
                { letter: 'd', accidental: 'b', role: 'b7' },
                { letter: 'd', accidental: 'n', role: '7' }
            ], 'e': [
                { letter: 'e', accidental: 'n', role: 'tonic' },
                { letter: 'e', accidental: '#', role: '7/2' },
                { letter: 'f', accidental: 'n', role: 'b9' },
                { letter: 'f', accidental: '#', role: '2' },
                { letter: 'f', accidental: '##', role: '7/3' },
                { letter: 'g', accidental: 'n', role: 'b3' },
                { letter: 'g', accidental: '#', role: '3' },
                { letter: 'a', accidental: 'n', role: '4' },
                { letter: 'a', accidental: '#', role: '#11' },
                { letter: 'b', accidental: 'b', role: 'b5' },
                { letter: 'b', accidental: 'n', role: '5' },
                { letter: 'b', accidental: '#', role: '7/6' },
                { letter: 'c', accidental: 'n', role: 'b6' },
                { letter: 'c', accidental: '#', role: '6' },
                { letter: 'c', accidental: '##', role: '7/7' },
                { letter: 'd', accidental: 'n', role: 'b7' },
                { letter: 'd', accidental: '#', role: '7' }
            ], 'f': [
                { letter: 'f', accidental: 'n', role: 'tonic' },
                { letter: 'f', accidental: '#', role: '7/2' },
                { letter: 'g', accidental: 'b', role: 'b9' },
                { letter: 'g', accidental: 'n', role: '2' },
                { letter: 'g', accidental: '#', role: '7/3' },
                { letter: 'a', accidental: 'b', role: 'b3' },
                { letter: 'a', accidental: 'n', role: '3' },
                { letter: 'b', accidental: 'b', role: '4' },
                { letter: 'b', accidental: 'n', role: '#11' },
                { letter: 'c', accidental: 'b', role: 'b5' },
                { letter: 'c', accidental: 'n', role: '5' },
                { letter: 'c', accidental: '#', role: '7/6' },
                { letter: 'd', accidental: 'b', role: 'b6' },
                { letter: 'd', accidental: 'n', role: '6' },
                { letter: 'd', accidental: '#', role: '7/7' },
                { letter: 'e', accidental: 'b', role: 'b7' },
                { letter: 'e', accidental: 'n', role: '7' }
            ], 'f#': [
                { letter: 'f', accidental: '#', role: 'tonic' },
                { letter: 'f', accidental: '##', role: '7/2' },
                { letter: 'g', accidental: 'n', role: 'b9' },
                { letter: 'g', accidental: '#', role: '2' },
                { letter: 'g', accidental: '##', role: '#2' },
                { letter: 'a', accidental: 'n', role: 'b3' },
                { letter: 'a', accidental: '#', role: '3' },
                { letter: 'b', accidental: 'n', role: '4' },
                { letter: 'b', accidental: '#', role: '#11' },
                { letter: 'c', accidental: 'n', role: 'b5' },
                { letter: 'c', accidental: '#', role: '5' },
                { letter: 'c', accidental: '##', role: '7/6' },
                { letter: 'd', accidental: 'n', role: 'b6' },
                { letter: 'd', accidental: '#', role: '6' },
                { letter: 'd', accidental: '##', role: '7/7' },
                { letter: 'e', accidental: 'n', role: 'b7' },
                { letter: 'e', accidental: '#', role: '7' }
            ], 'gb': [
                { letter: 'g', accidental: 'b', role: 'tonic' },
                { letter: 'g', accidental: 'n', role: '7/2' },
                { letter: 'a', accidental: 'bb', role: 'b9' },
                { letter: 'a', accidental: 'b', role: '2' },
                { letter: 'a', accidental: 'n', role: '7/3' },
                { letter: 'a', accidental: 'bb', role: 'b3' },
                { letter: 'b', accidental: 'b', role: '3' },
                { letter: 'c', accidental: 'b', role: '4' },
                { letter: 'c', accidental: 'n', role: '#11' },
                { letter: 'd', accidental: 'bb', role: 'b5' },
                { letter: 'd', accidental: 'b', role: '5' },
                { letter: 'd', accidental: 'n', role: '7/6' },
                { letter: 'e', accidental: 'bb', role: 'b6' },
                { letter: 'e', accidental: 'b', role: '6' },
                { letter: 'e', accidental: 'n', role: '7/7' },
                { letter: 'f', accidental: 'b', role: 'b7' },
                { letter: 'f', accidental: 'n', role: '7' }
            ], 'g': [
                { letter: 'g', accidental: 'n', role: 'tonic' },
                { letter: 'g', accidental: '#', role: '7/2' },
                { letter: 'g', accidental: 'b', role: 'b9' },
                { letter: 'a', accidental: 'n', role: '2' },
                { letter: 'a', accidental: '#', role: '7/3' },
                { letter: 'b', accidental: 'b', role: 'b3' },
                { letter: 'b', accidental: 'n', role: '3' },
                { letter: 'c', accidental: 'n', role: '4' },
                { letter: 'c', accidental: '#', role: '#11' },
                { letter: 'd', accidental: 'b', role: 'b5' },
                { letter: 'd', accidental: 'n', role: '5' },
                { letter: 'd', accidental: '#', role: '7/6' },
                { letter: 'e', accidental: 'b', role: 'b6' },
                { letter: 'e', accidental: 'n', role: '6' },
                { letter: 'e', accidental: '#', role: '7/7' },
                { letter: 'f', accidental: 'n', role: 'b7' },
                { letter: 'f', accidental: '#', role: '7' }
            ], 'ab': [
                { letter: 'a', accidental: 'b', role: 'tonic' },
                { letter: 'a', accidental: 'n', role: '7/2' },
                { letter: 'b', accidental: 'bb', role: 'b9' },
                { letter: 'b', accidental: 'b', role: '2' },
                { letter: 'b', accidental: 'n', role: '7/3' },
                { letter: 'b', accidental: 'bb', role: 'b3' },
                { letter: 'c', accidental: 'n', role: '3' },
                { letter: 'd', accidental: 'b', role: '4' },
                { letter: 'd', accidental: 'n', role: '#11' },
                { letter: 'e', accidental: 'bb', role: 'b5' },
                { letter: 'e', accidental: 'b', role: '5' },
                { letter: 'e', accidental: 'n', role: '7/6' },
                { letter: 'f', accidental: 'b', role: 'b6' },
                { letter: 'f', accidental: 'n', role: '6' },
                { letter: 'f', accidental: '#', role: '7/7' },
                { letter: 'g', accidental: 'b', role: 'b7' },
                { letter: 'g', accidental: 'n', role: '7' }
            ], 'a': [
                { letter: 'a', accidental: 'n', role: 'tonic' },
                { letter: 'a', accidental: '#', role: '7/2' },
                { letter: 'b', accidental: 'b', role: 'b9' },
                { letter: 'b', accidental: 'n', role: '2' },
                { letter: 'b', accidental: '#', role: '7/3' },
                { letter: 'c', accidental: 'n', role: 'b3' },
                { letter: 'c', accidental: '#', role: '3' },
                { letter: 'd', accidental: 'n', role: '4' },
                { letter: 'd', accidental: '#', role: '#11' },
                { letter: 'e', accidental: 'b', role: 'b5' },
                { letter: 'e', accidental: 'n', role: '5' },
                { letter: 'e', accidental: '#', role: '7/6' },
                { letter: 'f', accidental: 'n', role: 'b6' },
                { letter: 'f', accidental: '#', role: '6' },
                { letter: 'f', accidental: '##', role: '7/7' },
                { letter: 'g', accidental: 'n', role: 'b7' },
                { letter: 'g', accidental: '#', role: '7' }
            ], 'bb': [
                { letter: 'b', accidental: 'b', role: 'tonic' },
                { letter: 'b', accidental: 'n', role: '7/2' },
                { letter: 'c', accidental: 'b', role: 'b9' },
                { letter: 'c', accidental: 'n', role: '2' },
                { letter: 'c', accidental: '#', role: '7/3' },
                { letter: 'd', accidental: 'b', role: 'b3' },
                { letter: 'd', accidental: 'n', role: '3' },
                { letter: 'e', accidental: 'b', role: '4' },
                { letter: 'e', accidental: 'n', role: '#11' },
                { letter: 'f', accidental: 'b', role: 'b5' },
                { letter: 'f', accidental: 'n', role: '5' },
                { letter: 'f', accidental: '#', role: '7/6' },
                { letter: 'g', accidental: 'b', role: 'b6' },
                { letter: 'g', accidental: 'n', role: '6' },
                { letter: 'g', accidental: '#', role: '7/7' },
                { letter: 'a', accidental: 'b', role: 'b7' },
                { letter: 'a', accidental: 'n', role: '7' }
            ], 'b': [
                { letter: 'b', accidental: 'n', role: 'tonic' },
                { letter: 'b', accidental: '#', role: '7/2' },
                { letter: 'c', accidental: 'n', role: 'b9' },
                { letter: 'c', accidental: '#', role: '2' },
                { letter: 'c', accidental: '##', role: '7/3' },
                { letter: 'd', accidental: 'n', role: 'b3' },
                { letter: 'd', accidental: '#', role: '3' },
                { letter: 'e', accidental: 'n', role: '4' },
                { letter: 'e', accidental: '#', role: '#11' },
                { letter: 'f', accidental: 'n', role: 'b5' },
                { letter: 'f', accidental: '#', role: '5' },
                { letter: 'f', accidental: '##', role: '7/6' },
                { letter: 'g', accidental: 'n', role: 'b6' },
                { letter: 'g', accidental: '#', role: '6' },
                { letter: 'g', accidental: '##', role: '7/7' },
                { letter: 'a', accidental: 'n', role: 'b7' },
                { letter: 'a', accidental: '#', role: '7' }
            ] };
        return tbl;
    }
    /**
     * Find the harmonic role for the given pitch
     * @param smoPitch
     * @param keySignature
     * @returns
     */
    static findRoleOfPitch(smoPitch, keySignature) {
        const keyRoles = SmoMusic.enharmonicRoles[keySignature];
        if (!keyRoles) {
            return '';
        }
        const keyRole = keyRoles.find((x) => x.letter === smoPitch.letter.toLocaleLowerCase() && x.accidental === smoPitch.accidental.toLowerCase());
        if (!keyRole) {
            return '';
        }
        return keyRole.role;
    }
    /**
     * Given a harmonic role, find the pitch that matches it.  If there is no one, just
     * return the raw transposition
     * @param role
     * @param keySignature
     * @param transposedPitch
     * @returns
     */
    static findPitchForRole(role, keySignature, transposedPitch) {
        const keyRoles = SmoMusic.enharmonicRoles[keySignature];
        if (!keyRoles) {
            return JSON.parse(JSON.stringify(transposedPitch));
        }
        const keyRole = keyRoles.find((x) => x.role === role);
        if (!keyRole) {
            return JSON.parse(JSON.stringify(transposedPitch));
        }
        let octave = transposedPitch.octave;
        if ((transposedPitch.letter === 'a' || transposedPitch.letter === 'b') && keyRole.letter === 'c') {
            octave += 1;
        }
        return { letter: keyRole.letter, accidental: keyRole.accidental, octave };
    }
    static rawTranspose(pitch, offset) {
        return SmoMusic.smoIntToPitch(SmoMusic.smoPitchToInt(pitch) + offset);
    }
    static transposePitchForKey(pitch, originalKey, destinationKey, offset) {
        const transposedPitch = SmoMusic.getEnharmonicInKey(SmoMusic.rawTranspose(pitch, offset), destinationKey);
        const role = SmoMusic.findRoleOfPitch(pitch, originalKey);
        if (role.length) {
            return SmoMusic.findPitchForRole(role, destinationKey, transposedPitch);
        }
        return transposedPitch;
    }
    /**
     * convert from SMO to VEX format so we can use the VexFlow tables and methods
     * example:
     *   `{letter,octave,accidental}` object to vexKey string `'f#'`
     * */
    static _pitchToVexKey(smoPitch) {
        // Convert to vex keys, where f# is a string like 'f#'.
        let vexKey = smoPitch.letter.toLowerCase();
        if (smoPitch.accidental.length === 0) {
            vexKey = vexKey + 'n';
        }
        else {
            vexKey = vexKey + smoPitch.accidental;
        }
        if (smoPitch.octave) {
            vexKey = vexKey + '/' + smoPitch.octave;
        }
        return vexKey;
    }
    /**
     * convert smo pitch to easy score (vex) format.  Mostly used
     * for debugging and generating Vex test cases
     * @param smoPitch
     * @returns - a string that can be converted to a VEX routine, with some difficulty
     */
    static pitchToEasyScore(smoPitch) {
        let vexKey = smoPitch.letter.toLowerCase();
        vexKey = vexKey + smoPitch.accidental;
        return vexKey + smoPitch.octave;
    }
    /**
     * convert a pitch to a format expected by the MIDI writer
     * @param smoPitch pitch to convert
     * @returns pitch in MIDI string format.
     */
    static smoPitchToMidiString(smoPitch) {
        const midiPitch = SmoMusic.smoIntToPitch(SmoMusic.smoPitchToInt(smoPitch));
        let rv = midiPitch.letter.toUpperCase();
        if (midiPitch.accidental !== 'n') {
            rv += midiPitch.accidental;
        }
        rv += midiPitch.octave;
        return rv;
    }
    static smoPitchesToMidiStrings(smoPitches) {
        const rv = [];
        smoPitches.forEach((pitch) => {
            rv.push(SmoMusic.smoPitchToMidiString(pitch));
        });
        return rv;
    }
    /**
     * filled in from the midi routines borrowed from
     * // https://github.com/grimmdude/MidiWriterJS
     * @param midiPitch pitch from MIDIwrite
     * @returns SMO pitch
     */
    static midiPitchToSmoPitch(midiPitch) {
        const smoPitch = {};
        smoPitch.letter = midiPitch[0].toLowerCase();
        if (isNaN(parseInt(midiPitch[1], 10))) {
            smoPitch.accidental = midiPitch[1];
            smoPitch.octave = parseInt(midiPitch[2], 10);
        }
        else {
            smoPitch.accidental = 'n';
            smoPitch.octave = parseInt(midiPitch[1], 10);
        }
        return smoPitch;
    }
    static midiPitchToMidiNumber(midiPitch) {
        return SmoMusic.smoPitchToInt(SmoMusic.midiPitchToSmoPitch(midiPitch)) + 12;
    }
    static pitchToVexKey(smoPitch, head = null) {
        if (!head) {
            return SmoMusic._pitchToVexKey(smoPitch);
        }
        return SmoMusic._pitchToVexKey(smoPitch) + '/' + head;
    }
    /**
     *  Turns vex pitch string into smo pitch, e.g.
     * `cn/4 => {'c','n',4}`
     * @param vexPitch
     * @returns SmoPitch
     * */
    static vexToSmoPitch(vexPitch) {
        let octave = 0;
        const po = vexPitch.split('/');
        const rv = SmoMusic.vexToSmoKey(po[0]);
        if (po.length > 1) {
            octave = parseInt(po[1], 10);
            octave = isNaN(octave) ? 4 : octave;
        }
        else {
            octave = 4;
        }
        rv.octave = octave;
        return rv;
    }
    /**
     * Convert to smo pitch, without octave
     * ``['f#'] => [{letter:'f',accidental:'#'}]``
     * */
    static vexToSmoKey(vexPitch) {
        const accidental = vexPitch.length < 2 ? 'n' : vexPitch.substring(1, vexPitch.length);
        const pp = vexPitch.split('/')[0];
        return {
            letter: pp[0].toLowerCase(),
            accidental
        };
    }
    // {letter:'f',accidental:'#'} => [f#/
    static smoPitchesToVex(pitchAr) {
        var rv = [];
        pitchAr.forEach((p) => {
            rv.push(SmoMusic.pitchToVexKey(p));
        });
        return rv;
    }
    /**
     * @param vexKey - pitch in vex format
     * @returns pitch in vex format, sans octave
     */
    static stripVexOctave(vexKey) {
        if (vexKey.indexOf('/') > 0) {
            vexKey = vexKey.substring(0, vexKey.indexOf('/'));
        }
        return vexKey;
    }
    /**
     * compare pitches for frequency match
     */
    static pitchArraysMatch(ar1, ar2) {
        let matches = 0;
        const ir1 = SmoMusic.smoPitchesToIntArray(ar1);
        const ir2 = SmoMusic.smoPitchesToIntArray(ar2);
        if (ir1.length !== ir2.length) {
            return false;
        }
        ir1.forEach((num) => {
            if (ir2.indexOf(num) >= 0) {
                matches += 1;
            }
        });
        return matches === ir1.length;
    }
    /**
     * convert pitches to integer pitch representations
     * by calling smoPitchToInt
     * @param pitches Smo pitches
     * @returns
     */
    static smoPitchesToIntArray(pitches) {
        const rv = [];
        pitches.forEach((pitch) => {
            rv.push(SmoMusic.smoPitchToInt(pitch));
        });
        return rv.sort();
    }
    /**
     * convert a pitch to an integer value, used for transpositions, intervals, etc.
     * @param pitch
     * @returns
     */
    static smoPitchToInt(pitch) {
        if (typeof (pitch.octave) === 'undefined') {
            pitch.octave = 0;
        }
        const intVal = SmoMusic.noteValues[SmoMusic.stripVexOctave(SmoMusic.pitchToVexKey(pitch))].int_val;
        const octave = (pitch.letter === 'c' && pitch.accidental === 'b' && pitch.octave > 0) ?
            pitch.octave - 1 : pitch.octave;
        return octave * 12 + intVal;
    }
    /**
     * Convert a number to a SMO pitch
     * @param intValue - number of 1/2 steps from `c0`
     * @returns
     */
    static smoIntToPitch(intValue) {
        let octave = 0;
        let accidental = '';
        let noteKey = null;
        const letterInt = intValue >= 0 ? intValue % 12 :
            12 - (Math.abs(intValue) % 12);
        noteKey = (Object.keys(SmoMusic.noteValues).find((key) => SmoMusic.noteValues[key].int_val === letterInt && key.length === 1));
        if (!noteKey) {
            noteKey = (Object.keys(SmoMusic.noteValues).find((key) => SmoMusic.noteValues[key].int_val === letterInt && key.length === 2));
        }
        octave = Math.floor(intValue / 12);
        octave = octave >= 0 ? octave : 0;
        accidental = noteKey.substring(1, noteKey.length);
        // eslint-disable-next-line
        accidental = accidental ? accidental : 'n';
        return {
            letter: noteKey[0],
            accidental,
            octave
        };
    }
    static pitchKeyToPitch(pk) {
        return { letter: pk.letter, accidental: pk.accidental, octave: 1 };
    }
    /**
     * Consider instrument transpose when setting key -
     * e.g. Eb for Bb instruments is F. Note:  return value is not
     * a valid VEX key signature.  Use vexKeySignatureTranspose for that.
     */
    static vexKeySigWithOffset(vexKey, offset) {
        const pk = SmoMusic.vexToSmoKey(vexKey);
        const pi = SmoMusic.smoPitchToInt(SmoMusic.pitchKeyToPitch(pk)) + offset;
        let newKey = SmoMusic.toValidKeySignature(SmoMusic.pitchToVexKey(SmoMusic.smoIntToPitch(pi)));
        // handle equivalent ks
        if (newKey === 'c#' && vexKey.indexOf('b') >= 0) {
            newKey = 'db';
        }
        return newKey;
    }
    /**
     * return a map of enharmonics for choosing or cycling.  notes are in vexKey form.
     */
    static get enharmonics() {
        let i = 0;
        const rv = {};
        const keys = Object.keys(SmoMusic.noteValues);
        for (i = 0; i < keys.length; ++i) {
            const key = keys[i];
            const int_val = SmoMusic.noteValues[key].int_val;
            if (typeof (rv[int_val.toString()]) === 'undefined') {
                rv[int_val.toString()] = [];
            }
            // only consider natural note 1 time.  It is in the list twice for some reason.
            if (key.indexOf('n') === -1) {
                rv[int_val.toString()].push(key);
            }
        }
        return rv;
    }
    /**
     * Get enharmonic equivalent of given notes for cycle/choose
     * @param vexKey
     * @returns
     */
    static getEnharmonics(vexKey) {
        const proto = SmoMusic.stripVexOctave(vexKey);
        const rv = [];
        let ne = SmoMusic.getEnharmonic(vexKey);
        rv.push(proto);
        while (ne[0] !== proto[0]) {
            rv.push(ne);
            ne = SmoMusic.getEnharmonic(ne);
        }
        return rv;
    }
    /**
     * return the next note from the cycle in `getEnharmonics`
     */
    static getEnharmonic(vexKey) {
        vexKey = SmoMusic.stripVexOctave(vexKey);
        const intVal = SmoMusic.noteValues[vexKey.toLowerCase()].int_val;
        const ar = SmoMusic.enharmonics[intVal.toString()];
        const len = ar.length;
        // 'n' for natural in key but not in value
        vexKey = vexKey.length > 1 && vexKey[1] === 'n' ? vexKey[0] : vexKey;
        const ix = ar.indexOf(vexKey);
        vexKey = ar[(ix + 1) % len];
        return vexKey;
    }
    /**
     * Return a pitch a diatonic step away from SmoPitch in vexKey
     * @param smoPitch
     * @param vexKey
     * @param direction
     * @returns
     */
    static closestTonic(smoPitch, vexKey, direction) {
        direction = Math.sign(direction) < 0 ? -1 : 1;
        const tonic = SmoMusic.vexToSmoKey(vexKey);
        const rv = SmoMusic.pitchKeyToPitch(tonic);
        rv.octave = smoPitch.octave;
        const iix = SmoMusic.smoPitchToInt(smoPitch);
        const smint = SmoMusic.smoPitchToInt(rv);
        if (Math.sign(smint - iix) !== direction) {
            rv.octave += direction;
        }
        return rv;
    }
    // ### toValidKeySignature
    // When transposing, make sure key signature is valid, e.g. g# should be
    // Ab
    static toValidKeySignature(vexKey) {
        let strlen = 0;
        const map = { 'a#': 'bb', 'g#': 'ab', 'cb': 'b', 'd#': 'eb' };
        strlen = (vexKey.length > 2 ? 2 : vexKey.length);
        // Vex doesn't like 'n' in key signatures.
        if (strlen === 2 && vexKey[1].toLowerCase() === 'n') {
            strlen = 1;
        }
        const rv = vexKey.substr(0, strlen);
        if (map[rv.toLowerCase()]) {
            return map[rv.toLowerCase()];
        }
        return rv;
    }
    /**
     * When transposing, get the enharmonic that most closely fits the key
     * `getEnharmonicInKey` returns an alternate to the given pitch, or the same pitch.
     * `getKeyFriendlyEnharmonic` return a pitch for a given key, given the letter name only
     * @param smoPitch
     * @param keySignature
     * @returns
     */
    static getEnharmonicInKey(smoPitch, keySignature) {
        let match = false;
        let rv = '';
        if (typeof (smoPitch.octave) === 'undefined') {
            smoPitch.octave = 1;
        }
        const sharpKey = keySignature.indexOf('#') >= 0;
        const flatKey = keySignature.indexOf('b') >= 0;
        const ar = SmoMusic.getEnharmonics(SmoMusic.pitchToVexKey(smoPitch));
        rv = SmoMusic.stripVexOctave(SmoMusic.pitchToVexKey(smoPitch));
        const scaleMap = new VF.Music().createScaleMap(keySignature);
        ar.forEach((vexKey) => {
            if (vexKey.length === 1) {
                vexKey += 'n';
            }
            if (vexKey === scaleMap[vexKey[0]]) {
                rv = vexKey;
                match = true;
            }
            else if (!match) {
                // In the absence of a match of a key tone, we bias towards more
                // 'common', like Bb is more common than A#, esp. as a chord.  This maybe
                // just be my horn player bias towards flat keys
                if (vexKey === 'a#' && !sharpKey) {
                    rv = 'bb';
                }
                else if (vexKey === 'g#' && !sharpKey) {
                    rv = 'ab';
                }
                else if (vexKey === 'c#' && !sharpKey) {
                    rv = 'db';
                }
                else if (vexKey === 'd#' && !sharpKey) {
                    rv = 'eb';
                }
                else if (vexKey === 'f#' && flatKey) {
                    rv = 'gb';
                }
            }
        });
        const smoRv = SmoMusic.pitchKeyToPitch(SmoMusic.vexToSmoKey(rv));
        smoRv.octave = smoPitch.octave;
        const rvi = SmoMusic.smoPitchToInt(smoRv);
        const ori = SmoMusic.smoPitchToInt(smoPitch);
        // handle the case of c0 < b0, pitch-wise
        smoRv.octave += Math.sign(ori - rvi);
        return smoRv;
    }
    /**
     * fix the enharmonic to match the key, if possible
     * @example
     * `getKeyFriendlyEnharmonic('b','eb');  => returns 'bb'
     * return vex string
     * `getEnharmonicInKey` returns an alternate to the given pitch, or the same pitch.
     * `getKeyFriendlyEnharmonic` return a pitch for a given key, given the letter name only
     */
    static getKeyFriendlyEnharmonic(letter, keySignature) {
        let rv = letter;
        let i = 0;
        const muse = new VF.Music();
        const scale = Object.values(muse.createScaleMap(keySignature));
        let prop = SmoMusic.getEnharmonic(letter.toLowerCase());
        while (prop.toLowerCase() !== letter.toLowerCase()) {
            for (i = 0; i < scale.length; ++i) {
                const skey = scale[i];
                if ((skey[0] === prop && skey[1] === 'n') ||
                    (skey.toLowerCase() === prop.toLowerCase())) {
                    rv = skey;
                    break;
                }
            }
            prop = (prop[1] === 'n' ? prop[0] : prop);
            prop = SmoMusic.getEnharmonic(prop);
        }
        return rv;
    }
    /**
    // given a letter pitch (a,b,c etc.), and a key signature, return the actual note
    // that you get without accidentals
    //   `SmoMusic.getKeySignatureKey('F','G'); // returns f#`
     * @param letter
     * @param keySignature
     * @returns
     */
    static getKeySignatureKey(letter, keySignature) {
        const km = new VF.KeyManager(keySignature);
        return km.scaleMap[letter];
    }
    static getAccidentalForKeySignature(smoPitch, keySignature) {
        const vexKey = SmoMusic.getKeySignatureKey(smoPitch.letter, keySignature);
        return vexKey.length === 1 ? 'n' : vexKey.substr(1, vexKey.length - 1);
    }
    // ### isPitchInKeySignature
    // Return true if the pitch is not an accidental in the give key, e.g.
    // f# in 'g' or c in 'Bb'
    static isPitchInKeySignature(smoPitch, keySignature) {
        const vexKey = SmoMusic.getKeySignatureKey(smoPitch.letter, keySignature);
        return (vexKey.length === 1 && smoPitch.accidental === 'n' ||
            (vexKey[1] === smoPitch.accidental));
    }
    // ### getIntervalInKey
    // give a pitch and a key signature, return another pitch at the given
    // diatonic interval.  Similar to getKeyOffset but diatonic.
    static getIntervalInKey(pitch, keySignature, interval) {
        let scaleIx = 0;
        let diatonicIx = 0;
        if (interval === 0) {
            return JSON.parse(JSON.stringify(pitch));
        }
        const delta = interval > 0 ? 1 : -1;
        const inv = -1 * delta;
        const tonic = SmoMusic.closestTonic(pitch, keySignature, inv);
        const intervals = delta > 0 ? SmoMusic.scaleIntervals.up : SmoMusic.scaleIntervals.down;
        const pitchInt = SmoMusic.smoPitchToInt(pitch);
        let nkey = tonic;
        let nkeyInt = SmoMusic.smoPitchToInt(nkey);
        while (Math.sign(nkeyInt - pitchInt) !== delta && Math.sign(nkeyInt - pitchInt) !== 0) {
            nkey = SmoMusic.smoIntToPitch(SmoMusic.smoPitchToInt(nkey) + delta * intervals[scaleIx]);
            scaleIx = (scaleIx + 1) % 7;
            nkeyInt = SmoMusic.smoPitchToInt(nkey);
        }
        while (diatonicIx !== interval) {
            nkey = SmoMusic.smoIntToPitch(SmoMusic.smoPitchToInt(nkey) + delta * intervals[scaleIx]);
            scaleIx = (scaleIx + 1) % 7;
            diatonicIx += delta;
        }
        return SmoMusic.getEnharmonicInKey(nkey, keySignature);
    }
    static getLetterNotePitch(prevPitch, letter, key) {
        const pitch = JSON.parse(JSON.stringify(prevPitch));
        pitch.letter = letter;
        // Make the key 'a' make 'Ab' in the key of Eb, for instance
        const vexKsKey = SmoMusic.getKeySignatureKey(letter, key);
        if (vexKsKey.length > 1) {
            pitch.accidental = vexKsKey[1];
        }
        else {
            pitch.accidental = 'n';
        }
        // make the octave of the new note as close to previous (or next) note as possible.
        const upv = ['bc', 'ac', 'bd', 'da', 'be', 'gc'];
        const downv = ['cb', 'ca', 'db', 'da', 'eb', 'cg'];
        const delta = prevPitch.letter + pitch.letter;
        if (upv.indexOf(delta) >= 0) {
            pitch.octave += 1;
        }
        if (downv.indexOf(delta) >= 0) {
            pitch.octave -= 1;
        }
        return pitch;
    }
    /**
   * Convenience function to create SmoNote[] from letters, with the correct accidental
   * for the key signature, given duration, etc
   * @param startPitch - the pitch used to calculate the octave of the new note
   * @param clef
   * @param keySignature
   * @param duration - vex duration
   * @param letters - string of PitchLetter
   * @returns
   */
    static notesFromLetters(startPitch, clef, keySignature, duration, letters) {
        const rv = [];
        let curPitch = startPitch;
        const ticks = SmoMusic.durationToTicks(duration);
        letters.split('').forEach((letter) => {
            curPitch = SmoMusic.getLetterNotePitch(curPitch, letter, keySignature);
            const defs = note_1.SmoNote.defaults;
            defs.ticks = { numerator: ticks, denominator: 1, remainder: 0 };
            defs.pitches = [curPitch];
            defs.clef = clef;
            rv.push(new note_1.SmoNote(defs));
        });
        return rv;
    }
    /**
     * return the key signature, transposed a number of 1/2 steps in Vex key format
     * @param key start key
     * @param transposeIndex number of 1/2 steps
     * @returns {string} - vex key
     */
    static vexKeySignatureTranspose(key, transposeIndex) {
        let rv = key;
        if (key.length < 1) {
            return key;
        }
        rv = this.vexKeySigWithOffset(key, transposeIndex);
        if (rv.length === 1) {
            return rv[0].toUpperCase();
        }
        return rv[0].toUpperCase() + rv.substring(1);
        /* const pitch: Pitch = SmoMusic.pitchKeyToPitch(SmoMusic.vexToSmoKey(key));
        key = SmoMusic.smoPitchesToVexKeys([pitch], transposeIndex, null)[0];
        key = SmoMusic.stripVexOctave(key);
        key = key[0].toUpperCase() + key.substring(1, key.length);
        if (key.length > 1 && key[1] === 'n') {
          key = key[0];
        }
        return key;  */
    }
    static get frequencyMap() {
        return SmoAudioPitch.pitchFrequencyMap;
    }
    // ### get letterPitchIndex
    // Used to adjust octave when transposing.
    // Pitches are measured from c, so that b0 is higher than c0, c1 is 1 note higher etc.
    static get letterPitchIndex() {
        return {
            'c': 0,
            'd': 1,
            'e': 2,
            'f': 3,
            'g': 4,
            'a': 5,
            'b': 6
        };
    }
    /**
     * Indicate if a change from letter note 'one' to 'two' needs us to adjust the
     * octave due to the `SmoMusic.letterPitchIndex` (b0 is higher than c0)
     * */
    static letterChangedOctave(one, two) {
        const p1 = SmoMusic.letterPitchIndex[one];
        const p2 = SmoMusic.letterPitchIndex[two];
        if (p1 < p2 && p2 - p1 > 2) {
            return -1;
        }
        if (p1 > p2 && p1 - p2 > 2) {
            return 1;
        }
        return 0;
    }
    /**
     * Transpose a `Pitch` `offset` 1/2 steps
     * @param pitch
     * @param offset
     * @returns
     */
    static getKeyOffset(pitch, offset) {
        const canon = VF.Music.canonical_notes;
        // Convert to vex keys, where f# is a string like 'f#'.
        let vexKey = SmoMusic.pitchToVexKey(pitch);
        vexKey = SmoMusic.vexToCannonical(vexKey);
        const rootIndex = canon.indexOf(vexKey);
        let octave = pitch.octave;
        if (Math.abs(offset) >= 12) {
            const octaveOffset = Math.sign(offset) * Math.floor(Math.abs(offset) / 12);
            octave += octaveOffset;
            offset = offset - (12 * octaveOffset);
            if (offset < 0) {
                offset = 12 + offset;
            }
        }
        if (rootIndex + offset >= canon.length) {
            octave += 1;
        }
        if (rootIndex + offset < 0) {
            octave -= 1;
        }
        const rv = JSON.parse(JSON.stringify(pitch));
        const index = (rootIndex + canon.length + offset) % canon.length;
        vexKey = canon[index];
        if (vexKey.length > 1) {
            rv.accidental = vexKey.substring(1);
            vexKey = vexKey[0];
        }
        else {
            rv.accidental = '';
        }
        rv.letter = vexKey;
        rv.octave = octave;
        return rv;
    }
    // ### keySignatureLength
    // return the number of sharp/flat in a key signature for sizing guess.
    static get keySignatureLength() {
        return {
            'C': 0,
            'B': 5,
            'A': 3,
            'F#': 6,
            'Bb': 2,
            'Ab': 4,
            'Gg': 6,
            'G': 1,
            'F': 1,
            'Eb': 3,
            'Db': 5,
            'Cb': 7,
            'C#': 7,
            'E': 4,
            'D': 2
        };
    }
    static getSharpsInKeySignature(key) {
        const sharpKeys = ['G', 'D', 'A', 'E', 'B', 'F#', 'C#'];
        if (sharpKeys.indexOf(key.toUpperCase()) < 0) {
            return 0;
        }
        return SmoMusic.keySignatureLength[key.toUpperCase()];
    }
    static getFlatsInKeySignature(key) {
        const flatKeys = ['F', 'Bb', 'Eb', 'Ab', 'Db', 'Gb', 'Cb'];
        let caseKey = key[0].toUpperCase();
        if (key.length > 0) {
            caseKey += key.substr(1, key.length);
        }
        if (flatKeys.indexOf(caseKey) < 0) {
            return 0;
        }
        return SmoMusic.keySignatureLength[caseKey];
    }
    static midiKeyToVexKey(midiKey) {
        const sharpKeys = ['G', 'D', 'A', 'E', 'B', 'F#', 'C#'];
        const flatKeys = ['F', 'Bb', 'Eb', 'Ab', 'Db', 'Gb', 'Cb'];
        if (midiKey === 0) {
            return 'C';
        }
        const flat = midiKey < 0;
        let ix = Math.abs(midiKey) - 1;
        if (ix > 6) {
            return 'C';
        }
        if (flat) {
            return flatKeys[ix];
        }
        else {
            return sharpKeys[ix];
        }
    }
    static timeSignatureToTicks(timeSignature) {
        const nd = timeSignature.split('/');
        const num = parseInt(nd[0], 10);
        const den = parseInt(nd[1], 10);
        const base = 2048 * (8 / den);
        return base * num;
    }
    static smoTicksToVexDots(ticks) {
        const vd = SmoMusic.ticksToDuration[ticks];
        if (!vd) {
            return 0;
        }
        const dots = (vd.match(/d/g) || []).length;
        return dots;
    }
    static midiTicksForQuantizeTo(ticks) {
        const oneDot = ticks * 2;
        const twoDots = ticks * 4;
        const threeDots = ticks * 8;
        const dCount = (str) => {
            const re = /d/g;
            return ((str || '').match(re) || []).length;
        };
        return Object.keys(SmoMusic.ticksToDuration).filter((key) => {
            const keyInt = parseInt(key, 10);
            if (keyInt < ticks) {
                return false;
            }
            const dots = dCount(SmoMusic.ticksToDuration[key]);
            if (dots > 0 && keyInt < oneDot) {
                return false;
            }
            if (dots > 1 && keyInt < twoDots) {
                return false;
            }
            if (dots > 2 && keyInt < threeDots) {
                return false;
            }
            if (dots > 3) {
                return false;
            }
            return true;
        })
            .map((key) => parseInt(key, 10));
        // return Object.keys(SmoMusic.ticksToDuration).map((key) => parseInt(key, 10));    
    }
    static get midiTicksForQuantizeMap() {
        return {
            512: SmoMusic.midiTicksForQuantizeTo(1024),
            1024: SmoMusic.midiTicksForQuantizeTo(1024),
            2048: SmoMusic.midiTicksForQuantizeTo(2048)
        };
    }
    static midiTicksForQuantize(ticks) {
        return SmoMusic.midiTicksForQuantizeMap[ticks];
    }
    static binarySearch(target, ix, partition, input) {
        const test = input[ix];
        const cost = Math.abs(target - test);
        if (cost < 1) {
            return ({ cost, result: test, newIx: ix, oldIx: ix, partition: 0, input });
        }
        partition = Math.round(partition / 2) + 1;
        const step = Math.round(partition / 2);
        if (input[ix] > target) {
            return ({ cost, result: input[ix], newIx: ix - step, partition, input });
        }
        else {
            return ({ cost, result: input[ix], newIx: ix + step, partition, input });
        }
    }
    static midiTickSearch(target, quantize) {
        const tickSet = SmoMusic.midiTicksForQuantize(quantize);
        let partition = Math.round(tickSet.length / 2);
        let ix = partition;
        let best = { cost: Math.abs(tickSet[ix] - target), result: tickSet[ix], ix };
        let result = SmoMusic.binarySearch(target, ix, partition, tickSet);
        while (best.cost > 1) {
            if (best.cost > result.cost) {
                best.cost = result.cost;
                best.result = result.result;
                best.ix = ix;
            }
            ix = result.newIx;
            if (result.partition <= 3) {
                break;
            }
            result = SmoMusic.binarySearch(target, result.newIx, result.partition, tickSet);
        }
        if (result.cost > 1 && result.partition > 0) {
            let i = 0;
            const ix = best.ix;
            const step = best.result > target ? -1 : 1;
            for (i = 0; i < (result.partition + 2) && (i * step) + ix < tickSet.length && (i * step) + ix >= 0; ++i) {
                const newIx = (i * step) + ix;
                const cost = Math.abs(target - tickSet[newIx]);
                if (best.cost > cost) {
                    best.cost = cost;
                    best.ix = (i * step) + ix;
                    best.result = tickSet[(i * step) + ix];
                }
            }
        }
        return { cost: best.cost, result: best.result };
    }
    // ## closestVexDuration
    // ## Description:
    // return the closest vex duration >= to the actual number of ticks. Used in beaming
    // triplets which have fewer ticks then their stem would normally indicate.
    static closestVexDuration(ticks) {
        let stemTicks = VF.RESOLUTION;
        // The stem value is the type on the non-tuplet note, e.g. 1/8 note
        // for a triplet.
        while (ticks <= stemTicks) {
            stemTicks = stemTicks / 2;
        }
        stemTicks = stemTicks * 2;
        return SmoMusic.ticksToDuration[stemTicks];
    }
    // ### closestDurationTickLtEq
    // Price is right style, closest tick value without going over.  Used to pad
    // rests when reading musicXML.
    static closestDurationTickLtEq(ticks) {
        const sorted = Object.keys(SmoMusic.ticksToDuration)
            .map((key) => parseInt(key, 10))
            .filter((key) => key <= ticks);
        return sorted[sorted.length - 1];
    }
    /**
     * Return array of valid note-lengths from an odd number of ticks,
     * so we can come as close as possible to representing the ticks with notes
     * @param ticks
     * @returns
     */
    static splitIntoValidDurations(ticks) {
        const rv = [];
        let closest = 0;
        while (ticks > 128) {
            closest = SmoMusic.closestDurationTickLtEq(ticks);
            ticks -= closest;
            rv.push(closest);
        }
        return rv;
    }
    // ### vexStemType
    // return the vex stem type (no dots)
    static vexStemType(ticks) {
        const str = SmoMusic.ticksToDuration[SmoMusic.splitIntoValidDurations(ticks)[0]];
        if (str.indexOf('d') >= 0) {
            return str.substr(0, str.indexOf('d'));
        }
        return str;
    }
    // ### Description:
    // Get ticks for this note with an added dot.  Return
    // identity if that is not a supported value.
    static getNextDottedLevel(ticks) {
        const ttd = SmoMusic.ticksToDuration;
        const vals = Object.values(ttd);
        const ix = vals.indexOf(ttd[ticks]);
        if (ix >= 0 && ix < vals.length && vals[ix][0] === vals[ix + 1][0]) {
            return SmoMusic.durationToTicks(vals[ix + 1]);
        }
        return ticks;
    }
    // ### Description:
    // Get ticks for this note with one fewer dot.  Return
    // identity if that is not a supported value.
    static getPreviousDottedLevel(ticks) {
        const ttd = SmoMusic.ticksToDuration;
        const vals = Object.values(ttd);
        const ix = vals.indexOf(ttd[ticks]);
        if (ix > 0 && vals[ix][0] === vals[ix - 1][0]) {
            return SmoMusic.durationToTicks(vals[ix - 1]);
        }
        return ticks;
    }
    // ### ticksToDuration
    // Frequently we double/halve a note duration, and we want to find the vex tick duration that goes with that.
    static get ticksToDuration() {
        let i = 0;
        const durations = ['1/2', '1', '2', '4', '8', '16', '32', '64', '128', '256'];
        const _ticksToDurationsF = () => {
            for (i = 0; i < durations.length - 1; ++i) {
                let j = 0;
                let dots = '';
                let ticks = 0;
                // We support up to 4 'dots'
                for (j = 0; j <= 4 && j + i < durations.length; ++j) {
                    ticks += VF.durationToTicks(durations[i + j]);
                    SmoMusic._ticksToDuration[ticks.toString()] = durations[i] + dots;
                    dots += 'd';
                }
            }
        };
        if (Object.keys(SmoMusic._ticksToDuration).length < 1) {
            _ticksToDurationsF();
        }
        return SmoMusic._ticksToDuration;
    }
    // ### durationToTicks
    // Uses VF.durationToTicks, but handles dots.
    static durationToTicks(duration) {
        let split = 0;
        let i = 0;
        let vfDuration = 0;
        let dots = duration.indexOf('d');
        if (dots < 0) {
            return VF.durationToTicks(duration);
        }
        else {
            vfDuration = VF.durationToTicks(duration.substring(0, dots));
            dots = duration.length - dots; // number of dots
            split = vfDuration / 2;
            for (i = 0; i < dots; ++i) {
                vfDuration += split;
                split = split / 2;
            }
            return vfDuration;
        }
    }
    /**
     * break the duration up into an array of durations, to split a long
     * note up between bars when pasting.
     * @param duration
     * @returns
     */
    static gcdMap(duration) {
        let k = 0;
        const keys = Object.keys(SmoMusic.ticksToDuration).map((x) => parseInt(x, 10));
        const dar = [];
        const gcd = (td) => {
            let rv = keys[0];
            for (k = 1; k < keys.length; ++k) {
                if (td % keys[k] === 0) {
                    rv = keys[k];
                }
            }
            return rv;
        };
        while (duration > 0 && !SmoMusic.ticksToDuration[duration]) {
            const div = gcd(duration);
            duration = duration - div;
            dar.push(div);
        }
        if (duration > 0) {
            dar.push(duration);
        }
        return dar.sort((a, b) => a > b ? -1 : 1);
    }
}
exports.SmoMusic = SmoMusic;
/**
 * an array of clefs and the xml information they map to
 */
SmoMusic.clefSigns = {
    'treble': { sign: 'G', line: 2 },
    'bass': { sign: 'F', line: 4 },
    'tenor': { sign: 'C', line: 4 },
    'alto': { sign: 'C', line: 3 },
    'soprano': { sign: 'C', line: 1 },
    'percussion': { sign: 'percussion' },
    'mezzo-soprano': { sign: 'C', line: 2 },
    'baritone-c': { sign: 'C', line: 5 },
    'baritone-f': { sign: 'F', line: 3 },
    'subbass': { sign: 'F', line: 3, octave: -1 },
    'french': { sign: 'G', line: 1 },
    'vocal-tenor': { sign: 'G', line: 2, octave: -1 }
};
SmoMusic._ticksToDuration = {};


/***/ }),

/***/ "./src/smo/data/note.ts":
/*!******************************!*\
  !*** ./src/smo/data/note.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SmoNote = exports.NoteBooleanParams = exports.NoteNumberParams = exports.NoteStringParams = void 0;
// [Smoosic](https://github.com/AaronDavidNewman/Smoosic)
// Copyright (c) Aaron David Newman 2021.
/**
 * Classes to support {@link SmoNote}.  Notes have pitches and a duration, and other
 * modifiers that can affect display or playback.
 * @module /smo/data/note
 */
const serializationHelpers_1 = __webpack_require__(/*! ../../common/serializationHelpers */ "./src/common/serializationHelpers.js");
const noteModifiers_1 = __webpack_require__(/*! ./noteModifiers */ "./src/smo/data/noteModifiers.ts");
const music_1 = __webpack_require__(/*! ./music */ "./src/smo/data/music.ts");
const VF = eval('Vex.Flow');
// @internal
exports.NoteStringParams = ['noteHead', 'clef'];
// @internal
exports.NoteNumberParams = ['beamBeats', 'flagState'];
// @internal
exports.NoteBooleanParams = ['hidden', 'endBeam', 'isCue'];
/**
 * SmoNote contains the pitch and duration of a note or chord.
 * It can also contain arrays of modifiers like lyrics, articulations etc.
 * Also information about the beaming, flag etc.
 * @category SmoObject
 * */
class SmoNote {
    constructor(params) {
        this.flagState = SmoNote.flagStates.auto;
        this.textModifiers = [];
        this.articulations = [];
        this.ornaments = [];
        this.pitches = [];
        this.noteHead = '';
        this.clef = 'treble';
        this.graceNotes = [];
        this.noteType = 'n';
        this.fillStyle = '';
        this.hidden = false;
        this.tuplet = null;
        this.tones = [];
        this.endBeam = false;
        this.ticks = { numerator: 4096, denominator: 1, remainder: 0 };
        this.beamBeats = 4096;
        this.beam_group = null;
        this.renderId = null;
        this.keySignature = 'c';
        this.logicalBox = null;
        this.isCue = false;
        this.accidentalsRendered = []; // set by renderer if accidental is to display
        const defs = SmoNote.defaults;
        exports.NoteStringParams.forEach((param) => {
            this[param] = params[param] ? params[param] : defs[param];
        });
        this.noteType = params.noteType ? params.noteType : defs.noteType;
        exports.NoteNumberParams.forEach((param) => {
            this[param] = params[param] ? params[param] : defs[param];
        });
        exports.NoteBooleanParams.forEach((param) => {
            this[param] = params[param] ? params[param] : defs[param];
        });
        const ticks = params.ticks ? params.ticks : defs.ticks;
        const pitches = params.pitches ? params.pitches : defs.pitches;
        this.ticks = JSON.parse(JSON.stringify(ticks));
        this.pitches = JSON.parse(JSON.stringify(pitches));
        this.clef = params.clef ? params.clef : defs.clef;
        this.fillStyle = params.fillStyle ? params.fillStyle : '';
        if (params.tuplet) {
            this.tuplet = params.tuplet;
        }
        this.attrs = {
            id: VF.Element.newID(),
            type: 'SmoNote'
        }; // else inherit
    }
    static get flagStates() {
        return { auto: 0, up: 1, down: 2 };
    }
    /**
     * used in serialization
     * @internal
     */
    static get parameterArray() {
        return ['ticks', 'pitches', 'noteType', 'tuplet', 'clef', 'isCue',
            'endBeam', 'beamBeats', 'flagState', 'noteHead', 'fillStyle', 'hidden'];
    }
    /**
     * Default constructor parameters.  We always return a copy so the caller can modify it
     */
    static get defaults() {
        return JSON.parse(JSON.stringify({
            noteType: 'n',
            noteHead: 'n',
            clef: 'treble',
            textModifiers: [],
            articulations: [],
            graceNotes: [],
            ornaments: [],
            tones: [],
            endBeam: false,
            fillStyle: '',
            hidden: false,
            beamBeats: 4096,
            isCue: false,
            flagState: SmoNote.flagStates.auto,
            ticks: {
                numerator: 4096,
                denominator: 1,
                remainder: 0
            },
            pitches: [{
                    letter: 'b',
                    octave: 4,
                    accidental: 'n'
                }],
        }));
    }
    /**
     * Up, down auto (tri-state)
     */
    toggleFlagState() {
        this.flagState = (this.flagState + 1) % 3;
    }
    // @internal
    toVexStemDirection() {
        return (this.flagState === SmoNote.flagStates.up ? VF.Stem.UP : VF.Stem.DOWN);
    }
    get dots() {
        if (this.isTuplet) {
            return 0;
        }
        const vexDuration = music_1.SmoMusic.ticksToDuration[this.tickCount];
        if (!vexDuration) {
            return 0;
        }
        return vexDuration.split('d').length - 1;
    }
    _addModifier(dynamic, toAdd) {
        var tms = [];
        this.textModifiers.forEach((tm) => {
            if (tm.attrs.type !== dynamic.attrs.type) {
                tms.push(tm);
            }
        });
        if (toAdd) {
            tms.push(dynamic);
        }
        this.textModifiers = tms;
    }
    _addArticulation(articulation, toAdd) {
        var tms = [];
        this.articulations.forEach((tm) => {
            if (tm.articulation !== articulation.articulation) {
                tms.push(tm);
            }
        });
        if (toAdd) {
            tms.push(articulation);
        }
        this.articulations = tms;
    }
    /**
     * Add a new dynamic to thisnote
     * @param dynamic
     */
    addDynamic(dynamic) {
        this._addModifier(dynamic, true);
    }
    /**
     * Remove the dynamic from this note.
     * @param dynamic
     */
    removeDynamic(dynamic) {
        this._addModifier(dynamic, false);
    }
    /**
     * Get all note modifiers of a type, either a lyric or a dynamic
     * @param type ctor
     * @returns
     */
    getModifiers(type) {
        var ms = this.textModifiers.filter((mod) => mod.attrs.type === type);
        return ms;
    }
    /**
     *
     * @returns the longest lyric, used for formatting
     */
    longestLyric() {
        const tms = this.textModifiers.filter((mod) => mod.attrs.type === 'SmoLyric' && mod.parser === noteModifiers_1.SmoLyric.parsers.lyric);
        if (!tms.length) {
            return null;
        }
        return tms.reduce((m1, m2) => m1.getText().length > m2.getText().length ? m1 : m2);
    }
    /** Add a lyric to this note, replacing another in the same verse */
    addLyric(lyric) {
        const tms = this.textModifiers.filter((mod) => mod.attrs.type !== 'SmoLyric' || mod.parser !== lyric.parser ||
            mod.verse !== lyric.verse);
        tms.push(lyric);
        this.textModifiers = tms;
    }
    /**
     * @returns array of lyrics that are lyrics
     */
    getTrueLyrics() {
        const ms = this.textModifiers.filter((mod) => mod.attrs.type === 'SmoLyric' && mod.parser === noteModifiers_1.SmoLyric.parsers.lyric);
        ms.sort((a, b) => a.verse - b.verse);
        return ms;
    }
    /**
     *
     * @returns array of SmoLyric whose parsers are chord
     */
    getChords() {
        const ms = this.textModifiers.filter((mod) => mod.attrs.type === 'SmoLyric' && mod.parser === noteModifiers_1.SmoLyric.parsers.chord);
        return ms;
    }
    /**
     *
     * @param lyric lyric to remove, find the best match if there are multiples
     */
    removeLyric(lyric) {
        const tms = this.textModifiers.filter((mod) => mod.attrs.type !== 'SmoLyric' || mod.verse !== lyric.verse || mod.parser !== lyric.parser);
        this.textModifiers = tms;
    }
    /**
     *
     * @param verse
     * @param parser
     * @returns
     */
    getLyricForVerse(verse, parser) {
        return this.textModifiers.filter((mod) => mod.attrs.type === 'SmoLyric' && mod.parser === parser && mod.verse === verse);
    }
    /**
     *
     * @param fontInfo
     */
    setLyricFont(fontInfo) {
        const lyrics = this.getTrueLyrics();
        lyrics.forEach((lyric) => {
            lyric.fontInfo = JSON.parse(JSON.stringify(fontInfo));
        });
    }
    /**
     * @param adjustNoteWidth if true, vex will consider the lyric width when formatting the measure
     */
    setLyricAdjustWidth(adjustNoteWidth) {
        const lyrics = this.getTrueLyrics();
        lyrics.forEach((lyric) => {
            lyric.adjustNoteWidth = adjustNoteWidth;
        });
    }
    setChordAdjustWidth(adjustNoteWidth) {
        const chords = this.getChords();
        chords.forEach((chord) => {
            chord.adjustNoteWidth = adjustNoteWidth;
        });
    }
    setChordFont(fontInfo) {
        const chords = this.getChords();
        chords.forEach((chord) => {
            chord.fontInfo = JSON.parse(JSON.stringify(fontInfo));
        });
    }
    getOrnaments() {
        return this.ornaments.filter((oo) => oo.isJazz() === false);
    }
    getJazzOrnaments() {
        return this.ornaments.filter((oo) => oo.isJazz());
    }
    /**
     * Toggle the ornament up/down/off
     * @param ornament
     */
    toggleOrnament(ornament) {
        const aix = this.ornaments.filter((a) => a.attrs.type === 'SmoOrnament' && a.ornament === ornament.ornament);
        if (!aix.length) {
            this.ornaments.push(ornament);
        }
        else {
            this.ornaments = [];
        }
    }
    /**
     * Toggle the ornament up/down/off
     * @param articulation
     */
    toggleArticulation(articulation) {
        var aix = this.articulations.findIndex((a) => a.articulation === articulation.articulation);
        if (aix >= 0) {
            const cur = this.articulations[aix];
            if (cur.position === noteModifiers_1.SmoArticulation.positions.above) {
                cur.position = noteModifiers_1.SmoArticulation.positions.below;
                return;
            }
            else {
                this._addArticulation(articulation, false);
                return;
            }
        }
        this._addArticulation(articulation, true);
    }
    /**
     * Sort pitches in pitch order, Vex likes to receive pitches in order
     * @param note
     */
    static sortPitches(note) {
        const canon = VF.Music.canonical_notes;
        const keyIndex = ((pitch) => canon.indexOf(pitch.letter) + pitch.octave * 12);
        note.pitches.sort((a, b) => keyIndex(a) - keyIndex(b));
    }
    setNoteHead(noteHead) {
        if (this.noteHead === noteHead) {
            this.noteHead = '';
        }
        else {
            this.noteHead = noteHead;
        }
    }
    /**
     *
     * @param graceNote
     * @param offset the index from the first grace note
     */
    addGraceNote(graceNote, offset) {
        if (typeof (offset) === 'undefined') {
            offset = 0;
        }
        graceNote.clef = this.clef;
        this.graceNotes.push(graceNote);
    }
    removeGraceNote(offset) {
        if (offset >= this.graceNotes.length) {
            return;
        }
        this.graceNotes.splice(offset, 1);
    }
    getGraceNotes() {
        return this.graceNotes;
    }
    /**
     * Add another pitch to this note at `offset` 1/2 steps
     * @param note
     * @param offset
     */
    static addPitchOffset(note, offset) {
        if (note.pitches.length === 0) {
            return;
        }
        note.noteType = 'n';
        const pitch = note.pitches[0];
        note.pitches.push(music_1.SmoMusic.getKeyOffset(pitch, offset));
        SmoNote.sortPitches(note);
    }
    /**
     * Add another pitch to this note at `offset` 1/2 steps
     * @param offset
     * @returns
     */
    addPitchOffset(offset) {
        if (this.pitches.length === 0) {
            return;
        }
        this.noteType = 'n';
        const pitch = this.pitches[0];
        this.pitches.push(music_1.SmoMusic.getKeyOffset(pitch, offset));
        SmoNote.sortPitches(this);
    }
    toggleRest() {
        this.noteType = (this.noteType === 'r' ? 'n' : 'r');
    }
    toggleSlash() {
        this.noteType = (this.noteType === '/' ? 'n' : '/');
    }
    makeSlash() {
        this.noteType = '/';
    }
    makeRest() {
        this.noteType = 'r';
    }
    isRest() {
        return this.noteType === 'r';
    }
    isSlash() {
        return this.noteType === '/';
    }
    isHidden() {
        return this.hidden;
    }
    makeNote() {
        this.noteType = 'n';
        // clear fill style if we were hiding rests
        this.fillStyle = '';
        this.hidden = false;
    }
    /**
     * set note opacity on/off
     * @param val
     */
    makeHidden(val) {
        this.hidden = val;
        this.fillStyle = val ? '#aaaaaa7f' : '';
    }
    /**
     * Return true if this note is part of a tuplet
     */
    get isTuplet() {
        return this.tuplet !== null && typeof (this.tuplet.id) !== 'undefined';
    }
    addMicrotone(tone) {
        const ar = this.tones.filter((tn) => tn.pitchIndex !== tone.pitchIndex);
        ar.push(tone);
        this.tones = ar;
    }
    removeMicrotone(tone) {
        const ar = this.tones.filter((tn) => tn.pitchIndex !== tone.pitchIndex
            && tn.pitchIndex <= this.pitches.length // also remove tones for removed pitches
            && tone.tone !== tn.tone);
        this.tones = ar;
    }
    getMicrotone(toneIndex) {
        return this.tones.find((tn) => tn.pitchIndex === toneIndex);
    }
    getMicrotones() {
        return this.tones;
    }
    /**
     * cycle through the list of enharmonics for this note.
     * @param pitch
     * @returns
     */
    static toggleEnharmonic(pitch) {
        const lastLetter = pitch.letter;
        let vexPitch = music_1.SmoMusic.stripVexOctave(music_1.SmoMusic.pitchToVexKey(pitch));
        vexPitch = music_1.SmoMusic.getEnharmonic(vexPitch);
        pitch.letter = vexPitch[0];
        pitch.accidental = vexPitch.length > 1 ?
            vexPitch.substring(1, vexPitch.length) : 'n';
        pitch.octave += music_1.SmoMusic.letterChangedOctave(lastLetter, pitch.letter);
        return pitch;
    }
    /**
     * transpose a note or grace note to a key-friendly enharmonic
     * @param pitchArray
     * @param offset
     * @param originalKey - keySignature from original note
     * @param destinationKey - keySignature we are transposing into
     * @returns
     */
    transpose(pitchArray, offset, originalKey, destinationKey) {
        return SmoNote.transpose(this, pitchArray, offset, originalKey, destinationKey);
    }
    /**
     * used to add chord and pitch by piano widget
     * @param pitch
     */
    toggleAddPitch(pitch) {
        const pitches = [];
        let exists = false;
        this.pitches.forEach((o) => {
            if (o.letter !== pitch.letter ||
                o.octave !== pitch.octave ||
                o.accidental !== pitch.accidental) {
                pitches.push(o);
            }
            else {
                exists = true;
            }
        });
        this.pitches = pitches;
        if (!exists) {
            this.pitches.push(JSON.parse(JSON.stringify(pitch)));
            this.noteType = 'n';
        }
        SmoNote.sortPitches(this);
    }
    /**
     * @param note note to transpose
     * @param pitchArray an array of indices (not pitches) that indicate which pitches get altered if a chord
     * @param offset in 1/2 step
     * @param originalKey original key for enharmonic-friendly key
     * @param destinationKey destination key signature
     * @returns
     */
    static transpose(note, pitchArray, offset, originalKey, destinationKey) {
        let index = 0;
        let j = 0;
        if (offset === 0 && originalKey === destinationKey) {
            return note;
        }
        // If no specific pitch, use all the pitches
        if (pitchArray.length === 0) {
            pitchArray = Array.from(note.pitches.keys());
        }
        for (j = 0; j < pitchArray.length; ++j) {
            index = pitchArray[j];
            if (index + 1 > note.pitches.length) {
                SmoNote.addPitchOffset(note, offset);
            }
            else {
                const original = JSON.parse(JSON.stringify(note.pitches[index]));
                const pitch = music_1.SmoMusic.transposePitchForKey(original, originalKey, destinationKey, offset);
                note.pitches[index] = pitch;
            }
        }
        SmoNote.sortPitches(note);
        return note;
    }
    get tickCount() {
        return this.ticks.numerator / this.ticks.denominator + this.ticks.remainder;
    }
    /**
     * Copy the note, give it unique id
     * @param note
     * @returns
     */
    static clone(note) {
        var rv = SmoNote.deserialize(note.serialize());
        // make sure id is unique
        rv.attrs = {
            id: VF.Element.newID(),
            type: 'SmoNote'
        };
        return rv;
    }
    /**
     * @param note
     * @param ticks
     * @returns A note identical to `note` but with different duration
     */
    static cloneWithDuration(note, ticks) {
        if (typeof (ticks) === 'number') {
            ticks = { numerator: ticks, denominator: 1, remainder: 0 };
        }
        const rv = SmoNote.clone(note);
        rv.ticks = ticks;
        return rv;
    }
    static serializeModifier(modifiers) {
        const rv = [];
        modifiers.forEach((modifier) => {
            rv.push(modifier.serialize());
        });
        return rv;
    }
    _serializeModifiers(params) {
        params.textModifiers = SmoNote.serializeModifier(this.textModifiers);
        params.graceNotes = SmoNote.serializeModifier(this.graceNotes);
        params.articulations = SmoNote.serializeModifier(this.articulations);
        params.ornaments = SmoNote.serializeModifier(this.ornaments);
        params.tones = SmoNote.serializeModifier(this.tones);
    }
    /**
     * @returns a JSON object that can be used to create this note
     */
    serialize() {
        var params = {};
        serializationHelpers_1.smoSerialize.serializedMergeNonDefault(SmoNote.defaults, SmoNote.parameterArray, this, params);
        if (params.ticks) {
            params.ticks = JSON.parse(JSON.stringify(params.ticks));
        }
        this._serializeModifiers(params);
        return params;
    }
    /**
     * restore note modifiers and create a SmoNote object
     * @param jsonObj
     * @returns
     */
    static deserialize(jsonObj) {
        var note = new SmoNote(jsonObj);
        if (jsonObj.textModifiers) {
            jsonObj.textModifiers.forEach((mod) => {
                note.textModifiers.push(noteModifiers_1.SmoNoteModifierBase.deserialize(mod));
            });
        }
        if (jsonObj.graceNotes) {
            jsonObj.graceNotes.forEach((mod) => {
                note.graceNotes.push(noteModifiers_1.SmoNoteModifierBase.deserialize(mod));
            });
        }
        if (jsonObj.ornaments) {
            jsonObj.ornaments.forEach((mod) => {
                note.ornaments.push(noteModifiers_1.SmoNoteModifierBase.deserialize(mod));
            });
        }
        if (jsonObj.articulations) {
            jsonObj.articulations.forEach((mod) => {
                note.articulations.push(noteModifiers_1.SmoNoteModifierBase.deserialize(mod));
            });
        }
        if (jsonObj.tones) {
            jsonObj.tones.forEach((mod) => {
                note.tones.push(noteModifiers_1.SmoNoteModifierBase.deserialize(mod));
            });
        }
        // Due to a bug, text modifiers were serialized into noteModifiers array
        if (jsonObj.noteModifiers) {
            jsonObj.noteModifiers.forEach((mod) => {
                note.textModifiers.push(noteModifiers_1.SmoNoteModifierBase.deserialize(mod));
            });
        }
        return note;
    }
}
exports.SmoNote = SmoNote;


/***/ }),

/***/ "./src/smo/data/noteModifiers.ts":
/*!***************************************!*\
  !*** ./src/smo/data/noteModifiers.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SmoDynamicText = exports.SmoLyric = exports.SmoArticulation = exports.SmoOrnament = exports.SmoMicrotone = exports.SmoGraceNote = exports.SmoNoteModifierBase = void 0;
const serializationHelpers_1 = __webpack_require__(/*! ../../common/serializationHelpers */ "./src/common/serializationHelpers.js");
const music_1 = __webpack_require__(/*! ./music */ "./src/smo/data/music.ts");
const VF = eval('Vex.Flow');
// const Smo = eval('globalThis.Smo');
/**
 * A note modifier is anything that is mapped to the note, but not part of the
 * pitch itself.  This includes grace notes, and note-text like lyrics.
 * All note modifiers have a serialize method and a 'ctor' parameter or deserialization
 * @category SmoModifier
 */
class SmoNoteModifierBase {
    constructor(ctor) {
        this.logicalBox = null;
        this.element = null;
        this.attrs = {
            id: VF.Element.newID(),
            type: ctor
        };
        this.ctor = ctor;
    }
    static deserialize(jsonObj) {
        const ctor = eval('globalThis.Smo.' + jsonObj.ctor);
        // Handle backwards-compatibility thing
        if (jsonObj.ctor === 'SmoMicrotone' && typeof (jsonObj.pitch) === 'number') {
            jsonObj.pitchIndex = jsonObj.pitch;
        }
        if (typeof (ctor) === 'undefined') {
            console.log('ouch bad ctor for ' + jsonObj.ctor);
        }
        const rv = new ctor(jsonObj);
        return rv;
    }
}
exports.SmoNoteModifierBase = SmoNoteModifierBase;
/**
 * A grace notes has many of the things an 'actual' note can have, but it doesn't take up
 * time against the time signature
 * @category SmoModifier
 */
class SmoGraceNote extends SmoNoteModifierBase {
    constructor(parameters) {
        super('SmoGraceNote');
        this.ticks = SmoGraceNote.defaults.ticks;
        this.pitches = [];
        this.slash = false;
        this.clef = 'treble';
        this.noteType = 'n';
        this.renderId = null;
        serializationHelpers_1.smoSerialize.serializedMerge(SmoGraceNote.parameterArray, SmoGraceNote.defaults, this);
        serializationHelpers_1.smoSerialize.serializedMerge(SmoGraceNote.parameterArray, parameters, this);
    }
    static get flagStates() {
        return { auto: 0, up: 1, down: 2 };
    }
    static get defaults() {
        return JSON.parse(JSON.stringify({
            ctor: 'SmoGraceNote',
            flagState: SmoGraceNote.flagStates.auto,
            noteType: 'n',
            beamBeats: 4096,
            endBeam: false,
            clef: 'treble',
            slash: false,
            ticks: {
                numerator: 4096,
                denominator: 1,
                remainder: 0
            },
            pitches: [{
                    letter: 'b',
                    octave: 4,
                    accidental: ''
                }]
        }));
    }
    // TODO: Matches SmoNote - move to SmoMusic?
    static get parameterArray() {
        const rv = [];
        // eslint-disable-next-line
        for (const key in SmoGraceNote.defaults) {
            rv.push(key);
        }
        return rv;
    }
    tickCount() {
        return this.ticks.numerator / this.ticks.denominator + this.ticks.remainder;
    }
    toVexGraceNote() {
        const p = music_1.SmoMusic.smoPitchesToVex(this.pitches);
        const rv = { duration: music_1.SmoMusic.closestVexDuration(this.tickCount()), keys: p, slash: this.slash };
        return rv;
    }
    serialize() {
        const params = {};
        serializationHelpers_1.smoSerialize.serializedMergeNonDefault(SmoGraceNote.defaults, SmoGraceNote.parameterArray, this, params);
        return params;
    }
}
exports.SmoGraceNote = SmoGraceNote;
/**
 * Microtones are treated similarly to ornaments.  There are not
 * rules for persisting throughout a measure, cancel etc.
 * @category SmoModifier
*/
class SmoMicrotone extends SmoNoteModifierBase {
    constructor(parameters) {
        super(parameters.ctor);
        this.pitchIndex = 0;
        this.pitchIndex = parameters.pitch;
        this.tone = parameters.tone;
    }
    get toPitchCoeff() {
        return SmoMicrotone.pitchCoeff[this.tone];
    }
    get toVex() {
        return SmoMicrotone.smoToVex[this.tone];
    }
    static get parameterArray() {
        const rv = [];
        // eslint-disable-next-line
        for (const key in SmoMicrotone.defaults) {
            rv.push(key);
        }
        return rv;
    }
    serialize() {
        var params = {};
        serializationHelpers_1.smoSerialize.serializedMergeNonDefault(SmoMicrotone.defaults, SmoMicrotone.parameterArray, this, params);
        return params;
    }
}
exports.SmoMicrotone = SmoMicrotone;
// This is how VexFlow notates them
SmoMicrotone.smoToVex = {
    flat75sz: 'db',
    flat25sz: 'd',
    flat25ar: 'bs',
    flat125ar: 'afhf',
    sharp75: '++',
    sharp125: 'ashs',
    sharp25: '+',
    sori: 'o',
    koron: 'k'
};
// The audio frequency offsets
SmoMicrotone.pitchCoeff = {
    flat75sz: -1.5,
    flat25sz: -0.5,
    flat25ar: -0.5,
    flat125ar: -2.5,
    sharp75: 1.5,
    sharp125: 2.5,
    sharp25: 0.5,
    sori: 0.5,
    koron: -0.5
};
SmoMicrotone.defaults = {
    ctor: 'SmoMicrotone',
    tone: 'flat25sz',
    pitch: 0
};
/**
 * Ornaments map to vex ornaments.  articulations vs. ornaments
 * is kind of arbitrary
 * @category SmoModifier
 */
class SmoOrnament extends SmoNoteModifierBase {
    constructor(parameters) {
        super('SmoOrnament');
        this.position = SmoOrnament.positions.above;
        this.offset = 'on';
        this.ornament = SmoOrnament.ornaments.mordent;
        serializationHelpers_1.smoSerialize.serializedMerge(SmoOrnament.parameterArray, SmoOrnament.defaults, this);
        serializationHelpers_1.smoSerialize.serializedMerge(SmoOrnament.parameterArray, parameters, this);
        // this.selector = parameters.selector;
    }
    static get jazzOrnaments() {
        return ['SCOOP', 'FALL_SHORT', 'FALL_LONG', 'DOIT', 'LIFT', 'FLIP', 'SMEAR'];
    }
    toVex() {
        return SmoOrnament.ornaments[this.ornament.toLowerCase()];
    }
    isJazz() {
        return SmoOrnament.jazzOrnaments.indexOf(this.ornament) >= 0;
    }
    static get parameterArray() {
        const rv = [];
        // eslint-disable-next-line
        for (const key in SmoOrnament.defaults) {
            rv.push(key);
        }
        return rv;
    }
    static get positions() {
        return {
            above: 'above',
            below: 'below'
        };
    }
    static get offsets() {
        return {
            on: 'on',
            after: 'after'
        };
    }
    static get defaults() {
        return JSON.parse(JSON.stringify({
            ctor: 'SmoOrnament',
            ornament: SmoOrnament.ornaments.mordent,
            position: SmoOrnament.positions.above,
            offset: SmoOrnament.offsets.on
        }));
    }
    serialize() {
        var params = {};
        serializationHelpers_1.smoSerialize.serializedMergeNonDefault(SmoOrnament.defaults, SmoOrnament.parameterArray, this, params);
        return params;
    }
}
exports.SmoOrnament = SmoOrnament;
SmoOrnament.ornaments = {
    mordent: 'mordent',
    mordentInverted: 'mordent_inverted',
    turn: 'turn',
    turnInverted: 'turn_inverted',
    trill: 'tr',
    upprall: 'upprall',
    prallup: 'prallup',
    pralldown: 'pralldown',
    upmordent: 'upmordent',
    downmordent: 'downmordent',
    lineprall: 'lineprall',
    prallprall: 'prallprall',
    scoop: 'scoop',
    fall_short: 'fall',
    dropLong: 'fallLong',
    doit: 'doit',
    doitLong: 'doitLong',
    flip: 'flip',
    smear: 'smear'
};
SmoOrnament.xmlOrnaments = {
    mordent: 'mordent',
    mordent_inverted: 'inverted-mordent',
    turn: 'turn',
    turn_inverted: 'inverted-turn',
    upmordent: 'mordent',
    downmordent: 'mordent',
    lineprall: 'schleifer',
    prallprall: 'schleifer',
    prallup: 'schleifer',
    tr: 'trill-mark'
};
// jazz ornaments in vex are articulations in music xml
SmoOrnament.xmlJazz = {
    doit: 'doit',
    scoop: 'scoop',
    dropLong: 'falloff',
    drop: 'plop'
};
/**
 * Articulations map to notes, can be placed above/below
 * @category SmoModifier
 */
class SmoArticulation extends SmoNoteModifierBase {
    constructor(parameters) {
        super('SmoArticulation');
        this.position = SmoOrnament.positions.above;
        this.offset = 0;
        this.articulation = SmoArticulation.articulations.accent;
        this.adjX = 0;
        serializationHelpers_1.smoSerialize.serializedMerge(SmoArticulation.parameterArray, SmoArticulation.defaults, this);
        serializationHelpers_1.smoSerialize.serializedMerge(SmoArticulation.parameterArray, parameters, this);
        // this.selector = parameters.selector;
    }
    static get articulations() {
        return {
            accent: 'accent',
            staccato: 'staccato',
            marcato: 'marcato',
            tenuto: 'tenuto',
            upStroke: 'upStroke',
            downStroke: 'downStroke',
            pizzicato: 'pizzicato',
            fermata: 'fermata'
        };
    }
    static get positions() {
        return {
            above: 'above',
            below: 'below'
        };
    }
    static get articulationToVex() {
        return {
            accent: 'a>',
            staccato: 'a.',
            marcato: 'a^',
            tenuto: 'a-',
            upStroke: 'a|',
            downStroke: 'am',
            pizzicato: 'ao',
            fermata: 'a@a'
        };
    }
    static get vexToArticulation() {
        return {
            'a>': 'accent',
            'a.': 'staccato',
            'a^': 'marcato',
            'a-': 'tenuto',
            'a|': 'upStroke',
            'am': 'downStroke',
            'ao': 'pizzicato',
            'a@a': 'fermata'
        };
    }
    static get parameterArray() {
        const rv = [];
        // eslint-disable-next-line
        for (const key in SmoArticulation.defaults) {
            rv.push(key);
        }
        return rv;
    }
    static get positionToVex() {
        return {
            'above': 3,
            'below': 4
        };
    }
    static get defaults() {
        return JSON.parse(JSON.stringify({
            ctor: 'SmoArticulation',
            position: SmoArticulation.positions.above,
            articulation: SmoArticulation.articulations.accent
        }));
    }
    serialize() {
        var params = {};
        serializationHelpers_1.smoSerialize.serializedMergeNonDefault(SmoArticulation.defaults, SmoArticulation.parameterArray, this, params);
        return params;
    }
}
exports.SmoArticulation = SmoArticulation;
SmoArticulation.xmlArticulations = {
    accent: 'accent',
    staccato: 'staccato',
    tenuto: 'tenuto',
    marcato: 'strong-accent'
};
/**
 * SmoLyric covers both chords and lyrics.  The parser tells you which
 * one you get.
 * @category SmoModifier
 */
class SmoLyric extends SmoNoteModifierBase {
    constructor(parameters) {
        super('SmoLyric');
        this.ctor = 'SmoLyric';
        this._text = '';
        this.endChar = '';
        this.fontInfo = {
            size: 12,
            family: 'Merriweather',
            style: 'normal',
            weight: 'normal'
        };
        this.parser = SmoLyric.parsers.lyric;
        this.selector = null; // used by UI
        this.adjustNoteWidthLyric = true;
        this.adjustNoteWidthChord = false;
        this.verse = 0;
        this.skipRender = false;
        this.fill = '';
        this.scaleX = 1.0;
        this.scaleY = 1.0;
        this.translateX = 0;
        this.translateY = 0;
        this.classes = '';
        this.adjX = 0;
        this.adjY = 0;
        this.hyphenX = 0;
        this.deleted = false;
        serializationHelpers_1.smoSerialize.serializedMerge(SmoLyric.parameterArray, SmoLyric.defaults, this);
        serializationHelpers_1.smoSerialize.serializedMerge(SmoLyric.parameterArray, parameters, this);
        // backwards-compatibility for lyric text
        if (parameters.text) {
            this._text = parameters.text;
        }
        // Return these for the text editor that expects them.
        // this.translateX = this.translateY = 0;
        this.scaleX = this.scaleY = 1.0;
        // calculated adjustments for alignment purposes
        this.adjY = 0;
        this.adjX = 0;
        // this.verse = parseInt(this.verse, 10);
        if (!this.attrs) {
            this.attrs = {
                id: VF.Element.newID(),
                type: parameters.ctor
            };
        }
    }
    static get defaults() {
        return JSON.parse(JSON.stringify({
            ctor: 'SmoLyric',
            _text: '\xa0',
            endChar: '',
            verse: 0,
            fontInfo: {
                size: 12,
                family: 'times',
                style: 'normal',
                weight: 'normal'
            },
            fill: 'black',
            classes: 'score-text',
            scaleX: 1.0,
            scaleY: 1.0,
            translateX: 0,
            translateY: 0,
            adjustNoteWidthLyric: true,
            adjustNoteWidthChord: false,
            parser: SmoLyric.parsers.lyric
        }));
    }
    static get symbolPosition() {
        return {
            SUPERSCRIPT: 1,
            SUBSCRIPT: 2,
            NORMAL: 3
        };
    }
    static toVexPosition(chordPos) {
        if (chordPos === SmoLyric.symbolPosition.NORMAL) {
            return VF.ChordSymbol.symbolModifiers.NONE;
        }
        else if (chordPos === SmoLyric.symbolPosition.SUPERSCRIPT) {
            return VF.ChordSymbol.symbolModifiers.SUPERSCRIPT;
        }
        return VF.ChordSymbol.symbolModifiers.SUBSCRIPT;
    }
    static get persistArray() {
        const rv = [];
        // eslint-disable-next-line
        for (const key in SmoLyric.defaults) {
            rv.push(key);
        }
        return rv;
    }
    static get parameterArray() {
        const rv = SmoLyric.persistArray;
        rv.push('selector', 'text');
        return rv;
    }
    serialize() {
        var params = {};
        serializationHelpers_1.smoSerialize.serializedMergeNonDefault(SmoLyric.defaults, SmoLyric.persistArray, this, params);
        return params;
    }
    // For lyrics, we default to adjust note width on lyric size.  For chords, this is almost never what
    // you want, so it is off by default.
    get adjustNoteWidth() {
        return (this.parser === SmoLyric.parsers.lyric) ? this.adjustNoteWidthLyric : this.adjustNoteWidthChord;
    }
    set adjustNoteWidth(val) {
        if (this.parser === SmoLyric.parsers.lyric) {
            this.adjustNoteWidthLyric = val;
        }
        else {
            this.adjustNoteWidthChord = val;
        }
    }
    // ### getClassSelector
    // returns a selector used to find this text block within a note.
    getClassSelector() {
        var parser = (this.parser === SmoLyric.parsers.lyric ? 'lyric' : 'chord');
        return 'g.' + parser + '-' + this.verse;
    }
    setText(text) {
        // For chords, trim all whitespace
        if (this.parser !== SmoLyric.parsers.lyric) {
            if (text.trim().length) {
                text.replace(/\s/g, '');
            }
        }
        this._text = text;
    }
    isHyphenated() {
        const text = this._text.trim();
        return this.parser === SmoLyric.parsers.lyric &&
            text.length &&
            text[text.length - 1] === '-';
    }
    getText() {
        const text = this._text.trim();
        if (this.isHyphenated()) {
            return serializationHelpers_1.smoSerialize.tryParseUnicode(text.substr(0, text.length - 1)).trim();
        }
        return serializationHelpers_1.smoSerialize.tryParseUnicode(text);
    }
    isDash() {
        return this.getText().length === 0 && this.isHyphenated();
    }
    static _chordGlyphFromCode(code) {
        const obj = Object.keys(VF.ChordSymbol.glyphs).find((glyph) => VF.ChordSymbol.glyphs[glyph].code === code);
        return obj;
    }
    static _tokenizeChordString(str) {
        // var str = this._text;
        const reg = /^([A-Z|a-z|0-9|]+)/g;
        let mmm = str.match(reg);
        let tokeType = '';
        let toke = '';
        const tokens = [];
        while (str.length) {
            if (!mmm) {
                tokeType = str[0];
                tokens.push(tokeType);
                str = str.slice(1, str.length);
            }
            else {
                toke = mmm[0].substr(0, mmm[0].length);
                str = str.slice(toke.length, str.length);
                tokens.push(toke);
                tokeType = '';
                toke = '';
            }
            mmm = str.match(reg);
        }
        return tokens;
    }
    getVexChordBlocks() {
        let mod = VF.ChordSymbol.symbolModifiers.NONE;
        let isGlyph = false;
        const tokens = SmoLyric._tokenizeChordString(this._text);
        const blocks = [];
        tokens.forEach((token) => {
            if (token === '^') {
                mod = (mod === VF.ChordSymbol.symbolModifiers.SUPERSCRIPT) ?
                    VF.ChordSymbol.symbolModifiers.NONE : VF.ChordSymbol.symbolModifiers.SUPERSCRIPT;
            }
            else if (token === '%') {
                mod = (mod === VF.ChordSymbol.symbolModifiers.SUBSCRIPT) ?
                    VF.ChordSymbol.symbolModifiers.NONE : VF.ChordSymbol.symbolModifiers.SUBSCRIPT;
            }
            else if (token === '@') {
                isGlyph = !isGlyph;
            }
            else if (token.length) {
                if (isGlyph) {
                    const glyph = SmoLyric._chordGlyphFromCode(token);
                    blocks.push({
                        glyph, symbolModifier: mod,
                        symbolType: VF.ChordSymbol.symbolTypes.GLYPH
                    });
                }
                else {
                    blocks.push({
                        text: token, symbolModifier: mod,
                        symbolType: VF.ChordSymbol.symbolTypes.TEXT
                    });
                }
            }
        });
        return blocks;
    }
}
exports.SmoLyric = SmoLyric;
SmoLyric.parsers = {
    lyric: 0, anaylysis: 1, chord: 2
};
/**
 * Dynamic text tells you how loud not to play.
 * @category SmoModifier
 */
class SmoDynamicText extends SmoNoteModifierBase {
    constructor(parameters) {
        super('SmoDynamicText');
        this.text = '';
        this.yOffsetLine = 11;
        this.yOffsetPixels = 0;
        this.xOffset = 0;
        this.fontSize = 38;
        Vex.Merge(this, SmoDynamicText.defaults);
        serializationHelpers_1.smoSerialize.filteredMerge(SmoDynamicText.parameterArray, parameters, this);
        this.selector = parameters.selector;
        if (!this.attrs) {
            this.attrs = {
                id: VF.Element.newID(),
                type: 'SmoDynamicText'
            };
        }
    }
    static get dynamics() {
        // matches VF.modifier
        return {
            PP: 'pp',
            P: 'p',
            MP: 'mp',
            MF: 'mf',
            F: 'f',
            FF: 'ff',
            SFZ: 'sfz'
        };
    }
    static get defaults() {
        return JSON.parse(JSON.stringify({
            ctor: 'SmoDynamicText',
            xOffset: 0,
            fontSize: 38,
            yOffsetLine: 11,
            yOffsetPixels: 0,
            text: SmoDynamicText.dynamics.MP,
        }));
    }
    static get persistArray() {
        const rv = [];
        // eslint-disable-next-line
        for (const key in SmoDynamicText.defaults) {
            rv.push(key);
        }
        return rv;
    }
    static get parameterArray() {
        const rv = SmoDynamicText.persistArray;
        rv.push('selector');
        return rv;
    }
    serialize() {
        var params = {};
        serializationHelpers_1.smoSerialize.serializedMergeNonDefault(SmoDynamicText.defaults, SmoDynamicText.persistArray, this, params);
        return params;
    }
}
exports.SmoDynamicText = SmoDynamicText;


/***/ }),

/***/ "./src/smo/data/partInfo.ts":
/*!**********************************!*\
  !*** ./src/smo/data/partInfo.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SmoPartInfo = exports.SmoPartInfoBooleanTypes = exports.SmoPartInfoNumTypes = exports.SmoPartInfoStringTypes = void 0;
// [Smoosic](https://github.com/AaronDavidNewman/Smoosic)
// Copyright (c) Aaron David Newman 2021.
/**
 * Classes to support partsInfo class, for part extraction.
 * Parts is parts.
 * @module /smo/data/partInfo
 */
const measureModifiers_1 = __webpack_require__(/*! ./measureModifiers */ "./src/smo/data/measureModifiers.ts");
const scoreModifiers_1 = __webpack_require__(/*! ./scoreModifiers */ "./src/smo/data/scoreModifiers.ts");
const staffModifiers_1 = __webpack_require__(/*! ./staffModifiers */ "./src/smo/data/staffModifiers.ts");
const VF = eval('Vex.Flow');
exports.SmoPartInfoStringTypes = ['partName', 'partAbbreviation'];
exports.SmoPartInfoNumTypes = ['stavesAfter', 'stavesBefore'];
exports.SmoPartInfoBooleanTypes = ['preserveTextGroups', 'cueInScore', 'expandMultimeasureRests'];
/**
 * Part info contains information that group 1 or 2 adjacent staves.
 * Parts can have formatting that is indepenedent of the score
 * @category SmoModifier
 */
class SmoPartInfo extends staffModifiers_1.StaffModifierBase {
    constructor(params) {
        super('SmoPartInfo');
        this.partName = '';
        this.partAbbreviation = '';
        this.measureFormatting = {};
        this.textGroups = [];
        this.stavesAfter = 0;
        this.stavesBefore = 0;
        this.preserveTextGroups = false;
        this.cueInScore = false;
        this.displayCues = false;
        this.expandMultimeasureRests = false;
        if (!params.layoutManager) {
            this.layoutManager = new scoreModifiers_1.SmoLayoutManager(scoreModifiers_1.SmoLayoutManager.defaults);
        }
        else {
            this.layoutManager = new scoreModifiers_1.SmoLayoutManager(params.layoutManager);
        }
        if (typeof (params.measureFormatting) !== 'undefined') {
            const formatKeys = Object.keys(params.measureFormatting);
            formatKeys.forEach((key) => {
                const numKey = parseInt(key, 10);
                this.measureFormatting[numKey] = new measureModifiers_1.SmoMeasureFormat(params.measureFormatting[numKey]);
            });
        }
        if (params.textGroups) {
            this.textGroups = params.textGroups;
        }
        exports.SmoPartInfoStringTypes.forEach((st) => {
            this[st] = params[st];
        });
        exports.SmoPartInfoNumTypes.forEach((st) => {
            this[st] = params[st];
        });
        exports.SmoPartInfoBooleanTypes.forEach((st) => {
            var _a;
            this[st] = (_a = params[st]) !== null && _a !== void 0 ? _a : false;
        });
        this.midiDevice = params.midiDevice;
        if (params.midiInstrument) {
            this.midiInstrument = JSON.parse(JSON.stringify(params.midiInstrument));
        }
        else {
            this.midiInstrument = null;
        }
    }
    static get defaults() {
        return JSON.parse(JSON.stringify({
            partName: 'Staff ',
            partAbbreviation: '',
            globalLayout: scoreModifiers_1.SmoLayoutManager.defaultLayout,
            textGroups: [],
            preserveTextGroups: false,
            pageLayoutMap: {},
            stavesAfter: 0,
            stavesBefore: 0,
            cueInScore: false,
            midiDevice: null,
            midiInstrument: null,
            expandMultimeasureRests: false
        }));
    }
    serialize() {
        const rv = {};
        exports.SmoPartInfoStringTypes.forEach((st) => {
            rv[st] = this[st];
        });
        exports.SmoPartInfoNumTypes.forEach((st) => {
            rv[st] = this[st];
        });
        exports.SmoPartInfoBooleanTypes.forEach((st) => {
            rv[st] = this[st];
        });
        rv.layoutManager = this.layoutManager.serialize();
        rv.textGroups = [];
        this.textGroups.forEach((tg) => {
            rv.textGroups.push(tg.serialize());
        });
        rv.measureFormatting = {};
        if (this.midiInstrument) {
            rv.midiInstrument = JSON.parse(JSON.stringify(this.midiInstrument));
        }
        if (this.midiDevice) {
            rv.midiDevice = this.midiDevice;
        }
        Object.keys(this.measureFormatting).forEach((key) => {
            const numKey = parseInt(key, 10);
            rv.measureFormatting[numKey] = this.measureFormatting[numKey];
        });
        return rv;
    }
    updateTextGroup(textGroup, toAdd) {
        const tgid = typeof (textGroup) === 'string' ? textGroup :
            textGroup.attrs.id;
        const ar = this.textGroups.filter((tg) => tg.attrs.id !== tgid);
        this.textGroups = ar;
        if (toAdd) {
            this.textGroups.push(textGroup);
        }
    }
}
exports.SmoPartInfo = SmoPartInfo;


/***/ }),

/***/ "./src/smo/data/score.ts":
/*!*******************************!*\
  !*** ./src/smo/data/score.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SmoScore = exports.SmoScorePreferences = exports.SmoScorePreferenceNumbers = exports.SmoScorePreferenceBools = exports.SmoScoreInfo = exports.isEngravingFont = exports.engravingFontTypes = void 0;
// [Smoosic](https://github.com/AaronDavidNewman/Smoosic)
// Copyright (c) Aaron David Newman 2021.
/**
 * Classes to support {@link SmoScore}
 * @module /smo/data/score
 */
const music_1 = __webpack_require__(/*! ./music */ "./src/smo/data/music.ts");
const measure_1 = __webpack_require__(/*! ./measure */ "./src/smo/data/measure.ts");
const measureModifiers_1 = __webpack_require__(/*! ./measureModifiers */ "./src/smo/data/measureModifiers.ts");
const scoreModifiers_1 = __webpack_require__(/*! ./scoreModifiers */ "./src/smo/data/scoreModifiers.ts");
const scoreText_1 = __webpack_require__(/*! ./scoreText */ "./src/smo/data/scoreText.ts");
const systemStaff_1 = __webpack_require__(/*! ./systemStaff */ "./src/smo/data/systemStaff.ts");
const serializationHelpers_1 = __webpack_require__(/*! ../../common/serializationHelpers */ "./src/common/serializationHelpers.js");
/**
 * Arrary of engraving fonts available in Smoosic
 */
exports.engravingFontTypes = ['Bravura', 'Gonville', 'Petaluma', 'Leland'];
function isEngravingFont(et) {
    return exports.engravingFontTypes.indexOf(et) >= 0;
}
exports.isEngravingFont = isEngravingFont;
/**
 * Information about the score itself, like composer etc.
 * @category SmoModifier
 */
class SmoScoreInfo {
    constructor() {
        this.name = 'Smoosical'; // deprecated
        this.title = 'Smoosical';
        this.subTitle = '(Op. 1)';
        this.composer = 'Me';
        this.copyright = '';
        this.version = 1;
    }
}
exports.SmoScoreInfo = SmoScoreInfo;
exports.SmoScorePreferenceBools = ['autoPlay', 'autoAdvance', 'showPiano', 'hideEmptyLines', 'transposingScore'];
exports.SmoScorePreferenceNumbers = ['defaultDupleDuration', 'defaultTripleDuration'];
/**
 * Some default SMO behavior
 * @param autoPlay play a new note or chord
 * @param autoAdvance Sibelius-like behavior of advancing cursor when a letter note is placed
 * @param defaultDupleDuration in ticks, even metered measures
 * @param defaultTripleDuration in ticks, 6/8 etc.
 * @param showPiano show the piano widget in the score
 * @param hideEmptyLines Hide empty lines in full score
 * @param transposingScore Whether to show the score parts in concert key
 * @category SmoModifier
 */
class SmoScorePreferences {
    constructor(params) {
        this.autoPlay = true;
        this.autoAdvance = true;
        this.defaultDupleDuration = 4096;
        this.defaultTripleDuration = 6144;
        this.showPiano = true;
        this.hideEmptyLines = false;
        this.transposingScore = false;
        if (params) {
            exports.SmoScorePreferenceBools.forEach((bb) => {
                this[bb] = params[bb];
            });
            exports.SmoScorePreferenceNumbers.forEach((nn) => {
                this[nn] = params[nn];
            });
        }
    }
    static get defaults() {
        return {
            autoPlay: true,
            autoAdvance: true,
            defaultDupleDuration: 4096,
            defaultTripleDuration: 6144,
            showPiano: true,
            hideEmptyLines: false,
            transposingScore: false
        };
    }
}
exports.SmoScorePreferences = SmoScorePreferences;
/**
 * SmoScore is the container for the entire score: staves, measures, notes
 * @category SmoObject
 */
class SmoScore {
    constructor(params) {
        this.instrumentMap = [];
        this.fonts = [];
        this.staffWidth = 1600;
        this.scoreInfo = new SmoScoreInfo();
        this.preferences = new SmoScorePreferences(SmoScorePreferences.defaults);
        this.startIndex = 0;
        this.staves = [];
        this.activeStaff = 0;
        this.textGroups = [];
        this.systemGroups = [];
        Vex.Merge(this, SmoScore.defaults);
        Vex.Merge(this, params);
        if (!this.layoutManager) {
            this.layoutManager = new scoreModifiers_1.SmoLayoutManager(scoreModifiers_1.SmoLayoutManager.defaults);
        }
        if (!this.formattingManager) {
            this.formattingManager = new scoreModifiers_1.SmoFormattingManager(scoreModifiers_1.SmoFormattingManager.defaults);
        }
        if (this.staves.length) {
            this.numberStaves();
        }
        if (typeof (this.preferences.showPiano) === 'undefined') {
            this.preferences.showPiano = true;
        }
        this.audioSettings = new scoreModifiers_1.SmoAudioPlayerSettings(params.audioSettings);
        this.updateMeasureFormats();
    }
    static get engravingFonts() {
        return { Bravura: 'Bravura', Gonville: 'Gonville', Petaluma: 'Petaluma' };
    }
    static get fontPurposes() {
        return { ENGRAVING: 1, SCORE: 2, CHORDS: 3, LYRICS: 4 };
    }
    static get defaults() {
        return {
            // legacy layout structure.  Now we use pages.
            fonts: [
                { name: 'engraving', purpose: SmoScore.fontPurposes.ENGRAVING, family: 'Bravura', size: 1, custom: false },
                { name: 'score', purpose: SmoScore.fontPurposes.SCORE, family: 'Merriweather', size: 14, custom: false },
                { name: 'chords', purpose: SmoScore.fontPurposes.CHORDS, family: 'Roboto Slab', size: 14, custom: false },
                { name: 'lyrics', purpose: SmoScore.fontPurposes.LYRICS, family: 'Merriweather', size: 12, custom: false }
            ],
            scoreInfo: {
                name: 'Smoosical',
                title: 'Smoosical',
                subTitle: '(Op. 1)',
                composer: 'Me',
                copyright: '',
                version: 1,
            },
            audioSettings: scoreModifiers_1.SmoAudioPlayerSettings.defaults,
            preferences: {
                autoPlay: true,
                autoAdvance: true,
                defaultDupleDuration: 4096,
                defaultTripleDuration: 6144,
                showPiano: true,
                hideEmptyLines: false,
                transposingScore: false
            },
            staves: [],
            activeStaff: 0,
            textGroups: [],
            systemGroups: []
        };
    }
    static get pageSizes() {
        return ['letter', 'tabloid', 'A4', 'A4Landscape', 'custom'];
    }
    static get pageDimensions() {
        return {
            'letter': { width: 8 * 96 + 48, height: 11 * 96 },
            'letterLandscape': { width: 11 * 96, height: 8 * 96 + 48 },
            'tabloid': { width: 1632, height: 1056 },
            'A4': { width: 794, height: 1122 },
            'A4Landscape': { width: 1122, height: 794 },
            'custom': { width: 1, height: 1 }
        };
    }
    static pageSizeFromDimensions(width, height) {
        var _a;
        const rv = (_a = SmoScore.pageSizes.find((sz) => SmoScore.pageDimensions[sz].width === width && SmoScore.pageDimensions[sz].height === height)) !== null && _a !== void 0 ? _a : null;
        return rv;
    }
    static get defaultAttributes() {
        return ['startIndex', 'renumberingMap', 'renumberIndex', 'fonts',
            'preferences', 'scoreInfo'];
    }
    static get preferences() {
        return ['preferences', 'fonts', 'scoreInfo', 'audioSettings'];
    }
    /**
     * serialize the keySignature, tempo and time signature, which are mapped
     * to a column at a measure index
     * @returns
     */
    serializeColumnMapped() {
        const keySignature = {};
        const tempo = {};
        const timeSignature = {};
        let previous = null;
        this.staves[0].measures.forEach((measure) => {
            const current = measure.serializeColumnMapped();
            const ix = measure.measureNumber.measureIndex;
            const currentInstrument = this.staves[0].getStaffInstrument(ix);
            current.keySignature = music_1.SmoMusic.vexKeySigWithOffset(current.keySignature, -1 * currentInstrument.keyOffset);
            if (ix === 0) {
                keySignature[0] = current.keySignature;
                tempo[0] = current.tempo;
                timeSignature[0] = current.timeSignature;
                previous = current;
            }
            else {
                if (current.keySignature !== previous.keySignature) {
                    previous.keySignature = current.keySignature;
                    keySignature[ix] = current.keySignature;
                }
                if (!(measureModifiers_1.TimeSignature.equal(current.timeSignature, previous.timeSignature))) {
                    previous.timeSignature = current.timeSignature;
                    timeSignature[ix] = current.timeSignature;
                }
                if (!(measureModifiers_1.SmoTempoText.eq(current.tempo, previous.tempo))) {
                    previous.tempo = current.tempo;
                    tempo[ix] = current.tempo;
                }
            }
        });
        return { keySignature, tempo, timeSignature };
    }
    /**
     * Column-mapped attributes stay the same in each measure until
     * changed, like key-signatures.  We don't store each measure value to
     * make the files smaller
     * @param scoreObj - the json blob that contains the score data
     * @returns
     */
    static deserializeColumnMapped(scoreObj) {
        let curValue;
        let mapIx = 0;
        if (!scoreObj.columnAttributeMap) {
            return;
        }
        const attrs = Object.keys(scoreObj.columnAttributeMap);
        scoreObj.staves.forEach((staff) => {
            const attrIxMap = {};
            attrs.forEach((attr) => {
                attrIxMap[attr] = 0;
            });
            staff.measures.forEach((measure) => {
                attrs.forEach((attr) => {
                    mapIx = attrIxMap[attr];
                    const curHash = scoreObj.columnAttributeMap[attr];
                    const attrKeys = Object.keys(curHash);
                    curValue = curHash[attrKeys[mapIx.toString()]];
                    attrKeys.sort((a, b) => parseInt(a, 10) > parseInt(b, 10) ? 1 : -1);
                    if (attrKeys.length > mapIx + 1) {
                        if (measure.measureNumber.measureIndex >= attrKeys[mapIx + 1]) {
                            mapIx += 1;
                            curValue = curHash[attrKeys[mapIx.toString()]];
                        }
                    }
                    // legacy timeSignature format was just a string 2/4, 3/8 etc.
                    if (attr === 'timeSignature') {
                        const ts = new measureModifiers_1.TimeSignature(measureModifiers_1.TimeSignature.defaults);
                        if (typeof (curValue) === 'string') {
                            ts.timeSignature = curValue;
                            measure[attr] = ts;
                        }
                        else {
                            if (typeof (curValue.isPickup) === 'undefined') {
                                curValue.isPickup = false;
                            }
                            measure[attr] = new measureModifiers_1.TimeSignature(curValue);
                        }
                    }
                    else {
                        measure[attr] = curValue;
                    }
                    attrIxMap[attr] = mapIx;
                });
            });
        });
    }
    /**
     * Serialize the entire score.
     * @returns JSON object
     */
    serialize(skipStaves) {
        const params = {};
        let obj = {
            score: params,
            layoutManager: {},
            audioSettings: {},
            measureFormats: {},
            staves: [],
            textGroups: [],
            systemGroups: []
        };
        if (this.layoutManager) {
            obj.layoutManager = this.layoutManager.serialize();
        }
        if (this.formattingManager) {
            obj.measureFormats = this.formattingManager.serialize();
        }
        serializationHelpers_1.smoSerialize.serializedMerge(SmoScore.defaultAttributes, this, params);
        obj.audioSettings = this.audioSettings.serialize();
        if (!skipStaves) {
            this.staves.forEach((staff) => {
                obj.staves.push(staff.serialize());
            });
        }
        else {
            obj.staves = [];
        }
        // Score text is not part of text group, so don't save separately.
        this.textGroups.forEach((tg) => {
            if (tg.isTextVisible()) {
                obj.textGroups.push(tg.serialize());
            }
        });
        this.systemGroups.forEach((gg) => {
            obj.systemGroups.push(gg.serialize());
        });
        obj.columnAttributeMap = this.serializeColumnMapped();
        serializationHelpers_1.smoSerialize.jsonTokens(obj);
        obj = serializationHelpers_1.smoSerialize.detokenize(obj, serializationHelpers_1.smoSerialize.tokenValues);
        obj.dictionary = serializationHelpers_1.smoSerialize.tokenMap;
        return obj;
    }
    updateScorePreferences(pref) {
        this.preferences = pref;
        measure_1.SmoMeasure.defaultDupleDuration = pref.defaultDupleDuration;
        measure_1.SmoMeasure.defaultTripleDuration = pref.defaultTripleDuration;
    }
    get engravingFont() {
        const efont = this.fonts.find((x) => x.purpose === SmoScore.fontPurposes.ENGRAVING);
        if (efont) {
            const val = exports.engravingFontTypes.find((x) => x === efont.family);
            if (val) {
                return val;
            }
        }
        return 'Bravura';
    }
    set engravingFont(value) {
        const efont = this.fonts.find((x) => x.purpose === SmoScore.fontPurposes.ENGRAVING);
        if (efont && isEngravingFont(value)) {
            efont.family = value;
        }
    }
    static upConvertGlobalLayout(jsonObj) {
        // upconvert global layout, which used to be directly on layoutManager
        if (typeof (jsonObj.layoutManager.globalLayout) === 'undefined') {
            jsonObj.layoutManager.globalLayout = {
                svgScale: jsonObj.layoutManager.svgScale,
                zoomScale: jsonObj.layoutManager.zoomScale,
                pageWidth: jsonObj.layoutManager.pageWidth,
                pageHeight: jsonObj.layoutManager.pageHeight,
                noteSpacing: jsonObj.layoutManager.noteSpacing
            };
            if (!jsonObj.layoutManager.globalLayout.noteSpacing) {
                jsonObj.layoutManager.globalLayout.noteSpacing = 1.0;
            }
        }
    }
    /**
     * Convert legacy score layout to layoutManager object parameters
     * @param jsonObj
     */
    static upConvertLayout(jsonObj) {
        let i = 0;
        jsonObj.layoutManager = {};
        scoreModifiers_1.SmoLayoutManager.attributes.forEach((attr) => {
            jsonObj.layoutManager[attr] = jsonObj.score.layout[attr];
        });
        jsonObj.layoutManager.pageLayouts = [];
        for (i = 0; i < jsonObj.score.layout.pages; ++i) {
            const pageSetting = JSON.parse(JSON.stringify(scoreModifiers_1.SmoPageLayout.defaults));
            scoreModifiers_1.SmoPageLayout.attributes.forEach((attr) => {
                if (typeof (jsonObj.score.layout[attr]) !== 'undefined') {
                    pageSetting[attr] = jsonObj.score.layout[attr];
                }
            });
            jsonObj.layoutManager.pageLayouts.push(pageSetting);
        }
        SmoScore.upConvertGlobalLayout(jsonObj);
    }
    /**
     * Deserialize an entire score
     * @param jsonString
     * @returns SmoScore
     */
    static deserialize(jsonString) {
        var _a, _b;
        let jsonObj = JSON.parse(jsonString);
        let upconvertFormat = false;
        let formattingManager = null;
        if (jsonObj.dictionary) {
            jsonObj = serializationHelpers_1.smoSerialize.detokenize(jsonObj, jsonObj.dictionary);
        }
        upconvertFormat = typeof (jsonObj.measureFormats) === 'undefined';
        const params = {};
        const staves = [];
        jsonObj.textGroups = jsonObj.textGroups ? jsonObj.textGroups : [];
        // Explode the sparse arrays of attributes into the measures
        SmoScore.deserializeColumnMapped(jsonObj);
        // meaning of customProportion has changed, backwards-compatiblity
        if (typeof (jsonObj.score.preferences) !== 'undefined' && typeof (jsonObj.score.preferences.customProportion) === 'number') {
            measureModifiers_1.SmoMeasureFormat.defaults.proportionality = jsonObj.score.preferences.customProportion;
            if (measureModifiers_1.SmoMeasureFormat.defaults.proportionality === measureModifiers_1.SmoMeasureFormat.legacyProportionality) {
                measureModifiers_1.SmoMeasureFormat.defaults.proportionality = measureModifiers_1.SmoMeasureFormat.defaultProportionality;
            }
        }
        // up-convert legacy layout data
        if (jsonObj.score.layout) {
            SmoScore.upConvertLayout(jsonObj);
        }
        if (jsonObj.layoutManager && !jsonObj.layoutManager.globalLayout) {
            SmoScore.upConvertGlobalLayout(jsonObj);
        }
        const layoutManager = new scoreModifiers_1.SmoLayoutManager(jsonObj.layoutManager);
        if (!upconvertFormat) {
            formattingManager = new scoreModifiers_1.SmoFormattingManager({ measureFormats: jsonObj.measureFormats });
        }
        // params.layout = JSON.parse(JSON.stringify(SmoScore.defaults.layout));
        serializationHelpers_1.smoSerialize.serializedMerge(SmoScore.defaultAttributes, jsonObj.score, params);
        if (!params.preferences) {
            params.preferences = SmoScore.defaults.preferences;
        }
        if (!jsonObj.audioSettings) {
            params.audioSettings = new scoreModifiers_1.SmoAudioPlayerSettings(scoreModifiers_1.SmoAudioPlayerSettings.defaults);
        }
        else {
            params.audioSettings = scoreModifiers_1.SmoScoreModifierBase.deserialize(jsonObj.audioSettings);
        }
        params.preferences.transposingScore = (_a = params.preferences.transposingScore) !== null && _a !== void 0 ? _a : false;
        params.preferences.hideEmptyLines = (_b = params.preferences.hideEmptyLines) !== null && _b !== void 0 ? _b : false;
        jsonObj.staves.forEach((staffObj, staffIx) => {
            staffObj.staffId = staffIx;
            const staff = systemStaff_1.SmoSystemStaff.deserialize(staffObj);
            staves.push(staff);
        });
        const textGroups = [];
        jsonObj.textGroups.forEach((tg) => {
            textGroups.push(scoreText_1.SmoTextGroup.deserializePreserveId(tg));
        });
        const systemGroups = [];
        if (jsonObj.systemGroups) {
            jsonObj.systemGroups.forEach((tt) => {
                var st = scoreModifiers_1.SmoScoreModifierBase.deserialize(tt);
                st.autoLayout = false; // since this has been layed out, presumably, before save
                systemGroups.push(st);
            });
        }
        params.staves = staves;
        if (upconvertFormat) {
            formattingManager = SmoScore.measureFormatFromLegacyScore(params, jsonObj);
        }
        params.formattingManager = formattingManager;
        params.layoutManager = layoutManager;
        const score = new SmoScore(params);
        score.textGroups = textGroups;
        score.systemGroups = systemGroups;
        score.scoreInfo.version += 1;
        return score;
    }
    /**
    * Convert measure formatting from legacy scores, that had the formatting
    * per measure, to the new way that has a separate formatting object.
    * **/
    static measureFormatFromLegacyScore(score, jsonObj) {
        let current = null;
        let previous = null;
        const measureFormats = [];
        score.staves[0].measures.forEach((measure) => {
            if (current === null) {
                current = measureModifiers_1.SmoMeasureFormat.fromLegacyMeasure(jsonObj.staves[0].measures[measure.measureNumber.measureIndex]);
                measureFormats[measure.measureNumber.measureIndex] = current;
            }
            else {
                previous = current;
                current = measureModifiers_1.SmoMeasureFormat.fromLegacyMeasure(jsonObj.staves[0].measures[measure.measureNumber.measureIndex]);
                if (!current.eq(previous)) {
                    measureFormats[measure.measureNumber.measureIndex] = current;
                }
            }
        });
        return new scoreModifiers_1.SmoFormattingManager({ measureFormats });
    }
    /**
     * Return a default score with no notes or staves
     * @param scoreDefaults
     * @param measureDefaults
     * @returns
     */
    static getDefaultScore(scoreDefaults, measureDefaults) {
        measureDefaults = measureDefaults !== null ? measureDefaults : measure_1.SmoMeasure.defaults;
        const score = new SmoScore(scoreDefaults);
        score.formattingManager = new scoreModifiers_1.SmoFormattingManager(scoreModifiers_1.SmoFormattingManager.defaults);
        score.addStaff(systemStaff_1.SmoSystemStaff.defaults);
        const measure = measure_1.SmoMeasure.getDefaultMeasure(measureDefaults);
        score.addMeasure(0);
        measure.voices.push({
            notes: measure_1.SmoMeasure.getDefaultNotes(measureDefaults)
        });
        return score;
    }
    /**
     * Return an 'empty' score, with one measure of rests
     * @param scoreDefaults
     * @returns
     */
    static getEmptyScore(scoreDefaults) {
        const score = new SmoScore(scoreDefaults);
        score.addStaff(systemStaff_1.SmoSystemStaff.defaults);
        return score;
    }
    /**
     * Iteratively number the staves, like when adding a measure
     */
    numberStaves() {
        let i = 0;
        for (i = 0; i < this.staves.length; ++i) {
            const stave = this.staves[i];
            stave.staffId = i;
            stave.numberMeasures();
        }
    }
    /**
     * determine if the measure at this index could be a multi-measure rest
     * @param measureIndex - the measure index we are considering to add
     * @param start - the measure index would be the start of the rest
     * @returns
     */
    isMultimeasureRest(measureIndex, start, forceRest) {
        let i = 0;
        for (i = 0; i < this.staves.length; ++i) {
            if (!forceRest && !this.staves[i].isRest(measureIndex)) {
                return false;
            }
            if (this.staves[i].getVoltasForMeasure(measureIndex).length > 0) {
                return false;
            }
            if (!start && measureIndex > 0 && this.staves[i].isRepeat(measureIndex - 1)) {
                return false;
            }
            if (this.staves[i].isRehearsal(measureIndex)) {
                return false;
            }
            // instrument change other than the initial measure
            if (this.staves[i].measureInstrumentMap[measureIndex] && i > 0) {
                return false;
            }
        }
        if (measureIndex > 0) {
            const measure = this.staves[0].measures[measureIndex];
            const prev = this.staves[0].measures[measureIndex - 1];
            if (!start && !measureModifiers_1.TimeSignature.equal(measure.timeSignature, prev.timeSignature)) {
                return false;
            }
            if (!start && measure.keySignature !== prev.keySignature) {
                return false;
            }
        }
        return true;
    }
    /**
     * Restore measure formats stored when a score is serialized
     */
    updateMeasureFormats() {
        this.staves.forEach((staff) => {
            staff.measures.forEach((measure) => {
                this.formattingManager.updateFormat(measure);
            });
        });
    }
    /**
     * Add a measure to the score with the supplied parameters at the supplied index.
     * The defaults per staff may be different depending on the clef, key of the staff.
    */
    addDefaultMeasureWithNotes(measureIndex, parameters) {
        this.staves.forEach((staff) => {
            const defaultMeasure = measure_1.SmoMeasure.getDefaultMeasureWithNotes(parameters);
            staff.addMeasure(measureIndex, defaultMeasure);
        });
    }
    replaceTextGroup(tgr) {
        const tgar = [];
        this.textGroups.forEach((tg) => {
            if (tg.attrs.id !== tgr.attrs.id) {
                tgar.push(tg);
            }
        });
        tgar.push(tgr);
        this.textGroups = tgar;
    }
    /**
     * delete the measure at the supplied index in all the staves
    */
    deleteMeasure(measureIndex) {
        this.staves.forEach((staff) => {
            staff.deleteMeasure(measureIndex);
        });
        // adjust offset if text was attached to any missing measures after the deleted one.
        this.textGroups.forEach((tg) => {
            if (tg.attachToSelector && tg.selector.measure >= measureIndex && tg.selector.measure > 0) {
                tg.selector.measure -= 1;
            }
        });
    }
    /**
     * get a measure 'compatible' with the measure at the given index, in terms
     * of key, time signature etc.
     * @param measureIndex
     * @param staffIndex
     * @returns
     */
    getPrototypeMeasure(measureIndex, staffIndex) {
        const staff = this.staves[staffIndex];
        let protomeasure = {};
        // Since this staff may already have instrument settings, use the
        // immediately preceeding or post-ceding measure if it exists.
        if (measureIndex < staff.measures.length) {
            protomeasure = staff.measures[measureIndex];
        }
        else if (staff.measures.length) {
            protomeasure = staff.measures[staff.measures.length - 1];
        }
        else {
            protomeasure = measure_1.SmoMeasure.defaults;
        }
        return measure_1.SmoMeasure.getDefaultMeasureWithNotes(protomeasure);
    }
    /**
     * Give a measure prototype, create a new measure and add it to each staff, with the
     * correct settings for current time signature/clef.
     * @param measureIndex
     */
    addMeasure(measureIndex) {
        let i = 0;
        for (i = 0; i < this.staves.length; ++i) {
            const staff = this.staves[i];
            const nmeasure = this.getPrototypeMeasure(measureIndex, i);
            if (nmeasure.voices.length <= nmeasure.getActiveVoice()) {
                nmeasure.setActiveVoice(0);
            }
            staff.addMeasure(measureIndex, nmeasure);
        }
        // Update offsets for score modifiers that have a selector
        this.textGroups.forEach((tg) => {
            if (typeof (tg.selector) === 'undefined') {
                return;
            }
            if (tg.attachToSelector && tg.selector.measure >= measureIndex && tg.selector.measure < this.staves[0].measures.length) {
                tg.selector.measure += 1;
            }
        });
        this.numberStaves();
    }
    /**
     * Replace the measure at the given location.  Probably due to an undo operation or paste.
     * @param selector
     * @param measure
     */
    replaceMeasure(selector, measure) {
        var staff = this.staves[selector.staff];
        staff.measures[selector.measure] = measure;
    }
    getSystemGroupForStaff(selection) {
        const staffId = selection.staff.staffId;
        const measureIndex = selection.measure.measureNumber.measureIndex;
        const exist = this.systemGroups.find((sg) => sg.startSelector.staff <= staffId &&
            sg.endSelector.staff >= staffId &&
            (sg.mapType === scoreModifiers_1.SmoSystemGroup.mapTypes.allMeasures ||
                (sg.startSelector.measure <= measureIndex &&
                    sg.endSelector.measure >= measureIndex)));
        return exist;
    }
    getStavesForGroup(group) {
        return this.staves.filter((staff) => staff.staffId >= group.startSelector.staff &&
            staff.staffId <= group.endSelector.staff);
    }
    // ### addOrReplaceSystemGroup
    // Add a new staff grouping, or replace it if it overlaps and is different, or
    // remove it if it is identical (toggle)
    addOrReplaceSystemGroup(newGroup) {
        // Replace this group for any groups that overlap it.
        this.systemGroups = this.systemGroups.filter((sg) => !sg.overlaps(newGroup));
        this.systemGroups.push(newGroup);
    }
    isPartExposed() {
        if (this.staves.length > 2) {
            return false;
        }
        const staff = this.staves[0];
        const staveCount = staff.partInfo.stavesAfter + staff.partInfo.stavesBefore + 1;
        return staveCount === this.staves.length
            && staff.partInfo.stavesBefore === 0;
    }
    /**
     * Probably due to an undo operation, replace the staff at the given index.
     * @param index
     * @param staff
     */
    replaceStaff(index, staff) {
        const staves = [];
        let i = 0;
        for (i = 0; i < this.staves.length; ++i) {
            if (i !== index) {
                staves.push(this.staves[i]);
            }
            else {
                staves.push(staff);
            }
        }
        this.staves = staves;
    }
    /**
     *
     * @param measureIndex
     * @param key
     */
    addKeySignature(measureIndex, key) {
        this.staves.forEach((staff) => {
            // Consider transpose for key of instrument
            const netOffset = staff.measures[measureIndex].transposeIndex;
            const newKey = music_1.SmoMusic.vexKeySigWithOffset(key, netOffset);
            staff.addKeySignature(measureIndex, newKey);
        });
    }
    /**
     * If the part is a transposing part, remove the transposition from the notes/staff.  This logic
     * assumes the measures previously had transposeIndex set up by the instrument map.
     */
    setTransposing() {
        this.staves.forEach((staff) => {
            staff.measures.forEach((mm) => {
                if (mm.transposeIndex !== 0) {
                    const concert = music_1.SmoMusic.vexKeySigWithOffset(mm.keySignature, -1 * mm.transposeIndex);
                    mm.transposeToOffset(0, concert);
                    mm.transposeIndex = 0;
                    mm.keySignature = concert;
                }
            });
        });
    }
    /**
     * If the score is switching from transposing to non-transposing, update the index
     * and pitches.  This logic assumes we are changing from transposing to non-transposing.
     */
    setNonTransposing() {
        this.staves.forEach((staff) => {
            staff.measures.forEach((mm) => {
                const inst = staff.getStaffInstrument(mm.measureNumber.measureIndex);
                if (inst.keyOffset !== 0) {
                    const concert = music_1.SmoMusic.vexKeySigWithOffset(mm.keySignature, inst.keyOffset);
                    mm.transposeToOffset(inst.keyOffset, concert);
                    mm.transposeIndex = inst.keyOffset;
                    mm.keySignature = concert;
                }
            });
        });
    }
    // ### addInstrument
    // add a new staff (instrument) to the score
    addStaff(parameters) {
        let i = 0;
        if (this.staves.length === 0) {
            const staff = new systemStaff_1.SmoSystemStaff(parameters);
            this.staves.push(staff);
            this.activeStaff = 0;
            // For part views, we renumber the staves even if there is only one staff.
            if (staff.measures.length) {
                this.numberStaves();
            }
            return;
        }
        if (!parameters) {
            parameters = systemStaff_1.SmoSystemStaff.defaults;
        }
        const proto = this.staves[0];
        const measures = [];
        for (i = 0; i < proto.measures.length; ++i) {
            const measure = proto.measures[i];
            let newMeasure = measure_1.SmoMeasure.deserialize(measure.serialize());
            newMeasure.measureNumber = measure.measureNumber;
            newMeasure.clef = parameters.measureInstrumentMap[0].clef;
            newMeasure.modifiers = [];
            newMeasure.transposeIndex = 0;
            // Consider key change if the proto measure is non-concert pitch
            newMeasure.keySignature =
                music_1.SmoMusic.vexKeySigWithOffset(newMeasure.keySignature, newMeasure.transposeIndex - measure.transposeIndex);
            newMeasure.voices = [{ notes: measure_1.SmoMeasure.getDefaultNotes(newMeasure) }];
            measure.modifiers.forEach((modifier) => {
                const nmod = measureModifiers_1.SmoMeasureModifierBase.deserialize(modifier);
                newMeasure.modifiers.push(nmod);
            });
            measures.push(newMeasure);
        }
        parameters.measures = measures;
        const staff = new systemStaff_1.SmoSystemStaff(parameters);
        this.staves.push(staff);
        this.activeStaff = this.staves.length - 1;
        this.numberStaves();
    }
    // ### removeStaff
    // Remove stave at the given index
    removeStaff(index) {
        const staves = [];
        let ix = 0;
        this.staves.forEach((staff) => {
            if (ix !== index) {
                staves.push(staff);
            }
            ix += 1;
        });
        this.staves = staves;
        this.numberStaves();
    }
    getStaffInstrument(selector) {
        const staff = this.staves[selector.staff];
        return staff.getStaffInstrument(selector.measure);
    }
    swapStaves(index1, index2) {
        if (this.staves.length < index1 || this.staves.length < index2) {
            return;
        }
        const tmpStaff = this.staves[index1];
        this.staves[index1] = this.staves[index2];
        this.staves[index2] = tmpStaff;
        this.staves.forEach((staff) => {
            staff.mapStaffFromTo(index1, index2);
            staff.mapStaffFromTo(index2, index1);
        });
        this.numberStaves();
    }
    updateTextGroup(textGroup, toAdd) {
        const tgid = typeof (textGroup) === 'string' ? textGroup :
            textGroup.attrs.id;
        const ar = this.textGroups.filter((tg) => tg.attrs.id !== tgid);
        this.textGroups = ar;
        if (toAdd) {
            this.textGroups.push(textGroup);
        }
    }
    addTextGroup(textGroup) {
        this.updateTextGroup(textGroup, true);
    }
    getTextGroups() {
        return this.textGroups;
    }
    scaleTextGroups(scale) {
        this.textGroups.forEach((tg) => {
            tg.scaleText(scale);
        });
    }
    removeTextGroup(textGroup) {
        this.updateTextGroup(textGroup, false);
    }
    setLyricAdjustWidth(adjustNoteWidth) {
        this.staves.forEach((staff) => {
            staff.setLyricAdjustWidth(adjustNoteWidth);
        });
    }
    setChordAdjustWidth(adjustNoteWidth) {
        this.staves.forEach((staff) => {
            staff.setChordAdjustWidth(adjustNoteWidth);
        });
    }
    // ### setLyricFont
    // set the font for lyrics, which are the same for all lyrics in the score
    setLyricFont(fontInfo) {
        this.staves.forEach((staff) => {
            staff.setLyricFont(fontInfo);
        });
        const fontInst = this.fonts.find((fn) => fn.purpose === SmoScore.fontPurposes.LYRICS);
        if (typeof (fontInst) === 'undefined') {
            return;
        }
        fontInst.family = fontInfo.family;
        fontInst.size = fontInfo.size;
        fontInst.custom = true;
    }
    setChordFont(fontInfo) {
        this.staves.forEach((staff) => {
            staff.setChordFont(fontInfo);
        });
    }
    get measures() {
        if (this.staves.length === 0) {
            return [];
        }
        return this.staves[this.activeStaff].measures;
    }
    incrementActiveStaff(offset) {
        if (offset < 0) {
            offset = offset + this.staves.length;
        }
        const nextStaff = (this.activeStaff + offset) % this.staves.length;
        if (nextStaff >= 0 && nextStaff < this.staves.length) {
            this.activeStaff = nextStaff;
        }
        return this.activeStaff;
    }
    setActiveStaff(index) {
        this.activeStaff = index <= this.staves.length ? index : this.activeStaff;
    }
}
exports.SmoScore = SmoScore;


/***/ }),

/***/ "./src/smo/data/scoreModifiers.ts":
/*!****************************************!*\
  !*** ./src/smo/data/scoreModifiers.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SmoSystemGroup = exports.SmoLayoutManager = exports.GlobalLayoutAttributesArray = exports.SmoPageLayout = exports.SmoAudioPlayerSettings = exports.IsOscillatorType = exports.SmoFormattingManager = exports.SmoScoreModifierBase = void 0;
// [Smoosic](https://github.com/AaronDavidNewman/Smoosic)
// Copyright (c) Aaron David Newman 2021.
/**
 * A score modifier is anything that isn't mapped specifically to a musical object.
 * This includes score text, layout information
 * @module /smo/data/scoreModifier
 */
const serializationHelpers_1 = __webpack_require__(/*! ../../common/serializationHelpers */ "./src/common/serializationHelpers.js");
const measureModifiers_1 = __webpack_require__(/*! ./measureModifiers */ "./src/smo/data/measureModifiers.ts");
const selections_1 = __webpack_require__(/*! ../xform/selections */ "./src/smo/xform/selections.ts");
const VF = eval('Vex.Flow');
/**
 * Base class for all {@link SmoScore} modifiers.
 * It is used to de/serialize the objects.
 * @param ctor constructor for derived class
 * @param logicalBox bounding box in SVG coordinates, if rendered
 * @param attrs object identification
 * @category SmoModifier
 */
class SmoScoreModifierBase {
    constructor(ctor) {
        this.logicalBox = null;
        this.ctor = ctor;
        this.attrs = {
            id: VF.Element.newID(),
            type: ctor
        };
    }
    static deserialize(jsonObj) {
        const ctor = eval('globalThis.Smo.' + jsonObj.ctor);
        const rv = new ctor(jsonObj);
        return rv;
    }
}
exports.SmoScoreModifierBase = SmoScoreModifierBase;
/**
 * A score can have different views - one for the score itself and one for each
 * part, and each part can have its own formatting and text.
 * *Note*: I may move this to part info module.
 * @param measureFormats map of index to {@link SmoMeasureFormat} objects
 * @param partIndex the associated part, or -1 for the score
 * @category SmoModifier
 */
class SmoFormattingManager extends SmoScoreModifierBase {
    constructor(params) {
        super('SmoFormattingManager');
        this.partIndex = -1;
        if (typeof (params) === 'undefined') {
            params = {};
        }
        this.measureFormats = {};
        this.partIndex = SmoFormattingManager.forScore;
        if (typeof (params.partIndex) !== 'undefined') {
            this.partIndex = params.partIndex;
        }
        if (typeof (params.measureFormats) !== 'undefined' && params.measureFormats.length) {
            params.measureFormats.forEach((format) => {
                // 0 is default value, so fix case of first measure
                if (typeof (format.measureIndex) !== 'number') {
                    format.measureIndex = 0;
                }
                this.measureFormats[format.measureIndex] = new measureModifiers_1.SmoMeasureFormat(format);
            });
        }
    }
    static get forScore() {
        return -1;
    }
    static get defaults() {
        return {
            measureFormats: [new measureModifiers_1.SmoMeasureFormat(measureModifiers_1.SmoMeasureFormat.defaults)],
            partIndex: -1
        };
    }
    /**
     * Update the measure format for the measure at the given index
     * @param format
     */
    updateMeasureFormat(format) {
        this.measureFormats[format.measureIndex] = format;
    }
    /**
     * Update the measure format based on the format of a given measure
     * @param measure
     */
    updateFormat(measure) {
        if (this.measureFormats[measure.measureNumber.measureIndex]) {
            measure.format = this.measureFormats[measure.measureNumber.measureIndex];
        }
        else {
            measure.format = new measureModifiers_1.SmoMeasureFormat(measureModifiers_1.SmoMeasureFormat.defaults);
        }
    }
    serialize() {
        const rv = [];
        const keys = Object.keys(this.measureFormats);
        keys.forEach((key) => {
            if (!this.measureFormats[key].isDefault) {
                rv.push(this.measureFormats[key].serialize());
            }
        });
        return rv;
    }
}
exports.SmoFormattingManager = SmoFormattingManager;
/**
 * web audio API defines this
 * @param otype
 * @returns
 */
function IsOscillatorType(otype) {
    return ['sine', 'square', 'sawtooth', 'triangle', 'custom'].findIndex((x) => x === otype) >= 0;
}
exports.IsOscillatorType = IsOscillatorType;
/**
 * Audio playback parameters.  Just fun stuff.
 * @category SmoModifier
 */
class SmoAudioPlayerSettings extends SmoScoreModifierBase {
    constructor(params) {
        super('SmoAudioPlayerSettings');
        this.playerType = 'sampler';
        this.waveform = 'sine';
        this.reverbEnable = true;
        this.reverbDelay = 0.2;
        this.reverbDecay = 0.5;
        serializationHelpers_1.smoSerialize.serializedMerge(SmoAudioPlayerSettings.attributes, SmoAudioPlayerSettings.defaults, this);
        serializationHelpers_1.smoSerialize.serializedMerge(SmoAudioPlayerSettings.attributes, params, this);
    }
    static get defaults() {
        return {
            playerType: 'sampler',
            waveform: 'sine',
            reverbEnable: true,
            reverbDelay: 0.5,
            reverbDecay: 2
        };
    }
    static get attributes() {
        return ['playerType', 'waveform', 'reverbEnable', 'reverbDelay', 'reverbDecay'];
    }
    serialize() {
        const params = {};
        serializationHelpers_1.smoSerialize.serializedMergeNonDefault(SmoAudioPlayerSettings.defaults, SmoAudioPlayerSettings.attributes, this, params);
        params.ctor = 'SmoAudioPlayerSettings';
        return params;
    }
}
exports.SmoAudioPlayerSettings = SmoAudioPlayerSettings;
/**
 * Define margins and other layout information associated with a specific page, and may
 * be different on different pages.
 * @category SmoModifier
 */
class SmoPageLayout extends SmoScoreModifierBase {
    constructor(params) {
        super('SmoPageLayout');
        this.leftMargin = 30;
        this.rightMargin = 30;
        this.topMargin = 40;
        this.bottomMargin = 40;
        this.interGap = 30;
        this.intraGap = 10;
        this.leftMargin = params.leftMargin;
        this.rightMargin = params.rightMargin;
        this.topMargin = params.topMargin;
        this.bottomMargin = params.bottomMargin;
        this.interGap = params.interGap;
        this.intraGap = params.intraGap;
    }
    static get defaults() {
        return JSON.parse(JSON.stringify({
            leftMargin: 30,
            rightMargin: 30,
            topMargin: 144,
            bottomMargin: 72,
            interGap: 30,
            intraGap: 10
        }));
    }
    static get attributes() {
        return ['leftMargin', 'rightMargin', 'topMargin', 'bottomMargin', 'interGap', 'intraGap'];
    }
    serialize() {
        const params = {};
        serializationHelpers_1.smoSerialize.serializedMergeNonDefault(SmoPageLayout.defaults, SmoPageLayout.attributes, this, params);
        params.ctor = 'SmoPageLayout';
        return params;
    }
}
exports.SmoPageLayout = SmoPageLayout;
exports.GlobalLayoutAttributesArray = ['pageWidth', 'pageHeight', 'noteSpacing', 'svgScale', 'zoomScale', 'proportionality', 'maxMeasureSystem'];
/**
 * Storage and utilities for layout information in the score.  Each
 * manager has one set of page height/width, since svg element
 * must have single length/width and viewbox.
 * Each page can have different margins.
 * @category SmoModifier
 */
class SmoLayoutManager extends SmoScoreModifierBase {
    constructor(params) {
        super('SmoLayoutManager');
        this.pageLayouts = [];
        if (typeof (params.globalLayout.maxMeasureSystem) === 'undefined') {
            params.globalLayout.maxMeasureSystem = SmoLayoutManager.defaultLayout.maxMeasureSystem;
        }
        this.globalLayout = JSON.parse(JSON.stringify(params.globalLayout));
        if (params.pageLayouts.length) {
            params.pageLayouts.forEach((plp) => {
                const pageParams = SmoPageLayout.defaults;
                SmoPageLayout.attributes.forEach((attr) => {
                    if (typeof (plp[attr]) !== 'undefined') {
                        pageParams[attr] = plp[attr];
                    }
                });
                this.pageLayouts.push(new SmoPageLayout(pageParams));
            });
        }
        else {
            this.pageLayouts.push(new SmoPageLayout(SmoPageLayout.defaults));
        }
    }
    static get defaultLayout() {
        return {
            svgScale: 0.55,
            zoomScale: 2.0,
            noteSpacing: 1.0,
            pageWidth: 8 * 96 + 48,
            pageHeight: 11 * 96,
            proportionality: 5,
            maxMeasureSystem: 0
        };
    }
    static get defaults() {
        return {
            globalLayout: JSON.parse(JSON.stringify(SmoLayoutManager.defaultLayout)),
            pageLayouts: []
        };
    }
    static get attributes() {
        return ['pageWidth', 'pageHeight', 'noteSpacing', 'svgScale', 'zoomScale', 'maxMeasureSystem'];
    }
    // Attributes that are scaled by svgScale
    /* static get scalableAttributes(): Global {
      return ['pageWidth', 'pageHeight'];
    }*/
    static get scaledPageAttributes() {
        return ['leftMargin', 'rightMargin', 'topMargin', 'bottomMargin', 'interGap', 'intraGap'];
    }
    static get scaledGlobalAttributes() {
        return ['pageWidth', 'pageHeight'];
    }
    static areLayoutsEqual(g1, g2) {
        let rv = true;
        exports.GlobalLayoutAttributesArray.forEach((attr) => {
            if (g1[attr] !== g2[attr]) {
                rv = false;
            }
        });
        return rv;
    }
    static isZoomChange(g1, g2) {
        let rv = true;
        exports.GlobalLayoutAttributesArray.forEach((attr) => {
            if (g1[attr] !== g2[attr] && attr !== 'zoomScale') {
                rv = false;
            }
        });
        return rv;
    }
    /**
     * Adjust zoom width so the score takes up the whole score area
     */
    zoomToWidth(screenWidth) {
        const curWidth = this.globalLayout.pageWidth * this.globalLayout.svgScale;
        this.globalLayout.zoomScale = ((screenWidth - 350) / curWidth) * this.globalLayout.svgScale; // magic 350 for left controls....TODO standardize this
    }
    static getScaledPageLayout(globalLayout, pageLayout, pages) {
        const rv = {};
        SmoLayoutManager.scaledPageAttributes.forEach((attr) => {
            rv[attr] = pageLayout[attr] / globalLayout.svgScale;
        });
        SmoLayoutManager.scaledGlobalAttributes.forEach((attr) => {
            rv[attr] = globalLayout[attr] / globalLayout.svgScale;
        });
        // Note spacing is relative, so * it and not divide
        rv.noteSpacing = globalLayout.noteSpacing * globalLayout.svgScale;
        rv.svgScale = globalLayout.svgScale;
        rv.zoomScale = globalLayout.zoomScale;
        rv.maxMeasureSystem = globalLayout.maxMeasureSystem;
        return rv;
    }
    trimPages(pageCount) {
        if (pageCount < this.pageLayouts.length - 1) {
            this.pageLayouts = this.pageLayouts.slice(0, pageCount + 1);
        }
    }
    getZoomScale() {
        return this.globalLayout.zoomScale;
    }
    serialize() {
        const rv = {};
        rv.pageLayouts = [];
        this.pageLayouts.forEach((pl) => {
            rv.pageLayouts.push(pl.serialize());
        });
        rv.globalLayout = JSON.parse(JSON.stringify(this.globalLayout));
        return rv;
    }
    updateGlobalLayout(params) {
        SmoLayoutManager.attributes.forEach((attr) => {
            if (typeof (params[attr]) !== 'undefined') {
                this.globalLayout[attr] = params[attr];
            }
        });
    }
    // ### addToPageLayouts
    // Make sure the next page has a layout.  If not, copy settings from
    // previous page.
    addToPageLayouts(pageNum) {
        const lastLayout = this.pageLayouts[this.pageLayouts.length - 1];
        if (this.pageLayouts.length <= pageNum) {
            this.pageLayouts.push(new SmoPageLayout(lastLayout));
        }
    }
    getGlobalLayout() {
        return JSON.parse(JSON.stringify(this.globalLayout));
    }
    // Return a deep copy of the page parameters, adjusted for the global scale.
    getScaledPageLayout(pageIndex) {
        return SmoLayoutManager.getScaledPageLayout(this.globalLayout, this.pageLayouts[pageIndex], this.pageLayouts.length);
    }
    getPageLayout(pageIndex) {
        return new SmoPageLayout(this.pageLayouts[pageIndex]);
    }
    getPageLayouts() {
        const rv = [];
        this.pageLayouts.forEach((pl) => {
            rv.push(new SmoPageLayout(pl));
        });
        return rv;
    }
    updatePage(pageLayout, pageIndex) {
        if (this.pageLayouts.length > pageIndex) {
            this.pageLayouts[pageIndex] = new SmoPageLayout(pageLayout);
        }
    }
}
exports.SmoLayoutManager = SmoLayoutManager;
/**
 * System group is the grouping of staves into a system.
 * @category SmoModifier
 *  */
class SmoSystemGroup extends SmoScoreModifierBase {
    constructor(params) {
        super('SmoSystemGroup');
        this.leftConnector = SmoSystemGroup.connectorTypes.single;
        this.rightConnector = SmoSystemGroup.connectorTypes.single;
        this.mapType = SmoSystemGroup.mapTypes.allMeasures;
        this.text = '';
        this.shortText = '';
        this.justify = true;
        this.startSelector = selections_1.SmoSelector.default;
        this.endSelector = selections_1.SmoSelector.default;
        serializationHelpers_1.smoSerialize.serializedMerge(SmoSystemGroup.attributes, SmoSystemGroup.defaults, this);
        serializationHelpers_1.smoSerialize.serializedMerge(SmoSystemGroup.attributes, params, this);
        this.attrs = {
            id: VF.Element.newID(),
            type: 'SmoSystemGroup'
        };
    }
    static get connectorTypes() {
        return { brace: 0, bracket: 1, single: 2, double: 3 };
    }
    static get mapTypes() {
        return { allMeasures: 0, range: 1 };
    }
    static get attributes() {
        return ['leftConnector', 'rightConnector', 'text', 'shortText', 'justify',
            'startSelector', 'endSelector', 'mapType'];
    }
    static get defaults() {
        return JSON.parse(JSON.stringify({
            leftConnector: SmoSystemGroup.connectorTypes.single,
            rightConnector: SmoSystemGroup.connectorTypes.single,
            mapType: SmoSystemGroup.mapTypes.allMeasures,
            text: '',
            shortText: '',
            justify: true,
            startSelector: selections_1.SmoSelector.default,
            endSelector: selections_1.SmoSelector.default
        }));
    }
    static isSystemGroup(modifier) {
        return modifier.ctor === 'SmoSystemGroup';
    }
    stavesOverlap(group) {
        return (this.startSelector.staff >= group.startSelector.staff && this.startSelector.staff <= group.endSelector.staff) ||
            (this.endSelector.staff >= group.startSelector.staff && this.endSelector.staff <= group.endSelector.staff);
    }
    measuresOverlap(group) {
        return this.stavesOverlap(group) &&
            ((this.startSelector.measure >= group.startSelector.measure && this.endSelector.measure <= group.startSelector.measure) ||
                (this.endSelector.measure >= group.startSelector.measure && this.endSelector.measure <= group.endSelector.measure));
    }
    overlaps(group) {
        return (this.stavesOverlap(group) && this.mapType === SmoSystemGroup.mapTypes.allMeasures) ||
            (this.measuresOverlap(group) && this.mapType === SmoSystemGroup.mapTypes.range);
    }
    leftConnectorVx() {
        switch (this.leftConnector) {
            case SmoSystemGroup.connectorTypes.single:
                return VF.StaveConnector.type.SINGLE_LEFT;
            case SmoSystemGroup.connectorTypes.double:
                return VF.StaveConnector.type.DOUBLE_LEFT;
            case SmoSystemGroup.connectorTypes.brace:
                return VF.StaveConnector.type.BRACE;
            case SmoSystemGroup.connectorTypes.bracket:
            default:
                return VF.StaveConnector.type.BRACKET;
        }
    }
    rightConnectorVx() {
        switch (this.rightConnector) {
            case SmoSystemGroup.connectorTypes.single:
                return VF.StaveConnector.type.SINGLE_RIGHT;
            case SmoSystemGroup.connectorTypes.double:
            default:
                return VF.StaveConnector.type.DOUBLE_RIGHT;
        }
    }
    serialize() {
        const params = {};
        serializationHelpers_1.smoSerialize.serializedMergeNonDefault(SmoSystemGroup.defaults, SmoSystemGroup.attributes, this, params);
        params.ctor = 'SmoSystemGroup';
        return params;
    }
}
exports.SmoSystemGroup = SmoSystemGroup;


/***/ }),

/***/ "./src/smo/data/scoreText.ts":
/*!***********************************!*\
  !*** ./src/smo/data/scoreText.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SmoTextGroup = exports.SmoScoreText = void 0;
// [Smoosic](https://github.com/AaronDavidNewman/Smoosic)
// Copyright (c) Aaron David Newman 2021.
/**
 * A score modifier is anything that isn't mapped specifically to a musical object.
 * This includes score text, layout information
 * @module /smo/data/scoreModifier
 */
const serializationHelpers_1 = __webpack_require__(/*! ../../common/serializationHelpers */ "./src/common/serializationHelpers.js");
const scoreModifiers_1 = __webpack_require__(/*! ./scoreModifiers */ "./src/smo/data/scoreModifiers.ts");
const selections_1 = __webpack_require__(/*! ../xform/selections */ "./src/smo/xform/selections.ts");
const VF = eval('Vex.Flow');
/**
 * Identify some text in the score, not associated with any musical element, like page
 * decorations, titles etc.
 * Note: score text is always contained in a text group.  So this isn't directly accessed
 * by score, but we keep the collection in score for backwards-compatibility
 * @category SmoModifier
 * @internal
 */
class SmoScoreText extends scoreModifiers_1.SmoScoreModifierBase {
    constructor(parameters) {
        super('SmoScoreText');
        this.x = 15;
        this.y = 15;
        this.width = 0;
        this.height = 0;
        this.text = 'Smoosic';
        this.fontInfo = {
            size: 14,
            family: SmoScoreText.fontFamilies.serif,
            style: 'normal',
            weight: 'normal'
        };
        this.fill = 'black';
        this.rotate = 0;
        this.justification = SmoScoreText.justifications.left;
        this.classes = 'score-text';
        this.boxModel = 'none';
        this.scaleX = 1.0;
        this.scaleY = 1.0;
        this.translateX = 0;
        this.translateY = 0;
        this.pagination = 'once';
        this.position = 'custom';
        this.autoLayout = false; // set to true if one of the pre-canned positions are used.
        let rx = '';
        serializationHelpers_1.smoSerialize.serializedMerge(SmoScoreText.attributes, SmoScoreText.defaults, this);
        serializationHelpers_1.smoSerialize.serializedMerge(SmoScoreText.attributes, parameters, this);
        if (!this.classes) {
            this.classes = '';
        }
        if (this.classes.indexOf(this.attrs.id) < 0) {
            this.classes += ' ' + this.attrs.id;
        }
        if (this.boxModel === SmoScoreText.boxModels.wrap) {
            this.width = parameters.width ? this.width : 200;
            this.height = parameters.height ? this.height : 150;
        }
        const weight = parameters.fontInfo ? parameters.fontInfo.weight : 'normal';
        this.fontInfo.weight = SmoScoreText.weightString(weight);
        if (this.text) {
            rx = serializationHelpers_1.smoSerialize.tryParseUnicode(this.text);
            this.text = rx;
        }
    }
    // convert EM to a number, or leave as a number etc.
    static fontPointSize(size) {
        let rv = 12;
        if (typeof (size) === 'number') {
            return size;
        }
        const ptString = size.substring(0, size.length - 2);
        rv = parseFloat(ptString);
        if (size.indexOf('em') > 0) {
            rv *= 14;
        }
        else if (size.indexOf('px') > 0) {
            rv *= (96.0 / 72.0);
        }
        return rv;
    }
    /**
     * Convert a numeric or string weight into either 'bold' or 'normal'
     * @param fontWeight
     * @returns
     */
    static weightString(fontWeight) {
        let rv = 'normal';
        if (fontWeight) {
            const numForm = parseInt(fontWeight, 10);
            if (isNaN(numForm)) {
                rv = fontWeight;
            }
            else if (numForm > 500) {
                rv = 'bold';
            }
        }
        return rv;
    }
    static get paginations() {
        return { every: 'every', even: 'even', odd: 'odd', once: 'once', subsequent: 'subsequent' };
    }
    static get positions() {
        return { title: 'title', copyright: 'copyright', footer: 'footer', header: 'header', custom: 'custom' };
    }
    static get justifications() {
        return { left: 'left', right: 'right', center: 'center' };
    }
    static get fontFamilies() {
        return {
            serif: 'Merriweather', sansSerif: 'Roboto,sans-serif', monospace: 'monospace', cursive: 'cursive',
            times: 'Merriweather', arial: 'Arial'
        };
    }
    // If box model is 'none', the font and location determine the size.
    // spacing and spacingGlyph fit the box into a container based on the svg policy
    static get boxModels() {
        return { none: 'none', spacing: 'spacing', spacingAndGlyphs: 'spacingAndGlyphs', wrap: 'wrap' };
    }
    static get defaults() {
        return JSON.parse(JSON.stringify({
            x: 15,
            y: 15,
            width: 0,
            height: 0,
            text: 'Smoosic',
            fontInfo: {
                size: 14,
                family: SmoScoreText.fontFamilies.serif,
                style: 'normal',
                weight: 'normal'
            },
            fill: 'black',
            rotate: 0,
            justification: SmoScoreText.justifications.left,
            classes: 'score-text',
            boxModel: 'none',
            scaleX: 1.0,
            scaleY: 1.0,
            translateX: 0,
            translateY: 0,
            pagination: 'once',
            position: 'custom',
            autoLayout: false // set to true if one of the pre-canned positions are used.
        }));
    }
    getText() {
        return this.text;
    }
    estimateWidth() {
        let i = 0;
        let rv = 0;
        const textFont = VF.TextFormatter.create({
            family: this.fontInfo.family,
            size: this.fontInfo.size,
            weight: this.fontInfo.weight,
            style: this.fontInfo.style
        });
        textFont.setFontSize(this.fontInfo.size);
        for (i = 0; i < this.text.length; ++i) {
            rv += textFont.getWidthForTextInPx(this.text[i]);
        }
        return rv;
    }
    tryParseUnicode() {
        this.text = serializationHelpers_1.smoSerialize.tryParseUnicode(this.text);
    }
    offsetX(offset) {
        this.x += offset;
    }
    offsetY(offset) {
        this.y += offset;
    }
    serialize() {
        const params = {};
        serializationHelpers_1.smoSerialize.serializedMergeNonDefault(SmoScoreText.defaults, SmoScoreText.attributes, this, params);
        params.ctor = 'SmoScoreText';
        return params;
    }
    static get attributes() {
        return ['x', 'y', 'text', 'pagination', 'position', 'fontInfo', 'classes',
            'boxModel', 'justification', 'fill', 'width', 'height', 'scaleX', 'scaleY',
            'translateX', 'translateY', 'autoLayout'];
    }
}
exports.SmoScoreText = SmoScoreText;
/**
 * A grouping of text that can be used as a block for
 * justification, alignment etc.
 * @category SmoModifier
 */
class SmoTextGroup extends scoreModifiers_1.SmoScoreModifierBase {
    /* _isScoreText(st: ) {
      return st.ctor && st.ctor === 'SmoScoreText';
    } */
    constructor(params) {
        super('SmoTextGroup');
        this.justification = SmoTextGroup.justifications.LEFT;
        this.relativePosition = SmoTextGroup.relativePositions.RIGHT;
        this.pagination = SmoTextGroup.paginations.ONCE;
        this.purpose = SmoTextGroup.purposes.NONE;
        this.spacing = 0;
        this.attachToSelector = false;
        this.musicXOffset = 0;
        this.musicYOffset = 0;
        this.elements = [];
        this.textBlocks = [];
        this.edited = false; // indicates not edited this session
        this.skipRender = false; // don't render if it is being edited  
        if (typeof (params) === 'undefined') {
            params = {};
        }
        this.textBlocks = [];
        Vex.Merge(this, SmoTextGroup.defaults);
        Vex.Merge(this, params);
        if (params.blocks) {
            params.blocks.forEach((block) => {
                this.textBlocks.push(block);
            });
        }
    }
    static get justifications() {
        return {
            LEFT: 1,
            RIGHT: 2,
            CENTER: 3
        };
    }
    static get paginations() {
        return { EVERY: 1, EVENT: 2, ODD: 3, ONCE: 4, SUBSEQUENT: 5 };
    }
    // The position of block n relative to block n-1.  Each block
    // has it's own position.  Justification is inter-block.
    static get relativePositions() {
        return { ABOVE: 1, BELOW: 2, LEFT: 3, RIGHT: 4 };
    }
    static get purposes() {
        return {
            NONE: 1, TITLE: 2, SUBTITLE: 3, COMPOSER: 4, COPYRIGHT: 5
        };
    }
    static get attributes() {
        return ['textBlocks', 'justification', 'relativePosition', 'spacing', 'pagination', 'attachToSelector', 'selector', 'musicXOffset', 'musicYOffset'];
    }
    static isTextGroup(modifier) {
        return modifier.ctor === 'SmoTextGroup';
    }
    static get purposeToFont() {
        const rv = {};
        rv[SmoTextGroup.purposes.TITLE] = {
            fontFamily: 'Merriweather',
            fontSize: 18,
            justification: SmoTextGroup.justifications.CENTER,
            xPlacement: 0.5,
            yOffset: 4
        };
        rv[SmoTextGroup.purposes.SUBTITLE] = {
            fontFamily: 'Merriweather',
            fontSize: 16,
            justification: SmoTextGroup.justifications.CENTER,
            xPlacement: 0.5,
            yOffset: 20,
        };
        rv[SmoTextGroup.purposes.COMPOSER] = {
            fontFamily: 'Merriweather',
            fontSize: 12,
            justification: SmoTextGroup.justifications.RIGHT,
            xPlacement: 0.8,
            yOffset: 10
        };
        rv[SmoTextGroup.purposes.COPYRIGHT] = {
            fontFamily: 'Merriweather',
            fontSize: 12,
            xPlacement: 0.5,
            justification: SmoTextGroup.justifications.CENTER,
            yOffset: -12
        };
        return rv;
    }
    // ### createTextForLayout
    // Create a specific score text type (title etc.) based on the supplied
    // score layout
    static createTextForLayout(purpose, text, layout) {
        let x = 0;
        const textAttr = SmoTextGroup.purposeToFont[purpose];
        const pageWidth = layout.pageWidth;
        const pageHeight = layout.pageHeight;
        const bottomMargin = layout.bottomMargin;
        const topMargin = layout.topMargin;
        x = textAttr.xPlacement > 0 ? pageWidth * textAttr.xPlacement
            : pageWidth - (pageWidth * textAttr.xPlacement);
        const y = textAttr.yOffset > 0 ?
            topMargin + textAttr.yOffset :
            pageHeight + textAttr.yOffset - bottomMargin;
        const defaults = SmoScoreText.defaults;
        const st = new SmoScoreText({
            text, x, y, width: defaults.width, height: defaults.height,
            fontInfo: { family: textAttr.fontFamily, size: textAttr.fontSize, weight: 'normal' }
        });
        const width = st.estimateWidth();
        x -= width / 2;
        const tg = new SmoTextGroup({
            blocks: [{ text: st, position: SmoTextGroup.relativePositions.RIGHT, activeText: false }],
            purpose, pagination: SmoTextGroup.paginations.EVERY,
            attachToSelector: false, justification: SmoTextGroup.justifications.CENTER, spacing: 0, relativePosition: SmoTextGroup.relativePositions.LEFT,
            selector: selections_1.SmoSelector.default
        });
        return tg;
    }
    static get defaults() {
        return JSON.parse(JSON.stringify({
            textBlocks: [],
            justification: SmoTextGroup.justifications.LEFT,
            relativePosition: SmoTextGroup.relativePositions.RIGHT,
            pagination: SmoTextGroup.paginations.ONCE,
            purpose: SmoTextGroup.purposes.NONE,
            spacing: 0,
            attachToSelector: false,
            selector: null,
            musicXOffset: 0,
            musicYOffset: 0
        }));
    }
    static deserialize(jObj) {
        const blocks = [];
        const params = {};
        // Create new scoreText object for the text blocks
        jObj.textBlocks.forEach((st) => {
            if (typeof (st.text.fontInfo.size === 'string')) {
                st.text.fontInfo.size = SmoScoreText.fontPointSize(st.text.fontInfo.size);
            }
            const tx = new SmoScoreText(st.text);
            blocks.push({ text: tx, position: st.position });
        });
        // fill in the textBlock configuration
        SmoTextGroup.attributes.forEach((attr) => {
            if (attr !== 'textBlocks') {
                if (typeof (jObj[attr]) !== 'undefined') {
                    params[attr] = jObj[attr];
                }
            }
        });
        params.blocks = blocks;
        return new SmoTextGroup(params);
    }
    static deserializePreserveId(jObj) {
        const rv = SmoTextGroup.deserialize(jObj);
        if (jObj.attrs.id) {
            rv.attrs.id = jObj.attrs.id;
        }
        return rv;
    }
    // ### getPagedTextGroups
    // If this text is repeated on page, create duplicates for each page, and
    // resolve page numbers;
    static getPagedTextGroups(tg, pages, pageHeight) {
        const rv = [];
        let i = 0;
        if (tg.pagination === SmoTextGroup.paginations.ONCE) {
            rv.push(tg);
            return rv;
        }
        for (i = 0; i < pages; ++i) {
            const ix = i;
            const nblocks = [];
            // deep copy the blocks so the page offsets don't bleed into
            // original.
            tg.textBlocks.forEach((block) => {
                const nscoreText = new SmoScoreText(block.text);
                nblocks.push({
                    text: nscoreText, position: block.position
                });
            });
            const params = {};
            SmoTextGroup.attributes.forEach((attr) => {
                if (attr !== 'textBlocks') {
                    params[attr] = tg[attr];
                }
            });
            params.blocks = nblocks;
            const ngroup = new SmoTextGroup(params);
            ngroup.textBlocks.forEach((block) => {
                const xx = block.text;
                xx.classes = 'score-text ' + xx.attrs.id;
                xx.text = xx.text.replace('###', (ix + 1).toString()); /// page number
                xx.text = xx.text.replace('@@@', pages.toString()); /// page number
                xx.y += pageHeight * ix;
            });
            if (tg.logicalBox) {
                ngroup.logicalBox = JSON.parse(JSON.stringify(tg.logicalBox));
                ngroup.logicalBox.y += pageHeight * i;
            }
            rv.push(ngroup);
        }
        return rv;
    }
    serialize() {
        const params = {};
        serializationHelpers_1.smoSerialize.serializedMergeNonDefault(SmoTextGroup.defaults, SmoTextGroup.attributes, this, params);
        params.ctor = 'SmoTextGroup';
        params.attrs = JSON.parse(JSON.stringify(this.attrs));
        return params;
    }
    scaleText(scale) {
        this.musicXOffset *= scale;
        this.musicYOffset *= scale;
        this.textBlocks.forEach((block) => {
            block.text.x *= scale;
            block.text.y *= scale;
        });
    }
    // ### tryParseUnicode
    // Try to parse unicode strings.
    tryParseUnicode() {
        this.textBlocks.forEach((tb) => {
            tb.text.tryParseUnicode();
        });
    }
    estimateWidth() {
        let rv = 0;
        this.textBlocks.forEach((tb) => {
            rv += tb.text.estimateWidth();
        });
        return rv;
    }
    // avoid saving text that can't be deleted
    isTextVisible() {
        let rv = true;
        if (this.attachToSelector) {
            return true;
        }
        this.textBlocks.forEach((block) => {
            if (block.text.x < 0 || block.text.y < 0) {
                rv = false;
            }
        });
        return rv;
    }
    // ### setActiveBlock
    // let the UI know which block is being edited.  Parameter null means reset all
    setActiveBlock(scoreText) {
        this.textBlocks.forEach((block) => {
            if (scoreText != null && block.text.attrs.id === scoreText.attrs.id) {
                block.activeText = true;
            }
            else {
                block.activeText = false;
            }
        });
    }
    // For editing, keep track of the active text block.
    getActiveBlock() {
        const rv = this.textBlocks.find((block) => block.activeText === true);
        if (typeof (rv) !== 'undefined') {
            return rv.text;
        }
        return this.textBlocks[0].text;
    }
    setRelativePosition(position) {
        this.textBlocks.forEach((block) => {
            block.position = position;
        });
        this.relativePosition = position;
    }
    firstBlock() {
        return this.textBlocks[0].text;
    }
    indexOf(scoreText) {
        return this.textBlocks.findIndex((block) => block.text.attrs.id === scoreText.attrs.id);
    }
    addScoreText(scoreText, position = SmoTextGroup.relativePositions.LEFT) {
        this.textBlocks.push({ text: scoreText, position, activeText: false });
    }
    ul() {
        const rv = { x: 0, y: 0 };
        this.textBlocks.forEach((block) => {
            rv.x = block.text.x > rv.x ? block.text.x : rv.x;
            rv.y = block.text.y > rv.y ? block.text.y : rv.y;
        });
        return rv;
    }
    removeBlock(scoreText) {
        const bbid = (typeof (scoreText) === 'string') ? scoreText : scoreText.attrs.id;
        const ix = this.textBlocks.findIndex((bb) => bb.text.attrs.id === bbid);
        this.textBlocks.splice(ix, 1);
    }
    offsetX(offset) {
        if (this.attachToSelector) {
            this.musicXOffset += offset;
        }
        this.textBlocks.forEach((block) => {
            block.text.offsetX(offset);
        });
    }
    offsetY(offset) {
        if (this.attachToSelector) {
            this.musicYOffset += offset;
        }
        this.textBlocks.forEach((block) => {
            block.text.offsetY(offset);
        });
    }
}
exports.SmoTextGroup = SmoTextGroup;


/***/ }),

/***/ "./src/smo/data/staffModifiers.ts":
/*!****************************************!*\
  !*** ./src/smo/data/staffModifiers.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SmoTie = exports.SmoSlur = exports.SlurNumberParams = exports.SmoStaffTextBracket = exports.SmoTextBracketNumberTypes = exports.SmoTextBracketStringTypes = exports.SmoStaffHairpin = exports.SmoInstrument = exports.SmoInstrumentStringParams = exports.SmoInstrumentNumParams = exports.SmoOscillatorInfoAllTypes = exports.StaffModifierBase = void 0;
// [Smoosic](https://github.com/AaronDavidNewman/Smoosic)
// Copyright (c) Aaron David Newman 2021.
/**
 * Classes to modify a staff or system.  Some staff modifiers can span multiple
 * staves, so it can be a little arbitrary what is a score vs. staff modifier.  But
 * generally, a staff modifier is anything that has a beginning and end {@link SmoSelector}
 * @module /smo/data/staffModifiers
 */
const serializationHelpers_1 = __webpack_require__(/*! ../../common/serializationHelpers */ "./src/common/serializationHelpers.js");
const selections_1 = __webpack_require__(/*! ../xform/selections */ "./src/smo/xform/selections.ts");
const VF = eval('Vex.Flow');
/**
 * Base class that mostly standardizes the interface and deals with serialization.
 * @param ctor constructor for derived class
 * @param logicalBox bounding box in SVG coordinates, if rendered
 * @param attrs object identification
 * @param startSelector where the modifier starts
 * @param endSelector where it ends
 * @category SmoModifier
 * */
class StaffModifierBase {
    constructor(ctor) {
        this.associatedStaff = 0;
        this.startSelector = selections_1.SmoSelector.default;
        this.endSelector = selections_1.SmoSelector.default;
        this.logicalBox = null;
        this.element = null;
        this.ctor = ctor;
        this.attrs = {
            id: VF.Element.newID(),
            type: ctor
        };
    }
    static deserialize(params) {
        const ctor = eval('globalThis.Smo.' + params.ctor);
        const fixInstrument = params;
        if (fixInstrument.subFamily) {
            fixInstrument.instrument = fixInstrument.subFamily;
        }
        const rv = new ctor(params);
        return rv;
    }
}
exports.StaffModifierBase = StaffModifierBase;
exports.SmoOscillatorInfoAllTypes = ['minDuration', 'maxDuration', 'dynamic', 'nativeFrequency', 'realOvertones', 'imaginaryOvertones', 'sample', 'family',
    'waveform', 'sustain', 'options', 'instrument'];
exports.SmoInstrumentNumParams = ['keyOffset', 'midichannel', 'midiport'];
exports.SmoInstrumentStringParams = ['instrumentName', 'abbreviation', 'family', 'instrument'];
/**
 * Define an instrument.  An instrument is associated with a part, but a part can have instrument changes
 * and thus contain multiple instruments at different points in the score.
 * Not all of these parameters are fully utilized yet, and there are plans to greatly expand what
 * an SmoInstrument is.  Note I may move this to PartInfo module.
 * @category SmoModifier
 */
class SmoInstrument extends StaffModifierBase {
    constructor(params) {
        super('SmoInstrument');
        this.instrumentName = '';
        this.abbreviation = '';
        this.keyOffset = 0;
        this.clef = 'treble';
        this.oscillators = [];
        let name = '';
        if (typeof (params.instrument) === 'undefined') {
            name = params.instrumentName;
        }
        else {
            name = params.instrument;
        }
        this.instrumentName = name;
        this.family = params.family;
        this.instrument = params.instrument;
        this.keyOffset = params.keyOffset;
        this.clef = params.clef;
        this.midiport = params.midiport;
        this.midichannel = params.midichannel;
        this.startSelector = params.startSelector;
        this.endSelector = params.endSelector;
    }
    static get attributes() {
        return ['startSelector', 'endSelector', 'keyOffset', 'midichannel', 'midiport', 'instrumentName', 'abbreviation', 'instrument', 'family'];
    }
    static get defaults() {
        return JSON.parse(JSON.stringify({
            clef: 'treble',
            keyOffset: 0,
            instrumentName: '',
            abbreviation: '',
            family: 'keyboard',
            instrument: 'piano',
            midichannel: 0,
            midiport: 0,
            startSelector: selections_1.SmoSelector.default,
            endSelector: selections_1.SmoSelector.default
        }));
    }
    static get defaultOscillatorParam() {
        return JSON.parse(JSON.stringify({
            waveform: 'sample',
            sustain: 'percussive',
            realOvertones: [],
            imaginaryOvertones: [],
            sample: null,
            family: 'none',
            instrument: 'none',
            nativeFrequency: 440,
            dynamic: 100,
            options: [],
            minDuration: 0,
            maxDuration: 0
        }));
    }
    serialize() {
        const params = {};
        serializationHelpers_1.smoSerialize.serializedMergeNonDefault(SmoInstrument.defaults, SmoInstrument.attributes, this, params);
        params.ctor = 'SmoInstrument';
        return params;
    }
    eq(other) {
        let rv = true;
        exports.SmoInstrumentNumParams.forEach((param) => {
            if (other[param] !== this[param]) {
                rv = false;
            }
        });
        exports.SmoInstrumentStringParams.forEach((param) => {
            if (other[param] !== this[param]) {
                rv = false;
            }
        });
        return rv;
    }
}
exports.SmoInstrument = SmoInstrument;
/**
 * Also called crescendo etc.
 * @category SmoModifier
 */
class SmoStaffHairpin extends StaffModifierBase {
    constructor(params) {
        super('SmoStaffHairpin');
        this.xOffsetLeft = -2;
        this.xOffsetRight = 0;
        this.yOffset = -50;
        this.height = 10;
        this.position = SmoStaffHairpin.positions.BELOW;
        this.hairpinType = SmoStaffHairpin.types.CRESCENDO;
        this.startSelector = selections_1.SmoSelector.default;
        this.endSelector = selections_1.SmoSelector.default;
        Vex.Merge(this, SmoStaffHairpin.defaults);
        serializationHelpers_1.smoSerialize.filteredMerge(SmoStaffHairpin.attributes, params, this);
        // If start/end selector on same note, make sure the hairpin extends
        if (selections_1.SmoSelector.eq(this.startSelector, this.endSelector)) {
            if (this.xOffsetRight === SmoStaffHairpin.defaults.xOffsetRight
                && this.xOffsetLeft === SmoStaffHairpin.defaults.xOffsetLeft) {
                this.xOffsetLeft = -10;
                this.xOffsetRight = 10;
            }
        }
        if (!this.attrs) {
            this.attrs = {
                id: VF.Element.newID(),
                type: 'SmoStaffHairpin'
            };
        }
    }
    static get editableAttributes() {
        return ['xOffsetLeft', 'xOffsetRight', 'yOffset', 'height'];
    }
    static get defaults() {
        return JSON.parse(JSON.stringify({
            xOffsetLeft: -2,
            xOffsetRight: 0,
            yOffset: -50,
            height: 10,
            position: SmoStaffHairpin.positions.BELOW,
            hairpinType: SmoStaffHairpin.types.CRESCENDO,
            startSelector: selections_1.SmoSelector.default,
            endSelector: selections_1.SmoSelector.default
        }));
    }
    static get positions() {
        // matches VF.modifier
        return {
            LEFT: 1,
            RIGHT: 2,
            ABOVE: 3,
            BELOW: 4,
        };
    }
    static get types() {
        return {
            CRESCENDO: 1,
            DECRESCENDO: 2
        };
    }
    static get attributes() {
        return ['position', 'startSelector', 'endSelector', 'xOffsetLeft',
            'xOffsetRight', 'yOffset', 'hairpinType', 'height'];
    }
    serialize() {
        const params = {};
        serializationHelpers_1.smoSerialize.serializedMergeNonDefault(SmoStaffHairpin.defaults, SmoStaffHairpin.attributes, this, params);
        params.ctor = 'SmoStaffHairpin';
        return params;
    }
}
exports.SmoStaffHairpin = SmoStaffHairpin;
exports.SmoTextBracketStringTypes = ['text', 'superscript'];
exports.SmoTextBracketNumberTypes = ['line', 'position'];
/**
 * Text like 8va, rit. that is bracketed on a system
 * @category SmoModifier
 */
class SmoStaffTextBracket extends StaffModifierBase {
    constructor(params) {
        super('SmoStaffTextBracket');
        this.position = SmoStaffTextBracket.positions.BOTTOM;
        this.text = '';
        this.superscript = '';
        this.line = 1;
        this.startSelector = selections_1.SmoSelector.default;
        this.endSelector = selections_1.SmoSelector.default;
        serializationHelpers_1.smoSerialize.serializedMerge(SmoStaffTextBracket.attributes, SmoStaffTextBracket.defaults, this);
        serializationHelpers_1.smoSerialize.serializedMerge(SmoStaffTextBracket.attributes, params, this);
        this.startSelector = JSON.parse(JSON.stringify(params.startSelector));
        this.endSelector = JSON.parse(JSON.stringify(params.endSelector));
        if (!this.attrs) {
            this.attrs = {
                id: VF.Element.newID(),
                type: 'SmoStaffTextBracket'
            };
        }
    }
    static get defaults() {
        return JSON.parse(JSON.stringify({
            line: 1,
            position: SmoStaffTextBracket.positions.BOTTOM,
            text: '',
            superscript: '',
            startSelector: selections_1.SmoSelector.default,
            endSelector: selections_1.SmoSelector.default
        }));
    }
    static get positions() {
        // matches VF.modifier
        return {
            TOP: 1,
            BOTTOM: -1
        };
    }
    static get attributes() {
        return ['startSelector', 'endSelector', 'line', 'position', 'text', 'superscript'];
    }
    serialize() {
        const params = {};
        serializationHelpers_1.smoSerialize.serializedMergeNonDefault(SmoStaffTextBracket.defaults, SmoStaffTextBracket.attributes, this, params);
        params.ctor = 'SmoStaffTextBracket';
        return params;
    }
}
exports.SmoStaffTextBracket = SmoStaffTextBracket;
SmoStaffTextBracket.RITARD = 'ritard';
SmoStaffTextBracket.ACCEL = 'accelerando';
SmoStaffTextBracket.CRESCENDO = 'crescendo';
SmoStaffTextBracket.DIMENUENDO = 'diminuendo';
SmoStaffTextBracket.OCTAVEUP = '8va';
SmoStaffTextBracket.OCTAVEDOWN = '8vb';
SmoStaffTextBracket.OCTAVEUP2 = '15va';
SmoStaffTextBracket.OCTAVE2DOWN = '15vb';
exports.SlurNumberParams = ['spacing', 'thickness', 'xOffset', 'yOffset', 'position',
    'position_end', 'cp1x', 'cp1y', 'cp2x', 'cp2y'];
/**
 * Defines a slur
 * @category SmoModifier
 */
class SmoSlur extends StaffModifierBase {
    constructor(params) {
        super('SmoSlur');
        this.spacing = 2;
        this.thickness = 2;
        this.xOffset = -5;
        this.yOffset = 10;
        this.position = SmoSlur.positions.TOP;
        this.position_end = SmoSlur.positions.TOP;
        this.orientation = SmoSlur.orientations.AUTO;
        this.invert = false;
        this.cp1x = 0;
        this.cp1y = 15;
        this.cp2x = 0;
        this.cp2y = 15;
        this.startSelector = selections_1.SmoSelector.default;
        this.endSelector = selections_1.SmoSelector.default;
        serializationHelpers_1.smoSerialize.serializedMerge(SmoSlur.parameterArray, SmoSlur.defaults, this);
        serializationHelpers_1.smoSerialize.serializedMerge(SmoSlur.parameterArray, params, this);
        this.startSelector = params.startSelector;
        this.endSelector = params.endSelector;
        // Fix some earlier serialization error.    
        if (!this.attrs) {
            this.attrs = {
                id: VF.Element.newID(),
                type: 'SmoSlur'
            };
        }
    }
    static get defaults() {
        return JSON.parse(JSON.stringify({
            spacing: 2,
            thickness: 2,
            xOffset: 5,
            yOffset: 0,
            position: SmoSlur.positions.TOP,
            position_end: SmoSlur.positions.TOP,
            orientation: SmoSlur.orientations.AUTO,
            invert: false,
            cp1x: 0,
            cp1y: 15,
            cp2x: 0,
            cp2y: 15,
            startSelector: selections_1.SmoSelector.default,
            endSelector: selections_1.SmoSelector.default
        }));
    }
    // matches VF curve
    static get positions() {
        return {
            HEAD: 1,
            TOP: 2,
            ABOVE: 3,
            BELOW: 4,
            AUTO: 5
        };
    }
    static get orientations() {
        return {
            AUTO: 0,
            UP: 1,
            DOWN: 2
        };
    }
    static get parameterArray() {
        return ['startSelector', 'endSelector', 'spacing', 'xOffset', 'yOffset', 'position', 'position_end', 'invert',
            'orientation', 'cp1x', 'cp1y', 'cp2x', 'cp2y', 'thickness', 'pitchesStart', 'pitchesEnd'];
    }
    serialize() {
        const params = {};
        serializationHelpers_1.smoSerialize.serializedMergeNonDefault(SmoSlur.defaults, SmoSlur.parameterArray, this, params);
        params.ctor = 'SmoSlur';
        return params;
    }
    get controlPoints() {
        const ar = [{
                x: this.cp1x,
                y: this.cp1y
            }, {
                x: this.cp2x,
                y: this.cp2y
            }];
        return ar;
    }
}
exports.SmoSlur = SmoSlur;
/**
 * Like slur, but multiple pitches.
 * @category SmoModifier
 */
class SmoTie extends StaffModifierBase {
    constructor(params) {
        super('SmoTie');
        this.invert = false;
        this.cp1 = 8;
        this.cp2 = 12;
        this.first_x_shift = 0;
        this.last_x_shift = 0;
        this.y_shift = 7;
        this.tie_spacing = 0;
        this.lines = [];
        this.startSelector = selections_1.SmoSelector.default;
        this.endSelector = selections_1.SmoSelector.default;
        serializationHelpers_1.smoSerialize.serializedMerge(SmoTie.parameterArray, SmoTie.defaults, this);
        serializationHelpers_1.smoSerialize.serializedMerge(SmoTie.parameterArray, params, this);
        if (!this.attrs) {
            this.attrs = {
                id: VF.Element.newID(),
                type: 'SmoTie'
            };
        }
    }
    static get defaults() {
        return JSON.parse(JSON.stringify({
            invert: false,
            cp1: 8,
            cp2: 12,
            y_shift: 7,
            first_x_shift: 0,
            last_x_shift: 0,
            lines: [],
            startSelector: selections_1.SmoSelector.default,
            endSelector: selections_1.SmoSelector.default
        }));
    }
    static get parameterArray() {
        return ['startSelector', 'endSelector', 'invert', 'lines', 'y_shift', 'tie_spacing', 'cp1', 'cp2', 'first_x_shift', 'last_x_shift'];
    }
    static get vexParameters() {
        return ['cp1', 'cp2', 'first_x_shift', 'last_x_shift'];
    }
    static isTie(modifier) {
        return modifier.ctor === 'SmoTie';
    }
    static createLines(fromNote, toNote) {
        const maxPitches = Math.max(fromNote.pitches.length, toNote.pitches.length);
        let i = 0;
        const lines = [];
        // By default, just tie all the pitches to all the other pitches in order
        for (i = 0; i < maxPitches; ++i) {
            const from = i < fromNote.pitches.length ? i : fromNote.pitches.length - 1;
            const to = i < toNote.pitches.length ? i : toNote.pitches.length - 1;
            lines.push({ from, to });
        }
        return lines;
    }
    get vexOptions() {
        const rv = {};
        rv.direction = this.invert ? VF.Stem.DOWN : VF.Stem.UP;
        SmoTie.vexParameters.forEach((p) => {
            rv[p] = this[p];
        });
        return rv;
    }
    serialize() {
        const params = {};
        serializationHelpers_1.smoSerialize.serializedMergeNonDefault(SmoTie.defaults, SmoTie.parameterArray, this, params);
        params.ctor = 'SmoTie';
        return params;
    }
    // ### checkLines
    // If the note chords have changed, the lines may no longer be valid so update them
    checkLines(fromNote, toNote) {
        const maxTo = this.lines.map((ll) => ll.to).reduce((a, b) => a > b ? a : b);
        const maxFrom = this.lines.map((ll) => ll.from).reduce((a, b) => a > b ? a : b);
        if (maxTo < toNote.pitches.length && maxFrom < fromNote.pitches.length) {
            return;
        }
        this.lines = SmoTie.createLines(fromNote, toNote);
    }
}
exports.SmoTie = SmoTie;


/***/ }),

/***/ "./src/smo/data/systemStaff.ts":
/*!*************************************!*\
  !*** ./src/smo/data/systemStaff.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SmoSystemStaff = void 0;
const music_1 = __webpack_require__(/*! ./music */ "./src/smo/data/music.ts");
const measure_1 = __webpack_require__(/*! ./measure */ "./src/smo/data/measure.ts");
const measureModifiers_1 = __webpack_require__(/*! ./measureModifiers */ "./src/smo/data/measureModifiers.ts");
const staffModifiers_1 = __webpack_require__(/*! ./staffModifiers */ "./src/smo/data/staffModifiers.ts");
const partInfo_1 = __webpack_require__(/*! ./partInfo */ "./src/smo/data/partInfo.ts");
const scoreText_1 = __webpack_require__(/*! ./scoreText */ "./src/smo/data/scoreText.ts");
const selections_1 = __webpack_require__(/*! ../xform/selections */ "./src/smo/xform/selections.ts");
const beamers_1 = __webpack_require__(/*! ../xform/beamers */ "./src/smo/xform/beamers.ts");
const serializationHelpers_1 = __webpack_require__(/*! ../../common/serializationHelpers */ "./src/common/serializationHelpers.js");
const VF = eval('Vex.Flow');
/**
 * A staff is a line of music that can span multiple measures.
 * A system is a line of music for each staff in the score.  So a staff
 * spans multiple systems.
 * A staff modifier connects 2 points in the staff.
 * @category SmoObject
 * */
class SmoSystemStaff {
    constructor(params) {
        var _a;
        this.staffId = 0;
        this.renumberingMap = {};
        this.keySignatureMap = {};
        this.measureInstrumentMap = {};
        this.measures = [];
        this.modifiers = [];
        this.textBrackets = [];
        this.bracketMap = {};
        this.attrs = {
            id: '',
            type: 'SmoSystemStaff'
        };
        this.ctor = 'SmoSystemStaff';
        this._mappedStaffId = 0;
        this.staffId = params.staffId;
        this.measures = params.measures;
        this.modifiers = params.modifiers;
        this.textBrackets = (_a = params.textBrackets) !== null && _a !== void 0 ? _a : [];
        if (Object.keys(params.measureInstrumentMap).length === 0) {
            this.measureInstrumentMap[0] = new staffModifiers_1.SmoInstrument(staffModifiers_1.SmoInstrument.defaults);
            this.measureInstrumentMap[0].startSelector.staff = this.staffId;
            this.measureInstrumentMap[0].endSelector.staff = this.measures.length;
        }
        else {
            Object.keys(params.measureInstrumentMap).forEach((p) => {
                const pnum = parseInt(p, 10);
                this.measureInstrumentMap[pnum] = new staffModifiers_1.SmoInstrument(params.measureInstrumentMap[pnum]);
            });
        }
        if (this.measures.length) {
            this.numberMeasures();
        }
        this.attrs = {
            id: VF.Element.newID(),
            type: 'SmoSystemStaff'
        };
        if (params.partInfo) {
            this.partInfo = params.partInfo;
        }
        else {
            const staveNo = this.staffId + 1;
            const partDefs = partInfo_1.SmoPartInfo.defaults;
            partDefs.partName = 'Staff ' + staveNo;
            partDefs.partAbbreviation = staveNo.toString() + '.';
            this.partInfo = new partInfo_1.SmoPartInfo(partDefs);
        }
    }
    /**
     * Gets the instrument assigned to a given measure
     * @param measureInstrumentMap
     * @param measureIndex
     * @returns
     */
    static getStaffInstrument(measureInstrumentMap, measureIndex) {
        const keyar = Object.keys(measureInstrumentMap);
        let fit = 0;
        keyar.forEach((key) => {
            const numkey = parseInt(key, 10);
            if (numkey <= measureIndex && numkey > fit) {
                fit = numkey;
            }
        });
        return measureInstrumentMap[fit];
    }
    static getStaffInstrumentArray(measureInstrumentMap) {
        const rv = [];
        const keyar = Object.keys(measureInstrumentMap);
        keyar.forEach((key) => {
            const measureIndex = parseInt(key, 10);
            rv.push({ measureIndex, instrument: measureInstrumentMap[measureIndex] });
        });
        return rv;
    }
    // ### defaults
    // default values for all instances
    static get defaults() {
        return JSON.parse(JSON.stringify({
            staffId: 0,
            renumberingMap: {},
            keySignatureMap: {},
            measureInstrumentMap: {},
            textBrackets: [],
            measures: [],
            modifiers: []
        }));
    }
    setMappedStaffId(value) {
        this._mappedStaffId = value;
    }
    getMappedStaffId() {
        return this._mappedStaffId;
    }
    // ### defaultParameters
    // the parameters that get saved with the score.
    static get defaultParameters() {
        return [
            'renumberingMap', 'keySignatureMap', 'instrumentInfo'
        ];
    }
    get renderableModifiers() {
        const rv = this.modifiers.concat(this.textBrackets);
        return rv;
    }
    // ### serialize
    // JSONify self.
    serialize() {
        const params = {};
        serializationHelpers_1.smoSerialize.serializedMerge(SmoSystemStaff.defaultParameters, this, params);
        params.modifiers = [];
        params.measures = [];
        params.measureInstrumentMap = {};
        const ikeys = Object.keys(this.measureInstrumentMap);
        ikeys.forEach((ikey) => {
            params.measureInstrumentMap[ikey] = this.measureInstrumentMap[parseInt(ikey, 10)].serialize();
        });
        this.measures.forEach((measure) => {
            params.measures.push(measure.serialize());
        });
        this.modifiers.forEach((modifier) => {
            params.modifiers.push(modifier.serialize());
        });
        this.textBrackets.forEach((bracket) => {
            params.modifiers.push(bracket.serialize());
        });
        params.partInfo = this.partInfo.serialize();
        return params;
    }
    // ### deserialize
    // parse formerly serialized staff.
    static deserialize(jsonObj) {
        var _a, _b;
        const defaults = SmoSystemStaff.defaults;
        const params = SmoSystemStaff.defaults;
        params.staffId = (_a = jsonObj.staffId) !== null && _a !== void 0 ? _a : 0;
        params.measures = [];
        params.modifiers = [];
        params.textBrackets = [];
        if (jsonObj.partInfo) {
            // Deserialize the text groups first
            const tgs = [];
            jsonObj.partInfo.textGroups.forEach((tgSer) => {
                tgs.push(scoreText_1.SmoTextGroup.deserializePreserveId(tgSer));
            });
            jsonObj.partInfo.textGroups = tgs;
            params.partInfo = new partInfo_1.SmoPartInfo(jsonObj.partInfo);
        }
        // Up-convert legacy instrument info, which was split between different objects
        if (!jsonObj.measureInstrumentMap) {
            if (jsonObj.instrumentInfo) {
                const defs = staffModifiers_1.SmoInstrument.defaults;
                defs.keyOffset = jsonObj.instrumentInfo.keyOffset;
                defs.clef = jsonObj.instrumentInfo.clef;
                defs.instrumentName = jsonObj.instrumentInfo.instrumentName;
                const ii = new staffModifiers_1.SmoInstrument(defs);
                params.measureInstrumentMap = { 0: ii };
            }
            else {
                const ii = new staffModifiers_1.SmoInstrument(staffModifiers_1.SmoInstrument.defaults);
                params.measureInstrumentMap = { 0: ii };
            }
            params.measureInstrumentMap[0].startSelector.staff = params.staffId;
            params.measureInstrumentMap[0].endSelector.staff = params.staffId;
            params.measureInstrumentMap[0].endSelector.measure = jsonObj.measures.length - 1;
            params.measureInstrumentMap[0].keyOffset = (_b = jsonObj.measures[0].transposeIndex) !== null && _b !== void 0 ? _b : 0;
        }
        else {
            const ikeys = Object.keys(jsonObj.measureInstrumentMap);
            ikeys.forEach((ikey) => {
                const ix = parseInt(ikey, 10);
                const inst = jsonObj.measureInstrumentMap[ix];
                const defs = staffModifiers_1.SmoInstrument.defaults;
                staffModifiers_1.SmoInstrumentStringParams.forEach((str) => {
                    if (typeof (inst[str]) === 'string') {
                        defs[str] = inst[str];
                    }
                });
                staffModifiers_1.SmoInstrumentNumParams.forEach((str) => {
                    if (typeof (inst[str]) === 'number') {
                        defs[str] = inst[str];
                    }
                });
                if (typeof (inst.startSelector) !== 'undefined') {
                    defs.startSelector = inst.startSelector;
                }
                if (typeof (inst.endSelector) !== 'undefined') {
                    defs.endSelector = inst.endSelector;
                }
                params.measureInstrumentMap[ix] = new staffModifiers_1.SmoInstrument(defs);
            });
        }
        const instrumentAr = SmoSystemStaff.getStaffInstrumentArray(params.measureInstrumentMap);
        let curInstrumentIndex = 0;
        jsonObj.measures.forEach((measureObj) => {
            const measure = measure_1.SmoMeasure.deserialize(measureObj);
            if (instrumentAr.length > (curInstrumentIndex + 1) && measure.measureNumber.measureIndex >=
                instrumentAr[curInstrumentIndex + 1].measureIndex) {
                curInstrumentIndex += 1;
            }
            measure.transposeIndex = instrumentAr[curInstrumentIndex].instrument.keyOffset;
            params.measures.push(measure);
        });
        if (jsonObj.modifiers) {
            jsonObj.modifiers.forEach((modParams) => {
                const mod = staffModifiers_1.StaffModifierBase.deserialize(modParams);
                mod.associatedStaff = jsonObj.staffId;
                if (mod.ctor === 'SmoStaffTextBracket') {
                    params.textBrackets.push(mod);
                }
                else {
                    params.modifiers.push(mod);
                }
            });
        }
        const rv = new SmoSystemStaff(params);
        return rv;
    }
    /**
     * We have created a score with staff mappings.  Update the selectors in staff modifiers so that
     * 'from' in the staff slot is 'to'
     */
    mapStaffFromTo(from, to) {
        if (from === to) {
            return;
        }
        this.modifiers.forEach((mod) => {
            if (mod.startSelector.staff === from) {
                mod.startSelector.staff = to;
            }
            if (mod.endSelector.staff === from) {
                mod.endSelector.staff = to;
            }
            mod.associatedStaff = to; // this.staffId will remap to 'to' value
        });
    }
    updateMeasureFormatsForPart() {
        this.measures.forEach((measure, mix) => {
            if (this.partInfo.measureFormatting[mix]) {
                measure.format = new measureModifiers_1.SmoMeasureFormat(this.partInfo.measureFormatting[mix]);
            }
            else {
                measure.format = new measureModifiers_1.SmoMeasureFormat(measureModifiers_1.SmoMeasureFormat.defaults);
            }
        });
    }
    /**
     * Get the active instrument at the given measure
     * @param measureIndex
     * @returns
     */
    getStaffInstrument(measureIndex) {
        return SmoSystemStaff.getStaffInstrument(this.measureInstrumentMap, measureIndex);
    }
    updateInstrumentOffsets() {
        const ar = SmoSystemStaff.getStaffInstrumentArray(this.measureInstrumentMap);
        ar.forEach((entry) => {
            let i = entry.instrument.startSelector.measure;
            for (i; i <= entry.instrument.endSelector.measure && i < this.measures.length; ++i) {
                const measure = this.measures[i];
                const concertKey = music_1.SmoMusic.vexKeySigWithOffset(measure.keySignature, -1 * measure.transposeIndex);
                const targetKey = music_1.SmoMusic.vexKeySigWithOffset(concertKey, entry.instrument.keyOffset);
                measure.transposeToOffset(entry.instrument.keyOffset, targetKey, entry.instrument.clef);
                measure.transposeIndex = entry.instrument.keyOffset;
                measure.keySignature = targetKey;
                measure.setClef(entry.instrument.clef);
            }
        });
    }
    isRest(index) {
        return this.measures[index].isRest();
    }
    isRepeat(index) {
        return !(this.measures[index].getEndBarline().barline === measureModifiers_1.SmoBarline.barlines.singleBar &&
            (this.measures[index].getStartBarline().barline === measureModifiers_1.SmoBarline.barlines.singleBar ||
                this.measures[index].getStartBarline().barline === measureModifiers_1.SmoBarline.barlines.noBar));
    }
    isRehearsal(index) {
        return !(typeof (this.measures[index].getRehearsalMark()) === 'undefined');
    }
    // ### addStaffModifier
    // add a staff modifier, or replace a modifier of same type
    // with same endpoints.
    addStaffModifier(modifier) {
        this.removeStaffModifier(modifier);
        this.modifiers.push(modifier);
        modifier.associatedStaff = this.staffId;
    }
    // ### removeStaffModifier
    // Remove a modifier of given type and location
    removeStaffModifier(modifier) {
        const mods = [];
        const tbs = [];
        this.renderableModifiers.forEach((mod) => {
            if (mod.attrs.type !== modifier.attrs.type ||
                selections_1.SmoSelector.neq(mod.startSelector, modifier.startSelector) ||
                selections_1.SmoSelector.neq(mod.endSelector, modifier.endSelector)) {
                if (mod.ctor === 'SmoStaffTextBracket') {
                    tbs.push(mod);
                }
                else {
                    mods.push(mod);
                }
            }
        });
        this.textBrackets = tbs;
        this.modifiers = mods;
    }
    // ### getVoltaMap
    getVoltaMap(startIndex, endIndex) {
        const rv = [];
        this.measures.forEach((measure) => {
            measure.getNthEndings().forEach((ending) => {
                if (ending.startBar >= startIndex && ending.endBar <= endIndex) {
                    rv.push(ending);
                }
            });
        });
        return rv;
    }
    getVoltasForMeasure(ix) {
        const rv = [];
        this.measures.forEach((measure) => {
            measure.getNthEndings().forEach((ending) => {
                var _a, _b;
                if (((_a = ending.startSelector) === null || _a === void 0 ? void 0 : _a.measure) === ix || ((_b = ending.endSelector) === null || _b === void 0 ? void 0 : _b.measure) === ix) {
                    rv.push(ending);
                }
            });
        });
        return rv;
    }
    // ### getModifiersAt
    // get any modifiers at the selected location
    getModifiersAt(selector) {
        const rv = [];
        this.modifiers.forEach((mod) => {
            if (selections_1.SmoSelector.sameNote(mod.startSelector, selector)) {
                rv.push(mod);
            }
        });
        return rv;
    }
    getModifier(modData) {
        return this.getModifiers().find((mod) => selections_1.SmoSelector.eq(mod.startSelector, modData.startSelector) && mod.attrs.type === modData.attrs.type);
    }
    setLyricFont(fontInfo) {
        this.measures.forEach((measure) => {
            measure.setLyricFont(fontInfo);
        });
    }
    setLyricAdjustWidth(adjustNoteWidth) {
        this.measures.forEach((measure) => {
            measure.setLyricAdjustWidth(adjustNoteWidth);
        });
    }
    setChordFont(fontInfo) {
        this.measures.forEach((measure) => {
            measure.setChordFont(fontInfo);
        });
    }
    setChordAdjustWidth(adjustNoteWidth) {
        this.measures.forEach((measure) => {
            measure.setChordAdjustWidth(adjustNoteWidth);
        });
    }
    addTextBracket(bracketParams) {
        const nb = new staffModifiers_1.SmoStaffTextBracket(bracketParams);
        const brackets = this.textBrackets.filter((tb) => selections_1.SmoSelector.lteq(tb.startSelector, nb.startSelector)
            || selections_1.SmoSelector.gteq(tb.endSelector, nb.startSelector) || tb.position !== nb.position);
        brackets.push(new staffModifiers_1.SmoStaffTextBracket(bracketParams));
        this.textBrackets = brackets;
    }
    removeTextBracket(bracketParams) {
        const nb = new staffModifiers_1.SmoStaffTextBracket(bracketParams);
        const brackets = this.textBrackets.filter((tb) => selections_1.SmoSelector.lteq(tb.startSelector, nb.startSelector)
            || selections_1.SmoSelector.gteq(tb.endSelector, nb.startSelector) || tb.position !== nb.position);
        this.textBrackets = brackets;
    }
    getTextBracketsStartingAt(selector) {
        return this.textBrackets.filter((tb) => selections_1.SmoSelector.eq(tb.startSelector, selector));
    }
    // ### getSlursStartingAt
    // like it says.  Used by audio player to slur notes
    getSlursStartingAt(selector) {
        return this.modifiers.filter((mod) => selections_1.SmoSelector.sameNote(mod.startSelector, selector) && mod.attrs.type === 'SmoSlur');
    }
    // ### getSlursEndingAt
    // like it says.
    getSlursEndingAt(selector) {
        return this.modifiers.filter((mod) => selections_1.SmoSelector.sameNote(mod.endSelector, selector));
    }
    getTiesStartingAt(selector) {
        return this.modifiers.filter((mod) => selections_1.SmoSelector.sameNote(mod.startSelector, selector) && mod.attrs.type === 'SmoTie');
    }
    getTiesEndingAt(selector) {
        return this.modifiers.filter((mod) => selections_1.SmoSelector.sameNote(mod.endSelector, selector) && mod.attrs.type === 'SmoTie');
    }
    // ### accesor getModifiers
    getModifiers() {
        return this.modifiers;
    }
    // ### applyBeams
    // group all the measures' notes into beam groups.
    applyBeams() {
        for (let i = 0; i < this.measures.length; ++i) {
            const measure = this.measures[i];
            beamers_1.SmoBeamer.applyBeams(measure);
        }
    }
    // ### addRehearsalMark
    // for all measures in the system, and also bump the
    // auto-indexing
    addRehearsalMark(index, parameters) {
        let i = 0;
        let symbol = '';
        var mark = new measureModifiers_1.SmoRehearsalMark(parameters);
        if (!mark.increment) {
            this.measures[index].addRehearsalMark(mark);
            return;
        }
        symbol = mark.symbol;
        for (i = 0; i < this.measures.length; ++i) {
            const mm = this.measures[i];
            if (i < index) {
                const rm = mm.getRehearsalMark();
                if (rm && rm.cardinality === mark.cardinality && rm.increment) {
                    symbol = rm.getIncrement();
                    mark.symbol = symbol;
                }
            }
            if (i === index) {
                mm.addRehearsalMark(mark);
                symbol = mark.getIncrement();
            }
            if (i > index) {
                const rm = mm.getRehearsalMark();
                if (rm && rm.cardinality === mark.cardinality && rm.increment) {
                    rm.symbol = symbol;
                    symbol = rm.getIncrement();
                }
            }
        }
    }
    removeTempo(index) {
        this.measures[index].resetTempo();
    }
    addTempo(tempo, index) {
        this.measures[index].setTempo(tempo);
    }
    // ### removeRehearsalMark
    // for all measures in the system, and also decrement the
    // auto-indexing
    removeRehearsalMark(index) {
        let ix = 0;
        let symbol = null;
        let card = null;
        this.measures.forEach((measure) => {
            if (ix === index) {
                const mark = measure.getRehearsalMark();
                if (mark) {
                    symbol = mark.symbol;
                    card = mark.cardinality;
                }
                measure.removeRehearsalMark();
            }
            if (ix > index && symbol && card) {
                const mark = measure.getRehearsalMark();
                if (mark && mark.increment) {
                    mark.symbol = symbol;
                    symbol = mark.getIncrement();
                }
            }
            ix += 1;
        });
    }
    // ### deleteMeasure
    // delete the measure, and any staff modifiers that start/end there.
    deleteMeasure(index) {
        if (this.measures.length < 2) {
            return; // don't delete last measure.
        }
        const nm = [];
        this.measures.forEach((measure) => {
            if (measure.measureNumber.measureIndex !== index) {
                nm.push(measure);
            }
        });
        const sm = [];
        this.modifiers.forEach((mod) => {
            // Bug: if we are deleting a measure before the selector, change the measure number.
            if (mod.startSelector.measure !== index && mod.endSelector.measure !== index) {
                if (index < mod.startSelector.measure) {
                    mod.startSelector.measure -= 1;
                }
                if (index < mod.endSelector.measure) {
                    mod.endSelector.measure -= 1;
                }
                sm.push(mod);
            }
        });
        const instMap = {};
        SmoSystemStaff.getStaffInstrumentArray(this.measureInstrumentMap).forEach((mm) => {
            if (mm.instrument.startSelector.measure > index || mm.instrument.startSelector.measure > this.measures.length - 1) {
                mm.instrument.startSelector.measure -= 1;
            }
            if (mm.instrument.endSelector.measure > index || mm.instrument.endSelector.measure > this.measures.length - 1) {
                mm.instrument.endSelector.measure -= 1;
            }
            instMap[mm.instrument.startSelector.measure] = new staffModifiers_1.SmoInstrument(mm.instrument);
        });
        this.measures = nm;
        this.modifiers = sm;
        this.numberMeasures();
    }
    // ### addKeySignature
    // Add key signature to the given measure and update map so we know
    // when it changes, cancels etc.
    addKeySignature(measureIndex, key) {
        this.keySignatureMap[measureIndex] = key;
        const target = this.measures[measureIndex];
        target.keySignature = key;
    }
    _updateKeySignatures() {
        let i = 0;
        const currentSig = this.measures[0].keySignature;
        for (i = 0; i < this.measures.length; ++i) {
            const measure = this.measures[i];
            const nextSig = this.keySignatureMap[i] ? this.keySignatureMap[i] : currentSig;
            measure.setKeySignature(nextSig);
        }
    }
    // ### numberMeasures
    // After anything that might change the measure numbers, update them iteratively
    numberMeasures() {
        let i = 0;
        let renumberIndex = 0;
        for (i = 0; i < this.measures.length; ++i) {
            const measure = this.measures[i];
            renumberIndex = typeof (this.renumberingMap[i]) === 'undefined' ? 0 : this.renumberingMap[i];
            const localIndex = renumberIndex + i;
            // If this is the first full measure, call it '1'
            const numberObj = {
                localIndex,
                measureIndex: i,
                systemIndex: i,
                staffId: this.staffId
            };
            measure.setMeasureNumber(numberObj);
        }
    }
    addDefaultMeasure(index, params) {
        const measure = measure_1.SmoMeasure.getDefaultMeasure(params);
        this.addMeasure(index, measure);
    }
    // ## addMeasure
    // ## Description:
    // Add the measure at the specified index, splicing the array as required.
    addMeasure(index, measure) {
        if (index === 0 && this.measures.length) {
            measure.setMeasureNumber(this.measures[0].measureNumber);
        }
        if (index >= this.measures.length) {
            this.measures.push(measure);
        }
        else {
            this.measures.splice(index, 0, measure);
        }
        const modifiers = this.modifiers.filter((mod) => mod.startSelector.measure >= index);
        modifiers.forEach((mod) => {
            if (mod.startSelector.measure < this.measures.length) {
                mod.startSelector.measure += 1;
            }
            if (mod.endSelector.measure < this.measures.length) {
                mod.endSelector.measure += 1;
            }
        });
        this.numberMeasures();
    }
}
exports.SmoSystemStaff = SmoSystemStaff;


/***/ }),

/***/ "./src/smo/data/tuplet.ts":
/*!********************************!*\
  !*** ./src/smo/data/tuplet.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SmoTuplet = void 0;
// [Smoosic](https://github.com/AaronDavidNewman/Smoosic)
// Copyright (c) Aaron David Newman 2021.
/**
 * Classes to support {@link SmoTuplet}
 * @module /smo/data/tuplet
 */
const serializationHelpers_1 = __webpack_require__(/*! ../../common/serializationHelpers */ "./src/common/serializationHelpers.js");
const note_1 = __webpack_require__(/*! ./note */ "./src/smo/data/note.ts");
const music_1 = __webpack_require__(/*! ./music */ "./src/smo/data/music.ts");
const noteModifiers_1 = __webpack_require__(/*! ./noteModifiers */ "./src/smo/data/noteModifiers.ts");
const VF = eval('Vex.Flow');
/**
 * A tuplet is a container for notes within a measure
 * @category SmoObject
 */
class SmoTuplet {
    constructor(params) {
        this.numNotes = 3;
        this.stemTicks = 2048;
        this.totalTicks = 4096;
        this.durationMap = [1.0, 1.0, 1.0];
        this.bracketed = true;
        this.voice = 0;
        this.ratioed = false;
        this.startIndex = 0;
        Vex.Merge(this, SmoTuplet.defaults);
        serializationHelpers_1.smoSerialize.serializedMerge(SmoTuplet.parameterArray, params, this);
        this.notes = params.notes;
        this.attrs = {
            id: VF.Element.newID(),
            type: 'SmoTuplet'
        };
        this._adjustTicks();
    }
    static get defaults() {
        return JSON.parse(JSON.stringify({
            notes: [],
            numNotes: 3,
            stemTicks: 2048,
            totalTicks: 4096,
            durationMap: [1.0, 1.0, 1.0],
            bracketed: true,
            voice: 0,
            ratioed: false,
            startIndex: 0
        }));
    }
    get clonedParams() {
        const paramAr = ['stemTicks', 'ticks', 'totalTicks', 'durationMap'];
        const rv = {};
        serializationHelpers_1.smoSerialize.serializedMerge(paramAr, this, rv);
        return rv;
    }
    static get parameterArray() {
        return ['stemTicks', 'ticks', 'totalTicks',
            'durationMap', 'attrs', 'ratioed', 'bracketed', 'voice', 'startIndex'];
    }
    serialize() {
        const params = {};
        serializationHelpers_1.smoSerialize.serializedMergeNonDefault(SmoTuplet.defaults, SmoTuplet.parameterArray, this, params);
        return params;
    }
    static calculateStemTicks(totalTicks, numNotes) {
        const stemValue = totalTicks / numNotes;
        let stemTicks = SmoTuplet.longestTuplet;
        // The stem value is the type on the non-tuplet note, e.g. 1/8 note
        // for a triplet.
        while (stemValue < stemTicks) {
            stemTicks = stemTicks / 2;
        }
        return stemTicks * 2;
    }
    static get longestTuplet() {
        return 8192;
    }
    static cloneTuplet(tuplet) {
        let i = 0;
        const noteAr = tuplet.notes;
        const durationMap = JSON.parse(JSON.stringify(tuplet.durationMap)); // deep copy array
        // Add any remainders for oddlets
        const totalTicks = noteAr.map((nn) => nn.ticks.numerator + nn.ticks.remainder)
            .reduce((acc, nn) => acc + nn);
        const numNotes = tuplet.numNotes;
        const stemTicks = SmoTuplet.calculateStemTicks(totalTicks, numNotes);
        const tupletNotes = [];
        noteAr.forEach((note) => {
            const textModifiers = note.textModifiers;
            // Note preserver remainder
            note = note_1.SmoNote.cloneWithDuration(note, {
                numerator: stemTicks * tuplet.durationMap[i],
                denominator: 1,
                remainder: note.ticks.remainder
            });
            // Don't clone modifiers, except for first one.
            if (i === 0) {
                const ntmAr = [];
                textModifiers.forEach((tm) => {
                    const ntm = noteModifiers_1.SmoNoteModifierBase.deserialize(tm);
                    ntmAr.push(ntm);
                });
                note.textModifiers = ntmAr;
            }
            i += 1;
            tupletNotes.push(note);
        });
        const rv = new SmoTuplet({
            numNotes: tuplet.numNotes,
            voice: tuplet.voice,
            notes: tupletNotes,
            stemTicks,
            totalTicks,
            ratioed: false,
            bracketed: true,
            startIndex: tuplet.startIndex,
            durationMap
        });
        return rv;
    }
    _adjustTicks() {
        let i = 0;
        const sum = this.durationSum;
        for (i = 0; i < this.notes.length; ++i) {
            const note = this.notes[i];
            // TODO:  notes_occupied needs to consider vex duration
            note.ticks.denominator = 1;
            note.ticks.numerator = Math.floor((this.totalTicks * this.durationMap[i]) / sum);
            note.tuplet = this.attrs;
        }
        // put all the remainder in the first note of the tuplet
        const noteTicks = this.notes.map((nn) => nn.tickCount)
            .reduce((acc, dd) => acc + dd);
        // bug fix:  if this is a clones tuplet, remainder is already set
        this.notes[0].ticks.remainder =
            this.notes[0].ticks.remainder + this.totalTicks - noteTicks;
    }
    getIndexOfNote(note) {
        let rv = -1;
        let i = 0;
        if (!note) {
            return -1;
        }
        for (i = 0; i < this.notes.length; ++i) {
            const tn = this.notes[i];
            if (note.attrs.id === tn.attrs.id) {
                rv = i;
            }
        }
        return rv;
    }
    split(combineIndex) {
        let i = 0;
        const multiplier = 0.5;
        const nnotes = [];
        const nmap = [];
        for (i = 0; i < this.notes.length; ++i) {
            const note = this.notes[i];
            if (i === combineIndex) {
                nmap.push(this.durationMap[i] * multiplier);
                nmap.push(this.durationMap[i] * multiplier);
                note.ticks.numerator *= multiplier;
                const onote = note_1.SmoNote.clone(note);
                // remainder is for the whole tuplet, so don't duplicate that.
                onote.ticks.remainder = 0;
                nnotes.push(note);
                nnotes.push(onote);
            }
            else {
                nmap.push(this.durationMap[i]);
                nnotes.push(note);
            }
        }
        this.notes = nnotes;
        this.durationMap = nmap;
    }
    combine(startIndex, endIndex) {
        let i = 0;
        let base = 0.0;
        let acc = 0.0;
        // can't combine in this way, too many notes
        if (this.notes.length <= endIndex || startIndex >= endIndex) {
            return this;
        }
        for (i = startIndex; i <= endIndex; ++i) {
            acc += this.durationMap[i];
            if (i === startIndex) {
                base = this.durationMap[i];
            }
            else if (this.durationMap[i] !== base) {
                // Can't combine non-equal tuplet notes
                return this;
            }
        }
        // how much each combined value will be multiplied by
        const multiplier = acc / base;
        const nmap = [];
        const nnotes = [];
        // adjust the duration map
        for (i = 0; i < this.notes.length; ++i) {
            const note = this.notes[i];
            // notes that don't change are unchanged
            if (i < startIndex || i > endIndex) {
                nmap.push(this.durationMap[i]);
                nnotes.push(note);
            }
            // changed note with combined duration
            if (i === startIndex) {
                note.ticks.numerator = note.ticks.numerator * multiplier;
                nmap.push(acc);
                nnotes.push(note);
            }
            // other notes after startIndex are removed from the map.
        }
        this.notes = nnotes;
        this.durationMap = nmap;
        return this;
    }
    // ### getStemDirection
    // Return the stem direction, so we can bracket the correct place
    getStemDirection(clef) {
        const note = this.notes.find((nn) => nn.noteType === 'n');
        if (!note) {
            return note_1.SmoNote.flagStates.down;
        }
        if (note.flagState !== note_1.SmoNote.flagStates.auto) {
            return note.flagState;
        }
        return music_1.SmoMusic.pitchToLedgerLine(clef, note.pitches[0])
            >= 2 ? note_1.SmoNote.flagStates.up : note_1.SmoNote.flagStates.down;
    }
    get durationSum() {
        let acc = 0;
        let i = 0;
        for (i = 0; i < this.durationMap.length; ++i) {
            acc += this.durationMap[i];
        }
        return Math.round(acc);
    }
    get num_notes() {
        return this.durationSum;
    }
    get notes_occupied() {
        return Math.floor(this.totalTicks / this.stemTicks);
    }
    get note_ticks_occupied() {
        return this.totalTicks / this.stemTicks;
    }
    get tickCount() {
        let rv = 0;
        let i = 0;
        for (i = 0; i < this.notes.length; ++i) {
            const note = this.notes[i];
            rv += (note.ticks.numerator / note.ticks.denominator) + note.ticks.remainder;
        }
        return rv;
    }
}
exports.SmoTuplet = SmoTuplet;


/***/ }),

/***/ "./src/smo/midi/midiToSmo.ts":
/*!***********************************!*\
  !*** ./src/smo/midi/midiToSmo.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MidiToSmo = void 0;
const measure_1 = __webpack_require__(/*! ../data/measure */ "./src/smo/data/measure.ts");
const measureModifiers_1 = __webpack_require__(/*! ../data/measureModifiers */ "./src/smo/data/measureModifiers.ts");
const music_1 = __webpack_require__(/*! ../data/music */ "./src/smo/data/music.ts");
const note_1 = __webpack_require__(/*! ../data/note */ "./src/smo/data/note.ts");
const score_1 = __webpack_require__(/*! ../data/score */ "./src/smo/data/score.ts");
const staffModifiers_1 = __webpack_require__(/*! ../data/staffModifiers */ "./src/smo/data/staffModifiers.ts");
const systemStaff_1 = __webpack_require__(/*! ../data/systemStaff */ "./src/smo/data/systemStaff.ts");
const tuplet_1 = __webpack_require__(/*! ../data/tuplet */ "./src/smo/data/tuplet.ts");
function getValueForTick(arg, tick) {
    const keys = Object.keys(arg);
    let maxKey = 0;
    let rv = arg[0];
    keys.forEach((key) => {
        const keyInt = parseInt(key, 10);
        if (keyInt <= tick && keyInt > maxKey && arg[keyInt]) {
            rv = arg[maxKey];
            maxKey = keyInt;
        }
    });
    return rv;
}
/**
 * Converts a JSON midi file to a {@link SmoScore}
 * @category SmoToMidi
 */
class MidiToSmo {
    /**
     * Create an object to convert MIDI to a {@link SmoScore}
     * @param midi the output of midi parser
     * @param quantizeDuration ticks to quantize (1024 == 16th note)
     */
    constructor(midi, quantizeDuration) {
        this.timeSignatureMap = {};
        this.tempoMap = {};
        this.keySignatureMap = {};
        this.tieMap = {};
        this.timeDivision = 480;
        this.trackIndex = 0;
        this.eventIndex = 0; // index into current track
        this.maxMeasure = 0;
        this.quantizeTicks = MidiToSmo.quantizeTicksDefault;
        this.eot = false;
        this.midiOnNotes = {};
        this.midi = midi;
        // console.log(JSON.stringify(midi, null, ''));
        this.timeSignatureMap[0] = new measureModifiers_1.TimeSignature(measureModifiers_1.TimeSignature.defaults);
        this.tempoMap[0] = new measureModifiers_1.SmoTempoText(measureModifiers_1.SmoTempoText.defaults);
        this.keySignatureMap[0] = 'c';
        this.timeDivision = midi.header.ticksPerBeat;
        this.quantizeTicks = quantizeDuration;
    }
    static get quantizeTicksDefault() {
        return 1024;
    }
    /**
     * Since midi has very little metadata, we don't know the original clef.
     * so just use the one (treble or bass) that uses the fewest ledger lines
     * @internal
     * @param notes notes in measure
     * @returns
     */
    static guessClefForNotes(measure) {
        let trebleMax = 0;
        let bassMax = 0;
        measure.voices[0].notes.forEach((note) => {
            note.pitches.forEach((pitch) => {
                const tl = Math.abs(music_1.SmoMusic.pitchToLedgerLine('treble', pitch));
                const bl = Math.abs(music_1.SmoMusic.pitchToLedgerLine('bass', pitch));
                trebleMax = Math.max(trebleMax, tl);
                bassMax = Math.max(bassMax, bl);
            });
        });
        const clef = trebleMax <= bassMax ? 'treble' : 'bass';
        measure.clef = clef;
        // For rests, make sure the rest is centered in the clef
        measure.voices[0].notes.forEach((note) => {
            if (note.noteType === 'r') {
                note.pitches = [measure_1.SmoMeasure.defaultPitchForClef[clef]];
            }
            note.clef = clef;
        });
        return clef;
    }
    /**
     * @internal
     * @param ticks
     * @returns
     */
    getTempo(ticks) {
        if (this.tempoMap[ticks]) {
            return this.tempoMap[ticks];
        }
        return getValueForTick(this.tempoMap, ticks);
    }
    /**
     * @internal
     * @param ticks
     * @returns
     */
    getTimeSignature(ticks) {
        if (this.timeSignatureMap[ticks]) {
            return this.timeSignatureMap[ticks];
        }
        return getValueForTick(this.timeSignatureMap, ticks);
    }
    /**
     * @internal
     * @param ticks
     * @returns
     */
    getKeySignature(ticks) {
        if (this.keySignatureMap[ticks]) {
            return this.keySignatureMap[ticks];
        }
        return getValueForTick(this.keySignatureMap, ticks);
    }
    /**
     * Get metadata from the map for this point in the score
     * @param ticks current point in track
     * @returns
     */
    getMetadata(ticks) {
        return { tempo: this.getTempo(ticks), timeSignature: this.getTimeSignature(ticks), keySignature: this.getKeySignature(ticks) };
    }
    /**
     * We process 3 types of metadata at present:  time signature, tempo and keysignature.
     * @param trackEvent
     * @param ticks
     */
    handleMetadata(trackEvent, ticks) {
        if (trackEvent.meta) {
            const mtype = trackEvent.type;
            if (mtype === 'timeSignature') {
                /**
                 * whenever we get a time signature event, recompute ticks per measure
                 */
                const numerator = trackEvent.numerator;
                const denominator = trackEvent.denominator;
                const tsDef = measureModifiers_1.TimeSignature.defaults;
                tsDef.actualBeats = numerator;
                tsDef.beatDuration = denominator;
                const ts = new measureModifiers_1.TimeSignature(tsDef);
                this.timeSignatureMap[ticks] = ts;
            }
            else if (mtype === 'setTempo') {
                const bpm = 60 / (trackEvent.microsecondsPerBeat / 1000000);
                const tempoDef = measureModifiers_1.SmoTempoText.defaults;
                tempoDef.bpm = bpm;
                this.tempoMap[ticks] = new measureModifiers_1.SmoTempoText(tempoDef);
            }
            else if (mtype === 'keySignature') {
                const mdata = trackEvent.key;
                if (mdata === 0) {
                    this.keySignatureMap[ticks] = 'C';
                }
                else {
                    // there seem to be different ways to encode this...
                    let signed = mdata / 256;
                    if (signed > 7) {
                        signed = -1 * (256 - signed);
                    }
                    if (Math.abs(mdata) < 256) {
                        signed = mdata;
                    }
                    this.keySignatureMap[ticks] = music_1.SmoMusic.midiKeyToVexKey(signed);
                }
            }
        }
    }
    /**
     * Convert from Midi PPQ to Smoosic (and vex) ticks
     * @internal
     */
    getSmoTicks(midiTicks) {
        return 4096 * midiTicks / this.timeDivision;
    }
    /**
     * @internal
     */
    createNewEvent(metadata) {
        return {
            pitches: [], durationTicks: 0, tupletInfo: null, isRest: false, timeSignature: new measureModifiers_1.TimeSignature(metadata.timeSignature),
            tempo: new measureModifiers_1.SmoTempoText(metadata.tempo), keySignature: metadata.keySignature, measure: 0, tick: 0, isTied: false
        };
    }
    /**
     * @internal
     */
    static copyEvent(o) {
        const pitches = JSON.parse(JSON.stringify(o.pitches));
        const timeSignature = new measureModifiers_1.TimeSignature(o.timeSignature);
        const tempo = new measureModifiers_1.SmoTempoText(o.tempo);
        return ({
            pitches, durationTicks: o.durationTicks, tupletInfo: o.tupletInfo, isRest: o.isRest, timeSignature, tempo, keySignature: o.keySignature,
            measure: o.measure, tick: o.tick, isTied: o.isTied
        });
    }
    /**
     * @internal
     */
    addToTieMap(measureIndex) {
        const staffIx = this.trackIndex;
        if (typeof (this.tieMap[staffIx]) === 'undefined') {
            this.tieMap[staffIx] = [];
        }
        this.tieMap[staffIx].push(measureIndex);
    }
    /**
     * Step 3 in the 3-step process.  Quantize the note durations and convert the midi
     * event into SmoNotes.
     * @param events
     * @returns
     */
    createNotesFromEvents(events) {
        let measureIndex = 0;
        const measures = [];
        let measure = null;
        let deficit = 0;
        // If the midi event is smaller than the smallest note..
        const smallest = 1 * (this.quantizeTicks / 4);
        events.forEach((ev) => {
            if (measure === null || ev.measure > measureIndex) {
                const measureDefs = measure_1.SmoMeasure.defaults;
                measureDefs.keySignature = ev.keySignature;
                measureDefs.timeSignature = new measureModifiers_1.TimeSignature(ev.timeSignature);
                measureDefs.tempo = new measureModifiers_1.SmoTempoText(ev.tempo);
                measure = new measure_1.SmoMeasure(measureDefs);
                measure.voices.push({ notes: [] });
                measureIndex = ev.measure;
                measures.push(measure);
            }
            if (Math.abs(ev.durationTicks - deficit) < smallest && !(ev.tupletInfo !== null)) {
                deficit = deficit - ev.durationTicks;
            }
            else {
                const best = music_1.SmoMusic.midiTickSearch(ev.durationTicks - deficit, this.quantizeTicks);
                deficit += best.result - ev.durationTicks;
                ev.durationTicks = best.result;
                const defs = note_1.SmoNote.defaults;
                defs.ticks.numerator = ev.durationTicks;
                defs.pitches = JSON.parse(JSON.stringify(ev.pitches));
                defs.noteType = ev.isRest ? 'r' : 'n';
                const note = new note_1.SmoNote(defs);
                note_1.SmoNote.sortPitches(note);
                measure.voices[0].notes.push(note);
                if (ev.tupletInfo !== null && ev.tupletInfo.isLast === true) {
                    const voiceLen = measure.voices[0].notes.length;
                    const tupletNotes = [note, measure.voices[0].notes[voiceLen - 2], measure.voices[0].notes[voiceLen - 3]];
                    const defs = tuplet_1.SmoTuplet.defaults;
                    defs.notes = tupletNotes;
                    defs.stemTicks = ev.tupletInfo.stemTicks;
                    defs.numNotes = ev.tupletInfo.numNotes;
                    defs.totalTicks = ev.tupletInfo.totalTicks;
                    defs.startIndex = voiceLen - 3;
                    measure.tuplets.push(new tuplet_1.SmoTuplet(defs));
                }
                if (ev.isTied) {
                    this.addToTieMap(measureIndex);
                }
            }
        });
        measures.forEach((measure) => {
            measure.clef = MidiToSmo.guessClefForNotes(measure);
        });
        return measures;
    }
    /**
     * @param ticks
     * @returns the length in ticks of a triplet, if this looks like a triplet.  Otherwise 0
     */
    tripletType(ticks) {
        const tripletBeat = Math.round(4096 / 3);
        const tripletHalf = Math.round((4096 * 2) / 3);
        const tripletEighth = Math.round((4096 / 2) / 3);
        const beatTrip = tripletBeat / ticks;
        const eigthTrip = tripletEighth / ticks;
        const halfTrip = tripletHalf / ticks;
        if (Math.abs(1 - beatTrip) < 0.05) {
            return 4096;
        }
        if (Math.abs(1 - eigthTrip) < 0.05) {
            return 2048;
        }
        if (Math.abs(1 - halfTrip) < 0.05) {
            return 4096 * 2;
        }
        return 0;
    }
    /**
     * step 2 in the 3 step process.  Divide the music up into measures based on
     * tick duration.  If there are events overlapping measures, create extra events in the
     * new measure (hence the expand) and shorten the original event
     * @param events
     * @returns
     */
    expandMidiEvents(events) {
        const rv = [];
        if (events.length === 0) {
            return rv;
        }
        let i = 0;
        let ticksSoFar = 0;
        let measure = 0;
        let tick = 0;
        let tripletCount = 0;
        let tripletValue = 0;
        for (i = 0; i < events.length; ++i) {
            const ev = events[i];
            // If it's too small, continue.  Don't record the event but do count the ticks
            if (ev.durationTicks < 128) {
                ticksSoFar += ev.durationTicks;
                continue;
            }
            const ticksPerMeasure = music_1.SmoMusic.timeSignatureToTicks(ev.timeSignature.timeSignature);
            const nevent = MidiToSmo.copyEvent(ev);
            if (ticksSoFar + ev.durationTicks > ticksPerMeasure) {
                nevent.durationTicks = ticksPerMeasure - ticksSoFar;
                if (nevent.durationTicks > 0) {
                    rv.push(nevent);
                    nevent.tick = tick;
                }
                tick = 0;
                tripletCount = 0;
                tripletValue = 0;
                measure += 1;
                ticksSoFar = 0;
                this.maxMeasure = Math.max(this.maxMeasure, measure);
                let overflow = ev.durationTicks - nevent.durationTicks;
                while (overflow > ticksPerMeasure) {
                    const ovfEvent = MidiToSmo.copyEvent(nevent);
                    ovfEvent.tick = tick;
                    ovfEvent.measure = measure;
                    tick += 1;
                    measure += 1;
                    ovfEvent.durationTicks = ticksPerMeasure;
                    rv.push(ovfEvent);
                    overflow -= ticksPerMeasure;
                }
                if (overflow > 0) {
                    const ovfEvent = MidiToSmo.copyEvent(nevent);
                    ovfEvent.isTied = true;
                    ovfEvent.durationTicks = overflow;
                    ovfEvent.measure = measure;
                    ovfEvent.tick = tick;
                    ticksSoFar += ovfEvent.durationTicks;
                    tick += 1;
                    rv.push(ovfEvent);
                    overflow = 0;
                }
            }
            else {
                ticksSoFar += ev.durationTicks;
                // Try to infer the presence of triplets.  If it looks like a triplet, mark it and we will
                // create the tuplet when we create the measure.
                const possibleTriplet = this.tripletType(nevent.durationTicks);
                if (possibleTriplet > 0 && (tripletValue === 0 || possibleTriplet === tripletValue)) {
                    tripletCount += 1;
                    tripletValue = possibleTriplet;
                    if (tripletCount === 3) {
                        nevent.tupletInfo = {
                            numNotes: 3,
                            stemTicks: possibleTriplet / 2,
                            totalTicks: possibleTriplet,
                            isLast: true
                        };
                        rv[rv.length - 1].tupletInfo = {
                            numNotes: 3,
                            stemTicks: possibleTriplet / 2,
                            totalTicks: possibleTriplet,
                            isLast: false
                        };
                        rv[rv.length - 2].tupletInfo = {
                            numNotes: 3,
                            stemTicks: possibleTriplet / 2,
                            totalTicks: possibleTriplet,
                            isLast: false
                        };
                        tripletCount = 0;
                        tripletValue = 0;
                    }
                }
                else {
                    tripletCount = 0;
                    tripletValue = 0;
                }
                rv.push(nevent);
            }
        }
        return rv;
    }
    /**
     * Store midi on events.  If the midi on or off matches an existing
     * stored event based on channel and note, return it so it can be processed
     * @param ev raw event
     * @param evIndex index of processed events
     * @returns
     */
    pushPopMidiEvent(ev, evIndex) {
        let rv = null;
        if (!ev.noteNumber || typeof (ev.channel) === 'undefined') {
            return null;
        }
        if (this.midiOnNotes[ev.noteNumber]) {
            const ix = this.midiOnNotes[ev.noteNumber].findIndex((x) => x.channel === ev.channel);
            if (ix >= 0) {
                rv = JSON.parse(JSON.stringify(this.midiOnNotes[ev.noteNumber][ix]));
                this.midiOnNotes[ev.noteNumber].splice(ix);
            }
        }
        if (!this.midiOnNotes[ev.noteNumber]) {
            this.midiOnNotes[ev.noteNumber] = [];
        }
        if (ev.type === 'noteOn' && ev.velocity && ev.velocity > 0) {
            this.midiOnNotes[ev.noteNumber].push({
                note: ev.noteNumber,
                channel: ev.channel,
                smoIndex: evIndex
            });
        }
        return rv;
    }
    /**
     * Step 1 in the 3-step process.  Collapse midi events into
     * a single EventSmoData for each distinct tick that contains
     * the metadata state, a duration, and note information.
     * @param trackEvents
     * @returns
     */
    collapseMidiEvents(trackEvents) {
        const isEot = (ev) => {
            if (!ev) {
                return true;
            }
            if (typeof (ev.type) === 'undefined') {
                return true;
            }
            return ev.type === 'endOfTrack';
        };
        if (this.eventIndex >= trackEvents.length) {
            this.eot = true;
            return [];
        }
        const rv = [];
        let cur = trackEvents[0];
        let metadata = this.getMetadata(0);
        let curSmo = this.createNewEvent(metadata);
        let untrackedTicks = 0;
        let ticks = 0;
        while (this.eventIndex < trackEvents.length && !(this.eot)) {
            if (isEot(cur)) {
                this.eot = true;
                break;
            }
            if (cur.deltaTime > 0) {
                curSmo.durationTicks = this.getSmoTicks(cur.deltaTime);
                ticks += curSmo.durationTicks;
                // We only need to track note on/off events.  Other events update the global
                // map, we need to keep track of the duration changes though.
                if (cur.type === 'noteOn' || cur.type === 'noteOff') {
                    if (curSmo.pitches.length === 0) {
                        curSmo.isRest = true;
                    }
                    curSmo.durationTicks += untrackedTicks;
                    untrackedTicks = 0;
                    rv.push(curSmo);
                }
                else {
                    untrackedTicks += curSmo.durationTicks;
                }
                curSmo = this.createNewEvent(metadata);
            }
            curSmo.timeSignature = metadata.timeSignature;
            curSmo.tempo = metadata.tempo;
            curSmo.keySignature = metadata.keySignature;
            if (cur.type === 'noteOn' || cur.type === 'noteOff') {
                const mm = this.pushPopMidiEvent(cur, rv.length);
                if (mm) {
                    const npitch = music_1.SmoMusic.getEnharmonicInKey(music_1.SmoMusic.smoIntToPitch(mm.note - 12), metadata.keySignature);
                    if (mm.smoIndex < rv.length) {
                        rv[mm.smoIndex].pitches.push(npitch);
                        rv[mm.smoIndex].isRest = false;
                    }
                    else {
                        console.warn('bad index in event mm.smoIndex');
                    }
                }
            }
            else if (cur.meta) {
                this.handleMetadata(cur, ticks);
            }
            metadata = this.getMetadata(ticks);
            this.eventIndex += 1;
            cur = trackEvents[this.eventIndex];
            if (isEot(cur)) {
                this.eot = true;
                break;
            }
        }
        return rv;
    }
    getTrackData(midi) {
        if (midi.header.format !== 0) {
            return midi.tracks;
        }
        const trackData = [];
        const trackHash = {};
        const trackEvents = midi.tracks[0];
        trackEvents.forEach((ev) => {
            var _a;
            const channel = (_a = ev.channel) !== null && _a !== void 0 ? _a : 0;
            if (!trackHash[channel]) {
                trackHash[channel] = [];
            }
            trackHash[channel].push(ev);
        });
        const trackKeys = Object.keys(trackHash);
        trackKeys.forEach((trackKey) => {
            trackData.push(trackHash[trackKey]);
        });
        return trackData;
    }
    /**
     * Convert the midi to a score as best we can.  The conversion is made via a 3-step
     * process.
     * 1. consolidate all the MIDI events into individual note on/off events with a duration
     * 2. adjust the durations so the fit in with Smoosic measure lengths.
     * 3. Create the {@link SmoNote} objects from the events.
     * @returns
     */
    convert() {
        let staves = [];
        // go through the tracks.  If this is midi format 1, split tracks into their own channels
        const tracks = this.getTrackData(this.midi);
        tracks.forEach((trackEvents, trackIx) => {
            this.eventIndex = 0; // index into current track
            this.trackIndex = trackIx;
            this.eot = false;
            this.tieMap[trackIx] = [];
            const collapsed = this.collapseMidiEvents(trackEvents);
            const expanded = this.expandMidiEvents(collapsed);
            if (expanded.length > 0) {
                const staffDef = systemStaff_1.SmoSystemStaff.defaults;
                staffDef.staffId = trackIx;
                staffDef.measures = this.createNotesFromEvents(expanded);
                const staff = new systemStaff_1.SmoSystemStaff(staffDef);
                // For notes that are tied across measures, add the tie
                this.tieMap[trackIx].forEach((mm) => {
                    const startMeasure = staffDef.measures[mm - 1];
                    const endMeasure = staffDef.measures[mm];
                    const endIx = startMeasure.voices[0].notes.length - 1;
                    const startNote = startMeasure.voices[0].notes[endIx];
                    const endNote = endMeasure.voices[0].notes[0];
                    if (startNote.noteType === 'n' &&
                        endNote.noteType === 'n' && music_1.SmoMusic.pitchArraysMatch(startNote.pitches, endNote.pitches)) {
                        const tieDefs = staffModifiers_1.SmoTie.defaults;
                        tieDefs.startSelector = {
                            staff: trackIx, measure: mm - 1, voice: 0, tick: endIx,
                            pitches: []
                        };
                        tieDefs.endSelector = {
                            staff: trackIx, measure: mm, voice: 0, tick: 0,
                            pitches: []
                        };
                        tieDefs.lines.push({ from: 0, to: 0 });
                        const tie = new staffModifiers_1.SmoTie(tieDefs);
                        staff.modifiers.push(tie);
                    }
                });
                staves.push(staff);
            }
        });
        if (staves.length === 0) {
            return score_1.SmoScore.getEmptyScore(score_1.SmoScore.defaults);
        }
        let longestStave = staves[0];
        staves.forEach((staff) => {
            if (staff.measures.length > longestStave.measures.length) {
                longestStave = staff;
            }
        });
        staves.forEach((staff) => {
            let i = 0;
            for (i = staff.measures.length; i < longestStave.measures.length; ++i) {
                const measure = measure_1.SmoMeasure.getDefaultMeasure(longestStave.measures[i]);
                measure.voices.push({ notes: measure_1.SmoMeasure.getDefaultNotes(longestStave.measures[i]) });
                staff.measures.push(measure);
            }
        });
        const scoreDefs = score_1.SmoScore.defaults;
        scoreDefs.staves = staves;
        const rv = new score_1.SmoScore(scoreDefs);
        const layoutDefaults = rv.layoutManager;
        // if no scale given in score, default to something small.
        layoutDefaults.globalLayout.svgScale = 0.65;
        layoutDefaults.globalLayout.zoomScale = 1.5;
        return rv;
    }
}
exports.MidiToSmo = MidiToSmo;


/***/ }),

/***/ "./src/smo/midi/smoToMidi.ts":
/*!***********************************!*\
  !*** ./src/smo/midi/smoToMidi.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SmoToMidi = void 0;
// [Smoosic](https://github.com/AaronDavidNewman/Smoosic)
// Copyright (c) Aaron David Newman 2021.
/**
 * Support for converting Smo object model to MIDI
 * @module /smo/midi/smoToMidi
 */
const music_1 = __webpack_require__(/*! ../data/music */ "./src/smo/data/music.ts");
const selections_1 = __webpack_require__(/*! ../xform/selections */ "./src/smo/xform/selections.ts");
const audioTrack_1 = __webpack_require__(/*! ../xform/audioTrack */ "./src/smo/xform/audioTrack.ts");
/**
 * Convert a {@link SmoScore} object to MIDI
 * @category SmoToMidi
 */
class SmoToMidi {
    /**
     * @param score
     * @returns Midi byte array that can be sent to a file upload widget
     */
    static convert(score) {
        const beatTime = 128; // midi ticks per beat
        const converter = new audioTrack_1.SmoAudioScore(score, beatTime);
        const audioScore = converter.convert();
        const smoTracks = audioScore.tracks;
        let currentKey = 'C';
        const trackHash = {};
        smoTracks.forEach((smoTrack, trackIx) => {
            let j = 0;
            if (typeof (trackHash[trackIx]) === 'undefined') {
                trackHash[trackIx] = {
                    track: new MidiWriter.Track(),
                    lastMeasure: 0
                };
            }
            const track = trackHash[trackIx].track;
            // eslint-disable-next-line
            audioScore.repeatMap.forEach((measureMap) => {
                for (j = measureMap.startMeasure; j <= measureMap.endMeasure; ++j) {
                    // eslint-disable-next-line
                    const notes = smoTrack.notes.filter((nn) => nn.selector.measure === j);
                    notes.forEach((noteData) => {
                        const selectorKey = selections_1.SmoSelector.getMeasureKey(noteData.selector);
                        if (smoTrack.tempoMap[selectorKey]) {
                            track.setTempo(smoTrack.tempoMap[selectorKey]);
                        }
                        if (smoTrack.timeSignatureMap[selectorKey]) {
                            const ts = smoTrack.timeSignatureMap[selectorKey];
                            track.setTimeSignature(ts.numerator, ts.denominator);
                        }
                        if (smoTrack.keyMap[j]) {
                            const ksString = smoTrack.keyMap[j];
                            const ks = -1 * music_1.SmoMusic.getFlatsInKeySignature(ksString) + music_1.SmoMusic.getSharpsInKeySignature(ksString);
                            track.setKeySignature(ks, 0);
                        }
                        if (noteData.noteType === 'r') {
                            if (!noteData.padding) {
                                const rest = new MidiWriter.NoteOffEvent({
                                    channel: trackIx + 1,
                                    pitch: 'C4',
                                    duration: 't' + noteData.duration
                                });
                                track.addEvent(rest);
                            }
                        }
                        else {
                            const pitchArray = music_1.SmoMusic.smoPitchesToMidiStrings(noteData.pitches);
                            const velocity = Math.round(127 * noteData.volume);
                            const midiNote = new MidiWriter.NoteEvent({
                                channel: trackIx + 1,
                                pitch: pitchArray,
                                duration: 't' + noteData.duration,
                                velocity
                            });
                            track.addEvent(midiNote);
                        }
                    });
                }
            });
        });
        const tracks = Object.keys(trackHash).map((key) => trackHash[key].track);
        const writer = new MidiWriter.Writer(tracks);
        return writer.buildFile();
    }
}
exports.SmoToMidi = SmoToMidi;


/***/ }),

/***/ "./src/smo/mxml/smoToXml.ts":
/*!**********************************!*\
  !*** ./src/smo/mxml/smoToXml.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SmoToXml = void 0;
const note_1 = __webpack_require__(/*! ../data/note */ "./src/smo/data/note.ts");
const music_1 = __webpack_require__(/*! ../data/music */ "./src/smo/data/music.ts");
const score_1 = __webpack_require__(/*! ../data/score */ "./src/smo/data/score.ts");
const measureModifiers_1 = __webpack_require__(/*! ../data/measureModifiers */ "./src/smo/data/measureModifiers.ts");
const staffModifiers_1 = __webpack_require__(/*! ../data/staffModifiers */ "./src/smo/data/staffModifiers.ts");
const noteModifiers_1 = __webpack_require__(/*! ../data/noteModifiers */ "./src/smo/data/noteModifiers.ts");
const selections_1 = __webpack_require__(/*! ../xform/selections */ "./src/smo/xform/selections.ts");
const xmlHelpers_1 = __webpack_require__(/*! ./xmlHelpers */ "./src/smo/mxml/xmlHelpers.ts");
const measureModifiers_2 = __webpack_require__(/*! ../data/measureModifiers */ "./src/smo/data/measureModifiers.ts");
const xmlToSmo_1 = __webpack_require__(/*! ./xmlToSmo */ "./src/smo/mxml/xmlToSmo.ts");
const scoreModifiers_1 = __webpack_require__(/*! ../data/scoreModifiers */ "./src/smo/data/scoreModifiers.ts");
/**
 * Convert {@link SmoScore} object into a music XML serialization
 *
 * usage: `xdoc: XmlDocument = SmoToXml.convert(score)`
 * @category SmoToXml
 */
class SmoToXml {
    static get beamStates() {
        return {
            none: 1, start: 2, continue: 3, stop: 4
        };
    }
    static get defaultState() {
        return JSON.parse(JSON.stringify({
            divisions: 0,
            measureNumber: 0,
            measureIndex: 0,
            transposeOffset: 0,
            tickCount: 0,
            voiceIndex: 0,
            keySignature: 'C',
            voiceTickIndex: 0,
            slurs: [],
            partStaves: [],
            lyricState: {},
            measureTicks: 0,
            beamState: 0,
            beamTicks: 4096
        }));
    }
    /**
     * see usage
     * @param score
     * @returns
     */
    static convert(score) {
        let staffGroupIx = 0;
        let staffIx = 0;
        const nn = xmlHelpers_1.XmlHelpers.createTextElementChild;
        const dom = xmlHelpers_1.XmlHelpers.createRootElement();
        const root = dom.children[0];
        const work = nn(root, 'work', null, '');
        nn(work, 'work-title', score.scoreInfo, 'title');
        const identification = nn(root, 'identification', null, '');
        const creator = nn(identification, 'creator', score.scoreInfo, 'composer');
        xmlHelpers_1.XmlHelpers.createAttributes(creator, { type: 'composer' });
        const encoding = nn(identification, 'encoding', null, '');
        nn(encoding, 'software', { software: 'Some pre-release version of Smoosic' }, 'software');
        const today = new Date();
        const dd = (n) => n < 10 ? '0' + n.toString() : n.toString();
        const dateString = today.getFullYear() + '-' + dd(today.getMonth() + 1) + '-' + dd(today.getDate());
        nn(encoding, 'encoding-date', dateString, 'date');
        const defaults = nn(root, 'defaults', null, '');
        const scaling = nn(defaults, 'scaling', null, '');
        const svgScale = score.layoutManager.getGlobalLayout().svgScale;
        // music in vexflow is rendered at a font size of 38
        const mm = xmlToSmo_1.XmlToSmo.mmPerPixel * 42 * svgScale;
        nn(scaling, 'millimeters', { mm }, 'mm');
        nn(scaling, 'tenths', { tenths: 40 }, 'tenths');
        const pageLayout = nn(defaults, 'page-layout', null, '');
        const musicFont = nn(defaults, 'music-font', null, '');
        const engrave = score.fonts.find((fn) => fn.purpose === score_1.SmoScore.fontPurposes.ENGRAVING);
        xmlHelpers_1.XmlHelpers.createAttribute(musicFont, 'font-size', 38 * svgScale);
        if (engrave) {
            xmlHelpers_1.XmlHelpers.createAttribute(musicFont, 'font-family', engrave.family);
        }
        const tenthConversion = (25.2 / 96) * (40 / mm);
        const pageDims = {
            'page-height': score.layoutManager.globalLayout.pageHeight * tenthConversion,
            'page-width': score.layoutManager.globalLayout.pageWidth * tenthConversion
        };
        Object.keys(pageDims).forEach((dim) => {
            nn(pageLayout, dim, pageDims, dim);
        });
        const margins = { 'left-margin': score.layoutManager.pageLayouts[0].leftMargin * tenthConversion,
            'right-margin': score.layoutManager.pageLayouts[0].rightMargin * tenthConversion,
            'top-margin': score.layoutManager.pageLayouts[0].topMargin * tenthConversion,
            'bottom-margin': score.layoutManager.pageLayouts[0].bottomMargin * tenthConversion };
        const pageMargins = nn(pageLayout, 'page-margins', null, '');
        Object.keys(margins).forEach((margin) => {
            nn(pageMargins, margin, margins, margin);
        });
        const partList = nn(root, 'part-list', null, '');
        score.staves.forEach((staff) => {
            score.systemGroups.forEach((sg) => {
                if (sg.startSelector.staff === staff.staffId && sg.startSelector.staff < sg.endSelector.staff) {
                    const partGroup = nn(partList, 'part-group', null, '');
                    xmlHelpers_1.XmlHelpers.createAttributes(partGroup, { number: staffGroupIx, type: 'start' });
                    const groupSymbol = nn(partGroup, 'group-symbol', null, '');
                    let symbolText = 'line';
                    if (sg.leftConnector === scoreModifiers_1.SmoSystemGroup.connectorTypes['brace']) {
                        symbolText = 'brace';
                    }
                    else if (sg.leftConnector === scoreModifiers_1.SmoSystemGroup.connectorTypes['bracket']) {
                        symbolText = 'bracket';
                    }
                    else if (sg.leftConnector === scoreModifiers_1.SmoSystemGroup.connectorTypes['double']) {
                        symbolText = 'square';
                    }
                    groupSymbol.textContent = symbolText;
                }
                else if (sg.endSelector.staff === staff.staffId && sg.startSelector.staff < sg.endSelector.staff) {
                    const partGroup = nn(partList, 'part-group', null, '');
                    xmlHelpers_1.XmlHelpers.createAttributes(partGroup, { number: staffGroupIx, type: 'stop' });
                }
            });
            if (!staff.partInfo.stavesBefore) {
                const id = 'P' + staff.staffId;
                const scorePart = nn(partList, 'score-part', null, '');
                xmlHelpers_1.XmlHelpers.createAttributes(scorePart, { id });
                nn(scorePart, 'part-name', { name: staff.measureInstrumentMap[0].instrumentName }, 'name');
            }
        });
        const smoState = SmoToXml.defaultState;
        for (staffIx = 0; staffIx < score.staves.length; ++staffIx) {
            smoState.partStaves = [];
            // If this is the second staff in a part, we've already output the music with the
            // first stave
            if (score.staves[staffIx].partInfo.stavesBefore > 0) {
                continue;
            }
            smoState.partStaves.push(score.staves[staffIx]);
            if (smoState.partStaves[0].partInfo.stavesAfter > 0 && staffIx < score.staves.length + 1) {
                smoState.partStaves.push(score.staves[staffIx + 1]);
            }
            const part = nn(root, 'part', null, '');
            const id = 'P' + smoState.partStaves[0].staffId;
            xmlHelpers_1.XmlHelpers.createAttributes(part, { id });
            smoState.measureNumber = 1;
            smoState.tickCount = 0;
            smoState.transposeOffset = 0;
            smoState.slurs = [];
            smoState.lyricState = {};
            for (smoState.measureIndex = 0; smoState.measureIndex < smoState.partStaves[0].measures.length; ++smoState.measureIndex) {
                const measureElement = nn(part, 'measure', null, '');
                for (smoState.staffPartIx = 0; smoState.staffPartIx < smoState.partStaves.length; ++smoState.staffPartIx) {
                    smoState.measureTicks = 0;
                    // each staff in a part goes in the same measure element.  If this is a subsequent part, we've already 
                    SmoToXml.measure(measureElement, smoState);
                }
                smoState.measureNumber += 1;
            }
        }
        return SmoToXml.prettifyXml(dom);
    }
    /**
     * MuseScore doesn't like minified xml, so we pretty-print it.
     * @param xmlDoc
     * @returns
     */
    static prettifyXml(xmlDoc) {
        var xsltDoc = new DOMParser().parseFromString([
            // describes how we want to modify the XML - indent everything
            '<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform">',
            '  <xsl:strip-space elements="*"/>',
            '  <xsl:template match="para[content-style][not(text())]">',
            '    <xsl:value-of select="normalize-space(.)"/>',
            '  </xsl:template>',
            '  <xsl:template match="node()|@*">',
            '    <xsl:copy><xsl:apply-templates select="node()|@*"/></xsl:copy>',
            '  </xsl:template>',
            '  <xsl:output indent="yes"/>',
            '</xsl:stylesheet>',
        ].join('\n'), 'application/xml');
        var xsltProcessor = new XSLTProcessor();
        xsltProcessor.importStylesheet(xsltDoc);
        var resultDoc = xsltProcessor.transformToDocument(xmlDoc);
        return resultDoc;
    }
    ;
    /**
     * /score-partwise/part/measure
     * @param measureElement
     * @param smoState
     * @returns
     */
    static measure(measureElement, smoState) {
        const nn = xmlHelpers_1.XmlHelpers.createTextElementChild;
        const measure = smoState.partStaves[smoState.staffPartIx].measures[smoState.measureIndex];
        if (smoState.measureNumber === 1 && measure.isPickup()) {
            smoState.measureNumber = 0;
        }
        if (measure.getForceSystemBreak()) {
            const printElement = nn(measureElement, 'print', null, '');
            xmlHelpers_1.XmlHelpers.createAttributes(printElement, { 'new-system': 'yes' });
        }
        xmlHelpers_1.XmlHelpers.createAttributes(measureElement, { number: smoState.measureNumber });
        SmoToXml.attributes(measureElement, measure, smoState);
        smoState.voiceIndex = 1;
        smoState.beamState = SmoToXml.beamStates.none;
        smoState.beamTicks = 0;
        SmoToXml.barline(measureElement, smoState, true);
        measure.voices.forEach((voice) => {
            smoState.voiceTickIndex = 0;
            smoState.voice = voice;
            voice.notes.forEach((note) => {
                smoState.note = note;
                // Start wedge before note starts
                SmoToXml.direction(measureElement, smoState, true);
                SmoToXml.note(measureElement, measure, note, smoState);
                // End wedge on next tick
                SmoToXml.direction(measureElement, smoState, false);
            });
            // If this is the end of a voice, back up the time to align the voices
            if (measure.voices.length > smoState.voiceIndex) {
                smoState.voiceIndex += 1;
                const backupElement = nn(measureElement, 'backup', null, '');
                nn(backupElement, 'duration', { duration: smoState.measureTicks }, 'duration');
            }
            else {
                if (smoState.partStaves.length > 1 && smoState.staffPartIx + 1 < smoState.partStaves.length) {
                    // If this is the end of a measure, and this is the first part in the staff, back it up for the second staff
                    const backupElement = nn(measureElement, 'backup', null, '');
                    nn(backupElement, 'duration', { duration: smoState.measureTicks }, 'duration');
                    smoState.tickCount += smoState.measureTicks;
                }
                else if (smoState.partStaves.length === 1) {
                    smoState.tickCount += smoState.measureTicks;
                }
            }
            smoState.measureTicks = 0;
        });
        SmoToXml.barline(measureElement, smoState, false);
    }
    /**
     * /score-partwise/part/measure/barline
     * @param measureElement
     * @param smoState
     * @param start
     */
    static barline(measureElement, smoState, start) {
        const nn = xmlHelpers_1.XmlHelpers.createTextElementChild;
        let barlineElement = null;
        const staff = smoState.partStaves[smoState.staffPartIx];
        const measure = staff.measures[smoState.measureIndex];
        if (start) {
            if (measure.getStartBarline().barline === measureModifiers_1.SmoBarline.barlines.startRepeat) {
                barlineElement = nn(measureElement, 'barline', null, '');
                const repeatElement = nn(barlineElement, 'repeat', null, '');
                xmlHelpers_1.XmlHelpers.createAttributes(repeatElement, { direction: 'forward' });
            }
        }
        const voltas = staff.getVoltasForMeasure(measure.measureNumber.measureIndex);
        const numArray = [];
        voltas.forEach((volta) => {
            var _a, _b;
            if ((start && ((_a = volta === null || volta === void 0 ? void 0 : volta.startSelector) === null || _a === void 0 ? void 0 : _a.measure) === measure.measureNumber.measureIndex) ||
                (!start && ((_b = volta === null || volta === void 0 ? void 0 : volta.endSelector) === null || _b === void 0 ? void 0 : _b.measure) === measure.measureNumber.measureIndex)) {
                numArray.push(volta.number);
            }
        });
        if (!start && measure.getEndBarline().barline === measureModifiers_1.SmoBarline.barlines.endBar) {
            barlineElement = barlineElement !== null && barlineElement !== void 0 ? barlineElement : nn(measureElement, 'barline', null, '');
            nn(barlineElement, 'bar-style', { style: 'light-heavy' }, 'style');
        }
        else if (!start && measure.getEndBarline().barline === measureModifiers_1.SmoBarline.barlines.doubleBar) {
            barlineElement = barlineElement !== null && barlineElement !== void 0 ? barlineElement : nn(measureElement, 'barline', null, '');
            nn(barlineElement, 'bar-style', { style: 'light-light' }, 'style');
        }
        if (numArray.length) {
            barlineElement = barlineElement !== null && barlineElement !== void 0 ? barlineElement : nn(measureElement, 'barline', null, '');
            const numstr = numArray.join(',');
            const endElement = nn(barlineElement, 'ending', null, '');
            const endString = start ? 'start' : 'stop';
            xmlHelpers_1.XmlHelpers.createAttributes(endElement, { type: endString, number: numstr });
        }
        if (!start && measure.getEndBarline().barline === measureModifiers_1.SmoBarline.barlines.endRepeat) {
            barlineElement = barlineElement !== null && barlineElement !== void 0 ? barlineElement : nn(measureElement, 'barline', null, '');
            const repeatElement = nn(barlineElement, 'repeat', null, '');
            xmlHelpers_1.XmlHelpers.createAttributes(repeatElement, { direction: 'backward' });
        }
    }
    /**
     * /score-partwise/part/measure/note/notations/slur
     * @param notationsElement
     * @param smoState
     */
    static slur(notationsElement, smoState) {
        const nn = xmlHelpers_1.XmlHelpers.createTextElementChild;
        const staff = smoState.partStaves[smoState.staffPartIx];
        const measure = staff.measures[smoState.measureIndex];
        const getNumberForSlur = ((slurs) => {
            let rv = 1;
            const hash = {};
            slurs.forEach((ss) => {
                hash[ss.number] = true;
            });
            while (rv < 100) {
                if (typeof (hash[rv]) === 'undefined') {
                    break;
                }
                rv += 1;
            }
            return rv;
        });
        const selector = {
            staff: staff.staffId,
            measure: measure.measureNumber.measureIndex,
            voice: smoState.voiceIndex - 1,
            tick: smoState.voiceTickIndex,
            pitches: []
        };
        const starts = staff.getSlursStartingAt(selector);
        const ends = staff.getSlursEndingAt(selector);
        const remove = [];
        const newSlurs = [];
        ends.forEach((slur) => {
            const match = smoState.slurs.find((ss) => selections_1.SmoSelector.eq(ss.startSelector, slur.startSelector) &&
                selections_1.SmoSelector.eq(ss.endSelector, slur.endSelector));
            if (match) {
                remove.push(match);
                const slurElement = nn(notationsElement, 'slur', null, '');
                xmlHelpers_1.XmlHelpers.createAttributes(slurElement, { number: match.number, type: 'stop' });
            }
        });
        smoState.slurs.forEach((slur) => {
            if (remove.findIndex((rr) => rr.number === slur.number) < 0) {
                newSlurs.push(slur);
            }
        });
        smoState.slurs = newSlurs;
        starts.forEach((slur) => {
            const number = getNumberForSlur(smoState.slurs);
            smoState.slurs.push({
                startSelector: slur.startSelector,
                endSelector: slur.endSelector,
                number
            });
            const slurElement = nn(notationsElement, 'slur', null, '');
            xmlHelpers_1.XmlHelpers.createAttributes(slurElement, { number: number, type: 'start' });
        });
    }
    /**
     * /score-partwise/measure/note/time-modification
     * /score-partwise/measure/note/tuplet
     * @param noteElement
     * @param notationsElement
     * @param smoState
     * @returns
     */
    static tupletTime(noteElement, tuplet, smoState) {
        const nn = xmlHelpers_1.XmlHelpers.createTextElementChild;
        const obj = {
            actualNotes: tuplet.numNotes, normalNotes: tuplet.notes_occupied
        };
        const timeModification = nn(noteElement, 'time-modification', null, '');
        nn(timeModification, 'actual-notes', obj, 'actualNotes');
        nn(timeModification, 'normal-notes', obj, 'normalNotes');
    }
    static tupletNotation(notationsElement, tuplet, note) {
        const nn = xmlHelpers_1.XmlHelpers.createTextElementChild;
        if (tuplet.getIndexOfNote(note) === 0) {
            const tupletElement = nn(notationsElement, 'tuplet', null, '');
            xmlHelpers_1.XmlHelpers.createAttributes(tupletElement, {
                number: 1, type: 'start'
            });
        }
        else if (tuplet.getIndexOfNote(note) === tuplet.notes.length - 1) {
            const tupletElement = nn(notationsElement, 'tuplet', null, '');
            xmlHelpers_1.XmlHelpers.createAttributes(tupletElement, {
                number: 1, type: 'stop'
            });
        }
    }
    /**
     * /score-partwise/measure/note/pitch
     * @param pitch
     * @param noteElement
     */
    static pitch(pitch, noteElement) {
        const nn = xmlHelpers_1.XmlHelpers.createTextElementChild;
        const accidentalOffset = ['bb', 'b', 'n', '#', '##'];
        const alter = accidentalOffset.indexOf(pitch.accidental) - 2;
        const pitchElement = nn(noteElement, 'pitch', null, '');
        nn(pitchElement, 'step', { letter: pitch.letter.toUpperCase() }, 'letter');
        nn(pitchElement, 'alter', { alter }, 'alter');
        nn(pitchElement, 'octave', pitch, 'octave');
    }
    /**
     * /score-partwise/measure/beam
     * @param noteElement
     * @param smoState
     * @returns
     */
    static beamNote(noteElement, smoState) {
        if (!smoState.note) {
            return;
        }
        if (!smoState.voice) {
            return;
        }
        const nn = xmlHelpers_1.XmlHelpers.createTextElementChild;
        const note = smoState.note;
        const nextNote = (smoState.voiceTickIndex + 1) >= smoState.voice.notes.length ?
            null : smoState.voice.notes[smoState.voiceTickIndex + 1];
        const exceedTicks = smoState.beamTicks + note.tickCount >= note.beamBeats;
        // don't start a beam on a rest
        if (note.isRest() && smoState.beamState === SmoToXml.beamStates.none) {
            return;
        }
        let toBeam = SmoToXml.beamStates.none;
        if (note.tickCount <= 2048 && !exceedTicks) {
            // Explicit end beam, or no more notes to beam, so stop beam
            if (note.endBeam || nextNote === null) {
                if (smoState.beamState !== SmoToXml.beamStates.none) {
                    toBeam = SmoToXml.beamStates.stop;
                }
            }
            else {
                // else if the next note is beamable, start or continue the beam
                if (nextNote.tickCount <= 2048) {
                    toBeam = smoState.beamState === SmoToXml.beamStates.continue ?
                        SmoToXml.beamStates.continue : SmoToXml.beamStates.start;
                }
            }
        }
        if (toBeam === SmoToXml.beamStates.start || toBeam === SmoToXml.beamStates.continue) {
            smoState.beamTicks += smoState.note.tickCount;
        }
        else {
            smoState.beamTicks = 0;
        }
        // slur is start/stop, beam is begin, end, gf
        if (toBeam === SmoToXml.beamStates.start) {
            const beamElement = nn(noteElement, 'beam', { type: 'begin' }, 'type');
            xmlHelpers_1.XmlHelpers.createAttributes(beamElement, { number: 1 });
            smoState.beamState = SmoToXml.beamStates.continue;
        }
        else if (toBeam === SmoToXml.beamStates.continue) {
            const beamElement = nn(noteElement, 'beam', { type: 'continue' }, 'type');
            xmlHelpers_1.XmlHelpers.createAttributes(beamElement, { number: 1 });
        }
        else if ((toBeam === SmoToXml.beamStates.stop) ||
            (toBeam === SmoToXml.beamStates.none && smoState.beamState !== SmoToXml.beamStates.none)) {
            const beamElement = nn(noteElement, 'beam', { type: 'end' }, 'type');
            xmlHelpers_1.XmlHelpers.createAttributes(beamElement, { number: 1 });
            smoState.beamState = SmoToXml.beamStates.none;
        }
    }
    /**
     * /score-partwise/measure/direction/direction-type
     * @param measureElement
     * @param smoState
     * @param beforeNote
     */
    static direction(measureElement, smoState, beforeNote) {
        let addDirection = false;
        const nn = xmlHelpers_1.XmlHelpers.createTextElementChild;
        const directionElement = measureElement.ownerDocument.createElement('direction');
        const staff = smoState.partStaves[smoState.staffPartIx];
        const measure = staff.measures[smoState.measureIndex];
        const directionChildren = [];
        const tempo = measure.getTempo();
        let displayTempo = false;
        if (smoState.tempo) {
            if (tempo.display && measure.measureNumber.measureIndex === 0 && smoState.measureTicks === 0) {
                displayTempo = true;
            }
            else if (tempo.display && !measureModifiers_2.SmoTempoText.eq(smoState.tempo, tempo)) {
                displayTempo = true;
            }
        }
        else {
            displayTempo = true;
        }
        smoState.tempo = new measureModifiers_2.SmoTempoText(tempo);
        if (beforeNote === true && smoState.staffPartIx === 0 && smoState.measureTicks === 0 && smoState.partStaves[0].staffId === 0) {
            const mark = measure.getRehearsalMark();
            if (mark) {
                const rmtype = nn(directionElement, 'direction-type', null, '');
                const xmark = mark;
                const rElement = nn(rmtype, 'rehearsal', { mark: xmark.symbol }, 'mark');
                xmlHelpers_1.XmlHelpers.createAttribute(rElement, 'enclosure', 'square');
                xmlHelpers_1.XmlHelpers.createAttribute(directionElement, 'placement', 'above');
                addDirection = true;
            }
        }
        if (beforeNote === true && displayTempo) {
            addDirection = true;
            const tempoBpm = Math.round(tempo.bpm * tempo.beatDuration / 4096);
            const tempoElement = nn(directionElement, 'direction-type', null, '');
            xmlHelpers_1.XmlHelpers.createAttribute(directionElement, 'placement', 'above');
            let tempoText = tempo.tempoText;
            if (tempo.tempoMode === measureModifiers_2.SmoTempoText.tempoModes.customMode) {
                tempoText = tempo.customText;
            }
            if (tempo.tempoMode === measureModifiers_2.SmoTempoText.tempoModes.textMode) {
                nn(tempoElement, 'words', { words: tempoText }, 'words');
            }
            else if (tempo.tempoMode === measureModifiers_2.SmoTempoText.tempoModes.customMode || tempo.tempoMode === measureModifiers_2.SmoTempoText.tempoModes.durationMode) {
                const metronomeElement = nn(tempoElement, 'metronome', null, '');
                let durationType = 'quarter';
                let dotType = false;
                if (tempo.bpm >= 8192) {
                    durationType = 'half';
                }
                else if (tempo.bpm < 4096) {
                    durationType = 'eighth';
                }
                if (tempo.bpm === 6144 || tempo.bpm === 12288 || tempo.bpm === 3072) {
                    dotType = true;
                }
                nn(metronomeElement, 'beat-unit', { beatUnit: durationType }, 'beatUnit');
                if (dotType) {
                    nn(metronomeElement, 'beat-unit-dot', null, '');
                }
                nn(metronomeElement, 'per-minute', { tempo }, 'bpm');
            }
            // Sound is supposed to come last under 'direction' element
            const soundElement = measureElement.ownerDocument.createElement('sound');
            soundElement.setAttribute('tempo', tempoBpm.toString());
            directionChildren.push(soundElement);
        }
        const selector = {
            staff: staff.staffId,
            measure: measure.measureNumber.measureIndex,
            voice: smoState.voiceIndex - 1,
            tick: smoState.voiceTickIndex,
            pitches: []
        };
        if (!beforeNote) {
            selector.tick -= 1;
        }
        const startWedge = staff.modifiers.find((mod) => selections_1.SmoSelector.sameNote(mod.startSelector, selector) &&
            (mod.attrs.type === 'SmoStaffHairpin'));
        const endWedge = staff.modifiers.find((mod) => selections_1.SmoSelector.sameNote(mod.endSelector, selector) &&
            (mod.attrs.type === 'SmoStaffHairpin'));
        if (endWedge && !beforeNote) {
            const wedgeDirection = nn(measureElement, 'direction', null, '');
            const dtype = nn(wedgeDirection, 'direction-type', null, '');
            const wedgeElement = nn(dtype, 'wedge', null, '');
            xmlHelpers_1.XmlHelpers.createAttributes(wedgeElement, { type: 'stop', spread: '20' });
        }
        if (startWedge && beforeNote) {
            const wedgeDirection = nn(measureElement, 'direction', null, '');
            const dtype = nn(wedgeDirection, 'direction-type', null, '');
            const wedgeElement = nn(dtype, 'wedge', null, '');
            const wedgeType = startWedge.hairpinType === staffModifiers_1.SmoStaffHairpin.types.CRESCENDO ?
                'crescendo' : 'diminuendo';
            xmlHelpers_1.XmlHelpers.createAttributes(wedgeElement, { type: wedgeType });
        }
        if (addDirection) {
            measureElement.appendChild(directionElement);
            directionChildren.forEach((el) => {
                directionElement.appendChild(el);
            });
        }
    }
    /**
     * /score-partwise/measure/note/lyric
     * @param noteElement
     * @param smoState
     */
    static lyric(noteElement, smoState) {
        const smoNote = smoState.note;
        const nn = xmlHelpers_1.XmlHelpers.createTextElementChild;
        const lyrics = smoNote.getTrueLyrics();
        lyrics.forEach((lyric) => {
            let syllabic = 'single';
            if (lyric.isHyphenated() === false && lyric.isDash() === false) {
                if (smoState.lyricState[lyric.verse] === 'begin') {
                    syllabic = 'end';
                } // else stays single
            }
            else {
                if (lyric.isHyphenated()) {
                    syllabic = smoState.lyricState[lyric.verse] === 'begin' ?
                        'middle' : 'begin';
                }
                else if (lyric.isDash()) {
                    syllabic = 'middle';
                }
            }
            smoState.lyricState[lyric.verse] = syllabic;
            const lyricElement = nn(noteElement, 'lyric', null, '');
            xmlHelpers_1.XmlHelpers.createAttribute(lyricElement, 'number', lyric.verse + 1);
            xmlHelpers_1.XmlHelpers.createAttribute(lyricElement, 'placement', 'below');
            xmlHelpers_1.XmlHelpers.createAttribute(lyricElement, 'default-y', -80 - 10 * lyric.verse);
            nn(lyricElement, 'syllabic', syllabic, '');
            nn(lyricElement, 'text', lyric.getText(), '');
        });
    }
    /**
     * /score-partwise/measure/note
     * @param measureElement
     * @param smoState
     */
    static note(measureElement, measure, note, smoState) {
        const nn = xmlHelpers_1.XmlHelpers.createTextElementChild;
        let i = 0;
        for (i = 0; i < note.pitches.length; ++i) {
            let j = 0;
            const noteElement = nn(measureElement, 'note', null, '');
            const isChord = i > 0;
            if (isChord) {
                nn(noteElement, 'chord', null, '');
            }
            else {
            }
            if (note.isRest()) {
                const restElement = nn(noteElement, 'rest', null, '');
                const step = { letter: note.pitches[i].letter.toUpperCase() };
                nn(restElement, 'display-step', step, 'letter');
                nn(restElement, 'display-octave', Object.assign({}, note.pitches[i]), 'octave');
            }
            else {
                SmoToXml.pitch(note.pitches[i], noteElement);
            }
            const duration = note.tickCount;
            smoState.measureTicks += duration;
            const tuplet = measure.getTupletForNote(note);
            nn(noteElement, 'duration', { duration }, 'duration');
            nn(noteElement, 'voice', { voice: smoState.voiceIndex }, 'voice');
            let typeTickCount = note.tickCount;
            if (tuplet) {
                typeTickCount = tuplet.stemTicks;
            }
            nn(noteElement, 'type', { type: xmlHelpers_1.XmlHelpers.closestStemType(typeTickCount) }, 'type');
            const dots = music_1.SmoMusic.smoTicksToVexDots(note.tickCount);
            for (j = 0; j < dots; ++j) {
                nn(noteElement, 'dot', null, '');
            }
            // time modification (tuplet) comes before notations which have tuplet beaming rules
            // also before stem
            if (tuplet) {
                SmoToXml.tupletTime(noteElement, tuplet, smoState);
            }
            if (note.flagState === note_1.SmoNote.flagStates.up) {
                nn(noteElement, 'stem', { direction: 'up' }, 'direction');
            }
            if (note.flagState === note_1.SmoNote.flagStates.down) {
                nn(noteElement, 'stem', { direction: 'down' }, 'direction');
            }
            // stupid musicxml requires beam to be last.
            const notationsElement = noteElement.ownerDocument.createElement('notations');
            // If a multi-part staff, we need to include 'staff' element
            if (smoState.partStaves.length > 1) {
                nn(noteElement, 'staff', { staffIx: smoState.staffPartIx + 1 }, 'staffIx');
            }
            if (!isChord) {
                SmoToXml.beamNote(noteElement, smoState);
            }
            if (!isChord) {
                SmoToXml.slur(notationsElement, smoState);
            }
            if (tuplet) {
                SmoToXml.tupletNotation(notationsElement, tuplet, note);
            }
            const ornaments = note.getOrnaments();
            if (ornaments.length) {
                const ornamentsElement = noteElement.ownerDocument.createElement('ornaments');
                ornamentsElement.textContent = '\n';
                ornaments.forEach((ornament) => {
                    if (noteModifiers_1.SmoOrnament.xmlOrnaments[ornament.ornament]) {
                        const sub = nn(ornamentsElement, noteModifiers_1.SmoOrnament.xmlOrnaments[ornament.ornament], null, '');
                        xmlHelpers_1.XmlHelpers.createAttribute(sub, 'placement', 'above');
                    }
                });
                if (ornamentsElement.children.length) {
                    notationsElement.appendChild(ornamentsElement);
                }
            }
            const jazzOrnaments = note.getJazzOrnaments();
            const articulations = note.articulations;
            if (jazzOrnaments.length || articulations.length) {
                const articulationsElement = noteElement.ownerDocument.createElement('articulations');
                jazzOrnaments.forEach((ornament) => {
                    if (noteModifiers_1.SmoOrnament.xmlJazz[ornament.ornament]) {
                        nn(articulationsElement, noteModifiers_1.SmoOrnament.xmlJazz[ornament.ornament], null, '');
                    }
                });
                articulations.forEach((articulation) => {
                    if (noteModifiers_1.SmoArticulation.xmlArticulations[articulation.articulation]) {
                        nn(articulationsElement, noteModifiers_1.SmoArticulation.xmlArticulations[articulation.articulation], null, '');
                    }
                });
                if (articulationsElement.children.length) {
                    notationsElement.append(articulationsElement);
                }
            }
            if (notationsElement.children.length) {
                noteElement.appendChild(notationsElement);
            }
            // stupid musicxml requires beam to be laster.
            if (!isChord) {
                SmoToXml.lyric(noteElement, smoState);
            }
        }
        smoState.voiceTickIndex += 1;
    }
    /**
     * /score-partwise/measure/attributes/key
     * @param attributesElement
     * @param smoState
     * @returns
     */
    static key(attributesElement, measure, smoState) {
        let fifths = 0;
        if (smoState.keySignature && measure.keySignature === smoState.keySignature) {
            return; // no key change
        }
        const flats = music_1.SmoMusic.getFlatsInKeySignature(measure.keySignature);
        const nn = xmlHelpers_1.XmlHelpers.createTextElementChild;
        if (flats > 0) {
            fifths = -1 * flats;
        }
        else {
            fifths = music_1.SmoMusic.getSharpsInKeySignature(measure.keySignature);
        }
        const keyElement = nn(attributesElement, 'key', null, '');
        nn(keyElement, 'fifths', { fifths }, 'fifths');
        nn(keyElement, 'mode', { mode: 'major' }, 'major');
        smoState.keySignature = measure.keySignature;
    }
    /**
     * /score-partwise/part/measure/attributes/time
     * @param attributesElement
     * @param smoState
     * @returns
     */
    static time(attributesElement, smoState) {
        var _a;
        const nn = xmlHelpers_1.XmlHelpers.createTextElementChild;
        const staff = smoState.partStaves[smoState.staffPartIx];
        const measure = staff.measures[smoState.measureIndex];
        const currentTs = (_a = smoState.timeSignature) !== null && _a !== void 0 ? _a : null;
        if (currentTs !== null && measureModifiers_1.TimeSignature.equal(currentTs, measure.timeSignature)) {
            return;
        }
        smoState.timeSignature = measure.timeSignature;
        const time = { beats: measure.timeSignature.actualBeats, beatType: measure.timeSignature.beatDuration };
        const timeElement = nn(attributesElement, 'time', null, '');
        nn(timeElement, 'beats', time, 'beats');
        nn(timeElement, 'beat-type', time, 'beatType');
        smoState.timeSignature = measure.timeSignature;
    }
    /**
     * /score-partwise/part/measure/attributes/clef
     * @param attributesElement
     * @param smoState
     * @returns
     */
    static clef(attributesElement, smoState) {
        smoState.partStaves.forEach((staff, staffIx) => {
            const measure = staff.measures[smoState.measureIndex];
            let prevMeasure = null;
            let clefChange = null;
            if (smoState.measureIndex > 0) {
                prevMeasure = staff.measures[smoState.measureIndex - 1];
            }
            if (prevMeasure && prevMeasure.clef !== measure.clef) {
                clefChange = measure.clef;
            }
            // both clefs are defined in the first measure one time.
            if (smoState.measureIndex === 0 && smoState.staffPartIx === 0) {
                clefChange = measure.clef;
            }
            if (clefChange) {
                const nn = xmlHelpers_1.XmlHelpers.createTextElementChild;
                const xmlClef = music_1.SmoMusic.clefSigns[clefChange];
                const clefElement = nn(attributesElement, 'clef', null, '');
                nn(clefElement, 'sign', xmlClef.sign, 'sign');
                if (typeof (xmlClef.line) !== 'undefined') {
                    nn(clefElement, 'line', xmlClef, 'line');
                }
                if (typeof (xmlClef.octave) !== 'undefined') {
                    nn(clefElement, 'clef-octave-change', xmlClef, 'octave');
                }
                xmlHelpers_1.XmlHelpers.createAttribute(clefElement, 'number', (staffIx + 1).toString());
            }
        });
    }
    /**
     * /score-partwise/part/measure/attributes
     * @param measureElement
     * @param smoState
     */
    static attributes(measureElement, measure, smoState) {
        const nn = xmlHelpers_1.XmlHelpers.createTextElementChild;
        const attributesElement = measureElement.ownerDocument.createElement('attributes');
        if (smoState.divisions < 1) {
            nn(attributesElement, 'divisions', { divisions: 4096 }, 'divisions');
            smoState.divisions = 4096;
        }
        SmoToXml.key(attributesElement, measure, smoState);
        SmoToXml.time(attributesElement, smoState);
        // only call out number of staves in a part at the beginning of the part
        if (smoState.measureIndex === 0 && smoState.staffPartIx === 0) {
            SmoToXml.staves(attributesElement, smoState);
        }
        SmoToXml.clef(attributesElement, smoState);
        SmoToXml.transpose(attributesElement, smoState);
        if (attributesElement.children.length > 0) {
            // don't add an empty attributes element
            measureElement.appendChild(attributesElement);
        }
    }
    static staves(attributesElement, smoState) {
        const staff = smoState.partStaves[smoState.staffPartIx];
        const staffCount = staff.partInfo.stavesAfter > 0 ? 2 : 1;
        const nn = xmlHelpers_1.XmlHelpers.createTextElementChild;
        nn(attributesElement, 'staves', { staffCount: staffCount.toString() }, 'staffCount');
    }
    /**
     * /score-partwise/part/measure/attributes/transpose
     * @param attributesElement
     * @param smoState
     * @returns
     */
    static transpose(attributesElement, smoState) {
        const staff = smoState.partStaves[smoState.staffPartIx];
        const measure = staff.measures[smoState.measureIndex];
        if (measure.transposeIndex !== smoState.transposeOffset) {
            smoState.transposeOffset = measure.transposeIndex;
            const nn = xmlHelpers_1.XmlHelpers.createTextElementChild;
            const xposeElement = nn(attributesElement, 'transpose', null, '');
            const offset = (measure.transposeIndex * -1).toString();
            ;
            nn(xposeElement, 'chromatic', { offset: offset }, 'offset');
        }
    }
}
exports.SmoToXml = SmoToXml;


/***/ }),

/***/ "./src/smo/mxml/xmlHelpers.ts":
/*!************************************!*\
  !*** ./src/smo/mxml/xmlHelpers.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.XmlHelpers = void 0;
// [Smoosic](https://github.com/AaronDavidNewman/Smoosic)
// Copyright (c) Aaron David Newman 2021.
const serializationHelpers_1 = __webpack_require__(/*! ../../common/serializationHelpers */ "./src/common/serializationHelpers.js");
const noteModifiers_1 = __webpack_require__(/*! ../data/noteModifiers */ "./src/smo/data/noteModifiers.ts");
const music_1 = __webpack_require__(/*! ../data/music */ "./src/smo/data/music.ts");
const note_1 = __webpack_require__(/*! ../data/note */ "./src/smo/data/note.ts");
const measureModifiers_1 = __webpack_require__(/*! ../data/measureModifiers */ "./src/smo/data/measureModifiers.ts");
const VF = eval('Vex.Flow');
/**
 * Utilities for parsing and serialzing musicXML.
 * @category SmoToXml
 * */
class XmlHelpers {
    /**
     * mxml note 'types', really s/b stem types.
     * For grace notes, we use the note type and not duration
     * to get the flag
     */
    static get noteTypesToSmoMap() {
        return {
            'breve': 8192 * 4,
            'whole': 8192 * 2,
            'half': 8192,
            'quarter': 4096,
            'eighth': 2048,
            '16th': 1024,
            '32nd': 512,
            '64th': 256,
            '128th': 128
        };
    }
    static get ticksToNoteTypeMap() {
        return XmlHelpers._ticksToNoteTypeMap;
    }
    // ### closestStemType
    // smo infers the stem type from the duration, but other applications don't
    static closestStemType(ticks) {
        const nticks = VF.durationToTicks(music_1.SmoMusic.vexStemType(ticks));
        return XmlHelpers.ticksToNoteTypeMap[nticks];
    }
    static get beamStates() {
        return {
            BEGIN: 1,
            END: 2,
            AUTO: 3
        };
    }
    static get ornamentXmlToSmoMap() {
        return {
            staccato: { ctor: 'SmoArticulation', params: { articulation: noteModifiers_1.SmoArticulation.articulations.staccato } },
            tenuto: { ctor: 'SmoArticulation', params: { articulation: noteModifiers_1.SmoArticulation.articulations.tenuto } },
            marcato: { ctor: 'SmoArticulation', params: { articulation: noteModifiers_1.SmoArticulation.articulations.marcato } },
            accent: { ctor: 'SmoArticulation', params: { articulation: noteModifiers_1.SmoArticulation.articulations.accent } },
            doit: { ctor: 'SmoOrnament', params: { ornament: noteModifiers_1.SmoOrnament.ornaments.doitLong } },
            falloff: { ctor: 'SmoOrnament', params: { ornament: noteModifiers_1.SmoOrnament.ornaments.fall } },
            scoop: { ctor: 'SmoOrnament', params: { ornament: noteModifiers_1.SmoOrnament.ornaments.scoop } },
            'delayed-turn': { ctor: 'SmoOrnament', params: { ornament: noteModifiers_1.SmoOrnament.ornaments.turn, offset: noteModifiers_1.SmoOrnament.offsets.after } },
            turn: { ctor: 'SmoOrnament', params: { ornament: noteModifiers_1.SmoOrnament.ornaments.turn, offset: noteModifiers_1.SmoOrnament.offsets.on } },
            'inverted-turn': { ctor: 'SmoOrnament', params: { ornament: noteModifiers_1.SmoOrnament.ornaments.turnInverted } },
            mordent: { ctor: 'SmoOrnament', params: { ornament: noteModifiers_1.SmoOrnament.ornaments.mordent } },
            'inverted-mordent': { ctor: 'SmoOrnament', params: { ornament: noteModifiers_1.SmoOrnament.ornaments.mordentInverted } },
            shake: { ctor: 'SmoOrnament', params: { ornament: noteModifiers_1.SmoOrnament.ornaments.mordentInverted } },
            'trill-mark': { ctor: 'SmoOrnament', params: { ornament: noteModifiers_1.SmoOrnament.ornaments.trill } },
        };
    }
    // ### createRootElement
    // Create score-partwise document with prelude
    // https://bugzilla.mozilla.org/show_bug.cgi?id=318086
    static createRootElement() {
        const doc = document.implementation.createDocument('', '', null);
        const rootElem = doc.createElement('score-partwise');
        const piElement = doc.createProcessingInstruction('xml', 'version="1.0" encoding="UTF-8"');
        rootElem.setAttribute('version', '3.1');
        doc.appendChild(rootElem);
        doc.insertBefore(piElement, rootElem);
        return doc;
    }
    // Parse an element whose child has a number in the textContent
    static getNumberFromElement(parent, path, defaults) {
        let rv = (typeof (defaults) === 'undefined' || defaults === null)
            ? 0 : defaults;
        const tval = XmlHelpers.getTextFromElement(parent, path, defaults);
        if (!tval) {
            return rv;
        }
        if (typeof (tval) === 'number') {
            return tval;
        }
        if (tval.indexOf('.')) {
            const tf = parseFloat(tval);
            rv = isNaN(tf) ? rv : tf;
        }
        else {
            const ff = parseInt(tval, 10);
            rv = isNaN(ff) ? rv : ff;
        }
        return rv;
    }
    // Parse an element whose child has a textContent
    static getTextFromElement(parent, path, defaults) {
        const rv = (typeof (defaults) === 'undefined' || defaults === null)
            ? 0 : defaults;
        const el = [...parent.getElementsByTagName(path)];
        if (!el.length) {
            return rv.toString();
        }
        return el[0].textContent;
    }
    static getNumberFromAttribute(node, attribute, defaults) {
        const str = XmlHelpers.getTextFromAttribute(node, attribute, defaults.toString());
        const rv = parseInt(str, 10);
        if (isNaN(rv)) {
            return defaults;
        }
        return rv;
    }
    static getTextFromAttribute(node, attribute, defaults) {
        const rv = node.getAttribute(attribute);
        if (rv) {
            return rv;
        }
        return defaults;
    }
    // ### getChildrenFromPath
    // Like xpath, given ['foo', 'bar'] and parent element
    // 'moo' return any element /moo/foo/bar as an array of elements
    static getChildrenFromPath(parent, pathAr) {
        let i = 0;
        let node = parent;
        const rv = [];
        for (i = 0; i < pathAr.length; ++i) {
            const tag = pathAr[i];
            const nodes = [...node.getElementsByTagName(tag)];
            if (nodes.length === 0) {
                return [];
            }
            if (i < pathAr.length - 1) {
                node = nodes[0];
            }
            else {
                nodes.forEach((nn) => {
                    rv.push(nn);
                });
            }
        }
        return rv;
    }
    static getStemType(noteElement) {
        const tt = XmlHelpers.getTextFromElement(noteElement, 'stem', '');
        if (tt === 'up') {
            return note_1.SmoNote.flagStates.up;
        }
        else if (tt === 'down') {
            return note_1.SmoNote.flagStates.down;
        }
        return note_1.SmoNote.flagStates.auto;
    }
    static getEnding(barlineNode) {
        const endingNodes = [...barlineNode.getElementsByTagName('ending')];
        if (!endingNodes.length) {
            return null;
        }
        const attrs = XmlHelpers.nodeAttributes(endingNodes[0]);
        if (attrs.number && attrs.type) {
            return {
                numbers: attrs.number.split(',').map((x) => parseInt(x, 10)),
                type: attrs.type
            };
        }
        return null;
    }
    static getBarline(barlineNode) {
        const rptNode = [...barlineNode.getElementsByTagName('repeat')];
        if (rptNode.length) {
            const repeatattr = XmlHelpers.nodeAttributes(rptNode[0]);
            return repeatattr.direction === 'forward' ? measureModifiers_1.SmoBarline.barlines.startRepeat : measureModifiers_1.SmoBarline.barlines.endRepeat;
        }
        const styleText = XmlHelpers.getTextFromElement(barlineNode, 'bar-style', '');
        if (styleText.length) {
            const double = styleText.indexOf('-') >= 0;
            const heavy = styleText.indexOf('heavy') >= 0;
            const light = styleText.indexOf('light') >= 0;
            if (double && heavy && light) {
                return measureModifiers_1.SmoBarline.barlines.endBar;
            }
            if (double) {
                return measureModifiers_1.SmoBarline.barlines.doubleBar;
            }
        }
        return measureModifiers_1.SmoBarline.barlines.singleBar;
    }
    // ### assignDefaults
    // Map SMO layout data from xml layout data (default node)
    static assignDefaults(node, defObj, parameters) {
        parameters.forEach((param) => {
            if (!isNaN(parseInt(defObj[param.smo], 10))) {
                const smoParam = param.smo;
                const xmlParam = param.xml;
                defObj[smoParam] = XmlHelpers.getNumberFromElement(node, xmlParam, defObj[smoParam]);
            }
        });
    }
    // ### nodeAttributes
    // turn the attributes of an element into a JS hash
    static nodeAttributes(node) {
        const rv = {};
        node.getAttributeNames().forEach((attr) => {
            const aval = node.getAttribute(attr);
            if (aval) {
                rv[attr] = aval;
            }
        });
        return rv;
    }
    // Some measures have staff ID, some don't.
    // convert xml 1 index to array 0 index
    static getStaffId(node) {
        const staff = [...node.getElementsByTagName('staff')];
        if (staff.length && staff[0].textContent) {
            return parseInt(staff[0].textContent, 10) - 1;
        }
        return 0;
    }
    static noteBeamState(noteNode) {
        const beamNodes = [...noteNode.getElementsByTagName('beam')];
        if (!beamNodes.length) {
            return XmlHelpers.beamStates.AUTO;
        }
        const beamText = beamNodes[0].textContent;
        if (beamText === 'begin') {
            return XmlHelpers.beamStates.BEGIN;
        }
        else if (beamText === 'end') {
            return XmlHelpers.beamStates.END;
        }
        return XmlHelpers.beamStates.AUTO;
    }
    // same with notes and voices.  same convert
    static getVoiceId(node) {
        const voice = [...node.getElementsByTagName('voice')];
        if (voice.length && voice[0].textContent) {
            return parseInt(voice[0].textContent, 10) - 1;
        }
        return 0;
    }
    static smoPitchFromNote(noteNode, defaultPitch) {
        const accidentals = ['bb', 'b', 'n', '#', '##'];
        const letter = XmlHelpers.getTextFromElement(noteNode, 'step', defaultPitch.letter).toLowerCase();
        const octave = XmlHelpers.getNumberFromElement(noteNode, 'octave', defaultPitch.octave);
        const xaccidental = XmlHelpers.getNumberFromElement(noteNode, 'alter', 0);
        return { letter, accidental: accidentals[xaccidental + 2], octave };
    }
    static isGrace(noteNode) {
        const path = XmlHelpers.getChildrenFromPath(noteNode, ['grace']);
        return (path === null || path === void 0 ? void 0 : path.length) > 0;
    }
    static isSystemBreak(measureNode) {
        const printNodes = measureNode.getElementsByTagName('print');
        if (printNodes.length) {
            const attrs = XmlHelpers.nodeAttributes(printNodes[0]);
            if (typeof (attrs['new-system']) !== 'undefined') {
                return attrs['new-system'] === 'yes';
            }
        }
        return false;
    }
    // ### durationFromType
    // Get the SMO tick duration of a note, based on the XML type element (quarter, etc)
    static durationFromType(noteNode, def) {
        const typeNodes = [...noteNode.getElementsByTagName('type')];
        if (typeNodes.length) {
            const txt = typeNodes[0].textContent;
            if (txt && XmlHelpers.noteTypesToSmoMap[txt]) {
                return XmlHelpers.noteTypesToSmoMap[txt];
            }
        }
        return def;
    }
    // ### durationFromNode
    // the true duration value, used to handle forward/backward
    static durationFromNode(noteNode, def) {
        const durationNodes = [...noteNode.getElementsByTagName('duration')];
        if (durationNodes.length && durationNodes[0].textContent) {
            const duration = parseInt(durationNodes[0].textContent, 10);
            return duration;
        }
        return def;
    }
    static ticksFromDuration(noteNode, divisions, def) {
        const rv = { tickCount: def, duration: def / divisions, alteration: { noteCount: 1, noteDuration: 1 } };
        const durationNodes = [...noteNode.getElementsByTagName('duration')];
        const timeAlteration = XmlHelpers.getTimeAlteration(noteNode);
        // different ways to declare note duration - from type is the graphical
        // type, SMO uses ticks for everything
        if (durationNodes.length && durationNodes[0].textContent) {
            rv.duration = parseInt(durationNodes[0].textContent, 10);
            rv.tickCount = 4096 * (rv.duration / divisions);
        }
        else {
            rv.tickCount = XmlHelpers.durationFromType(noteNode, def);
            rv.duration = (divisions / 4096) * rv.tickCount;
        }
        // If this is a tuplet, we adjust the note duration back to the graphical type
        // and SMO will create the tuplet after.  We keep track of tuplet data though for beaming
        if (timeAlteration) {
            rv.tickCount = (rv.tickCount * timeAlteration.noteCount) / timeAlteration.noteDuration;
            rv.alteration = timeAlteration;
        }
        return rv;
    }
    static getTieData(noteNode, selector, pitchIndex) {
        const rv = [];
        let number = 0;
        const nNodes = [...noteNode.getElementsByTagName('notations')];
        nNodes.forEach((nNode) => {
            const slurNodes = [...nNode.getElementsByTagName('tied')];
            slurNodes.forEach((slurNode) => {
                const orientation = XmlHelpers.getTextFromAttribute(slurNode, 'orientation', 'auto');
                const type = slurNode.getAttribute('type');
                number = XmlHelpers.getNumberFromAttribute(slurNode, 'number', 1);
                rv.push({ number, type, orientation, selector, pitchIndex });
            });
        });
        return rv;
    }
    static getSlurData(noteNode, selector) {
        const rv = [];
        const nNodes = [...noteNode.getElementsByTagName('notations')];
        nNodes.forEach((nNode) => {
            const slurNodes = [...nNode.getElementsByTagName('slur')];
            slurNodes.forEach((slurNode) => {
                const number = parseInt(slurNode.getAttribute('number'), 10);
                const type = slurNode.getAttribute('type');
                const orientation = XmlHelpers.getTextFromAttribute(slurNode, 'orienation', 'auto');
                const placement = XmlHelpers.getTextFromAttribute(slurNode, 'placement', 'auto');
                const controlX = XmlHelpers.getNumberFromAttribute(slurNode, 'bezier-x', 0);
                // Y coordinates are reversed from music XML to SVG, hence the -1
                const controlY = XmlHelpers.getNumberFromAttribute(slurNode, 'bezier-y', 15) * -1;
                const slurInfo = { number, type, orientation, placement, controlX, controlY, selector, invert: false, yOffset: 0 };
                rv.push(slurInfo);
            });
        });
        return rv;
    }
    static getCrescendoData(directionElement) {
        let rv = {};
        const nNodes = XmlHelpers.getChildrenFromPath(directionElement, ['direction-type', 'wedge']);
        nNodes.forEach((nNode) => {
            rv = { type: nNode.getAttribute('type') };
        });
        return rv;
    }
    static getTupletData(noteNode) {
        const rv = [];
        const nNodes = [...noteNode.getElementsByTagName('notations')];
        nNodes.forEach((nNode) => {
            const slurNodes = [...nNode.getElementsByTagName('tuplet')];
            slurNodes.forEach((slurNode) => {
                const number = parseInt(slurNode.getAttribute('number'), 10);
                const type = slurNode.getAttribute('type');
                rv.push({ number, type });
            });
        });
        return rv;
    }
    static articulationsAndOrnaments(noteNode) {
        const rv = [];
        const nNodes = [...noteNode.getElementsByTagName('notations')];
        nNodes.forEach((nNode) => {
            ['articulations', 'ornaments'].forEach((typ) => {
                const articulations = [...nNode.getElementsByTagName(typ)];
                articulations.forEach((articulation) => {
                    Object.keys(XmlHelpers.ornamentXmlToSmoMap).forEach((key) => {
                        if (articulation.getElementsByTagName(key).length) {
                            const ctor = eval('globalThis.Smo.' + XmlHelpers.ornamentXmlToSmoMap[key].ctor);
                            rv.push(new ctor(XmlHelpers.ornamentXmlToSmoMap[key].params));
                        }
                    });
                });
            });
        });
        return rv;
    }
    static lyrics(noteNode) {
        const rv = [];
        const nNodes = [...noteNode.getElementsByTagName('lyric')];
        nNodes.forEach((nNode) => {
            let verse = nNode.getAttribute('number');
            const text = XmlHelpers.getTextFromElement(nNode, 'text', '_');
            const name = nNode.getAttribute('name');
            const syllabic = XmlHelpers.getTextFromElement(nNode, 'syllabic', 'end');
            // Per xml spec, verse can be specified by a string (name), as in 'chorus'
            if (!verse) {
                verse = name;
            }
            const obj = { _text: text, verse, syllabic };
            rv.push(obj);
        });
        return rv;
    }
    static getTimeAlteration(noteNode) {
        const timeNodes = XmlHelpers.getChildrenFromPath(noteNode, ['time-modification']);
        if (timeNodes.length) {
            return {
                noteCount: XmlHelpers.getNumberFromElement(timeNodes[0], 'actual-notes', 1),
                noteDuration: XmlHelpers.getNumberFromElement(timeNodes[0], 'normal-notes', 1)
            };
        }
        return null;
    }
    // ### createTextElementChild
    // In:  ../parent
    // Out: ../parent/elementName/obj[field]
    // returns elementName element.  If obj is null, just creates and returns child
    // if obj is a string, it uses it as the text value
    static createTextElementChild(parentElement, elementName, obj, field) {
        const el = parentElement.ownerDocument.createElement(elementName);
        if (obj) {
            if (typeof (obj) === 'string') {
                el.textContent = obj;
            }
            else {
                el.textContent = obj[field];
            }
        }
        parentElement.appendChild(el);
        return el;
    }
    static createAttributes(element, obj) {
        Object.keys(obj).forEach((key) => {
            const attr = element.ownerDocument.createAttribute(key);
            attr.value = obj[key];
            element.setAttributeNode(attr);
        });
    }
    static createAttribute(element, name, value) {
        const obj = {};
        obj[name] = value;
        XmlHelpers.createAttributes(element, obj);
    }
}
exports.XmlHelpers = XmlHelpers;
XmlHelpers._ticksToNoteTypeMap = serializationHelpers_1.smoSerialize.reverseMap(XmlHelpers.noteTypesToSmoMap);


/***/ }),

/***/ "./src/smo/mxml/xmlState.ts":
/*!**********************************!*\
  !*** ./src/smo/mxml/xmlState.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.XmlState = void 0;
// [Smoosic](https://github.com/AaronDavidNewman/Smoosic)
// Copyright (c) Aaron David Newman 2021.
const xmlHelpers_1 = __webpack_require__(/*! ./xmlHelpers */ "./src/smo/mxml/xmlHelpers.ts");
const scoreModifiers_1 = __webpack_require__(/*! ../data/scoreModifiers */ "./src/smo/data/scoreModifiers.ts");
const staffModifiers_1 = __webpack_require__(/*! ../data/staffModifiers */ "./src/smo/data/staffModifiers.ts");
const measureModifiers_1 = __webpack_require__(/*! ../data/measureModifiers */ "./src/smo/data/measureModifiers.ts");
const note_1 = __webpack_require__(/*! ../data/note */ "./src/smo/data/note.ts");
const noteModifiers_1 = __webpack_require__(/*! ../data/noteModifiers */ "./src/smo/data/noteModifiers.ts");
const tuplet_1 = __webpack_require__(/*! ../data/tuplet */ "./src/smo/data/tuplet.ts");
const music_1 = __webpack_require__(/*! ../data/music */ "./src/smo/data/music.ts");
const selections_1 = __webpack_require__(/*! ../xform/selections */ "./src/smo/xform/selections.ts");
/**
 * Keep state of musical objects while parsing music xml
 * @category SmoToXml
 * */
class XmlState {
    constructor() {
        this.clefInfo = [];
        this.systems = [];
        this.staffGroups = [];
        this.smoStaves = [];
        this.slurs = {};
        this.wedges = {};
        this.hairpins = [];
        this.instrument = staffModifiers_1.SmoInstrument.defaults;
        this.instrumentMap = {};
        this.globalCursor = 0;
        this.staffVoiceHash = {};
        this.endingMap = {};
        this.startRepeatMap = {};
        this.endRepeatMap = {};
        this.startBarline = measureModifiers_1.SmoBarline.barlines.singleBar;
        this.endBarline = measureModifiers_1.SmoBarline.barlines.singleBar;
        this.measureIndex = -1;
        this.completedSlurs = [];
        this.completedTies = [];
        this.verseMap = {};
        this.measureNumber = 0;
        this.formattingManager = new scoreModifiers_1.SmoFormattingManager(scoreModifiers_1.SmoFormattingManager.defaults);
        this.tuplets = {};
        this.tickCursor = 0;
        this.tempo = new measureModifiers_1.SmoTempoText(measureModifiers_1.SmoTempoText.defaults);
        this.staffArray = [];
        this.staffIndex = 0;
        this.graceNotes = [];
        this.currentDuration = 0;
        this.beamGroups = {};
        this.dynamics = [];
        this.previousNote = new note_1.SmoNote(note_1.SmoNote.defaults);
        this.completedTuplets = [];
        this.newTitle = false;
        this.divisions = 4096;
        this.keySignature = 'c';
        this.timeSignature = '4/4';
        this.voiceIndex = 0;
        this.pixelsPerTenth = 0.4;
        this.musicFontSize = 16;
        this.partId = '';
        this.rehearsalMark = '';
        this.rehearsalMarks = {};
        this.parts = {};
        this.openPartGroup = null;
    }
    static get defaults() {
        return {
            divisions: 4096, tempo: new measureModifiers_1.SmoTempoText(measureModifiers_1.SmoTempoText.defaults), timeSignature: '4/4', keySignature: 'C',
            clefInfo: [], staffGroups: [], smoStaves: []
        };
    }
    // Initialize things that persist throughout a staff
    // likc hairpins and slurs
    initializeForPart() {
        this.slurs = {};
        this.wedges = {};
        this.hairpins = [];
        this.globalCursor = 0;
        this.staffVoiceHash = {};
        this.measureIndex = -1;
        this.completedSlurs = [];
        this.verseMap = {};
        this.instrument.keyOffset = 0;
        this.instrumentMap = {};
        this.partId = '';
        this.clefInfo = [];
        this.formattingManager = new scoreModifiers_1.SmoFormattingManager(scoreModifiers_1.SmoFormattingManager.defaults);
    }
    // ### initializeForMeasure
    // reset state for a new measure:  beam groups, tuplets
    // etc. that don't cross measure boundaries
    initializeForMeasure(measureElement) {
        const oldMeasure = this.measureNumber;
        this.measureNumber =
            parseInt(measureElement.getAttribute('number'), 10) - 1;
        if (isNaN(this.measureNumber)) {
            this.measureNumber = oldMeasure + 1;
        }
        this.tuplets = {};
        this.tickCursor = 0;
        this.tempo = measureModifiers_1.SmoMeasureModifierBase.deserialize(this.tempo.serialize());
        this.tempo.display = false;
        this.staffArray = [];
        this.graceNotes = [];
        this.currentDuration = 0;
        this.beamGroups = {};
        this.completedTuplets = [];
        this.dynamics = [];
        this.startBarline = measureModifiers_1.SmoBarline.barlines.singleBar;
        this.endBarline = measureModifiers_1.SmoBarline.barlines.singleBar;
        this.previousNote = new note_1.SmoNote(note_1.SmoNote.defaults);
        this.measureIndex += 1;
        this.rehearsalMark = '';
    }
    // ### initializeStaff
    // voices are not sequential, seem to have artitrary numbers and
    // persist per part, so we treat them as a hash.
    // staff IDs persist per part but are sequential.
    initializeStaff(staffIndex, voiceIndex) {
        // If no clef is specified, default to treble
        if (typeof (this.staffArray[staffIndex]) === 'undefined') {
            this.staffArray.push({ clefInfo: { clef: 'treble', staffId: this.staffIndex }, measure: null, voices: {} });
        }
        if (typeof (this.staffArray[staffIndex].voices[voiceIndex]) === 'undefined') {
            this.staffArray[staffIndex].voices[voiceIndex] = { notes: [], ticksUsed: 0 };
            // keep track of 0-indexed voice for slurs and other modifiers
            if (!this.staffVoiceHash[staffIndex]) {
                this.staffVoiceHash[staffIndex] = [];
            }
            if (this.staffVoiceHash[staffIndex].indexOf(voiceIndex) < 0) {
                this.staffVoiceHash[staffIndex].push(voiceIndex);
            }
            // The smo 0-indexed voice index, used in selectors
            this.beamGroups[voiceIndex] = null;
        }
    }
    // ### updateStaffGroups
    // once everything is parsed, figure out how to group the staves
    updateStaffGroups() {
        this.systems = [];
        this.staffGroups.forEach((staffGroup) => {
            const len = this.smoStaves[staffGroup.start].measures.length;
            const startSelector = selections_1.SmoSelector.default;
            startSelector.staff = staffGroup.start;
            startSelector.measure = 0;
            const endSelector = selections_1.SmoSelector.default;
            endSelector.staff = staffGroup.start + (staffGroup.length - 1);
            endSelector.measure = len;
            const grpParams = scoreModifiers_1.SmoSystemGroup.defaults;
            grpParams.startSelector = startSelector;
            grpParams.endSelector = endSelector;
            grpParams.leftConnector = scoreModifiers_1.SmoSystemGroup.connectorTypes.brace;
            this.systems.push(new scoreModifiers_1.SmoSystemGroup(grpParams));
        });
    }
    addLyric(note, lyricData) {
        if (typeof (this.verseMap[lyricData.verse]) === 'undefined') {
            const keys = Object.keys(this.verseMap);
            this.verseMap[lyricData.verse] = keys.length;
        }
        lyricData.verse = this.verseMap[lyricData.verse];
        const params = noteModifiers_1.SmoLyric.defaults;
        params._text = lyricData._text;
        params.verse = lyricData.verse;
        if (lyricData.syllabic === 'begin' || lyricData.syllabic === 'middle') {
            params._text += '-';
        }
        const lyric = new noteModifiers_1.SmoLyric(params);
        note.addLyric(lyric);
    }
    /**
     * process a wedge aka hairpin dynamic
     * @param wedgeInfo
     */
    processWedge(wedgeInfo) {
        if (wedgeInfo.type) {
            // If we already know about this wedge, it must have been
            // started, so complete it
            if (this.wedges.type) {
                this.hairpins.push({
                    type: this.wedges.type,
                    start: this.wedges.start,
                    end: this.tickCursor + this.globalCursor
                });
                this.wedges = {};
            }
            else {
                this.wedges.type = wedgeInfo.type;
                this.wedges.start = this.tickCursor + this.globalCursor;
            }
        }
    }
    // ### backtrackHairpins
    // For the measure just parsed, find the correct tick for the
    // beginning and end of hairpins, if a hairpin stop directive
    // was received.  These are not associated with a staff or voice, so
    // we use the first one in the measure element for both
    backtrackHairpins(smoStaff, staffId) {
        this.hairpins.forEach((hairpin) => {
            let hpMeasureIndex = this.measureIndex;
            let hpMeasure = smoStaff.measures[hpMeasureIndex];
            let startTick = hpMeasure.voices[0].notes.length - 1;
            let hpTickCount = this.globalCursor; // All ticks read so far
            const endSelector = {
                staff: staffId - 1, measure: hpMeasureIndex, voice: 0,
                tick: -1, pitches: []
            };
            while (hpMeasureIndex >= 0 && hpTickCount > hairpin.start) {
                if (endSelector.tick < 0 && hpTickCount <= hairpin.end) {
                    endSelector.tick = startTick;
                }
                hpTickCount -= hpMeasure.voices[0].notes[startTick].ticks.numerator;
                if (hpTickCount > hairpin.start) {
                    startTick -= 1;
                    if (startTick < 0) {
                        hpMeasureIndex -= 1;
                        hpMeasure = smoStaff.measures[hpMeasureIndex];
                        startTick = hpMeasure.voices[0].notes.length - 1;
                    }
                }
            }
            const params = staffModifiers_1.SmoStaffHairpin.defaults;
            params.startSelector = {
                staff: staffId - 1, measure: hpMeasureIndex, voice: 0, tick: startTick, pitches: []
            };
            params.endSelector = endSelector;
            params.hairpinType = hairpin.type === 'crescendo' ? staffModifiers_1.SmoStaffHairpin.types.CRESCENDO : staffModifiers_1.SmoStaffHairpin.types.DECRESCENDO;
            const smoHp = new staffModifiers_1.SmoStaffHairpin(params);
            smoStaff.modifiers.push(smoHp);
        });
        this.hairpins = [];
    }
    // ### updateDynamics
    // Based on note just parsed, put the dynamics on the closest
    // note, based on the offset of dynamic
    updateDynamics() {
        const smoNote = this.previousNote;
        const tickCursor = this.tickCursor;
        const newArray = [];
        this.dynamics.forEach((dynamic) => {
            if (tickCursor >= dynamic.offset) {
                const modParams = noteModifiers_1.SmoDynamicText.defaults;
                modParams.text = dynamic.dynamic;
                // TODO: change the smonote name of this interface
                smoNote.addDynamic(new noteModifiers_1.SmoDynamicText(modParams));
            }
            else {
                newArray.push(dynamic);
            }
        });
        this.dynamics = newArray;
    }
    // For the given voice, beam the notes according to the
    // note beam length
    backtrackBeamGroup(voice, beamGroup) {
        let i = 0;
        for (i = 0; i < beamGroup.notes; ++i) {
            const note = voice.notes[voice.notes.length - (i + 1)];
            if (!note) {
                console.warn('no note for beam group');
                return;
            }
            note.endBeam = i === 0;
            note.beamBeats = beamGroup.ticks;
        }
    }
    // ### updateBeamState
    // Keep track of beam instructions found while parsing note element
    // includes time alteration from tuplets
    updateBeamState(beamState, alteration, voice, voiceIndex) {
        const note = voice.notes[voice.notes.length - 1];
        if (beamState === xmlHelpers_1.XmlHelpers.beamStates.BEGIN) {
            this.beamGroups[voiceIndex] = {
                ticks: (note.tickCount * alteration.noteCount) / alteration.noteDuration,
                notes: 1
            };
        }
        else if (this.beamGroups[voiceIndex]) {
            this.beamGroups[voiceIndex].ticks += note.tickCount;
            this.beamGroups[voiceIndex].notes += 1;
            if (beamState === xmlHelpers_1.XmlHelpers.beamStates.END) {
                this.backtrackBeamGroup(voice, this.beamGroups[voiceIndex]);
                this.beamGroups[voiceIndex] = null;
            }
        }
    }
    updateTieStates(tieInfos) {
        tieInfos.forEach((tieInfo) => {
            // tieInfo = { number, type, orientation, selector, pitchIndex }
            if (tieInfo.type === 'start') {
                this.completedTies.push(tieInfo);
            }
        });
    }
    updateEndings(barlineNode) {
        const findStartEnding = (endingNumber, ix) => {
            const endingIx = Object.keys(this.endingMap).map((xx) => parseInt(xx, 10));
            let gt = -1;
            let rv = null;
            endingIx.forEach((ee) => {
                if (ee > gt && ee <= ix) {
                    const endings = this.endingMap[ee];
                    const txt = endings.find((xx) => xx.number === endingNumber);
                    if (txt) {
                        gt = ee;
                        rv = txt;
                    }
                    if (endings.findIndex((xx) => xx.number === endingNumber) >= 0) {
                        gt = ee;
                    }
                }
            });
            if (gt >= 0) {
                return rv;
            }
            else {
                return null;
            }
        };
        const ending = xmlHelpers_1.XmlHelpers.getEnding(barlineNode);
        if (ending) {
            if (ending.type === 'start') {
                const numbers = ending.numbers;
                numbers.forEach((nn) => {
                    const endings = this.endingMap[this.measureIndex];
                    if (!endings) {
                        this.endingMap[this.measureIndex] = [];
                    }
                    const inst = this.endingMap[this.measureIndex].find((ee) => ee.number === nn);
                    if (!inst) {
                        this.endingMap[this.measureIndex].push({
                            start: this.measureIndex,
                            end: -1,
                            number: nn
                        });
                    }
                });
            }
            else {
                ending.numbers.forEach((nn) => {
                    const inst = findStartEnding(nn, this.measureIndex);
                    if (!inst) {
                        console.warn('bad ending ' + nn + ' at ' + this.measureIndex);
                    }
                    else {
                        inst.end = this.measureIndex;
                    }
                });
            }
        }
        const barline = xmlHelpers_1.XmlHelpers.getBarline(barlineNode);
        if (barline === measureModifiers_1.SmoBarline.barlines.startRepeat) {
            this.startBarline = barline;
        }
        else {
            this.endBarline = barline;
        }
    }
    /**
     * While parsing a measure,
     * on a slur element, either complete a started
     * slur or start a new one.
     * @param slurInfos
     */
    updateSlurStates(slurInfos) {
        const clef = this.staffArray[this.staffIndex].clefInfo.clef;
        const note = this.previousNote;
        const getForcedSlurDirection = (smoParams, xmlStart, xmlEnd) => {
            // If the slur direction is specified, otherwise use autor.
            if (xmlStart.placement === 'above' || (xmlEnd === null || xmlEnd === void 0 ? void 0 : xmlEnd.placement) === 'above') {
                smoParams.position_end = staffModifiers_1.SmoSlur.positions.ABOVE;
                smoParams.position = staffModifiers_1.SmoSlur.positions.ABOVE;
                if (xmlStart.orientation === 'over') {
                    smoParams.orientation = staffModifiers_1.SmoSlur.orientations.DOWN;
                }
                else if (xmlStart.orientation === 'under') {
                    smoParams.orientation = staffModifiers_1.SmoSlur.orientations.UP;
                }
            }
            else if (xmlStart.placement === 'below' || (xmlEnd === null || xmlEnd === void 0 ? void 0 : xmlEnd.placement) === 'below') {
                smoParams.position_end = staffModifiers_1.SmoSlur.positions.BELOW;
                smoParams.position = staffModifiers_1.SmoSlur.positions.BELOW;
                if (xmlStart.orientation === 'over') {
                    smoParams.orientation = staffModifiers_1.SmoSlur.orientations.DOWN;
                }
                else if (xmlStart.orientation === 'under') {
                    smoParams.orientation = staffModifiers_1.SmoSlur.orientations.UP;
                }
            }
        };
        slurInfos.forEach((slurInfo) => {
            // slurInfo = { number, type, selector }
            if (slurInfo.type === 'start') {
                const slurParams = staffModifiers_1.SmoSlur.defaults;
                // if start and stop come out of order
                if (this.slurs[slurInfo.number] && this.slurs[slurInfo.number].type === 'stop') {
                    slurParams.endSelector = JSON.parse(JSON.stringify(this.slurs[slurInfo.number].selector));
                    slurParams.startSelector = slurInfo.selector;
                    slurParams.cp1x = slurInfo.controlX;
                    slurParams.cp1y = slurInfo.controlY;
                    const slurType = this.slurs[slurInfo.number];
                    getForcedSlurDirection(slurParams, slurInfo, slurType);
                    this.completedSlurs.push(slurParams);
                    this.slurs[slurInfo.number] = null;
                }
                else {
                    // We no longer try to pick the slur direction until the score is complete.
                    this.slurs[slurInfo.number] = JSON.parse(JSON.stringify(slurInfo));
                }
            }
            else if (slurInfo.type === 'stop') {
                if (this.slurs[slurInfo.number] && this.slurs[slurInfo.number].type === 'start') {
                    const slurData = this.slurs[slurInfo.number];
                    const slurParams = staffModifiers_1.SmoSlur.defaults;
                    slurParams.startSelector = JSON.parse(JSON.stringify(this.slurs[slurInfo.number].selector));
                    slurParams.endSelector = slurInfo.selector;
                    slurParams.cp2x = slurInfo.controlX;
                    slurParams.cp2y = slurInfo.controlY;
                    slurParams.yOffset = slurData.yOffset;
                    const slurType = this.slurs[slurInfo.number];
                    getForcedSlurDirection(slurParams, slurInfo, slurType);
                    // console.log('complete slur ' + slurInfo.number + JSON.stringify(slurParams, null, ' '));
                    this.completedSlurs.push(slurParams);
                    this.slurs[slurInfo.number] = null;
                }
                else {
                    this.slurs[slurInfo.number] = JSON.parse(JSON.stringify(slurInfo));
                }
            }
        });
    }
    assignRehearsalMarks() {
        Object.keys(this.rehearsalMarks).forEach((rm) => {
            const measureIx = parseInt(rm, 10);
            this.smoStaves.forEach((staff) => {
                const mark = new measureModifiers_1.SmoRehearsalMark(measureModifiers_1.SmoRehearsalMark.defaults);
                staff.addRehearsalMark(measureIx, mark);
            });
        });
    }
    /**
     * After reading in a measure, update any completed slurs and make them
     * into SmoSlur and add them to the SmoSystemGroup objects.
     * staffIndexOffset is the offset from the xml staffId and the score staff Id
     * (i.e. the staves that have already been parsed in other parts)
     */
    completeSlurs() {
        this.completedSlurs.forEach((slur) => {
            const smoSlur = new staffModifiers_1.SmoSlur(slur);
            this.smoStaves[slur.startSelector.staff].addStaffModifier(smoSlur);
        });
    }
    /**
     * Go through saved start ties, try to find the endpoint of the tie.  Ties in music xml
     * are a little ambiguous, we assume we are tying to the same pitch
     * @param score
     */
    completeTies(score) {
        this.completedTies.forEach((tieInfo) => {
            const startSelection = selections_1.SmoSelection.noteFromSelector(score, tieInfo.selector);
            if (startSelection && startSelection.note) {
                const startNote = startSelection.note;
                const endSelection = selections_1.SmoSelection.nextNoteSelectionFromSelector(score, startSelection.selector);
                const endNote = endSelection === null || endSelection === void 0 ? void 0 : endSelection.note;
                const pitches = [];
                if (endSelection && endNote) {
                    startNote.pitches.forEach((spitch, ix) => {
                        endNote.pitches.forEach((epitch, jx) => {
                            if (music_1.SmoMusic.smoPitchToInt(spitch) === music_1.SmoMusic.smoPitchToInt(epitch)) {
                                pitches.push({ from: ix, to: jx });
                            }
                        });
                    });
                }
                if (pitches.length && endSelection) {
                    const params = staffModifiers_1.SmoTie.defaults;
                    params.startSelector = startSelection.selector;
                    params.endSelector = endSelection.selector;
                    params.lines = pitches;
                    const smoTie = new staffModifiers_1.SmoTie(params);
                    score.staves[smoTie.startSelector.staff].addStaffModifier(smoTie);
                }
            }
        });
    }
    // ### backtrackTuplets
    // If we received a tuplet end, go back through the voice
    // and construct the SmoTuplet.
    backtrackTuplets(voice, tupletNumber, staffId, voiceId) {
        const tupletState = this.tuplets[tupletNumber];
        let i = tupletState.start.tick;
        const notes = [];
        const durationMap = [];
        while (i < voice.notes.length) {
            const note = voice.notes[i];
            notes.push(note);
            if (i === tupletState.start.tick) {
                durationMap.push(1.0);
            }
            else {
                const prev = voice.notes[i - 1];
                durationMap.push(note.ticks.numerator / prev.ticks.numerator);
            }
            i += 1;
        }
        const tp = tuplet_1.SmoTuplet.defaults;
        tp.notes = notes;
        tp.durationMap = durationMap;
        tp.voice = voiceId;
        const tuplet = new tuplet_1.SmoTuplet(tp);
        // Store the tuplet with the staff ID and voice so we
        // can add it to the right measure when it's created.
        this.completedTuplets.push({ tuplet, staffId, voiceId });
    }
    // ### updateTupletStates
    // react to a tuplet start or stop directive
    updateTupletStates(tupletInfos, voice, staffIndex, voiceIndex) {
        const tick = voice.notes.length - 1;
        tupletInfos.forEach((tupletInfo) => {
            if (tupletInfo.type === 'start') {
                this.tuplets[tupletInfo.number] = {
                    start: { staff: staffIndex, measure: this.measureNumber, voice: voiceIndex, tick, pitches: [] },
                    end: selections_1.SmoSelector.default
                };
            }
            else if (tupletInfo.type === 'stop') {
                this.tuplets[tupletInfo.number].end = {
                    staff: staffIndex, measure: this.measureNumber, voice: voiceIndex, tick, pitches: []
                };
                this.backtrackTuplets(voice, tupletInfo.number, staffIndex, voiceIndex);
            }
        });
    }
    addTupletsToMeasure(smoMeasure, staffId, voiceId) {
        const completed = [];
        this.completedTuplets.forEach((tuplet) => {
            if (tuplet.voiceId === voiceId && tuplet.staffId === staffId) {
                smoMeasure.tuplets.push(tuplet.tuplet);
            }
            else {
                completed.push(tuplet);
            }
        });
        this.completedTuplets = completed;
    }
    getSystems() {
        const rv = [];
        this.systems.forEach((system) => {
            const params = scoreModifiers_1.SmoSystemGroup.defaults;
            params.startSelector = system.startSelector;
            params.endSelector = system.endSelector;
            params.leftConnector = system.leftConnector;
            rv.push(new scoreModifiers_1.SmoSystemGroup(params));
        });
        return rv;
    }
}
exports.XmlState = XmlState;


/***/ }),

/***/ "./src/smo/mxml/xmlToSmo.ts":
/*!**********************************!*\
  !*** ./src/smo/mxml/xmlToSmo.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.XmlToSmo = void 0;
// [Smoosic](https://github.com/AaronDavidNewman/Smoosic)
// Copyright (c) Aaron David Newman 2021.
/**
 * Logic to convert music XML (finale) to Smo internal format
 * @module XmlToSmo
 */
const xmlHelpers_1 = __webpack_require__(/*! ./xmlHelpers */ "./src/smo/mxml/xmlHelpers.ts");
const xmlState_1 = __webpack_require__(/*! ./xmlState */ "./src/smo/mxml/xmlState.ts");
const scoreModifiers_1 = __webpack_require__(/*! ../data/scoreModifiers */ "./src/smo/data/scoreModifiers.ts");
const scoreText_1 = __webpack_require__(/*! ../data/scoreText */ "./src/smo/data/scoreText.ts");
const measureModifiers_1 = __webpack_require__(/*! ../data/measureModifiers */ "./src/smo/data/measureModifiers.ts");
const score_1 = __webpack_require__(/*! ../data/score */ "./src/smo/data/score.ts");
const measure_1 = __webpack_require__(/*! ../data/measure */ "./src/smo/data/measure.ts");
const music_1 = __webpack_require__(/*! ../data/music */ "./src/smo/data/music.ts");
const noteModifiers_1 = __webpack_require__(/*! ../data/noteModifiers */ "./src/smo/data/noteModifiers.ts");
const systemStaff_1 = __webpack_require__(/*! ../data/systemStaff */ "./src/smo/data/systemStaff.ts");
const note_1 = __webpack_require__(/*! ../data/note */ "./src/smo/data/note.ts");
const operations_1 = __webpack_require__(/*! ../xform/operations */ "./src/smo/xform/operations.ts");
const staffModifiers_1 = __webpack_require__(/*! ../data/staffModifiers */ "./src/smo/data/staffModifiers.ts");
const partInfo_1 = __webpack_require__(/*! ../data/partInfo */ "./src/smo/data/partInfo.ts");
/**
 * A class that takes a music XML file and outputs a {@link SmoScore}
 * @category SmoToXml
 */
class XmlToSmo {
    static get mmPerPixel() {
        return 0.264583;
    }
    /**
     * Vex renders everything as if the font size were 39
     */
    static get vexFontSize() {
        return 39;
    }
    static get customProportionDefault() {
        var _a, _b;
        return (_b = (_a = score_1.SmoScore.defaults.layoutManager) === null || _a === void 0 ? void 0 : _a.getGlobalLayout().proportionality) !== null && _b !== void 0 ? _b : 0;
    }
    static get pageLayoutMap() {
        return [
            { xml: 'page-height', smo: 'pageHeight' },
            { xml: 'page-width', smo: 'pageWidth' }
        ];
    }
    static get pageMarginMap() {
        return [
            { xml: 'left-margin', smo: 'leftMargin' },
            { xml: 'right-margin', smo: 'rightMargin' },
            { xml: 'top-margin', smo: 'topMargin' },
            { xml: 'bottom-margin', smo: 'bottomMargin' }
        ];
    }
    static get scoreInfoFields() {
        return ['title', 'subTitle', 'composer', 'copyright'];
    }
    /**
     * Convert music XML file from parsed xml to a {@link SmoScore}
     * @param xmlDoc
     * @returns
     */
    static convert(xmlDoc) {
        try {
            const scoreRoots = [...xmlDoc.getElementsByTagName('score-partwise')];
            if (!scoreRoots.length) {
                // no score node
                return score_1.SmoScore.getDefaultScore(score_1.SmoScore.defaults, measure_1.SmoMeasure.defaults);
            }
            const scoreRoot = scoreRoots[0];
            const rv = new score_1.SmoScore(score_1.SmoScore.defaults);
            rv.staves = [];
            const layoutDefaults = rv.layoutManager;
            // if no scale given in score, default to something small.
            layoutDefaults.globalLayout.svgScale = 0.5;
            layoutDefaults.globalLayout.zoomScale = 1.0;
            const xmlState = new xmlState_1.XmlState();
            xmlState.newTitle = false;
            rv.scoreInfo.name = 'Imported Smoosic';
            XmlToSmo.scoreInfoFields.forEach((field) => {
                rv.scoreInfo[field] = '';
            });
            const childNodes = [...scoreRoot.children];
            childNodes.forEach((scoreElement) => {
                if (scoreElement.tagName === 'work') {
                    const scoreNameNode = [...scoreElement.getElementsByTagName('work-title')];
                    if (scoreNameNode.length && scoreNameNode[0].textContent) {
                        rv.scoreInfo.title = scoreNameNode[0].textContent;
                        rv.scoreInfo.name = rv.scoreInfo.title;
                        xmlState.newTitle = true;
                    }
                }
                else if (scoreElement.tagName === 'identification') {
                    const creators = [...scoreElement.getElementsByTagName('creator')];
                    creators.forEach((creator) => {
                        if (creator.getAttribute('type') === 'composer' && creator.textContent) {
                            rv.scoreInfo.composer = creator.textContent;
                        }
                    });
                }
                else if (scoreElement.tagName === 'movement-title') {
                    if (xmlState.newTitle && scoreElement.textContent) {
                        rv.scoreInfo.subTitle = scoreElement.textContent;
                    }
                    else if (scoreElement.textContent) {
                        rv.scoreInfo.title = scoreElement.textContent;
                        rv.scoreInfo.name = rv.scoreInfo.title;
                        xmlState.newTitle = true;
                    }
                }
                else if (scoreElement.tagName === 'defaults') {
                    XmlToSmo.defaults(scoreElement, rv, layoutDefaults, xmlState);
                }
                else if (scoreElement.tagName === 'part') {
                    xmlState.initializeForPart();
                    XmlToSmo.part(scoreElement, xmlState);
                }
                else if (scoreElement.tagName === 'part-list') {
                    XmlToSmo.partList(scoreElement, rv, xmlState);
                }
            });
            // The entire score is parsed and xmlState now contains the staves.
            rv.formattingManager = xmlState.formattingManager;
            rv.staves = xmlState.smoStaves;
            xmlState.updateStaffGroups();
            rv.systemGroups = xmlState.getSystems();
            // Fix tempo to be column mapped
            rv.staves[0].measures.forEach((measure) => {
                const tempoStaff = rv.staves.find((ss) => ss.measures[measure.measureNumber.measureIndex].tempo.display === true);
                if (tempoStaff) {
                    const tempo = tempoStaff.measures[measure.measureNumber.measureIndex].tempo;
                    rv.staves.forEach((ss) => {
                        ss.measures[measure.measureNumber.measureIndex].tempo =
                            measureModifiers_1.SmoMeasureModifierBase.deserialize(tempo);
                    });
                }
            });
            const lm = rv.layoutManager;
            if (rv.scoreInfo.title) {
                rv.addTextGroup(scoreText_1.SmoTextGroup.createTextForLayout(scoreText_1.SmoTextGroup.purposes.TITLE, rv.scoreInfo.title, lm.getScaledPageLayout(0)));
            }
            if (rv.scoreInfo.subTitle) {
                rv.addTextGroup(scoreText_1.SmoTextGroup.createTextForLayout(scoreText_1.SmoTextGroup.purposes.SUBTITLE, rv.scoreInfo.subTitle, lm.getScaledPageLayout(0)));
            }
            if (rv.scoreInfo.composer) {
                rv.addTextGroup(scoreText_1.SmoTextGroup.createTextForLayout(scoreText_1.SmoTextGroup.purposes.COMPOSER, rv.scoreInfo.composer, lm.getScaledPageLayout(0)));
            }
            XmlToSmo.setSlurDefaults(rv);
            xmlState.completeTies(rv);
            rv.preferences.showPiano = false;
            XmlToSmo.setVoltas(rv, xmlState);
            rv.staves.forEach((staff) => {
            });
            return rv;
        }
        catch (exc) {
            console.warn(exc);
            return score_1.SmoScore.getDefaultScore(score_1.SmoScore.defaults, measure_1.SmoMeasure.defaults);
        }
    }
    /**
     * when building the slurs, we don't always know which direction the beams will go or what other
     * voices there will be.
     * @param score
     */
    static setSlurDefaults(score) {
        score.staves.forEach((staff) => {
            const slurs = staff.modifiers.filter((mm) => mm.ctor === 'SmoSlur');
            slurs.forEach((ss) => {
                const slur = ss;
                let slurPosition = staffModifiers_1.SmoSlur.positions.AUTO;
                if (slur.position === slur.position_end) {
                    slurPosition = slur.position;
                }
                const slurParams = operations_1.SmoOperation.getDefaultSlurDirection(score, ss.startSelector, ss.endSelector, slurPosition, slur.orientation);
                slur.position = slurParams.position;
                slur.position_end = slurParams.position_end;
                slur.invert = slurParams.invert;
                slur.yOffset = slurParams.yOffset;
                slur.cp1y = slurParams.cp1y;
                slur.cp2y = slurParams.cp2y;
                slur.xOffset = slurParams.xOffset;
            });
        });
    }
    /**
     * After parsing the XML, resolve the voltas we've saved
     * @param score
     * @param state
     */
    static setVoltas(score, state) {
        const endingMeasures = Object.keys(state.endingMap).map((k) => parseInt(k, 10));
        endingMeasures.forEach((em) => {
            const endings = state.endingMap[em];
            endings.forEach((ending) => {
                const defs = measureModifiers_1.SmoVolta.defaults;
                defs.number = ending.number;
                defs.startBar = ending.start;
                defs.endBar = ending.end >= 0 ? ending.end : ending.start;
                const volta = new measureModifiers_1.SmoVolta(defs);
                operations_1.SmoOperation.addEnding(score, volta);
            });
        });
    }
    static partList(partList, score, state) {
        const children = partList.children;
        let partIndex = 0;
        var i = 0;
        for (i = 0; i < children.length; ++i) {
            const child = children[i];
            if (child.tagName === 'score-part') {
                const partElement = child;
                const partData = new partInfo_1.SmoPartInfo(partInfo_1.SmoPartInfo.defaults);
                partData.partName = xmlHelpers_1.XmlHelpers.getTextFromElement(partElement, 'part-name', 'part ' + i);
                const partId = xmlHelpers_1.XmlHelpers.getTextFromAttribute(partElement, 'id', i.toString());
                if (state.openPartGroup) {
                    state.openPartGroup.parts.push(partIndex);
                }
                partIndex += 1;
                state.parts[partId] = partData;
                partData.partAbbreviation = xmlHelpers_1.XmlHelpers.getTextFromElement(partElement, 'part-abbreviation', 'p.');
                partData.midiDevice = xmlHelpers_1.XmlHelpers.getTextFromElement(partElement, 'part-abbreviation', null);
                // it seems like musicxml doesn't allow for different music font size in parts vs. score
                // partData.layoutManager.globalLayout.svgScale = 0.55;
                partData.layoutManager.globalLayout.svgScale = state.musicFontSize / XmlToSmo.vexFontSize;
                const midiElements = partElement.getElementsByTagName('midi-instrument');
                if (midiElements.length) {
                    const midiElement = midiElements[0];
                    partData.midiInstrument = {
                        channel: xmlHelpers_1.XmlHelpers.getNumberFromElement(midiElement, 'midi-channel', 1),
                        program: xmlHelpers_1.XmlHelpers.getNumberFromElement(midiElement, 'midi-program', 1),
                        volume: xmlHelpers_1.XmlHelpers.getNumberFromElement(midiElement, 'volume', 80),
                        pan: xmlHelpers_1.XmlHelpers.getNumberFromElement(midiElement, 'pan', 0)
                    };
                }
            }
            else if (child.tagName === 'part-group') {
                const groupElement = child;
                if (state.openPartGroup) {
                    const staffGroup = state.openPartGroup.group;
                    state.openPartGroup.parts.forEach((part) => {
                        if (staffGroup.startSelector.staff === 0 || staffGroup.startSelector.staff > part) {
                            staffGroup.startSelector.staff = part;
                        }
                        if (staffGroup.endSelector.staff < part) {
                            staffGroup.endSelector.staff = part;
                        }
                    });
                    score.systemGroups.push(staffGroup);
                    state.openPartGroup = null;
                }
                else {
                    const staffGroup = new scoreModifiers_1.SmoSystemGroup(scoreModifiers_1.SmoSystemGroup.defaults);
                    const groupNum = xmlHelpers_1.XmlHelpers.getNumberFromAttribute(groupElement, 'number', 1);
                    const xmlSymbol = xmlHelpers_1.XmlHelpers.getTextFromElement(groupElement, 'group-symbol', 'single');
                    if (xmlSymbol === 'single') {
                        staffGroup.leftConnector = scoreModifiers_1.SmoSystemGroup.connectorTypes['single'];
                    }
                    else if (xmlSymbol === 'brace') {
                        staffGroup.leftConnector = scoreModifiers_1.SmoSystemGroup.connectorTypes['brace'];
                    }
                    if (xmlSymbol === 'bracket') {
                        staffGroup.leftConnector = scoreModifiers_1.SmoSystemGroup.connectorTypes['bracket'];
                    }
                    if (xmlSymbol === 'square') {
                        staffGroup.leftConnector = scoreModifiers_1.SmoSystemGroup.connectorTypes['double'];
                    }
                    state.openPartGroup = {
                        partNum: groupNum,
                        parts: [],
                        group: staffGroup
                    };
                }
            }
        }
    }
    /**
     * page-layout element occurs in a couple of places
     * @param defaultsElement
     * @param layoutDefaults
     * @param xmlState
     */
    static pageSizeFromLayout(defaultsElement, layoutDefaults, xmlState) {
        const pageLayoutNode = defaultsElement.getElementsByTagName('page-layout');
        if (pageLayoutNode.length) {
            xmlHelpers_1.XmlHelpers.assignDefaults(pageLayoutNode[0], layoutDefaults.globalLayout, XmlToSmo.pageLayoutMap);
            layoutDefaults.globalLayout.pageHeight *= xmlState.pixelsPerTenth;
            layoutDefaults.globalLayout.pageWidth *= xmlState.pixelsPerTenth;
        }
        const pageMarginNode = xmlHelpers_1.XmlHelpers.getChildrenFromPath(defaultsElement, ['page-layout', 'page-margins']);
        if (pageMarginNode.length) {
            xmlHelpers_1.XmlHelpers.assignDefaults(pageMarginNode[0], layoutDefaults.pageLayouts[0], XmlToSmo.pageMarginMap);
            scoreModifiers_1.SmoPageLayout.attributes.forEach((attr) => {
                layoutDefaults.pageLayouts[0][attr] *= xmlState.pixelsPerTenth;
            });
        }
    }
    /**
     * /score-partwise/defaults
     * @param defaultsElement
     * @param score
     * @param layoutDefaults
     */
    static defaults(defaultsElement, score, layoutDefaults, xmlState) {
        // Default scale for mxml
        let scale = 1 / 7;
        const currentScale = layoutDefaults.getGlobalLayout().svgScale;
        const scaleNode = defaultsElement.getElementsByTagName('scaling');
        if (scaleNode.length) {
            const mm = xmlHelpers_1.XmlHelpers.getNumberFromElement(scaleNode[0], 'millimeters', 1);
            const tn = xmlHelpers_1.XmlHelpers.getNumberFromElement(scaleNode[0], 'tenths', 7);
            if (tn > 0 && mm > 0) {
                scale = mm / tn;
            }
        }
        const fontNode = defaultsElement.getElementsByTagName('music-font');
        // All musicxml sizes are given in 'tenths'.  Smoosic and vex use pixels. so find the ratio and 
        // normalize all values.
        xmlState.pixelsPerTenth = scale / XmlToSmo.mmPerPixel;
        if (fontNode.length) {
            const fontString = fontNode[0].getAttribute('font-size');
            if (fontString) {
                xmlState.musicFontSize = parseInt(fontString, 10);
            }
            const fontFamily = fontNode[0].getAttribute('font-family');
            if (fontFamily && (0, score_1.isEngravingFont)(fontFamily)) {
                score.engravingFont = fontFamily;
            }
        }
        XmlToSmo.pageSizeFromLayout(defaultsElement, layoutDefaults, xmlState);
        // svgScale is the ratio of music font size to the default Vex font size (39).
        layoutDefaults.globalLayout.svgScale = xmlState.musicFontSize / XmlToSmo.vexFontSize;
        score.scaleTextGroups(currentScale / layoutDefaults.globalLayout.svgScale);
    }
    /**
     * /score-partwise/part
     * @param partElement
     * @param xmlState
     */
    static part(partElement, xmlState) {
        let staffId = xmlState.smoStaves.length;
        const partId = xmlHelpers_1.XmlHelpers.getTextFromAttribute(partElement, 'id', '');
        console.log('part ' + partId);
        xmlState.initializeForPart();
        xmlState.partId = partId;
        const stavesForPart = [];
        const measureElements = [...partElement.getElementsByTagName('measure')];
        measureElements.forEach((measureElement) => {
            // Parse the measure element, populate staffArray of xmlState with the
            // measure data
            XmlToSmo.measure(measureElement, xmlState);
            const newStaves = xmlState.staffArray;
            if (newStaves.length > 1 && stavesForPart.length <= newStaves[0].clefInfo.staffId) {
                xmlState.staffGroups.push({ start: staffId, length: newStaves.length });
            }
            xmlState.globalCursor += newStaves[0].measure.getMaxTicksVoice();
            newStaves.forEach((staffMeasure) => {
                if (stavesForPart.length <= staffMeasure.clefInfo.staffId) {
                    const params = systemStaff_1.SmoSystemStaff.defaults;
                    params.staffId = staffId;
                    params.measureInstrumentMap = xmlState.instrumentMap;
                    const newStaff = new systemStaff_1.SmoSystemStaff(params);
                    if (xmlState.parts[partId]) {
                        console.log('putting part ' + partId + ' in staff ' + newStaff.staffId);
                        newStaff.partInfo = new partInfo_1.SmoPartInfo(xmlState.parts[partId]);
                    }
                    console.log('createing stave ' + newStaff.staffId);
                    stavesForPart.push(newStaff);
                    staffId += 1;
                }
                const smoStaff = stavesForPart[staffMeasure.clefInfo.staffId];
                smoStaff.measures.push(staffMeasure.measure);
            });
            const oldStaffId = staffId - stavesForPart.length;
            xmlState.backtrackHairpins(stavesForPart[0], oldStaffId + 1);
        });
        if (stavesForPart.length > 1) {
            stavesForPart[0].partInfo.stavesAfter = 1;
            stavesForPart[0].partInfo.stavesBefore = 0;
            console.log('part has stave after ' + stavesForPart[0].staffId);
            stavesForPart[1].partInfo.stavesAfter = 0;
            stavesForPart[1].partInfo.stavesBefore = 1;
            console.log('part has stave before ' + stavesForPart[1].staffId);
        }
        xmlState.smoStaves = xmlState.smoStaves.concat(stavesForPart);
        xmlState.completeSlurs();
        xmlState.assignRehearsalMarks();
    }
    /**
     * /score-partwise/measure/direction/sound:tempo
     * @param element
     * @returns
     */
    static tempo(element) {
        let tempoText = '';
        let customText = tempoText;
        const rv = [];
        const soundNodes = xmlHelpers_1.XmlHelpers.getChildrenFromPath(element, ['sound']);
        soundNodes.forEach((sound) => {
            let tempoMode = measureModifiers_1.SmoTempoText.tempoModes.durationMode;
            tempoText = sound.getAttribute('tempo');
            if (tempoText) {
                const bpm = parseInt(tempoText, 10);
                const wordNode = [...element.getElementsByTagName('words')];
                tempoText = wordNode.length ? wordNode[0].textContent :
                    tempoText.toString();
                if (isNaN(parseInt(tempoText, 10))) {
                    if (measureModifiers_1.SmoTempoText.tempoTexts[tempoText.toLowerCase()]) {
                        tempoMode = measureModifiers_1.SmoTempoText.tempoModes.textMode;
                    }
                    else {
                        tempoMode = measureModifiers_1.SmoTempoText.tempoModes.customMode;
                        customText = tempoText;
                    }
                }
                const params = measureModifiers_1.SmoTempoText.defaults;
                params.tempoMode = tempoMode;
                params.bpm = bpm;
                params.tempoText = tempoText;
                params.customText = customText;
                params.display = true;
                const tempo = new measureModifiers_1.SmoTempoText(params);
                const staffId = xmlHelpers_1.XmlHelpers.getStaffId(element);
                rv.push({ staffId, tempo });
            }
        });
        return rv;
    }
    /**
     * /score-partwise/measure/direction/dynamics
     * @param element
     * @returns
     */
    static dynamics(directionElement, xmlState) {
        let offset = 1;
        const dynamicNodes = xmlHelpers_1.XmlHelpers.getChildrenFromPath(directionElement, ['direction-type', 'dynamics']);
        const rehearsalNodes = xmlHelpers_1.XmlHelpers.getChildrenFromPath(directionElement, ['direction-type', 'rehearsal']);
        const offsetNodes = xmlHelpers_1.XmlHelpers.getChildrenFromPath(directionElement, ['offset']);
        if (offsetNodes.length) {
            offset = parseInt(offsetNodes[0].textContent, 10);
        }
        if (rehearsalNodes.length) {
            const rm = rehearsalNodes[0].textContent;
            if (rm) {
                xmlState.rehearsalMark = rm;
            }
        }
        dynamicNodes.forEach((dynamic) => {
            xmlState.dynamics.push({
                dynamic: dynamic.children[0].tagName,
                offset: (offset / xmlState.divisions) * 4096
            });
        });
    }
    // ### attributes
    // /score-partwise/part/measure/attributes
    static attributes(measureElement, xmlState) {
        let smoKey = {};
        const attributesNodes = xmlHelpers_1.XmlHelpers.getChildrenFromPath(measureElement, ['attributes']);
        if (!attributesNodes.length) {
            return;
        }
        const attributesNode = attributesNodes[0];
        xmlState.divisions =
            xmlHelpers_1.XmlHelpers.getNumberFromElement(attributesNode, 'divisions', xmlState.divisions);
        const keyNode = xmlHelpers_1.XmlHelpers.getChildrenFromPath(attributesNode, ['key']);
        // MusicXML expresses keys in 'fifths' from C.
        if (keyNode.length) {
            const fifths = xmlHelpers_1.XmlHelpers.getNumberFromElement(keyNode[0], 'fifths', 0);
            if (fifths < 0) {
                smoKey = music_1.SmoMusic.circleOfFifths[music_1.SmoMusic.circleOfFifths.length + fifths];
            }
            else {
                smoKey = music_1.SmoMusic.circleOfFifths[fifths];
            }
            xmlState.keySignature = smoKey.letter.toUpperCase();
            if (smoKey.accidental !== 'n') {
                xmlState.keySignature += smoKey.accidental;
            }
        }
        const transposeNode = xmlHelpers_1.XmlHelpers.getChildrenFromPath(attributesNode, ['transpose']);
        if (transposeNode.length) {
            const offset = xmlHelpers_1.XmlHelpers.getNumberFromElement(transposeNode[0], 'chromatic', 0);
            if (offset !== xmlState.instrument.keyOffset) {
                xmlState.instrument.keyOffset = -1 * offset;
                if (xmlState.instrumentMap[xmlState.measureIndex]) {
                    xmlState.instrumentMap[xmlState.measureIndex].keyOffset = xmlState.instrument.keyOffset;
                }
                else {
                    const params = xmlState.instrument;
                    xmlState.instrumentMap[xmlState.measureIndex] = new staffModifiers_1.SmoInstrument(params);
                }
            }
        }
        const currentTime = xmlState.timeSignature.split('/');
        const timeNodes = xmlHelpers_1.XmlHelpers.getChildrenFromPath(attributesNode, ['time']);
        if (timeNodes.length) {
            const timeNode = timeNodes[0];
            const num = xmlHelpers_1.XmlHelpers.getNumberFromElement(timeNode, 'beats', parseInt(currentTime[0], 10));
            const den = xmlHelpers_1.XmlHelpers.getNumberFromElement(timeNode, 'beat-type', parseInt(currentTime[1], 10));
            xmlState.timeSignature = '' + num + '/' + den;
        }
        const clefNodes = xmlHelpers_1.XmlHelpers.getChildrenFromPath(attributesNode, ['clef']);
        if (clefNodes.length) {
            // We expect the number of clefs to equal the number of staves in each measure
            clefNodes.forEach((clefNode) => {
                let clefNum = 0;
                let clef = 'treble';
                const clefAttrs = xmlHelpers_1.XmlHelpers.nodeAttributes(clefNode);
                if (typeof (clefAttrs.number) !== 'undefined') {
                    // staff numbers index from 1 in mxml
                    clefNum = parseInt(clefAttrs.number, 10) - 1;
                }
                const clefType = xmlHelpers_1.XmlHelpers.getTextFromElement(clefNode, 'sign', 'G');
                const clefLine = xmlHelpers_1.XmlHelpers.getNumberFromElement(clefNode, 'line', 2);
                // mxml supports a zillion clefs, just implement the basics.
                if (clefType === 'F') {
                    clef = 'bass';
                }
                else if (clefType === 'C') {
                    if (clefLine === 4) {
                        clef = 'alto';
                    }
                    else if (clefLine === 3) {
                        clef = 'tenor';
                    }
                    else if (clefLine === 1) {
                        clef = 'soprano';
                    }
                }
                else if (clefType === 'percussion') {
                    clef = 'percussion';
                }
                if (xmlState.clefInfo.length <= clefNum) {
                    xmlState.clefInfo.push({ clef, staffId: clefNum });
                }
                else {
                    xmlState.clefInfo[clefNum].clef = clef;
                }
            });
        }
    }
    // ### wedge (hairpin)
    // /score-partwise/part/measure/direction/direction-type/wedge
    static wedge(directionElement, xmlState) {
        let crescInfo = null;
        const wedgeNodes = xmlHelpers_1.XmlHelpers.getChildrenFromPath(directionElement, ['direction-type', 'wedge']);
        wedgeNodes.forEach((wedgeNode) => {
            crescInfo = { type: wedgeNode.getAttribute('type') };
        });
        // If this is a start hairpin, start it.  If an end hairpin, add it to the
        // hairpin array with the type and start/stop ticks
        if (crescInfo !== null) {
            xmlState.processWedge(crescInfo);
        }
    }
    // ### direction
    // /score-partwise/part/measure/direction
    static direction(directionElement, xmlState) {
        const tempo = XmlToSmo.tempo(directionElement);
        // Only display tempo if changes.
        if (tempo.length) {
            // TODO: staff ID is with tempo, but tempo is per column in SMO
            if (!measureModifiers_1.SmoTempoText.eq(xmlState.tempo, tempo[0].tempo)) {
                xmlState.tempo = tempo[0].tempo;
                xmlState.tempo.display = true;
            }
        }
        // parse dynamic node and add to xmlState
        XmlToSmo.dynamics(directionElement, xmlState);
        // parse wedge (hairpin)
        XmlToSmo.wedge(directionElement, xmlState);
    }
    // ### note
    // /score-partwise/part/measure/note
    static note(noteElement, xmlState) {
        let grIx = 0;
        const staffIndex = xmlHelpers_1.XmlHelpers.getStaffId(noteElement);
        xmlState.staffIndex = staffIndex;
        // We assume the clef information from attributes comes before the notes
        // xmlState.staffArray[staffIndex] = { clefInfo: { clef }, voices[voiceIndex]: notes[] }
        if (xmlState.staffArray.length <= staffIndex) {
            // mxml has measures for all staves in a part interleaved.  In SMO they are
            // each in a separate stave object.  Base the staves we expect based on
            // the number of clefs in the xml state object
            xmlState.clefInfo.forEach((clefInfo) => {
                xmlState.staffArray.push({ clefInfo, measure: null, voices: {} });
            });
        }
        const chordNode = xmlHelpers_1.XmlHelpers.getChildrenFromPath(noteElement, ['chord']);
        if (chordNode.length === 0) {
            xmlState.currentDuration += xmlHelpers_1.XmlHelpers.durationFromNode(noteElement, 0);
        }
        // voices are not sequential, seem to have artitrary numbers and
        // persist per part (same with staff IDs).  Update XML state if these are new
        // staves
        const voiceIndex = xmlHelpers_1.XmlHelpers.getVoiceId(noteElement);
        xmlState.voiceIndex = voiceIndex;
        xmlState.initializeStaff(staffIndex, voiceIndex);
        const voice = xmlState.staffArray[staffIndex].voices[voiceIndex];
        // Calculate the tick and staff index for selectors
        const tickIndex = chordNode.length < 1 ? voice.notes.length : voice.notes.length - 1;
        const smoVoiceIndex = xmlState.staffVoiceHash[staffIndex].indexOf(voiceIndex);
        const pitchIndex = chordNode.length ? xmlState.previousNote.pitches.length : 0;
        const smoStaffIndex = xmlState.smoStaves.length + staffIndex;
        const selector = {
            staff: smoStaffIndex, measure: xmlState.measureIndex, voice: smoVoiceIndex,
            tick: tickIndex, pitches: []
        };
        const divisions = xmlState.divisions;
        const printText = noteElement.getAttribute('print-object');
        const hideNote = typeof (printText) === 'string' && printText === 'no';
        const isGrace = xmlHelpers_1.XmlHelpers.isGrace(noteElement);
        const restNode = xmlHelpers_1.XmlHelpers.getChildrenFromPath(noteElement, ['rest']);
        const noteType = restNode.length ? 'r' : 'n';
        const durationData = xmlHelpers_1.XmlHelpers.ticksFromDuration(noteElement, divisions, 4096);
        const tickCount = durationData.tickCount;
        if (chordNode.length === 0) {
            xmlState.staffArray[staffIndex].voices[voiceIndex].ticksUsed += tickCount;
        }
        xmlState.tickCursor = (xmlState.currentDuration / divisions) * 4096;
        const beamState = xmlHelpers_1.XmlHelpers.noteBeamState(noteElement);
        const slurInfos = xmlHelpers_1.XmlHelpers.getSlurData(noteElement, selector);
        const tieInfos = xmlHelpers_1.XmlHelpers.getTieData(noteElement, selector, pitchIndex);
        const tupletInfos = xmlHelpers_1.XmlHelpers.getTupletData(noteElement);
        const ornaments = xmlHelpers_1.XmlHelpers.articulationsAndOrnaments(noteElement);
        const lyrics = xmlHelpers_1.XmlHelpers.lyrics(noteElement);
        const flagState = xmlHelpers_1.XmlHelpers.getStemType(noteElement);
        const clefString = xmlState.staffArray[staffIndex].clefInfo.clef;
        const pitch = xmlHelpers_1.XmlHelpers.smoPitchFromNote(noteElement, measure_1.SmoMeasure.defaultPitchForClef[clefString]);
        if (isGrace === false) {
            if (chordNode.length) {
                // If this is a note in a chord, just add the pitch to previous note.
                xmlState.previousNote.pitches.push(pitch);
                xmlState.updateTieStates(tieInfos);
            }
            else {
                // Create a new note
                const noteData = note_1.SmoNote.defaults;
                noteData.noteType = noteType;
                noteData.pitches = [pitch];
                // If this is a non-grace note, add any grace notes to the note since SMO
                // treats them as note modifiers
                noteData.ticks = { numerator: tickCount, denominator: 1, remainder: 0 };
                noteData.flagState = flagState;
                noteData.clef = clefString;
                xmlState.previousNote = new note_1.SmoNote(noteData);
                if (hideNote) {
                    xmlState.previousNote.makeHidden(true);
                }
                xmlState.updateDynamics();
                ornaments.forEach((ornament) => {
                    if (ornament.ctor === 'SmoOrnament') {
                        xmlState.previousNote.toggleOrnament(ornament);
                    }
                    else if (ornament.ctor === 'SmoArticulation') {
                        xmlState.previousNote.toggleArticulation(ornament);
                    }
                });
                lyrics.forEach((lyric) => {
                    xmlState.addLyric(xmlState.previousNote, lyric);
                });
                for (grIx = 0; grIx < xmlState.graceNotes.length; ++grIx) {
                    xmlState.previousNote.addGraceNote(xmlState.graceNotes[grIx], grIx);
                }
                xmlState.graceNotes = []; // clear the grace note array
                // If this note starts later than the cursor due to forward, pad with rests
                if (xmlState.tickCursor > xmlState.staffArray[staffIndex].voices[voiceIndex].ticksUsed) {
                    const pads = music_1.SmoMusic.splitIntoValidDurations(xmlState.tickCursor - xmlState.staffArray[staffIndex].voices[voiceIndex].ticksUsed);
                    console.log(`padding ${pads.length} before ${xmlState.staffIndex}-${xmlState.measureIndex}-${xmlState.voiceIndex}-${tickIndex}`);
                    pads.forEach((pad) => {
                        const clefString = xmlState.staffArray[staffIndex].clefInfo.clef;
                        const padNote = measure_1.SmoMeasure.createRestNoteWithDuration(pad, clefString);
                        padNote.makeHidden(true);
                        voice.notes.push(padNote);
                    });
                    // slurs and ties use selector, so this affects them, also
                    selector.tick += pads.length;
                    // then reset the cursor since we are now in sync
                    xmlState.staffArray[staffIndex].voices[voiceIndex].ticksUsed = xmlState.tickCursor;
                }
                /* slurInfos.forEach((slurInfo) => {
                  console.log(`xml slur: ${slurInfo.selector.staff}-${slurInfo.selector.measure}-${slurInfo.selector.voice}-${slurInfo.selector.tick} ${slurInfo.type} ${slurInfo.number}`);
                  console.log(`  ${slurInfo.placement}`);
                });*/
                /* tieInfos.forEach((tieInfo) => {
                  console.log(`xml tie: ${tieInfo.selector.staff}-${tieInfo.selector.measure}-${tieInfo.selector.voice}-${tieInfo.selector.tick} ${tieInfo.type} `);
                  console.log(`  pitch ${tieInfo.pitchIndex} orient ${tieInfo.orientation} num ${tieInfo.number}`);
                });*/
                xmlState.updateSlurStates(slurInfos);
                xmlState.updateTieStates(tieInfos);
                voice.notes.push(xmlState.previousNote);
                xmlState.updateBeamState(beamState, durationData.alteration, voice, voiceIndex);
                xmlState.updateTupletStates(tupletInfos, voice, staffIndex, voiceIndex);
            }
        }
        else {
            if (chordNode.length) {
                xmlState.graceNotes[xmlState.graceNotes.length - 1].pitches.push(pitch);
            }
            else {
                // grace note durations don't seem to have explicit duration, so
                // get it from note type
                xmlState.updateSlurStates(slurInfos);
                xmlState.updateTieStates(tieInfos);
                xmlState.graceNotes.push(new noteModifiers_1.SmoGraceNote({
                    pitches: [pitch],
                    ticks: { numerator: tickCount, denominator: 1, remainder: 0 }
                }));
            }
        }
    }
    static print(printElement, xmlState) {
        if (xmlState.parts[xmlState.partId]) {
            XmlToSmo.pageSizeFromLayout(printElement, xmlState.parts[xmlState.partId].layoutManager, xmlState);
        }
    }
    /**
     * /score-partwise/part/measure
     * A measure in music xml might represent several measures in SMO at the same
     * column in the score
     * @param measureElement
     * @param xmlState
     */
    static measure(measureElement, xmlState) {
        xmlState.initializeForMeasure(measureElement);
        const elements = [...measureElement.children];
        let hasNotes = false;
        elements.forEach((element) => {
            if (element.tagName === 'backup') {
                xmlState.currentDuration -= xmlHelpers_1.XmlHelpers.durationFromNode(element, 0);
            }
            if (element.tagName === 'forward') {
                xmlState.currentDuration += xmlHelpers_1.XmlHelpers.durationFromNode(element, 0);
            }
            if (element.tagName === 'attributes') {
                // update the running state of the XML with new information from this measure
                // if an XML attributes element is present
                XmlToSmo.attributes(measureElement, xmlState);
            }
            else if (element.tagName === 'direction') {
                XmlToSmo.direction(element, xmlState);
            }
            else if (element.tagName === 'note') {
                XmlToSmo.note(element, xmlState);
                hasNotes = true;
            }
            else if (element.tagName === 'barline') {
                xmlState.updateEndings(element);
            }
            else if (element.tagName === 'print') {
                XmlToSmo.print(element, xmlState);
            }
        });
        // If a measure has no notes, just make one with the defaults
        if (hasNotes === false && xmlState.staffArray.length < 1 && xmlState.clefInfo.length >= 1) {
            xmlState.clefInfo.forEach((clefInfo) => {
                xmlState.staffArray.push({ clefInfo, measure: null, voices: {} });
            });
        }
        if (xmlState.rehearsalMark.length) {
            xmlState.rehearsalMarks[xmlState.measureIndex] = xmlState.rehearsalMark;
        }
        xmlState.staffArray.forEach((staffData) => {
            const clef = staffData.clefInfo.clef;
            const params = measure_1.SmoMeasure.defaults;
            params.transposeIndex = xmlState.instrument.keyOffset;
            params.clef = clef;
            const smoMeasure = measure_1.SmoMeasure.getDefaultMeasure(params);
            smoMeasure.format = new measureModifiers_1.SmoMeasureFormat(measureModifiers_1.SmoMeasureFormat.defaults);
            smoMeasure.format.measureIndex = xmlState.measureNumber;
            smoMeasure.format.systemBreak = xmlHelpers_1.XmlHelpers.isSystemBreak(measureElement);
            smoMeasure.tempo = xmlState.tempo;
            smoMeasure.format.proportionality = XmlToSmo.customProportionDefault;
            xmlState.formattingManager.updateMeasureFormat(smoMeasure.format);
            smoMeasure.keySignature = xmlState.keySignature;
            smoMeasure.timeSignature = measure_1.SmoMeasure.convertLegacyTimeSignature(xmlState.timeSignature);
            smoMeasure.measureNumber.localIndex = xmlState.measureNumber;
            smoMeasure.measureNumber.measureIndex = xmlState.measureIndex;
            smoMeasure.measureNumber.staffId = staffData.clefInfo.staffId + xmlState.smoStaves.length;
            const startBarDefs = measureModifiers_1.SmoBarline.defaults;
            startBarDefs.position = measureModifiers_1.SmoBarline.positions.start;
            startBarDefs.barline = xmlState.startBarline;
            const endBarDefs = measureModifiers_1.SmoBarline.defaults;
            endBarDefs.position = measureModifiers_1.SmoBarline.positions.end;
            endBarDefs.barline = xmlState.endBarline;
            smoMeasure.setBarline(new measureModifiers_1.SmoBarline(startBarDefs));
            smoMeasure.setBarline(new measureModifiers_1.SmoBarline(endBarDefs));
            // voices not in array, put them in an array
            Object.keys(staffData.voices).forEach((voiceKey) => {
                const voice = staffData.voices[voiceKey];
                xmlState.addTupletsToMeasure(smoMeasure, staffData.clefInfo.staffId, parseInt(voiceKey, 10));
                voice.notes.forEach((note) => {
                    if (!note.clef) {
                        note.clef = smoMeasure.clef;
                    }
                });
                smoMeasure.voices.push(voice);
            });
            if (smoMeasure.voices.length === 0) {
                smoMeasure.voices.push({ notes: measure_1.SmoMeasure.getDefaultNotes(smoMeasure) });
            }
            staffData.measure = smoMeasure;
        });
        // Pad incomplete measures/voices with rests
        const maxTicks = xmlState.staffArray.map((staffData) => staffData.measure.getMaxTicksVoice())
            .reduce((a, b) => a > b ? a : b);
        xmlState.staffArray.forEach((staffData) => {
            let i = 0;
            let j = 0;
            const measure = staffData.measure;
            for (i = 0; i < measure.voices.length; ++i) {
                const curTicks = measure.getTicksFromVoice(i);
                if (curTicks < maxTicks) {
                    const tickAr = music_1.SmoMusic.splitIntoValidDurations(maxTicks - curTicks);
                    for (j = 0; j < tickAr.length; ++j) {
                        measure.voices[i].notes.push(measure_1.SmoMeasure.createRestNoteWithDuration(tickAr[j], measure.clef));
                    }
                }
            }
        });
    }
}
exports.XmlToSmo = XmlToSmo;


/***/ }),

/***/ "./src/smo/xform/audioTrack.ts":
/*!*************************************!*\
  !*** ./src/smo/xform/audioTrack.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SmoAudioScore = void 0;
// [Smoosic](https://github.com/AaronDavidNewman/Smoosic)
// Copyright (c) Aaron David Newman 2021.
const noteModifiers_1 = __webpack_require__(/*! ../data/noteModifiers */ "./src/smo/data/noteModifiers.ts");
const selections_1 = __webpack_require__(/*! ./selections */ "./src/smo/xform/selections.ts");
const staffModifiers_1 = __webpack_require__(/*! ../data/staffModifiers */ "./src/smo/data/staffModifiers.ts");
const music_1 = __webpack_require__(/*! ../data/music */ "./src/smo/data/music.ts");
const measureModifiers_1 = __webpack_require__(/*! ../data/measureModifiers */ "./src/smo/data/measureModifiers.ts");
const music_2 = __webpack_require__(/*! ../data/music */ "./src/smo/data/music.ts");
/**
 * Convert a score into a JSON structure that can be rendered to audio.
 * the return value looks like this:
 * ` { tracks, repeats, repeatMap} `
 * repeatMap is just an array of tuples with start/end measures.
 *  each track contains:
 *  ` { lastMeasure, notes, tempoMap, timeSignatureMap, hairpins, volume, tiedNotes } `
 * where each note might contain:
 * `{ pitches, noteType, duration, selector, volume }`
 * _Note_:  pitches are smo pitches, durations are adjusted for beatTime
 * (beatTime === 4096 uses Smo/Vex ticks, 128 is midi tick default)
 * volume is normalized 0-1
 * @category SmoTransform
 */
class SmoAudioScore {
    constructor(score, beatTime) {
        this.volume = 0;
        this.timeDiv = 4096 / beatTime;
        this.score = score;
        this.beatTime = beatTime;
    }
    // ### dynamicVolumeMap
    // normalized dynamic
    static get dynamicVolumeMap() {
        // matches SmoDynamicText.dynamics
        return {
            pp: 0.3,
            p: 0.4,
            mp: 0.5,
            mf: 0.6,
            f: 0.7,
            ff: 0.8
        };
    }
    static get emptyTrack() {
        return {
            lastMeasure: 0,
            notes: [],
            tempoMap: {},
            timeSignatureMap: {},
            hairpins: [],
            measureNoteMap: {},
            keyMap: {},
            volume: 0,
            tiedNotes: [],
            repeats: []
        };
    }
    // ### volumeFromNote
    // Return a normalized volume from the dynamic setting of the note
    // or supplied default if none exists
    static volumeFromNote(smoNote, def) {
        if (typeof (def) === 'undefined' || def === 0) {
            def = SmoAudioScore.dynamicVolumeMap[noteModifiers_1.SmoDynamicText.dynamics.PP];
        }
        const dynamic = smoNote.getModifiers('SmoDynamicText');
        if (dynamic.length < 1) {
            return def;
        }
        if (dynamic[0].text === noteModifiers_1.SmoDynamicText.dynamics.SFZ) {
            return SmoAudioScore.dynamicVolumeMap[noteModifiers_1.SmoDynamicText.dynamics.F];
        }
        if (typeof (SmoAudioScore.dynamicVolumeMap[dynamic[0].text]) === 'undefined') {
            return def;
        }
        return SmoAudioScore.dynamicVolumeMap[dynamic[0].text];
    }
    getVoltas(repeat, measureIndex) {
        let v1 = measureIndex;
        let endings = null;
        let currentEnding = -1;
        const rv = [];
        const staff = this.score.staves[0];
        while (v1 > repeat.startRepeat) {
            endings = staff.measures[v1].getNthEndings();
            if (endings.length && endings[0].endSelector) {
                currentEnding = endings[0].number;
                rv.push({ measureIndex: v1, ending: currentEnding });
                v1 = endings[0].endSelector.measure + 1;
                break;
            }
            v1--;
        }
        if (currentEnding < 0 || !(staff === null || staff === void 0 ? void 0 : staff.measures)) {
            return rv;
        }
        while ((endings === null || endings === void 0 ? void 0 : endings.length) && v1 < staff.measures.length) {
            endings = staff.measures[v1].getNthEndings();
            if (!endings.length) {
                break;
            }
            currentEnding = endings[0].number;
            rv.push({ measureIndex: v1, ending: currentEnding });
            v1 = endings[0].endSelector.measure + 1;
        }
        rv.sort((a, b) => a.ending - b.ending);
        return rv;
    }
    // ### ticksFromSelection
    // return the count of ticks between the selectors, adjusted for
    // beatTime
    ticksFromSelection(startSelector, endSelector) {
        const selection = selections_1.SmoSelection.selectionFromSelector(this.score, startSelector);
        const note = selection === null || selection === void 0 ? void 0 : selection.note;
        let ticks = note.tickCount;
        let nextSelection = selections_1.SmoSelection.nextNoteSelectionFromSelector(this.score, startSelector);
        while (nextSelection && nextSelection.note && !selections_1.SmoSelector.gt(nextSelection.selector, endSelector)) {
            ticks += nextSelection.note.tickCount;
            nextSelection = selections_1.SmoSelection.nextNoteSelectionFromSelector(this.score, nextSelection.selector);
        }
        return ticks / this.timeDiv;
    }
    // ### getHairpinInfo
    // Get any hairpin starting at this selection, and calculate its
    // effect on the overall volume
    getHairpinInfo(track, selection) {
        const staff = selection.staff;
        const selector = selection.selector;
        const cp = (x) => JSON.parse(JSON.stringify(x));
        const hps = staff.getModifiersAt(selector)
            .filter((hairpin) => hairpin.ctor === 'SmoStaffHairpin' &&
            selections_1.SmoSelector.eq(hairpin.startSelector, selector));
        const rv = [];
        // clear out old hairpins.
        // usually there will only be a single hairpin per voice, except
        // in the case of overlapping.
        track.hairpins.forEach((hairpin) => {
            if (selections_1.SmoSelector.gteq(selection.selector, hairpin.startSelector) &&
                selections_1.SmoSelector.lteq(selection.selector, hairpin.endSelector)) {
                rv.push(hairpin);
            }
        });
        track.hairpins = rv;
        hps.forEach((hairpin) => {
            const ch = hairpin;
            let endDynamic = 0;
            const trackHairpin = {
                hairpinType: ch.hairpinType,
                startSelector: cp(hairpin.startSelector),
                endSelector: cp(hairpin.endSelector),
                delta: 0,
                ticks: 0
            };
            // For a hairpin, try to calculate the volume difference from start to end,
            // as a function of ticks
            const endSelection = selections_1.SmoSelection.selectionFromSelector(this.score, hairpin.endSelector);
            if (endSelection !== null && typeof (endSelection.note) !== 'undefined') {
                const endNote = endSelection.note;
                const curNote = selection.note;
                endDynamic = SmoAudioScore.volumeFromNote(endNote);
                const startDynamic = SmoAudioScore.volumeFromNote(curNote, track.volume);
                if (startDynamic === endDynamic) {
                    const nextSelection = selections_1.SmoSelection.nextNoteSelectionFromSelector(this.score, hairpin.endSelector);
                    if (nextSelection) {
                        const nextNote = nextSelection.note;
                        endDynamic = SmoAudioScore.volumeFromNote(nextNote);
                    }
                }
                if (startDynamic === endDynamic) {
                    const offset = hairpin.hairpinType === staffModifiers_1.SmoStaffHairpin.types.CRESCENDO ? 0.1 : -0.1;
                    endDynamic = Math.max(endDynamic + offset, 0.1);
                    endDynamic = Math.min(endDynamic, 1.0);
                }
                trackHairpin.delta = endDynamic - startDynamic;
                trackHairpin.ticks = this.ticksFromSelection(hairpin.startSelector, hairpin.endSelector);
                track.hairpins.push(trackHairpin);
            }
        });
    }
    // ### computeVolume
    // come up with a current normalized volume based on dynamics
    // that appear in the music
    computeVolume(track, selection) {
        const note = selection.note;
        if (track.volume === 0) {
            track.volume = SmoAudioScore.volumeFromNote(note, SmoAudioScore.dynamicVolumeMap.p);
            return;
        }
        if (track.hairpins.length) {
            const hp = track.hairpins[0];
            const coff = (note.tickCount / this.timeDiv) / hp.ticks;
            track.volume += hp.delta * coff;
        }
        else {
            track.volume = SmoAudioScore.volumeFromNote(note, track.volume);
        }
    }
    getSlurInfo(track, selection) {
        const tn = [];
        const cp = (x) => JSON.parse(JSON.stringify(x));
        track.tiedNotes.forEach((tie) => {
            if (selections_1.SmoSelector.gteq(selection.selector, tie.startSelector) && selections_1.SmoSelector.lteq(selection.selector, tie.endSelector)) {
                tn.push(tie);
            }
        });
        track.tiedNotes = tn;
        const tieStart = selection.staff.getTiesStartingAt(selection.selector);
        tieStart.forEach((tie) => {
            tn.push({
                startSelector: cp(tie.startSelector),
                endSelector: cp(tie.endSelector)
            });
        });
    }
    isTiedPitch(track, selection, noteIx) {
        if (noteIx < 1) {
            return false;
        }
        if (!track.tiedNotes.length) {
            return false;
        }
        if (track.notes[noteIx - 1].noteType !== 'n') {
            return false;
        }
        // Don't do this for first note of nth endings, because it will mess up
        // other endings.
        if (selection.selector.tick === 0) {
            const endings = selection.measure.getNthEndings();
            if (endings.length) {
                return false;
            }
        }
        // the first note should be played, not tied
        if (selections_1.SmoSelector.eq(track.tiedNotes[0].startSelector, selection.selector)) {
            return false;
        }
        return music_1.SmoMusic.pitchArraysMatch(track.notes[noteIx - 1].pitches, selection.note.pitches);
    }
    static updateMeasureIndexMap(note, measureIndexMap) {
        if (note.noteType !== 'n') {
            return;
        }
        const selector = note.selector;
        if (typeof (measureIndexMap[selector.measure]) === 'undefined') {
            measureIndexMap[selector.measure] = {};
        }
        const measureIndex = measureIndexMap[selector.measure];
        if (typeof (measureIndex[selector.tick]) === 'undefined') {
            measureIndex[selector.tick] = [];
        }
        if (note.noteType === 'n') {
            measureIndex[selector.tick].push(note);
        }
    }
    updateMeasureNoteMap(track, measureIndex, note) {
        if (!track.measureNoteMap[measureIndex]) {
            track.measureNoteMap[measureIndex] = [];
        }
        track.measureNoteMap[measureIndex].push(note);
    }
    createTrackNote(track, selection, duration, runningDuration, measureIndexMap) {
        const noteIx = track.notes.length;
        if (this.isTiedPitch(track, selection, noteIx)) {
            track.notes[noteIx - 1].duration += duration;
            const restPad = this.createTrackRest(track, duration, runningDuration, selection.selector, measureIndexMap);
            // Indicate this rest is just padding for a previous tied note.  Midi and audio render this
            // differently
            restPad.padding = true;
            track.notes.push(restPad);
            return;
        }
        const tpitches = [];
        const frequencies = [];
        const xpose = selection.measure.transposeIndex;
        const smoNote = selection.note;
        smoNote.pitches.forEach((pitch, pitchIx) => {
            var _a;
            tpitches.push(music_1.SmoMusic.smoIntToPitch(music_1.SmoMusic.smoPitchToInt(pitch) - xpose));
            const mtone = (_a = smoNote.getMicrotone(pitchIx)) !== null && _a !== void 0 ? _a : null;
            frequencies.push(music_2.SmoAudioPitch.smoPitchToFrequency(pitch, -1 * xpose, mtone));
        });
        const pitchArray = JSON.parse(JSON.stringify(tpitches));
        const note = {
            pitches: pitchArray,
            noteType: 'n',
            duration,
            offset: runningDuration,
            selector: selection.selector,
            volume: track.volume,
            frequencies
        };
        this.updateMeasureNoteMap(track, selection.selector.measure, note);
        track.notes.push(note);
        SmoAudioScore.updateMeasureIndexMap(note, measureIndexMap);
    }
    createTrackRest(track, duration, runningDuration, selector, measureIndexMap) {
        const rest = {
            duration,
            offset: runningDuration,
            noteType: 'r',
            selector,
            volume: 0,
            pitches: [],
            frequencies: []
        };
        SmoAudioScore.updateMeasureIndexMap(rest, measureIndexMap);
        this.updateMeasureNoteMap(track, selector.measure, rest);
        return rest;
    }
    createRepeatMap(repeats) {
        let startm = 0;
        let j = 0;
        const staff = this.score.staves[0];
        const repeatMap = [];
        const endm = staff.measures.length - 1;
        repeats.forEach((repeat) => {
            // Include the current start to start of repeat, unless there is no start repeat
            if (repeat.startRepeat > 0) {
                repeatMap.push({ startMeasure: startm, endMeasure: repeat.startRepeat - 1 });
            }
            // Include first time through
            if (repeat.endRepeat) {
                repeatMap.push({ startMeasure: repeat.startRepeat, endMeasure: repeat.endRepeat });
            }
            startm = repeat.startRepeat;
            // nth time through, go to the start of volta 0, then to the start of volta n
            if (repeat.endRepeat && repeat.voltas.length < 1) {
                repeatMap.push({ startMeasure: repeat.startRepeat, endMeasure: repeat.endRepeat });
                startm = repeat.endRepeat + 1;
            }
            for (j = 1; j < repeat.voltas.length; ++j) {
                const volta = repeat.voltas[j];
                repeatMap.push({ startMeasure: repeat.startRepeat, endMeasure: repeat.voltas[0].measureIndex - 1 });
                // If there are more endings, repeat to first volta
                if (j + 1 < repeat.voltas.length) {
                    repeatMap.push({ startMeasure: volta.measureIndex, endMeasure: repeat.voltas[j + 1].measureIndex - 1 });
                }
                else {
                    startm = volta.measureIndex;
                }
            }
        });
        if (startm <= endm) {
            repeatMap.push({ startMeasure: startm, endMeasure: endm });
        }
        return repeatMap;
    }
    normalizeVolume(measureIndexMap) {
        let i = 0;
        let j = 0;
        let runningSum = -1;
        const measureKeys = Object.keys(measureIndexMap);
        for (i = 0; i < measureKeys.length; ++i) {
            const measureNotes = measureIndexMap[i];
            if (typeof (measureNotes) === 'undefined') {
                continue;
            }
            const tickKeys = Object.keys(measureNotes);
            for (j = 0; j < tickKeys.length; ++j) {
                let volumeSum = 0;
                let normalize = 1.0;
                const tickNotes = measureNotes[parseInt(tickKeys[j], 10)];
                if (typeof (tickNotes) === 'undefined') {
                    continue;
                }
                volumeSum = tickNotes.map((nn) => nn.volume).reduce((a, b) => a + b);
                if (volumeSum > 1.0) {
                    normalize = 1.0 / volumeSum;
                    volumeSum = 1.0;
                }
                if (runningSum < 0) {
                    runningSum = volumeSum;
                }
                const diff = Math.abs(runningSum - volumeSum);
                if (diff > 0.6) {
                    const avg = (volumeSum * 3 + runningSum) / 4;
                    normalize = normalize * avg;
                }
                runningSum = volumeSum * normalize;
                tickNotes.forEach((nn) => {
                    nn.volume *= normalize;
                });
                runningSum = volumeSum;
            }
        }
    }
    convert() {
        let measureIx = 0;
        const trackHash = {};
        const measureBeats = [];
        const measureIndexMap = {};
        const repeats = [];
        let startRepeat = 0;
        const tempoMap = [];
        this.score.staves.forEach((staff, staffIx) => {
            let runningKey = staff.measures[0].keySignature;
            this.volume = 0;
            for (measureIx = 0; measureIx < staff.measures.length; ++measureIx) {
                const measure = staff.measures[measureIx];
                measure.voices.forEach((voice, voiceIx) => {
                    let duration = 0;
                    const trackKey = (this.score.staves.length * voiceIx) + staffIx;
                    if (typeof (trackHash[trackKey]) === 'undefined') {
                        trackHash[trackKey] = SmoAudioScore.emptyTrack;
                    }
                    const measureSelector = selections_1.SmoSelector.default;
                    measureSelector.staff = staffIx;
                    measureSelector.measure = measureIx;
                    const track = trackHash[trackKey];
                    if (!measure.tempo) {
                        measure.tempo = new measureModifiers_1.SmoTempoText(measureModifiers_1.SmoTempoText.defaults);
                    }
                    const tempo = measure.tempo.bpm * (measure.tempo.beatDuration / 4096);
                    // staff 0/voice 0, set track values for the measure
                    if (voiceIx === 0) {
                        if (staffIx === 0) {
                            track.keyMap[0] = runningKey;
                            measureBeats.push(measure.getMaxTicksVoice() / this.timeDiv);
                            const startBar = measure.getStartBarline();
                            const endBar = measure.getEndBarline();
                            if (startBar.barline === measureModifiers_1.SmoBarline.barlines.startRepeat) {
                                startRepeat = measureIx;
                            }
                            if (endBar.barline === measureModifiers_1.SmoBarline.barlines.endRepeat) {
                                const repeat = { startRepeat, endRepeat: measureIx, voltas: [] };
                                repeat.voltas = this.getVoltas(repeat, measureIx);
                                repeats.push(repeat);
                            }
                            tempoMap.push(tempo);
                        }
                        const selectorKey = selections_1.SmoSelector.getMeasureKey(measureSelector);
                        track.tempoMap[selectorKey] = Math.round(tempo);
                        if (measure.keySignature !== runningKey) {
                            runningKey = measure.keySignature;
                            track.keyMap[measureIx] = runningKey;
                        }
                        track.timeSignatureMap[selectorKey] = {
                            numerator: measure.timeSignature.actualBeats,
                            denominator: measure.timeSignature.beatDuration
                        };
                    }
                    // If this voice is not in every measure, fill in the space
                    // in its own channel.
                    while (track.lastMeasure < measureIx) {
                        track.notes.push(this.createTrackRest(track, measureBeats[track.lastMeasure], 0, { staff: staffIx, measure: track.lastMeasure, voice: voiceIx, tick: 0, pitches: [] }, measureIndexMap));
                        track.lastMeasure += 1;
                    }
                    let tupletTicks = 0;
                    let runningDuration = 0;
                    voice.notes.forEach((note, noteIx) => {
                        const selector = {
                            staff: staffIx, measure: measureIx, voice: voiceIx, tick: noteIx, pitches: []
                        };
                        const selection = selections_1.SmoSelection.selectionFromSelector(this.score, selector);
                        // update staff features of slur/tie/cresc.
                        this.getSlurInfo(track, selection);
                        this.getHairpinInfo(track, selection);
                        const tuplet = measure.getTupletForNote(note);
                        if (tuplet && tuplet.getIndexOfNote(note) === 0) {
                            tupletTicks = tuplet.tickCount / this.timeDiv;
                        }
                        if (tupletTicks) {
                            // tuplet likely won't fit evenly in ticks, so
                            // use remainder in last tuplet note.
                            if (tuplet && tuplet.getIndexOfNote(note) === tuplet.notes.length - 1) {
                                duration = tupletTicks;
                                tupletTicks = 0;
                            }
                            else {
                                duration = note.tickCount / this.timeDiv;
                                tupletTicks -= duration;
                            }
                        }
                        else {
                            duration = note.tickCount / this.timeDiv;
                        }
                        if (note.isRest() || note.isSlash()) {
                            track.notes.push(this.createTrackRest(track, duration, runningDuration, selector, measureIndexMap));
                        }
                        else {
                            this.computeVolume(track, selection);
                            this.createTrackNote(track, selection, duration, runningDuration, measureIndexMap);
                        }
                        runningDuration += duration;
                    });
                    track.lastMeasure += 1;
                });
            }
        });
        // For voices that don't fill out the full piece, fill them in with rests
        const tracks = Object.keys(trackHash).map((key) => trackHash[key]);
        const maxMeasure = tracks[0].lastMeasure;
        tracks.forEach((track) => {
            while (track.lastMeasure < maxMeasure) {
                const staff = track.notes[0].selector.staff;
                const voice = track.notes[0].selector.voice;
                const rest = this.createTrackRest(track, measureBeats[track.lastMeasure], 0, { staff, measure: track.lastMeasure, voice, tick: 0, pitches: [] }, measureIndexMap);
                track.notes.push(rest);
                track.lastMeasure += 1;
            }
        });
        const repeatMap = this.createRepeatMap(repeats);
        this.normalizeVolume(measureIndexMap);
        return { tracks, repeats, repeatMap, measureBeats, tempoMap };
    }
}
exports.SmoAudioScore = SmoAudioScore;


/***/ }),

/***/ "./src/smo/xform/beamers.ts":
/*!**********************************!*\
  !*** ./src/smo/xform/beamers.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SmoBeamer = void 0;
// [Smoosic](https://github.com/AaronDavidNewman/Smoosic)
// Copyright (c) Aaron David Newman 2021.
const music_1 = __webpack_require__(/*! ../data/music */ "./src/smo/data/music.ts");
const VF = eval('Vex.Flow');
/**
 * Contain a group of {@link SmoNote} used for beaming.
 * @internal
 */
class SmoBeamGroup {
    constructor(params) {
        this.voice = 0;
        let i = 0;
        this.voice = params.voice;
        this.notes = params.notes;
        Vex.Merge(this, params);
        this.attrs = {
            id: VF.Element.newID(),
            type: 'SmoBeamGroup'
        };
        for (i = 0; i < this.notes.length; ++i) {
            const note = this.notes[i];
            if (note.tickCount < 4096) {
                note.beam_group = this.attrs;
            }
        }
    }
}
/**
 * Apply the beam policy set up in node and measure to group the notes into beam groups
 * @category SmoTransform
 */
class SmoBeamer {
    constructor(measure, voice) {
        this.measure = measure;
        this._removeVoiceBeam(measure, voice);
        this.duration = 0;
        this.meterNumbers = [measure.timeSignature.actualBeats, measure.timeSignature.beatDuration];
        // beam on 1/4 notes in most meter, triple time dotted quarter
        this.beamBeats = 2 * 2048;
        if (this.meterNumbers[0] % 3 === 0) {
            this.beamBeats = 3 * 2048;
        }
        this.skipNext = 0;
        this.currentGroup = [];
    }
    static applyBeams(measure) {
        let i = 0;
        let j = 0;
        for (i = 0; i < measure.voices.length; ++i) {
            const beamer = new SmoBeamer(measure, i);
            const tickmap = measure.tickmapForVoice(i);
            for (j = 0; j < tickmap.durationMap.length; ++j) {
                beamer.beamNote(tickmap, j, measure.voices[i].notes[j]);
            }
        }
    }
    get beamGroups() {
        return this.measure.beamGroups;
    }
    _removeVoiceBeam(measure, voice) {
        const beamGroups = [];
        measure.beamGroups.forEach((gr) => {
            if (gr.voice !== voice) {
                beamGroups.push(gr);
            }
        });
        measure.beamGroups = beamGroups;
    }
    _completeGroup(voice) {
        const nrCount = this.currentGroup.filter((nn) => nn.isRest() === false);
        // don't beam groups of 1
        if (nrCount.length > 1) {
            this.measure.beamGroups.push(new SmoBeamGroup({
                notes: this.currentGroup,
                voice
            }));
        }
    }
    _advanceGroup() {
        this.currentGroup = [];
        this.duration = 0;
    }
    // ### _isRemainingTicksBeamable
    // look ahead, and see if we need to beam the tuplet now or if we
    // can combine current beam with future notes.
    _isRemainingTicksBeamable(tickmap, index) {
        let acc = 0;
        let i = 0;
        if (this.duration >= this.beamBeats) {
            return false;
        }
        acc = this.duration;
        for (i = index + 1; i < tickmap.deltaMap.length; ++i) {
            acc += tickmap.deltaMap[i];
            if (acc === this.beamBeats) {
                return true;
            }
            if (acc > this.beamBeats) {
                return false;
            }
        }
        return false;
    }
    beamNote(tickmap, index, note) {
        this.beamBeats = note.beamBeats;
        this.duration += tickmap.deltaMap[index];
        if (note.noteType === '/') {
            this._completeGroup(tickmap.voice);
            this._advanceGroup();
            return;
        }
        // beam tuplets
        if (note.isTuplet) {
            const tuplet = this.measure.getTupletForNote(note);
            // The underlying notes must have been deleted.
            if (!tuplet) {
                return;
            }
            const ult = tuplet.notes[tuplet.notes.length - 1];
            const first = tuplet.notes[0];
            if (first.endBeam) {
                this._advanceGroup();
                return;
            }
            // is this beamable length-wise
            const vexDuration = music_1.SmoMusic.closestVexDuration(note.tickCount);
            const stemTicks = VF.durationToTicks(vexDuration);
            if (note.noteType === 'n' && stemTicks < 4096) {
                this.currentGroup.push(note);
            }
            // Ultimate note in tuplet
            if (ult.attrs.id === note.attrs.id && !this._isRemainingTicksBeamable(tickmap, index)) {
                this._completeGroup(tickmap.voice);
                this._advanceGroup();
            }
            return;
        }
        // don't beam > 1/4 note in 4/4 time.  Don't beam rests.
        if (tickmap.deltaMap[index] >= 4096 || (note.isRest() && this.currentGroup.length === 0)) {
            this._completeGroup(tickmap.voice);
            this._advanceGroup();
            return;
        }
        this.currentGroup.push(note);
        if (note.endBeam) {
            this._completeGroup(tickmap.voice);
            this._advanceGroup();
        }
        if (this.duration === this.beamBeats) {
            this._completeGroup(tickmap.voice);
            this._advanceGroup();
            return;
        }
        // If this does not align on a beat, don't beam it
        if (this.duration > this.beamBeats) {
            this._advanceGroup();
        }
    }
}
exports.SmoBeamer = SmoBeamer;


/***/ }),

/***/ "./src/smo/xform/copypaste.ts":
/*!************************************!*\
  !*** ./src/smo/xform/copypaste.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PasteBuffer = void 0;
// [Smoosic](https://github.com/AaronDavidNewman/Smoosic)
// Copyright (c) Aaron David Newman 2021.
const selections_1 = __webpack_require__(/*! ./selections */ "./src/smo/xform/selections.ts");
const note_1 = __webpack_require__(/*! ../data/note */ "./src/smo/data/note.ts");
const measure_1 = __webpack_require__(/*! ../data/measure */ "./src/smo/data/measure.ts");
const staffModifiers_1 = __webpack_require__(/*! ../data/staffModifiers */ "./src/smo/data/staffModifiers.ts");
const tuplet_1 = __webpack_require__(/*! ../data/tuplet */ "./src/smo/data/tuplet.ts");
const music_1 = __webpack_require__(/*! ../data/music */ "./src/smo/data/music.ts");
const svgHelpers_1 = __webpack_require__(/*! ../../render/sui/svgHelpers */ "./src/render/sui/svgHelpers.ts");
const VF = eval('Vex.Flow');
/**
 * PasteBuffer holds copied music, and handles the action of pasting the music to
 * a different point in the score.  It does this by serializing the measure(s) from the source
 * and then creating handling the overlap with existing music when deserializaing it.
 * @category SmoTransform
 */
class PasteBuffer {
    constructor() {
        this.score = null;
        this.tupletNoteMap = {};
        this.modifiers = [];
        this.modifiersToPlace = [];
        this.destination = selections_1.SmoSelector.default;
        this.staffSelectors = [];
        this.notes = [];
        this.noteIndex = 0;
        this.measures = [];
        this.measureIndex = -1;
        this.remainder = 0;
        this.replacementMeasures = [];
    }
    setSelections(score, selections) {
        this.notes = [];
        this.noteIndex = 0;
        this.score = score;
        if (selections.length < 1) {
            return;
        }
        this.tupletNoteMap = {};
        const first = selections[0];
        const last = selections[selections.length - 1];
        if (!first.note || !last.note) {
            return;
        }
        const startTuplet = first.measure.getTupletForNote(first.note);
        if (startTuplet) {
            if (startTuplet.getIndexOfNote(first.note) !== 0) {
                return; // can't paste from the middle of a tuplet
            }
        }
        const endTuplet = last.measure.getTupletForNote(last.note);
        if (endTuplet) {
            if (endTuplet.getIndexOfNote(last.note) !== endTuplet.notes.length - 1) {
                return; // can't paste part of a tuplet.
            }
        }
        this._populateSelectArray(selections);
    }
    // ### _populateSelectArray
    // copy the selected notes into the paste buffer with their original locations.
    _populateSelectArray(selections) {
        let selector = selections_1.SmoSelector.default;
        this.modifiers = [];
        selections.forEach((selection) => {
            var _a, _b;
            selector = JSON.parse(JSON.stringify(selection.selector));
            const mod = selection.staff.getModifiersAt(selector);
            if (mod.length) {
                mod.forEach((modifier) => {
                    const cp = staffModifiers_1.StaffModifierBase.deserialize(modifier.serialize());
                    cp.attrs.id = VF.Element.newID();
                    this.modifiers.push(cp);
                });
            }
            const isTuplet = (_b = (_a = selection === null || selection === void 0 ? void 0 : selection.note) === null || _a === void 0 ? void 0 : _a.isTuplet) !== null && _b !== void 0 ? _b : false;
            // We store copy in concert pitch.  The originalKey is the original key of the copy.
            // the destKey is the originalKey in concert pitch.
            const originalKey = selection.measure.keySignature;
            const keyOffset = -1 * selection.measure.transposeIndex;
            const destKey = music_1.SmoMusic.vexKeySignatureTranspose(originalKey, keyOffset).toLocaleLowerCase();
            if (isTuplet) {
                const tuplet = selection.measure.getTupletForNote(selection.note);
                const index = tuplet.getIndexOfNote(selection.note);
                if (index === 0) {
                    const ntuplet = tuplet_1.SmoTuplet.cloneTuplet(tuplet);
                    this.tupletNoteMap[ntuplet.attrs.id] = ntuplet;
                    ntuplet.notes.forEach((nnote) => {
                        const xposeNote = note_1.SmoNote.transpose(note_1.SmoNote.clone(nnote), [], -1 * selection.measure.transposeIndex, selection.measure.keySignature, destKey);
                        this.notes.push({ selector, note: xposeNote, originalKey: destKey });
                        selector = JSON.parse(JSON.stringify(selector));
                        selector.tick += 1;
                    });
                }
            }
            else if (selection.note) {
                const note = note_1.SmoNote.transpose(note_1.SmoNote.clone(selection.note), [], keyOffset, selection.measure.keySignature, destKey);
                this.notes.push({ selector, note, originalKey: destKey });
            }
        });
        this.notes.sort((a, b) => selections_1.SmoSelector.gt(a.selector, b.selector) ? 1 : -1);
    }
    clearSelections() {
        this.notes = [];
    }
    _findModifier(selector) {
        const rv = this.modifiers.filter((mod) => selections_1.SmoSelector.eq(selector, mod.startSelector));
        return (rv && rv.length) ? rv[0] : null;
    }
    _findPlacedModifier(selector) {
        const rv = this.modifiers.filter((mod) => selections_1.SmoSelector.eq(selector, mod.endSelector));
        return (typeof (rv) !== 'undefined' && rv.length) ? rv[0] : null;
    }
    // ### _populateMeasureArray
    // Before pasting, populate an array of existing measures from the paste destination
    // so we know how to place the notes.
    _populateMeasureArray() {
        if (!this.score || !this.destination) {
            return;
        }
        let measureSelection = selections_1.SmoSelection.measureSelection(this.score, this.destination.staff, this.destination.measure);
        if (!measureSelection) {
            return;
        }
        const measure = measureSelection.measure;
        while (measure.voices.length <= this.destination.voice) {
            measure.populateVoice(measure.voices.length);
        }
        const tickmap = measure.tickmapForVoice(this.destination.voice);
        let currentDuration = tickmap.durationMap[this.destination.tick];
        this.measures = [];
        this.staffSelectors = [];
        this.measures.push(measure);
        this.notes.forEach((selection) => {
            if (currentDuration + selection.note.tickCount > tickmap.totalDuration && measureSelection !== null) {
                // If this note will overlap the measure boundary, the note will be split in 2 with the
                // remainder going to the next measure.  If they line up exactly, the remainder is 0.
                const remainder = (currentDuration + selection.note.tickCount) - tickmap.totalDuration;
                currentDuration = remainder;
                measureSelection = selections_1.SmoSelection.measureSelection(this.score, measureSelection.selector.staff, measureSelection.selector.measure + 1);
                // If the paste buffer overlaps the end of the score, we can't paste (TODO:  add a measure in this case)
                if (measureSelection != null) {
                    this.measures.push(measureSelection.measure);
                }
            }
            else if (measureSelection != null) {
                currentDuration += selection.note.tickCount;
            }
        });
    }
    // ### _populatePre
    // When we paste, we replace entire measures.  Populate the first measure up until the start of pasting.
    _populatePre(voiceIndex, measure, startTick, tickmap) {
        const voice = {
            notes: []
        };
        let i = 0;
        let j = 0;
        let ticksToFill = tickmap.durationMap[startTick];
        // TODO: bug here, need to handle tuplets in pre-part, create new tuplet
        for (i = 0; i < measure.voices[voiceIndex].notes.length; ++i) {
            const note = measure.voices[voiceIndex].notes[i];
            // If this is a tuplet, clone all the notes at once.
            if (note.isTuplet) {
                const tuplet = measure.getTupletForNote(note);
                if (!tuplet) {
                    continue; // we remove the tuplet after first iteration
                }
                const ntuplet = tuplet_1.SmoTuplet.cloneTuplet(tuplet);
                voice.notes = voice.notes.concat(ntuplet.notes);
                measure.removeTupletForNote(note);
                measure.tuplets.push(ntuplet);
                ticksToFill -= tuplet.tickCount;
            }
            else if (ticksToFill >= note.tickCount) {
                ticksToFill -= note.tickCount;
                voice.notes.push(note_1.SmoNote.clone(note));
            }
            else {
                const duration = note.tickCount - ticksToFill;
                const durMap = music_1.SmoMusic.gcdMap(duration);
                for (j = 0; j < durMap.length; ++j) {
                    const dd = durMap[j];
                    note_1.SmoNote.cloneWithDuration(note, {
                        numerator: dd,
                        denominator: 1,
                        remainder: 0
                    });
                }
                ticksToFill = 0;
            }
            if (ticksToFill < 1) {
                break;
            }
        }
        return voice;
    }
    // ### _populateVoice
    // ### Description:
    // Create a new voice for a new measure in the paste destination
    _populateVoice(voiceIndex) {
        this._populateMeasureArray();
        const measures = this.measures;
        let measure = measures[0];
        let tickmap = measure.tickmapForVoice(this.destination.voice);
        let voice = this._populatePre(voiceIndex, measure, this.destination.tick, tickmap);
        let startSelector = JSON.parse(JSON.stringify(this.destination));
        this.measureIndex = 0;
        const measureVoices = [];
        measureVoices.push(voice);
        while (this.measureIndex < measures.length) {
            measure = measures[this.measureIndex];
            while (measure.voices.length <= this.destination.voice) {
                const nvoice = { notes: measure_1.SmoMeasure.getDefaultNotes(measure) };
                measure.voices.push(nvoice);
            }
            tickmap = measure.tickmapForVoice(this.destination.voice);
            this._populateNew(voice, measure, tickmap, startSelector);
            if (this.noteIndex < this.notes.length && this.measureIndex < measures.length) {
                voice = {
                    notes: []
                };
                measureVoices.push(voice);
                startSelector = {
                    staff: startSelector.staff,
                    measure: startSelector.measure,
                    voice: voiceIndex,
                    tick: 0
                };
                this.measureIndex += 1;
                startSelector.measure += 1;
            }
            else {
                break;
            }
        }
        this._populatePost(voice, voiceIndex, measure, tickmap);
        return measureVoices;
    }
    static _countTicks(voice) {
        let voiceTicks = 0;
        voice.notes.forEach((note) => {
            voiceTicks += note.tickCount;
        });
        return voiceTicks;
    }
    /**
     * If the source contains a staff modifier that ends on the source selection, copy the modifier
     * @param srcSelector
     * @param destSelector
     * @param staff
     * @returns
     */
    _populateModifier(srcSelector, destSelector, staff) {
        const mod = this._findPlacedModifier(srcSelector);
        if (mod && this.score) {
            // Don't copy modifiers that cross staff boundaries outside the source staff b/c it's not clear what
            // the dest staff should be
            if (mod.startSelector.staff !== mod.endSelector.staff && srcSelector.staff !== destSelector.staff) {
                return;
            }
            const repl = staffModifiers_1.StaffModifierBase.deserialize(mod.serialize());
            repl.endSelector = JSON.parse(JSON.stringify(destSelector));
            const tickOffset = selections_1.SmoSelection.countTicks(this.score, mod.startSelector, mod.endSelector);
            this.modifiersToPlace.push({
                modifier: repl,
                ticksToStart: tickOffset
            });
        }
    }
    /**
     * Start copying the paste buffer into the destination by copying the notes and working out
     * the measure overlap
     *
     * @param voice
     * @param measure
     * @param tickmap
     * @param startSelector
     * @returns
     */
    _populateNew(voice, measure, tickmap, startSelector) {
        let currentDuration = tickmap.durationMap[startSelector.tick];
        let i = 0;
        let j = 0;
        const totalDuration = tickmap.totalDuration;
        while (currentDuration < totalDuration && this.noteIndex < this.notes.length) {
            if (!this.score) {
                return;
            }
            const selection = this.notes[this.noteIndex];
            const note = selection.note;
            if (note.noteType === 'n') {
                const pitchAr = [];
                note.pitches.forEach((pitch, ix) => {
                    pitchAr.push(ix);
                });
                note_1.SmoNote.transpose(note, pitchAr, measure.transposeIndex, selection.originalKey, measure.keySignature);
            }
            this._populateModifier(selection.selector, startSelector, this.score.staves[selection.selector.staff]);
            if (note.isTuplet) {
                const tuplet = this.tupletNoteMap[note.tuplet.id];
                const ntuplet = tuplet_1.SmoTuplet.cloneTuplet(tuplet);
                this.noteIndex += ntuplet.notes.length;
                startSelector.tick += ntuplet.notes.length;
                currentDuration += tuplet.tickCount;
                for (i = 0; i < ntuplet.notes.length; ++i) {
                    const tn = ntuplet.notes[i];
                    tn.clef = measure.clef;
                    voice.notes.push(tn);
                }
                measure.tuplets.push(ntuplet);
            }
            else if (currentDuration + note.tickCount <= totalDuration && this.remainder === 0) {
                // The whole note fits in the measure, paste it.
                const nnote = note_1.SmoNote.clone(note);
                nnote.clef = measure.clef;
                voice.notes.push(nnote);
                currentDuration += note.tickCount;
                this.noteIndex += 1;
                startSelector.tick += 1;
            }
            else if (this.remainder > 0) {
                // This is a note that spilled over the last measure
                const nnote = note_1.SmoNote.cloneWithDuration(note, {
                    numerator: this.remainder,
                    denominator: 1,
                    remainder: 0
                });
                nnote.clef = measure.clef;
                voice.notes.push(nnote);
                currentDuration += this.remainder;
                this.remainder = 0;
            }
            else {
                // The note won't fit, so we split it in 2 and paste the remainder in the next measure.
                // TODO:  tie the last note to this one.
                const partial = totalDuration - currentDuration;
                const dar = music_1.SmoMusic.gcdMap(partial);
                for (j = 0; j < dar.length; ++j) {
                    const ddd = dar[j];
                    const vnote = note_1.SmoNote.cloneWithDuration(note, {
                        numerator: ddd,
                        denominator: 1,
                        remainder: 0
                    });
                    voice.notes.push(vnote);
                }
                currentDuration += partial;
                // Set the remaining length of the current note, this will be added to the
                // next measure with the previous note's pitches
                this.remainder = note.tickCount - partial;
            }
        }
    }
    // ### _populatePost
    // When we paste, we replace entire measures.  Populate the last measure from the end of paste to the
    // end of the measure with notes in the existing measure.
    _populatePost(voice, voiceIndex, measure, tickmap) {
        let startTicks = PasteBuffer._countTicks(voice);
        let existingIndex = 0;
        const totalDuration = tickmap.totalDuration;
        while (startTicks < totalDuration) {
            // Find the point in the music where the paste area runs out, or as close as we can get.
            existingIndex = tickmap.durationMap.indexOf(startTicks);
            existingIndex = (existingIndex < 0) ? measure.voices[voiceIndex].notes.length - 1 : existingIndex;
            const note = measure.voices[voiceIndex].notes[existingIndex];
            if (note.isTuplet) {
                const tuplet = measure.getTupletForNote(note);
                const ntuplet = tuplet_1.SmoTuplet.cloneTuplet(tuplet);
                startTicks += tuplet.tickCount;
                voice.notes = voice.notes.concat(ntuplet.notes);
                measure.tuplets.push(ntuplet);
                measure.removeTupletForNote(note);
            }
            else {
                const ticksLeft = totalDuration - startTicks;
                if (ticksLeft >= note.tickCount) {
                    startTicks += note.tickCount;
                    voice.notes.push(note_1.SmoNote.clone(note));
                }
                else {
                    const remainder = totalDuration - startTicks;
                    voice.notes.push(note_1.SmoNote.cloneWithDuration(note, {
                        numerator: remainder,
                        denominator: 1,
                        remainder: 0
                    }));
                    startTicks = totalDuration;
                }
            }
        }
    }
    _pasteVoiceSer(ser, vobj, voiceIx) {
        const voices = [];
        let ix = 0;
        ser.voices.forEach((vc) => {
            if (ix !== voiceIx) {
                voices.push(vc);
            }
            else {
                voices.push(vobj);
            }
            ix += 1;
        });
        // If we are pasting into a measure that doesn't contain this voice, add the voice
        if (ser.voices.length <= voiceIx) {
            voices.push(vobj);
        }
        ser.voices = voices;
    }
    pasteSelections(selector) {
        let i = 0;
        const maxCutVoice = this.notes.map((n) => n.selector.voice).reduce((a, b) => a > b ? a : b);
        const minCutVoice = this.notes.map((n) => n.selector.voice).reduce((a, b) => a > b ? a : b);
        const backupNotes = [];
        this.notes.forEach((bb) => {
            const note = (note_1.SmoNote.deserialize(bb.note.serialize()));
            const selector = JSON.parse(JSON.stringify(bb.selector));
            backupNotes.push({ note, selector, originalKey: bb.originalKey });
        });
        this.destination = selector;
        if (minCutVoice === maxCutVoice && minCutVoice > this.destination.voice) {
            this.destination.voice = minCutVoice;
        }
        this.modifiersToPlace = [];
        if (this.notes.length < 1) {
            return;
        }
        if (!this.score) {
            return;
        }
        this.noteIndex = 0;
        this.measureIndex = -1;
        this.remainder = 0;
        const voices = this._populateVoice(this.destination.voice);
        const measureSel = JSON.parse(JSON.stringify(this.destination));
        const selectors = [];
        for (i = 0; i < this.measures.length && i < voices.length; ++i) {
            const measure = this.measures[i];
            const nvoice = voices[i];
            const ser = measure.serialize();
            // Make sure the key is concert pitch, it is what measure constructor expects
            ser.transposeIndex = measure.transposeIndex; // default values are undefined, make sure the transpose is valid
            ser.keySignature = music_1.SmoMusic.vexKeySigWithOffset(measure.keySignature, -1 * measure.transposeIndex);
            ser.timeSignature = measure.timeSignature.serialize();
            ser.tempo = measure.tempo.serialize();
            const vobj = {
                notes: []
            };
            nvoice.notes.forEach((note) => {
                vobj.notes.push(note.serialize());
            });
            // TODO: figure out how to do this with multiple voices
            this._pasteVoiceSer(ser, vobj, this.destination.voice);
            const nmeasure = measure_1.SmoMeasure.deserialize(ser);
            // If this is the non-display buffer, don't try to reset the display rectangles.
            // Q: Is this even required since we are going to re-render?
            // A: yes, because until we do, the replaced measure needs the formatting info
            if (measure.svg.logicalBox && measure.svg.logicalBox.width > 0) {
                nmeasure.setBox(svgHelpers_1.SvgHelpers.smoBox(measure.svg.logicalBox), 'copypaste');
                nmeasure.setX(measure.svg.logicalBox.x, 'copyPaste');
                nmeasure.setWidth(measure.svg.logicalBox.width, 'copypaste');
                nmeasure.setY(measure.svg.logicalBox.y, 'copypaste');
                nmeasure.svg.element = measure.svg.element;
            }
            ['forceClef', 'forceKeySignature', 'forceTimeSignature', 'forceTempo'].forEach((flag) => {
                nmeasure[flag] = measure.svg[flag];
            });
            this.score.replaceMeasure(measureSel, nmeasure);
            measureSel.measure += 1;
            selectors.push({ staff: selector.staff, measure: nmeasure.measureNumber.measureIndex, voice: 0, tick: 0, pitches: [] });
        }
        this.replacementMeasures = [];
        selectors.forEach((selector) => {
            const nsel = selections_1.SmoSelection.measureSelection(this.score, selector.staff, selector.measure);
            if (nsel) {
                this.replacementMeasures.push(nsel);
            }
        });
        this.modifiersToPlace.forEach((mod) => {
            let selection = selections_1.SmoSelection.selectionFromSelector(this.score, mod.modifier.endSelector);
            while (selection && mod.ticksToStart !== 0) {
                if (mod.ticksToStart < 0) {
                    selection = selections_1.SmoSelection.nextNoteSelectionFromSelector(this.score, selection.selector);
                }
                else {
                    selection = selections_1.SmoSelection.lastNoteSelectionFromSelector(this.score, selection.selector);
                }
                mod.ticksToStart -= 1 * Math.sign(mod.ticksToStart);
            }
            if (selection) {
                mod.modifier.startSelector = JSON.parse(JSON.stringify(selection.selector));
                selection.staff.addStaffModifier(mod.modifier);
            }
        });
        this.notes = backupNotes;
    }
}
exports.PasteBuffer = PasteBuffer;


/***/ }),

/***/ "./src/smo/xform/operations.ts":
/*!*************************************!*\
  !*** ./src/smo/xform/operations.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SmoOperation = void 0;
const music_1 = __webpack_require__(/*! ../data/music */ "./src/smo/data/music.ts");
const note_1 = __webpack_require__(/*! ../data/note */ "./src/smo/data/note.ts");
const measure_1 = __webpack_require__(/*! ../data/measure */ "./src/smo/data/measure.ts");
const systemStaff_1 = __webpack_require__(/*! ../data/systemStaff */ "./src/smo/data/systemStaff.ts");
const noteModifiers_1 = __webpack_require__(/*! ../data/noteModifiers */ "./src/smo/data/noteModifiers.ts");
const measureModifiers_1 = __webpack_require__(/*! ../data/measureModifiers */ "./src/smo/data/measureModifiers.ts");
const staffModifiers_1 = __webpack_require__(/*! ../data/staffModifiers */ "./src/smo/data/staffModifiers.ts");
const scoreModifiers_1 = __webpack_require__(/*! ../data/scoreModifiers */ "./src/smo/data/scoreModifiers.ts");
const selections_1 = __webpack_require__(/*! ./selections */ "./src/smo/xform/selections.ts");
const tickDuration_1 = __webpack_require__(/*! ./tickDuration */ "./src/smo/xform/tickDuration.ts");
const beamers_1 = __webpack_require__(/*! ./beamers */ "./src/smo/xform/beamers.ts");
const serializationHelpers_1 = __webpack_require__(/*! ../../common/serializationHelpers */ "./src/common/serializationHelpers.js");
const VF = eval('Vex.Flow');
/**
 * SmoOperation is a collection of static methods that operate on/change/transform the music.  Most methods
 * take the score, a selection or selection array, and the parameters of the operation.
 * @category SmoUtilities
 */
class SmoOperation {
    static setMeasureFormat(score, selection, value) {
        if (!score.formattingManager) {
            return;
        }
        score.staves.forEach((staff) => {
            value.formatMeasure(staff.measures[selection.selector.measure]);
        });
        score.formattingManager.updateMeasureFormat(value);
    }
    static addKeySignature(score, selection, keySignature) {
        score.addKeySignature(selection.selector.measure, keySignature);
    }
    static addConnectorDown(score, selections, parameters) {
        const msel = selections_1.SmoSelection.getMeasureList(selections);
        const len = msel.length - 1;
        if (score.staves.length <= msel[len].selector.staff) {
            return;
        }
        const existing = score.getSystemGroupForStaff(msel[0]);
        if (existing && existing.endSelector.staff < selections[len].selector.staff) {
            existing.endSelector.staff = msel[len].selector.staff + 1;
        }
        else {
            parameters.startSelector = selections_1.SmoSelector.default;
            parameters.startSelector.staff = msel[0].selector.staff;
            parameters.startSelector.measure = msel[0].selector.measure;
            parameters.endSelector = selections_1.SmoSelector.default;
            parameters.endSelector.staff = msel[len].selector.staff + 1;
            parameters.endSelector.measure = msel[len].selector.measure;
            score.addOrReplaceSystemGroup(new scoreModifiers_1.SmoSystemGroup(parameters));
        }
    }
    static toggleBeamGroup(noteSelection) {
        if (!noteSelection.note) {
            return;
        }
        noteSelection.note.endBeam = !(noteSelection.note.endBeam);
    }
    static setActiveVoice(score, voiceIx) {
        score.staves.forEach((staff) => {
            staff.measures.forEach((measure) => {
                measure.setActiveVoice(voiceIx);
            });
        });
    }
    static addRemoveMicrotone(ignore, selections, tone) {
        selections.forEach((sel) => {
            const note = sel.note;
            if (note) {
                const oldTone = note.getMicrotone(tone.pitchIndex);
                if (oldTone) {
                    note.removeMicrotone(oldTone);
                }
                else {
                    note.addMicrotone(tone);
                }
            }
        });
    }
    static moveStaffUpDown(score, selection, index) {
        const index1 = selection.selector.staff;
        const index2 = selection.selector.staff + index;
        if (index2 < score.staves.length && index2 >= 0) {
            score.swapStaves(index1, index2);
        }
    }
    static depopulateVoice(selection, voiceIx) {
        let ix = 0;
        const voices = [];
        const measure = selection.measure;
        measure.voices.forEach((voice) => {
            if (measure.voices.length < 2 || ix !== voiceIx) {
                voices.push(voice);
            }
            ix += 1;
        });
        measure.voices = voices;
        if (measure.getActiveVoice() >= measure.voices.length) {
            measure.setActiveVoice(0);
        }
    }
    static populateVoice(selection, voiceIx) {
        selection.measure.populateVoice(voiceIx);
    }
    static setTimeSignature(score, selections, timeSignature, timeSignatureString) {
        const selectors = [];
        let i = 0;
        let ticks = 0;
        selections.forEach((selection) => {
            for (i = 0; i < score.staves.length; ++i) {
                const measureSel = selections_1.SmoSelector.measureSelector(i, selection.selector.measure);
                selectors.push(measureSel);
            }
        });
        selectors.forEach((selector) => {
            var _a;
            const params = {};
            const rowSelection = selections_1.SmoSelection.measureSelection(score, selector.staff, selector.measure);
            let nm = {};
            const attrs = measure_1.SmoMeasure.defaultAttributes.filter((aa) => aa !== 'timeSignature');
            const psel = selections_1.SmoSelection.measureSelection(score, selector.staff, selector.measure);
            if (!(psel === null || psel === void 0 ? void 0 : psel.measure)) {
                console.log('Error: score has changed in time signature change');
            }
            else {
                const proto = (_a = selections_1.SmoSelection.measureSelection(score, selector.staff, selector.measure)) === null || _a === void 0 ? void 0 : _a.measure;
                serializationHelpers_1.smoSerialize.serializedMerge(attrs, proto, params);
                params.timeSignature = timeSignature;
                nm = measure_1.SmoMeasure.getDefaultMeasure(params);
                nm.timeSignatureString = timeSignatureString;
                nm.setX(rowSelection.measure.staffX, 'op:setTimeSignature');
                nm.setY(rowSelection.measure.staffY, 'op:setTimeSignature');
                nm.setWidth(rowSelection.measure.staffWidth, 'op:setTimeSignature');
                ['forceKeySignature', 'forceTimeSignature', 'forceTempo', 'forceClef'].forEach((attr) => {
                    nm[attr] = rowSelection.measure.svg[attr];
                });
                ticks = 0;
                nm.voices = [{ notes: measure_1.SmoMeasure.timeSignatureNotes(timeSignature, params.clef) }];
            }
            const original = score.staves[selector.staff].measures[selector.measure];
            // Keep track of original element so it can be replaced.
            nm.svg.element = original.svg.element;
            score.replaceMeasure(selector, nm);
        });
    }
    static batchSelectionOperation(score, selections, operation) {
        var measureTicks = [];
        selections.forEach((selection) => {
            const tm = selection.measure.tickmapForVoice(selection.selector.voice);
            const tickOffset = tm.durationMap[selection.selector.tick];
            const selector = JSON.parse(JSON.stringify(selection.selector));
            measureTicks.push({
                selector,
                tickOffset
            });
        });
        measureTicks.forEach((measureTick) => {
            const selection = selections_1.SmoSelection.measureSelection(score, measureTick.selector.staff, measureTick.selector.measure);
            const tickmap = selection.measure.tickmapForVoice(measureTick.selector.voice);
            const ix = tickmap.durationMap.indexOf(measureTick.tickOffset);
            if (ix >= 0) {
                const nsel = selections_1.SmoSelection.noteSelection(score, measureTick.selector.staff, measureTick.selector.measure, measureTick.selector.voice, ix);
                SmoOperation[operation](nsel);
            }
        });
    }
    // ## doubleDuration
    // ## Description
    // double the duration of a note in a measure, at the expense of the following
    // note, if possible.  Works on tuplets also.
    static doubleDuration(selection) {
        const note = selection.note;
        const measure = selection.measure;
        const tuplet = measure.getTupletForNote(note);
        if (!tuplet) {
            tickDuration_1.SmoDuration.doubleDurationNonTuplet(selection);
        }
        else {
            tickDuration_1.SmoDuration.doubleDurationTuplet(selection);
        }
        return true;
    }
    // ## halveDuration
    // ## Description
    // Replace the note with 2 notes of 1/2 duration, if possible
    // Works on tuplets also.
    static halveDuration(selection) {
        const note = selection.note;
        let divisor = 2;
        const measure = selection.measure;
        const tuplet = measure.getTupletForNote(note);
        if (measure.timeSignature.actualBeats % 3 === 0 && note.tickCount === 6144) {
            // special behavior, if this is dotted 1/4 in 6/8, split to 3
            divisor = 3;
        }
        if (!tuplet) {
            const nticks = note.tickCount / divisor;
            if (!music_1.SmoMusic.ticksToDuration[nticks]) {
                return;
            }
            tickDuration_1.SmoContractNoteActor.apply({
                startIndex: selection.selector.tick,
                measure: selection.measure,
                voice: selection.selector.voice,
                newTicks: nticks
            });
            beamers_1.SmoBeamer.applyBeams(measure);
        }
        else {
            const startIndex = measure.tupletIndex(tuplet) + tuplet.getIndexOfNote(note);
            tickDuration_1.SmoContractTupletActor.apply({
                changeIndex: startIndex,
                measure,
                voice: selection.selector.voice
            });
        }
    }
    // ## makeTuplet
    // ## Description
    // Makes a non-tuplet into a tuplet of equal value.
    static makeTuplet(selection, numNotes) {
        const note = selection.note;
        const measure = selection.measure;
        if (measure.getTupletForNote(note)) {
            return;
        }
        const nticks = note.tickCount;
        tickDuration_1.SmoMakeTupletActor.apply({
            index: selection.selector.tick,
            totalTicks: nticks,
            numNotes,
            measure: selection.measure,
            voice: selection.selector.voice
        });
    }
    static addStaffModifier(selection, modifier) {
        selection.staff.addStaffModifier(modifier);
    }
    static toggleRest(selection) {
        var _a;
        (_a = selection.note) === null || _a === void 0 ? void 0 : _a.toggleRest();
    }
    static toggleSlash(selection) {
        var _a;
        (_a = selection.note) === null || _a === void 0 ? void 0 : _a.toggleSlash();
    }
    static makeRest(selection) {
        var _a;
        (_a = selection.note) === null || _a === void 0 ? void 0 : _a.makeRest();
    }
    static makeNote(selection) {
        var _a;
        (_a = selection.note) === null || _a === void 0 ? void 0 : _a.makeNote();
    }
    static setNoteHead(selections, noteHead) {
        selections.forEach((selection) => {
            var _a;
            (_a = selection.note) === null || _a === void 0 ? void 0 : _a.setNoteHead(noteHead);
        });
    }
    static addGraceNote(selection, g, offset) {
        var _a;
        (_a = selection.note) === null || _a === void 0 ? void 0 : _a.addGraceNote(g, offset);
    }
    static removeGraceNote(selection, offset) {
        var _a;
        (_a = selection.note) === null || _a === void 0 ? void 0 : _a.removeGraceNote(offset);
    }
    static doubleGraceNoteDuration(selection, modifiers) {
        if (!Array.isArray(modifiers)) {
            modifiers = [modifiers];
        }
        modifiers.forEach((mm) => {
            mm.ticks.numerator = mm.ticks.numerator * 2;
        });
    }
    static halveGraceNoteDuration(selection, modifiers) {
        if (!Array.isArray(modifiers)) {
            modifiers = [modifiers];
        }
        modifiers.forEach((mm) => {
            mm.ticks.numerator = mm.ticks.numerator / 2;
        });
    }
    static toggleGraceNoteCourtesy(selection, modifiers) {
        if (!Array.isArray(modifiers)) {
            modifiers = [modifiers];
        }
        modifiers.forEach((mm) => {
            mm.pitches.forEach((pitch) => {
                // eslint-disable-next-line
                pitch.cautionary = pitch.cautionary ? false : true;
            });
        });
    }
    static toggleGraceNoteEnharmonic(selection, modifiers) {
        if (!Array.isArray(modifiers)) {
            modifiers = [modifiers];
        }
        modifiers.forEach((mm) => {
            mm.pitches.forEach((pitch) => {
                note_1.SmoNote.toggleEnharmonic(pitch);
            });
        });
    }
    static transposeGraceNotes(selection, modifiers, offset) {
        if (!Array.isArray(modifiers)) {
            modifiers = [modifiers];
        }
        modifiers.forEach((mm) => {
            const par = [];
            if (!mm) {
                console.warn('bad modifier grace note');
                return;
            }
            mm.pitches.forEach((pitch) => {
                par.push(music_1.SmoMusic.smoIntToPitch(music_1.SmoMusic.smoPitchToInt(pitch) + offset));
            });
            mm.pitches = par;
        });
    }
    static slashGraceNotes(selections) {
        if (!Array.isArray(selections)) {
            selections = [selections];
        }
        // TODO: modifiers on artifacts should be typed
        selections.forEach((mm) => {
            if (mm.modifier && mm.modifier.ctor === 'SmoGraceNote') {
                mm.modifier.slash = !mm.modifier.slash;
            }
        });
    }
    // ## unmakeTuplet
    // ## Description
    // Makes a tuplet into a single with the duration of the whole tuplet
    static unmakeTuplet(selection) {
        const note = selection.note;
        const measure = selection.measure;
        if (!measure.getTupletForNote(note)) {
            return;
        }
        const tuplet = measure.getTupletForNote(note);
        if (tuplet === null) {
            return;
        }
        const startIndex = measure.tupletIndex(tuplet);
        const endIndex = tuplet.notes.length + startIndex - 1;
        tickDuration_1.SmoUnmakeTupletActor.apply({
            startIndex,
            endIndex,
            measure,
            voice: selection.selector.voice
        });
    }
    // ## dotDuration
    // ## Description
    // Add a dot to a note, if possible, and make the note ahead of it shorter
    // to compensate.
    static dotDuration(selection) {
        const note = selection.note;
        const measure = selection.measure;
        const nticks = music_1.SmoMusic.getNextDottedLevel(note.tickCount);
        if (nticks === note.tickCount) {
            return;
        }
        // Don't dot if the thing on the right of the . is too small
        const dotCount = music_1.SmoMusic.smoTicksToVexDots(nticks);
        const multiplier = Math.pow(2, dotCount);
        const baseDot = VF.durationToTicks(music_1.SmoMusic.closestVexDuration(nticks)) / (multiplier * 2);
        if (baseDot <= 128) {
            return;
        }
        // If this is the ultimate note in the measure, we can't increase the length
        if (selection.selector.tick + 1 === selection.measure.voices[selection.selector.voice].notes.length) {
            return;
        }
        if (selection.measure.voices[selection.selector.voice].notes[selection.selector.tick + 1].tickCount > note.tickCount) {
            console.log('too long');
            return;
        }
        // is dot too short?
        if (!music_1.SmoMusic.ticksToDuration[selection.measure.voices[selection.selector.voice].notes[selection.selector.tick + 1].tickCount / 2]) {
            return;
        }
        tickDuration_1.SmoStretchNoteActor.apply({
            startIndex: selection.selector.tick,
            measure,
            voice: selection.selector.voice,
            newTicks: nticks
        });
    }
    // ## undotDuration
    // ## Description
    // Add the value of the last dot to the note, increasing length and
    // reducing the number of dots.
    static undotDuration(selection) {
        const note = selection.note;
        const measure = selection.measure;
        const nticks = music_1.SmoMusic.getPreviousDottedLevel(note.tickCount);
        if (nticks === note.tickCount) {
            return;
        }
        tickDuration_1.SmoContractNoteActor.apply({
            startIndex: selection.selector.tick,
            measure,
            voice: selection.selector.voice,
            newTicks: nticks
        });
    }
    // ## transpose
    // ## Description
    // Transpose the selected note, trying to find a key-signature friendly value
    static transpose(selection, offset) {
        let trans;
        let transInt = 0;
        let i = 0;
        if (typeof (selection.selector.pitches) === 'undefined') {
            selection.selector.pitches = [];
        }
        const measure = selection.measure;
        const note = selection.note;
        if (measure && note) {
            const pitchar = [];
            note.pitches.forEach((opitch, pitchIx) => {
                // Only translate selected pitches
                const shouldXpose = selection.selector.pitches.length === 0 ||
                    selection.selector.pitches.indexOf(pitchIx) >= 0;
                // Translate the pitch, ignoring enharmonic
                trans = shouldXpose ? music_1.SmoMusic.getKeyOffset(opitch, offset)
                    : JSON.parse(JSON.stringify(opitch));
                if (shouldXpose) {
                    trans = music_1.SmoMusic.getEnharmonicInKey(trans, measure.keySignature);
                    if (!trans.accidental) {
                        trans.accidental = 'n';
                    }
                    transInt = music_1.SmoMusic.smoPitchToInt(trans);
                    // Look through the earlier notes in the measure and try
                    // to find an equivalent note, and convert it if it exists.
                    measure.voices.forEach((voice) => {
                        for (i = 0; i < selection.selector.tick
                            && i < voice.notes.length; ++i) {
                            const prevNote = voice.notes[i];
                            // eslint-disable-next-line
                            prevNote.pitches.forEach((prevPitch) => {
                                const prevInt = music_1.SmoMusic.smoPitchToInt(prevPitch);
                                if (prevInt === transInt) {
                                    trans = JSON.parse(JSON.stringify(prevPitch));
                                }
                            });
                        }
                    });
                }
                pitchar.push(trans);
            });
            note.pitches = pitchar;
            return true;
        }
        return false;
    }
    // ## setPitch
    // ## Description:
    // pitches can be either an array, a single pitch, or a letter.  In the latter case,
    // the letter value appropriate for the key signature is used, e.g. c in A major becomes
    // c#
    static setPitch(selection, pitches) {
        let i = 0;
        const measure = selection.measure;
        const note = selection.note;
        if (typeof (note) === 'undefined') {
            console.warn('set Pitch on invalid note');
            return;
        }
        note.makeNote();
        // TODO allow hint for octave
        const octave = note.pitches[0].octave;
        note.pitches = [];
        if (!Array.isArray(pitches)) {
            pitches = [pitches];
        }
        const earlierAccidental = (pitch) => {
            selection.measure.voices.forEach((voice) => {
                for (i = 0; i < selection.selector.tick
                    && i < voice.notes.length; ++i) {
                    const prevNote = voice.notes[i];
                    if (prevNote === null || prevNote.pitches === null) {
                        console.log('this will die null');
                    }
                    prevNote.pitches.forEach((prevPitch) => {
                        if (prevNote.noteType === 'n' && prevPitch.letter === pitch.letter) {
                            pitch.accidental = prevPitch.accidental;
                        }
                    });
                }
            });
        };
        pitches.forEach((pitch) => {
            if (typeof (pitch) === 'string') {
                const letter = music_1.SmoMusic.getKeySignatureKey(pitch[0], measure.keySignature);
                pitch = {
                    letter: letter[0],
                    accidental: letter.length > 1 ? letter.substring(1) : '',
                    octave
                };
            }
            earlierAccidental(pitch);
            note.pitches.push(pitch);
        });
    }
    static toggleCourtesyAccidental(selection) {
        let toBe = false;
        const note = selection.note;
        if (!selection.selector.pitches || selection.selector.pitches.length === 0) {
            const ps = [];
            note.pitches.forEach((pitch) => {
                const p = JSON.parse(JSON.stringify(pitch));
                ps.push(p);
                p.cautionary = !(pitch.cautionary);
            });
            note.pitches = ps;
        }
        else {
            toBe = !(note.pitches[selection.selector.pitches[0]].cautionary);
        }
        SmoOperation.courtesyAccidental(selection, toBe);
    }
    static courtesyAccidental(pitchSelection, toBe) {
        pitchSelection.selector.pitches.forEach((pitchIx) => {
            pitchSelection.note.pitches[pitchIx].cautionary = toBe;
        });
    }
    static toggleEnharmonic(pitchSelection) {
        if (pitchSelection.selector.pitches.length === 0) {
            pitchSelection.selector.pitches.push(0);
        }
        const pitch = pitchSelection.note.pitches[pitchSelection.selector.pitches[0]];
        note_1.SmoNote.toggleEnharmonic(pitch);
    }
    static addDynamic(selection, dynamic) {
        selection.note.addDynamic(dynamic);
    }
    static removeDynamic(selection, dynamic) {
        selection.note.removeDynamic(dynamic);
    }
    static beamSelections(score, selections) {
        const start = selections[0].selector;
        let cur = selections[0].selector;
        const beamGroup = [];
        let ticks = 0;
        selections.forEach((selection) => {
            const note = selection.note;
            if (selections_1.SmoSelector.sameNote(start, selection.selector) ||
                (selections_1.SmoSelector.sameMeasure(selection.selector, cur) &&
                    cur.tick === selection.selector.tick - 1)) {
                ticks += note.tickCount;
                cur = selection.selector;
                beamGroup.push(note);
            }
        });
        if (beamGroup.length) {
            beamGroup.forEach((note) => {
                note.beamBeats = ticks;
                note.endBeam = false;
            });
            beamGroup[beamGroup.length - 1].endBeam = true;
            // Make sure the last note of the previous beam is the end of this beam group.
            if (selections[0].selector.tick > 0) {
                const ps = JSON.parse(JSON.stringify(selections[0].selector));
                ps.tick -= 1;
                const previous = selections_1.SmoSelection.noteFromSelector(score, ps);
                if ((previous === null || previous === void 0 ? void 0 : previous.note) && previous.note.tickCount < 4096) {
                    previous.note.endBeam = true;
                }
            }
        }
    }
    static toggleBeamDirection(selections) {
        const note0 = selections[0].note;
        note0.toggleFlagState();
        selections.forEach((selection) => {
            const note = selection.note;
            note.flagState = note0.flagState;
        });
    }
    static toggleOrnament(selection, ornament) {
        selection.note.toggleOrnament(ornament);
    }
    static toggleArticulation(selection, articulation) {
        selection.note.toggleArticulation(articulation);
    }
    static addEnding(score, parameters) {
        let m = 0;
        let s = 0;
        const startMeasure = parameters.startBar;
        const endMeasure = parameters.endBar;
        // Ending ID ties all the instances of an ending across staves
        parameters.endingId = VF.Element.newID();
        score.staves.forEach((staff) => {
            m = 0;
            staff.measures.forEach((measure) => {
                if (m === startMeasure) {
                    const pp = JSON.parse(JSON.stringify(parameters));
                    pp.startSelector = {
                        staff: s,
                        measure: startMeasure
                    };
                    pp.endSelector = {
                        staff: s,
                        measure: endMeasure
                    };
                    const ending = new measureModifiers_1.SmoVolta(pp);
                    measure.addNthEnding(ending);
                }
                m += 1;
            });
            s += 1;
        });
    }
    static removeEnding(score, ending) {
        let i = 0;
        score.staves.forEach((staff) => {
            // bug
            // Due to deleted measures, volta might not match up so look through all measures.
            for (i = 0; i < staff.measures.length; ++i) {
                staff.measures[i].removeNthEnding(ending);
            }
        });
    }
    static addTextGroup(score, textGroup) {
        score.addTextGroup(textGroup);
    }
    static removeTextGroup(score, textGroup) {
        score.removeTextGroup(textGroup);
    }
    static addMeasureText(score, selection, measureText) {
        const current = selection.measure.getMeasureText();
        // TODO: should we allow multiples per position
        current.forEach((mod) => {
            selection.measure.removeMeasureText(mod.attrs.id);
        });
        selection.measure.addMeasureText(measureText);
    }
    static removeMeasureText(score, selection, mt) {
        selection.measure.removeMeasureText(mt.attrs.id);
    }
    static removeRehearsalMark(score, selection) {
        score.staves.forEach((staff) => {
            staff.removeRehearsalMark(selection.selector.measure);
        });
    }
    static addRehearsalMark(score, selection, rehearsalMark) {
        score.staves.forEach((staff) => {
            const mt = new measureModifiers_1.SmoRehearsalMark(rehearsalMark.serialize());
            staff.addRehearsalMark(selection.selector.measure, mt);
        });
    }
    static addTempo(score, selection, tempo) {
        score.staves.forEach((staff) => {
            staff.addTempo(tempo, selection.selector.measure);
        });
    }
    static setMeasureBarline(score, selection, barline) {
        const mm = selection.selector.measure;
        let ix = 0;
        score.staves.forEach(() => {
            const s2 = selections_1.SmoSelection.measureSelection(score, ix, mm);
            s2 === null || s2 === void 0 ? void 0 : s2.measure.setBarline(barline);
            ix += 1;
        });
    }
    static setRepeatSymbol(score, selection, sym) {
        let ix = 0;
        const mm = selection.selector.measure;
        score.staves.forEach(() => {
            const s2 = selections_1.SmoSelection.measureSelection(score, ix, mm);
            s2 === null || s2 === void 0 ? void 0 : s2.measure.setRepeatSymbol(sym);
            ix += 1;
        });
    }
    // ## interval
    // Add a pitch at the specified interval to the chord in the selection.
    static interval(selection, interval) {
        const measure = selection.measure;
        const note = selection.note;
        let pitch = {};
        // TODO: figure out which pitch is selected
        pitch = note.pitches[0];
        if (interval > 0) {
            pitch = note.pitches[note.pitches.length - 1];
        }
        pitch = music_1.SmoMusic.getIntervalInKey(pitch, measure.keySignature, interval);
        if (pitch) {
            note.pitches.push(pitch);
            note.pitches.sort((x, y) => music_1.SmoMusic.smoPitchToInt(x) - music_1.SmoMusic.smoPitchToInt(y));
            return true;
        }
        return false;
    }
    static addOrReplaceBracket(modifier, fromSelection, toSelection) {
        fromSelection.staff.addTextBracket(modifier);
    }
    static ritard(fromSelection, toSelection) {
        const params = staffModifiers_1.SmoStaffTextBracket.defaults;
        params.startSelector = JSON.parse(JSON.stringify(fromSelection.selector));
        params.endSelector = JSON.parse(JSON.stringify(toSelection.selector));
        params.text = staffModifiers_1.SmoStaffTextBracket.RITARD;
        const modifier = new staffModifiers_1.SmoStaffTextBracket(params);
        fromSelection.staff.addTextBracket(modifier);
        return modifier;
    }
    static accelerando(fromSelection, toSelection) {
        const params = staffModifiers_1.SmoStaffTextBracket.defaults;
        params.startSelector = JSON.parse(JSON.stringify(fromSelection.selector));
        params.endSelector = JSON.parse(JSON.stringify(toSelection.selector));
        params.text = staffModifiers_1.SmoStaffTextBracket.ACCEL;
        const modifier = new staffModifiers_1.SmoStaffTextBracket(params);
        fromSelection.staff.addTextBracket(modifier);
        return modifier;
    }
    static crescendoBracket(fromSelection, toSelection) {
        const params = staffModifiers_1.SmoStaffTextBracket.defaults;
        params.startSelector = JSON.parse(JSON.stringify(fromSelection.selector));
        params.endSelector = JSON.parse(JSON.stringify(toSelection.selector));
        params.text = staffModifiers_1.SmoStaffTextBracket.CRESCENDO;
        const modifier = new staffModifiers_1.SmoStaffTextBracket(params);
        fromSelection.staff.addTextBracket(modifier);
        return modifier;
    }
    static dimenuendo(fromSelection, toSelection) {
        const params = staffModifiers_1.SmoStaffTextBracket.defaults;
        params.startSelector = JSON.parse(JSON.stringify(fromSelection.selector));
        params.endSelector = JSON.parse(JSON.stringify(toSelection.selector));
        params.text = staffModifiers_1.SmoStaffTextBracket.CRESCENDO;
        const modifier = new staffModifiers_1.SmoStaffTextBracket(params);
        fromSelection.staff.addTextBracket(modifier);
        return modifier;
    }
    static crescendo(fromSelection, toSelection) {
        const params = staffModifiers_1.SmoStaffHairpin.defaults;
        params.startSelector = JSON.parse(JSON.stringify(fromSelection.selector));
        params.endSelector = JSON.parse(JSON.stringify(toSelection.selector));
        params.hairpinType = staffModifiers_1.SmoStaffHairpin.types.CRESCENDO;
        const modifier = new staffModifiers_1.SmoStaffHairpin(params);
        fromSelection.staff.addStaffModifier(modifier);
        return modifier;
    }
    static decrescendo(fromSelection, toSelection) {
        const params = staffModifiers_1.SmoStaffHairpin.defaults;
        params.startSelector = JSON.parse(JSON.stringify(fromSelection.selector));
        params.endSelector = JSON.parse(JSON.stringify(toSelection.selector));
        params.hairpinType = staffModifiers_1.SmoStaffHairpin.types.DECRESCENDO;
        const modifier = new staffModifiers_1.SmoStaffHairpin(params);
        fromSelection.staff.addStaffModifier(modifier);
        return modifier;
    }
    static tie(fromSelection, toSelection) {
        // By default, just tie all the pitches to all the other pitches in order
        const lines = staffModifiers_1.SmoTie.createLines(fromSelection.note, toSelection.note);
        const params = staffModifiers_1.SmoTie.defaults;
        params.startSelector = fromSelection.selector;
        params.endSelector = toSelection.selector;
        params.lines = lines;
        const modifier = new staffModifiers_1.SmoTie(params);
        fromSelection.staff.addStaffModifier(modifier);
        return modifier;
    }
    static getSlurDefaultParameters(selections) {
        const lastIndex = selections.length - 1;
        const note1 = selections[0].note;
        const note2 = selections[lastIndex].note;
        const inners = [];
        let minLine = -1;
        let maxLine = 0;
        if (selections.length > 2) {
            for (var i = 1; i < selections.length - 1; ++i) {
                inners.push(selections[i]);
            }
        }
        if (note1 === null || note2 === null) {
            throw ('no note in slur selections');
        }
        const sameBeam = (note1.beam_group && note2.beam_group && note1.beam_group.id === note2.beam_group.id);
        const lineDifference = Math.abs(music_1.SmoMusic.pitchToStaffLine(note1.clef, note1.pitches[0]) -
            music_1.SmoMusic.pitchToStaffLine(note2.clef, note2.pitches[0]));
    }
    /**
     * Heuristically determine how a slur should be formatted based on the notes.  Determine control points,
     * offset, and alignment
     *
     * ## Note: Vexflow slurs consider `top` to mean the furthest point from the note head, which could be the top
     * or the bottom of the note.  It also considers yoffset to be negative if inverted is set.  Head means close to the
     * note head.
     * @param score
     * @param fromSelection
     * @param toSelection
     * @returns
     */
    static getDefaultSlurDirection(score, fromSelector, toSelector, forcePosition, forceOrientation) {
        const params = staffModifiers_1.SmoSlur.defaults;
        const sels = selections_1.SmoSelector.order(fromSelector, toSelector);
        params.startSelector = JSON.parse(JSON.stringify(sels[0]));
        params.endSelector = JSON.parse(JSON.stringify(sels[1]));
        const fromSelection = selections_1.SmoSelection.noteFromSelector(score, fromSelector);
        if (!fromSelection) {
            return params;
        }
        // Get all selections within the slur
        const selections = selections_1.SmoSelection.innerSelections(score, sels[0], sels[1]).filter((ff) => ff.selector.voice === fromSelection.selector.voice);
        const dirs = {};
        const beamGroups = {};
        let startDir = note_1.SmoNote.flagStates.up;
        let mixed = false;
        let endDir = note_1.SmoNote.flagStates.up;
        let firstGap = 0;
        let lastGap = 0;
        if (selections.length < 1) {
            return new staffModifiers_1.SmoSlur(params);
        }
        selections.forEach((selection, selectionIx) => {
            const note = selection.note;
            if (note.beam_group) {
                beamGroups[note.beam_group.id] = true;
            }
            else {
                beamGroups[note.attrs.id] = true;
            }
            // Find the gap between the first and second note, and also between last 2.  If they are far apart,
            // increase the control points so the slurs don't run into the notes
            if (selectionIx === 1) {
                const lastNote = selections[0].note;
                firstGap = Math.abs(music_1.SmoMusic.pitchToStaffLine(note.clef, note.pitches[0]) -
                    music_1.SmoMusic.pitchToStaffLine(lastNote.clef, lastNote.pitches[0]));
            }
            if (selectionIx === selections.length - 2 && selections.length > 2) {
                const nextNote = selections[selectionIx + 1].note;
                lastGap = Math.abs(music_1.SmoMusic.pitchToStaffLine(note.clef, note.pitches[0]) -
                    music_1.SmoMusic.pitchToStaffLine(nextNote.clef, nextNote.pitches[0]));
            }
            const fstate = music_1.SmoMusic.flagStateFromNote(note.clef, note);
            // Keep track of the number of stem directions, so we can determine if the flags are mixed direction
            // the rules are a little different for mixed - we always try to put the slur on (the real) top of the staff.
            dirs[fstate] = true;
            if (selectionIx === 0) {
                startDir = fstate;
            }
            if (selectionIx === selections.length - 1) {
                endDir = fstate;
            }
        });
        params.invert = false;
        mixed = Object.keys(dirs).length > 1;
        // If the notes are beamed together, we assume the beams point in the same direction
        if (Object.keys(beamGroups).length < 2) {
            mixed = false;
        }
        if (forcePosition === staffModifiers_1.SmoSlur.positions.ABOVE) {
            params.position = startDir === note_1.SmoNote.flagStates.up ? staffModifiers_1.SmoSlur.positions.TOP : staffModifiers_1.SmoSlur.positions.HEAD;
            params.position_end = endDir === note_1.SmoNote.flagStates.up ? staffModifiers_1.SmoSlur.positions.TOP : staffModifiers_1.SmoSlur.positions.HEAD;
            if (startDir === note_1.SmoNote.flagStates.up && forceOrientation !== staffModifiers_1.SmoSlur.orientations.DOWN) {
                params.invert = true;
            }
        }
        else if (forcePosition === staffModifiers_1.SmoSlur.positions.BELOW) {
            params.position = startDir === note_1.SmoNote.flagStates.up ? staffModifiers_1.SmoSlur.positions.HEAD : staffModifiers_1.SmoSlur.positions.TOP;
            params.position_end = endDir === note_1.SmoNote.flagStates.up ? staffModifiers_1.SmoSlur.positions.HEAD : staffModifiers_1.SmoSlur.positions.TOP;
            if (startDir === note_1.SmoNote.flagStates.down && forceOrientation !== staffModifiers_1.SmoSlur.orientations.UP) {
                params.invert = true;
            }
        }
        else {
            if (mixed) {
                // special case: slur 2 notes, note heads close, connect the note heads
                // to keep a flat arc
                if (selections.length === 2 && firstGap < 3) {
                    params.position = staffModifiers_1.SmoSlur.positions.HEAD;
                    params.position_end = staffModifiers_1.SmoSlur.positions.HEAD;
                    params.xOffset = 5;
                }
                else {
                    params.position = startDir === note_1.SmoNote.flagStates.up ? staffModifiers_1.SmoSlur.positions.TOP : staffModifiers_1.SmoSlur.positions.HEAD;
                    params.position_end = endDir === note_1.SmoNote.flagStates.up ? staffModifiers_1.SmoSlur.positions.TOP : staffModifiers_1.SmoSlur.positions.HEAD;
                    if (firstGap >= 3 || lastGap >= 3) {
                        params.cp1y = 45;
                        params.cp2y = 45;
                    }
                }
                params.invert = endDir === note_1.SmoNote.flagStates.up;
            }
            if (!mixed) {
                params.position = staffModifiers_1.SmoSlur.positions.HEAD;
                params.position_end = staffModifiers_1.SmoSlur.positions.HEAD;
                if (firstGap >= 2 || lastGap >= 2) {
                    params.cp1y = 45;
                    params.cp2y = 45;
                    params.yOffset += 10;
                }
                else {
                    params.yOffset += 10;
                }
            }
        }
        if (selections.length === 2) {
            params.xOffset = 0;
        }
        return params;
    }
    static slur(score, fromSelection, toSelection) {
        const params = SmoOperation.getDefaultSlurDirection(score, fromSelection.selector, toSelection.selector, staffModifiers_1.SmoSlur.positions.AUTO, staffModifiers_1.SmoSlur.orientations.AUTO);
        const modifier = new staffModifiers_1.SmoSlur(params);
        fromSelection.staff.addStaffModifier(modifier);
        return modifier;
    }
    static addStaff(score, parameters) {
        score.addStaff(parameters);
    }
    static removeStaff(score, index) {
        score.removeStaff(index);
    }
    static transposeChords(smoNote, offset, key) {
        const chords = smoNote.getModifiers('SmoLyric');
        chords.forEach((ll) => {
            const lyric = ll;
            if (lyric.parser === noteModifiers_1.SmoLyric.parsers.chord) {
                const tx = lyric.getText();
                // Look for something that looks like a key name
                if (tx.length >= 1 && (tx[0].toUpperCase() >= 'A'
                    && tx[0].toUpperCase() <= 'G')) {
                    // toffset is 2 if the key has b or # in it
                    let toffset = 1;
                    let newText = tx[0];
                    if (tx.length > 0 && tx[1] === 'b' || tx[1] === '#') {
                        newText += tx[1];
                        toffset = 2;
                    }
                    // Transpose the key, as if it were a key signature (octave has no meaning)
                    let nkey = music_1.SmoMusic.smoIntToPitch(music_1.SmoMusic.smoPitchToInt(music_1.SmoMusic.pitchKeyToPitch(music_1.SmoMusic.vexToSmoKey(newText))) + offset);
                    nkey = JSON.parse(JSON.stringify(music_1.SmoMusic.getEnharmonicInKey(nkey, key)));
                    newText = nkey.letter.toUpperCase();
                    // new key may have different length, e.g. Bb to B natural
                    if (nkey.accidental !== 'n') {
                        newText += nkey.accidental;
                    }
                    newText += tx.substr(toffset, tx.length - toffset);
                    lyric.setText(newText);
                }
            }
        });
    }
    /**
     * Compute new map based on current instrument selections, adjusting existing instruments as required
     * @param instrument
     * @param selections
     */
    static changeInstrument(instrument, selections) {
        const measureSel = selections_1.SmoSelection.getMeasureList(selections);
        const measureIndex = measureSel[0].selector.measure;
        const measureEnd = measureIndex + (measureSel.length - 1);
        instrument.startSelector = JSON.parse(JSON.stringify(measureSel[0].selector));
        instrument.endSelector = JSON.parse(JSON.stringify(measureSel[measureSel.length - 1].selector));
        const instMap = {};
        const staffArray = systemStaff_1.SmoSystemStaff.getStaffInstrumentArray(measureSel[0].staff.measureInstrumentMap);
        instMap[measureIndex] = instrument;
        staffArray.forEach((ar) => {
            if (ar.instrument.endSelector.measure < measureIndex || ar.instrument.startSelector.measure > measureEnd) {
                // No overlap, juse use the original instrument
                instMap[ar.instrument.startSelector.measure] = new staffModifiers_1.SmoInstrument(ar.instrument);
            }
            else if (ar.instrument.startSelector.measure < measureIndex) {
                // overlap on left
                const split1 = new staffModifiers_1.SmoInstrument(ar.instrument);
                split1.startSelector.measure = ar.instrument.startSelector.measure;
                instMap[split1.startSelector.measure] = split1;
                split1.endSelector.measure = measureIndex - 1;
                if (ar.instrument.endSelector.measure > measureEnd) {
                    // overlap on left and right
                    const split2 = new staffModifiers_1.SmoInstrument(ar.instrument);
                    split2.startSelector.measure = measureEnd + 1;
                    split2.endSelector.measure = ar.instrument.endSelector.measure;
                    instMap[split2.startSelector.measure] = split2;
                }
                instMap[ar.instrument.startSelector.measure] = new staffModifiers_1.SmoInstrument(ar.instrument);
            }
            else if (ar.instrument.endSelector.measure > measureEnd) {
                // overlap on right only
                const split1 = new staffModifiers_1.SmoInstrument(ar.instrument);
                split1.startSelector.measure = measureEnd + 1;
                instMap[split1.startSelector.measure] = split1;
            }
        });
        selections[0].staff.measureInstrumentMap = instMap;
        selections[0].staff.updateInstrumentOffsets();
    }
    static computeMultipartRest(score) {
        let i = 0;
        let j = 0;
        const measureRanges = {};
        const measureCount = score.staves[0].measures.length;
        if (score.staves[0].partInfo.expandMultimeasureRests === true) {
            return;
        }
        while (i < measureCount) {
            let forceRest = score.staves[0].measures[i].format.forceRest;
            if (score.isMultimeasureRest(i, true, forceRest)) {
                for (j = i + 1; j < measureCount; ++j) {
                    const restBreak = score.staves[0].measures[j].format.restBreak;
                    forceRest = score.staves[0].measures[j].format.forceRest;
                    if (!score.isMultimeasureRest(j, false, forceRest) || restBreak) {
                        break;
                    }
                }
                if (j - i >= 2) {
                    measureRanges[i] = j;
                }
                i = j;
            }
            else {
                const startMeasure = i;
                score.staves.forEach((staff) => {
                    staff.measures[startMeasure].svg.hideMultimeasure = false;
                });
                i += 1;
            }
        }
        const multiKeys = Object.keys(measureRanges).map((x) => parseInt(x, 10));
        multiKeys.forEach((key) => {
            const endMeasure = measureRanges[key];
            score.staves.forEach((staff) => {
                const mmLength = endMeasure - key;
                const svg = staff.measures[key].svg;
                svg.multimeasureLength = mmLength;
                if (svg.multimeasureLength > 1) {
                    svg.multimeasureEndBarline = staff.measures[endMeasure - 1].getEndBarline().barline;
                }
                staff.measures[key].svg.hideMultimeasure = false;
                for (i = key + 1; i < endMeasure; ++i) {
                    staff.measures[i].svg.hideMultimeasure = true;
                }
            });
        });
    }
}
exports.SmoOperation = SmoOperation;


/***/ }),

/***/ "./src/smo/xform/selections.ts":
/*!*************************************!*\
  !*** ./src/smo/xform/selections.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SmoSelection = exports.SmoSelector = void 0;
/**
 * There are 2 parts to a selection: the actual musical bits that are selected, and the
 * indices that define what was selected.  This is the latter.  The actual object does not
 * have any methods so there is no constructor.
 * @category SmoTransform
 * */
class SmoSelector {
    constructor() {
        this.staff = 0;
        this.measure = 0;
        this.voice = 0;
        this.tick = -1;
        this.pitches = [];
    }
    static get default() {
        return {
            staff: 0,
            measure: 0,
            voice: 0,
            tick: -1,
            pitches: []
        };
    }
    static measureSelector(staff, measure) {
        return { staff, measure, voice: 0, tick: 0, pitches: [] };
    }
    // TODO:  tick in selector s/b tickIndex
    static sameNote(sel1, sel2) {
        return (sel1.staff === sel2.staff && sel1.measure === sel2.measure && sel1.voice === sel2.voice
            && sel1.tick === sel2.tick);
    }
    static sameMeasure(sel1, sel2) {
        return (sel1.staff === sel2.staff && sel1.measure === sel2.measure);
    }
    static sameStaff(sel1, sel2) {
        return sel1.staff === sel2.staff;
    }
    /**
     * Return gt, not considering the voice (e.g. gt in time)
     * @param sel1
     * @param sel2
     */
    static gtInTime(sel1, sel2) {
        return (sel1.measure > sel2.measure) ||
            (sel1.measure === sel2.measure && sel1.tick > sel2.tick);
    }
    // ## return true if sel1 > sel2.
    static gt(sel1, sel2) {
        // Note: voice is not considered b/c it's more of a vertical component
        // Note further: sometimes we need to consider voice
        return (sel1.staff > sel2.staff) ||
            (sel1.staff === sel2.staff && sel1.measure > sel2.measure) ||
            (sel1.staff === sel2.staff && sel1.measure === sel2.measure && sel1.voice > sel2.voice) ||
            (sel1.staff === sel2.staff && sel1.measure === sel2.measure && sel1.voice === sel2.voice && sel1.tick > sel2.tick);
    }
    static eq(sel1, sel2) {
        return (sel1.staff === sel2.staff && sel1.voice === sel2.voice && sel1.measure === sel2.measure && sel1.tick === sel2.tick);
    }
    static neq(sel1, sel2) {
        return !(SmoSelector.eq(sel1, sel2));
    }
    static lt(sel1, sel2) {
        return SmoSelector.gt(sel2, sel1);
    }
    static gteq(sel1, sel2) {
        return SmoSelector.gt(sel1, sel2) || SmoSelector.eq(sel1, sel2);
    }
    static lteq(sel1, sel2) {
        return SmoSelector.lt(sel1, sel2) || SmoSelector.eq(sel1, sel2);
    }
    // Return 2 selectors in score order, rv[0] is first in time.
    static order(a, b) {
        if (SmoSelector.gtInTime(a, b)) {
            return [b, a];
        }
        return [a, b];
    }
    // ### getNoteKey
    // Get a key useful for a hash map of notes.
    static getNoteKey(selector) {
        return '' + selector.staff + '-' + selector.measure + '-' + selector.voice + '-' + selector.tick;
    }
    static getMeasureKey(selector) {
        return '' + selector.staff + '-' + selector.measure;
    }
    // return true if testSel is contained in the selStart to selEnd range.
    static contains(testSel, selStart, selEnd) {
        const geStart = selStart.measure < testSel.measure ||
            (selStart.measure === testSel.measure && selStart.tick <= testSel.tick);
        const leEnd = selEnd.measure > testSel.measure ||
            (selEnd.measure === testSel.measure && testSel.tick <= selEnd.tick);
        return geStart && leEnd;
    }
    // create a hashmap key for a single note, used to organize modifiers
    static selectorNoteKey(selector) {
        return 'staff-' + selector.staff + '-measure-' + selector.measure + '-voice-' + selector.voice + '-tick-' + selector.tick;
    }
}
exports.SmoSelector = SmoSelector;
/**
 * A selection is a {@link SmoSelector} and a set of references to musical elements, like measure etc.
 * The staff and measure are always a part of the selection, and possible a voice and note,
 * and one or more pitches.  Selections can also be made from the UI by clicking on an element
 * or navigating to an element with the keyboard.
 * @category SmoTransform
 * */
class SmoSelection {
    constructor(params) {
        this.selector = {
            staff: 0,
            measure: 0,
            voice: 0,
            tick: -1,
            pitches: []
        };
        this._pitches = [];
        this.box = null;
        this.scrollBox = null;
        this.selector = {
            staff: 0,
            measure: 0,
            voice: 0,
            tick: 0,
            pitches: []
        };
        this._staff = params._staff;
        this._measure = params._measure;
        this._note = null;
        this._pitches = [];
        Vex.Merge(this, params);
    }
    // ### measureSelection
    // A selection that does not contain a specific note
    static measureSelection(score, staffIndex, measureIndex) {
        staffIndex = staffIndex !== null ? staffIndex : score.activeStaff;
        const selector = {
            staff: staffIndex,
            measure: measureIndex,
            voice: 0,
            tick: 0,
            pitches: []
        };
        if (score.staves.length <= staffIndex) {
            return null;
        }
        const staff = score.staves[staffIndex];
        if (staff.measures.length <= measureIndex) {
            return null;
        }
        const measure = staff.measures[measureIndex];
        return new SmoSelection({
            selector,
            _staff: staff,
            _measure: measure,
            type: 'measure'
        });
    }
    static measuresInColumn(score, staffIndex) {
        let i = 0;
        const rv = [];
        for (i = 0; i < score.staves.length; ++i) {
            const sel = SmoSelection.measureSelection(score, i, staffIndex);
            if (sel) {
                rv.push(sel);
            }
        }
        return rv;
    }
    // ### noteSelection
    // a selection that specifies a note in the score
    static noteSelection(score, staffIndex, measureIndex, voiceIndex, tickIndex) {
        staffIndex = staffIndex != null ? staffIndex : score.activeStaff;
        measureIndex = typeof (measureIndex) !== 'undefined' ? measureIndex : 0;
        voiceIndex = typeof (voiceIndex) !== 'undefined' ? voiceIndex : 0;
        const staff = score.staves[staffIndex];
        if (!staff) {
            return null;
        }
        const measure = staff.measures[measureIndex];
        if (!measure) {
            return null;
        }
        if (measure.voices.length <= voiceIndex) {
            return null;
        }
        if (measure.voices[voiceIndex].notes.length <= tickIndex) {
            return null;
        }
        const note = measure.voices[voiceIndex].notes[tickIndex];
        const selector = {
            staff: staffIndex,
            measure: measureIndex,
            voice: voiceIndex,
            tick: tickIndex,
            pitches: []
        };
        return new SmoSelection({
            selector,
            _staff: staff,
            _measure: measure,
            _note: note,
            _pitches: [],
            type: 'note'
        });
    }
    // ### noteFromSelector
    // return a selection based on the passed-in selector
    static noteFromSelector(score, selector) {
        return SmoSelection.noteSelection(score, selector.staff, selector.measure, selector.voice, selector.tick);
    }
    // ### selectionsToEnd
    // Select all the measures from startMeasure to the end of the score in the given staff.
    static selectionsToEnd(score, staff, startMeasure) {
        let i = 0;
        const rv = [];
        for (i = startMeasure; i < score.staves[staff].measures.length; ++i) {
            const selection = SmoSelection.measureSelection(score, staff, i);
            if (selection) {
                rv.push(selection);
            }
        }
        return rv;
    }
    // ### renderedNoteSelection
    // return the appropriate type of selection from the selector, based on the selector.
    static selectionFromSelector(score, selector) {
        if (typeof (selector.pitches) !== 'undefined' && selector.pitches.length) {
            return SmoSelection.pitchSelection(score, selector.staff, selector.measure, selector.voice, selector.tick, selector.pitches);
        }
        if (typeof (selector.tick) === 'number') {
            return SmoSelection.noteFromSelector(score, selector);
        }
        return SmoSelection.measureSelection(score, selector.staff, selector.measure);
    }
    static pitchSelection(score, staffIndex, measureIndex, voiceIndex, tickIndex, pitches) {
        staffIndex = staffIndex !== null ? staffIndex : score.activeStaff;
        measureIndex = typeof (measureIndex) !== 'undefined' ? measureIndex : 0;
        voiceIndex = typeof (voiceIndex) !== 'undefined' ? voiceIndex : 0;
        const staff = score.staves[staffIndex];
        const measure = staff.measures[measureIndex];
        const note = measure.voices[voiceIndex].notes[tickIndex];
        pitches = typeof (pitches) !== 'undefined' ? pitches : [];
        const pa = [];
        pitches.forEach((ix) => {
            pa.push(JSON.parse(JSON.stringify(note.pitches[ix])));
        });
        const selector = {
            staff: staffIndex,
            measure: measureIndex,
            voice: voiceIndex,
            tick: tickIndex,
            pitches
        };
        return new SmoSelection({
            selector,
            _staff: staff,
            _measure: measure,
            _note: note,
            _pitches: pa,
            type: 'pitches'
        });
    }
    /**
     * Return the selection that is tickCount ticks after the current selection.
     * @param score
     * @param selection
     * @param tickCount
     * @returns
     */
    static advanceTicks(score, selection, tickCount) {
        let rv = null;
        if (!selection.note) {
            return rv;
        }
        const staff = selection.staff;
        rv = SmoSelection.noteFromSelector(score, selection.selector);
        while (rv !== null && rv.note !== null && tickCount > 0) {
            const prevSelector = JSON.parse(JSON.stringify(rv.selector));
            const measureTicks = rv.measure.getMaxTicksVoice();
            const tickIx = rv.selector.tick;
            const voiceId = rv.measure.voices.length > rv.selector.voice ? rv.selector.voice : 0;
            // If the destination is more than a measure away, increment measure
            if (tickIx === 0 && tickCount >= measureTicks) {
                tickCount -= measureTicks;
                if (staff.measures.length > rv.selector.measure + 1) {
                    rv.selector.measure += 1;
                    rv.selector.tick = 0;
                    rv = SmoSelection.selectionFromSelector(score, rv.selector);
                }
            }
            else if (selection.measure.voices[voiceId].notes.length > tickIx + 1) {
                // else count the tick and advance to next tick
                tickCount -= rv.note.tickCount;
                rv.selector.tick += 1;
                rv = SmoSelection.selectionFromSelector(score, rv.selector);
            }
            else if (staff.measures.length > rv.selector.measure + 1) {
                // else advance to next measure and start counting ticks there
                tickCount -= rv.note.tickCount;
                rv.selector.measure += 1;
                rv.selector.tick = 0;
                rv = SmoSelection.selectionFromSelector(score, rv.selector);
            }
            if (rv !== null && SmoSelector.eq(prevSelector, rv.selector)) {
                // No progress, start and end the same
                break;
            }
        }
        return rv;
    }
    /**
     * Count the number of tick indices between selector 1 and selector 2;
     * @param score
     * @param sel1
     * @param sel2
     * @returns
     */
    static countTicks(score, sel1, sel2) {
        if (SmoSelector.eq(sel1, sel2)) {
            return 0;
        }
        const backwards = SmoSelector.gt(sel1, sel2);
        let ticks = 0;
        const startSelection = SmoSelection.selectionFromSelector(score, sel1);
        let endSelection = SmoSelection.selectionFromSelector(score, sel2);
        while (endSelection !== null && startSelection !== null) {
            if (SmoSelector.eq(startSelection.selector, endSelection.selector)) {
                break;
            }
            if (backwards) {
                endSelection = SmoSelection.nextNoteSelectionFromSelector(score, endSelection.selector);
                ticks -= 1;
            }
            else {
                endSelection = SmoSelection.lastNoteSelectionFromSelector(score, endSelection.selector);
                ticks += 1;
            }
        }
        return ticks;
    }
    // ## nextNoteSelection
    // ## Description:
    // Return the next note in this measure, or the first note of the next measure, if it exists.
    static nextNoteSelection(score, staffIndex, measureIndex, voiceIndex, tickIndex) {
        const nextTick = tickIndex + 1;
        const nextMeasure = measureIndex + 1;
        const staff = score.staves[staffIndex];
        const measure = staff.measures[measureIndex];
        if (measure.voices[voiceIndex].notes.length > nextTick) {
            return SmoSelection.noteSelection(score, staffIndex, measureIndex, voiceIndex, nextTick);
        }
        if (staff.measures.length > nextMeasure) {
            return SmoSelection.noteSelection(score, staffIndex, nextMeasure, voiceIndex, 0);
        }
        return null;
    }
    /**
     *
     * @param score
     * @param selector
     * @returns
     */
    static innerSelections(score, startSelector, endSelector) {
        const sels = SmoSelector.order(startSelector, endSelector);
        let start = JSON.parse(JSON.stringify(sels[0]));
        const rv = [];
        let cur = SmoSelection.selectionFromSelector(score, start);
        if (cur) {
            rv.push(cur);
        }
        while (cur && SmoSelector.lt(start, sels[1])) {
            cur = SmoSelection.nextNoteSelection(score, start.staff, start.measure, start.voice, start.tick);
            if (cur) {
                start = JSON.parse(JSON.stringify(cur.selector));
                rv.push(cur);
            }
        }
        return rv;
    }
    static nextNoteSelectionFromSelector(score, selector) {
        return SmoSelection.nextNoteSelection(score, selector.staff, selector.measure, selector.voice, selector.tick);
    }
    static lastNoteSelectionFromSelector(score, selector) {
        return SmoSelection.lastNoteSelection(score, selector.staff, selector.measure, selector.voice, selector.tick);
    }
    static lastNoteSelection(score, staffIndex, measureIndex, voiceIndex, tickIndex) {
        const lastTick = tickIndex - 1;
        const lastMeasure = measureIndex - 1;
        const staff = score.staves[staffIndex];
        let measure = staff.measures[measureIndex];
        if (tickIndex > 0) {
            return SmoSelection.noteSelection(score, staffIndex, measureIndex, voiceIndex, lastTick);
        }
        if (lastMeasure >= 0) {
            measure = staff.measures[lastMeasure];
            if (voiceIndex >= measure.voices.length) {
                return null;
            }
            const noteIndex = measure.voices[voiceIndex].notes.length - 1;
            return SmoSelection.noteSelection(score, staffIndex, lastMeasure, voiceIndex, noteIndex);
        }
        if (measureIndex === 0 && voiceIndex === 0 && tickIndex === 0) {
            return null;
        }
        return SmoSelection.noteSelection(score, staffIndex, 0, 0, 0);
    }
    // ### getMeasureList
    // Gets the list of measures in an array from the selections
    static getMeasureList(selections) {
        let i = 0;
        let cur = {};
        const rv = [];
        if (!selections.length) {
            return rv;
        }
        cur = selections[0].selector.measure;
        for (i = 0; i < selections.length; ++i) {
            const sel = selections[i];
            if (i === 0 || (sel.selector.measure !== cur)) {
                const _staff = sel._staff;
                const _measure = sel._measure;
                rv.push(new SmoSelection({
                    selector: {
                        staff: sel.selector.staff,
                        measure: sel.selector.measure,
                        voice: 0,
                        tick: 0,
                        pitches: []
                    },
                    _staff,
                    _measure
                }));
            }
            cur = sel.selector.measure;
        }
        return rv;
    }
    static getMeasuresBetween(score, fromSelector, toSelector) {
        let i = 0;
        const rv = [];
        if (fromSelector.staff !== toSelector.staff) {
            return rv;
        }
        for (i = fromSelector.measure; i <= toSelector.measure; ++i) {
            const sel = SmoSelection.measureSelection(score, fromSelector.staff, i);
            if (sel) {
                rv.push(sel);
            }
        }
        return rv;
    }
    // ### selectionsSameMeasure
    // Return true if the selections are all in the same measure.  Used to determine what
    // type of undo we need.
    static selectionsSameMeasure(selections) {
        let i = 0;
        if (selections.length < 2) {
            return true;
        }
        const sel1 = selections[0].selector;
        for (i = 1; i < selections.length; ++i) {
            if (!SmoSelector.sameMeasure(sel1, selections[i].selector)) {
                return false;
            }
        }
        return true;
    }
    static selectionsSameStaff(selections) {
        let i = 0;
        if (selections.length < 2) {
            return true;
        }
        const sel1 = selections[0].selector;
        for (i = 1; i < selections.length; ++i) {
            if (!SmoSelector.sameStaff(sel1, selections[i].selector)) {
                return false;
            }
        }
        return true;
    }
    get staff() {
        return this._staff;
    }
    get measure() {
        return this._measure;
    }
    get note() {
        return this._note;
    }
    get pitches() {
        return this.selector.pitches;
    }
}
exports.SmoSelection = SmoSelection;


/***/ }),

/***/ "./src/smo/xform/tickDuration.ts":
/*!***************************************!*\
  !*** ./src/smo/xform/tickDuration.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SmoStretchNoteActor = exports.SmoMakeTupletActor = exports.SmoUnmakeTupletActor = exports.SmoContractTupletActor = exports.SmoContractNoteActor = exports.SmoTickIterator = exports.SmoDuration = exports.TickIteratorBase = void 0;
// [Smoosic](https://github.com/AaronDavidNewman/Smoosic)
// Copyright (c) Aaron David Newman 2021.
const note_1 = __webpack_require__(/*! ../data/note */ "./src/smo/data/note.ts");
const tuplet_1 = __webpack_require__(/*! ../data/tuplet */ "./src/smo/data/tuplet.ts");
const music_1 = __webpack_require__(/*! ../data/music */ "./src/smo/data/music.ts");
/**
 * Abstract class for classes that modifiy duration.
 * @param note the note we're iterating over
 * @param tickmap the tickmap for the measure
 * @param index the index into the tickmap
 * @returns the note or notes that replace this one.  Null if this note is no longer in the measure
 */
class TickIteratorBase {
    // es
    iterateOverTick(note, tickmap, index) {
        return null;
    }
}
exports.TickIteratorBase = TickIteratorBase;
/**
 * SmoDuration: change the duration of a note, maybe at the expense of some
 * other note.
 * @category SmoTransform
 */
class SmoDuration {
    /**
     * doubleDurationNonTuplet
     * double the duration of the selection, consuming the next note or
     * possibly split it in half and consume that.  Simple operation so
     * do it inline
     * @param selection
     * @returns
     */
    static doubleDurationNonTuplet(selection) {
        const note = selection === null || selection === void 0 ? void 0 : selection.note;
        const measure = selection.measure;
        if (note === null) {
            return;
        }
        const selector = selection.selector;
        const voices = measure === null || measure === void 0 ? void 0 : measure.voices;
        const voice = voices[selector.voice];
        const notes = voice === null || voice === void 0 ? void 0 : voice.notes;
        let i = 0;
        const nticks = { numerator: note.tickCount * 2, denominator: 1, remainder: 0 };
        const replNote = note_1.SmoNote.cloneWithDuration(note, nticks);
        let ticksUsed = note.tickCount;
        const newNotes = [];
        for (i = 0; i < selector.tick; ++i) {
            newNotes.push(notes[i]);
        }
        for (i = selector.tick + 1; i < notes.length; ++i) {
            const nnote = notes[i];
            ticksUsed += nnote.tickCount;
            if (ticksUsed >= nticks.numerator) {
                break;
            }
        }
        const remainder = ticksUsed - nticks.numerator;
        if (remainder < 0) {
            return;
        }
        newNotes.push(replNote);
        if (remainder > 0) {
            const lmap = music_1.SmoMusic.gcdMap(remainder);
            lmap.forEach((duration) => {
                newNotes.push(note_1.SmoNote.cloneWithDuration(note, duration));
            });
        }
        for (i = i + 1; i < notes.length; ++i) {
            newNotes.push(notes[i]);
        }
        // If any tuplets got removed while extending the notes,
        voice.notes = newNotes;
        const measureTuplets = [];
        const allTuplets = measure === null || measure === void 0 ? void 0 : measure.tuplets;
        allTuplets === null || allTuplets === void 0 ? void 0 : allTuplets.forEach((tuplet) => {
            const testNotes = measure === null || measure === void 0 ? void 0 : measure.tupletNotes(tuplet);
            if ((testNotes === null || testNotes === void 0 ? void 0 : testNotes.length) === tuplet.notes.length) {
                measureTuplets.push(tuplet);
            }
        });
        measure.tuplets = measureTuplets;
    }
    /**
     * double duration, tuplet form.  Increase the first selection and consume the
     * following note.  Also a simple operation
     * @param selection
     * @returns
     */
    static doubleDurationTuplet(selection) {
        let i = 0;
        const measure = selection.measure;
        const note = selection === null || selection === void 0 ? void 0 : selection.note;
        if (note === null) {
            return;
        }
        const notes = measure.voices[selection.selector.voice].notes;
        const tuplet = measure.getTupletForNote(note);
        if (tuplet === null) {
            return;
        }
        const startIndex = selection.selector.tick - tuplet.startIndex;
        const startLength = tuplet.notes.length;
        tuplet.combine(startIndex, startIndex + 1);
        if (tuplet.notes.length >= startLength) {
            return;
        }
        const newNotes = [];
        for (i = 0; i < tuplet.startIndex; ++i) {
            newNotes.push(notes[i]);
        }
        tuplet.notes.forEach((note) => {
            newNotes.push(note);
        });
        for (i = i + tuplet.notes.length + 1; i < notes.length; ++i) {
            newNotes.push(notes[i]);
        }
        measure.voices[selection.selector.voice].notes = newNotes;
    }
}
exports.SmoDuration = SmoDuration;
/**
 * SmoTickIterator
 * this is a local helper class that follows a pattern of iterating of the notes.  Most of the
 * duration changers iterate over a selection, and return:
 * - A note, if the duration changes
 * - An array of notes, if the notes split
 * - null if the note stays the same
 * - empty array, remove the note from the group
 * @category SmoTransform
 */
class SmoTickIterator {
    constructor(measure, actor, voiceIndex) {
        this.notes = [];
        this.newNotes = [];
        this.voice = 0;
        this.notes = measure.voices[voiceIndex].notes;
        this.measure = measure;
        this.voice = typeof (voiceIndex) === 'number' ? voiceIndex : 0;
        this.newNotes = [];
        // eslint-disable-next-line
        this.actor = actor;
        this.keySignature = 'C';
    }
    static nullActor(note) {
        return note;
    }
    /**
     *
     * @param measure {SmoMeasure}
     * @param actor {}
     * @param voiceIndex
     */
    static iterateOverTicks(measure, actor, voiceIndex) {
        measure.clearBeamGroups();
        const transformer = new SmoTickIterator(measure, actor, voiceIndex);
        transformer.run();
        measure.voices[voiceIndex].notes = transformer.notes;
    }
    // ### transformNote
    // call the actors for each note, and put the result in the note array.
    // The note from the original array is copied and sent to each actor.
    //
    // Because the resulting array can have a different number of notes than the existing
    // array, the actors communicate with the transformer in the following, jquery-ish
    // but somewhat unintuitive way:
    //
    // 1. if the actor returns null, the next actor is called and the results of that actor are used
    // 2. if all the actors return null, the copy is used.
    // 3. if a note object is returned, that is used for the current tick and no more actors are called.
    // 4. if an array of notes is returned, it is concatenated to the existing note array and no more actors are called.
    //     Note that *return note;* and *return [note];* produce the same result.
    // 5. if an empty array [] is returned, that copy is not added to the result.  The note is effectively deleted.
    iterateOverTick(tickmap, index, note) {
        const actor = this.actor;
        const newNote = actor.iterateOverTick(note, tickmap, index);
        if (newNote === null) {
            this.newNotes.push(note); // no change
            return note;
        }
        if (Array.isArray(newNote)) {
            if (newNote.length === 0) {
                return null;
            }
            this.newNotes = this.newNotes.concat(newNote);
            return null;
        }
        this.newNotes.push(newNote);
        return null;
    }
    run() {
        let i = 0;
        const tickmap = this.measure.tickmapForVoice(this.voice);
        for (i = 0; i < tickmap.durationMap.length; ++i) {
            this.iterateOverTick(tickmap, i, this.measure.voices[this.voice].notes[i]);
        }
        this.notes = this.newNotes;
        return this.newNotes;
    }
}
exports.SmoTickIterator = SmoTickIterator;
/**
 * Contract the duration of a note, filling in the space with another note
 * or rest.
 * @category SmoTransform
 * */
class SmoContractNoteActor extends TickIteratorBase {
    constructor(params) {
        super();
        this.startIndex = params.startIndex;
        this.measure = params.measure;
        this.voice = params.voice;
        this.tickmap = this.measure.tickmapForVoice(this.voice);
        this.newTicks = params.newTicks;
    }
    static apply(params) {
        const actor = new SmoContractNoteActor(params);
        SmoTickIterator.iterateOverTicks(actor.measure, actor, actor.voice);
    }
    iterateOverTick(note, tickmap, index) {
        let i = 0;
        if (index === this.startIndex) {
            const notes = [];
            const noteCount = Math.floor(note.ticks.numerator / this.newTicks);
            let remainder = note.ticks.numerator;
            /**
             *  Replace 1 note with noteCOunt notes of newTIcks duration
             *      old map:
             *     d  .  d  .  .
             *     new map:
             *     d  d  d  .  .
             */
            for (i = 0; i < noteCount; ++i) {
                // first note, retain modifiers so clone.  Otherwise just
                // retain pitches
                if (i === 0) {
                    const nn = note_1.SmoNote.clone(note);
                    nn.ticks = { numerator: this.newTicks, denominator: 1, remainder: 0 };
                    notes.push(nn);
                }
                else {
                    const nnote = new note_1.SmoNote(note_1.SmoNote.defaults);
                    nnote.clef = note.clef;
                    nnote.pitches = JSON.parse(JSON.stringify(note.pitches));
                    nnote.ticks = { numerator: this.newTicks, denominator: 1, remainder: 0 };
                    nnote.beamBeats = note.beamBeats;
                    notes.push(nnote);
                }
                remainder = remainder - this.newTicks;
            }
            // make sure remnainder is not too short
            if (remainder > 0) {
                if (remainder < 128) {
                    return null;
                }
                const nnote = new note_1.SmoNote(note_1.SmoNote.defaults);
                nnote.clef = note.clef;
                nnote.pitches = JSON.parse(JSON.stringify(note.pitches));
                nnote.ticks = { numerator: remainder, denominator: 1, remainder: 0 };
                nnote.beamBeats = note.beamBeats;
                notes.push(nnote);
            }
            return notes;
        }
        return null;
    }
}
exports.SmoContractNoteActor = SmoContractNoteActor;
/**
 * Shrink the duration of a note in a tuplet by creating additional notes
 * @category SmoTransform
 */
class SmoContractTupletActor extends TickIteratorBase {
    constructor(params) {
        super();
        this.oldLength = 0;
        this.tupletIndex = 0;
        this.splitIndex = 0;
        this.changeIndex = params.changeIndex;
        this.measure = params.measure;
        this.voice = params.voice;
        this.tuplet = this.measure.getTupletForNote(this.measure.voices[this.voice].notes[this.changeIndex]);
        if (this.tuplet === null) {
            return;
        }
        this.oldLength = this.tuplet.notes.length;
        this.tupletIndex = this.measure.tupletIndex(this.tuplet);
        this.splitIndex = this.changeIndex - this.tupletIndex;
        this.tuplet.split(this.splitIndex);
    }
    static apply(params) {
        const actor = new SmoContractTupletActor(params);
        SmoTickIterator.iterateOverTicks(actor.measure, actor, actor.voice);
    }
    iterateOverTick(note, tickmap, index) {
        if (this.tuplet === null) {
            return null;
        }
        if (index < this.tupletIndex) {
            return note;
        }
        if (index >= this.tupletIndex + this.oldLength) {
            return note;
        }
        if (index === this.changeIndex) {
            return this.tuplet.notes;
        }
        return [];
    }
}
exports.SmoContractTupletActor = SmoContractTupletActor;
/**
 * Convert a tuplet into a single note that takes up the whole duration
 * @category SmoTransform
 */
class SmoUnmakeTupletActor extends TickIteratorBase {
    constructor(parameters) {
        super();
        this.startIndex = 0;
        this.endIndex = 0;
        this.startIndex = parameters.startIndex;
        this.endIndex = parameters.endIndex;
        this.measure = parameters.measure;
        this.voice = parameters.voice;
    }
    static apply(params) {
        const actor = new SmoUnmakeTupletActor(params);
        SmoTickIterator.iterateOverTicks(actor.measure, actor, actor.voice);
    }
    iterateOverTick(note, tickmap, index) {
        if (index < this.startIndex || index > this.endIndex) {
            return null;
        }
        if (index === this.startIndex) {
            const tuplet = this.measure.getTupletForNote(note);
            if (tuplet === null) {
                return [];
            }
            const ticks = tuplet.totalTicks;
            const nn = note_1.SmoNote.cloneWithDuration(note, { numerator: ticks, denominator: 1, remainder: 0 });
            nn.tuplet = {};
            this.measure.removeTupletForNote(note);
            return [nn];
        }
        return [];
    }
}
exports.SmoUnmakeTupletActor = SmoUnmakeTupletActor;
/**
 * Turn a tuplet into a non-tuplet of the same length
 * @category SmoTransform
 *
 * */
class SmoMakeTupletActor extends TickIteratorBase {
    constructor(params) {
        let i = 0;
        super();
        this.measure = params.measure;
        this.numNotes = params.numNotes;
        this.durationMap = [];
        this.totalTicks = params.totalTicks;
        this.voice = params.voice;
        this.index = params.index;
        for (i = 0; i < this.numNotes; ++i) {
            this.durationMap.push(1.0);
        }
        this.stemTicks = tuplet_1.SmoTuplet.calculateStemTicks(this.totalTicks, this.numNotes);
        this.rangeToSkip = this._rangeToSkip();
        this.tuplet = [];
    }
    static apply(params) {
        const actor = new SmoMakeTupletActor(params);
        SmoTickIterator.iterateOverTicks(actor.measure, actor, actor.voice);
    }
    _rangeToSkip() {
        let i = 0;
        if (this.measure === null) {
            return [];
        }
        const ticks = this.measure.tickmapForVoice(this.voice);
        let accum = 0;
        const rv = [];
        rv.push(this.index);
        for (i = 0; i < ticks.deltaMap.length; ++i) {
            if (i >= this.index) {
                accum += ticks.deltaMap[i];
            }
            if (accum >= this.totalTicks) {
                rv.push(i);
                break;
            }
        }
        return rv;
    }
    iterateOverTick(note, tickmap, index) {
        let i = 0;
        // if our tuplet replaces this note, make sure we make it go away.
        if (index > this.index && index <= this.rangeToSkip[1]) {
            return [];
        }
        if (this.measure === null) {
            return [];
        }
        if (index !== this.index) {
            return null;
        }
        for (i = 0; i < this.numNotes; ++i) {
            note = note_1.SmoNote.cloneWithDuration(note, { numerator: this.stemTicks, denominator: 1, remainder: 0 });
            // Don't clone modifiers, except for first one.
            note.textModifiers = i === 0 ? note.textModifiers : [];
            this.tuplet.push(note);
        }
        const tuplet = new tuplet_1.SmoTuplet({
            notes: this.tuplet,
            stemTicks: this.stemTicks,
            totalTicks: this.totalTicks,
            ratioed: false,
            bracketed: true,
            startIndex: index,
            durationMap: this.durationMap,
            voice: tickmap.voice,
            numNotes: this.numNotes
        });
        this.measure.tuplets.push(tuplet);
        return this.tuplet;
    }
}
exports.SmoMakeTupletActor = SmoMakeTupletActor;
/**
 * increase the length of a note, removing future notes in the measure as required
 * @category SmoTransform
 */
class SmoStretchNoteActor extends TickIteratorBase {
    constructor(params) {
        let mapIx = 0;
        let i = 0;
        super();
        this.startIndex = params.startIndex;
        this.measure = params.measure;
        this.voice = params.voice;
        this.tickmap = this.measure.tickmapForVoice(this.voice);
        this.newTicks = params.newTicks;
        this.startTick = this.tickmap.durationMap[this.startIndex];
        const currentTicks = this.tickmap.deltaMap[this.startIndex];
        const endTick = this.tickmap.durationMap[this.startIndex] + this.newTicks;
        this.divisor = -1;
        this.durationMap = [];
        this.skipFromStart = this.startIndex + 1;
        this.skipFromEnd = this.startIndex + 1;
        this.durationMap.push(this.newTicks);
        mapIx = this.tickmap.durationMap.indexOf(endTick);
        const remaining = this.tickmap.deltaMap.slice(this.startIndex, this.tickmap.durationMap.length).reduce((accum, x) => x + accum);
        if (remaining === this.newTicks) {
            mapIx = this.tickmap.deltaMap.length;
        }
        // If there is no tickable at the end point, try to split the next note
        /**
         *      old map:
         *     d  . d  .
         *     split map:
         *     d  .  d  d
         *     new map:
         *     d .   .  d
         */
        if (mapIx < 0) {
            const ndelta = this.tickmap.deltaMap[this.startIndex + 1];
            const needed = this.newTicks - currentTicks;
            const exp = ndelta / needed;
            // Next tick does not divide evenly into this, or next tick is shorter than this
            if (Math.round(ndelta / exp) - ndelta / exp !== 0 || ndelta < 256) {
                this.durationMap = [];
            }
            else if (ndelta / exp + this.startTick + this.newTicks <= this.tickmap.totalDuration) {
                this.durationMap.push(ndelta - (ndelta / exp));
            }
            else {
                // there is no way to do this...
                this.durationMap = [];
            }
        }
        else {
            // If this note now takes up the space of other notes, remove those notes
            for (i = this.startIndex + 1; i < mapIx; ++i) {
                this.durationMap.push(0);
            }
        }
    }
    static apply(params) {
        const actor = new SmoStretchNoteActor(params);
        SmoTickIterator.iterateOverTicks(actor.measure, actor, actor.voice);
    }
    iterateOverTick(note, tickmap, index) {
        if (this.durationMap.length === 0) {
            return null;
        }
        if (index >= this.startIndex && index < this.startIndex + this.durationMap.length) {
            const mapIndex = index - this.startIndex;
            const ticks = this.durationMap[mapIndex];
            if (ticks === 0) {
                return [];
            }
            note = note_1.SmoNote.cloneWithDuration(note, { numerator: ticks, denominator: 1, remainder: 0 });
            return [note];
        }
        return null;
    }
}
exports.SmoStretchNoteActor = SmoStretchNoteActor;


/***/ }),

/***/ "./src/smo/xform/tickMap.ts":
/*!**********************************!*\
  !*** ./src/smo/xform/tickMap.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TickMap = void 0;
// [Smoosic](https://github.com/AaronDavidNewman/Smoosic)
// Copyright (c) Aaron David Newman 2021.
const music_1 = __webpack_require__(/*! ../data/music */ "./src/smo/data/music.ts");
const VF = eval('Vex.Flow');
/**
 * create a map note durations at each index into the voice, including the accidentals at each duration.
 * return format:
 * ```
   tickmap = {
          totalDuration: 16384,
          durationMap:[2048,4096,..],  // A running total per tick
            deltaMap:[2048,2048...], a map of deltas
 ```
 * @category SmoTransform
 */
class TickMap {
    constructor(measure, voiceIndex) {
        this.notes = [];
        this.index = 0;
        this.startIndex = 0;
        this.endIndex = 0;
        // duration is the accumulated duraition over all the notes
        this.totalDuration = 0;
        // delta is the tick contribution of this note
        this.delta = 0;
        // the absolute tick start location of notes[x]
        this.durationMap = [];
        // the relative duration if each tick slot
        this.deltaMap = [];
        // An array of active accidentals for each tick index
        this.accidentalMap = [];
        // a map of active accidentals, indexed by duration index
        this.durationAccidentalMap = {};
        this.keySignature = measure.keySignature;
        this.voice = voiceIndex;
        if (measure.voices.length <= this.voice) {
            console.warn('tickmap for invalid voice');
            return;
        }
        this.notes = measure.voices[this.voice].notes;
        this.endIndex = this.notes.length;
        this.createMap();
    }
    // ### _getAccidentalsForKey
    // Update `map` with the correct accidental based on the key signature.
    _getAccidentalsForKey(map) {
        const music = new VF.Music();
        const keys = music.createScaleMap(this.keySignature);
        const keyKeys = Object.keys(keys);
        keyKeys.forEach((keyKey) => {
            const vexKey = keys[keyKey];
            if (vexKey.length > 1 && (vexKey[1] === 'b' || vexKey[1] === '#')) {
                const pitch = {
                    letter: vexKey[0],
                    accidental: vexKey[1],
                    octave: 4
                };
                map[vexKey[0]] = {
                    duration: 0,
                    pitch
                };
            }
        });
    }
    // ### updateAccidentalMap
    // Keep a running tally of the accidentals for this voice
    // based on the key and previous accidentals.
    updateAccidentalMap(note) {
        let i = 0;
        let sigObj = {};
        const newObj = {};
        if (this.index === 0) {
            this._getAccidentalsForKey(newObj);
            sigObj = newObj;
        }
        else {
            sigObj = this.accidentalMap[this.index - 1];
        }
        for (i = 0; i < note.pitches.length; ++i) {
            if (note.noteType !== 'n') {
                continue;
            }
            const pitch = note.pitches[i];
            const pitchOctave = pitch.letter.toLowerCase() + '-' + pitch.octave;
            const sigLetter = pitchOctave + pitch.accidental;
            const sigKey = music_1.SmoMusic.getKeySignatureKey(pitch.letter, this.keySignature);
            if (sigObj && sigObj[pitchOctave]) {
                const curObj = sigObj[pitchOctave];
                const currentVal = curObj.pitch.letter.toLowerCase() + '-' + curObj.pitch.octave + curObj.pitch.accidental;
                if (sigLetter !== currentVal) {
                    newObj[pitchOctave] = { pitch, duration: this.duration };
                }
            }
            else {
                if (sigLetter !== sigKey) {
                    newObj[pitchOctave] = { pitch, duration: this.duration };
                }
            }
        }
        this.accidentalMap.push(newObj);
        // Mark the accidental with the start of this note.
        this.durationAccidentalMap[this.durationMap[this.index]] = newObj;
    }
    // ### getActiveAccidental
    // return the active accidental for the given note
    getActiveAccidental(pitch, iteratorIndex, keySignature) {
        let defaultAccidental = music_1.SmoMusic.getKeySignatureKey(pitch.letter, keySignature);
        let i = 0;
        let j = 0;
        defaultAccidental = defaultAccidental.length > 1 ? defaultAccidental[1] : 'n';
        if (iteratorIndex === 0) {
            return defaultAccidental;
        }
        // Back up the accidental map until we have a match, or until we run out
        for (i = iteratorIndex; i > 0; --i) {
            const map = this.accidentalMap[i - 1];
            const mapKeys = Object.keys(map);
            for (j = 0; j < mapKeys.length; ++j) {
                const mapKey = mapKeys[j];
                // The letter name + accidental in the map
                const mapPitch = map[mapKey].pitch;
                const mapAcc = mapPitch.accidental ? mapPitch.accidental : 'n';
                // if the letters match and the accidental...
                if (mapPitch.letter.toLowerCase() === pitch.letter) {
                    return mapAcc;
                }
            }
        }
        return defaultAccidental;
    }
    get duration() {
        return this.totalDuration;
    }
    createMap() {
        for (this.index = this.startIndex; this.index < this.endIndex; ++this.index) {
            const note = this.notes[this.index];
            // save the starting point, tickwise
            this.durationMap.push(this.totalDuration);
            // the number of ticks for this note
            this.delta = (note.ticks.numerator / note.ticks.denominator) + note.ticks.remainder;
            this.deltaMap.push(this.delta);
            // update the tick count for the whole array/measure
            this.totalDuration += this.delta;
            this.updateAccidentalMap(note);
        }
    }
}
exports.TickMap = TickMap;


/***/ }),

/***/ "./src/smo/xform/toVex.ts":
/*!********************************!*\
  !*** ./src/smo/xform/toVex.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SmoToVex = void 0;
// [Smoosic](https://github.com/AaronDavidNewman/Smoosic)
// Copyright (c) Aaron David Newman 2021.
const music_1 = __webpack_require__(/*! ../data/music */ "./src/smo/data/music.ts");
// ## SmoToVex
// Simple serialize class that produced VEX note and voice objects
// for vex EasyScore (for easier bug reports and test cases)
class SmoToVex {
    static convert(smoScore, options) {
        let useId = false;
        options = options !== null && options !== void 0 ? options : {};
        if (typeof (options['id']) === 'boolean') {
            useId = options.id;
        }
        smoScore.staves.forEach((smoStaff, staffIx) => {
            smoStaff.measures.forEach((smoMeasure, measureIx) => {
                const voiceStrings = [];
                const lyricsHash = {};
                smoMeasure.voices.forEach((smoVoice, vix) => {
                    let keyString = '';
                    voiceStrings.push([]);
                    smoVoice.notes.forEach((smoNote, nix) => {
                        const noteId = 'v' + vix + 'n' + nix;
                        let duration = music_1.SmoMusic.ticksToDuration[music_1.SmoMusic.closestDurationTickLtEq(smoNote.tickCount)];
                        duration = duration.replaceAll('d', '.');
                        if (smoNote.pitches.length > 1) {
                            keyString += '(';
                        }
                        smoNote.pitches.forEach((smoPitch, pitchIx) => {
                            // Create a copy of the pitch.  If the accidental is not displayed, ignore it
                            const pitch = { letter: smoPitch.letter, accidental: '', octave: smoPitch.octave };
                            if (smoNote.accidentalsRendered && smoNote.accidentalsRendered[pitchIx].length) {
                                pitch.accidental = smoPitch.accidental;
                            }
                            keyString += music_1.SmoMusic.pitchToEasyScore(pitch);
                            if (pitchIx + 1 < smoNote.pitches.length) {
                                keyString += ' ';
                            }
                        });
                        if (smoNote.pitches.length > 1) {
                            keyString += ')';
                        }
                        keyString += '/' + duration;
                        if (useId) {
                            keyString += "[id='" + noteId + "'],";
                        }
                        smoNote.getTrueLyrics().forEach((lyric) => {
                            if (typeof lyricsHash[noteId] === 'undefined') {
                                lyricsHash[noteId] = [];
                            }
                            lyricsHash[noteId].push(lyric.getText());
                        });
                    });
                    voiceStrings.push(keyString);
                });
                console.log('// notes', staffIx, measureIx, '=', JSON.stringify(voiceStrings, null, ''));
                console.log('// lyrics', staffIx, measureIx, '=', JSON.stringify(lyricsHash), null, '');
            });
        });
    }
}
exports.SmoToVex = SmoToVex;


/***/ }),

/***/ "./src/smo/xform/undo.ts":
/*!*******************************!*\
  !*** ./src/smo/xform/undo.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SmoUndoable = exports.UndoBuffer = exports.copyUndo = void 0;
// [Smoosic](https://github.com/AaronDavidNewman/Smoosic)
// Copyright (c) Aaron David Newman 2021.
const staffModifiers_1 = __webpack_require__(/*! ../data/staffModifiers */ "./src/smo/data/staffModifiers.ts");
const systemStaff_1 = __webpack_require__(/*! ../data/systemStaff */ "./src/smo/data/systemStaff.ts");
const music_1 = __webpack_require__(/*! ../data/music */ "./src/smo/data/music.ts");
const operations_1 = __webpack_require__(/*! ./operations */ "./src/smo/xform/operations.ts");
const score_1 = __webpack_require__(/*! ../data/score */ "./src/smo/data/score.ts");
const measure_1 = __webpack_require__(/*! ../data/measure */ "./src/smo/data/measure.ts");
const serializationHelpers_1 = __webpack_require__(/*! ../../common/serializationHelpers */ "./src/common/serializationHelpers.js");
const scoreText_1 = __webpack_require__(/*! ../data/scoreText */ "./src/smo/data/scoreText.ts");
const selections_1 = __webpack_require__(/*! ./selections */ "./src/smo/xform/selections.ts");
function copyUndo(entry) {
    const obj = {
        title: entry.title,
        type: entry.type,
        selector: entry.selector,
        subtype: entry.subtype,
        grouped: entry.grouped,
        firstInGroup: entry.firstInGroup,
        json: undefined
    };
    if (entry.json) {
        obj.json = JSON.parse(JSON.stringify(entry.json));
    }
    return obj;
}
exports.copyUndo = copyUndo;
/**
 * manage a set of undo or redo operations on a score.  The objects passed into
 * undo must implement serialize()/deserialize()
 *
 * ## Buffer format:
 * A buffer is one of 7 things:
 * * A single measure,
 * * A single staff
 *  * the whole score
 *  * a score modifier (text)
 *  * score attributes (layout, etc)
 *  * column - all the measures at one index
 *  * rectangle - a rectangle of measures
 * @category SmoTransform
 * */
class UndoBuffer {
    constructor() {
        this.buffer = [];
        this.reconcile = -1;
        this.buffer = [];
        this.opCount = 0;
        this._grouping = false;
    }
    static get bufferMax() {
        return 100;
    }
    static get bufferTypes() {
        return {
            FIRST: 1,
            MEASURE: 1, STAFF: 2, SCORE: 3, SCORE_MODIFIER: 4, COLUMN: 5, RECTANGLE: 6,
            SCORE_ATTRIBUTES: 7, STAFF_MODIFIER: 8, LAST: 8
        };
    }
    static get bufferSubtypes() {
        return {
            NONE: 0, ADD: 1, REMOVE: 2, UPDATE: 3
        };
    }
    static get bufferTypeLabel() {
        return ['INVALID', 'MEASURE', 'STAFF', 'SCORE', 'SCORE_MODIFIER', 'COLUMN', 'RECTANGLE',
            'SCORE_ATTRIBUTES', 'STAFF_MODIFIER'];
    }
    // ### serializeMeasure
    // serialize a measure, preserving the column-mapped bits which aren't serialized on a full score save.
    static serializeMeasure(measure) {
        const json = measure.serialize();
        const columnMapped = measure.serializeColumnMapped();
        Object.keys(columnMapped).forEach((key) => {
            json[key] = columnMapped[key];
        });
        return json;
    }
    get grouping() {
        return this._grouping;
    }
    // Allows a set of operations to be bunched into a single group
    set grouping(val) {
        if (this._grouping === true && val === false) {
            const buf = this.peek();
            // If we have been grouping, indicate that the last buffer is the
            // fist part of a group
            if (buf) {
                buf.firstInGroup = true;
            }
        }
        this._grouping = val;
    }
    reset() {
        this.buffer = [];
    }
    // ### addBuffer
    // Description:
    // Add the current state of the score required to undo the next operation we
    // are about to perform.  For instance, if we are adding a crescendo, we back up the
    // staff the crescendo will go on.
    addBuffer(title, type, selector, obj, subtype) {
        let i = 0;
        let j = 0;
        if (typeof (type) !== 'number' || type < UndoBuffer.bufferTypes.FIRST || type > UndoBuffer.bufferTypes.LAST) {
            throw 'Undo failure: illegal buffer type ' + type;
        }
        const undoObj = {
            title,
            type,
            selector,
            subtype,
            grouped: this._grouping,
            firstInGroup: false
        };
        if (type === UndoBuffer.bufferTypes.RECTANGLE) {
            // RECTANGLE obj is {score, topLeft, bottomRight}
            // where the last 2 are selectors
            const measures = [];
            for (i = obj.topLeft.staff; i <= obj.bottomRight.staff; ++i) {
                for (j = obj.topLeft.measure; j <= obj.bottomRight.measure; ++j) {
                    measures.push(UndoBuffer.serializeMeasure(obj.score.staves[i].measures[j]));
                }
            }
            undoObj.json = { topLeft: JSON.parse(JSON.stringify(obj.topLeft)),
                bottomRight: JSON.parse(JSON.stringify(obj.bottomRight)),
                measures };
        }
        else if (type === UndoBuffer.bufferTypes.SCORE_ATTRIBUTES) {
            undoObj.json = {};
            serializationHelpers_1.smoSerialize.serializedMerge(score_1.SmoScore.preferences, obj, undoObj.json);
        }
        else if (type === UndoBuffer.bufferTypes.COLUMN) {
            // COLUMN obj is { score, measureIndex }
            const ix = obj.measureIndex;
            const measures = [];
            obj.score.staves.forEach((staff) => {
                measures.push(UndoBuffer.serializeMeasure(staff.measures[ix]));
            });
            undoObj.json = { measureIndex: ix, measures };
        }
        else if (type === UndoBuffer.bufferTypes.MEASURE) {
            // If this is a measure, preserve the column-mapped attributes
            undoObj.json = UndoBuffer.serializeMeasure(obj);
        }
        else if (type === UndoBuffer.bufferTypes.SCORE_MODIFIER ||
            type === UndoBuffer.bufferTypes.STAFF_MODIFIER) {
            // score modifier, already serialized
            undoObj.json = obj;
        }
        else {
            // staff or score or staffModifier
            undoObj.json = obj.serialize();
        }
        if (this.buffer.length >= UndoBuffer.bufferMax) {
            this.buffer.splice(0, 1);
        }
        this.opCount += 1;
        this.buffer.push(undoObj);
    }
    // ### _pop
    // ### Description:
    // Internal method to pop the top buffer off the stack.
    _pop() {
        if (this.buffer.length < 1) {
            return null;
        }
        const buf = this.buffer.pop();
        return buf;
    }
    // ## Before undoing, peek at the top action in the q
    // so it can be re-rendered
    peek() {
        if (this.buffer.length < 1) {
            return null;
        }
        return this.buffer[this.buffer.length - 1];
    }
    peekIndex(index) {
        if (this.buffer.length - index < 1) {
            return null;
        }
        return this.buffer[this.buffer.length - (1 + index)];
    }
    // ## undo
    // ## Description:
    // Undo the operation at the top of the undo stack.  This is done by replacing
    // the music as it existed before the change was made.
    undo(score, staffMap, pop) {
        var _a;
        let i = 0;
        let j = 0;
        let mix = 0;
        let buf = null;
        let peekIndex = 0;
        if (pop) {
            buf = this._pop();
        }
        else {
            buf = this.peekIndex(peekIndex);
            if (buf) {
                buf = copyUndo(buf);
            }
        }
        if (!buf) {
            return score;
        }
        const grouping = buf.firstInGroup;
        while (buf) {
            if (buf.type === UndoBuffer.bufferTypes.RECTANGLE) {
                for (i = buf.json.topLeft.staff; i <= buf.json.bottomRight.staff; ++i) {
                    for (j = buf.json.topLeft.measure; j <= buf.json.bottomRight.measure; ++j) {
                        const measure = measure_1.SmoMeasure.deserialize(buf.json.measures[mix]);
                        mix += 1;
                        const selector = selections_1.SmoSelector.default;
                        if (typeof (staffMap[i]) === 'number') {
                            selector.staff = staffMap[i];
                            measure.measureNumber.staffId = staffMap[i];
                            selector.measure = j;
                            score.replaceMeasure(selector, measure);
                        }
                    }
                }
            }
            else if (buf.type === UndoBuffer.bufferTypes.STAFF_MODIFIER) {
                const modifier = staffModifiers_1.StaffModifierBase.deserialize(buf.json);
                if (typeof (staffMap[modifier.startSelector.staff]) === 'number') {
                    const staff = score.staves[staffMap[modifier.startSelector.staff]];
                    const existing = staff.getModifier(modifier);
                    if (existing) {
                        staff.removeStaffModifier(existing);
                    }
                    // If we undo an add, we just remove it.
                    if (buf.subtype !== UndoBuffer.bufferSubtypes.ADD) {
                        if (modifier.ctor === 'SmoStaffTextBracket') {
                            staff.addTextBracket(modifier);
                        }
                        else {
                            staff.addStaffModifier(modifier);
                        }
                    }
                }
            }
            else if (buf.type === UndoBuffer.bufferTypes.SCORE_ATTRIBUTES) {
                serializationHelpers_1.smoSerialize.serializedMerge(score_1.SmoScore.preferences, buf.json, score);
            }
            else if (buf.type === UndoBuffer.bufferTypes.COLUMN) {
                for (i = 0; i < score.staves.length; ++i) {
                    const measure = measure_1.SmoMeasure.deserialize(buf.json.measures[i]);
                    const selector = selections_1.SmoSelector.default;
                    if (typeof (staffMap[i]) === 'number') {
                        selector.staff = staffMap[i];
                        measure.measureNumber.staffId = staffMap[i];
                        selector.measure = buf.json.measureIndex;
                        score.replaceMeasure(selector, measure);
                    }
                }
            }
            else if (buf.type === UndoBuffer.bufferTypes.MEASURE) {
                // measure expects key signature to be in concert key.
                if (typeof (staffMap[buf.selector.staff]) === 'number') {
                    buf.selector.staff = staffMap[buf.selector.staff];
                    const xpose = (_a = buf.json.transposeIndex) !== null && _a !== void 0 ? _a : 0;
                    const concertKey = music_1.SmoMusic.vexKeySigWithOffset(buf.json.keySignature, -1 * xpose);
                    buf.json.keySignature = concertKey;
                    const measure = measure_1.SmoMeasure.deserialize(buf.json);
                    measure.measureNumber.staffId = buf.selector.staff;
                    score.replaceMeasure(buf.selector, measure);
                }
            }
            else if (buf.type === UndoBuffer.bufferTypes.SCORE) {
                // Score expects string, as deserialized score is how saving is done.
                score = score_1.SmoScore.deserialize(JSON.stringify(buf.json));
            }
            else if (buf.type === UndoBuffer.bufferTypes.SCORE_MODIFIER) {
                // Currently only one type like this: SmoTextGroup
                if (buf.json && buf.json.ctor === 'SmoTextGroup') {
                    const obj = scoreText_1.SmoTextGroup.deserializePreserveId(buf.json);
                    obj.attrs.id = buf.json.attrs.id;
                    // undo of add is remove, undo of remove is add.  Undo of update is remove and add older version
                    if (buf.subtype === UndoBuffer.bufferSubtypes.UPDATE || buf.subtype === UndoBuffer.bufferSubtypes.ADD) {
                        score.removeTextGroup(obj);
                    }
                    if (buf.subtype === UndoBuffer.bufferSubtypes.UPDATE || buf.subtype === UndoBuffer.bufferSubtypes.REMOVE) {
                        score.addTextGroup(obj);
                    }
                }
            }
            else {
                if (typeof (staffMap[buf.selector.staff]) === 'number') {
                    buf.selector.staff = staffMap[buf.selector.staff];
                    const staff = systemStaff_1.SmoSystemStaff.deserialize(buf.json);
                    score.replaceStaff(buf.selector.staff, staff);
                }
            }
            const peekBuf = this.peekIndex(peekIndex + 1);
            // If buf is grouped and not the first in the group, also undo the next buffer
            if (grouping && peekBuf !== null && peekBuf.grouped && buf.firstInGroup === false) {
                // For the backup/full score, we actually pop the buffer.  For the visible score, we 
                // just use copies of the buffer.
                if (pop) {
                    buf = this._pop();
                }
                else {
                    peekIndex += 1;
                    buf = this.peekIndex(peekIndex);
                    if (buf) {
                        buf = copyUndo(buf);
                    }
                }
            }
            else {
                buf = null;
            }
        }
        return score;
    }
}
exports.UndoBuffer = UndoBuffer;
UndoBuffer.groupCount = 0;
// ## SmoUndoable
// Convenience functions to save the score state before operations so we can undo the operation.
// Each undo-able knows which set of parameters the undo operation requires (measure, staff, score).
class SmoUndoable {
    // ### undoScoreObject
    // Called when a score object is being modified.  There is no need to update the score as it contains a
    // reference to the object
    static changeTextGroup(score, undoBuffer, object, subtype) {
        undoBuffer.addBuffer('modify text', UndoBuffer.bufferTypes.SCORE_MODIFIER, selections_1.SmoSelector.default, object, subtype);
        if (subtype === UndoBuffer.bufferSubtypes.REMOVE) {
            operations_1.SmoOperation.removeTextGroup(score, object);
        }
        else if (subtype === UndoBuffer.bufferSubtypes.ADD) {
            operations_1.SmoOperation.addTextGroup(score, object);
        }
        // Update operation, there is nothing to do since the text is already
        // part of the score
    }
}
exports.SmoUndoable = SmoUndoable;


/***/ }),

/***/ "./src/styles/font_metrics/Commissioner-Medium-Metrics.js":
/*!****************************************************************!*\
  !*** ./src/styles/font_metrics/Commissioner-Medium-Metrics.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Commissioner_MediumFont = void 0;
exports.Commissioner_MediumFont = {
    smufl: false,
    name: "CommissionerMedium",
    spacing: 50,
    fontFamily: "Commisioner",
    description: "Commisioner, a sans-serif font similar to Arial",
    serifs: true,
    monospaced: false,
    superscriptOffset: 0.66,
    subscriptOffset: 0.66,
    maxSizeGlyph: 'H',
    "glyphs": {
        "0": {
            "x_min": 102,
            "x_max": 1212,
            "y_min": -23,
            "y_max": 1400,
            "ha": 1423,
            "leftSideBearing": 102,
            "advanceWidth": 1314
        },
        "1": {
            "x_min": 56,
            "x_max": 676,
            "y_min": 0,
            "y_max": 1380,
            "ha": 1380,
            "leftSideBearing": 56,
            "advanceWidth": 874
        },
        "2": {
            "x_min": 86,
            "x_max": 1020,
            "y_min": 0,
            "y_max": 1400,
            "ha": 1400,
            "leftSideBearing": 86,
            "advanceWidth": 1120
        },
        "3": {
            "x_min": 84,
            "x_max": 1056,
            "y_min": -23,
            "y_max": 1401,
            "ha": 1424,
            "leftSideBearing": 84,
            "advanceWidth": 1150
        },
        "4": {
            "x_min": 56,
            "x_max": 1157,
            "y_min": 0,
            "y_max": 1373,
            "ha": 1373,
            "leftSideBearing": 56,
            "advanceWidth": 1209
        },
        "5": {
            "x_min": 84,
            "x_max": 1061,
            "y_min": -23,
            "y_max": 1373,
            "ha": 1396,
            "leftSideBearing": 84,
            "advanceWidth": 1155
        },
        "6": {
            "x_min": 102,
            "x_max": 1127,
            "y_min": -23,
            "y_max": 1400,
            "ha": 1423,
            "leftSideBearing": 102,
            "advanceWidth": 1221
        },
        "7": {
            "x_min": 50,
            "x_max": 998,
            "y_min": 0,
            "y_max": 1373,
            "ha": 1373,
            "leftSideBearing": 50,
            "advanceWidth": 1072
        },
        "8": {
            "x_min": 94,
            "x_max": 1128,
            "y_min": -23,
            "y_max": 1401,
            "ha": 1424,
            "leftSideBearing": 94,
            "advanceWidth": 1222
        },
        "9": {
            "x_min": 94,
            "x_max": 1119,
            "y_min": -23,
            "y_max": 1400,
            "ha": 1423,
            "leftSideBearing": 94,
            "advanceWidth": 1221
        },
        " ": {
            "x_min": 0,
            "x_max": 0,
            "y_min": 0,
            "y_max": 0,
            "ha": 0,
            "leftSideBearing": 0,
            "advanceWidth": 382
        },
        "!": {
            "x_min": 94,
            "x_max": 398,
            "y_min": -24,
            "y_max": 1472,
            "ha": 1496,
            "leftSideBearing": 94,
            "advanceWidth": 493
        },
        "\"": {
            "x_min": 78,
            "x_max": 674,
            "y_min": 846,
            "y_max": 1489,
            "ha": 643,
            "leftSideBearing": 78,
            "advanceWidth": 790
        },
        "#": {
            "x_min": 32,
            "x_max": 1344,
            "y_min": 0,
            "y_max": 1322,
            "ha": 1322,
            "leftSideBearing": 32,
            "advanceWidth": 1376
        },
        "$": {
            "x_min": 99,
            "x_max": 1060,
            "y_min": -274,
            "y_max": 1606,
            "ha": 1880,
            "leftSideBearing": 99,
            "advanceWidth": 1133
        },
        "%": {
            "x_min": 64,
            "x_max": 1732,
            "y_min": -24,
            "y_max": 1453,
            "ha": 1477,
            "leftSideBearing": 64,
            "advanceWidth": 1804
        },
        "&": {
            "x_min": 89,
            "x_max": 1465,
            "y_min": -21,
            "y_max": 1453,
            "ha": 1474,
            "leftSideBearing": 89,
            "advanceWidth": 1490
        },
        "'": {
            "x_min": 78,
            "x_max": 305,
            "y_min": 846,
            "y_max": 1489,
            "ha": 643,
            "leftSideBearing": 78,
            "advanceWidth": 421
        },
        "(": {
            "x_min": 108,
            "x_max": 718,
            "y_min": -250,
            "y_max": 1545,
            "ha": 1795,
            "leftSideBearing": 108,
            "advanceWidth": 790
        },
        ")": {
            "x_min": 72,
            "x_max": 682,
            "y_min": -250,
            "y_max": 1545,
            "ha": 1795,
            "leftSideBearing": 72,
            "advanceWidth": 790
        },
        "*": {
            "x_min": 52,
            "x_max": 908,
            "y_min": 578,
            "y_max": 1492,
            "ha": 914,
            "leftSideBearing": 52,
            "advanceWidth": 960
        },
        "+": {
            "x_min": 116,
            "x_max": 1068,
            "y_min": 113,
            "y_max": 1089,
            "ha": 976,
            "leftSideBearing": 116,
            "advanceWidth": 1184
        },
        ",": {
            "x_min": 49,
            "x_max": 379,
            "y_min": -314,
            "y_max": 279,
            "ha": 593,
            "leftSideBearing": 49,
            "advanceWidth": 474
        },
        "-": {
            "x_min": 116,
            "x_max": 732,
            "y_min": 503,
            "y_max": 691,
            "ha": 188,
            "leftSideBearing": 116,
            "advanceWidth": 848
        },
        ".": {
            "x_min": 94,
            "x_max": 398,
            "y_min": -24,
            "y_max": 272,
            "ha": 296,
            "leftSideBearing": 94,
            "advanceWidth": 493
        },
        "/": {
            "x_min": 49,
            "x_max": 848,
            "y_min": 0,
            "y_max": 1426,
            "ha": 1426,
            "leftSideBearing": 49,
            "advanceWidth": 897
        },
        ":": {
            "x_min": 94,
            "x_max": 398,
            "y_min": -24,
            "y_max": 1019,
            "ha": 1043,
            "leftSideBearing": 94,
            "advanceWidth": 493
        },
        ";": {
            "x_min": 67,
            "x_max": 398,
            "y_min": -314,
            "y_max": 1019,
            "ha": 1333,
            "leftSideBearing": 67,
            "advanceWidth": 493
        },
        "<": {
            "x_min": 116,
            "x_max": 1028,
            "y_min": 132,
            "y_max": 1068,
            "ha": 936,
            "leftSideBearing": 116,
            "advanceWidth": 1144
        },
        "=": {
            "x_min": 124,
            "x_max": 1020,
            "y_min": 277,
            "y_max": 925,
            "ha": 648,
            "leftSideBearing": 124,
            "advanceWidth": 1144
        },
        ">": {
            "x_min": 116,
            "x_max": 1028,
            "y_min": 132,
            "y_max": 1068,
            "ha": 936,
            "leftSideBearing": 116,
            "advanceWidth": 1144
        },
        "?": {
            "x_min": 76,
            "x_max": 782,
            "y_min": -24,
            "y_max": 1498,
            "ha": 1522,
            "leftSideBearing": 76,
            "advanceWidth": 872
        },
        "@": {
            "x_min": 91.72000000000001,
            "x_max": 1680.1678341637535,
            "y_min": -272,
            "y_max": 1366,
            "ha": 1638,
            "leftSideBearing": 91,
            "advanceWidth": 1772
        },
        "A": {
            "x_min": 53,
            "x_max": 1350,
            "y_min": 0,
            "y_max": 1426,
            "ha": 1426,
            "leftSideBearing": 53,
            "advanceWidth": 1401
        },
        "B": {
            "x_min": 168,
            "x_max": 1227,
            "y_min": 0,
            "y_max": 1426,
            "ha": 1426,
            "leftSideBearing": 168,
            "advanceWidth": 1303
        },
        "C": {
            "x_min": 91,
            "x_max": 1272,
            "y_min": -24,
            "y_max": 1453,
            "ha": 1477,
            "leftSideBearing": 91,
            "advanceWidth": 1369
        },
        "D": {
            "x_min": 169,
            "x_max": 1380,
            "y_min": 0,
            "y_max": 1426,
            "ha": 1426,
            "leftSideBearing": 169,
            "advanceWidth": 1471
        },
        "E": {
            "x_min": 168,
            "x_max": 1081,
            "y_min": 0,
            "y_max": 1426,
            "ha": 1426,
            "leftSideBearing": 168,
            "advanceWidth": 1189
        },
        "F": {
            "x_min": 169,
            "x_max": 1061,
            "y_min": 0,
            "y_max": 1426,
            "ha": 1426,
            "leftSideBearing": 169,
            "advanceWidth": 1150
        },
        "G": {
            "x_min": 91,
            "x_max": 1333,
            "y_min": -23,
            "y_max": 1453,
            "ha": 1476,
            "leftSideBearing": 91,
            "advanceWidth": 1463
        },
        "H": {
            "x_min": 169,
            "x_max": 1331,
            "y_min": 0,
            "y_max": 1426,
            "ha": 1426,
            "leftSideBearing": 169,
            "advanceWidth": 1500
        },
        "I": {
            "x_min": 173,
            "x_max": 412,
            "y_min": 0,
            "y_max": 1426,
            "ha": 1426,
            "leftSideBearing": 173,
            "advanceWidth": 585
        },
        "J": {
            "x_min": 21,
            "x_max": 430,
            "y_min": -314,
            "y_max": 1426,
            "ha": 1740,
            "leftSideBearing": 21,
            "advanceWidth": 603
        },
        "K": {
            "x_min": 169,
            "x_max": 1310,
            "y_min": 0,
            "y_max": 1426,
            "ha": 1426,
            "leftSideBearing": 169,
            "advanceWidth": 1362
        },
        "L": {
            "x_min": 169,
            "x_max": 1086,
            "y_min": 0,
            "y_max": 1426,
            "ha": 1426,
            "leftSideBearing": 169,
            "advanceWidth": 1150
        },
        "M": {
            "x_min": 122,
            "x_max": 1798,
            "y_min": 0,
            "y_max": 1426,
            "ha": 1426,
            "leftSideBearing": 122,
            "advanceWidth": 1920
        },
        "N": {
            "x_min": 169,
            "x_max": 1336,
            "y_min": 0,
            "y_max": 1426,
            "ha": 1426,
            "leftSideBearing": 169,
            "advanceWidth": 1505
        },
        "O": {
            "x_min": 91,
            "x_max": 1540,
            "y_min": -24,
            "y_max": 1453,
            "ha": 1477,
            "leftSideBearing": 91,
            "advanceWidth": 1632
        },
        "P": {
            "x_min": 168,
            "x_max": 1194,
            "y_min": 0,
            "y_max": 1426,
            "ha": 1426,
            "leftSideBearing": 168,
            "advanceWidth": 1271
        },
        "Q": {
            "x_min": 91,
            "x_max": 1540,
            "y_min": -341,
            "y_max": 1453,
            "ha": 1794,
            "leftSideBearing": 91,
            "advanceWidth": 1632
        },
        "R": {
            "x_min": 168,
            "x_max": 1304,
            "y_min": 0,
            "y_max": 1426,
            "ha": 1426,
            "leftSideBearing": 168,
            "advanceWidth": 1356
        },
        "S": {
            "x_min": 99,
            "x_max": 1110,
            "y_min": -23,
            "y_max": 1453,
            "ha": 1476,
            "leftSideBearing": 99,
            "advanceWidth": 1183
        },
        "T": {
            "x_min": 58,
            "x_max": 1227,
            "y_min": 0,
            "y_max": 1426,
            "ha": 1426,
            "leftSideBearing": 58,
            "advanceWidth": 1285
        },
        "U": {
            "x_min": 152,
            "x_max": 1306,
            "y_min": -24,
            "y_max": 1426,
            "ha": 1450,
            "leftSideBearing": 152,
            "advanceWidth": 1459
        },
        "V": {
            "x_min": 51,
            "x_max": 1338,
            "y_min": 0,
            "y_max": 1426,
            "ha": 1426,
            "leftSideBearing": 51,
            "advanceWidth": 1390
        },
        "W": {
            "x_min": 50,
            "x_max": 2010,
            "y_min": 0,
            "y_max": 1426,
            "ha": 1426,
            "leftSideBearing": 50,
            "advanceWidth": 2060
        },
        "X": {
            "x_min": 64,
            "x_max": 1316,
            "y_min": 0,
            "y_max": 1426,
            "ha": 1426,
            "leftSideBearing": 64,
            "advanceWidth": 1380
        },
        "Y": {
            "x_min": 50,
            "x_max": 1278,
            "y_min": 0,
            "y_max": 1426,
            "ha": 1426,
            "leftSideBearing": 50,
            "advanceWidth": 1325
        },
        "Z": {
            "x_min": 90,
            "x_max": 1258,
            "y_min": 0,
            "y_max": 1426,
            "ha": 1426,
            "leftSideBearing": 90,
            "advanceWidth": 1354
        },
        "[": {
            "x_min": 177,
            "x_max": 733,
            "y_min": -238,
            "y_max": 1538,
            "ha": 1776,
            "leftSideBearing": 177,
            "advanceWidth": 770
        },
        "\\": {
            "x_min": 49,
            "x_max": 848,
            "y_min": 0,
            "y_max": 1426,
            "ha": 1426,
            "leftSideBearing": 49,
            "advanceWidth": 897
        },
        "]": {
            "x_min": 37,
            "x_max": 593,
            "y_min": -238,
            "y_max": 1538,
            "ha": 1776,
            "leftSideBearing": 37,
            "advanceWidth": 770
        },
        "^": {
            "x_min": 112,
            "x_max": 1122,
            "y_min": 744,
            "y_max": 1373,
            "ha": 629,
            "leftSideBearing": 112,
            "advanceWidth": 1234
        },
        "_": {
            "x_min": -20,
            "x_max": 844,
            "y_min": -272,
            "y_max": -96,
            "ha": 176,
            "leftSideBearing": -20,
            "advanceWidth": 824
        },
        "`": {
            "x_min": 272,
            "x_max": 765,
            "y_min": 1146,
            "y_max": 1556,
            "ha": 410,
            "leftSideBearing": 272,
            "advanceWidth": 1200
        },
        "a": {
            "x_min": 94,
            "x_max": 922,
            "y_min": -21,
            "y_max": 1018,
            "ha": 1039,
            "leftSideBearing": 94,
            "advanceWidth": 1053
        },
        "b": {
            "x_min": 154,
            "x_max": 1093,
            "y_min": -24,
            "y_max": 1487,
            "ha": 1511,
            "leftSideBearing": 154,
            "advanceWidth": 1184
        },
        "c": {
            "x_min": 89,
            "x_max": 900,
            "y_min": -20,
            "y_max": 1018,
            "ha": 1038,
            "leftSideBearing": 89,
            "advanceWidth": 982
        },
        "d": {
            "x_min": 90,
            "x_max": 1030,
            "y_min": -24,
            "y_max": 1487,
            "ha": 1511,
            "leftSideBearing": 90,
            "advanceWidth": 1161
        },
        "e": {
            "x_min": 89,
            "x_max": 972,
            "y_min": -23,
            "y_max": 1018,
            "ha": 1041,
            "leftSideBearing": 89,
            "advanceWidth": 1054
        },
        "f": {
            "x_min": 44,
            "x_max": 794,
            "y_min": 0,
            "y_max": 1492,
            "ha": 1492,
            "leftSideBearing": 44,
            "advanceWidth": 801
        },
        "g": {
            "x_min": 85,
            "x_max": 1050,
            "y_min": -407,
            "y_max": 1018,
            "ha": 1425,
            "leftSideBearing": 85,
            "advanceWidth": 1089
        },
        "h": {
            "x_min": 154,
            "x_max": 1018,
            "y_min": 0,
            "y_max": 1487,
            "ha": 1487,
            "leftSideBearing": 154,
            "advanceWidth": 1150
        },
        "i": {
            "x_min": 119,
            "x_max": 408,
            "y_min": 0,
            "y_max": 1472,
            "ha": 1472,
            "leftSideBearing": 119,
            "advanceWidth": 530
        },
        "j": {
            "x_min": 0,
            "x_max": 409,
            "y_min": -391,
            "y_max": 1472,
            "ha": 1863,
            "leftSideBearing": 0,
            "advanceWidth": 526
        },
        "k": {
            "x_min": 154,
            "x_max": 1075,
            "y_min": 0,
            "y_max": 1487,
            "ha": 1487,
            "leftSideBearing": 154,
            "advanceWidth": 1108
        },
        "l": {
            "x_min": 154,
            "x_max": 368,
            "y_min": 0,
            "y_max": 1487,
            "ha": 1487,
            "leftSideBearing": 154,
            "advanceWidth": 522
        },
        "m": {
            "x_min": 154,
            "x_max": 1613,
            "y_min": 0,
            "y_max": 1019,
            "ha": 1019,
            "leftSideBearing": 154,
            "advanceWidth": 1745
        },
        "n": {
            "x_min": 154,
            "x_max": 1018,
            "y_min": 0,
            "y_max": 1019,
            "ha": 1019,
            "leftSideBearing": 154,
            "advanceWidth": 1150
        },
        "o": {
            "x_min": 89,
            "x_max": 1106,
            "y_min": -24,
            "y_max": 1019,
            "ha": 1043,
            "leftSideBearing": 89,
            "advanceWidth": 1195
        },
        "p": {
            "x_min": 154,
            "x_max": 1093,
            "y_min": -391,
            "y_max": 1019,
            "ha": 1410,
            "leftSideBearing": 154,
            "advanceWidth": 1184
        },
        "q": {
            "x_min": 90,
            "x_max": 1030,
            "y_min": -391,
            "y_max": 1019,
            "ha": 1410,
            "leftSideBearing": 90,
            "advanceWidth": 1172
        },
        "r": {
            "x_min": 154,
            "x_max": 766,
            "y_min": 0,
            "y_max": 1019,
            "ha": 1019,
            "leftSideBearing": 154,
            "advanceWidth": 808
        },
        "s": {
            "x_min": 104,
            "x_max": 839,
            "y_min": -23,
            "y_max": 1018,
            "ha": 1041,
            "leftSideBearing": 104,
            "advanceWidth": 918
        },
        "t": {
            "x_min": 44,
            "x_max": 774,
            "y_min": -24,
            "y_max": 1359,
            "ha": 1383,
            "leftSideBearing": 44,
            "advanceWidth": 829
        },
        "u": {
            "x_min": 132,
            "x_max": 990,
            "y_min": -24,
            "y_max": 1002,
            "ha": 1026,
            "leftSideBearing": 132,
            "advanceWidth": 1126
        },
        "v": {
            "x_min": 42,
            "x_max": 1006,
            "y_min": 0,
            "y_max": 1002,
            "ha": 1002,
            "leftSideBearing": 42,
            "advanceWidth": 1048
        },
        "w": {
            "x_min": 42,
            "x_max": 1581,
            "y_min": 0,
            "y_max": 1002,
            "ha": 1002,
            "leftSideBearing": 42,
            "advanceWidth": 1623
        },
        "x": {
            "x_min": 51,
            "x_max": 1043,
            "y_min": 0,
            "y_max": 1002,
            "ha": 1002,
            "leftSideBearing": 51,
            "advanceWidth": 1090
        },
        "y": {
            "x_min": 42,
            "x_max": 1016,
            "y_min": -391,
            "y_max": 1002,
            "ha": 1393,
            "leftSideBearing": 42,
            "advanceWidth": 1058
        },
        "z": {
            "x_min": 72,
            "x_max": 940,
            "y_min": 0,
            "y_max": 994,
            "ha": 994,
            "leftSideBearing": 72,
            "advanceWidth": 1007
        },
        "{": {
            "x_min": 28,
            "x_max": 802,
            "y_min": -238,
            "y_max": 1538,
            "ha": 1776,
            "leftSideBearing": 28,
            "advanceWidth": 838
        },
        "|": {
            "x_min": 177,
            "x_max": 365,
            "y_min": -316,
            "y_max": 1564,
            "ha": 1880,
            "leftSideBearing": 177,
            "advanceWidth": 542
        },
        "}": {
            "x_min": 36,
            "x_max": 810,
            "y_min": -238,
            "y_max": 1538,
            "ha": 1776,
            "leftSideBearing": 36,
            "advanceWidth": 838
        },
        "~": {
            "x_min": 116,
            "x_max": 1028,
            "y_min": 431,
            "y_max": 774,
            "ha": 343,
            "leftSideBearing": 116,
            "advanceWidth": 1144
        }
    },
    "resolution": 2000,
    "generatedOn": "2020-10-16T17:54:48.712Z"
};


/***/ }),

/***/ "./src/styles/font_metrics/ConcertOne-Regular.js":
/*!*******************************************************!*\
  !*** ./src/styles/font_metrics/ConcertOne-Regular.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Concert_OneFont = void 0;
exports.Concert_OneFont = {
    smufl: false,
    name: "ConcertOne",
    spacing: 50,
    fontFamily: "ConcertOne",
    description: "Concert One, a sans-serif rounded title font",
    serifs: true,
    monospaced: false,
    superscriptOffset: 0.66,
    subscriptOffset: 0.66,
    maxSizeGlyph: 'H',
    "glyphs": {
        "0": {
            "x_min": 102,
            "x_max": 1016,
            "y_min": -8,
            "y_max": 1408,
            "ha": 1416,
            "leftSideBearing": 102,
            "advanceWidth": 1118
        },
        "1": {
            "x_min": 58,
            "x_max": 664,
            "y_min": 0,
            "y_max": 1400,
            "ha": 1400,
            "leftSideBearing": 58,
            "advanceWidth": 786
        },
        "2": {
            "x_min": 100,
            "x_max": 1022,
            "y_min": 0,
            "y_max": 1408,
            "ha": 1408,
            "leftSideBearing": 100,
            "advanceWidth": 1060
        },
        "3": {
            "x_min": 54,
            "x_max": 946,
            "y_min": -8,
            "y_max": 1400,
            "ha": 1408,
            "leftSideBearing": 54,
            "advanceWidth": 1026
        },
        "4": {
            "x_min": 74,
            "x_max": 906,
            "y_min": 0,
            "y_max": 1400,
            "ha": 1400,
            "leftSideBearing": 74,
            "advanceWidth": 1002
        },
        "5": {
            "x_min": 76,
            "x_max": 968,
            "y_min": -8,
            "y_max": 1400,
            "ha": 1408,
            "leftSideBearing": 76,
            "advanceWidth": 1026
        },
        "6": {
            "x_min": 122,
            "x_max": 948,
            "y_min": -8,
            "y_max": 1400,
            "ha": 1408,
            "leftSideBearing": 122,
            "advanceWidth": 992
        },
        "7": {
            "x_min": 48,
            "x_max": 966,
            "y_min": 0,
            "y_max": 1400,
            "ha": 1400,
            "leftSideBearing": 48,
            "advanceWidth": 1012
        },
        "8": {
            "x_min": 90,
            "x_max": 930,
            "y_min": -8,
            "y_max": 1408,
            "ha": 1416,
            "leftSideBearing": 90,
            "advanceWidth": 1020
        },
        "9": {
            "x_min": 46,
            "x_max": 870,
            "y_min": 0,
            "y_max": 1408,
            "ha": 1408,
            "leftSideBearing": 46,
            "advanceWidth": 992
        },
        " ": {
            "x_min": 0,
            "x_max": 0,
            "y_min": 0,
            "y_max": 0,
            "ha": 0,
            "leftSideBearing": 0,
            "advanceWidth": 798
        },
        "!": {
            "x_min": 226,
            "x_max": 556,
            "y_min": -2,
            "y_max": 1398,
            "ha": 1400,
            "leftSideBearing": 226,
            "advanceWidth": 808
        },
        "\"": {
            "x_min": 110,
            "x_max": 766,
            "y_min": 904,
            "y_max": 1404,
            "ha": 500,
            "leftSideBearing": 110,
            "advanceWidth": 898
        },
        "#": {
            "x_min": 118,
            "x_max": 1170,
            "y_min": 160,
            "y_max": 1222,
            "ha": 1062,
            "leftSideBearing": 118,
            "advanceWidth": 1268
        },
        "$": {
            "x_min": 142,
            "x_max": 904,
            "y_min": 6,
            "y_max": 1384,
            "ha": 1378,
            "leftSideBearing": 142,
            "advanceWidth": 1052
        },
        "%": {
            "x_min": 98,
            "x_max": 1384,
            "y_min": -6,
            "y_max": 1400,
            "ha": 1406,
            "leftSideBearing": 98,
            "advanceWidth": 1484
        },
        "&": {
            "x_min": 104,
            "x_max": 1178,
            "y_min": -2,
            "y_max": 1408,
            "ha": 1410,
            "leftSideBearing": 104,
            "advanceWidth": 1296
        },
        "'": {
            "x_min": 130,
            "x_max": 374,
            "y_min": 904,
            "y_max": 1404,
            "ha": 500,
            "leftSideBearing": 130,
            "advanceWidth": 522
        },
        "(": {
            "x_min": 240,
            "x_max": 814,
            "y_min": -158,
            "y_max": 1562,
            "ha": 1720,
            "leftSideBearing": 240,
            "advanceWidth": 888
        },
        ")": {
            "x_min": 74,
            "x_max": 648,
            "y_min": -158,
            "y_max": 1562,
            "ha": 1720,
            "leftSideBearing": 74,
            "advanceWidth": 888
        },
        "*": {
            "x_min": 110,
            "x_max": 1084,
            "y_min": 164,
            "y_max": 1260,
            "ha": 1096,
            "leftSideBearing": 110,
            "advanceWidth": 1194
        },
        "+": {
            "x_min": 190,
            "x_max": 920,
            "y_min": 356,
            "y_max": 1086,
            "ha": 730,
            "leftSideBearing": 190,
            "advanceWidth": 1102
        },
        ",": {
            "x_min": 134,
            "x_max": 464,
            "y_min": -164,
            "y_max": 330,
            "ha": 494,
            "leftSideBearing": 134,
            "advanceWidth": 598
        },
        "-": {
            "x_min": 108,
            "x_max": 838,
            "y_min": 480,
            "y_max": 724,
            "ha": 244,
            "leftSideBearing": 108,
            "advanceWidth": 966
        },
        ".": {
            "x_min": 134,
            "x_max": 464,
            "y_min": 0,
            "y_max": 330,
            "ha": 330,
            "leftSideBearing": 134,
            "advanceWidth": 598
        },
        "/": {
            "x_min": 70,
            "x_max": 826,
            "y_min": -26,
            "y_max": 1408,
            "ha": 1434,
            "leftSideBearing": 70,
            "advanceWidth": 906
        },
        ":": {
            "x_min": 122,
            "x_max": 454,
            "y_min": 0,
            "y_max": 854,
            "ha": 854,
            "leftSideBearing": 122,
            "advanceWidth": 572
        },
        ";": {
            "x_min": 120,
            "x_max": 452,
            "y_min": -166,
            "y_max": 852,
            "ha": 1018,
            "leftSideBearing": 120,
            "advanceWidth": 596
        },
        "<": {
            "x_min": 162,
            "x_max": 768,
            "y_min": 126,
            "y_max": 1074,
            "ha": 948,
            "leftSideBearing": 162,
            "advanceWidth": 930
        },
        "=": {
            "x_min": 180,
            "x_max": 914,
            "y_min": 290,
            "y_max": 926,
            "ha": 636,
            "leftSideBearing": 180,
            "advanceWidth": 1102
        },
        ">": {
            "x_min": 162,
            "x_max": 768,
            "y_min": 126,
            "y_max": 1074,
            "ha": 948,
            "leftSideBearing": 162,
            "advanceWidth": 930
        },
        "?": {
            "x_min": 104,
            "x_max": 1012,
            "y_min": 0,
            "y_max": 1420,
            "ha": 1420,
            "leftSideBearing": 104,
            "advanceWidth": 1122
        },
        "@": {
            "x_min": 132,
            "x_max": 1306,
            "y_min": -96,
            "y_max": 1078,
            "ha": 1174,
            "leftSideBearing": 132,
            "advanceWidth": 1494
        },
        "A": {
            "x_min": 74,
            "x_max": 1030,
            "y_min": 0,
            "y_max": 1400,
            "ha": 1400,
            "leftSideBearing": 74,
            "advanceWidth": 1104
        },
        "B": {
            "x_min": 120,
            "x_max": 1042,
            "y_min": 0,
            "y_max": 1400,
            "ha": 1400,
            "leftSideBearing": 120,
            "advanceWidth": 1104
        },
        "C": {
            "x_min": 90,
            "x_max": 1046,
            "y_min": -6,
            "y_max": 1408,
            "ha": 1414,
            "leftSideBearing": 90,
            "advanceWidth": 1110
        },
        "D": {
            "x_min": 134,
            "x_max": 1008,
            "y_min": 0,
            "y_max": 1400,
            "ha": 1400,
            "leftSideBearing": 134,
            "advanceWidth": 1094
        },
        "E": {
            "x_min": 140,
            "x_max": 912,
            "y_min": 0,
            "y_max": 1400,
            "ha": 1400,
            "leftSideBearing": 140,
            "advanceWidth": 986
        },
        "F": {
            "x_min": 140,
            "x_max": 912,
            "y_min": 0,
            "y_max": 1400,
            "ha": 1400,
            "leftSideBearing": 140,
            "advanceWidth": 938
        },
        "G": {
            "x_min": 106,
            "x_max": 1072,
            "y_min": -8,
            "y_max": 1408,
            "ha": 1416,
            "leftSideBearing": 106,
            "advanceWidth": 1156
        },
        "H": {
            "x_min": 146,
            "x_max": 1028,
            "y_min": 0,
            "y_max": 1400,
            "ha": 1400,
            "leftSideBearing": 146,
            "advanceWidth": 1166
        },
        "I": {
            "x_min": 168,
            "x_max": 500,
            "y_min": 0,
            "y_max": 1400,
            "ha": 1400,
            "leftSideBearing": 168,
            "advanceWidth": 666
        },
        "J": {
            "x_min": 46,
            "x_max": 980,
            "y_min": -8,
            "y_max": 1400,
            "ha": 1408,
            "leftSideBearing": 46,
            "advanceWidth": 1126
        },
        "K": {
            "x_min": 140,
            "x_max": 1064,
            "y_min": -8,
            "y_max": 1400,
            "ha": 1408,
            "leftSideBearing": 140,
            "advanceWidth": 1142
        },
        "L": {
            "x_min": 178,
            "x_max": 906,
            "y_min": 0,
            "y_max": 1400,
            "ha": 1400,
            "leftSideBearing": 178,
            "advanceWidth": 968
        },
        "M": {
            "x_min": 156,
            "x_max": 1430,
            "y_min": 0,
            "y_max": 1400,
            "ha": 1400,
            "leftSideBearing": 156,
            "advanceWidth": 1594
        },
        "N": {
            "x_min": 148,
            "x_max": 1222,
            "y_min": 0,
            "y_max": 1400,
            "ha": 1400,
            "leftSideBearing": 148,
            "advanceWidth": 1360
        },
        "O": {
            "x_min": 104,
            "x_max": 1026,
            "y_min": -8,
            "y_max": 1408,
            "ha": 1416,
            "leftSideBearing": 104,
            "advanceWidth": 1128
        },
        "P": {
            "x_min": 142,
            "x_max": 1066,
            "y_min": 0,
            "y_max": 1400,
            "ha": 1400,
            "leftSideBearing": 142,
            "advanceWidth": 1082
        },
        "Q": {
            "x_min": 122,
            "x_max": 1114,
            "y_min": -110,
            "y_max": 1408,
            "ha": 1518,
            "leftSideBearing": 122,
            "advanceWidth": 1156
        },
        "R": {
            "x_min": 142,
            "x_max": 1062,
            "y_min": -8,
            "y_max": 1400,
            "ha": 1408,
            "leftSideBearing": 142,
            "advanceWidth": 1142
        },
        "S": {
            "x_min": 88,
            "x_max": 950,
            "y_min": -8,
            "y_max": 1408,
            "ha": 1416,
            "leftSideBearing": 88,
            "advanceWidth": 1014
        },
        "T": {
            "x_min": 10,
            "x_max": 974,
            "y_min": 0,
            "y_max": 1400,
            "ha": 1400,
            "leftSideBearing": 10,
            "advanceWidth": 982
        },
        "U": {
            "x_min": 142,
            "x_max": 1070,
            "y_min": -8,
            "y_max": 1400,
            "ha": 1408,
            "leftSideBearing": 142,
            "advanceWidth": 1208
        },
        "V": {
            "x_min": 16,
            "x_max": 992,
            "y_min": 0,
            "y_max": 1400,
            "ha": 1400,
            "leftSideBearing": 16,
            "advanceWidth": 1000
        },
        "W": {
            "x_min": 24,
            "x_max": 1658,
            "y_min": 0,
            "y_max": 1400,
            "ha": 1400,
            "leftSideBearing": 24,
            "advanceWidth": 1666
        },
        "X": {
            "x_min": 56,
            "x_max": 1094,
            "y_min": 0,
            "y_max": 1400,
            "ha": 1400,
            "leftSideBearing": 56,
            "advanceWidth": 1146
        },
        "Y": {
            "x_min": -14,
            "x_max": 1022,
            "y_min": 0,
            "y_max": 1400,
            "ha": 1400,
            "leftSideBearing": -14,
            "advanceWidth": 1000
        },
        "Z": {
            "x_min": 70,
            "x_max": 982,
            "y_min": 0,
            "y_max": 1400,
            "ha": 1400,
            "leftSideBearing": 70,
            "advanceWidth": 1042
        },
        "[": {
            "x_min": 240,
            "x_max": 736,
            "y_min": 2,
            "y_max": 1404,
            "ha": 1402,
            "leftSideBearing": 240,
            "advanceWidth": 836
        },
        "\\": {
            "x_min": 70,
            "x_max": 826,
            "y_min": -26,
            "y_max": 1408,
            "ha": 1434,
            "leftSideBearing": 70,
            "advanceWidth": 906
        },
        "]": {
            "x_min": 140,
            "x_max": 636,
            "y_min": 2,
            "y_max": 1404,
            "ha": 1402,
            "leftSideBearing": 140,
            "advanceWidth": 836
        },
        "^": {
            "x_min": 174,
            "x_max": 782,
            "y_min": 762,
            "y_max": 1156,
            "ha": 394,
            "leftSideBearing": 174,
            "advanceWidth": 976
        },
        "_": {
            "x_min": 146,
            "x_max": 1254,
            "y_min": 2,
            "y_max": 246,
            "ha": 244,
            "leftSideBearing": 146,
            "advanceWidth": 1408
        },
        "`": {
            "x_min": 132,
            "x_max": 578,
            "y_min": 1102,
            "y_max": 1452,
            "ha": 350,
            "leftSideBearing": 132,
            "advanceWidth": 698
        },
        "a": {
            "x_min": 84,
            "x_max": 912,
            "y_min": 0,
            "y_max": 1000,
            "ha": 1000,
            "leftSideBearing": 84,
            "advanceWidth": 1020
        },
        "b": {
            "x_min": 120,
            "x_max": 948,
            "y_min": 0,
            "y_max": 1400,
            "ha": 1400,
            "leftSideBearing": 120,
            "advanceWidth": 1042
        },
        "c": {
            "x_min": 84,
            "x_max": 930,
            "y_min": 0,
            "y_max": 1000,
            "ha": 1000,
            "leftSideBearing": 84,
            "advanceWidth": 1000
        },
        "d": {
            "x_min": 82,
            "x_max": 910,
            "y_min": 0,
            "y_max": 1400,
            "ha": 1400,
            "leftSideBearing": 82,
            "advanceWidth": 1020
        },
        "e": {
            "x_min": 92,
            "x_max": 936,
            "y_min": 0,
            "y_max": 1002,
            "ha": 1002,
            "leftSideBearing": 92,
            "advanceWidth": 1020
        },
        "f": {
            "x_min": 0,
            "x_max": 724,
            "y_min": 0,
            "y_max": 1400,
            "ha": 1400,
            "leftSideBearing": 0,
            "advanceWidth": 750
        },
        "g": {
            "x_min": 92,
            "x_max": 922,
            "y_min": -400,
            "y_max": 1000,
            "ha": 1400,
            "leftSideBearing": 92,
            "advanceWidth": 1042
        },
        "h": {
            "x_min": 122,
            "x_max": 956,
            "y_min": 0,
            "y_max": 1400,
            "ha": 1400,
            "leftSideBearing": 122,
            "advanceWidth": 1042
        },
        "i": {
            "x_min": 154,
            "x_max": 460,
            "y_min": 0,
            "y_max": 1400,
            "ha": 1400,
            "leftSideBearing": 154,
            "advanceWidth": 626
        },
        "j": {
            "x_min": -44,
            "x_max": 480,
            "y_min": -400,
            "y_max": 1402,
            "ha": 1802,
            "leftSideBearing": -44,
            "advanceWidth": 626
        },
        "k": {
            "x_min": 150,
            "x_max": 920,
            "y_min": -2,
            "y_max": 1400,
            "ha": 1402,
            "leftSideBearing": 150,
            "advanceWidth": 1014
        },
        "l": {
            "x_min": 140,
            "x_max": 444,
            "y_min": 0,
            "y_max": 1400,
            "ha": 1400,
            "leftSideBearing": 140,
            "advanceWidth": 586
        },
        "m": {
            "x_min": 134,
            "x_max": 1486,
            "y_min": 0,
            "y_max": 1000,
            "ha": 1000,
            "leftSideBearing": 134,
            "advanceWidth": 1604
        },
        "n": {
            "x_min": 132,
            "x_max": 966,
            "y_min": 0,
            "y_max": 1000,
            "ha": 1000,
            "leftSideBearing": 132,
            "advanceWidth": 1082
        },
        "o": {
            "x_min": 78,
            "x_max": 912,
            "y_min": -8,
            "y_max": 1008,
            "ha": 1016,
            "leftSideBearing": 78,
            "advanceWidth": 990
        },
        "p": {
            "x_min": 132,
            "x_max": 960,
            "y_min": -400,
            "y_max": 1000,
            "ha": 1400,
            "leftSideBearing": 132,
            "advanceWidth": 1062
        },
        "q": {
            "x_min": 104,
            "x_max": 932,
            "y_min": -400,
            "y_max": 1000,
            "ha": 1400,
            "leftSideBearing": 104,
            "advanceWidth": 1062
        },
        "r": {
            "x_min": 132,
            "x_max": 770,
            "y_min": 0,
            "y_max": 998,
            "ha": 998,
            "leftSideBearing": 132,
            "advanceWidth": 792
        },
        "s": {
            "x_min": 86,
            "x_max": 836,
            "y_min": -8,
            "y_max": 1008,
            "ha": 1016,
            "leftSideBearing": 86,
            "advanceWidth": 910
        },
        "t": {
            "x_min": 60,
            "x_max": 786,
            "y_min": 0,
            "y_max": 1400,
            "ha": 1400,
            "leftSideBearing": 60,
            "advanceWidth": 870
        },
        "u": {
            "x_min": 118,
            "x_max": 952,
            "y_min": 0,
            "y_max": 1000,
            "ha": 1000,
            "leftSideBearing": 118,
            "advanceWidth": 1076
        },
        "v": {
            "x_min": 36,
            "x_max": 844,
            "y_min": 0,
            "y_max": 1000,
            "ha": 1000,
            "leftSideBearing": 36,
            "advanceWidth": 876
        },
        "w": {
            "x_min": 24,
            "x_max": 1372,
            "y_min": 0,
            "y_max": 1000,
            "ha": 1000,
            "leftSideBearing": 24,
            "advanceWidth": 1396
        },
        "x": {
            "x_min": 84,
            "x_max": 860,
            "y_min": 0,
            "y_max": 1000,
            "ha": 1000,
            "leftSideBearing": 84,
            "advanceWidth": 938
        },
        "y": {
            "x_min": 20,
            "x_max": 892,
            "y_min": -400,
            "y_max": 1004,
            "ha": 1404,
            "leftSideBearing": 20,
            "advanceWidth": 916
        },
        "z": {
            "x_min": 72,
            "x_max": 844,
            "y_min": 0,
            "y_max": 1000,
            "ha": 1000,
            "leftSideBearing": 72,
            "advanceWidth": 916
        },
        "{": {
            "x_min": 188,
            "x_max": 932,
            "y_min": -160,
            "y_max": 1566,
            "ha": 1726,
            "leftSideBearing": 188,
            "advanceWidth": 1012
        },
        "|": {
            "x_min": 180,
            "x_max": 424,
            "y_min": -160,
            "y_max": 1566,
            "ha": 1726,
            "leftSideBearing": 180,
            "advanceWidth": 604
        },
        "}": {
            "x_min": 80,
            "x_max": 824,
            "y_min": -160,
            "y_max": 1566,
            "ha": 1726,
            "leftSideBearing": 80,
            "advanceWidth": 1012
        },
        "~": {
            "x_min": 112,
            "x_max": 802,
            "y_min": 84,
            "y_max": 398,
            "ha": 314,
            "leftSideBearing": 112,
            "advanceWidth": 918
        }
    },
    "resolution": 2048,
    "generatedOn": "2020-10-16T18:00:03.708Z"
};


/***/ }),

/***/ "./src/styles/font_metrics/Merriweather-Regular.js":
/*!*********************************************************!*\
  !*** ./src/styles/font_metrics/Merriweather-Regular.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MerriweatherFont = void 0;
exports.MerriweatherFont = {
    name: "Merriweather-Regular",
    smufl: false,
    spacing: 50,
    fontFamily: "Merriweather",
    description: "Merriweather, a serif web font by Sorkin Type",
    serifs: true,
    monospaced: false,
    superscriptOffset: 0.66,
    subscriptOffset: 0.66,
    maxSizeGlyph: 'H',
    "glyphs": {
        "0": {
            "x_min": 62,
            "x_max": 582,
            "y_min": -9,
            "y_max": 631,
            "ha": 640,
            "leftSideBearing": 62,
            "advanceWidth": 643
        },
        "1": {
            "x_min": 39,
            "x_max": 419,
            "y_min": 0,
            "y_max": 632,
            "ha": 632,
            "leftSideBearing": 39,
            "advanceWidth": 440
        },
        "2": {
            "x_min": 47,
            "x_max": 565,
            "y_min": 0,
            "y_max": 632,
            "ha": 632,
            "leftSideBearing": 47,
            "advanceWidth": 598
        },
        "3": {
            "x_min": 57,
            "x_max": 512,
            "y_min": -161,
            "y_max": 632,
            "ha": 793,
            "leftSideBearing": 57,
            "advanceWidth": 560
        },
        "4": {
            "x_min": 37,
            "x_max": 625,
            "y_min": -161,
            "y_max": 680,
            "ha": 841,
            "leftSideBearing": 37,
            "advanceWidth": 644
        },
        "5": {
            "x_min": 91,
            "x_max": 527,
            "y_min": -161,
            "y_max": 643,
            "ha": 804,
            "leftSideBearing": 91,
            "advanceWidth": 594
        },
        "6": {
            "x_min": 76,
            "x_max": 592,
            "y_min": -11,
            "y_max": 786,
            "ha": 797,
            "leftSideBearing": 76,
            "advanceWidth": 664
        },
        "7": {
            "x_min": 48,
            "x_max": 546,
            "y_min": -173,
            "y_max": 624,
            "ha": 797,
            "leftSideBearing": 48,
            "advanceWidth": 588
        },
        "8": {
            "x_min": 65,
            "x_max": 572,
            "y_min": -10,
            "y_max": 752,
            "ha": 762,
            "leftSideBearing": 65,
            "advanceWidth": 633
        },
        "9": {
            "x_min": 70,
            "x_max": 588,
            "y_min": -167,
            "y_max": 632,
            "ha": 799,
            "leftSideBearing": 70,
            "advanceWidth": 660
        },
        " ": {
            "x_min": 0,
            "x_max": 0,
            "y_min": 0,
            "y_max": 0,
            "ha": 0,
            "leftSideBearing": 0,
            "advanceWidth": 237
        },
        "!": {
            "x_min": 107,
            "x_max": 248,
            "y_min": -10,
            "y_max": 883,
            "ha": 893,
            "leftSideBearing": 107,
            "advanceWidth": 354
        },
        "\"": {
            "x_min": 124,
            "x_max": 489,
            "y_min": 456,
            "y_max": 827,
            "ha": 371,
            "leftSideBearing": 124,
            "advanceWidth": 612
        },
        "#": {
            "x_min": 81,
            "x_max": 677,
            "y_min": 0,
            "y_max": 743,
            "ha": 743,
            "leftSideBearing": 81,
            "advanceWidth": 744
        },
        "$": {
            "x_min": 94,
            "x_max": 575,
            "y_min": -126,
            "y_max": 860,
            "ha": 986,
            "leftSideBearing": 94,
            "advanceWidth": 659
        },
        "%": {
            "x_min": 53,
            "x_max": 981,
            "y_min": 0,
            "y_max": 751,
            "ha": 751,
            "leftSideBearing": 53,
            "advanceWidth": 1037
        },
        "&": {
            "x_min": 60,
            "x_max": 739,
            "y_min": -9,
            "y_max": 752,
            "ha": 761,
            "leftSideBearing": 60,
            "advanceWidth": 756
        },
        "'": {
            "x_min": 124,
            "x_max": 230,
            "y_min": 456,
            "y_max": 827,
            "ha": 371,
            "leftSideBearing": 124,
            "advanceWidth": 353
        },
        "(": {
            "x_min": 67,
            "x_max": 360,
            "y_min": -184,
            "y_max": 828,
            "ha": 1012,
            "leftSideBearing": 67,
            "advanceWidth": 430
        },
        ")": {
            "x_min": 70,
            "x_max": 363,
            "y_min": -183,
            "y_max": 829,
            "ha": 1012,
            "leftSideBearing": 70,
            "advanceWidth": 430
        },
        "*": {
            "x_min": 76,
            "x_max": 568,
            "y_min": 310,
            "y_max": 823,
            "ha": 513,
            "leftSideBearing": 76,
            "advanceWidth": 643
        },
        "+": {
            "x_min": 105,
            "x_max": 556,
            "y_min": 84,
            "y_max": 547,
            "ha": 463,
            "leftSideBearing": 105,
            "advanceWidth": 661
        },
        ",": {
            "x_min": 99,
            "x_max": 250,
            "y_min": -224,
            "y_max": 150,
            "ha": 374,
            "leftSideBearing": 99,
            "advanceWidth": 335
        },
        "-": {
            "x_min": 112,
            "x_max": 516,
            "y_min": 284,
            "y_max": 357,
            "ha": 73,
            "leftSideBearing": 112,
            "advanceWidth": 628
        },
        ".": {
            "x_min": 63,
            "x_max": 202,
            "y_min": -10,
            "y_max": 127,
            "ha": 137,
            "leftSideBearing": 63,
            "advanceWidth": 265
        },
        "/": {
            "x_min": 36,
            "x_max": 394,
            "y_min": -177,
            "y_max": 781,
            "ha": 958,
            "leftSideBearing": 36,
            "advanceWidth": 431
        },
        ":": {
            "x_min": 102,
            "x_max": 240,
            "y_min": -10,
            "y_max": 539,
            "ha": 549,
            "leftSideBearing": 102,
            "advanceWidth": 344
        },
        ";": {
            "x_min": 99,
            "x_max": 250,
            "y_min": -224,
            "y_max": 539,
            "ha": 763,
            "leftSideBearing": 99,
            "advanceWidth": 344
        },
        "<": {
            "x_min": 82,
            "x_max": 555,
            "y_min": 27,
            "y_max": 575,
            "ha": 548,
            "leftSideBearing": 82,
            "advanceWidth": 669
        },
        "=": {
            "x_min": 102,
            "x_max": 552,
            "y_min": 127,
            "y_max": 474,
            "ha": 347,
            "leftSideBearing": 102,
            "advanceWidth": 653
        },
        ">": {
            "x_min": 114,
            "x_max": 587,
            "y_min": 27,
            "y_max": 575,
            "ha": 548,
            "leftSideBearing": 114,
            "advanceWidth": 669
        },
        "?": {
            "x_min": 42,
            "x_max": 452,
            "y_min": -10,
            "y_max": 906,
            "ha": 916,
            "leftSideBearing": 42,
            "advanceWidth": 487
        },
        "@": {
            "x_min": 93,
            "x_max": 977,
            "y_min": -253,
            "y_max": 760,
            "ha": 1013,
            "leftSideBearing": 93,
            "advanceWidth": 1078
        },
        "A": {
            "x_min": -13,
            "x_max": 705,
            "y_min": 0,
            "y_max": 749,
            "ha": 749,
            "leftSideBearing": -13,
            "advanceWidth": 692
        },
        "B": {
            "x_min": 46,
            "x_max": 649,
            "y_min": -6,
            "y_max": 751,
            "ha": 757,
            "leftSideBearing": 46,
            "advanceWidth": 685
        },
        "C": {
            "x_min": 33,
            "x_max": 617,
            "y_min": -11,
            "y_max": 751,
            "ha": 762,
            "leftSideBearing": 33,
            "advanceWidth": 653
        },
        "D": {
            "x_min": 46,
            "x_max": 725,
            "y_min": -8,
            "y_max": 751,
            "ha": 759,
            "leftSideBearing": 46,
            "advanceWidth": 758
        },
        "E": {
            "x_min": 46,
            "x_max": 630,
            "y_min": 0,
            "y_max": 743,
            "ha": 743,
            "leftSideBearing": 46,
            "advanceWidth": 651
        },
        "F": {
            "x_min": 43,
            "x_max": 588,
            "y_min": 0,
            "y_max": 743,
            "ha": 743,
            "leftSideBearing": 43,
            "advanceWidth": 619
        },
        "G": {
            "x_min": 43,
            "x_max": 721,
            "y_min": -11,
            "y_max": 751,
            "ha": 762,
            "leftSideBearing": 43,
            "advanceWidth": 740
        },
        "H": {
            "x_min": 50,
            "x_max": 777,
            "y_min": 0,
            "y_max": 743,
            "ha": 743,
            "leftSideBearing": 50,
            "advanceWidth": 828
        },
        "I": {
            "x_min": 54,
            "x_max": 348,
            "y_min": 0,
            "y_max": 743,
            "ha": 743,
            "leftSideBearing": 54,
            "advanceWidth": 403
        },
        "J": {
            "x_min": -6,
            "x_max": 343,
            "y_min": -179,
            "y_max": 743,
            "ha": 922,
            "leftSideBearing": -6,
            "advanceWidth": 381
        },
        "K": {
            "x_min": 48,
            "x_max": 727,
            "y_min": 0,
            "y_max": 743,
            "ha": 743,
            "leftSideBearing": 48,
            "advanceWidth": 726
        },
        "L": {
            "x_min": 48,
            "x_max": 616,
            "y_min": 0,
            "y_max": 743,
            "ha": 743,
            "leftSideBearing": 48,
            "advanceWidth": 634
        },
        "M": {
            "x_min": 6,
            "x_max": 984,
            "y_min": 0,
            "y_max": 743,
            "ha": 743,
            "leftSideBearing": 6,
            "advanceWidth": 990
        },
        "N": {
            "x_min": 50,
            "x_max": 774,
            "y_min": 0,
            "y_max": 743,
            "ha": 743,
            "leftSideBearing": 50,
            "advanceWidth": 799
        },
        "O": {
            "x_min": 34,
            "x_max": 689,
            "y_min": -11,
            "y_max": 751,
            "ha": 762,
            "leftSideBearing": 34,
            "advanceWidth": 722
        },
        "P": {
            "x_min": 48,
            "x_max": 624,
            "y_min": 0,
            "y_max": 750,
            "ha": 750,
            "leftSideBearing": 48,
            "advanceWidth": 649
        },
        "Q": {
            "x_min": 36,
            "x_max": 904,
            "y_min": -198,
            "y_max": 751,
            "ha": 949,
            "leftSideBearing": 36,
            "advanceWidth": 727
        },
        "R": {
            "x_min": 46,
            "x_max": 705,
            "y_min": 0,
            "y_max": 751,
            "ha": 751,
            "leftSideBearing": 46,
            "advanceWidth": 704
        },
        "S": {
            "x_min": 62,
            "x_max": 556,
            "y_min": -11,
            "y_max": 751,
            "ha": 762,
            "leftSideBearing": 62,
            "advanceWidth": 594
        },
        "T": {
            "x_min": 17,
            "x_max": 669,
            "y_min": 0,
            "y_max": 743,
            "ha": 743,
            "leftSideBearing": 17,
            "advanceWidth": 692
        },
        "U": {
            "x_min": 24,
            "x_max": 725,
            "y_min": -8,
            "y_max": 743,
            "ha": 751,
            "leftSideBearing": 24,
            "advanceWidth": 740
        },
        "V": {
            "x_min": -16,
            "x_max": 689,
            "y_min": -8,
            "y_max": 743,
            "ha": 751,
            "leftSideBearing": -16,
            "advanceWidth": 670
        },
        "W": {
            "x_min": -19,
            "x_max": 1019,
            "y_min": -5,
            "y_max": 743,
            "ha": 748,
            "leftSideBearing": -19,
            "advanceWidth": 1000
        },
        "X": {
            "x_min": 7,
            "x_max": 710,
            "y_min": 0,
            "y_max": 743,
            "ha": 743,
            "leftSideBearing": 7,
            "advanceWidth": 712
        },
        "Y": {
            "x_min": -12,
            "x_max": 658,
            "y_min": 0,
            "y_max": 743,
            "ha": 743,
            "leftSideBearing": -12,
            "advanceWidth": 644
        },
        "Z": {
            "x_min": 34,
            "x_max": 616,
            "y_min": 0,
            "y_max": 746,
            "ha": 746,
            "leftSideBearing": 34,
            "advanceWidth": 654
        },
        "[": {
            "x_min": 96,
            "x_max": 338,
            "y_min": -137,
            "y_max": 804,
            "ha": 941,
            "leftSideBearing": 96,
            "advanceWidth": 428
        },
        "\\": {
            "x_min": 30,
            "x_max": 388,
            "y_min": -177,
            "y_max": 781,
            "ha": 958,
            "leftSideBearing": 30,
            "advanceWidth": 431
        },
        "]": {
            "x_min": 90,
            "x_max": 332,
            "y_min": -137,
            "y_max": 804,
            "ha": 941,
            "leftSideBearing": 90,
            "advanceWidth": 428
        },
        "^": {
            "x_min": 86,
            "x_max": 579,
            "y_min": 133,
            "y_max": 748,
            "ha": 615,
            "leftSideBearing": 86,
            "advanceWidth": 666
        },
        "_": {
            "x_min": -10,
            "x_max": 845,
            "y_min": -183,
            "y_max": -122,
            "ha": 61,
            "leftSideBearing": -10,
            "advanceWidth": 835
        },
        "`": {
            "x_min": -7,
            "x_max": 227,
            "y_min": 653,
            "y_max": 884,
            "ha": 231,
            "leftSideBearing": -7,
            "advanceWidth": 333
        },
        "a": {
            "x_min": 45,
            "x_max": 536,
            "y_min": -11,
            "y_max": 567,
            "ha": 578,
            "leftSideBearing": 45,
            "advanceWidth": 561
        },
        "b": {
            "x_min": -2,
            "x_max": 565,
            "y_min": -11,
            "y_max": 819,
            "ha": 830,
            "leftSideBearing": -2,
            "advanceWidth": 607
        },
        "c": {
            "x_min": 33,
            "x_max": 471,
            "y_min": -11,
            "y_max": 570,
            "ha": 581,
            "leftSideBearing": 33,
            "advanceWidth": 513
        },
        "d": {
            "x_min": 42,
            "x_max": 586,
            "y_min": -11,
            "y_max": 819,
            "ha": 830,
            "leftSideBearing": 42,
            "advanceWidth": 621
        },
        "e": {
            "x_min": 43,
            "x_max": 503,
            "y_min": -11,
            "y_max": 570,
            "ha": 581,
            "leftSideBearing": 43,
            "advanceWidth": 544
        },
        "f": {
            "x_min": 31,
            "x_max": 413,
            "y_min": 0,
            "y_max": 828,
            "ha": 828,
            "leftSideBearing": 31,
            "advanceWidth": 400
        },
        "g": {
            "x_min": 41,
            "x_max": 597,
            "y_min": -270,
            "y_max": 571,
            "ha": 841,
            "leftSideBearing": 41,
            "advanceWidth": 607
        },
        "h": {
            "x_min": 15,
            "x_max": 630,
            "y_min": 0,
            "y_max": 819,
            "ha": 819,
            "leftSideBearing": 15,
            "advanceWidth": 659
        },
        "i": {
            "x_min": 42,
            "x_max": 307,
            "y_min": 0,
            "y_max": 793,
            "ha": 793,
            "leftSideBearing": 42,
            "advanceWidth": 333
        },
        "j": {
            "x_min": -11,
            "x_max": 238,
            "y_min": -243,
            "y_max": 793,
            "ha": 1036,
            "leftSideBearing": -11,
            "advanceWidth": 317
        },
        "k": {
            "x_min": 20,
            "x_max": 624,
            "y_min": 0,
            "y_max": 819,
            "ha": 819,
            "leftSideBearing": 20,
            "advanceWidth": 600
        },
        "l": {
            "x_min": 37,
            "x_max": 307,
            "y_min": 0,
            "y_max": 819,
            "ha": 819,
            "leftSideBearing": 37,
            "advanceWidth": 333
        },
        "m": {
            "x_min": 33,
            "x_max": 970,
            "y_min": 0,
            "y_max": 568,
            "ha": 568,
            "leftSideBearing": 33,
            "advanceWidth": 995
        },
        "n": {
            "x_min": 33,
            "x_max": 637,
            "y_min": 0,
            "y_max": 568,
            "ha": 568,
            "leftSideBearing": 33,
            "advanceWidth": 664
        },
        "o": {
            "x_min": 45,
            "x_max": 562,
            "y_min": -11,
            "y_max": 570,
            "ha": 581,
            "leftSideBearing": 45,
            "advanceWidth": 608
        },
        "p": {
            "x_min": 29,
            "x_max": 586,
            "y_min": -242,
            "y_max": 570,
            "ha": 812,
            "leftSideBearing": 29,
            "advanceWidth": 628
        },
        "q": {
            "x_min": 42,
            "x_max": 597,
            "y_min": -242,
            "y_max": 570,
            "ha": 812,
            "leftSideBearing": 42,
            "advanceWidth": 609
        },
        "r": {
            "x_min": 47,
            "x_max": 437,
            "y_min": 0,
            "y_max": 570,
            "ha": 570,
            "leftSideBearing": 47,
            "advanceWidth": 458
        },
        "s": {
            "x_min": 55,
            "x_max": 460,
            "y_min": -11,
            "y_max": 567,
            "ha": 578,
            "leftSideBearing": 55,
            "advanceWidth": 505
        },
        "t": {
            "x_min": 31,
            "x_max": 391,
            "y_min": -10,
            "y_max": 699,
            "ha": 709,
            "leftSideBearing": 31,
            "advanceWidth": 407
        },
        "u": {
            "x_min": 36,
            "x_max": 597,
            "y_min": -11,
            "y_max": 567,
            "ha": 578,
            "leftSideBearing": 36,
            "advanceWidth": 632
        },
        "v": {
            "x_min": -1,
            "x_max": 575,
            "y_min": -8,
            "y_max": 555,
            "ha": 563,
            "leftSideBearing": -1,
            "advanceWidth": 568
        },
        "w": {
            "x_min": -7,
            "x_max": 853,
            "y_min": -8,
            "y_max": 555,
            "ha": 563,
            "leftSideBearing": -7,
            "advanceWidth": 839
        },
        "x": {
            "x_min": 6,
            "x_max": 591,
            "y_min": 0,
            "y_max": 555,
            "ha": 555,
            "leftSideBearing": 6,
            "advanceWidth": 595
        },
        "y": {
            "x_min": -3,
            "x_max": 571,
            "y_min": -249,
            "y_max": 555,
            "ha": 804,
            "leftSideBearing": -3,
            "advanceWidth": 572
        },
        "z": {
            "x_min": 30,
            "x_max": 518,
            "y_min": 0,
            "y_max": 555,
            "ha": 555,
            "leftSideBearing": 30,
            "advanceWidth": 554
        },
        "{": {
            "x_min": 57,
            "x_max": 431,
            "y_min": -137,
            "y_max": 806,
            "ha": 943,
            "leftSideBearing": 57,
            "advanceWidth": 508
        },
        "|": {
            "x_min": 170,
            "x_max": 252,
            "y_min": -91,
            "y_max": 869,
            "ha": 960,
            "leftSideBearing": 170,
            "advanceWidth": 422
        },
        "}": {
            "x_min": 77,
            "x_max": 450,
            "y_min": -137,
            "y_max": 806,
            "ha": 943,
            "leftSideBearing": 77,
            "advanceWidth": 508
        },
        "~": {
            "x_min": 107,
            "x_max": 584,
            "y_min": 218,
            "y_max": 379,
            "ha": 161,
            "leftSideBearing": 107,
            "advanceWidth": 692
        }
    },
    "resolution": 1000,
    "generatedOn": "2020-10-16T18:04:00.805Z"
};


/***/ }),

/***/ "./src/styles/font_metrics/arial_metrics.js":
/*!**************************************************!*\
  !*** ./src/styles/font_metrics/arial_metrics.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ArialFont = void 0;
exports.ArialFont = {
    smufl: false,
    name: "Arial",
    spacing: 50,
    Description: 'Built-in sans-serif font',
    bold: true,
    italic: true,
    monospaced: false,
    serifs: false,
    "glyphs": {
        "0": {
            "x_min": 85,
            "x_max": 1041,
            "y_min": -25,
            "y_max": 1472,
            "ha": 1497,
            "leftSideBearing": 85,
            "advanceWidth": 1139
        },
        "1": {
            "x_min": 223,
            "x_max": 763,
            "y_min": 0,
            "y_max": 1472,
            "ha": 1472,
            "leftSideBearing": 223,
            "advanceWidth": 1139
        },
        "2": {
            "x_min": 61.840001123045234,
            "x_max": 1031,
            "y_min": 0,
            "y_max": 1472,
            "ha": 1472,
            "leftSideBearing": 61,
            "advanceWidth": 1139
        },
        "3": {
            "x_min": 86,
            "x_max": 1046,
            "y_min": -26,
            "y_max": 1472,
            "ha": 1498,
            "leftSideBearing": 86,
            "advanceWidth": 1139
        },
        "4": {
            "x_min": 26,
            "x_max": 1040,
            "y_min": 0,
            "y_max": 1466,
            "ha": 1466,
            "leftSideBearing": 26,
            "advanceWidth": 1139
        },
        "5": {
            "x_min": 85,
            "x_max": 1057,
            "y_min": -25,
            "y_max": 1446,
            "ha": 1471,
            "leftSideBearing": 85,
            "advanceWidth": 1139
        },
        "6": {
            "x_min": 77,
            "x_max": 1045,
            "y_min": -25,
            "y_max": 1472,
            "ha": 1497,
            "leftSideBearing": 77,
            "advanceWidth": 1139
        },
        "7": {
            "x_min": 97,
            "x_max": 1046,
            "y_min": 0,
            "y_max": 1447,
            "ha": 1447,
            "leftSideBearing": 97,
            "advanceWidth": 1139
        },
        "8": {
            "x_min": 83,
            "x_max": 1049,
            "y_min": -25,
            "y_max": 1472,
            "ha": 1497,
            "leftSideBearing": 83,
            "advanceWidth": 1139
        },
        "9": {
            "x_min": 85,
            "x_max": 1049,
            "y_min": -25,
            "y_max": 1472,
            "ha": 1497,
            "leftSideBearing": 85,
            "advanceWidth": 1139
        },
        " ": {
            "x_min": 0,
            "x_max": 0,
            "y_min": 0,
            "y_max": 0,
            "ha": 0,
            "leftSideBearing": 0,
            "advanceWidth": 569
        },
        "!": {
            "x_min": 176,
            "x_max": 399,
            "y_min": 0,
            "y_max": 1466,
            "ha": 1466,
            "leftSideBearing": 176,
            "advanceWidth": 569
        },
        "\"": {
            "x_min": 94,
            "x_max": 631,
            "y_min": 947,
            "y_max": 1466,
            "ha": 519,
            "leftSideBearing": 94,
            "advanceWidth": 727
        },
        "#": {
            "x_min": 21,
            "x_max": 1113,
            "y_min": -25,
            "y_max": 1491,
            "ha": 1516,
            "leftSideBearing": 21,
            "advanceWidth": 1139
        },
        "$": {
            "x_min": 73,
            "x_max": 1043,
            "y_min": -211,
            "y_max": 1601,
            "ha": 1812,
            "leftSideBearing": 73,
            "advanceWidth": 1139
        },
        "%": {
            "x_min": 119,
            "x_max": 1695,
            "y_min": -54,
            "y_max": 1491,
            "ha": 1545,
            "leftSideBearing": 119,
            "advanceWidth": 1821
        },
        "&": {
            "x_min": 88,
            "x_max": 1319,
            "y_min": -34,
            "y_max": 1491,
            "ha": 1525,
            "leftSideBearing": 88,
            "advanceWidth": 1366
        },
        "'": {
            "x_min": 90,
            "x_max": 295,
            "y_min": 947,
            "y_max": 1466,
            "ha": 519,
            "leftSideBearing": 90,
            "advanceWidth": 391
        },
        "(": {
            "x_min": 124,
            "x_max": 608,
            "y_min": -431,
            "y_max": 1491,
            "ha": 1922,
            "leftSideBearing": 124,
            "advanceWidth": 682
        },
        ")": {
            "x_min": 124,
            "x_max": 608,
            "y_min": -431,
            "y_max": 1491,
            "ha": 1922,
            "leftSideBearing": 124,
            "advanceWidth": 682
        },
        "*": {
            "x_min": 64,
            "x_max": 725,
            "y_min": 867,
            "y_max": 1491,
            "ha": 624,
            "leftSideBearing": 64,
            "advanceWidth": 797
        },
        "+": {
            "x_min": 114,
            "x_max": 1082,
            "y_min": 237,
            "y_max": 1206,
            "ha": 969,
            "leftSideBearing": 114,
            "advanceWidth": 1196
        },
        ",": {
            "x_min": 170,
            "x_max": 387,
            "y_min": -290,
            "y_max": 205,
            "ha": 495,
            "leftSideBearing": 170,
            "advanceWidth": 569
        },
        "-": {
            "x_min": 65,
            "x_max": 618,
            "y_min": 440,
            "y_max": 621,
            "ha": 181,
            "leftSideBearing": 65,
            "advanceWidth": 682
        },
        ".": {
            "x_min": 186,
            "x_max": 391,
            "y_min": 0,
            "y_max": 205,
            "ha": 205,
            "leftSideBearing": 186,
            "advanceWidth": 569
        },
        "/": {
            "x_min": 0,
            "x_max": 569,
            "y_min": -25,
            "y_max": 1491,
            "ha": 1516,
            "leftSideBearing": 0,
            "advanceWidth": 569
        },
        ":": {
            "x_min": 185,
            "x_max": 390,
            "y_min": 0,
            "y_max": 1062,
            "ha": 1062,
            "leftSideBearing": 185,
            "advanceWidth": 569
        },
        ";": {
            "x_min": 170,
            "x_max": 387,
            "y_min": -290,
            "y_max": 1062,
            "ha": 1352,
            "leftSideBearing": 170,
            "advanceWidth": 569
        },
        "<": {
            "x_min": 112,
            "x_max": 1083,
            "y_min": 226,
            "y_max": 1219,
            "ha": 993,
            "leftSideBearing": 112,
            "advanceWidth": 1196
        },
        "=": {
            "x_min": 114,
            "x_max": 1082,
            "y_min": 417,
            "y_max": 1030,
            "ha": 613,
            "leftSideBearing": 114,
            "advanceWidth": 1196
        },
        ">": {
            "x_min": 112,
            "x_max": 1083,
            "y_min": 226,
            "y_max": 1219,
            "ha": 993,
            "leftSideBearing": 112,
            "advanceWidth": 1196
        },
        "?": {
            "x_min": 90,
            "x_max": 1036,
            "y_min": 0,
            "y_max": 1491,
            "ha": 1491,
            "leftSideBearing": 90,
            "advanceWidth": 1139
        },
        "@": {
            "x_min": 111,
            "x_max": 2005,
            "y_min": -431,
            "y_max": 1493,
            "ha": 1924,
            "leftSideBearing": 111,
            "advanceWidth": 2079
        },
        "A": {
            "x_min": -3,
            "x_max": 1369,
            "y_min": 0,
            "y_max": 1466,
            "ha": 1466,
            "leftSideBearing": -3,
            "advanceWidth": 1366
        },
        "B": {
            "x_min": 150,
            "x_max": 1257,
            "y_min": 0,
            "y_max": 1466,
            "ha": 1466,
            "leftSideBearing": 150,
            "advanceWidth": 1366
        },
        "C": {
            "x_min": 102,
            "x_max": 1398,
            "y_min": -25,
            "y_max": 1491,
            "ha": 1516,
            "leftSideBearing": 102,
            "advanceWidth": 1479
        },
        "D": {
            "x_min": 158,
            "x_max": 1370,
            "y_min": 0,
            "y_max": 1466,
            "ha": 1466,
            "leftSideBearing": 158,
            "advanceWidth": 1479
        },
        "E": {
            "x_min": 162,
            "x_max": 1256,
            "y_min": 0,
            "y_max": 1466,
            "ha": 1466,
            "leftSideBearing": 162,
            "advanceWidth": 1366
        },
        "F": {
            "x_min": 168,
            "x_max": 1157,
            "y_min": 0,
            "y_max": 1466,
            "ha": 1466,
            "leftSideBearing": 168,
            "advanceWidth": 1251
        },
        "G": {
            "x_min": 109,
            "x_max": 1465,
            "y_min": -25,
            "y_max": 1491,
            "ha": 1516,
            "leftSideBearing": 109,
            "advanceWidth": 1593
        },
        "H": {
            "x_min": 164,
            "x_max": 1314,
            "y_min": 0,
            "y_max": 1466,
            "ha": 1466,
            "leftSideBearing": 164,
            "advanceWidth": 1479
        },
        "I": {
            "x_min": 191,
            "x_max": 385,
            "y_min": 0,
            "y_max": 1466,
            "ha": 1466,
            "leftSideBearing": 191,
            "advanceWidth": 569
        },
        "J": {
            "x_min": 58.84976474807333,
            "x_max": 865,
            "y_min": -25,
            "y_max": 1466,
            "ha": 1491,
            "leftSideBearing": 58,
            "advanceWidth": 1024
        },
        "K": {
            "x_min": 150,
            "x_max": 1362,
            "y_min": 0,
            "y_max": 1466,
            "ha": 1466,
            "leftSideBearing": 150,
            "advanceWidth": 1366
        },
        "L": {
            "x_min": 150,
            "x_max": 1066,
            "y_min": 0,
            "y_max": 1466,
            "ha": 1466,
            "leftSideBearing": 150,
            "advanceWidth": 1139
        },
        "M": {
            "x_min": 152,
            "x_max": 1551,
            "y_min": 0,
            "y_max": 1466,
            "ha": 1466,
            "leftSideBearing": 152,
            "advanceWidth": 1706
        },
        "N": {
            "x_min": 156,
            "x_max": 1311,
            "y_min": 0,
            "y_max": 1466,
            "ha": 1466,
            "leftSideBearing": 156,
            "advanceWidth": 1479
        },
        "O": {
            "x_min": 99,
            "x_max": 1501,
            "y_min": -25,
            "y_max": 1492,
            "ha": 1517,
            "leftSideBearing": 99,
            "advanceWidth": 1593
        },
        "P": {
            "x_min": 158,
            "x_max": 1277,
            "y_min": 0,
            "y_max": 1466,
            "ha": 1466,
            "leftSideBearing": 158,
            "advanceWidth": 1366
        },
        "Q": {
            "x_min": 88,
            "x_max": 1518,
            "y_min": -114,
            "y_max": 1492,
            "ha": 1606,
            "leftSideBearing": 88,
            "advanceWidth": 1593
        },
        "R": {
            "x_min": 161,
            "x_max": 1453,
            "y_min": 0,
            "y_max": 1466,
            "ha": 1466,
            "leftSideBearing": 161,
            "advanceWidth": 1479
        },
        "S": {
            "x_min": 92,
            "x_max": 1259,
            "y_min": -25,
            "y_max": 1491,
            "ha": 1516,
            "leftSideBearing": 92,
            "advanceWidth": 1366
        },
        "T": {
            "x_min": 48,
            "x_max": 1210,
            "y_min": 0,
            "y_max": 1466,
            "ha": 1466,
            "leftSideBearing": 48,
            "advanceWidth": 1251
        },
        "U": {
            "x_min": 161,
            "x_max": 1314,
            "y_min": -25,
            "y_max": 1466,
            "ha": 1491,
            "leftSideBearing": 161,
            "advanceWidth": 1479
        },
        "V": {
            "x_min": 9,
            "x_max": 1350,
            "y_min": 0,
            "y_max": 1466,
            "ha": 1466,
            "leftSideBearing": 9,
            "advanceWidth": 1366
        },
        "W": {
            "x_min": 25,
            "x_max": 1910,
            "y_min": 0,
            "y_max": 1466,
            "ha": 1466,
            "leftSideBearing": 25,
            "advanceWidth": 1933
        },
        "X": {
            "x_min": 9,
            "x_max": 1353,
            "y_min": 0,
            "y_max": 1466,
            "ha": 1466,
            "leftSideBearing": 9,
            "advanceWidth": 1366
        },
        "Y": {
            "x_min": 6,
            "x_max": 1350,
            "y_min": 0,
            "y_max": 1466,
            "ha": 1466,
            "leftSideBearing": 6,
            "advanceWidth": 1366
        },
        "Z": {
            "x_min": 41,
            "x_max": 1200,
            "y_min": 0,
            "y_max": 1466,
            "ha": 1466,
            "leftSideBearing": 41,
            "advanceWidth": 1251
        },
        "[": {
            "x_min": 139,
            "x_max": 536,
            "y_min": -407,
            "y_max": 1466,
            "ha": 1873,
            "leftSideBearing": 139,
            "advanceWidth": 569
        },
        "\\": {
            "x_min": 0,
            "x_max": 569,
            "y_min": -25,
            "y_max": 1491,
            "ha": 1516,
            "leftSideBearing": 0,
            "advanceWidth": 569
        },
        "]": {
            "x_min": 39,
            "x_max": 436,
            "y_min": -407,
            "y_max": 1466,
            "ha": 1873,
            "leftSideBearing": 39,
            "advanceWidth": 569
        },
        "^": {
            "x_min": 54,
            "x_max": 907,
            "y_min": 690,
            "y_max": 1491,
            "ha": 801,
            "leftSideBearing": 54,
            "advanceWidth": 961
        },
        "_": {
            "x_min": -31,
            "x_max": 1162,
            "y_min": -407,
            "y_max": -277,
            "ha": 130,
            "leftSideBearing": -31,
            "advanceWidth": 1139
        },
        "`": {
            "x_min": 89,
            "x_max": 465,
            "y_min": 1194,
            "y_max": 1474,
            "ha": 280,
            "leftSideBearing": 89,
            "advanceWidth": 682
        },
        "a": {
            "x_min": 74,
            "x_max": 1052,
            "y_min": -24,
            "y_max": 1086,
            "ha": 1110,
            "leftSideBearing": 74,
            "advanceWidth": 1139
        },
        "b": {
            "x_min": 134,
            "x_max": 1055,
            "y_min": -24,
            "y_max": 1466,
            "ha": 1490,
            "leftSideBearing": 134,
            "advanceWidth": 1139
        },
        "c": {
            "x_min": 80,
            "x_max": 1005,
            "y_min": -24,
            "y_max": 1086,
            "ha": 1110,
            "leftSideBearing": 80,
            "advanceWidth": 1024
        },
        "d": {
            "x_min": 70,
            "x_max": 991,
            "y_min": -24,
            "y_max": 1466,
            "ha": 1490,
            "leftSideBearing": 70,
            "advanceWidth": 1139
        },
        "e": {
            "x_min": 75,
            "x_max": 1054,
            "y_min": -24,
            "y_max": 1086,
            "ha": 1110,
            "leftSideBearing": 75,
            "advanceWidth": 1139
        },
        "f": {
            "x_min": 19,
            "x_max": 640,
            "y_min": 0,
            "y_max": 1491,
            "ha": 1491,
            "leftSideBearing": 19,
            "advanceWidth": 569
        },
        "g": {
            "x_min": 66,
            "x_max": 1002,
            "y_min": -431,
            "y_max": 1086,
            "ha": 1517,
            "leftSideBearing": 66,
            "advanceWidth": 1139
        },
        "h": {
            "x_min": 135,
            "x_max": 1000,
            "y_min": 0,
            "y_max": 1466,
            "ha": 1466,
            "leftSideBearing": 135,
            "advanceWidth": 1139
        },
        "i": {
            "x_min": 136,
            "x_max": 316,
            "y_min": 0,
            "y_max": 1466,
            "ha": 1466,
            "leftSideBearing": 136,
            "advanceWidth": 455
        },
        "j": {
            "x_min": -94,
            "x_max": 314,
            "y_min": -431,
            "y_max": 1466,
            "ha": 1897,
            "leftSideBearing": -94,
            "advanceWidth": 455
        },
        "k": {
            "x_min": 136,
            "x_max": 1016,
            "y_min": 0,
            "y_max": 1466,
            "ha": 1466,
            "leftSideBearing": 136,
            "advanceWidth": 1024
        },
        "l": {
            "x_min": 131,
            "x_max": 311,
            "y_min": 0,
            "y_max": 1466,
            "ha": 1466,
            "leftSideBearing": 131,
            "advanceWidth": 455
        },
        "m": {
            "x_min": 135,
            "x_max": 1574,
            "y_min": 0,
            "y_max": 1086,
            "ha": 1086,
            "leftSideBearing": 135,
            "advanceWidth": 1706
        },
        "n": {
            "x_min": 135,
            "x_max": 998,
            "y_min": 0,
            "y_max": 1086,
            "ha": 1086,
            "leftSideBearing": 135,
            "advanceWidth": 1139
        },
        "o": {
            "x_min": 68,
            "x_max": 1063,
            "y_min": -24,
            "y_max": 1086,
            "ha": 1110,
            "leftSideBearing": 68,
            "advanceWidth": 1139
        },
        "p": {
            "x_min": 135,
            "x_max": 1057,
            "y_min": -407,
            "y_max": 1086,
            "ha": 1493,
            "leftSideBearing": 135,
            "advanceWidth": 1139
        },
        "q": {
            "x_min": 72,
            "x_max": 992,
            "y_min": -407,
            "y_max": 1086,
            "ha": 1493,
            "leftSideBearing": 72,
            "advanceWidth": 1139
        },
        "r": {
            "x_min": 133,
            "x_max": 710,
            "y_min": 0,
            "y_max": 1086,
            "ha": 1086,
            "leftSideBearing": 133,
            "advanceWidth": 682
        },
        "s": {
            "x_min": 63,
            "x_max": 945,
            "y_min": -24,
            "y_max": 1086,
            "ha": 1110,
            "leftSideBearing": 63,
            "advanceWidth": 1024
        },
        "t": {
            "x_min": 36,
            "x_max": 554,
            "y_min": -14,
            "y_max": 1433,
            "ha": 1447,
            "leftSideBearing": 36,
            "advanceWidth": 569
        },
        "u": {
            "x_min": 131,
            "x_max": 992,
            "y_min": -24,
            "y_max": 1062,
            "ha": 1086,
            "leftSideBearing": 131,
            "advanceWidth": 1139
        },
        "v": {
            "x_min": 26,
            "x_max": 1000,
            "y_min": 0,
            "y_max": 1062,
            "ha": 1062,
            "leftSideBearing": 26,
            "advanceWidth": 1024
        },
        "w": {
            "x_min": 6,
            "x_max": 1463,
            "y_min": 0,
            "y_max": 1062,
            "ha": 1062,
            "leftSideBearing": 6,
            "advanceWidth": 1479
        },
        "x": {
            "x_min": 15,
            "x_max": 1009,
            "y_min": 0,
            "y_max": 1062,
            "ha": 1062,
            "leftSideBearing": 15,
            "advanceWidth": 1024
        },
        "y": {
            "x_min": 33,
            "x_max": 1006,
            "y_min": -431,
            "y_max": 1062,
            "ha": 1493,
            "leftSideBearing": 33,
            "advanceWidth": 1024
        },
        "z": {
            "x_min": 40,
            "x_max": 980,
            "y_min": 0,
            "y_max": 1062,
            "ha": 1062,
            "leftSideBearing": 40,
            "advanceWidth": 1024
        },
        "{": {
            "x_min": 57,
            "x_max": 636,
            "y_min": -431,
            "y_max": 1491,
            "ha": 1922,
            "leftSideBearing": 57,
            "advanceWidth": 684
        },
        "|": {
            "x_min": 188,
            "x_max": 345,
            "y_min": -431,
            "y_max": 1491,
            "ha": 1922,
            "leftSideBearing": 188,
            "advanceWidth": 532
        },
        "}": {
            "x_min": 47,
            "x_max": 626,
            "y_min": -431,
            "y_max": 1491,
            "ha": 1922,
            "leftSideBearing": 47,
            "advanceWidth": 684
        },
        "~": {
            "x_min": 87,
            "x_max": 1110,
            "y_min": 557,
            "y_max": 885,
            "ha": 328,
            "leftSideBearing": 87,
            "advanceWidth": 1196
        }
    },
    "fontFamily": "Arial",
    "resolution": 2048,
    "generatedOn": "2020-10-18T18:48:11.823Z"
};


/***/ }),

/***/ "./src/styles/font_metrics/ssp-sans-metrics.js":
/*!*****************************************************!*\
  !*** ./src/styles/font_metrics/ssp-sans-metrics.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SourceSansProFont = void 0;
exports.SourceSansProFont = {
    smufl: false,
    name: "Sans",
    spacing: 50,
    description: "Open-source Sans font from Adobe",
    serifs: true,
    monospaced: false,
    superscriptOffset: 0.66,
    subscriptOffset: 0.66,
    maxSizeGlyph: 'H',
    "fontFamily": "Source Sans Pro",
    "resolution": 1000,
    "generatedOn": "2020-11-01T21:31:30.347Z",
    "glyphs": {
        "0": {
            "x_min": 44,
            "x_max": 453,
            "y_min": -12,
            "y_max": 650,
            "ha": 662,
            "leftSideBearing": 44,
            "advanceWidth": 497
        },
        "1": {
            "x_min": 79,
            "x_max": 439,
            "y_min": 0,
            "y_max": 638,
            "ha": 638,
            "leftSideBearing": 79,
            "advanceWidth": 497
        },
        "2": {
            "x_min": 36,
            "x_max": 452,
            "y_min": 0,
            "y_max": 650,
            "ha": 650,
            "leftSideBearing": 36,
            "advanceWidth": 497
        },
        "3": {
            "x_min": 26,
            "x_max": 446,
            "y_min": -12,
            "y_max": 650,
            "ha": 662,
            "leftSideBearing": 26,
            "advanceWidth": 497
        },
        "4": {
            "x_min": 17,
            "x_max": 469,
            "y_min": 0,
            "y_max": 638,
            "ha": 638,
            "leftSideBearing": 17,
            "advanceWidth": 497
        },
        "5": {
            "x_min": 25,
            "x_max": 449,
            "y_min": -12,
            "y_max": 638,
            "ha": 650,
            "leftSideBearing": 25,
            "advanceWidth": 497
        },
        "6": {
            "x_min": 48,
            "x_max": 457,
            "y_min": -12,
            "y_max": 650,
            "ha": 662,
            "leftSideBearing": 48,
            "advanceWidth": 497
        },
        "7": {
            "x_min": 44,
            "x_max": 455,
            "y_min": 0,
            "y_max": 638,
            "ha": 638,
            "leftSideBearing": 44,
            "advanceWidth": 497
        },
        "8": {
            "x_min": 41,
            "x_max": 456,
            "y_min": -12,
            "y_max": 650,
            "ha": 662,
            "leftSideBearing": 41,
            "advanceWidth": 497
        },
        "9": {
            "x_min": 40,
            "x_max": 448,
            "y_min": -12,
            "y_max": 650,
            "ha": 662,
            "leftSideBearing": 40,
            "advanceWidth": 497
        },
        " ": {
            "x_min": 0,
            "x_max": 0,
            "y_min": 0,
            "y_max": 0,
            "ha": 0,
            "leftSideBearing": 0,
            "advanceWidth": 200
        },
        "!": {
            "x_min": 85,
            "x_max": 204,
            "y_min": -12,
            "y_max": 670,
            "ha": 682,
            "leftSideBearing": 85,
            "advanceWidth": 289
        },
        "\"": {
            "x_min": 80,
            "x_max": 344,
            "y_min": 431,
            "y_max": 690,
            "ha": 259,
            "leftSideBearing": 80,
            "advanceWidth": 425
        },
        "#": {
            "x_min": 35,
            "x_max": 467,
            "y_min": 0,
            "y_max": 650,
            "ha": 650,
            "leftSideBearing": 35,
            "advanceWidth": 497
        },
        "$": {
            "x_min": 52,
            "x_max": 437,
            "y_min": -110,
            "y_max": 748,
            "ha": 858,
            "leftSideBearing": 52,
            "advanceWidth": 497
        },
        "%": {
            "x_min": 35,
            "x_max": 790,
            "y_min": -12,
            "y_max": 668,
            "ha": 680,
            "leftSideBearing": 35,
            "advanceWidth": 824
        },
        "&": {
            "x_min": 32,
            "x_max": 594,
            "y_min": -12,
            "y_max": 668,
            "ha": 680,
            "leftSideBearing": 32,
            "advanceWidth": 609
        },
        "'": {
            "x_min": 80,
            "x_max": 168,
            "y_min": 431,
            "y_max": 690,
            "ha": 259,
            "leftSideBearing": 80,
            "advanceWidth": 249
        },
        "(": {
            "x_min": 82,
            "x_max": 265,
            "y_min": -176,
            "y_max": 732,
            "ha": 908,
            "leftSideBearing": 82,
            "advanceWidth": 303
        },
        ")": {
            "x_min": 38,
            "x_max": 221,
            "y_min": -176,
            "y_max": 732,
            "ha": 908,
            "leftSideBearing": 38,
            "advanceWidth": 303
        },
        "*": {
            "x_min": 58,
            "x_max": 360,
            "y_min": 420,
            "y_max": 712,
            "ha": 292,
            "leftSideBearing": 58,
            "advanceWidth": 418
        },
        "+": {
            "x_min": 34,
            "x_max": 463,
            "y_min": 104,
            "y_max": 556,
            "ha": 452,
            "leftSideBearing": 34,
            "advanceWidth": 497
        },
        ",": {
            "x_min": 47,
            "x_max": 198,
            "y_min": -170,
            "y_max": 114,
            "ha": 284,
            "leftSideBearing": 47,
            "advanceWidth": 249
        },
        "-": {
            "x_min": 41,
            "x_max": 271,
            "y_min": 219,
            "y_max": 282,
            "ha": 63,
            "leftSideBearing": 41,
            "advanceWidth": 311
        },
        ".": {
            "x_min": 65,
            "x_max": 184,
            "y_min": -12,
            "y_max": 114,
            "ha": 126,
            "leftSideBearing": 65,
            "advanceWidth": 249
        },
        "/": {
            "x_min": 10,
            "x_max": 337,
            "y_min": -160,
            "y_max": 710,
            "ha": 870,
            "leftSideBearing": 10,
            "advanceWidth": 350
        },
        ":": {
            "x_min": 65,
            "x_max": 184,
            "y_min": -12,
            "y_max": 475,
            "ha": 487,
            "leftSideBearing": 65,
            "advanceWidth": 249
        },
        ";": {
            "x_min": 47,
            "x_max": 198,
            "y_min": -170,
            "y_max": 475,
            "ha": 645,
            "leftSideBearing": 47,
            "advanceWidth": 249
        },
        "<": {
            "x_min": 34,
            "x_max": 463,
            "y_min": 131,
            "y_max": 533,
            "ha": 402,
            "leftSideBearing": 34,
            "advanceWidth": 497
        },
        "=": {
            "x_min": 34,
            "x_max": 463,
            "y_min": 193,
            "y_max": 468,
            "ha": 275,
            "leftSideBearing": 34,
            "advanceWidth": 497
        },
        ">": {
            "x_min": 34,
            "x_max": 463,
            "y_min": 131,
            "y_max": 533,
            "ha": 402,
            "leftSideBearing": 34,
            "advanceWidth": 497
        },
        "?": {
            "x_min": 38,
            "x_max": 377,
            "y_min": -12,
            "y_max": 682,
            "ha": 694,
            "leftSideBearing": 38,
            "advanceWidth": 425
        },
        "@": {
            "x_min": 51,
            "x_max": 796,
            "y_min": -155,
            "y_max": 646,
            "ha": 801,
            "leftSideBearing": 51,
            "advanceWidth": 847
        },
        "A": {
            "x_min": 3,
            "x_max": 541,
            "y_min": 0,
            "y_max": 656,
            "ha": 656,
            "leftSideBearing": 3,
            "advanceWidth": 544
        },
        "B": {
            "x_min": 90,
            "x_max": 548,
            "y_min": 0,
            "y_max": 656,
            "ha": 656,
            "leftSideBearing": 90,
            "advanceWidth": 588
        },
        "C": {
            "x_min": 52,
            "x_max": 539,
            "y_min": -12,
            "y_max": 668,
            "ha": 680,
            "leftSideBearing": 52,
            "advanceWidth": 571
        },
        "D": {
            "x_min": 90,
            "x_max": 564,
            "y_min": 0,
            "y_max": 656,
            "ha": 656,
            "leftSideBearing": 90,
            "advanceWidth": 615
        },
        "E": {
            "x_min": 90,
            "x_max": 478,
            "y_min": 0,
            "y_max": 656,
            "ha": 656,
            "leftSideBearing": 90,
            "advanceWidth": 527
        },
        "F": {
            "x_min": 90,
            "x_max": 468,
            "y_min": 0,
            "y_max": 656,
            "ha": 656,
            "leftSideBearing": 90,
            "advanceWidth": 494
        },
        "G": {
            "x_min": 52,
            "x_max": 550,
            "y_min": -12,
            "y_max": 668,
            "ha": 680,
            "leftSideBearing": 52,
            "advanceWidth": 617
        },
        "H": {
            "x_min": 90,
            "x_max": 562,
            "y_min": 0,
            "y_max": 656,
            "ha": 656,
            "leftSideBearing": 90,
            "advanceWidth": 652
        },
        "I": {
            "x_min": 90,
            "x_max": 173,
            "y_min": 0,
            "y_max": 656,
            "ha": 656,
            "leftSideBearing": 90,
            "advanceWidth": 263
        },
        "J": {
            "x_min": 31,
            "x_max": 393,
            "y_min": -12,
            "y_max": 656,
            "ha": 668,
            "leftSideBearing": 31,
            "advanceWidth": 480
        },
        "K": {
            "x_min": 90,
            "x_max": 575,
            "y_min": 0,
            "y_max": 656,
            "ha": 656,
            "leftSideBearing": 90,
            "advanceWidth": 579
        },
        "L": {
            "x_min": 90,
            "x_max": 460,
            "y_min": 0,
            "y_max": 656,
            "ha": 656,
            "leftSideBearing": 90,
            "advanceWidth": 486
        },
        "M": {
            "x_min": 90,
            "x_max": 637,
            "y_min": 0,
            "y_max": 656,
            "ha": 656,
            "leftSideBearing": 90,
            "advanceWidth": 727
        },
        "N": {
            "x_min": 90,
            "x_max": 557,
            "y_min": 0,
            "y_max": 656,
            "ha": 656,
            "leftSideBearing": 90,
            "advanceWidth": 647
        },
        "O": {
            "x_min": 52,
            "x_max": 613,
            "y_min": -12,
            "y_max": 668,
            "ha": 680,
            "leftSideBearing": 52,
            "advanceWidth": 664
        },
        "P": {
            "x_min": 90,
            "x_max": 523,
            "y_min": 0,
            "y_max": 656,
            "ha": 656,
            "leftSideBearing": 90,
            "advanceWidth": 566
        },
        "Q": {
            "x_min": 52,
            "x_max": 627,
            "y_min": -165,
            "y_max": 668,
            "ha": 833,
            "leftSideBearing": 52,
            "advanceWidth": 664
        },
        "R": {
            "x_min": 90,
            "x_max": 544,
            "y_min": 0,
            "y_max": 656,
            "ha": 656,
            "leftSideBearing": 90,
            "advanceWidth": 569
        },
        "S": {
            "x_min": 42,
            "x_max": 495,
            "y_min": -12,
            "y_max": 668,
            "ha": 680,
            "leftSideBearing": 42,
            "advanceWidth": 534
        },
        "T": {
            "x_min": 28,
            "x_max": 508,
            "y_min": 0,
            "y_max": 656,
            "ha": 656,
            "leftSideBearing": 28,
            "advanceWidth": 536
        },
        "U": {
            "x_min": 87,
            "x_max": 558,
            "y_min": -12,
            "y_max": 656,
            "ha": 668,
            "leftSideBearing": 87,
            "advanceWidth": 645
        },
        "V": {
            "x_min": 0,
            "x_max": 515,
            "y_min": 0,
            "y_max": 656,
            "ha": 656,
            "leftSideBearing": 0,
            "advanceWidth": 515
        },
        "W": {
            "x_min": 23,
            "x_max": 762,
            "y_min": 0,
            "y_max": 656,
            "ha": 656,
            "leftSideBearing": 23,
            "advanceWidth": 786
        },
        "X": {
            "x_min": 15,
            "x_max": 498,
            "y_min": 0,
            "y_max": 656,
            "ha": 656,
            "leftSideBearing": 15,
            "advanceWidth": 513
        },
        "Y": {
            "x_min": -1,
            "x_max": 477,
            "y_min": 0,
            "y_max": 656,
            "ha": 656,
            "leftSideBearing": -1,
            "advanceWidth": 476
        },
        "Z": {
            "x_min": 45,
            "x_max": 497,
            "y_min": 0,
            "y_max": 656,
            "ha": 656,
            "leftSideBearing": 45,
            "advanceWidth": 539
        },
        "[": {
            "x_min": 94,
            "x_max": 273,
            "y_min": -152,
            "y_max": 708,
            "ha": 860,
            "leftSideBearing": 94,
            "advanceWidth": 303
        },
        "\\": {
            "x_min": 14,
            "x_max": 340,
            "y_min": -160,
            "y_max": 710,
            "ha": 870,
            "leftSideBearing": 14,
            "advanceWidth": 350
        },
        "]": {
            "x_min": 31,
            "x_max": 209,
            "y_min": -152,
            "y_max": 708,
            "ha": 860,
            "leftSideBearing": 31,
            "advanceWidth": 303
        },
        "^": {
            "x_min": 60,
            "x_max": 437,
            "y_min": 284,
            "y_max": 670,
            "ha": 386,
            "leftSideBearing": 60,
            "advanceWidth": 497
        },
        "_": {
            "x_min": 12,
            "x_max": 488,
            "y_min": -126,
            "y_max": -71,
            "ha": 55,
            "leftSideBearing": 12,
            "advanceWidth": 500
        },
        "`": {
            "x_min": 128,
            "x_max": 327,
            "y_min": 573,
            "y_max": 781,
            "ha": 208,
            "leftSideBearing": 128,
            "advanceWidth": 542
        },
        "a": {
            "x_min": 52,
            "x_max": 433,
            "y_min": -12,
            "y_max": 498,
            "ha": 510,
            "leftSideBearing": 52,
            "advanceWidth": 504
        },
        "b": {
            "x_min": 82,
            "x_max": 507,
            "y_min": -12,
            "y_max": 712,
            "ha": 724,
            "leftSideBearing": 82,
            "advanceWidth": 553
        },
        "c": {
            "x_min": 46,
            "x_max": 431,
            "y_min": -12,
            "y_max": 498,
            "ha": 510,
            "leftSideBearing": 46,
            "advanceWidth": 456
        },
        "d": {
            "x_min": 47,
            "x_max": 473,
            "y_min": -12,
            "y_max": 712,
            "ha": 724,
            "leftSideBearing": 47,
            "advanceWidth": 555
        },
        "e": {
            "x_min": 46,
            "x_max": 458,
            "y_min": -12,
            "y_max": 498,
            "ha": 510,
            "leftSideBearing": 46,
            "advanceWidth": 496
        },
        "f": {
            "x_min": 30,
            "x_max": 319,
            "y_min": 0,
            "y_max": 724,
            "ha": 724,
            "leftSideBearing": 30,
            "advanceWidth": 292
        },
        "g": {
            "x_min": 45,
            "x_max": 492,
            "y_min": -224,
            "y_max": 498,
            "ha": 722,
            "leftSideBearing": 45,
            "advanceWidth": 504
        },
        "h": {
            "x_min": 82,
            "x_max": 471,
            "y_min": 0,
            "y_max": 712,
            "ha": 712,
            "leftSideBearing": 82,
            "advanceWidth": 544
        },
        "i": {
            "x_min": 67,
            "x_max": 181,
            "y_min": 0,
            "y_max": 692,
            "ha": 692,
            "leftSideBearing": 67,
            "advanceWidth": 246
        },
        "j": {
            "x_min": -40,
            "x_max": 181,
            "y_min": -217,
            "y_max": 692,
            "ha": 909,
            "leftSideBearing": -40,
            "advanceWidth": 247
        },
        "k": {
            "x_min": 82,
            "x_max": 486,
            "y_min": 0,
            "y_max": 712,
            "ha": 712,
            "leftSideBearing": 82,
            "advanceWidth": 495
        },
        "l": {
            "x_min": 82,
            "x_max": 216,
            "y_min": -12,
            "y_max": 712,
            "ha": 724,
            "leftSideBearing": 82,
            "advanceWidth": 255
        },
        "m": {
            "x_min": 82,
            "x_max": 753,
            "y_min": 0,
            "y_max": 498,
            "ha": 498,
            "leftSideBearing": 82,
            "advanceWidth": 829
        },
        "n": {
            "x_min": 82,
            "x_max": 471,
            "y_min": 0,
            "y_max": 498,
            "ha": 498,
            "leftSideBearing": 82,
            "advanceWidth": 547
        },
        "o": {
            "x_min": 46,
            "x_max": 496,
            "y_min": -12,
            "y_max": 498,
            "ha": 510,
            "leftSideBearing": 46,
            "advanceWidth": 542
        },
        "p": {
            "x_min": 82,
            "x_max": 507,
            "y_min": -205,
            "y_max": 498,
            "ha": 703,
            "leftSideBearing": 82,
            "advanceWidth": 555
        },
        "q": {
            "x_min": 47,
            "x_max": 473,
            "y_min": -205,
            "y_max": 498,
            "ha": 703,
            "leftSideBearing": 47,
            "advanceWidth": 555
        },
        "r": {
            "x_min": 82,
            "x_max": 350,
            "y_min": 0,
            "y_max": 498,
            "ha": 498,
            "leftSideBearing": 82,
            "advanceWidth": 347
        },
        "s": {
            "x_min": 28,
            "x_max": 387,
            "y_min": -12,
            "y_max": 498,
            "ha": 510,
            "leftSideBearing": 28,
            "advanceWidth": 419
        },
        "t": {
            "x_min": 24,
            "x_max": 325,
            "y_min": -12,
            "y_max": 622,
            "ha": 634,
            "leftSideBearing": 24,
            "advanceWidth": 338
        },
        "u": {
            "x_min": 75,
            "x_max": 462,
            "y_min": -12,
            "y_max": 486,
            "ha": 498,
            "leftSideBearing": 75,
            "advanceWidth": 544
        },
        "v": {
            "x_min": 12,
            "x_max": 455,
            "y_min": 0,
            "y_max": 486,
            "ha": 486,
            "leftSideBearing": 12,
            "advanceWidth": 467
        },
        "w": {
            "x_min": 24,
            "x_max": 694,
            "y_min": 0,
            "y_max": 486,
            "ha": 486,
            "leftSideBearing": 24,
            "advanceWidth": 718
        },
        "x": {
            "x_min": 14,
            "x_max": 432,
            "y_min": 0,
            "y_max": 486,
            "ha": 486,
            "leftSideBearing": 14,
            "advanceWidth": 446
        },
        "y": {
            "x_min": 12,
            "x_max": 455,
            "y_min": -209,
            "y_max": 486,
            "ha": 695,
            "leftSideBearing": 12,
            "advanceWidth": 467
        },
        "z": {
            "x_min": 31,
            "x_max": 399,
            "y_min": 0,
            "y_max": 486,
            "ha": 486,
            "leftSideBearing": 31,
            "advanceWidth": 425
        },
        "{": {
            "x_min": 34,
            "x_max": 273,
            "y_min": -152,
            "y_max": 708,
            "ha": 860,
            "leftSideBearing": 34,
            "advanceWidth": 303
        },
        "|": {
            "x_min": 92,
            "x_max": 150,
            "y_min": -250,
            "y_max": 750,
            "ha": 1000,
            "leftSideBearing": 92,
            "advanceWidth": 241
        },
        "}": {
            "x_min": 31,
            "x_max": 269,
            "y_min": -152,
            "y_max": 708,
            "ha": 860,
            "leftSideBearing": 31,
            "advanceWidth": 303
        },
        "~": {
            "x_min": 36,
            "x_max": 461,
            "y_min": 257,
            "y_max": 403,
            "ha": 146,
            "leftSideBearing": 36,
            "advanceWidth": 497
        }
    },
};


/***/ }),

/***/ "./src/styles/font_metrics/ssp-serif-metrics.js":
/*!******************************************************!*\
  !*** ./src/styles/font_metrics/ssp-serif-metrics.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SourceSerifProFont = void 0;
exports.SourceSerifProFont = {
    smufl: false,
    name: "Serif",
    spacing: 50,
    description: "Open-source Serif font from Adobe",
    serifs: true,
    monospaced: false,
    superscriptOffset: 0.66,
    subscriptOffset: 0.66,
    maxSizeGlyph: 'H',
    "fontFamily": "Source Serif Pro",
    "resolution": 1000,
    "glyphs": {
        "0": {
            "x_min": 41,
            "x_max": 460,
            "y_min": -13,
            "y_max": 659,
            "ha": 672,
            "leftSideBearing": 41,
            "advanceWidth": 500
        },
        "1": {
            "x_min": 74,
            "x_max": 445,
            "y_min": 0,
            "y_max": 654,
            "ha": 654,
            "leftSideBearing": 74,
            "advanceWidth": 500
        },
        "2": {
            "x_min": 44,
            "x_max": 460,
            "y_min": 0,
            "y_max": 659,
            "ha": 659,
            "leftSideBearing": 44,
            "advanceWidth": 500
        },
        "3": {
            "x_min": 44,
            "x_max": 460,
            "y_min": -13,
            "y_max": 659,
            "ha": 672,
            "leftSideBearing": 44,
            "advanceWidth": 500
        },
        "4": {
            "x_min": 24,
            "x_max": 484,
            "y_min": 0,
            "y_max": 655,
            "ha": 655,
            "leftSideBearing": 24,
            "advanceWidth": 500
        },
        "5": {
            "x_min": 38,
            "x_max": 458,
            "y_min": -13,
            "y_max": 646,
            "ha": 659,
            "leftSideBearing": 38,
            "advanceWidth": 500
        },
        "6": {
            "x_min": 40,
            "x_max": 457,
            "y_min": -13,
            "y_max": 659,
            "ha": 672,
            "leftSideBearing": 40,
            "advanceWidth": 500
        },
        "7": {
            "x_min": 51,
            "x_max": 464,
            "y_min": 0,
            "y_max": 646,
            "ha": 646,
            "leftSideBearing": 51,
            "advanceWidth": 500
        },
        "8": {
            "x_min": 44,
            "x_max": 455,
            "y_min": -13,
            "y_max": 659,
            "ha": 672,
            "leftSideBearing": 44,
            "advanceWidth": 500
        },
        "9": {
            "x_min": 29,
            "x_max": 450,
            "y_min": -20,
            "y_max": 659,
            "ha": 679,
            "leftSideBearing": 29,
            "advanceWidth": 500
        },
        " ": {
            "x_min": 0,
            "x_max": 0,
            "y_min": 0,
            "y_max": 0,
            "ha": 0,
            "leftSideBearing": 0,
            "advanceWidth": 233
        },
        "!": {
            "x_min": 80,
            "x_max": 209,
            "y_min": -13,
            "y_max": 684,
            "ha": 697,
            "leftSideBearing": 80,
            "advanceWidth": 289
        },
        "\"": {
            "x_min": 40,
            "x_max": 315,
            "y_min": 429,
            "y_max": 737,
            "ha": 308,
            "leftSideBearing": 40,
            "advanceWidth": 356
        },
        "#": {
            "x_min": 25,
            "x_max": 502,
            "y_min": 0,
            "y_max": 650,
            "ha": 650,
            "leftSideBearing": 25,
            "advanceWidth": 526
        },
        "$": {
            "x_min": 51,
            "x_max": 464,
            "y_min": -115,
            "y_max": 749,
            "ha": 864,
            "leftSideBearing": 51,
            "advanceWidth": 500
        },
        "%": {
            "x_min": 69,
            "x_max": 792,
            "y_min": -25,
            "y_max": 669,
            "ha": 694,
            "leftSideBearing": 69,
            "advanceWidth": 861
        },
        "&": {
            "x_min": 27,
            "x_max": 675,
            "y_min": -13,
            "y_max": 684,
            "ha": 697,
            "leftSideBearing": 27,
            "advanceWidth": 720
        },
        "'": {
            "x_min": 40,
            "x_max": 143,
            "y_min": 429,
            "y_max": 737,
            "ha": 308,
            "leftSideBearing": 40,
            "advanceWidth": 183
        },
        "(": {
            "x_min": 80,
            "x_max": 314,
            "y_min": -192,
            "y_max": 748,
            "ha": 940,
            "leftSideBearing": 80,
            "advanceWidth": 339
        },
        ")": {
            "x_min": 25,
            "x_max": 259,
            "y_min": -192,
            "y_max": 748,
            "ha": 940,
            "leftSideBearing": 25,
            "advanceWidth": 339
        },
        "*": {
            "x_min": 20,
            "x_max": 420,
            "y_min": 363,
            "y_max": 747,
            "ha": 384,
            "leftSideBearing": 20,
            "advanceWidth": 439
        },
        "+": {
            "x_min": 29,
            "x_max": 502,
            "y_min": 77,
            "y_max": 577,
            "ha": 500,
            "leftSideBearing": 29,
            "advanceWidth": 531
        },
        ",": {
            "x_min": 6,
            "x_max": 213,
            "y_min": -224,
            "y_max": 130,
            "ha": 354,
            "leftSideBearing": 6,
            "advanceWidth": 300
        },
        "-": {
            "x_min": 40,
            "x_max": 272,
            "y_min": 218,
            "y_max": 284,
            "ha": 66,
            "leftSideBearing": 40,
            "advanceWidth": 312
        },
        ".": {
            "x_min": 79,
            "x_max": 221,
            "y_min": -13,
            "y_max": 130,
            "ha": 143,
            "leftSideBearing": 79,
            "advanceWidth": 300
        },
        "/": {
            "x_min": 2,
            "x_max": 328,
            "y_min": -160,
            "y_max": 710,
            "ha": 870,
            "leftSideBearing": 2,
            "advanceWidth": 330
        },
        ":": {
            "x_min": 79,
            "x_max": 221,
            "y_min": -13,
            "y_max": 493,
            "ha": 506,
            "leftSideBearing": 79,
            "advanceWidth": 300
        },
        ";": {
            "x_min": 6,
            "x_max": 221,
            "y_min": -224,
            "y_max": 493,
            "ha": 717,
            "leftSideBearing": 6,
            "advanceWidth": 300
        },
        "<": {
            "x_min": 57,
            "x_max": 474,
            "y_min": 81,
            "y_max": 578,
            "ha": 497,
            "leftSideBearing": 57,
            "advanceWidth": 531
        },
        "=": {
            "x_min": 29,
            "x_max": 502,
            "y_min": 201,
            "y_max": 458,
            "ha": 257,
            "leftSideBearing": 29,
            "advanceWidth": 531
        },
        ">": {
            "x_min": 57,
            "x_max": 474,
            "y_min": 81,
            "y_max": 578,
            "ha": 497,
            "leftSideBearing": 57,
            "advanceWidth": 531
        },
        "?": {
            "x_min": 66,
            "x_max": 350,
            "y_min": -13,
            "y_max": 684,
            "ha": 697,
            "leftSideBearing": 66,
            "advanceWidth": 416
        },
        "@": {
            "x_min": 36,
            "x_max": 800,
            "y_min": -155,
            "y_max": 660,
            "ha": 815,
            "leftSideBearing": 36,
            "advanceWidth": 835
        },
        "A": {
            "x_min": 5,
            "x_max": 653,
            "y_min": 0,
            "y_max": 674,
            "ha": 674,
            "leftSideBearing": 5,
            "advanceWidth": 664
        },
        "B": {
            "x_min": 44,
            "x_max": 586,
            "y_min": 0,
            "y_max": 669,
            "ha": 669,
            "leftSideBearing": 44,
            "advanceWidth": 629
        },
        "C": {
            "x_min": 47,
            "x_max": 592,
            "y_min": -15,
            "y_max": 684,
            "ha": 699,
            "leftSideBearing": 47,
            "advanceWidth": 631
        },
        "D": {
            "x_min": 44,
            "x_max": 663,
            "y_min": 0,
            "y_max": 669,
            "ha": 669,
            "leftSideBearing": 44,
            "advanceWidth": 710
        },
        "E": {
            "x_min": 44,
            "x_max": 569,
            "y_min": 0,
            "y_max": 669,
            "ha": 669,
            "leftSideBearing": 44,
            "advanceWidth": 603
        },
        "F": {
            "x_min": 44,
            "x_max": 549,
            "y_min": 0,
            "y_max": 669,
            "ha": 669,
            "leftSideBearing": 44,
            "advanceWidth": 579
        },
        "G": {
            "x_min": 47,
            "x_max": 667,
            "y_min": -15,
            "y_max": 684,
            "ha": 699,
            "leftSideBearing": 47,
            "advanceWidth": 682
        },
        "H": {
            "x_min": 44,
            "x_max": 744,
            "y_min": 0,
            "y_max": 669,
            "ha": 669,
            "leftSideBearing": 44,
            "advanceWidth": 789
        },
        "I": {
            "x_min": 44,
            "x_max": 327,
            "y_min": 0,
            "y_max": 669,
            "ha": 669,
            "leftSideBearing": 44,
            "advanceWidth": 371
        },
        "J": {
            "x_min": -43,
            "x_max": 340,
            "y_min": -163,
            "y_max": 669,
            "ha": 832,
            "leftSideBearing": -43,
            "advanceWidth": 374
        },
        "K": {
            "x_min": 44,
            "x_max": 662,
            "y_min": 0,
            "y_max": 669,
            "ha": 669,
            "leftSideBearing": 44,
            "advanceWidth": 667
        },
        "L": {
            "x_min": 44,
            "x_max": 552,
            "y_min": 0,
            "y_max": 669,
            "ha": 669,
            "leftSideBearing": 44,
            "advanceWidth": 596
        },
        "M": {
            "x_min": 39,
            "x_max": 857,
            "y_min": 0,
            "y_max": 669,
            "ha": 669,
            "leftSideBearing": 39,
            "advanceWidth": 902
        },
        "N": {
            "x_min": 39,
            "x_max": 695,
            "y_min": -7,
            "y_max": 669,
            "ha": 676,
            "leftSideBearing": 39,
            "advanceWidth": 735
        },
        "O": {
            "x_min": 47,
            "x_max": 660,
            "y_min": -15,
            "y_max": 684,
            "ha": 699,
            "leftSideBearing": 47,
            "advanceWidth": 707
        },
        "P": {
            "x_min": 44,
            "x_max": 567,
            "y_min": 0,
            "y_max": 669,
            "ha": 669,
            "leftSideBearing": 44,
            "advanceWidth": 589
        },
        "Q": {
            "x_min": 47,
            "x_max": 660,
            "y_min": -216,
            "y_max": 684,
            "ha": 900,
            "leftSideBearing": 47,
            "advanceWidth": 707
        },
        "R": {
            "x_min": 44,
            "x_max": 637,
            "y_min": -10,
            "y_max": 669,
            "ha": 679,
            "leftSideBearing": 44,
            "advanceWidth": 651
        },
        "S": {
            "x_min": 40,
            "x_max": 472,
            "y_min": -15,
            "y_max": 684,
            "ha": 699,
            "leftSideBearing": 40,
            "advanceWidth": 512
        },
        "T": {
            "x_min": 20,
            "x_max": 584,
            "y_min": 0,
            "y_max": 669,
            "ha": 669,
            "leftSideBearing": 20,
            "advanceWidth": 604
        },
        "U": {
            "x_min": 39,
            "x_max": 693,
            "y_min": -15,
            "y_max": 669,
            "ha": 684,
            "leftSideBearing": 39,
            "advanceWidth": 727
        },
        "V": {
            "x_min": 15,
            "x_max": 665,
            "y_min": -7,
            "y_max": 669,
            "ha": 676,
            "leftSideBearing": 15,
            "advanceWidth": 674
        },
        "W": {
            "x_min": 15,
            "x_max": 953,
            "y_min": -7,
            "y_max": 669,
            "ha": 676,
            "leftSideBearing": 15,
            "advanceWidth": 962
        },
        "X": {
            "x_min": 10,
            "x_max": 639,
            "y_min": 0,
            "y_max": 669,
            "ha": 669,
            "leftSideBearing": 10,
            "advanceWidth": 648
        },
        "Y": {
            "x_min": 15,
            "x_max": 623,
            "y_min": 0,
            "y_max": 669,
            "ha": 669,
            "leftSideBearing": 15,
            "advanceWidth": 633
        },
        "Z": {
            "x_min": 20,
            "x_max": 531,
            "y_min": 0,
            "y_max": 669,
            "ha": 669,
            "leftSideBearing": 20,
            "advanceWidth": 551
        },
        "[": {
            "x_min": 100,
            "x_max": 291,
            "y_min": -159,
            "y_max": 715,
            "ha": 874,
            "leftSideBearing": 100,
            "advanceWidth": 320
        },
        "\\": {
            "x_min": 2,
            "x_max": 328,
            "y_min": -160,
            "y_max": 710,
            "ha": 870,
            "leftSideBearing": 2,
            "advanceWidth": 330
        },
        "]": {
            "x_min": 29,
            "x_max": 220,
            "y_min": -159,
            "y_max": 715,
            "ha": 874,
            "leftSideBearing": 29,
            "advanceWidth": 320
        },
        "^": {
            "x_min": 88,
            "x_max": 446,
            "y_min": 208,
            "y_max": 481,
            "ha": 273,
            "leftSideBearing": 88,
            "advanceWidth": 531
        },
        "_": {
            "x_min": 40,
            "x_max": 472,
            "y_min": -66,
            "y_max": 0,
            "ha": 66,
            "leftSideBearing": 40,
            "advanceWidth": 512
        },
        "`": {
            "x_min": 75,
            "x_max": 256,
            "y_min": 557,
            "y_max": 758,
            "ha": 201,
            "leftSideBearing": 75,
            "advanceWidth": 400
        },
        "a": {
            "x_min": 45,
            "x_max": 503,
            "y_min": -13,
            "y_max": 488,
            "ha": 501,
            "leftSideBearing": 45,
            "advanceWidth": 509
        },
        "b": {
            "x_min": 25,
            "x_max": 532,
            "y_min": -13,
            "y_max": 739,
            "ha": 752,
            "leftSideBearing": 25,
            "advanceWidth": 577
        },
        "c": {
            "x_min": 42,
            "x_max": 453,
            "y_min": -13,
            "y_max": 488,
            "ha": 501,
            "leftSideBearing": 42,
            "advanceWidth": 488
        },
        "d": {
            "x_min": 45,
            "x_max": 551,
            "y_min": -13,
            "y_max": 739,
            "ha": 752,
            "leftSideBearing": 45,
            "advanceWidth": 567
        },
        "e": {
            "x_min": 45,
            "x_max": 461,
            "y_min": -13,
            "y_max": 488,
            "ha": 501,
            "leftSideBearing": 45,
            "advanceWidth": 510
        },
        "f": {
            "x_min": 34,
            "x_max": 426,
            "y_min": 0,
            "y_max": 749,
            "ha": 749,
            "leftSideBearing": 34,
            "advanceWidth": 354
        },
        "g": {
            "x_min": 36,
            "x_max": 495,
            "y_min": -239,
            "y_max": 488,
            "ha": 727,
            "leftSideBearing": 36,
            "advanceWidth": 518
        },
        "h": {
            "x_min": 25,
            "x_max": 571,
            "y_min": 0,
            "y_max": 739,
            "ha": 739,
            "leftSideBearing": 25,
            "advanceWidth": 601
        },
        "i": {
            "x_min": 29,
            "x_max": 267,
            "y_min": 0,
            "y_max": 726,
            "ha": 726,
            "leftSideBearing": 29,
            "advanceWidth": 298
        },
        "j": {
            "x_min": -83,
            "x_max": 220,
            "y_min": -249,
            "y_max": 726,
            "ha": 975,
            "leftSideBearing": -83,
            "advanceWidth": 277
        },
        "k": {
            "x_min": 25,
            "x_max": 547,
            "y_min": 0,
            "y_max": 739,
            "ha": 739,
            "leftSideBearing": 25,
            "advanceWidth": 547
        },
        "l": {
            "x_min": 25,
            "x_max": 273,
            "y_min": 0,
            "y_max": 739,
            "ha": 739,
            "leftSideBearing": 25,
            "advanceWidth": 298
        },
        "m": {
            "x_min": 34,
            "x_max": 872,
            "y_min": 0,
            "y_max": 488,
            "ha": 488,
            "leftSideBearing": 34,
            "advanceWidth": 901
        },
        "n": {
            "x_min": 34,
            "x_max": 576,
            "y_min": 0,
            "y_max": 488,
            "ha": 488,
            "leftSideBearing": 34,
            "advanceWidth": 606
        },
        "o": {
            "x_min": 45,
            "x_max": 504,
            "y_min": -13,
            "y_max": 488,
            "ha": 501,
            "leftSideBearing": 45,
            "advanceWidth": 549
        },
        "p": {
            "x_min": 35,
            "x_max": 538,
            "y_min": -239,
            "y_max": 488,
            "ha": 727,
            "leftSideBearing": 35,
            "advanceWidth": 583
        },
        "q": {
            "x_min": 45,
            "x_max": 556,
            "y_min": -239,
            "y_max": 488,
            "ha": 727,
            "leftSideBearing": 45,
            "advanceWidth": 557
        },
        "r": {
            "x_min": 34,
            "x_max": 416,
            "y_min": 0,
            "y_max": 488,
            "ha": 488,
            "leftSideBearing": 34,
            "advanceWidth": 423
        },
        "s": {
            "x_min": 47,
            "x_max": 395,
            "y_min": -13,
            "y_max": 488,
            "ha": 501,
            "leftSideBearing": 47,
            "advanceWidth": 434
        },
        "t": {
            "x_min": 9,
            "x_max": 323,
            "y_min": -13,
            "y_max": 611,
            "ha": 624,
            "leftSideBearing": 9,
            "advanceWidth": 325
        },
        "u": {
            "x_min": 25,
            "x_max": 549,
            "y_min": -13,
            "y_max": 481,
            "ha": 494,
            "leftSideBearing": 25,
            "advanceWidth": 583
        },
        "v": {
            "x_min": 0,
            "x_max": 496,
            "y_min": -6,
            "y_max": 475,
            "ha": 481,
            "leftSideBearing": 0,
            "advanceWidth": 505
        },
        "w": {
            "x_min": 0,
            "x_max": 754,
            "y_min": -6,
            "y_max": 475,
            "ha": 481,
            "leftSideBearing": 0,
            "advanceWidth": 764
        },
        "x": {
            "x_min": 10,
            "x_max": 516,
            "y_min": 0,
            "y_max": 475,
            "ha": 475,
            "leftSideBearing": 10,
            "advanceWidth": 526
        },
        "y": {
            "x_min": 0,
            "x_max": 512,
            "y_min": -249,
            "y_max": 475,
            "ha": 724,
            "leftSideBearing": 0,
            "advanceWidth": 512
        },
        "z": {
            "x_min": 29,
            "x_max": 431,
            "y_min": 0,
            "y_max": 475,
            "ha": 475,
            "leftSideBearing": 29,
            "advanceWidth": 456
        },
        "{": {
            "x_min": 40,
            "x_max": 314,
            "y_min": -159,
            "y_max": 715,
            "ha": 874,
            "leftSideBearing": 40,
            "advanceWidth": 344
        },
        "|": {
            "x_min": 96,
            "x_max": 155,
            "y_min": -250,
            "y_max": 750,
            "ha": 1000,
            "leftSideBearing": 96,
            "advanceWidth": 251
        },
        "}": {
            "x_min": 30,
            "x_max": 304,
            "y_min": -159,
            "y_max": 715,
            "ha": 874,
            "leftSideBearing": 30,
            "advanceWidth": 344
        },
        "~": {
            "x_min": 49,
            "x_max": 482,
            "y_min": 268,
            "y_max": 422,
            "ha": 154,
            "leftSideBearing": 49,
            "advanceWidth": 531
        }
    },
    "generatedOn": "2020-11-01T21:35:39.674Z"
};


/***/ }),

/***/ "./src/styles/font_metrics/times_metrics.js":
/*!**************************************************!*\
  !*** ./src/styles/font_metrics/times_metrics.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TimesFont = void 0;
exports.TimesFont = {
    smufl: false,
    name: "Times New Roman",
    spacing: 50,
    Description: 'Built-in serif font',
    bold: true,
    italic: true,
    monospaced: false,
    serifs: true,
    "glyphs": {
        "0": {
            "x_min": 49,
            "x_max": 975,
            "y_min": -27,
            "y_max": 1383,
            "ha": 1410,
            "leftSideBearing": 49,
            "advanceWidth": 1024
        },
        "1": {
            "x_min": 227,
            "x_max": 811,
            "y_min": 0,
            "y_max": 1383,
            "ha": 1383,
            "leftSideBearing": 227,
            "advanceWidth": 1024
        },
        "2": {
            "x_min": 61,
            "x_max": 965,
            "y_min": 0,
            "y_max": 1383,
            "ha": 1383,
            "leftSideBearing": 61,
            "advanceWidth": 1024
        },
        "3": {
            "x_min": 88,
            "x_max": 883,
            "y_min": -27,
            "y_max": 1383,
            "ha": 1410,
            "leftSideBearing": 88,
            "advanceWidth": 1024
        },
        "4": {
            "x_min": 25,
            "x_max": 967,
            "y_min": 0,
            "y_max": 1384,
            "ha": 1384,
            "leftSideBearing": 25,
            "advanceWidth": 1024
        },
        "5": {
            "x_min": 66,
            "x_max": 898,
            "y_min": -27,
            "y_max": 1409,
            "ha": 1436,
            "leftSideBearing": 66,
            "advanceWidth": 1024
        },
        "6": {
            "x_min": 70,
            "x_max": 958,
            "y_min": -27,
            "y_max": 1401,
            "ha": 1428,
            "leftSideBearing": 70,
            "advanceWidth": 1024
        },
        "7": {
            "x_min": 41,
            "x_max": 920,
            "y_min": -16,
            "y_max": 1356,
            "ha": 1372,
            "leftSideBearing": 41,
            "advanceWidth": 1024
        },
        "8": {
            "x_min": 115,
            "x_max": 911,
            "y_min": -27,
            "y_max": 1383,
            "ha": 1410,
            "leftSideBearing": 115,
            "advanceWidth": 1024
        },
        "9": {
            "x_min": 61,
            "x_max": 940,
            "y_min": -41,
            "y_max": 1383,
            "ha": 1424,
            "leftSideBearing": 61,
            "advanceWidth": 1024
        },
        " ": {
            "x_min": 0,
            "x_max": 0,
            "y_min": 0,
            "y_max": 0,
            "ha": 0,
            "leftSideBearing": 0,
            "advanceWidth": 512
        },
        "!": {
            "x_min": 266,
            "x_max": 488,
            "y_min": -22,
            "y_max": 1383,
            "ha": 1405,
            "leftSideBearing": 266,
            "advanceWidth": 682
        },
        "\"": {
            "x_min": 157.2000021972655,
            "x_max": 678.2500021457677,
            "y_min": 881,
            "y_max": 1385,
            "ha": 504,
            "leftSideBearing": 157,
            "advanceWidth": 836
        },
        "#": {
            "x_min": 10,
            "x_max": 1016,
            "y_min": -1,
            "y_max": 1356,
            "ha": 1357,
            "leftSideBearing": 10,
            "advanceWidth": 1024
        },
        "$": {
            "x_min": 90,
            "x_max": 936,
            "y_min": -180,
            "y_max": 1492,
            "ha": 1672,
            "leftSideBearing": 90,
            "advanceWidth": 1024
        },
        "%": {
            "x_min": 125,
            "x_max": 1581,
            "y_min": -30,
            "y_max": 1388,
            "ha": 1418,
            "leftSideBearing": 125,
            "advanceWidth": 1706
        },
        "&": {
            "x_min": 86,
            "x_max": 1536,
            "y_min": -28,
            "y_max": 1383,
            "ha": 1411,
            "leftSideBearing": 86,
            "advanceWidth": 1593
        },
        "'": {
            "x_min": 97.20000219726548,
            "x_max": 273.2500021457677,
            "y_min": 881,
            "y_max": 1385,
            "ha": 504,
            "leftSideBearing": 97,
            "advanceWidth": 369
        },
        "(": {
            "x_min": 98,
            "x_max": 623,
            "y_min": -363,
            "y_max": 1383,
            "ha": 1746,
            "leftSideBearing": 98,
            "advanceWidth": 682
        },
        ")": {
            "x_min": 59,
            "x_max": 584,
            "y_min": -363,
            "y_max": 1383,
            "ha": 1746,
            "leftSideBearing": 59,
            "advanceWidth": 682
        },
        "*": {
            "x_min": 137.96078522291893,
            "x_max": 886.039214777081,
            "y_min": 543,
            "y_max": 1383,
            "ha": 840,
            "leftSideBearing": 137,
            "advanceWidth": 1024
        },
        "+": {
            "x_min": 61,
            "x_max": 1093,
            "y_min": 2,
            "y_max": 1034,
            "ha": 1032,
            "leftSideBearing": 61,
            "advanceWidth": 1155
        },
        ",": {
            "x_min": 115,
            "x_max": 399,
            "y_min": -291,
            "y_max": 208,
            "ha": 499,
            "leftSideBearing": 115,
            "advanceWidth": 512
        },
        "-": {
            "x_min": 80,
            "x_max": 584,
            "y_min": 396,
            "y_max": 525,
            "ha": 129,
            "leftSideBearing": 80,
            "advanceWidth": 682
        },
        ".": {
            "x_min": 143,
            "x_max": 371,
            "y_min": -22,
            "y_max": 205,
            "ha": 227,
            "leftSideBearing": 143,
            "advanceWidth": 512
        },
        "/": {
            "x_min": -17,
            "x_max": 586,
            "y_min": -27,
            "y_max": 1383,
            "ha": 1410,
            "leftSideBearing": -17,
            "advanceWidth": 569
        },
        ":": {
            "x_min": 166,
            "x_max": 394,
            "y_min": -22,
            "y_max": 943,
            "ha": 965,
            "leftSideBearing": 166,
            "advanceWidth": 569
        },
        ";": {
            "x_min": 164,
            "x_max": 448,
            "y_min": -290,
            "y_max": 943,
            "ha": 1233,
            "leftSideBearing": 164,
            "advanceWidth": 569
        },
        "<": {
            "x_min": 57,
            "x_max": 1098,
            "y_min": -15,
            "y_max": 1051,
            "ha": 1066,
            "leftSideBearing": 57,
            "advanceWidth": 1155
        },
        "=": {
            "x_min": 61,
            "x_max": 1093,
            "y_min": 246,
            "y_max": 791,
            "ha": 545,
            "leftSideBearing": 61,
            "advanceWidth": 1155
        },
        ">": {
            "x_min": 57,
            "x_max": 1098,
            "y_min": -15,
            "y_max": 1051,
            "ha": 1066,
            "leftSideBearing": 57,
            "advanceWidth": 1155
        },
        "?": {
            "x_min": 139,
            "x_max": 848,
            "y_min": -15,
            "y_max": 1383,
            "ha": 1398,
            "leftSideBearing": 139,
            "advanceWidth": 909
        },
        "@": {
            "x_min": 238,
            "x_max": 1657,
            "y_min": -29,
            "y_max": 1386,
            "ha": 1415,
            "leftSideBearing": 238,
            "advanceWidth": 1886
        },
        "A": {
            "x_min": 31,
            "x_max": 1445,
            "y_min": 0,
            "y_max": 1380,
            "ha": 1380,
            "leftSideBearing": 31,
            "advanceWidth": 1479
        },
        "B": {
            "x_min": 35,
            "x_max": 1214,
            "y_min": 0,
            "y_max": 1356,
            "ha": 1356,
            "leftSideBearing": 35,
            "advanceWidth": 1366
        },
        "C": {
            "x_min": 57,
            "x_max": 1296,
            "y_min": -28,
            "y_max": 1383,
            "ha": 1411,
            "leftSideBearing": 57,
            "advanceWidth": 1366
        },
        "D": {
            "x_min": 33,
            "x_max": 1403,
            "y_min": 0,
            "y_max": 1356,
            "ha": 1356,
            "leftSideBearing": 33,
            "advanceWidth": 1479
        },
        "E": {
            "x_min": 25,
            "x_max": 1222,
            "y_min": 0,
            "y_max": 1356,
            "ha": 1356,
            "leftSideBearing": 25,
            "advanceWidth": 1251
        },
        "F": {
            "x_min": 25,
            "x_max": 1119,
            "y_min": 0,
            "y_max": 1356,
            "ha": 1356,
            "leftSideBearing": 25,
            "advanceWidth": 1139
        },
        "G": {
            "x_min": 66,
            "x_max": 1452,
            "y_min": -28,
            "y_max": 1383,
            "ha": 1411,
            "leftSideBearing": 66,
            "advanceWidth": 1479
        },
        "H": {
            "x_min": 39,
            "x_max": 1438,
            "y_min": 0,
            "y_max": 1356,
            "ha": 1356,
            "leftSideBearing": 39,
            "advanceWidth": 1479
        },
        "I": {
            "x_min": 37,
            "x_max": 642,
            "y_min": 0,
            "y_max": 1356,
            "ha": 1356,
            "leftSideBearing": 37,
            "advanceWidth": 682
        },
        "J": {
            "x_min": 20,
            "x_max": 758,
            "y_min": -28,
            "y_max": 1356,
            "ha": 1384,
            "leftSideBearing": 20,
            "advanceWidth": 797
        },
        "K": {
            "x_min": 70,
            "x_max": 1479,
            "y_min": 0,
            "y_max": 1356,
            "ha": 1356,
            "leftSideBearing": 70,
            "advanceWidth": 1479
        },
        "L": {
            "x_min": 25,
            "x_max": 1224,
            "y_min": 0,
            "y_max": 1356,
            "ha": 1356,
            "leftSideBearing": 25,
            "advanceWidth": 1251
        },
        "M": {
            "x_min": 25,
            "x_max": 1768,
            "y_min": 0,
            "y_max": 1356,
            "ha": 1356,
            "leftSideBearing": 25,
            "advanceWidth": 1821
        },
        "N": {
            "x_min": 25,
            "x_max": 1450,
            "y_min": -22,
            "y_max": 1356,
            "ha": 1378,
            "leftSideBearing": 25,
            "advanceWidth": 1479
        },
        "O": {
            "x_min": 70,
            "x_max": 1409,
            "y_min": -28,
            "y_max": 1383,
            "ha": 1411,
            "leftSideBearing": 70,
            "advanceWidth": 1479
        },
        "P": {
            "x_min": 33,
            "x_max": 1110,
            "y_min": 0,
            "y_max": 1356,
            "ha": 1356,
            "leftSideBearing": 33,
            "advanceWidth": 1139
        },
        "Q": {
            "x_min": 70,
            "x_max": 1435,
            "y_min": -364.28571588721996,
            "y_max": 1383,
            "ha": 1747.28571588722,
            "leftSideBearing": 70,
            "advanceWidth": 1479
        },
        "R": {
            "x_min": 35,
            "x_max": 1347,
            "y_min": 0,
            "y_max": 1356,
            "ha": 1356,
            "leftSideBearing": 35,
            "advanceWidth": 1366
        },
        "S": {
            "x_min": 86,
            "x_max": 1006,
            "y_min": -28,
            "y_max": 1383,
            "ha": 1411,
            "leftSideBearing": 86,
            "advanceWidth": 1139
        },
        "T": {
            "x_min": 35,
            "x_max": 1214,
            "y_min": 0,
            "y_max": 1356,
            "ha": 1356,
            "leftSideBearing": 35,
            "advanceWidth": 1251
        },
        "U": {
            "x_min": 29,
            "x_max": 1444,
            "y_min": -28,
            "y_max": 1356,
            "ha": 1384,
            "leftSideBearing": 29,
            "advanceWidth": 1479
        },
        "V": {
            "x_min": 33,
            "x_max": 1428,
            "y_min": -22,
            "y_max": 1356,
            "ha": 1378,
            "leftSideBearing": 33,
            "advanceWidth": 1479
        },
        "W": {
            "x_min": 10,
            "x_max": 1906,
            "y_min": -22,
            "y_max": 1356,
            "ha": 1378,
            "leftSideBearing": 10,
            "advanceWidth": 1933
        },
        "X": {
            "x_min": 20,
            "x_max": 1449,
            "y_min": 0,
            "y_max": 1356,
            "ha": 1356,
            "leftSideBearing": 20,
            "advanceWidth": 1479
        },
        "Y": {
            "x_min": 45,
            "x_max": 1441,
            "y_min": 0,
            "y_max": 1356,
            "ha": 1356,
            "leftSideBearing": 45,
            "advanceWidth": 1479
        },
        "Z": {
            "x_min": 18,
            "x_max": 1222,
            "y_min": 0,
            "y_max": 1356,
            "ha": 1356,
            "leftSideBearing": 18,
            "advanceWidth": 1251
        },
        "[": {
            "x_min": 180,
            "x_max": 612,
            "y_min": -319,
            "y_max": 1355,
            "ha": 1674,
            "leftSideBearing": 180,
            "advanceWidth": 682
        },
        "\\": {
            "x_min": -17,
            "x_max": 586,
            "y_min": -27,
            "y_max": 1383,
            "ha": 1410,
            "leftSideBearing": -17,
            "advanceWidth": 569
        },
        "]": {
            "x_min": 70,
            "x_max": 502,
            "y_min": -319,
            "y_max": 1355,
            "ha": 1674,
            "leftSideBearing": 70,
            "advanceWidth": 682
        },
        "^": {
            "x_min": 49,
            "x_max": 914,
            "y_min": 608,
            "y_max": 1355,
            "ha": 747,
            "leftSideBearing": 49,
            "advanceWidth": 961
        },
        "_": {
            "x_min": 0,
            "x_max": 1024,
            "y_min": -255,
            "y_max": -153,
            "ha": 102,
            "leftSideBearing": 0,
            "advanceWidth": 1024
        },
        "`": {
            "x_min": 39,
            "x_max": 499,
            "y_min": 1037,
            "y_max": 1392.509803639748,
            "ha": 355.50980363974804,
            "leftSideBearing": 39,
            "advanceWidth": 682
        },
        "a": {
            "x_min": 76,
            "x_max": 905,
            "y_min": -20,
            "y_max": 942,
            "ha": 962,
            "leftSideBearing": 76,
            "advanceWidth": 909
        },
        "b": {
            "x_min": 6,
            "x_max": 958,
            "y_min": -20,
            "y_max": 1399,
            "ha": 1419,
            "leftSideBearing": 6,
            "advanceWidth": 1024
        },
        "c": {
            "x_min": 51,
            "x_max": 843,
            "y_min": -20,
            "y_max": 942,
            "ha": 962,
            "leftSideBearing": 51,
            "advanceWidth": 909
        },
        "d": {
            "x_min": 55,
            "x_max": 1006,
            "y_min": -20,
            "y_max": 1399,
            "ha": 1419,
            "leftSideBearing": 55,
            "advanceWidth": 1024
        },
        "e": {
            "x_min": 51,
            "x_max": 868,
            "y_min": -20,
            "y_max": 942,
            "ha": 962,
            "leftSideBearing": 51,
            "advanceWidth": 909
        },
        "f": {
            "x_min": 41,
            "x_max": 783,
            "y_min": 0,
            "y_max": 1399,
            "ha": 1399,
            "leftSideBearing": 41,
            "advanceWidth": 682
        },
        "g": {
            "x_min": 57,
            "x_max": 963,
            "y_min": -446,
            "y_max": 942,
            "ha": 1388,
            "leftSideBearing": 57,
            "advanceWidth": 1024
        },
        "h": {
            "x_min": 18,
            "x_max": 997,
            "y_min": 0,
            "y_max": 1399,
            "ha": 1399,
            "leftSideBearing": 18,
            "advanceWidth": 1024
        },
        "i": {
            "x_min": 33,
            "x_max": 516,
            "y_min": 0,
            "y_max": 1399,
            "ha": 1399,
            "leftSideBearing": 33,
            "advanceWidth": 569
        },
        "j": {
            "x_min": -142,
            "x_max": 397,
            "y_min": -446,
            "y_max": 1399,
            "ha": 1845,
            "leftSideBearing": -142,
            "advanceWidth": 569
        },
        "k": {
            "x_min": 14,
            "x_max": 1029,
            "y_min": 0,
            "y_max": 1399,
            "ha": 1399,
            "leftSideBearing": 14,
            "advanceWidth": 1024
        },
        "l": {
            "x_min": 39,
            "x_max": 523,
            "y_min": 0,
            "y_max": 1399,
            "ha": 1399,
            "leftSideBearing": 39,
            "advanceWidth": 569
        },
        "m": {
            "x_min": 33,
            "x_max": 1587,
            "y_min": 0,
            "y_max": 944,
            "ha": 944,
            "leftSideBearing": 33,
            "advanceWidth": 1593
        },
        "n": {
            "x_min": 33,
            "x_max": 993,
            "y_min": 0,
            "y_max": 944,
            "ha": 944,
            "leftSideBearing": 33,
            "advanceWidth": 1024
        },
        "o": {
            "x_min": 59,
            "x_max": 963,
            "y_min": -20,
            "y_max": 942,
            "ha": 962,
            "leftSideBearing": 59,
            "advanceWidth": 1024
        },
        "p": {
            "x_min": 10,
            "x_max": 964,
            "y_min": -443,
            "y_max": 944,
            "ha": 1387,
            "leftSideBearing": 10,
            "advanceWidth": 1024
        },
        "q": {
            "x_min": 49,
            "x_max": 999,
            "y_min": -443,
            "y_max": 942.0135137169275,
            "ha": 1385.0135137169275,
            "leftSideBearing": 49,
            "advanceWidth": 1024
        },
        "r": {
            "x_min": 10,
            "x_max": 685,
            "y_min": 0,
            "y_max": 944,
            "ha": 944,
            "leftSideBearing": 10,
            "advanceWidth": 682
        },
        "s": {
            "x_min": 104,
            "x_max": 713,
            "y_min": -20,
            "y_max": 942.0263161804552,
            "ha": 962.0263161804552,
            "leftSideBearing": 104,
            "advanceWidth": 797
        },
        "t": {
            "x_min": 27,
            "x_max": 572,
            "y_min": -18,
            "y_max": 1186,
            "ha": 1204,
            "leftSideBearing": 27,
            "advanceWidth": 569
        },
        "u": {
            "x_min": 18,
            "x_max": 981,
            "y_min": -21,
            "y_max": 921,
            "ha": 942,
            "leftSideBearing": 18,
            "advanceWidth": 1024
        },
        "v": {
            "x_min": 39,
            "x_max": 976,
            "y_min": -28,
            "y_max": 921,
            "ha": 949,
            "leftSideBearing": 39,
            "advanceWidth": 1024
        },
        "w": {
            "x_min": 43,
            "x_max": 1423,
            "y_min": -28,
            "y_max": 921,
            "ha": 949,
            "leftSideBearing": 43,
            "advanceWidth": 1479
        },
        "x": {
            "x_min": 35,
            "x_max": 989,
            "y_min": 0,
            "y_max": 921,
            "ha": 921,
            "leftSideBearing": 35,
            "advanceWidth": 1024
        },
        "y": {
            "x_min": 29,
            "x_max": 976,
            "y_min": -445,
            "y_max": 921,
            "ha": 1366,
            "leftSideBearing": 29,
            "advanceWidth": 1024
        },
        "z": {
            "x_min": 55,
            "x_max": 855,
            "y_min": 0,
            "y_max": 921,
            "ha": 921,
            "leftSideBearing": 55,
            "advanceWidth": 909
        },
        "{": {
            "x_min": 205,
            "x_max": 717,
            "y_min": -377,
            "y_max": 1397,
            "ha": 1774,
            "leftSideBearing": 205,
            "advanceWidth": 983
        },
        "|": {
            "x_min": 137,
            "x_max": 273,
            "y_min": -512,
            "y_max": 1535,
            "ha": 2047,
            "leftSideBearing": 137,
            "advanceWidth": 410
        },
        "}": {
            "x_min": 266,
            "x_max": 778,
            "y_min": -377,
            "y_max": 1397,
            "ha": 1774,
            "leftSideBearing": 266,
            "advanceWidth": 983
        },
        "~": {
            "x_min": 82,
            "x_max": 1028,
            "y_min": 380,
            "y_max": 666,
            "ha": 286,
            "leftSideBearing": 82,
            "advanceWidth": 1108
        }
    },
    "fontFamily": "Times",
    "resolution": 2048,
    "generatedOn": "2020-10-18T19:03:12.514Z"
};


/***/ }),

/***/ "./src/ui/buttons/articulation.ts":
/*!****************************************!*\
  !*** ./src/ui/buttons/articulation.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ArticulationButtons = void 0;
const button_1 = __webpack_require__(/*! ./button */ "./src/ui/buttons/button.ts");
const noteModifiers_1 = __webpack_require__(/*! ../../smo/data/noteModifiers */ "./src/smo/data/noteModifiers.ts");
class ArticulationButtons extends button_1.SuiButton {
    constructor(parameters) {
        super(parameters);
        this.showState = false;
        this.articulation = ArticulationButtons.articulationIdMap[this.buttonData.id];
        this.ctor = ArticulationButtons.constructors[this.buttonData.id];
    }
    static get articulationIdMap() {
        return {
            accentButton: noteModifiers_1.SmoArticulation.articulations.accent,
            tenutoButton: noteModifiers_1.SmoArticulation.articulations.tenuto,
            staccatoButton: noteModifiers_1.SmoArticulation.articulations.staccato,
            marcatoButton: noteModifiers_1.SmoArticulation.articulations.marcato,
            pizzicatoButton: noteModifiers_1.SmoArticulation.articulations.pizzicato,
            fermataButton: noteModifiers_1.SmoArticulation.articulations.fermata,
            mordentButton: noteModifiers_1.SmoOrnament.ornaments.mordent,
            mordentInvertedButton: noteModifiers_1.SmoOrnament.ornaments.mordentInverted,
            trillButton: noteModifiers_1.SmoOrnament.ornaments.trill,
            scoopButton: noteModifiers_1.SmoOrnament.ornaments.scoop,
            dropButton: noteModifiers_1.SmoOrnament.ornaments.fall_short,
            dropLongButton: noteModifiers_1.SmoOrnament.ornaments.dropLong,
            doitButton: noteModifiers_1.SmoOrnament.ornaments.doit,
            doitLongButton: noteModifiers_1.SmoOrnament.ornaments.doitLong,
            flipButton: noteModifiers_1.SmoOrnament.ornaments.flip,
            smearButton: noteModifiers_1.SmoOrnament.ornaments.smear
        };
    }
    static get constructors() {
        return {
            accentButton: 'SmoArticulation',
            tenutoButton: 'SmoArticulation',
            staccatoButton: 'SmoArticulation',
            marcatoButton: 'SmoArticulation',
            pizzicatoButton: 'SmoArticulation',
            fermataButton: 'SmoArticulation',
            mordentButton: 'SmoOrnament',
            mordentInvertedButton: 'SmoOrnament',
            trillButton: 'SmoOrnament',
            scoopButton: 'SmoOrnament',
            dropButton: 'SmoOrnament',
            dropLongButton: 'SmoOrnament',
            doitButton: 'SmoOrnament',
            doitLongButton: 'SmoOrnament',
            flipButton: 'SmoOrnament',
            smearButton: 'SmoOrnament'
        };
    }
    _toggleArticulation() {
        this.showState = !this.showState;
        this.view.toggleArticulation(this.articulation, this.ctor);
    }
    bind() {
        this.eventSource.domClick(this.buttonElement, this, '_toggleArticulation', null);
    }
}
exports.ArticulationButtons = ArticulationButtons;


/***/ }),

/***/ "./src/ui/buttons/beam.ts":
/*!********************************!*\
  !*** ./src/ui/buttons/beam.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BeamButtons = void 0;
const button_1 = __webpack_require__(/*! ./button */ "./src/ui/buttons/button.ts");
class BeamButtons extends button_1.SuiButton {
    constructor(parameters) {
        super(parameters);
    }
    operation() {
        if (this.buttonData.id === 'breakBeam') {
            this.view.toggleBeamGroup();
        }
        else if (this.buttonData.id === 'beamSelections') {
            this.view.beamSelections();
        }
        else if (this.buttonData.id === 'toggleBeamDirection') {
            this.view.toggleBeamDirection();
        }
    }
    bind() {
        $(this.buttonElement).off('click').on('click', () => {
            this.operation();
        });
    }
}
exports.BeamButtons = BeamButtons;


/***/ }),

/***/ "./src/ui/buttons/button.ts":
/*!**********************************!*\
  !*** ./src/ui/buttons/button.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SuiButton = void 0;
class SuiButton {
    constructor(params) {
        this.buttonId = params.buttonId;
        this.buttonElement = params.buttonElement;
        this.view = params.view;
        this.buttonData = params.buttonData;
        this.eventSource = params.eventSource;
        this.menus = params.menus;
        this.completeNotifier = params.completeNotifier;
    }
}
exports.SuiButton = SuiButton;


/***/ }),

/***/ "./src/ui/buttons/chord.ts":
/*!*********************************!*\
  !*** ./src/ui/buttons/chord.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ChordButtons = void 0;
const button_1 = __webpack_require__(/*! ./button */ "./src/ui/buttons/button.ts");
class ChordButtons extends button_1.SuiButton {
    constructor(parameters) {
        super(parameters);
        this.interval = parseInt($(this.buttonElement).attr('data-interval'), 10);
        this.direction = parseInt($(this.buttonElement).attr('data-direction'), 10);
    }
    collapseChord() {
        this.view.collapseChord();
    }
    setInterval() {
        this.view.setInterval(this.interval * this.direction);
    }
    bind() {
        $(this.buttonElement).off('click').on('click', () => {
            if ($(this.buttonElement).attr('id') === 'CollapseChordButton') {
                this.collapseChord();
                return;
            }
            this.setInterval();
        });
    }
}
exports.ChordButtons = ChordButtons;


/***/ }),

/***/ "./src/ui/buttons/collapsable.ts":
/*!***************************************!*\
  !*** ./src/ui/buttons/collapsable.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ExtendedCollapseParent = exports.CollapseRibbonControl = exports.buttonIsBindable = exports.buttonIsCollapsible = void 0;
const button_1 = __webpack_require__(/*! ./button */ "./src/ui/buttons/button.ts");
const serializationHelpers_1 = __webpack_require__(/*! ../../common/serializationHelpers */ "./src/common/serializationHelpers.js");
function buttonIsCollapsible(action) {
    return ['collapseChild', 'collapseChildMenu', 'collapseGrandchild', 'collapseMore'].indexOf(action) >= 0;
}
exports.buttonIsCollapsible = buttonIsCollapsible;
function buttonIsBindable(action) {
    return ['collapseChildMenu', 'menu', 'modal'].indexOf(action) >= 0;
}
exports.buttonIsBindable = buttonIsBindable;
class CollapseRibbonControl extends button_1.SuiButton {
    constructor(parameters) {
        super(parameters);
        serializationHelpers_1.smoSerialize.filteredMerge(CollapseRibbonControl.paramArray, parameters, this);
        this.childButtons = parameters.buttons.filter((cb) => cb.group === this.buttonData.group &&
            buttonIsCollapsible(cb.action));
    }
    static get paramArray() {
        return ['ribbonButtons', 'keyCommands', 'controller', 'view', 'menus', 'buttonData', 'buttonElement',
            'eventSource'];
    }
    _toggleExpand() {
        this.childButtons.forEach((cb) => {
            const el = $('#' + cb.id);
            $(el).toggleClass('collapsed');
            $(el).toggleClass('expanded');
        });
        $(this.buttonElement).closest('div').toggleClass('expanded');
        $(this.buttonElement).toggleClass('expandedChildren');
        if ($(this.buttonElement).hasClass('expandedChildren')) {
            const leftSpan = $(this.buttonElement).find('.ribbon-button-text');
            $(leftSpan).text('');
            $(leftSpan).removeClass(this.buttonData.icon);
            $(this.buttonElement).addClass('icon icon-circle-left');
        }
        else {
            $(this.buttonElement).removeClass('icon-circle-left');
            const leftSpan = $(this.buttonElement).find('.ribbon-button-text');
            $(leftSpan).addClass(this.buttonData.icon);
            $(leftSpan).text(this.buttonData.leftText);
        }
        // Expand may change music dom, redraw
        $('body').trigger('forceScrollEvent');
    }
    bind() {
        $(this.buttonElement).closest('div').addClass('collapseContainer');
        this.eventSource.domClick(this.buttonElement, this, '_toggleExpand', null);
        this.childButtons.forEach((cb) => {
            const ctor = eval('globalThis.Smo.' + cb.ctor);
            if ((typeof (ctor) === 'function') && this.completeNotifier) {
                const el = $('#' + cb.id);
                const params = {
                    ctor: cb.ctor,
                    buttonId: cb.id,
                    buttonData: cb,
                    buttonElement: el,
                    view: this.view,
                    completeNotifier: this.completeNotifier,
                    eventSource: this.eventSource,
                    menus: this.menus
                };
                const btn = new ctor(params);
                if (typeof (btn.bind) === 'function') {
                    btn.bind();
                }
            }
        });
    }
}
exports.CollapseRibbonControl = CollapseRibbonControl;
// ## ExtendedCollapseParent
// Muse-style '...' buttons for less-common operations
class ExtendedCollapseParent extends button_1.SuiButton {
    constructor(parameters) {
        super(parameters);
    }
    bind() {
        $(this.buttonElement).off('click').on('click', () => {
            $(this.buttonElement).closest('.collapseContainer').toggleClass('expanded-more');
        });
    }
}
exports.ExtendedCollapseParent = ExtendedCollapseParent;


/***/ }),

/***/ "./src/ui/buttons/display.ts":
/*!***********************************!*\
  !*** ./src/ui/buttons/display.ts ***!
  \***********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DisplaySettings = void 0;
const button_1 = __webpack_require__(/*! ./button */ "./src/ui/buttons/button.ts");
/**
 * These are the quick-buttons that show up on the left of the button ribbon.
 * @category SuiButton
 */
class DisplaySettings extends button_1.SuiButton {
    constructor(parameters) {
        super(parameters);
        if (this.buttonData.id === 'selectPart') {
            this.eventSource.bindScoreChangeHandler(this, 'handleScoreChange');
            this.enablePartSelection();
        }
    }
    enablePartSelection() {
        const partMap = this.view.getPartMap();
        const disable = partMap.keys.length < 1;
        $(this.buttonElement[0]).prop('disabled', disable);
    }
    handleScoreChange(ev) {
        if (this.view.isPartExposed()) {
            this.buttonData.rightText = this.view.score.staves[0].partInfo.partName;
        }
        else {
            this.buttonData.rightText = 'Select Part';
        }
        $(this.buttonElement[0]).find('.ribbon-button-hotkey').text(this.buttonData.rightText);
        this.enablePartSelection();
    }
    refresh() {
        this.view.refreshViewport();
    }
    zoomout() {
        const globalLayout = this.view.score.layoutManager.getGlobalLayout();
        globalLayout.zoomScale *= 1.1;
        this.view.updateZoom(globalLayout.zoomScale);
    }
    zoomin() {
        const globalLayout = this.view.score.layoutManager.getGlobalLayout();
        globalLayout.zoomScale = globalLayout.zoomScale / 1.1;
        this.view.updateZoom(globalLayout.zoomScale);
    }
    playButton2() {
        this.view.playFromSelection();
    }
    stopButton2() {
        this.view.stopPlayer();
    }
    selectPart() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.completeNotifier) {
                return;
            }
            yield this.view.renderPromise();
            this.menus.slashMenuMode(this.completeNotifier);
            this.menus.createMenu('SuiPartSelectionMenu');
        });
    }
    bind() {
        this.eventSource.domClick(this.buttonElement, this, this.buttonData.id, null);
    }
}
exports.DisplaySettings = DisplaySettings;


/***/ }),

/***/ "./src/ui/buttons/duration.ts":
/*!************************************!*\
  !*** ./src/ui/buttons/duration.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DurationButtons = void 0;
const button_1 = __webpack_require__(/*! ./button */ "./src/ui/buttons/button.ts");
class DurationButtons extends button_1.SuiButton {
    constructor(parameters) {
        super(parameters);
        this.buttonData = parameters.buttonData;
    }
    setDuration() {
        if (this.buttonData.id === 'GrowDuration') {
            this.view.batchDurationOperation('doubleDuration');
        }
        else if (this.buttonData.id === 'LessDuration') {
            this.view.batchDurationOperation('halveDuration');
        }
        else if (this.buttonData.id === 'GrowDurationDot') {
            this.view.batchDurationOperation('dotDuration');
        }
        else if (this.buttonData.id === 'LessDurationDot') {
            this.view.batchDurationOperation('undotDuration');
        }
        else if (this.buttonData.id === 'TripletButton') {
            this.view.makeTuplet(3);
        }
        else if (this.buttonData.id === 'QuintupletButton') {
            this.view.makeTuplet(5);
        }
        else if (this.buttonData.id === 'SeptupletButton') {
            this.view.makeTuplet(7);
        }
        else if (this.buttonData.id === 'NoTupletButton') {
            this.view.unmakeTuplet();
        }
    }
    bind() {
        $(this.buttonElement).off('click').on('click', () => {
            this.setDuration();
        });
    }
}
exports.DurationButtons = DurationButtons;


/***/ }),

/***/ "./src/ui/buttons/measure.ts":
/*!***********************************!*\
  !*** ./src/ui/buttons/measure.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MeasureButtons = void 0;
const button_1 = __webpack_require__(/*! ./button */ "./src/ui/buttons/button.ts");
const measureModifiers_1 = __webpack_require__(/*! ../../smo/data/measureModifiers */ "./src/smo/data/measureModifiers.ts");
class MeasureButtons extends button_1.SuiButton {
    constructor(parameters) {
        super(parameters);
    }
    endRepeat() {
        this.view.setBarline(measureModifiers_1.SmoBarline.positions.end, measureModifiers_1.SmoBarline.barlines.endRepeat);
    }
    startRepeat() {
        this.view.setBarline(measureModifiers_1.SmoBarline.positions.start, measureModifiers_1.SmoBarline.barlines.startRepeat);
    }
    singleBarStart() {
        this.view.setBarline(measureModifiers_1.SmoBarline.positions.start, measureModifiers_1.SmoBarline.barlines.singleBar);
    }
    singleBarEnd() {
        this.view.setBarline(measureModifiers_1.SmoBarline.positions.end, measureModifiers_1.SmoBarline.barlines.singleBar);
    }
    doubleBar() {
        this.view.setBarline(measureModifiers_1.SmoBarline.positions.end, measureModifiers_1.SmoBarline.barlines.doubleBar);
    }
    endBar() {
        this.view.setBarline(measureModifiers_1.SmoBarline.positions.end, measureModifiers_1.SmoBarline.barlines.endBar);
    }
    coda() {
        this.view.setRepeatSymbol(measureModifiers_1.SmoRepeatSymbol.positions.end, measureModifiers_1.SmoRepeatSymbol.symbols.Coda);
    }
    toCoda() {
        this.view.setRepeatSymbol(measureModifiers_1.SmoRepeatSymbol.positions.end, measureModifiers_1.SmoRepeatSymbol.symbols.ToCoda);
    }
    segno() {
        this.view.setRepeatSymbol(measureModifiers_1.SmoRepeatSymbol.positions.end, measureModifiers_1.SmoRepeatSymbol.symbols.Segno);
    }
    dsAlCoda() {
        this.view.setRepeatSymbol(measureModifiers_1.SmoRepeatSymbol.positions.end, measureModifiers_1.SmoRepeatSymbol.symbols.DsAlCoda);
    }
    dcAlCoda() {
        this.view.setRepeatSymbol(measureModifiers_1.SmoRepeatSymbol.positions.end, measureModifiers_1.SmoRepeatSymbol.symbols.DcAlCoda);
    }
    dsAlFine() {
        this.view.setRepeatSymbol(measureModifiers_1.SmoRepeatSymbol.positions.end, measureModifiers_1.SmoRepeatSymbol.symbols.DsAlFine);
    }
    dcAlFine() {
        this.view.setRepeatSymbol(measureModifiers_1.SmoRepeatSymbol.positions.end, measureModifiers_1.SmoRepeatSymbol.symbols.DcAlFine);
    }
    fine() {
        this.view.setRepeatSymbol(measureModifiers_1.SmoRepeatSymbol.positions.end, measureModifiers_1.SmoRepeatSymbol.symbols.Fine);
    }
    nthEnding() {
        this.view.addEnding();
    }
    handleEvent(event, method) {
        this[method]();
    }
    bind() {
        this.eventSource.domClick(this.buttonElement, this, 'handleEvent', this.buttonData.id);
    }
}
exports.MeasureButtons = MeasureButtons;


/***/ }),

/***/ "./src/ui/buttons/microtone.ts":
/*!*************************************!*\
  !*** ./src/ui/buttons/microtone.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MicrotoneButtons = void 0;
const button_1 = __webpack_require__(/*! ./button */ "./src/ui/buttons/button.ts");
const noteModifiers_1 = __webpack_require__(/*! ../../smo/data/noteModifiers */ "./src/smo/data/noteModifiers.ts");
const oscillator_1 = __webpack_require__(/*! ../../render/audio/oscillator */ "./src/render/audio/oscillator.ts");
class MicrotoneButtons extends button_1.SuiButton {
    constructor(parameters) {
        super(parameters);
    }
    applyButton(el) {
        const defs = noteModifiers_1.SmoMicrotone.defaults;
        defs.tone = el.id;
        const tn = new noteModifiers_1.SmoMicrotone(defs);
        this.view.addRemoveMicrotone(tn);
        oscillator_1.SuiOscillator.playSelectionNow(this.view.tracker.selections[0], this.view.score, 1);
    }
    bind() {
        $(this.buttonElement).off('click').on('click', () => {
            this.applyButton(this.buttonData);
        });
    }
}
exports.MicrotoneButtons = MicrotoneButtons;


/***/ }),

/***/ "./src/ui/buttons/navigation.ts":
/*!**************************************!*\
  !*** ./src/ui/buttons/navigation.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NavigationButtons = void 0;
const button_1 = __webpack_require__(/*! ./button */ "./src/ui/buttons/button.ts");
class NavigationButtons extends button_1.SuiButton {
    static get directionsTrackerMap() {
        return {
            navLeftButton: 'moveSelectionLeft',
            navRightButton: 'moveSelectionRight',
            navUpButton: 'moveSelectionUp',
            navDownButton: 'moveSelectionDown',
            navFastForward: 'moveSelectionRightMeasure',
            navRewind: 'moveSelectionLeftMeasure',
            navGrowLeft: 'growSelectionLeft',
            navGrowRight: 'growSelectionRight'
        };
    }
    constructor(parameters) {
        super(parameters);
    }
    _moveTracker() {
        this.view.tracker[NavigationButtons.directionsTrackerMap[this.buttonData.id]]();
    }
    bind() {
        this.eventSource.domClick(this.buttonElement, this, '_moveTracker', null);
    }
}
exports.NavigationButtons = NavigationButtons;


/***/ }),

/***/ "./src/ui/buttons/note.ts":
/*!********************************!*\
  !*** ./src/ui/buttons/note.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NoteButtons = void 0;
const button_1 = __webpack_require__(/*! ./button */ "./src/ui/buttons/button.ts");
const common_1 = __webpack_require__(/*! ../../smo/data/common */ "./src/smo/data/common.ts");
class NoteButtons extends button_1.SuiButton {
    constructor(parameters) {
        super(parameters);
    }
    setPitch() {
        if (this.buttonData.id === 'UpNoteButton') {
            this.view.transposeSelections(1);
        }
        else if (this.buttonData.id === 'DownNoteButton') {
            this.view.transposeSelections(-1);
        }
        else if (this.buttonData.id === 'UpOctaveButton') {
            this.view.transposeSelections(12);
        }
        else if (this.buttonData.id === 'DownOctaveButton') {
            this.view.transposeSelections(-12);
        }
        else if (this.buttonData.id === 'ToggleAccidental') {
            this.view.toggleEnharmonic();
        }
        else if (this.buttonData.id === 'ToggleCourtesy') {
            this.view.toggleCourtesyAccidentals();
        }
        else if (this.buttonData.id === 'ToggleRestButton') {
            this.view.makeRest();
        }
        else if (this.buttonData.id === 'ToggleSlashButton') {
            this.view.toggleSlash();
        }
        else if (this.buttonData.id === 'AddGraceNote') {
            this.view.addGraceNote();
        }
        else if (this.buttonData.id === 'SlashGraceNote') {
            this.view.slashGraceNotes();
        }
        else if (this.buttonData.id === 'RemoveGraceNote') {
            this.view.removeGraceNote();
        }
        else if (this.buttonData.id === 'XNoteHead') {
            this.view.setNoteHead('x2');
        }
        else if (this.buttonData.id === 'TriUpNoteHead') {
            this.view.setNoteHead('T2');
        }
        else if (this.buttonData.id === 'CircleXNoteHead') {
            this.view.setNoteHead('X3');
        }
        else if (this.buttonData.id === 'DiamondNoteHead') {
            this.view.setNoteHead('D2');
        }
        else {
            if ((0, common_1.IsPitchLetter)(this.buttonData.rightText)) {
                this.view.setPitch(this.buttonData.rightText);
            }
        }
    }
    bind() {
        $(this.buttonElement).off('click').on('click', () => {
            this.setPitch();
        });
    }
}
exports.NoteButtons = NoteButtons;


/***/ }),

/***/ "./src/ui/buttons/player.ts":
/*!**********************************!*\
  !*** ./src/ui/buttons/player.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PlayerButtons = void 0;
const button_1 = __webpack_require__(/*! ./button */ "./src/ui/buttons/button.ts");
class PlayerButtons extends button_1.SuiButton {
    constructor(parameters) {
        super(parameters);
    }
    playButton() {
        this.view.playFromSelection();
    }
    stopButton() {
        this.view.stopPlayer();
    }
    pauseButton() {
        this.view.pausePlayer();
    }
    bind() {
        this.eventSource.domClick(this.buttonElement, this, this.buttonData.id, null);
    }
}
exports.PlayerButtons = PlayerButtons;


/***/ }),

/***/ "./src/ui/buttons/ribbon.ts":
/*!**********************************!*\
  !*** ./src/ui/buttons/ribbon.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RibbonButtons = exports.isModalButtonType = exports.SuiModalButtonStrings = void 0;
// [Smoosic](https://github.com/AaronDavidNewman/Smoosic)
// Copyright (c) Aaron David Newman 2021.
const htmlHelpers_1 = __webpack_require__(/*! ../../common/htmlHelpers */ "./src/common/htmlHelpers.ts");
const library_1 = __webpack_require__(/*! ../dialogs/library */ "./src/ui/dialogs/library.ts");
const tempo_1 = __webpack_require__(/*! ../dialogs/tempo */ "./src/ui/dialogs/tempo.ts");
const instrument_1 = __webpack_require__(/*! ../dialogs/instrument */ "./src/ui/dialogs/instrument.ts");
const collapsable_1 = __webpack_require__(/*! ./collapsable */ "./src/ui/buttons/collapsable.ts");
const dialog_1 = __webpack_require__(/*! ../dialogs/dialog */ "./src/ui/dialogs/dialog.ts");
const help_1 = __webpack_require__(/*! ../help */ "./src/ui/help.ts");
exports.SuiModalButtonStrings = ['SuiLibraryDialog', 'SuiTempoDialog', 'SuiInstrumentDialog'];
function isModalButtonType(but) {
    return exports.SuiModalButtonStrings.indexOf(but) >= 0;
}
exports.isModalButtonType = isModalButtonType;
// ## RibbonButtons
// Render the ribbon buttons based on group, function, and underlying UI handler.
// Also handles UI events.
// ### RibbonButton methods
// ---
class RibbonButtons {
    constructor(params) {
        this.collapsables = [];
        this.collapseChildren = [];
        this.controller = params.completeNotifier;
        this.config = params.config;
        this.eventSource = params.eventSource;
        this.view = params.view;
        this.menus = params.menus;
        this.ribbonButtons = params.ribbonButtons;
        this.ribbons = params.ribbons;
        this.collapsables = [];
        this.collapseChildren = [];
    }
    static get paramArray() {
        return ['ribbonButtons', 'ribbons', 'keyCommands', 'controller', 'menus', 'eventSource', 'view'];
    }
    static _buttonHtml(containerClass, buttonId, buttonClass, buttonText, buttonIcon, buttonKey) {
        const b = htmlHelpers_1.buildDom;
        const r = b('div').classes(containerClass).append(b('button').attr('id', buttonId).classes(buttonClass).append(b('span').classes('left-text').append(b('span').classes('text-span').text(buttonText)).append(b('span').classes('ribbon-button-text icon ' + buttonIcon))).append(b('span').classes('ribbon-button-hotkey').text(buttonKey)));
        return r.dom();
    }
    _executeButtonModal(buttonElement, buttonData) {
        if (isModalButtonType(buttonData.ctor)) {
            const params = {
                eventSource: this.eventSource,
                completeNotifier: this.controller,
                view: this.view,
                ctor: buttonData.ctor,
                id: buttonData.id,
                startPromise: null,
                tracker: this.view.tracker
            };
            if (buttonData.ctor === 'SuiInstrumentDialog') {
                (0, dialog_1.createAndDisplayDialog)(instrument_1.SuiInstrumentDialog, params);
            }
            else if (buttonData.ctor === 'SuiLibraryDialog') {
                library_1.SuiLibraryDialog.createAndDisplay(params, this.config);
            }
            else {
                (0, dialog_1.createAndDisplayDialog)(tempo_1.SuiTempoDialog, params);
            }
        }
        else if (buttonData.ctor === 'helpModal') {
            help_1.SuiHelp.displayHelp();
        }
    }
    _executeButtonMenu(buttonElement, buttonData) {
        this.menus.slashMenuMode(this.controller);
        this.menus.createMenu(buttonData.ctor);
    }
    _executeButton(buttonElement, buttonData) {
        if (buttonData.action === 'modal') {
            this._executeButtonModal(buttonElement, buttonData);
            return;
        }
        if (buttonData.action === 'menu' || buttonData.action === 'collapseChildMenu') {
            this._executeButtonMenu(buttonElement, buttonData);
        }
    }
    _bindButton(buttonElement, buttonData) {
        this.eventSource.domClick(buttonElement, this, '_executeButton', buttonData);
    }
    _createCollapsibleButtonGroups(selector) {
        let containerClass = '';
        // Now all the button elements have been bound.  Join child and parent buttons
        // For all the children of a button group, add it to the parent group
        this.collapseChildren.forEach((b) => {
            containerClass = 'ribbonButtonContainer';
            if (b.action === 'collapseGrandchild') {
                containerClass = 'ribbonButtonContainerMore';
            }
            const buttonHtml = RibbonButtons._buttonHtml(containerClass, b.id, b.classes, b.leftText, b.icon, b.rightText);
            if (b.dataElements) {
                const bkeys = Object.keys(b.dataElements);
                bkeys.forEach((bkey) => {
                    var de = b.dataElements[bkey];
                    $(buttonHtml).find('button').attr('data-' + bkey, de);
                });
            }
            // Bind the child button actions
            const parent = $(selector).find('.collapseContainer[data-group="' + b.group + '"]');
            $(parent).append(buttonHtml);
            const el = $(selector).find('#' + b.id);
            this._bindButton(el, b);
        });
        this.collapsables.forEach((cb) => {
            // Bind the events of the parent button
            cb.bind();
        });
    }
    static isCollapsible(action) {
        return ['collapseChild', 'collapseChildMenu', 'collapseGrandchild', 'collapseMore'].indexOf(action) >= 0;
    }
    // ### _createButtonHtml
    // For each button, create the html and bind the events based on
    // the button's configured action.
    _createRibbonHtml(buttonAr, selector) {
        let buttonClass = '';
        buttonAr.forEach((buttonId) => {
            const buttonData = this.ribbonButtons.find((e) => e.id === buttonId);
            if (buttonData) {
                if (buttonData.leftText) {
                    RibbonButtons.translateButtons.push({ buttonId: buttonData.id, buttonText: buttonData.leftText });
                }
                // collapse child is hidden until the parent button is selected, exposing the button group
                if (RibbonButtons.isCollapsible(buttonData.action)) {
                    this.collapseChildren.push(buttonData);
                }
                if (buttonData.action !== 'collapseChild') {
                    // else the button has a specific action, such as a menu or dialog, or a parent button
                    // for translation, add the menu name to the button class
                    buttonClass = buttonData.classes;
                    if (buttonData.action === 'menu' || buttonData.action === 'modal') {
                        buttonClass += ' ' + buttonData.ctor;
                    }
                    const buttonHtml = RibbonButtons._buttonHtml('ribbonButtonContainer', buttonData.id, buttonClass, buttonData.leftText, buttonData.icon, buttonData.rightText);
                    $(buttonHtml).attr('data-group', buttonData.group);
                    $(selector).append(buttonHtml);
                    const buttonElement = $('#' + buttonData.id);
                    // If this is a collabsable button, create it, otherwise bind its execute function.
                    if (buttonData.action === 'collapseParent') {
                        $(buttonHtml).addClass('collapseContainer');
                        // collapseParent
                        this.collapsables.push(new collapsable_1.CollapseRibbonControl({
                            ctor: buttonData.ctor,
                            buttons: this.ribbonButtons,
                            view: this.view,
                            menus: this.menus,
                            eventSource: this.eventSource,
                            completeNotifier: this.controller,
                            buttonId: buttonData.id,
                            buttonElement,
                            buttonData
                        }));
                    }
                    else {
                        this.eventSource.domClick(buttonElement, this, '_executeButton', buttonData);
                    }
                }
            }
        });
    }
    addButton(button, parentElement) {
        this.ribbonButtons.push(button);
        this.createRibbon([button.id], parentElement);
    }
    createRibbon(buttonDataArray, parentElement) {
        this._createRibbonHtml(buttonDataArray, parentElement);
        this._createCollapsibleButtonGroups(parentElement);
    }
    display() {
        if (this.config.leftControls) {
            const leftControl = (0, htmlHelpers_1.getDomContainer)(this.config.leftControls);
            if (leftControl) {
                $(leftControl).html('');
                const lbuttons = this.ribbons.left;
                this.createRibbon(lbuttons, leftControl);
            }
        }
        if (this.config.topControls) {
            const topControl = (0, htmlHelpers_1.getDomContainer)(this.config.topControls);
            if (topControl) {
                const tbuttons = this.ribbons.top;
                this.createRibbon(tbuttons, topControl);
            }
        }
    }
}
exports.RibbonButtons = RibbonButtons;
RibbonButtons.translateButtons = [];


/***/ }),

/***/ "./src/ui/buttons/stave.ts":
/*!*********************************!*\
  !*** ./src/ui/buttons/stave.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StaveButtons = void 0;
const button_1 = __webpack_require__(/*! ./button */ "./src/ui/buttons/button.ts");
const staffModifiers_1 = __webpack_require__(/*! ../../smo/data/staffModifiers */ "./src/smo/data/staffModifiers.ts");
class StaveButtons extends button_1.SuiButton {
    constructor(parameters) {
        super(parameters);
    }
    addClef(clef, clefName) {
        var instrument = new staffModifiers_1.SmoInstrument(staffModifiers_1.SmoInstrument.defaults);
        instrument.instrumentName = clefName;
        instrument.keyOffset = 0;
        instrument.clef = clef;
        this.view.changeInstrument(instrument, this.view.tracker.selections);
    }
    clefTreble() {
        this.addClef('treble', 'Treble Instrument');
    }
    clefBass() {
        this.addClef('bass', 'Bass Instrument');
    }
    clefAlto() {
        this.addClef('alto', 'Alto Instrument');
    }
    clefTenor() {
        this.addClef('tenor', 'Tenor Instrument');
    }
    clefPercussion() {
        this.addClef('percussion', 'Tenor Instrument');
    }
    _clefMove(index) {
        this.view.moveStaffUpDown(index);
    }
    clefMoveUp() {
        this._clefMove(-1);
    }
    clefMoveDown() {
        this._clefMove(1);
    }
    bind() {
        const self = this;
        $(this.buttonElement).off('click').on('click', () => {
            const id = self.buttonData.id;
            if (typeof (this[id]) === 'function') {
                this[id]();
            }
        });
    }
}
exports.StaveButtons = StaveButtons;


/***/ }),

/***/ "./src/ui/buttons/text.ts":
/*!********************************!*\
  !*** ./src/ui/buttons/text.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TextButtons = void 0;
const button_1 = __webpack_require__(/*! ./button */ "./src/ui/buttons/button.ts");
const textBlock_1 = __webpack_require__(/*! ../dialogs/textBlock */ "./src/ui/dialogs/textBlock.ts");
const lyric_1 = __webpack_require__(/*! ../dialogs/lyric */ "./src/ui/dialogs/lyric.ts");
const chordChange_1 = __webpack_require__(/*! ../dialogs/chordChange */ "./src/ui/dialogs/chordChange.ts");
const dialog_1 = __webpack_require__(/*! ../dialogs/dialog */ "./src/ui/dialogs/dialog.ts");
class TextButtons extends button_1.SuiButton {
    constructor(parameters) {
        super(parameters);
    }
    lyrics() {
        const sel = this.view.tracker.selections[0];
        const note = sel.note;
        if (!note) {
            return;
        }
        const lyrics = note.getTrueLyrics();
        const lyric = lyrics.length > 0 ? null : lyrics[0];
        (0, dialog_1.createAndDisplayDialog)(lyric_1.SuiLyricDialog, {
            completeNotifier: this.completeNotifier,
            view: this.view,
            eventSource: this.eventSource,
            id: 'lyricDialog',
            ctor: 'SuiLyricDialog',
            tracker: this.view.tracker,
            startPromise: null,
            modifier: lyric
        });
        // tracker, selection, controller
    }
    chordChanges() {
        const sel = this.view.tracker.selections[0];
        const note = sel.note;
        if (!note) {
            return;
        }
        const lyrics = note.getChords();
        const lyric = lyrics.length > 0 ? null : lyrics[0];
        (0, dialog_1.createAndDisplayDialog)(chordChange_1.SuiChordChangeDialog, {
            completeNotifier: this.completeNotifier,
            view: this.view,
            eventSource: this.eventSource,
            id: 'chordDialog',
            ctor: 'SuiChordChangeDialog',
            tracker: this.view.tracker,
            startPromise: null,
            modifier: lyric
        });
    }
    rehearsalMark() {
        this.view.toggleRehearsalMark();
    }
    _invokeMenu(cmd) {
        if (!this.completeNotifier) {
            return;
        }
        this.menus.slashMenuMode(this.completeNotifier);
        this.menus.createMenu(cmd);
    }
    addTextMenu() {
        (0, dialog_1.createAndDisplayDialog)(textBlock_1.SuiTextBlockDialog, {
            completeNotifier: this.completeNotifier,
            view: this.view,
            eventSource: this.eventSource,
            id: 'chordDialog',
            ctor: 'SuiChordChangeDialog',
            tracker: this.view.tracker,
            startPromise: null,
            modifier: null
        });
    }
    addDynamicsMenu() {
        this._invokeMenu('SuiDynamicsMenu');
    }
    bind() {
        this.eventSource.domClick(this.buttonElement, this, this.buttonData.id, null);
    }
}
exports.TextButtons = TextButtons;


/***/ }),

/***/ "./src/ui/buttons/voice.ts":
/*!*********************************!*\
  !*** ./src/ui/buttons/voice.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.VoiceButtons = void 0;
const button_1 = __webpack_require__(/*! ./button */ "./src/ui/buttons/button.ts");
class VoiceButtons extends button_1.SuiButton {
    constructor(parameters) {
        super(parameters);
    }
    doAction() {
        let voiceIx = 0;
        if (this.buttonData.id === 'V2Button') {
            voiceIx = 1;
        }
        else if (this.buttonData.id === 'V3Button') {
            voiceIx = 2;
        }
        else if (this.buttonData.id === 'V4Button') {
            voiceIx = 3;
        }
        else if (this.buttonData.id === 'VXButton') {
            this.view.depopulateVoice();
            return;
        }
        this.view.populateVoice(voiceIx);
    }
    bind() {
        $(this.buttonElement).off('click').on('click', () => {
            this.doAction();
        });
    }
}
exports.VoiceButtons = VoiceButtons;


/***/ }),

/***/ "./src/ui/common.ts":
/*!**************************!*\
  !*** ./src/ui/common.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CompleteNotifier = exports.ModalComponent = void 0;
/**
 * Define the base class for a modal component that resolves a promise when it is dismissed
 * @category SuiUiBase
 */
class ModalComponent {
}
exports.ModalComponent = ModalComponent;
/**
 * Define an interface that gives up event handling when a modal is active
 * @category SuiUiBase
 */
class CompleteNotifier {
}
exports.CompleteNotifier = CompleteNotifier;


/***/ }),

/***/ "./src/ui/configuration.ts":
/*!*********************************!*\
  !*** ./src/ui/configuration.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ "./src/ui/dialogs/adapter.ts":
/*!***********************************!*\
  !*** ./src/ui/dialogs/adapter.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SuiDialogAdapterBase = exports.SuiComponentAdapter = void 0;
const dialog_1 = __webpack_require__(/*! ./dialog */ "./src/ui/dialogs/dialog.ts");
/**
 * An adapter is the glue logic between UI components and the score view.
 * An adapter consists mostly of accessors (get/set) for the component data.  The
 * components have their initial values set from the adapter get, and changes to components
 * result in sets to the adapter.  The adapter can then update the score.
 * For dialogs that use this pattern,
 * the dialog automatically creates the components and binds their values with the
 * adapter.
 * @method commit - called when OK button of dialog is clicked
 * @method cancel - called when cancel button of dialog is clicked
 * @method remove - optional.  Called when 'remove' button is clicked, for artifacts like dynamics that can be removed.
 * @category SuiDialog
 */
class SuiComponentAdapter {
    constructor(view) {
        this.view = view;
    }
    remove() { }
    ;
}
exports.SuiComponentAdapter = SuiComponentAdapter;
/**
 * SuiDialogAdapterBase is the base class for dialogs that use the adapter pattern
 * (almost all of them).
 * @typeParam T a class that implements the Adapter interface and fulfills the
 *  adapter data contract, with getters and setters from the components
 * @category SuiDialog
 */
class SuiDialogAdapterBase extends dialog_1.SuiDialogBase {
    constructor(def, params) {
        super(def, params);
        this.adapter = params.adapter;
    }
    /**
     * Call the components bind() methods to activate them.  Also, verify that each
     * adapter meets the contract with the components
     */
    bindComponents() {
        this.components.forEach((component) => {
            // do some runtime validation of the adapter
            if (typeof (this.adapter[component.smoName]) === 'undefined') {
                throw ('Dialog ' + this.label + ' has component ' + component.smoName + ' but no setter in the adapter ');
            }
            component.bind();
        });
    }
    /**
     * Called before dialog is displayed.
     * components that interface (bind) with the adapter are called 'bound' components.
     * On initialize, update the component with the score value, as told by the adapter.
     */
    initialValue() {
        this.components.forEach((comp) => {
            comp.setValue(this.adapter[comp.smoName]);
        });
    }
    /**
     * When a component changes, it notifies the parent dialog.  Usually, we just
     * proxy the call to the adapter.  The specific dialog can override this method if
     * something in the UI needs to change as a result of the component state (e.g.
     * show or hide another component)
     */
    changed() {
        this.components.forEach((comp) => {
            if (comp.changeFlag) {
                this.adapter[comp.smoName] = comp.getValue();
            }
        });
    }
    /**
     * If there is any 'saving' to be done when the dialog clicks OK,
     * that is handled by the adapter.  Else it can be a noop.
     */
    commit() {
        this.adapter.commit();
    }
    /**
     * If there is any undo or restore to be done when the dialog clicks OK,
     * that is handled by the adapter.  Else it can be a noop.
     */
    cancel() {
        this.adapter.cancel();
    }
    /**
     * For score artifacts that can be removed,
     */
    remove() {
        this.adapter.remove();
    }
    /**
     * Binds the main dialog buttons.  For OK/Cancel/remove, the logic calls the appropriate
     * derived function, which calls the appropriate adapter method, then calls complete()
     * to restore the event handling loop to the application
     */
    bindElements() {
        var dgDom = this.dgDom;
        $(dgDom.element).find('.ok-button').off('click').on('click', () => {
            this.view.groupUndo(false);
            this.commit();
            this.complete();
        });
        $(dgDom.element).find('.cancel-button').off('click').on('click', () => {
            this.view.groupUndo(false);
            this.cancel();
            this.complete();
        });
        $(dgDom.element).find('.remove-button').off('click').on('click', () => {
            this.view.groupUndo(false);
            this.remove();
            this.complete();
        });
    }
}
exports.SuiDialogAdapterBase = SuiDialogAdapterBase;


/***/ }),

/***/ "./src/ui/dialogs/addMeasure.ts":
/*!**************************************!*\
  !*** ./src/ui/dialogs/addMeasure.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SuiInsertMeasures = void 0;
const dialog_1 = __webpack_require__(/*! ./dialog */ "./src/ui/dialogs/dialog.ts");
/**
 * Insert some number of measures
 * @category SuiDialog
 */
class SuiInsertMeasures extends dialog_1.SuiDialogBase {
    constructor(parameters) {
        super(SuiInsertMeasures.dialogElements, parameters);
        this.selection = this.view.tracker.selections[0];
        const selection = parameters.view.tracker.selections[0];
        const measure = selection.measure;
        this.measure = measure;
        if (!this.startPromise) {
            this.startPromise = new Promise((resolve) => {
                resolve();
            });
        }
    }
    commit() {
        this.view.addMeasures(this.appendCtrl.getValue(), this.measureCountCtrl.getValue());
    }
    get measureCountCtrl() {
        return this.cmap.measureCountCtrl;
    }
    get appendCtrl() {
        return this.cmap.appendCtrl;
    }
    populateInitial() {
        this.measureCountCtrl.setValue(1);
    }
}
exports.SuiInsertMeasures = SuiInsertMeasures;
SuiInsertMeasures.dialogElements = {
    label: 'Insert Measures',
    elements: [{
            smoName: 'measureCount',
            defaultValue: 0,
            control: 'SuiRockerComponent',
            label: 'Measures to Insert'
        }, {
            smoName: 'append',
            control: 'SuiToggleComponent',
            label: 'Append to Selection'
        }],
    staticText: []
};


/***/ }),

/***/ "./src/ui/dialogs/audioSettings.ts":
/*!*****************************************!*\
  !*** ./src/ui/dialogs/audioSettings.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SuiAudioSettingsDialog = exports.SuiAudioSettingsAdapter = void 0;
// [Smoosic](https://github.com/AaronDavidNewman/Smoosic)
// Copyright (c) Aaron David Newman 2021.
const scoreModifiers_1 = __webpack_require__(/*! ../../smo/data/scoreModifiers */ "./src/smo/data/scoreModifiers.ts");
const adapter_1 = __webpack_require__(/*! ./adapter */ "./src/ui/dialogs/adapter.ts");
class SuiAudioSettingsAdapter extends adapter_1.SuiComponentAdapter {
    constructor(view) {
        super(view);
        this.settings = new scoreModifiers_1.SmoAudioPlayerSettings(view.score.audioSettings);
        this.backup = new scoreModifiers_1.SmoAudioPlayerSettings(view.score.audioSettings);
    }
    get enableReverb() {
        return this.settings.reverbEnable;
    }
    set enableReverb(value) {
        this.settings.reverbEnable = value;
        this.view.updateAudioSettings(this.settings);
    }
    get playerType() {
        return this.settings.playerType;
    }
    set playerType(value) {
        if (value !== 'sampler') {
            this.settings.playerType = 'synthesizer';
        }
        else {
            this.settings.playerType = 'sampler';
        }
        this.view.updateAudioSettings(this.settings);
    }
    get waveform() {
        return this.settings.waveform;
    }
    set waveform(value) {
        if ((0, scoreModifiers_1.IsOscillatorType)(value)) {
            this.settings.waveform = value;
        }
        this.view.updateAudioSettings(this.settings);
    }
    get reverbDelay() {
        return this.settings.reverbDelay;
    }
    set reverbDelay(value) {
        this.settings.reverbDelay = value;
        this.view.updateAudioSettings(this.settings);
    }
    get reverbDecay() {
        return this.settings.reverbDecay;
    }
    set reverbDecay(value) {
        this.settings.reverbDecay = value;
        this.view.updateAudioSettings(this.settings);
    }
    cancel() {
        this.view.updateAudioSettings(this.backup);
    }
    commit() {
    }
}
exports.SuiAudioSettingsAdapter = SuiAudioSettingsAdapter;
class SuiAudioSettingsDialog extends adapter_1.SuiDialogAdapterBase {
    constructor(params) {
        const adapter = new SuiAudioSettingsAdapter(params.view);
        super(SuiAudioSettingsDialog.dialogElements, Object.assign({ adapter }, params));
    }
}
exports.SuiAudioSettingsDialog = SuiAudioSettingsDialog;
SuiAudioSettingsDialog.dialogElements = {
    label: 'Audio Settings',
    elements: [{
            smoName: 'enableReverb',
            control: 'SuiToggleComponent',
            label: 'Enable Reverb'
        }, {
            smoName: 'playerType',
            control: 'SuiDropdownComponent',
            label: 'Audio Playback Engine',
            options: [{
                    value: 'sampler', label: 'Sampler'
                }, {
                    value: 'synthesizer', label: 'Analog SoftSynth'
                }]
        }, {
            smoName: 'waveform',
            control: 'SuiDropdownComponent',
            label: 'Waveform (Synth only)',
            options: [{
                    value: 'sine', label: 'Sine'
                }, {
                    value: 'sawtooth', label: 'sawtooth'
                }, {
                    value: 'square', label: 'square'
                }, {
                    value: 'triangle', label: 'triangle'
                }, {
                    value: 'custom', label: 'custom'
                }]
        }, {
            smoName: 'reverbDelay',
            control: 'SuiRockerComponent',
            label: 'Delay Time (if reverb) in seconds',
            dataType: 'float'
        }, {
            smoName: 'reverbDecay',
            control: 'SuiRockerComponent',
            label: 'Decay Time (if reverb) in seconds',
            dataType: 'float'
        }],
    staticText: []
};


/***/ }),

/***/ "./src/ui/dialogs/chordChange.ts":
/*!***************************************!*\
  !*** ./src/ui/dialogs/chordChange.ts ***!
  \***************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SuiChordChangeDialog = void 0;
// [Smoosic](https://github.com/AaronDavidNewman/Smoosic)
// Copyright (c) Aaron David Newman 2021.
const dialog_1 = __webpack_require__(/*! ./dialog */ "./src/ui/dialogs/dialog.ts");
const textRender_1 = __webpack_require__(/*! ../../render/sui/textRender */ "./src/render/sui/textRender.ts");
/**
 * Dialog for running a chord change editing session.
 * @category SuiDialog
 */
class SuiChordChangeDialog extends dialog_1.SuiDialogBase {
    constructor(parameters) {
        super(SuiChordChangeDialog.dialogElements, parameters);
        this.lyric = null;
        this.selector = null;
        this.mouseMoveHandler = null;
        this.mouseClickHandler = null;
        parameters.ctor = 'SuiChordChangeDialog';
        this.displayOptions = ['BINDCOMPONENTS', 'DRAGGABLE', 'KEYBOARD_CAPTURE', 'SELECTIONPOS'];
    }
    get chordEditorCtrl() {
        return this.cmap.chordEditorCtrl;
    }
    get chordSymbolCtrl() {
        return this.cmap.chordSymbolCtrl;
    }
    get translateYCtrl() {
        return this.cmap.translateYCtrl;
    }
    get textPositionCtrl() {
        return this.cmap.textPositionCtrl;
    }
    get adjustWidthCtrl() {
        return this.cmap.adjustWidthCtrl;
    }
    get fontCtrl() {
        return this.cmap.fontCtrl;
    }
    changed() {
        let val = '';
        if (this.chordSymbolCtrl.changeFlag && this.chordEditorCtrl.running) {
            val = '@' + this.chordSymbolCtrl.getValue() + '@';
            var kv;
            /*     type: string, shiftKey: boolean, ctrlKey: boolean, altKey: boolean, key: string, keyCode: string,
          code: string*/
            this.chordEditorCtrl.evKey({
                type: 'keydown',
                shiftKey: false,
                ctrlKey: false,
                altKey: false,
                key: val,
                code: val,
                event: null,
                keyCode: '0'
            });
            // Move focus outside the element so it doesn't intercept keys
            this.chordSymbolCtrl.unselect();
        }
        if (this.translateYCtrl.changeFlag) {
            if (this.lyric && this.selector) {
                this.lyric.translateY = this.translateYCtrl.getValue();
                this.view.addOrUpdateLyric(this.selector, this.lyric);
            }
        }
        if (this.textPositionCtrl.changeFlag) {
            this.chordEditorCtrl.setTextType(this.textPositionCtrl.getValue());
            $(this.textPositionCtrl._getInputElement())[0].selectedIndex = -1;
            $(this.textPositionCtrl._getInputElement()).blur();
        }
        if (this.fontCtrl.changeFlag) {
            const fontInfo = this.fontCtrl.getValue();
            this.view.setChordFont(fontInfo);
        }
        if (this.adjustWidthCtrl.changeFlag) {
            this.view.score.setChordAdjustWidth(this.adjustWidthCtrl.getValue());
        }
    }
    setLyric(selector, lyric) {
        this.selector = selector;
        this.lyric = lyric;
        this.translateYCtrl.setValue(lyric.translateY);
    }
    display() {
        super.display();
        this.mouseMoveHandler = this.eventSource.bindMouseMoveHandler(this, 'mouseMove');
        this.mouseClickHandler = this.eventSource.bindMouseClickHandler(this, 'mouseClick');
        if (this.chordEditorCtrl && this.chordEditorCtrl.session && this.chordEditorCtrl.session.lyric) {
            const lyric = this.chordEditorCtrl.session.lyric;
            this.adjustWidthCtrl.setValue(lyric.adjustNoteWidthChord);
            this.fontCtrl.setValue({
                family: lyric.fontInfo.family,
                size: lyric.fontInfo.size, weight: 'normal'
            });
        }
    }
    bindElements() {
        const dgDom = this.dgDom;
        $(dgDom.element).find('.ok-button').off('click').on('click', () => {
            this._complete();
        });
        $(dgDom.element).find('.cancel-button').off('click').on('click', () => {
            this._complete();
        });
        $(dgDom.element).find('.remove-button').remove();
        // this.chordEditorCtrl.setView(this.eventSource, this.view);
        this.chordEditorCtrl.startEditSession();
    }
    // ### handleKeydown
    // allow a dialog to be dismissed by esc.
    evKey(evdata) {
        return __awaiter(this, void 0, void 0, function* () {
            if (evdata.key === 'Escape') {
                $(this.dgDom.element).find('.cancel-button').click();
                evdata.preventDefault();
            }
            else {
                if (!this.chordEditorCtrl.running) {
                    return;
                }
                const edited = yield this.chordEditorCtrl.evKey(evdata);
                if (edited) {
                    evdata.stopPropagation();
                }
            }
        });
    }
    _complete() {
        if (this.chordEditorCtrl.running) {
            this.chordEditorCtrl.endSession();
        }
        this.view.renderer.setDirty();
        if (this.mouseMoveHandler) {
            this.eventSource.unbindMouseMoveHandler(this.mouseMoveHandler);
        }
        if (this.mouseClickHandler) {
            this.eventSource.unbindMouseClickHandler(this.mouseClickHandler);
        }
        $('body').removeClass('showAttributeDialog');
        $('body').removeClass('textEditor');
        this.complete();
    }
    mouseMove(ev) {
        if (this.chordEditorCtrl && this.chordEditorCtrl.running) {
            this.chordEditorCtrl.mouseMove(ev);
        }
    }
    mouseClick(ev) {
        if (this.chordEditorCtrl && this.chordEditorCtrl.running) {
            this.chordEditorCtrl.mouseClick(ev);
            ev.stopPropagation();
        }
    }
}
exports.SuiChordChangeDialog = SuiChordChangeDialog;
SuiChordChangeDialog.dialogElements = {
    label: 'Edit Chord Symbol', elements: [{
            smoName: 'verse',
            defaultValue: 0,
            control: 'SuiDropdownComponent',
            label: 'Ordinality',
            classes: 'hide-when-editing',
            startRow: true,
            options: [{
                    value: 0,
                    label: '1'
                }, {
                    value: 1,
                    label: '2'
                }, {
                    value: 2,
                    label: '3'
                }]
        }, {
            smoName: 'translateY',
            defaultValue: 0,
            classes: 'hide-when-editing',
            control: 'SuiRockerComponent',
            label: 'Y Adjustment (Px)',
            dataType: 'int'
        }, {
            smoName: 'chordEditor',
            defaultValue: 0,
            classes: 'show-always',
            control: 'SuiChordComponent',
            label: 'Edit Text',
            options: []
        }, {
            smoName: 'chordSymbol',
            defaultValue: '',
            classes: 'show-when-editing',
            control: 'SuiDropdownComponent',
            label: 'Chord Symbol',
            startRow: true,
            options: [{
                    value: 'csymDiminished',
                    label: 'Dim'
                }, {
                    value: 'csymHalfDiminished',
                    label: 'Half dim'
                }, {
                    value: 'csymDiagonalArrangementSlash',
                    label: 'Slash'
                }, {
                    value: 'csymMajorSeventh',
                    label: 'Maj7'
                }]
        }, {
            smoName: 'textPosition',
            defaultValue: textRender_1.SuiInlineText.textTypes.normal,
            classes: 'show-when-editing',
            control: 'SuiDropdownComponent',
            label: 'Text Position',
            startRow: true,
            options: [{
                    value: textRender_1.SuiInlineText.textTypes.superScript,
                    label: 'Superscript'
                }, {
                    value: textRender_1.SuiInlineText.textTypes.subScript,
                    label: 'Subscript'
                }, {
                    value: textRender_1.SuiInlineText.textTypes.normal,
                    label: 'Normal'
                }]
        }, {
            smoName: 'font',
            classes: 'hide-when-editing',
            defaultValue: 0,
            control: 'SuiFontComponent',
            label: 'Font'
        }, {
            smoName: 'adjustWidth',
            classes: 'hide-when-editing',
            control: 'SuiToggleComponent',
            label: 'Adjust Note Width',
            options: []
        }],
    staticText: [
        { label: 'Edit Chord Symbol' },
        { undo: 'Undo Chord Symbols' },
        { doneEditing: 'Done Editing Chord Symbols' }
    ]
};


/***/ }),

/***/ "./src/ui/dialogs/components/baseComponent.ts":
/*!****************************************************!*\
  !*** ./src/ui/dialogs/components/baseComponent.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SuiComponentParent = exports.SuiComponentBase = exports.SuiDialogNotifier = void 0;
/**
 * components know about their parent dialog via the
 * DialogNotifier interface.  It allows a component to
 * notify parent of changing contents.
 * @category SuiDialog
 */
class SuiDialogNotifier {
}
exports.SuiDialogNotifier = SuiDialogNotifier;
/**
 * base class for Dialog components.  Notifies parent
 * dialog of state change via `change()`
 * @category SuiDialog
 */
class SuiComponentBase {
    constructor(dialog, parameters) {
        this.changeFlag = false;
        this.changeFlag = false;
        this.css = parameters.classes;
        this.dialog = dialog;
        this.id = parameters.id;
        this.label = parameters.label;
        this.control = parameters.control;
        this.smoName = parameters.smoName;
    }
    /**
     * Called by the derived class when the value changes.  The change flag is set to true, so the dialog will
     * know which component changed.
     */
    handleChanged() {
        this.changeFlag = true;
        this.dialog.changed();
        this.changeFlag = false;
    }
    /**
     * combine component classes with string, used for composites
     * @param classes string ot append
     * @returns combined strings
     */
    makeClasses(classes) {
        if (this.css) {
            return classes + ' ' + this.css;
        }
        return classes;
    }
    get parameterId() {
        return this.dialog.getId() + '-' + this.smoName;
    }
    show() {
        $('#' + this.parameterId).removeClass('hide');
    }
    hide() {
        $('#' + this.parameterId).addClass('hide');
    }
}
exports.SuiComponentBase = SuiComponentBase;
/**
 * Parent components are really containers for other components
 * For instance, FontComponent has size, family, weight, etc.
 *
 * @category SuiDialog
 */
class SuiComponentParent extends SuiComponentBase {
}
exports.SuiComponentParent = SuiComponentParent;


/***/ }),

/***/ "./src/ui/dialogs/components/button.ts":
/*!*********************************************!*\
  !*** ./src/ui/dialogs/components/button.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SuiButtonComposite = exports.SuiButtonComponent = void 0;
const htmlHelpers_1 = __webpack_require__(/*! ../../../common/htmlHelpers */ "./src/common/htmlHelpers.ts");
const baseComponent_1 = __webpack_require__(/*! ./baseComponent */ "./src/ui/dialogs/components/baseComponent.ts");
// ## SuiToggleComponent
// Simple on/off behavior.  No value just used to notifiy parent dialog
class SuiButtonComponent extends baseComponent_1.SuiComponentBase {
    constructor(dialog, parameter) {
        super(dialog, parameter);
        this.dialog = dialog;
        this.icon = parameter.icon;
    }
    get html() {
        const b = htmlHelpers_1.buildDom;
        const id = this.parameterId;
        this.icon = typeof (this.icon) === 'undefined' ? '' : this.icon;
        const r = b('div').classes(this.makeClasses('buttonControl smoControl')).attr('id', this.parameterId).attr('data-param', this.smoName)
            .append(b('button').attr('type', 'button').classes(this.icon)
            .attr('id', id + '-input')).append(b('label').attr('for', id + '-input').text(this.label));
        return r;
    }
    _getInputElement() {
        var pid = this.parameterId;
        return $(this.dialog.dgDom.element).find('#' + pid).find('button');
    }
    setValue() {
    }
    getValue() {
        return null;
    }
    bind() {
        const input = this._getInputElement();
        $(input).off('click').on('click', () => {
            this.handleChanged();
        });
    }
}
exports.SuiButtonComponent = SuiButtonComponent;
// ### SuiButtonComposite
// Dropdown component that can be part of a composite control.
class SuiButtonComposite extends SuiButtonComponent {
    constructor(dialog, parameters) {
        super(dialog, parameters);
        this.parentControl = parameters.parentControl;
    }
    handleChanged() {
        this.changeFlag = true;
        this.parentControl.changed();
        this.changeFlag = false;
    }
}
exports.SuiButtonComposite = SuiButtonComposite;


/***/ }),

/***/ "./src/ui/dialogs/components/checkdrop.ts":
/*!************************************************!*\
  !*** ./src/ui/dialogs/components/checkdrop.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CheckboxDropdownComponent = void 0;
const baseComponent_1 = __webpack_require__(/*! ../components/baseComponent */ "./src/ui/dialogs/components/baseComponent.ts");
const toggle_1 = __webpack_require__(/*! ../components/toggle */ "./src/ui/dialogs/components/toggle.ts");
const dropdown_1 = __webpack_require__(/*! ../components/dropdown */ "./src/ui/dialogs/components/dropdown.ts");
const htmlHelpers_1 = __webpack_require__(/*! ../../../common/htmlHelpers */ "./src/common/htmlHelpers.ts");
// ## CheckboxDropdownComponent
// A checkbox that enables a dropdown component, for optional or dependent parameter
class CheckboxDropdownComponent extends baseComponent_1.SuiComponentParent {
    constructor(dialog, parameter) {
        super(dialog, parameter);
        const toggleParams = Object.assign({ id: this.id + parameter.toggleElement.smoName, classes: '', parentControl: this }, parameter.toggleElement);
        const dropdownParams = Object.assign({ id: this.id + parameter.dropdownElement.smoName, classes: '', defaultValue: '', parentControl: this }, parameter.dropdownElement);
        this.toggleCtrl = new toggle_1.SuiToggleComposite(this.dialog, toggleParams);
        this.dropdownCtrl = new dropdown_1.SuiDropdownComposite(this.dialog, dropdownParams);
    }
    get html() {
        const b = htmlHelpers_1.buildDom;
        const q = b('div').classes(this.makeClasses('multiControl smoControl checkboxDropdown'))
            .attr('id', this.parameterId);
        q.append(this.toggleCtrl.html);
        q.append(this.dropdownCtrl.html);
        return q;
    }
    bind() {
        this.toggleCtrl.bind();
        this.dropdownCtrl.bind();
    }
    changed() {
        if (this.toggleCtrl.getValue()) {
            $('#' + this.parameterId).addClass('checked');
        }
        else {
            $('#' + this.parameterId).removeClass('checked');
        }
        this.handleChanged();
    }
}
exports.CheckboxDropdownComponent = CheckboxDropdownComponent;


/***/ }),

/***/ "./src/ui/dialogs/components/dragText.ts":
/*!***********************************************!*\
  !*** ./src/ui/dialogs/components/dragText.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SuiDragText = void 0;
const baseComponent_1 = __webpack_require__(/*! ./baseComponent */ "./src/ui/dialogs/components/baseComponent.ts");
const textEdit_1 = __webpack_require__(/*! ../../../render/sui/textEdit */ "./src/render/sui/textEdit.ts");
const htmlHelpers_1 = __webpack_require__(/*! ../../../common/htmlHelpers */ "./src/common/htmlHelpers.ts");
// ## SuiDragText
// A component that lets you drag the text you are editing to anywhere on the score.
// The text is not really part of the dialog but the location of the text appears
// in other dialog fields.
class SuiDragText extends baseComponent_1.SuiComponentBase {
    constructor(dialog, parameter) {
        super(dialog, parameter);
        this.dragging = false;
        this.running = false;
        this.value = '';
        this.session = null;
        this.dragging = false;
        this.running = false;
        this.staticText = this.dialog.getStaticText();
        this.altLabel = this.staticText.draggerLabel;
        this.value = '';
        this.view = this.dialog.getView();
    }
    get html() {
        var b = htmlHelpers_1.buildDom;
        var id = this.parameterId;
        var r = b('div').classes(this.makeClasses('cbDragTextDialog smoControl')).attr('id', this.parameterId).attr('data-param', this.smoName)
            .append(b('button').attr('type', 'checkbox').classes('toggleTextEdit')
            .attr('id', id + '-input').append(b('span').classes('icon icon-move'))
            .append(b('label').attr('for', id + '-input').text(this.label)));
        return r;
    }
    show() { }
    hide() { }
    _getInputElement() {
        var pid = this.parameterId;
        return $(this.dialog.dgDom.element).find('#' + pid).find('button');
    }
    stopEditSession() {
        $('body').removeClass('text-move');
        $(this._getInputElement()).find('span.icon').removeClass('icon-checkmark').addClass('icon-move');
        if (this.session && this.session.dragging) {
            this.session.dragging = false;
            this.session.endDrag();
        }
        if (this.session) {
            this.session.unrender();
        }
        this.handleChanged();
        this.running = false;
    }
    startEditSession() {
        $('body').addClass('text-move');
        this.session = new textEdit_1.SuiDragSession({
            textGroup: this.dialog.modifier,
            context: this.view.renderer.pageMap,
            scroller: this.view.tracker.scroller
        });
        $(this._getInputElement()).find('label').text(this.altLabel);
        $(this._getInputElement()).find('span.icon').removeClass('icon-enlarge').addClass('icon-checkmark');
        this.running = true;
    }
    mouseMove(e) {
        if (this.session && this.session.dragging) {
            this.session.mouseMove(e);
        }
    }
    mouseDown(e) {
        if (this.session && !this.session.dragging) {
            this.session.startDrag(e);
            this.dragging = true;
        }
    }
    mouseUp(e) {
        if (this.session && this.session.dragging) {
            this.session.endDrag();
            this.dragging = false;
        }
    }
    bind() {
        const self = this;
        $(this._getInputElement()).off('click').on('click', () => {
            if (self.running) {
                self.stopEditSession();
            }
            else {
                self.startEditSession();
            }
        });
    }
}
exports.SuiDragText = SuiDragText;


/***/ }),

/***/ "./src/ui/dialogs/components/dropdown.ts":
/*!***********************************************!*\
  !*** ./src/ui/dialogs/components/dropdown.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SuiDropdownComposite = exports.SuiDropdownComponent = void 0;
// [Smoosic](https://github.com/AaronDavidNewman/Smoosic)
// Copyright (c) Aaron David Newman 2021.
/**
 * Classes to support dropdown compontents
 * @module /ui/dialogs/components/dropdown
 */
const htmlHelpers_1 = __webpack_require__(/*! ../../../common/htmlHelpers */ "./src/common/htmlHelpers.ts");
const baseComponent_1 = __webpack_require__(/*! ./baseComponent */ "./src/ui/dialogs/components/baseComponent.ts");
/**
 * single-select dropdown list
 * @category SuiDialog
 */
class SuiDropdownComponent extends baseComponent_1.SuiComponentBase {
    constructor(dialog, parameter) {
        var _a, _b;
        super(dialog, parameter);
        this.value = '';
        this.options = parameter.options;
        this.disabledOption = (_a = parameter.disabledOption) !== null && _a !== void 0 ? _a : '';
        this.dataType = (_b = parameter.dataType) !== null && _b !== void 0 ? _b : 'string';
    }
    checkDefault(s, b) {
        if (this.disabledOption.length) {
            s.prop('required', true).append(b('option').attr('selected', 'selected').prop('disabled', true).text(this.disabledOption));
        }
    }
    get html() {
        const b = htmlHelpers_1.buildDom;
        const id = this.parameterId;
        const r = b('div').classes(this.makeClasses('dropdownControl smoControl')).attr('id', id).attr('data-param', this.smoName);
        const s = b('select');
        this.checkDefault(s, b);
        this.options.forEach((option) => {
            s.append(b('option').attr('value', option.value.toString()).text(option.label));
        });
        r.append(s).append(b('label').attr('for', id + '-input').text(this.label));
        return r;
    }
    replaceOptions(options) {
        const b = htmlHelpers_1.buildDom;
        const s = b('select');
        const sel = this._getInputElement();
        const parent = $(sel).parent();
        $(sel).remove();
        this.checkDefault(s, b);
        options.forEach((option) => {
            s.append(b('option').attr('value', option.value.toString()).text(option.label));
        });
        $(parent).append(s.dom());
        this.bind();
    }
    unselect() {
        $(this._getInputElement())[0].selectedIndex = -1;
        $(this._getInputElement()).blur();
    }
    _getInputElement() {
        var pid = this.parameterId;
        return $(this.dialog.dgDom.element).find('#' + pid).find('select');
    }
    getValue() {
        const input = this._getInputElement();
        const option = input.find('option:selected');
        let val = $(option).val();
        val = (this.dataType.toLowerCase() === 'int') ? parseInt(val, 10) : val;
        val = (this.dataType.toLowerCase() === 'float') ? parseFloat(val) : val;
        if (typeof (val) === 'undefined') {
            val = $(input).find('option:first').val();
            $(input).find('option:first').prop('selected', true);
        }
        return val;
    }
    setValue(value) {
        const input = this._getInputElement();
        $(input).val(value);
    }
    bind() {
        const input = this._getInputElement();
        const self = this;
        $(input).off('change').on('change', () => {
            self.handleChanged();
        });
    }
}
exports.SuiDropdownComponent = SuiDropdownComponent;
/**
 * A dropdown composite mixes a dropdown with some other
 * @category SuiDialog
 */
class SuiDropdownComposite extends SuiDropdownComponent {
    constructor(dialog, parameters) {
        super(dialog, parameters);
        this.parentControl = parameters.parentControl;
    }
    handleChanged() {
        this.changeFlag = true;
        this.parentControl.changed();
        this.changeFlag = false;
    }
}
exports.SuiDropdownComposite = SuiDropdownComposite;


/***/ }),

/***/ "./src/ui/dialogs/components/fileDownload.ts":
/*!***************************************************!*\
  !*** ./src/ui/dialogs/components/fileDownload.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SuiFileDownloadComponent = void 0;
const htmlHelpers_1 = __webpack_require__(/*! ../../../common/htmlHelpers */ "./src/common/htmlHelpers.ts");
const baseComponent_1 = __webpack_require__(/*! ./baseComponent */ "./src/ui/dialogs/components/baseComponent.ts");
const fileInput_1 = __webpack_require__(/*! ../../fileio/fileInput */ "./src/ui/fileio/fileInput.ts");
// ## SuiFileDownloadComponent
// Download a test file using the file input.
class SuiFileDownloadComponent extends baseComponent_1.SuiComponentBase {
    constructor(dialog, parameter) {
        var _a;
        super(dialog, parameter);
        this.value = null;
        this.defaultValue = (_a = parameter.defaultValue) !== null && _a !== void 0 ? _a : '';
        this.dialog = dialog;
    }
    get html() {
        const b = htmlHelpers_1.buildDom;
        const id = this.parameterId;
        var r = b('div').classes(this.makeClasses('select-file')).attr('id', this.parameterId).attr('data-param', this.smoName)
            .append(b('input').attr('type', 'file').classes('file-button')
            .attr('id', id + '-input')).append(b('label').attr('for', id + '-input').text(this.label));
        return r;
    }
    _handleUploadedFiles(evt) {
        const localFile = new fileInput_1.SuiFileInput(evt);
        localFile.loadAsync().then(() => {
            this.value = localFile.value;
            this.handleChanged();
        });
    }
    getValue() {
        return this.value;
    }
    setValue(value) {
        this.value = value;
    }
    bind() {
        const self = this;
        $('#' + this.parameterId).find('input').off('change').on('change', (e) => {
            self._handleUploadedFiles(e);
        });
    }
}
exports.SuiFileDownloadComponent = SuiFileDownloadComponent;


/***/ }),

/***/ "./src/ui/dialogs/components/fontComponent.ts":
/*!****************************************************!*\
  !*** ./src/ui/dialogs/components/fontComponent.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SuiFontComponent = void 0;
// [Smoosic](https://github.com/AaronDavidNewman/Smoosic)
// Copyright (c) Aaron David Newman 2021.
const baseComponent_1 = __webpack_require__(/*! ./baseComponent */ "./src/ui/dialogs/components/baseComponent.ts");
const dropdown_1 = __webpack_require__(/*! ./dropdown */ "./src/ui/dialogs/components/dropdown.ts");
const rocker_1 = __webpack_require__(/*! ./rocker */ "./src/ui/dialogs/components/rocker.ts");
const toggle_1 = __webpack_require__(/*! ./toggle */ "./src/ui/dialogs/components/toggle.ts");
const scoreText_1 = __webpack_require__(/*! ../../../smo/data/scoreText */ "./src/smo/data/scoreText.ts");
const htmlHelpers_1 = __webpack_require__(/*! ../../../common/htmlHelpers */ "./src/common/htmlHelpers.ts");
const ssp_serif_metrics_1 = __webpack_require__(/*! ../../../styles/font_metrics/ssp-serif-metrics */ "./src/styles/font_metrics/ssp-serif-metrics.js");
const ssp_sans_metrics_1 = __webpack_require__(/*! ../../../styles/font_metrics/ssp-sans-metrics */ "./src/styles/font_metrics/ssp-sans-metrics.js");
// ## SuiFontComponent
// Dialog component that lets user choose and customize fonts.
class SuiFontComponent extends baseComponent_1.SuiComponentBase {
    constructor(dialog, parameter) {
        super(dialog, parameter);
        this.dialog = dialog;
        const familyId = this.id + 'fontFamily';
        const sizeId = this.id + 'fontSize';
        this.familyPart = new dropdown_1.SuiDropdownComposite(this.dialog, {
            id: familyId,
            smoName: 'fontFamily',
            classes: 'hide-when-editing hide-when-moving',
            control: 'SuiDropdownComponent',
            label: 'Font Family',
            parentControl: this,
            options: [
                { label: 'Arial', value: 'Arial' },
                { label: 'Times New Roman', value: 'Times New Roman' },
                { label: 'Serif', value: ssp_serif_metrics_1.SourceSerifProFont.fontFamily },
                { label: 'Sans', value: ssp_sans_metrics_1.SourceSansProFont.fontFamily },
                { label: 'Roboto Slab', value: 'Roboto Slab' },
                { label: 'Petaluma', value: 'Petaluma Script' },
                { label: 'Commissioner', value: 'Commissioner' },
                { label: 'Concert One', value: 'ConcertOne' },
                { label: 'Merriweather', value: 'Merriweather' }
            ]
        });
        this.sizePart = new rocker_1.SuiRockerComposite(this.dialog, {
            id: sizeId,
            smoName: 'fontSize',
            defaultValue: 1,
            parentControl: this,
            classes: 'hide-when-editing hide-when-moving',
            control: 'SuiRockerComponent',
            label: 'Font Size',
            dataType: 'float',
            increment: 0.1
        });
        this.italicsCtrl = new toggle_1.SuiToggleComposite(this.dialog, {
            id: this.id + 'italic',
            smoName: 'italic',
            parentControl: this,
            classes: 'hide-when-editing hide-when-moving',
            control: 'SuiToggleComponent',
            label: 'Italics'
        });
        this.boldCtrl = new toggle_1.SuiToggleComposite(this.dialog, {
            id: this.id + 'bold',
            smoName: 'bold',
            parentControl: this,
            classes: 'hide-when-editing hide-when-moving',
            control: 'SuiToggleComponent',
            label: 'Bold'
        });
    }
    changed() {
        this.handleChanged();
    }
    get html() {
        const b = htmlHelpers_1.buildDom;
        const q = b('div').classes(this.makeClasses('multiControl smoControl')).attr('id', this.parameterId);
        if (this.label) {
            q.append(b('h3').classes('font-purpose').text(this.label));
        }
        q.append(this.familyPart.html);
        q.append(this.sizePart.html);
        q.append(this.boldCtrl.html);
        q.append(this.italicsCtrl.html);
        return q;
    }
    _getInputElement() {
        var pid = this.parameterId;
        return $(this.dialog.dgDom.element).find('#' + pid).find('select');
    }
    getValue() {
        return {
            family: this.familyPart.getValue().toString(),
            size: this.sizePart.getValue(),
            weight: this.boldCtrl.getValue() ? 'bold' : 'normal',
            style: this.italicsCtrl.getValue() ? 'italic' : 'normal'
        };
    }
    setValue(value) {
        let italics = false;
        // upconvert font size, all font sizes now in points.
        if (typeof (value.size) !== 'number') {
            value.size = scoreText_1.SmoScoreText.fontPointSize(value.size);
        }
        if (value.style && value.style === 'italic') {
            italics = true;
        }
        const boldString = scoreText_1.SmoScoreText.weightString(value.weight);
        const bold = boldString === 'bold';
        this.boldCtrl.setValue(bold);
        this.italicsCtrl.setValue(italics);
        this.familyPart.setValue(value.family);
        this.sizePart.setValue(value.size);
    }
    bind() {
        this.familyPart.bind();
        this.sizePart.bind();
        this.boldCtrl.bind();
        this.italicsCtrl.bind();
    }
}
exports.SuiFontComponent = SuiFontComponent;


/***/ }),

/***/ "./src/ui/dialogs/components/noteText.ts":
/*!***********************************************!*\
  !*** ./src/ui/dialogs/components/noteText.ts ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SuiChordComponent = exports.SuiLyricComponent = exports.SuiNoteTextComponent = void 0;
// [Smoosic](https://github.com/AaronDavidNewman/Smoosic)
// Copyright (c) Aaron David Newman 2021.
const textEdit_1 = __webpack_require__(/*! ../../../render/sui/textEdit */ "./src/render/sui/textEdit.ts");
const textRender_1 = __webpack_require__(/*! ../../../render/sui/textRender */ "./src/render/sui/textRender.ts");
const htmlHelpers_1 = __webpack_require__(/*! ../../../common/htmlHelpers */ "./src/common/htmlHelpers.ts");
const baseComponent_1 = __webpack_require__(/*! ./baseComponent */ "./src/ui/dialogs/components/baseComponent.ts");
/**
 * Base class for text editor components that navigate to
 * different notes.
 * */
class SuiNoteTextComponent extends baseComponent_1.SuiComponentBase {
    constructor(dialog, parameter) {
        super(dialog, parameter);
        this.session = null;
        this.value = null;
        this.started = false;
        this.view = this.dialog.getView();
        this.eventSource = this.dialog.getEventSource();
        this.selection = this.view.tracker.selections[0];
        this.selector = JSON.parse(JSON.stringify(this.selection.selector));
        this.staticText = this.dialog.getStaticText();
    }
    mouseMove(ev) {
        if (this.session && this.session.isRunning) {
            this.session.handleMouseEvent(ev);
        }
    }
    show() { }
    hide() { }
    mouseClick(ev) {
        if (this.session && this.session.isRunning) {
            this.session.handleMouseEvent(ev);
        }
    }
    _getInputElement() {
        var pid = this.parameterId;
        return $(this.dialog.dgDom.element).find('#' + pid).find('button');
    }
    get running() {
        return this.session && this.session.isRunning;
    }
    evKey(evdata) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.session) {
                return yield this.session.evKey(evdata);
            }
            return false;
        });
    }
    setDialogLyric() {
        if (this.session && this.session.lyric) {
            this.dialog.setLyric(this.selector, this.session.lyric);
        }
    }
    moveSelectionRight() {
        if (this.session) {
            this.session.advanceSelection(false);
            this.setDialogLyric();
        }
    }
    moveSelectionLeft() {
        if (this.session) {
            this.session.advanceSelection(true);
            this.setDialogLyric();
        }
    }
    removeText() {
        if (this.session) {
            this.session.removeLyric();
        }
    }
    _bind() {
        $(this._getInputElement()).off('click').on('click', () => {
            if (this.session && this.session.isRunning) {
                this.endSession();
            }
            else {
                this.startEditSession();
            }
        });
        $('#' + this.parameterId + '-left').off('click').on('click', () => {
            this.moveSelectionLeft();
        });
        $('#' + this.parameterId + '-right').off('click').on('click', () => {
            this.moveSelectionRight();
        });
        $('#' + this.parameterId + '-remove').off('click').on('click', () => {
            this.removeText();
        });
    }
    getValue() {
        return this.value;
    }
}
exports.SuiNoteTextComponent = SuiNoteTextComponent;
/**
 * manage a lyric session that moves from note to note and adds lyrics.
 * @category SuiDialog
**/
class SuiLyricComponent extends SuiNoteTextComponent {
    constructor(dialog, parameter) {
        var _a;
        super(dialog, parameter);
        this.altLabel = this.staticText.doneEditing;
        this.started = false;
        this.verse = (_a = parameter.verse) !== null && _a !== void 0 ? _a : 0;
    }
    get html() {
        var b = htmlHelpers_1.buildDom;
        var id = this.parameterId;
        var r = b('div').classes(this.makeClasses('cbLyricEdit smoControl')).attr('id', this.parameterId).attr('data-param', this.smoName)
            .append(b('div').classes('toggleEdit')
            .append(b('button').classes('toggleTextEdit')
            .attr('id', id + '-toggleInput').append(b('span').classes('icon icon-pencil'))).append(b('label').attr('for', id + '-toggleInput').text(this.label)))
            .append(b('div').classes('show-when-editing')
            .append(b('span')
            .append(b('button').attr('id', id + '-left').classes('icon-arrow-left buttonComponent')))
            .append(b('span')
            .append(b('button').attr('id', id + '-right').classes('icon-arrow-right buttonComponent')))
            .append(b('span')
            .append(b('button').attr('id', id + '-remove').classes('icon-cross buttonComponent'))));
        return r;
    }
    endSession() {
        this.started = false;
        console.log('ending text session');
        $(this._getInputElement()).find('label').text(this.label);
        const button = document.getElementById(this.parameterId);
        $(button).find('span.icon').removeClass('icon-checkmark').addClass('icon-pencil');
        if (this.session) {
            this.session.stopSession();
        }
        $('body').removeClass('text-edit');
    }
    startEditSession() {
        $(this._getInputElement()).find('label').text(this.altLabel);
        console.log('starting text session');
        if (this.started) {
            return;
        }
        // this.textElement=$(this.dialog.layout.svg).find('.'+modifier.attrs.id)[0];
        this.session = new textEdit_1.SuiLyricSession({
            renderer: this.view.renderer,
            selector: this.selector,
            scroller: this.view.tracker.scroller,
            verse: this.verse,
            score: this.view.score,
            view: this.view
        });
        this.started = true;
        $('body').addClass('text-edit');
        const button = document.getElementById(this.parameterId);
        $(button).find('span.icon').removeClass('icon-pencil').addClass('icon-checkmark');
        this.session.startSession();
        this.setDialogLyric();
    }
    bind() {
        this._bind();
    }
}
exports.SuiLyricComponent = SuiLyricComponent;
// ## SuiChordComponent
// manage a chord editing session that moves from note to note and adds chord symbols.
class SuiChordComponent extends SuiNoteTextComponent {
    constructor(dialog, parameter) {
        super(dialog, parameter);
        this.session = null;
        this.dialog = dialog;
        this.selection = this.view.tracker.selections[0];
        this.selector = JSON.parse(JSON.stringify(this.selection.selector));
        this.altLabel = this.staticText.doneEditing;
        this.verse = 0;
    }
    get html() {
        const b = htmlHelpers_1.buildDom;
        const id = this.parameterId;
        const r = b('div').classes(this.makeClasses('cbChordEdit smoControl')).attr('id', this.parameterId).attr('data-param', this.smoName)
            .append(b('div').classes('toggleEdit')
            .append(b('button').classes('toggleTextEdit')
            .attr('id', id + '-toggleInput').append(b('span').classes('icon icon-pencil'))).append(b('label').attr('for', id + '-toggleInput').text(this.label)))
            .append(b('div').classes('show-when-editing')
            .append(b('span')
            .append(b('button').attr('id', id + '-left').classes('icon-arrow-left buttonComponent')))
            .append(b('span')
            .append(b('button').attr('id', id + '-right').classes('icon-arrow-right buttonComponent')))
            .append(b('span')
            .append(b('button').attr('id', id + '-remove').classes('icon-cross buttonComponent'))));
        return r;
    }
    endSession() {
        $(this._getInputElement()).find('label').text(this.label);
        const button = document.getElementById(this.parameterId);
        $(button).find('span.icon').removeClass('icon-checkmark').addClass('icon-pencil');
        if (this.session) {
            this.session.stopSession();
        }
        $('body').removeClass('text-edit');
    }
    startEditSession() {
        $(this._getInputElement()).find('label').text(this.altLabel);
        // this.textElement=$(this.dialog.layout.svg).find('.'+modifier.attrs.id)[0];
        this.session = new textEdit_1.SuiChordSession({
            renderer: this.view.renderer,
            selector: this.selector,
            scroller: this.view.tracker.scroller,
            verse: 0,
            view: this.view,
            score: this.view.score
        });
        $('body').addClass('text-edit');
        const button = document.getElementById(this.parameterId);
        $(button).find('span.icon').removeClass('icon-pencil').addClass('icon-checkmark');
        this.session.startSession();
        this.setDialogLyric();
    }
    bind() {
        this._bind();
    }
    setTextType(type) {
        if (this.session) {
            this.session.textType = parseInt(type.toString(), 10);
        }
    }
    getTextType() {
        if (this.session) {
            return this.session.textType;
        }
        return textRender_1.SuiInlineText.textTypes.normal;
    }
}
exports.SuiChordComponent = SuiChordComponent;


/***/ }),

/***/ "./src/ui/dialogs/components/rocker.ts":
/*!*********************************************!*\
  !*** ./src/ui/dialogs/components/rocker.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SuiRockerComposite = exports.SuiRockerComponent = void 0;
// [Smoosic](https://github.com/AaronDavidNewman/Smoosic)
// Copyright (c) Aaron David Newman 2021.
/**
 * @module /ui/dialog/components/rocker
 * **/
const htmlHelpers_1 = __webpack_require__(/*! ../../../common/htmlHelpers */ "./src/common/htmlHelpers.ts");
const baseComponent_1 = __webpack_require__(/*! ./baseComponent */ "./src/ui/dialogs/components/baseComponent.ts");
/**
 * A numeric input box with +- buttons.   Adjustable type and scale
 * */
class SuiRockerComponent extends baseComponent_1.SuiComponentBase {
    constructor(dialog, params) {
        var _a, _b;
        super(dialog, params);
        this.initialValue = 0;
        this.increment = 1;
        this.dataType = (_a = params.dataType) !== null && _a !== void 0 ? _a : 'int';
        this.increment = (_b = params.increment) !== null && _b !== void 0 ? _b : SuiRockerComponent.increments[this.dataType];
        if (SuiRockerComponent.dataTypes.indexOf(this.dataType) < 0) {
            throw new Error('dialog element invalid type ' + this.dataType);
        }
        if (this.dataType === 'int' && this.increment < 1) {
            throw new Error('int component with decimal increment');
        }
        this.parser = SuiRockerComponent.parsers[this.dataType];
        this.dialog = dialog;
    }
    static get dataTypes() {
        return ['int', 'float', 'percent'];
    }
    static get increments() {
        return { 'int': 1, 'float': 0.1, 'percent': 10 };
    }
    static get parsers() {
        return { 'int': '_getIntValue', 'float': '_getFloatValue', 'percent': '_getPercentValue' };
    }
    get html() {
        const b = htmlHelpers_1.buildDom;
        const id = this.parameterId;
        const r = b('div').classes(this.makeClasses('rockerControl smoControl')).attr('id', id).attr('data-param', this.smoName)
            .append(b('button').classes('increment').append(b('span').classes('icon icon-circle-up'))).append(b('button').classes('decrement').append(b('span').classes('icon icon-circle-down'))).append(b('input').attr('type', 'text').classes('rockerInput')
            .attr('id', id + '-input')).append(b('label').attr('for', id + '-input').text(this.label));
        return r;
    }
    get parameterId() {
        return this.id;
    }
    handleChange() {
        this.changeFlag = true;
        this.dialog.changed();
        this.changeFlag = false;
    }
    bind() {
        const pid = this.parameterId;
        const input = this._getInputElement();
        let val = 0;
        $('#' + pid).find('button.increment').off('click').on('click', () => {
            val = this[this.parser]();
            if (this.dataType === 'percent') {
                val = 100 * val;
            }
            $(input).val(val + this.increment);
            this.handleChanged();
        });
        $('#' + pid).find('button.decrement').off('click').on('click', () => {
            val = this[this.parser]();
            if (this.dataType === 'percent') {
                val = 100 * val;
            }
            $(input).val(val - this.increment);
            this.handleChanged();
        });
        $(input).off('blur').on('blur', () => {
            val = this[this.parser]();
            if (val !== this.initialValue) {
                this.initialValue = val;
                this.handleChanged();
            }
        });
    }
    _getInputElement() {
        const pid = this.parameterId;
        return $(this.dialog.dgDom.element).find('#' + pid).find('input');
    }
    _getIntValue() {
        let val = parseInt(this._getInputElement().val(), 10);
        val = isNaN(val) ? 0 : val;
        return val;
    }
    _getFloatValue() {
        let val = parseFloat(this._getInputElement().val());
        val = isNaN(val) ? 1.0 : val;
        return val;
    }
    _getPercentValue() {
        let val = parseFloat(this._getInputElement().val());
        val = isNaN(val) ? 1 : val;
        return val / 100;
    }
    _setIntValue(val) {
        this._getInputElement().val(val);
    }
    setValue(value) {
        if (this.dataType === 'percent') {
            value = value * 100;
        }
        this._setIntValue(value);
        this.initialValue = value;
    }
    getValue() {
        return this[this.parser]();
    }
}
exports.SuiRockerComponent = SuiRockerComponent;
class SuiRockerComposite extends SuiRockerComponent {
    constructor(dialog, parameters) {
        super(dialog, parameters);
        this.parentControl = parameters.parentControl;
    }
    handleChanged() {
        this.changeFlag = true;
        this.parentControl.changed();
        this.changeFlag = false;
    }
}
exports.SuiRockerComposite = SuiRockerComposite;


/***/ }),

/***/ "./src/ui/dialogs/components/staffComponents.ts":
/*!******************************************************!*\
  !*** ./src/ui/dialogs/components/staffComponents.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StaffCheckComponent = exports.StaffAddRemoveComponent = void 0;
// [Smoosic](https://github.com/AaronDavidNewman/Smoosic)
// Copyright (c) Aaron David Newman 2021.
const baseComponent_1 = __webpack_require__(/*! ./baseComponent */ "./src/ui/dialogs/components/baseComponent.ts");
const toggle_1 = __webpack_require__(/*! ./toggle */ "./src/ui/dialogs/components/toggle.ts");
const htmlHelpers_1 = __webpack_require__(/*! ../../../common/htmlHelpers */ "./src/common/htmlHelpers.ts");
class StaffAddRemoveComponent extends baseComponent_1.SuiComponentBase {
    constructor(dialog, parameter) {
        super(dialog, parameter);
        this.staffRows = [];
        this.createdShell = false;
        this.modifier = null;
        this.view = this.dialog.getView();
        this.staticText = dialog.getStaticText();
        this.label = this.staticText['includeStaff'];
    }
    setControlRows() {
        const mod = this.modifier;
        let i = mod.startSelector.staff;
        this.staffRows = [];
        this.view.storeScore.staves.forEach((staff) => {
            const name = this.label + ' ' + (staff.staffId + 1);
            const id = 'show-' + i;
            const elementParams = {
                smoName: id,
                classes: 'toggle-add-row',
                control: 'SuiToggleComponent',
                label: name,
                parentControl: this,
                id: id
            };
            // Toggle add of last row + 1
            if (staff.staffId === mod.endSelector.staff + 1) {
                const rowElement = new toggle_1.SuiToggleComposite(this.dialog, elementParams);
                rowElement.parentControl = this;
                this.staffRows.push({
                    showCtrl: rowElement
                });
            }
            else if (staff.staffId > mod.startSelector.staff &&
                staff.staffId === mod.endSelector.staff) {
                elementParams.classes = 'toggle-remove-row';
                // toggle remove of ultimate row, other than first row
                const rowElement = new toggle_1.SuiToggleComposite(this.dialog, elementParams);
                this.staffRows.push({
                    showCtrl: rowElement
                });
            }
            else if ((staff.staffId <= mod.endSelector.staff) &&
                (staff.staffId >= mod.startSelector.staff)) {
                // toggle remove of ultimate row, other than first row
                elementParams.classes = 'toggle-disabled';
                const rowElement = new toggle_1.SuiToggleComposite(this.dialog, elementParams);
                this.staffRows.push({
                    showCtrl: rowElement
                });
            }
            i += 1;
        });
    }
    get html() {
        const b = htmlHelpers_1.buildDom;
        // a little hacky.  The first time we create an empty html shell for the control
        // subsequent times, we fill the html with the row information
        if (!this.createdShell) {
            this.createdShell = true;
            const q = b('div').classes(this.makeClasses('multiControl smoControl staffContainer')).attr('id', this.parameterId);
            return q;
        }
        else {
            const q = b('div').classes(this.makeClasses('smoControl'));
            this.staffRows.forEach((row) => {
                q.append(row.showCtrl.html);
            });
            return q;
        }
    }
    getInputElement() {
        var pid = this.parameterId;
        return $('#' + pid);
    }
    getValue() {
        if (!this.modifier) {
            throw 'No staff groups set for staff group component';
        }
        const mod = this.modifier;
        let nextStaff = mod.startSelector.staff;
        const maxMeasure = mod.endSelector.measure;
        mod.endSelector = JSON.parse(JSON.stringify(mod.startSelector));
        this.staffRows.forEach((staffRow) => {
            if (staffRow.showCtrl.getValue()) {
                mod.endSelector = { staff: nextStaff, measure: maxMeasure, voice: 0, tick: 0, pitches: [] };
                nextStaff += 1;
            }
        });
        return this.modifier;
    }
    setValue(staffGroup) {
        this.modifier = staffGroup;
        this.updateGroupMembership();
    }
    changed() {
        this.getValue(); // update modifier
        this.handleChanged();
        this.updateGroupMembership();
    }
    bind() {
        if (!this.modifier) {
            return;
        }
        // Can't bind before initial set of modifier
        this.staffRows.forEach((row) => {
            row.showCtrl.bind();
        });
    }
    updateGroupMembership() {
        const updateEl = this.getInputElement();
        this.setControlRows();
        $(updateEl).html('');
        $(updateEl).append(this.html.dom());
        $(updateEl).find('input').prop('disabled', false);
        $(updateEl).find('.toggle-disabled input').prop('checked', true);
        $(updateEl).find('.toggle-remove-row input').prop('checked', true);
        $(updateEl).find('.toggle-add-row input').prop('checked', false);
        $(updateEl).find('.toggle-disabled input').prop('disabled', true);
        this.bind();
    }
}
exports.StaffAddRemoveComponent = StaffAddRemoveComponent;
class StaffCheckComponent extends baseComponent_1.SuiComponentBase {
    constructor(dialog, parameter) {
        super(dialog, parameter);
        this.dialog = dialog;
        this.view = this.dialog.getView();
        this.staffRows = [];
        let previousStaff = null;
        this.view.storeScore.staves.forEach((staff) => {
            ;
            let name = 'View ' + staff.partInfo.partName;
            if (staff.partInfo.stavesBefore > 0 && previousStaff) {
                name = previousStaff + ' (2)';
            }
            previousStaff = name;
            const id = 'show-' + staff.staffId;
            const toggleParams = {
                smoName: id,
                classes: 'hide-when-editing',
                control: 'SuiToggleComponent',
                label: name,
                id: id,
                parentControl: this
            };
            const rowElement = new toggle_1.SuiToggleComposite(this.dialog, toggleParams);
            this.staffRows.push({
                showCtrl: rowElement
            });
        });
    }
    get html() {
        const b = htmlHelpers_1.buildDom;
        const q = b('div').classes(this.makeClasses('multiControl smoControl staffContainer'));
        this.staffRows.forEach((row) => {
            q.append(row.showCtrl.html);
        });
        return q;
    }
    // Is this used for compound controls?
    _getInputElement() {
        var pid = this.parameterId;
        return $(this.dialog.dgDom.element).find('#' + pid).find('.staffContainer');
    }
    /* export interface StaffCheckValue {
    show: boolean;
  }*/
    getValue() {
        const rv = [];
        let i = 0;
        for (i = 0; i < this.staffRows.length; ++i) {
            const show = this.staffRows[i].showCtrl.getValue();
            rv.push({ show });
        }
        return rv;
    }
    setValue(rows) {
        let i = 0;
        rows.forEach((row) => {
            this.staffRows[i].showCtrl.setValue(row.show);
            i += 1;
        });
    }
    changed() {
        this.handleChanged();
    }
    bind() {
        this.staffRows.forEach((row) => {
            row.showCtrl.bind();
        });
    }
}
exports.StaffCheckComponent = StaffCheckComponent;


/***/ }),

/***/ "./src/ui/dialogs/components/textCheck.ts":
/*!************************************************!*\
  !*** ./src/ui/dialogs/components/textCheck.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TextCheckComponent = void 0;
// [Smoosic](https://github.com/AaronDavidNewman/Smoosic)
// Copyright (c) Aaron David Newman 2021.
const baseComponent_1 = __webpack_require__(/*! ../components/baseComponent */ "./src/ui/dialogs/components/baseComponent.ts");
const toggle_1 = __webpack_require__(/*! ../components/toggle */ "./src/ui/dialogs/components/toggle.ts");
const textInput_1 = __webpack_require__(/*! ../components/textInput */ "./src/ui/dialogs/components/textInput.ts");
const htmlHelpers_1 = __webpack_require__(/*! ../../../common/htmlHelpers */ "./src/common/htmlHelpers.ts");
class TextCheckComponent extends baseComponent_1.SuiComponentBase {
    constructor(dialog, parameter) {
        super(dialog, parameter);
        this.dialog = dialog;
        this.view = this.dialog.getView();
        this.defaultValue = '';
        const toggleName = this.smoName + 'Toggle';
        const textName = this.smoName + 'Text';
        this.staticText = this.dialog.getStaticText();
        const label = this.staticText[textName];
        const show = this.staticText.show;
        this.toggleCtrl = new toggle_1.SuiToggleComposite(this.dialog, {
            smoName: toggleName,
            control: 'SuiToggleComposite',
            label: show,
            parentControl: this,
            classes: '',
            id: toggleName
        });
        this.textCtrl = new textInput_1.SuiTextInputComposite(this.dialog, {
            smoName: textName,
            defaultValue: this.defaultValue,
            control: 'SuiTextInputComposite',
            label,
            parentControl: this,
            classes: '',
            id: toggleName
        });
    }
    get html() {
        const b = htmlHelpers_1.buildDom;
        const q = b('div').classes(this.makeClasses('multiControl smoControl textCheckContainer'))
            .attr('id', this.parameterId);
        q.append(this.textCtrl.html);
        q.append(this.toggleCtrl.html);
        return q;
    }
    getInputElement() {
        var pid = this.parameterId;
        return $('#' + pid);
    }
    getValue() {
        return {
            checked: this.toggleCtrl.getValue(),
            text: this.textCtrl.getValue()
        };
    }
    setValue(val) {
        this.toggleCtrl.setValue(val.checked);
        this.textCtrl.setValue(val.text);
    }
    changed() {
        this.handleChanged();
    }
    bind() {
        this.toggleCtrl.bind();
        this.textCtrl.bind();
    }
}
exports.TextCheckComponent = TextCheckComponent;


/***/ }),

/***/ "./src/ui/dialogs/components/textInPlace.ts":
/*!**************************************************!*\
  !*** ./src/ui/dialogs/components/textInPlace.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SuiTextBlockComponent = exports.SuiTextInPlace = void 0;
const scoreText_1 = __webpack_require__(/*! ../../../smo/data/scoreText */ "./src/smo/data/scoreText.ts");
const textEdit_1 = __webpack_require__(/*! ../../../render/sui/textEdit */ "./src/render/sui/textEdit.ts");
const baseComponent_1 = __webpack_require__(/*! ./baseComponent */ "./src/ui/dialogs/components/baseComponent.ts");
const button_1 = __webpack_require__(/*! ./button */ "./src/ui/dialogs/components/button.ts");
const rocker_1 = __webpack_require__(/*! ./rocker */ "./src/ui/dialogs/components/rocker.ts");
const dropdown_1 = __webpack_require__(/*! ./dropdown */ "./src/ui/dialogs/components/dropdown.ts");
const textRender_1 = __webpack_require__(/*! ../../../render/sui/textRender */ "./src/render/sui/textRender.ts");
const htmlHelpers_1 = __webpack_require__(/*! ../../../common/htmlHelpers */ "./src/common/htmlHelpers.ts");
class SuiTextInPlace extends baseComponent_1.SuiComponentBase {
    constructor(dialog, parameter) {
        super(dialog, parameter);
        this.editMode = false;
        this.session = null;
        this.scroller = dialog.getView().scroller;
        this.value = new scoreText_1.SmoTextGroup(scoreText_1.SmoTextGroup.defaults);
        this.view = this.dialog.getView();
        const modifier = this.dialog.getModifier();
        if (modifier && scoreText_1.SmoTextGroup.isTextGroup(modifier)) {
            this.value = modifier;
        }
        this.staticText = this.dialog.getStaticText();
        this.altLabel = this.staticText.editorLabel;
    }
    show() { }
    hide() { }
    get html() {
        const b = htmlHelpers_1.buildDom;
        const id = this.parameterId;
        const r = b('div').classes(this.makeClasses('cbTextInPlace smoControl')).attr('id', this.parameterId).attr('data-param', this.smoName)
            .append(b('button').attr('type', 'checkbox').classes('toggleTextEdit')
            .attr('id', id + '-input').append(b('span').classes('icon icon-pencil'))
            .append(b('label').attr('for', id + '-input').text(this.label)));
        return r;
    }
    endSession() {
        $(this._getInputElement()).find('label').text(this.label);
        const button = document.getElementById(this.parameterId);
        $(button).find('span.icon').removeClass('icon-checkmark').addClass('icon-pencil');
        this.value.skipRender = false;
        if (this.session) {
            this.session.textGroup.tryParseUnicode();
            this.value = this.session.textGroup;
            this.session.stopSession();
        }
        $('body').removeClass('text-edit');
        this.handleChanged();
    }
    get isRunning() {
        return this.session && this.session.isRunning;
    }
    getValue() {
        return this.value;
    }
    _getInputElement() {
        var pid = this.parameterId;
        return $(this.dialog.dgDom.element).find('#' + pid).find('button');
    }
    mouseMove(ev) {
        if (this.session && this.session.isRunning) {
            this.session.handleMouseEvent(ev);
        }
    }
    mouseClick(ev) {
        if (this.session && this.session.isRunning) {
            this.session.handleMouseEvent(ev);
        }
    }
    _renderInactiveBlocks() {
        const modifier = this.value;
        const context = this.view.renderer.pageMap.getRendererFromModifier(this.value).getContext();
        context.save();
        context.setFillStyle('#ddd');
        const svgPage = this.view.renderer.pageMap.getRendererFromModifier(this.value);
        modifier.textBlocks.forEach((block) => {
            const st = block.text;
            if (st.attrs.id !== this.value.getActiveBlock().attrs.id && svgPage) {
                const svgText = textRender_1.SuiInlineText.fromScoreText(st, svgPage, this.view.renderer.pageMap, this.scroller);
                if (st.logicalBox) {
                    svgText.startX += st.logicalBox.x - st.x;
                    svgText.startY += (st.y - st.logicalBox.y) - st.logicalBox.height / 2;
                }
                const sgrp = context.openGroup();
                sgrp.classList.add('inactive-text');
                sgrp.classList.add('suiInlineText');
                svgText.render();
                context.closeGroup();
            }
        });
        context.restore();
    }
    startEditSession() {
        $(this._getInputElement()).find('label').text(this.altLabel);
        const modifier = this.value;
        modifier.skipRender = true;
        let pageContext = this.view.renderer.pageMap.getRendererFromModifier(this.value);
        $(pageContext.svg).find('#' + modifier.attrs.id).remove();
        this._renderInactiveBlocks();
        const ul = modifier.ul();
        // this.textElement=$(this.dialog.layout.svg).find('.'+modifier.attrs.id)[0];
        this.session = new textEdit_1.SuiTextSession({
            renderer: this.view.renderer,
            scroller: this.scroller,
            x: ul.x,
            y: ul.y,
            textGroup: modifier,
            text: modifier.getActiveBlock().text,
            scoreText: modifier.getActiveBlock()
        });
        $('body').addClass('text-edit');
        this.value = this.session.textGroup;
        const button = document.getElementById(this.parameterId);
        $(button).find('span.icon').removeClass('icon-pencil').addClass('icon-checkmark');
        // Erase the original since we are going to edit it now.
        if (this.value) {
            this.value.elements.forEach((el) => {
                el.remove();
            });
            this.value.elements = [];
        }
        this.session.startSession();
        // blur the button so key events don't get passed to it.
        $(this._getInputElement()).blur();
    }
    evKey(evdata) {
        if (this.session) {
            this.session.evKey(evdata);
        }
    }
    bind() {
        $(this._getInputElement()).off('click').on('click', () => {
            if (this.session && this.session.isRunning) {
                this.endSession();
            }
            else {
                this.startEditSession();
            }
        });
    }
}
exports.SuiTextInPlace = SuiTextInPlace;
class SuiTextBlockComponent extends baseComponent_1.SuiComponentParent {
    constructor(dialog, parameter) {
        super(dialog, parameter);
        this.addBlockCtrl = new button_1.SuiButtonComposite(this.dialog, {
            id: this.id + 'addBlock',
            smoName: 'addBlock',
            parentControl: this,
            icon: 'icon-plus',
            classes: 'hide-when-editing hide-when-moving',
            control: 'SuiButtonComponent',
            label: 'Add Text Block'
        });
        this.toggleBlockCtrl = new button_1.SuiButtonComposite(this.dialog, {
            id: this.id + 'toggleBlock',
            smoName: 'toggleBlock',
            parentControl: this,
            icon: 'icon-arrow-right',
            classes: 'hide-when-editing hide-when-moving',
            control: 'SuiButtonComponent',
            label: 'Next Block'
        });
        this.removeBlockCtrl = new button_1.SuiButtonComposite(this.dialog, {
            id: this.id + 'removeBlock',
            smoName: 'removeBlock',
            parentControl: this,
            icon: 'icon-minus',
            classes: 'hide-when-editing hide-when-moving',
            control: 'SuiButtonComponent',
            label: 'Remove Block'
        });
        this.relativePositionCtrl = new dropdown_1.SuiDropdownComposite(this.dialog, {
            id: this.id + 'relativePosition',
            smoName: 'relativePosition',
            parentControl: this,
            classes: 'hide-when-editing hide-when-moving',
            control: 'SuiDropdownComponent',
            label: 'Block Positions',
            options: [{
                    value: scoreText_1.SmoTextGroup.relativePositions.ABOVE,
                    label: 'Above'
                }, {
                    value: scoreText_1.SmoTextGroup.relativePositions.BELOW,
                    label: 'Below'
                }, {
                    value: scoreText_1.SmoTextGroup.relativePositions.LEFT,
                    label: 'Left'
                }, {
                    value: scoreText_1.SmoTextGroup.relativePositions.RIGHT,
                    label: 'Right'
                }]
        });
        this.justificationCtrl = new dropdown_1.SuiDropdownComposite(this.dialog, {
            id: this.id + 'justification',
            smoName: 'justification',
            parentControl: this,
            classes: 'hide-when-editing hide-when-moving',
            control: 'SuiDropdownComponent',
            label: 'Justification',
            options: [{
                    value: scoreText_1.SmoTextGroup.justifications.LEFT,
                    label: 'Left'
                }, {
                    value: scoreText_1.SmoTextGroup.justifications.RIGHT,
                    label: 'Right'
                }, {
                    value: scoreText_1.SmoTextGroup.justifications.CENTER,
                    label: 'Center'
                }]
        });
        this.spacingCtrl = new rocker_1.SuiRockerComposite(this.dialog, {
            id: this.id + 'spacing',
            smoName: 'spacing',
            defaultValue: 0,
            parentControl: this,
            classes: 'hide-when-editing hide-when-moving',
            control: 'SuiRockerComponent',
            label: 'Spacing',
            dataType: 'float',
            increment: 0.1
        });
        const mod = this.dialog.getModifier();
        if (mod && scoreText_1.SmoTextGroup.isTextGroup(mod)) {
            this.modifier = mod;
        }
        else {
            this.modifier = new scoreText_1.SmoTextGroup(scoreText_1.SmoTextGroup.defaults);
        }
        this.activeScoreText = this.modifier.textBlocks[0].text;
    }
    changed() {
        if (this.addBlockCtrl.changeFlag && this.modifier) {
            const nt = new scoreText_1.SmoScoreText(this.activeScoreText);
            this.modifier.addScoreText(nt);
            this.activeScoreText = nt;
            this.modifier.setActiveBlock(nt);
            this._updateMultiiFields();
        }
        if (this.relativePositionCtrl.changeFlag) {
            this.modifier.setRelativePosition(parseInt(this.relativePositionCtrl.getValue().toString(), 10));
        }
        if (this.justificationCtrl.changeFlag) {
            this.modifier.justification = parseInt(this.justificationCtrl.getValue().toString(), 10);
        }
        if (this.removeBlockCtrl.changeFlag) {
            this.modifier.removeBlock(this.activeScoreText);
            this.activeScoreText = this.modifier.firstBlock();
            this._updateMultiiFields();
        }
        if (this.toggleBlockCtrl.changeFlag) {
            const curIx = this.modifier.indexOf(this.activeScoreText);
            const newIx = (curIx + 1) % this.modifier.textBlocks.length;
            this.activeScoreText = this.modifier.textBlocks[newIx].text;
            this.modifier.setActiveBlock(this.activeScoreText);
        }
        if (this.spacingCtrl.changeFlag) {
            const val = this.spacingCtrl.getValue();
            if (val >= 0) {
                this.modifier.spacing = val;
            }
        }
        this.handleChanged();
    }
    get html() {
        const b = htmlHelpers_1.buildDom;
        const q = b('div').classes(this.makeClasses('multiControl smoControl'));
        q.append(this.addBlockCtrl.html);
        q.append(this.removeBlockCtrl.html);
        q.append(this.toggleBlockCtrl.html);
        q.append(this.relativePositionCtrl.html);
        q.append(this.justificationCtrl.html);
        q.append(this.spacingCtrl.html);
        return q;
    }
    _getInputElement() {
        return $(this.dialog.dgDom.element).find('#' + this.parameterId);
    }
    getValue() {
        return {
            activeScoreText: this.activeScoreText,
            modifier: this.modifier
        };
    }
    _updateMultiiFields() {
        const fields = [this.justificationCtrl, this.relativePositionCtrl,
            this.removeBlockCtrl, this.toggleBlockCtrl, this.spacingCtrl];
        fields.forEach((field) => {
            if (this.modifier.textBlocks.length < 2) {
                $('#' + field.parameterId).addClass('hide');
            }
            else {
                $('#' + field.parameterId).removeClass('hide');
            }
        });
    }
    setValue(value) {
        this.activeScoreText = value.activeScoreText;
        this.modifier = value.modifier;
        this.relativePositionCtrl.setValue(this.modifier.relativePosition);
        this._updateMultiiFields();
        this.justificationCtrl.setValue(this.modifier.justification);
        this.spacingCtrl.setValue(this.modifier.spacing);
    }
    bind() {
        this.addBlockCtrl.bind();
        this.relativePositionCtrl.bind();
        this.justificationCtrl.bind();
        this.removeBlockCtrl.bind();
        this.toggleBlockCtrl.bind();
        this.spacingCtrl.bind();
    }
}
exports.SuiTextBlockComponent = SuiTextBlockComponent;


/***/ }),

/***/ "./src/ui/dialogs/components/textInput.ts":
/*!************************************************!*\
  !*** ./src/ui/dialogs/components/textInput.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SuiTextInputComposite = exports.SuiTextInputComponent = void 0;
const htmlHelpers_1 = __webpack_require__(/*! ../../../common/htmlHelpers */ "./src/common/htmlHelpers.ts");
const baseComponent_1 = __webpack_require__(/*! ./baseComponent */ "./src/ui/dialogs/components/baseComponent.ts");
/**
 * Simple text input, like for a filename.  Not the text editing component.
 */
class SuiTextInputComponent extends baseComponent_1.SuiComponentBase {
    constructor(dialog, parameter) {
        super(dialog, parameter);
        this.defaultValue = '';
        this.value = '';
        this.dialog = dialog;
        this.value = '';
    }
    get html() {
        const b = htmlHelpers_1.buildDom;
        const id = this.parameterId;
        const r = b('div').classes(this.makeClasses('text-input smoControl')).attr('id', this.parameterId).attr('data-param', this.smoName)
            .append(b('input').attr('type', 'text').classes('file-name')
            .attr('id', id + '-input')).append(b('label').attr('for', id + '-input').text(this.label));
        return r;
    }
    getValue() {
        return this.value;
    }
    setValue(val) {
        this.value = val;
        $('#' + this.parameterId).find('input').val(val);
    }
    _getInputElement() {
        const pid = this.parameterId;
        return $(this.dialog.dgDom.element).find('#' + pid).find('input');
    }
    bind() {
        const self = this;
        $('#' + this.parameterId).find('input').off('change').on('change', () => {
            self.value = $(this._getInputElement()).val();
            self.handleChanged();
        });
    }
}
exports.SuiTextInputComponent = SuiTextInputComponent;
class SuiTextInputComposite extends SuiTextInputComponent {
    constructor(dialog, parameters) {
        super(dialog, parameters);
        this.parentControl = parameters.parentControl;
    }
    handleChanged() {
        this.changeFlag = true;
        this.parentControl.changed();
        this.changeFlag = false;
    }
}
exports.SuiTextInputComposite = SuiTextInputComposite;


/***/ }),

/***/ "./src/ui/dialogs/components/tie.ts":
/*!******************************************!*\
  !*** ./src/ui/dialogs/components/tie.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TieMappingComponent = void 0;
// [Smoosic](https://github.com/AaronDavidNewman/Smoosic)
// Copyright (c) Aaron David Newman 2021.
const baseComponent_1 = __webpack_require__(/*! ../components/baseComponent */ "./src/ui/dialogs/components/baseComponent.ts");
const dropdown_1 = __webpack_require__(/*! ../components/dropdown */ "./src/ui/dialogs/components/dropdown.ts");
const htmlHelpers_1 = __webpack_require__(/*! ../../../common/htmlHelpers */ "./src/common/htmlHelpers.ts");
const selections_1 = __webpack_require__(/*! ../../../smo/xform/selections */ "./src/smo/xform/selections.ts");
const staffModifiers_1 = __webpack_require__(/*! ../../../smo/data/staffModifiers */ "./src/smo/data/staffModifiers.ts");
// ## TieMappingComponent
// Represent the pitches in 2 notes that can be individually tied together
class TieMappingComponent extends baseComponent_1.SuiComponentParent {
    constructor(dialog, parameter) {
        super(dialog, parameter);
        this.controlRows = [];
        let i = 0;
        const modifier = this.dialog.getModifier();
        if (modifier && staffModifiers_1.SmoTie.isTie(modifier)) {
            this.modifier = modifier;
        }
        else { // should not happen
            this.modifier = new staffModifiers_1.SmoTie(staffModifiers_1.SmoTie.defaults);
        }
        this.startSelection = selections_1.SmoSelection.noteFromSelector(this.dialog.getView().score, this.modifier.startSelector);
        this.endSelection = selections_1.SmoSelection.noteFromSelector(this.dialog.getView().score, this.modifier.endSelector);
        if (this.startSelection === null || this.startSelection.note === null ||
            this.endSelection === null || this.endSelection.note === null) {
            return;
        }
        const pitchCount = Math.max(this.startSelection.note.pitches.length, this.endSelection.note.pitches.length);
        this.controlRows = [];
        for (i = 0; i < pitchCount; ++i) {
            const smoName = 'Line-' + (i + 1);
            const defaultValue = -1;
            const leftParams = {
                id: this.id + smoName + '-left',
                smoName: smoName + '-left',
                classes: 'leftControl',
                control: 'SuiDropdownComposite',
                label: dialog.getStaticText()['fromNote'],
                options: this._generateOptions(this.startSelection.note),
                parentControl: this
            };
            const leftControl = new dropdown_1.SuiDropdownComposite(this.dialog, leftParams);
            const rightParams = {
                id: this.id + smoName + '-right',
                smoName: smoName + '-right',
                classes: 'rightControl',
                control: 'SuiDropdownComposite',
                label: dialog.getStaticText()['toNote'],
                options: this._generateOptions(this.endSelection.note),
                parentControl: this
            };
            const rightControl = new dropdown_1.SuiDropdownComposite(this.dialog, rightParams);
            this.controlRows.push({ leftControl, rightControl });
        }
    }
    bind() {
        this.controlRows.forEach((row) => {
            row.rightControl.bind();
            row.leftControl.bind();
        });
    }
    _generateOptions(note) {
        const options = [];
        let index = 0;
        let label = '';
        options.push({ value: -1, label: 'No Line' });
        note.pitches.forEach((pitch) => {
            const value = index;
            label = pitch.letter.toUpperCase();
            if (pitch.accidental !== 'n') {
                label += pitch.accidental;
            }
            label += pitch.octave;
            options.push({ value, label });
            index += 1;
        });
        return options;
    }
    getValue() {
        const lines = [];
        this.controlRows.forEach((row) => {
            const left = parseInt(row.leftControl.getValue().toString(), 10);
            const right = parseInt(row.rightControl.getValue().toString(), 10);
            if (left >= 0 && right >= 0) {
                lines.push({ from: left, to: right });
            }
        });
        return lines;
    }
    setValue(modifier) {
        let i = 0;
        for (i = 0; i < this.controlRows.length; ++i) {
            const row = this.controlRows[i];
            if (modifier.length > i) {
                row.leftControl.setValue(modifier[i].from);
                row.rightControl.setValue(modifier[i].to);
            }
        }
    }
    changed() {
        this.handleChanged();
    }
    get html() {
        const b = htmlHelpers_1.buildDom;
        const q = b('div').classes(this.makeClasses('multiControl smoControl dropdownPair'))
            .attr('id', this.parameterId);
        this.controlRows.forEach((row) => {
            q.append(row.leftControl.html).append(row.rightControl.html);
        });
        return q;
    }
}
exports.TieMappingComponent = TieMappingComponent;


/***/ }),

/***/ "./src/ui/dialogs/components/toggle.ts":
/*!*********************************************!*\
  !*** ./src/ui/dialogs/components/toggle.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SuiToggleComposite = exports.SuiToggleComponent = void 0;
const htmlHelpers_1 = __webpack_require__(/*! ../../../common/htmlHelpers */ "./src/common/htmlHelpers.ts");
const baseComponent_1 = __webpack_require__(/*! ./baseComponent */ "./src/ui/dialogs/components/baseComponent.ts");
/**
 * Simple boolean checkbox component
 */
class SuiToggleComponent extends baseComponent_1.SuiComponentBase {
    constructor(dialog, parameter) {
        super(dialog, parameter);
        this.defaultValue = false;
        this.defaultValue = false;
        this.dialog = dialog;
    }
    get html() {
        const b = htmlHelpers_1.buildDom;
        const id = this.parameterId;
        const r = b('div').classes(this.makeClasses('toggleControl smoControl')).attr('id', this.parameterId).attr('data-param', this.smoName)
            .append(b('input').attr('type', 'checkbox').classes('toggleInput')
            .attr('id', id + '-input')).append(b('label').attr('for', id + '-input').text(this.label));
        return r;
    }
    _getInputElement() {
        const pid = this.parameterId;
        return $(this.dialog.dgDom.element).find('#' + pid).find('input');
    }
    setValue(value) {
        $(this._getInputElement()).prop('checked', value);
    }
    getValue() {
        return $(this._getInputElement()).prop('checked');
    }
    bind() {
        const input = this._getInputElement();
        $(input).off('change').on('change', () => {
            this.handleChanged();
        });
    }
}
exports.SuiToggleComponent = SuiToggleComponent;
// ### SuiToggleComposite
// Dropdown component that can be part of a composite control.
class SuiToggleComposite extends SuiToggleComponent {
    constructor(dialog, parameters) {
        super(dialog, parameters);
        this.parentControl = parameters.parentControl;
    }
    handleChanged() {
        this.changeFlag = true;
        this.parentControl.changed();
        this.changeFlag = false;
    }
}
exports.SuiToggleComposite = SuiToggleComposite;


/***/ }),

/***/ "./src/ui/dialogs/components/tree.ts":
/*!*******************************************!*\
  !*** ./src/ui/dialogs/components/tree.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SuiTreeComponent = void 0;
// [Smoosic](https://github.com/AaronDavidNewman/Smoosic)
// Copyright (c) Aaron David Newman 2021.
const baseComponent_1 = __webpack_require__(/*! ./baseComponent */ "./src/ui/dialogs/components/baseComponent.ts");
const htmlHelpers_1 = __webpack_require__(/*! ../../../common/htmlHelpers */ "./src/common/htmlHelpers.ts");
// ### SuiDropdownComponent
// simple dropdown select list.
class SuiTreeComponent extends baseComponent_1.SuiComponentBase {
    constructor(dialog, parameter) {
        super(dialog, parameter);
        this.persistControls = false;
        this.tree = {};
        this.options = [];
        this.root = parameter.root;
        this.value = this.root;
        this.options = parameter.options;
        this.calculateOptionTree();
    }
    calculateOptionTree() {
        this.tree = {};
        this.options.forEach((option) => {
            if (option.parent) {
                if (!(this.tree[option.parent])) {
                    this.tree[option.parent] = [];
                }
                this.tree[option.parent].push(option);
            }
        });
    }
    getNodesWithParent(parent) {
        return this.options.filter((oo) => oo.parent === parent);
    }
    appendOptionRecurse(b, option, level) {
        const children = this.getNodesWithParent(option.value);
        let treeClass = 'tree-branch';
        let buttonClass = 'expander';
        if (option.format === 'library' && children.length > 0) {
            if (this.persistControls && option.expanded) {
                buttonClass += ' expanded icon-minus';
            }
            if (this.persistControls && !option.expanded) {
                buttonClass += ' collapsed icon-plus';
                treeClass += ' collapsed';
            }
        }
        const current = b('li').classes(treeClass).attr('data-value', option.value).attr('data-level', level);
        current.append(b('button').classes(buttonClass));
        current.append(b('a').classes('tree-link').text(option.label));
        if (option.format === 'library') {
            current.append(b('span').classes('file-type icon-book'));
        }
        else {
            current.append(b('span').classes('file-type icon-file-music'));
        }
        children.forEach((child) => {
            current.append(b('ul').append(this.appendOptionRecurse(b, child, level + 1)));
        });
        return current;
    }
    _createTree(builder, ul) {
        // this.checkDefault(s, b);
        const options = this.getNodesWithParent(this.root);
        options.forEach((option) => {
            ul.append(this.appendOptionRecurse(builder, option, 0));
        });
    }
    get html() {
        const b = htmlHelpers_1.buildDom;
        const id = this.parameterId;
        const r = b('div').classes(this.makeClasses('dropdownControl smoControl')).attr('id', id).attr('data-param', this.smoName);
        const ul = b('ul').classes('tree tree-root');
        this._createTree(b, ul);
        r.append(ul);
        this.persistControls = true;
        return r;
    }
    updateOptions(options) {
        this.options = options;
        this.calculateOptionTree();
        const parentEl = $(this._getInputElement());
        const oldUl = $(parentEl).find('ul.tree-root');
        $(oldUl).remove();
        const b = htmlHelpers_1.buildDom;
        const ul = b('ul').classes('tree tree-root');
        this._createTree(b, ul);
        $(parentEl).append(ul.dom());
        this.bind();
    }
    _getInputElement() {
        var pid = this.parameterId;
        return $(this.dialog.dgDom.element).find('#' + pid);
    }
    getValue() {
        return this.value;
    }
    setValue(value) {
        $('ul.tree li').removeClass('selected');
        const option = this.options.find((o) => o.value === value);
        const input = this._getInputElement();
        const li = $(input).find('li[data-value="' + value + '"]');
        $(li).addClass('selected');
        if (option && option.format === 'library') {
            $(li).find('button').first().addClass('expanded icon-minus');
        }
        this.bindTreeControls();
    }
    bindTreeControls() {
        $('ul.tree button.expanded').off('click').on('click', (evt) => {
            const button = evt.currentTarget;
            $(button).removeClass('expanded').removeClass('icon-minus').addClass('icon-plus').addClass('collapsed');
            $(button).closest('li').addClass('collapsed');
            this.bindTreeControls();
        });
        $('ul.tree button.collapsed').off('click').on('click', (evt) => {
            const button = evt.currentTarget;
            $(button).addClass('expanded').addClass('icon-minus').removeClass('icon-plus').removeClass('collapsed');
            $(button).closest('li').removeClass('collapsed');
            this.bindTreeControls();
        });
    }
    bind() {
        const input = this._getInputElement();
        this.bindTreeControls();
        $(input).find('a.tree-link').each((ix, el) => {
            $(el).removeClass('selected');
            $(el).off('click').on('click', (ev) => {
                $(this._getInputElement()).find('li').removeClass('selected');
                const li = $(ev.currentTarget).closest('li.tree-branch');
                $(li).addClass('selected');
                this.value = $(li).attr('data-value');
                this.handleChanged();
            });
        });
    }
}
exports.SuiTreeComponent = SuiTreeComponent;


/***/ }),

/***/ "./src/ui/dialogs/dialog.ts":
/*!**********************************!*\
  !*** ./src/ui/dialogs/dialog.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createAndDisplayDialog = exports.dialogConstructor = exports.SuiDialogBase = void 0;
// [Smoosic](https://github.com/AaronDavidNewman/Smoosic)
// Copyright (c) Aaron David Newman 2021.
const svgHelpers_1 = __webpack_require__(/*! ../../render/sui/svgHelpers */ "./src/render/sui/svgHelpers.ts");
const htmlHelpers_1 = __webpack_require__(/*! ../../common/htmlHelpers */ "./src/common/htmlHelpers.ts");
const baseComponent_1 = __webpack_require__(/*! ./components/baseComponent */ "./src/ui/dialogs/components/baseComponent.ts");
/**
 * Note: Most dialogs will inherit from SuiDialogAdapter, not SuiDialogBase.
 * You will only want to inherit from SuiDialogBase under 2 conditions:
 * 1. the dialog is triviailly simple, like an alert box that makes no changes to the score, or
 * 2. the dialog is extremely complicated in how it interacts with the user, such that a form-based approach won't work
 * @category SuiDialog
 */
class SuiDialogBase extends baseComponent_1.SuiDialogNotifier {
    // ### SuiDialogBase ctor
    // Creates the DOM element for the dialog and gets some initial elements
    constructor(dialogElements, parameters) {
        super();
        this.components = [];
        this.boundComponents = [];
        this.cmap = {};
        this.staticText = [];
        this.displayOptions = ['BINDCOMPONENTS', 'DRAGGABLE', 'KEYBOARD_CAPTURE', 'GLOBALPOS', 'HIDEREMOVE'];
        this.keydownHandler = null;
        this.id = parameters.id;
        this.boundKeyboard = false;
        this.scroller = parameters.view.tracker.scroller;
        this.label = dialogElements.label;
        this.eventSource = parameters.eventSource;
        this.view = parameters.view;
        this.completeNotifier = parameters.completeNotifier;
        this.modifier = parameters.modifier;
        this.ctor = parameters.ctor;
        this.closeDialogPromise = new Promise((resolve) => {
            $('body').off('dialogDismiss').on('dialogDismiss', () => {
                resolve();
            });
        });
        this.staticText = dialogElements.staticText;
        // If this dialog was spawned by a menu, wait for the menu to dismiss
        // before continuing.
        // this.startPromise = parameters.closeMenuPromise;
        this.startPromise = parameters.startPromise;
        this.dialogElements = dialogElements;
        const left = $('.musicRelief').offset().left + $('.musicRelief').width() / 2;
        const top = $('.musicRelief').offset().top + $('.musicRelief').height() / 2;
        this.dgDom = this._constructDialog(dialogElements, {
            id: 'dialog-' + this.id,
            top,
            left,
            label: this.label
        });
        // SmoTranslator.registerDialog(this.ctor);
    }
    static get displayOptions() {
        return {
            BINDCOMPONENTS: 'bindComponents', DRAGGABLE: 'makeDraggable',
            KEYBOARD_CAPTURE: 'captureKeyboardPromise', GLOBALPOS: 'positionGlobally',
            SELECTIONPOS: 'positionFromSelection', MODIFIERPOS: 'positionFromModifier',
            HIDEREMOVE: 'hideRemoveButton'
        };
    }
    // ### printXlate
    // print json with string labels to use as a translation file seed.
    static printTranslate(_class) {
        const output = [];
        const xx = eval('globalThis.Smo.' + _class);
        xx.dialogElements.elements.forEach((element) => {
            var _a;
            const component = {};
            if (element.label) {
                component.label = (_a = element.label) !== null && _a !== void 0 ? _a : '';
                component.id = element.smoName;
                if (element.options) {
                    component.options = [];
                    element.options.forEach((option) => {
                        component.options.push({ value: option.value, label: option.label });
                    });
                }
                output.push(component);
            }
        });
        // convert static text from an array of name/value pairs to a record for translation
        const staticText = {};
        const dialogStaticText = xx.dialogElements.staticText;
        if (dialogStaticText) {
            dialogStaticText.forEach((st) => {
                const key = Object.keys(st)[0];
                staticText[key] = st[key];
            });
        }
        return { ctor: xx.ctor, label: xx.dialogElements.label, dialogElements: output, staticText };
    }
    static getStaticText(staticText) {
        const rv = {};
        staticText.forEach((st) => {
            const key = Object.keys(st)[0];
            rv[key] = st[key];
        });
        return rv;
    }
    // ### display
    // make3 the modal visible.  bind events and elements.
    display() {
        $('body').addClass('showAttributeDialog');
        this.bindComponents();
        this.bindElements();
        this.applyDisplayOptions();
        this.initialValue();
    }
    // ### bindElements
    // bing the generic controls in most dialogs.
    bindElements() {
        var dgDom = this.dgDom;
        $(dgDom.element).find('.ok-button').off('click').on('click', () => {
            this.view.groupUndo(false);
            this.commit();
            this.complete();
        });
        $(dgDom.element).find('.cancel-button').off('click').on('click', () => {
            this.view.groupUndo(false);
            if (this.modifier) {
                this.modifier.cancel();
            }
            this.complete();
        });
        $(dgDom.element).find('.remove-button').off('click').on('click', () => {
            this.view.groupUndo(false);
            this.complete();
        });
    }
    bindComponents() {
        this.components.forEach((component) => {
            component.bind();
        });
    }
    initialValue() {
        if (this.modifier === null) {
            return;
        }
        this.boundComponents.forEach((comp) => {
            comp.setValue(this.modifier[comp.smoName]);
        });
    }
    changed() {
        if (this.modifier === null) {
            return;
        }
        this.boundComponents.forEach((comp) => {
            if (comp.changeFlag) {
                this.modifier[comp.smoName] = comp.getValue();
            }
        });
    }
    getId() {
        return this.id;
    }
    getModifier() {
        var _a;
        return (_a = this.modifier) !== null && _a !== void 0 ? _a : null;
    }
    getEventSource() {
        return this.eventSource;
    }
    getStaticText() {
        return SuiDialogBase.getStaticText(this.staticText);
    }
    commit() {
    }
    get closeModalPromise() {
        return this.closeDialogPromise;
    }
    // ### position
    // For dialogs based on selections, tries to place the dialog near the selection and also
    // to scroll so the dialog is in view
    static position(box, dgDom, scroller) {
        let y = (box.y + box.height) - scroller.netScroll.y;
        let x = 0;
        // TODO: adjust if db is clipped by the browser.
        const dge = $(dgDom.element).find('.attributeModal');
        const dgeHeight = $(dge).height();
        const maxY = $('.musicRelief').height();
        const maxX = $('.musicRelief').width();
        const offset = $('.dom-container').offset();
        y = y - offset.top;
        const offsetY = dgeHeight + y > window.innerHeight ? (dgeHeight + y) - window.innerHeight : 0;
        y = (y < 0) ? -y : y - offsetY;
        y = (y > maxY || y < 0) ? maxY / 2 : y;
        $(dge).css('top', '' + y + 'px');
        x = box.x - scroller.netScroll.x;
        x = x - offset.left;
        const w = $(dge).width();
        x = (x > window.innerWidth / 2) ? x - (w + 25) : x + (w + 25);
        x = (x < 0 || x > maxX) ? maxX / 2 : x;
        $(dge).css('left', '' + x + 'px');
    }
    getView() {
        return this.view;
    }
    applyDisplayOptions() {
        $('body').addClass('showAttributeDialog');
        this.displayOptions.forEach((option) => {
            this[SuiDialogBase.displayOptions[option]]();
        });
    }
    // ### position
    // Position the dialog near a selection.  If the dialog is not visible due
    // to scrolling, make sure it is visible.
    position(box) {
        SuiDialogBase.position(box, this.dgDom, this.view.tracker.scroller);
    }
    hideRemoveButton() {
        $(this.dgDom.element).find('.remove-button').remove();
    }
    // ### positionModifier()
    positionFromModifier() {
        if (this.modifier === null || this.modifier.logicalBox === null) {
            this.positionGlobally();
            return;
        }
        const pageContext = this.view.renderer.pageMap.getRendererFromModifier(this.modifier);
        const screenBox = this.view.renderer.pageMap.svgToClient(this.modifier.logicalBox);
        this.position(screenBox);
    }
    // ### positionGlobally
    // position the dialog box in the center of the current scroll region
    positionGlobally() {
        const box = svgHelpers_1.SvgHelpers.boxPoints(250, 250, 1, 1);
        SuiDialogBase.position(box, this.dgDom, this.view.tracker.scroller);
    }
    // ### postionFromSelection
    // set initial position of dialog based on first selection
    positionFromSelection() {
        const note = this.view.tracker.selections[0].note;
        if (note && note.logicalBox) {
            const screenBox = this.view.renderer.pageMap.svgToClient(note.logicalBox);
            this.position(screenBox);
        }
    }
    // ### build the html for the dialog, based on the instance-specific components.
    _constructDialog(dialogElements, parameters) {
        (0, htmlHelpers_1.createTopDomContainer)('.attributeDialog');
        const id = parameters.id;
        const b = htmlHelpers_1.buildDom;
        const r = b('div').classes('attributeModal').attr('id', 'attr-modal-' + id)
            .css('top', parameters.top + 'px').css('left', parameters.left + 'px')
            .append(b('spanb').classes('draggable button').append(b('span').classes('icon icon-move jsDbMove')))
            .append(b('h2').classes('dialog-label').text(this.label));
        var ctrl = b('div').classes('smoControlContainer');
        dialogElements.elements.filter((de) => de.control).forEach((de) => {
            let ctor = null;
            if (typeof (de.control) === 'function') {
                ctor = de.control;
            }
            else {
                ctor = eval('globalThis.Smo.' + de.control);
            }
            const classes = de.classes ? de.classes : '';
            const compParams = Object.assign({ classes, id: id + de.smoName }, de);
            const control = new ctor(this, compParams);
            this.components.push(control);
            this.cmap[de.smoName + 'Ctrl'] = control;
            ctrl.append(control.html);
        });
        r.append(ctrl);
        r.append(b('div').classes('buttonContainer').append(b('button').classes('ok-button button-left').text('OK')).append(b('button').classes('cancel-button button-center').text('Cancel')).append(b('button').classes('remove-button button-right').text('Remove').append(b('span').classes('icon icon-cancel-circle'))));
        $('.attributeDialog').html('');
        $('.attributeDialog').append(r.dom());
        const trapper = new htmlHelpers_1.InputTrapper('.attributeDialog');
        trapper.trap();
        $('.attributeDialog').find('.cancel-button').focus();
        return {
            element: $('.attributeDialog'),
            trapper
        };
    }
    // ### Complete
    // Dialogs take over the keyboard, so release that and trigger an event
    // that the dialog is closing that can resolve any outstanding promises.
    complete() {
        if (this.boundKeyboard && this.keydownHandler) {
            this.eventSource.unbindKeydownHandler(this.keydownHandler);
        }
        $('body').removeClass('showAttributeDialog');
        $('body').trigger('dialogDismiss');
        this.dgDom.trapper.close();
    }
    // ### makeDraggable
    // generic code to make the dialog box draggable so it doesn't
    // get in front of stuff.
    makeDraggable() {
        (0, htmlHelpers_1.createTopDomContainer)('.draganime');
        const cb = () => { };
        (0, htmlHelpers_1.draggable)({
            parent: $(this.dgDom.element).find('.attributeModal'),
            handle: $(this.dgDom.element).find('.jsDbMove'),
            animateDiv: '.draganime',
            cb,
            moveParent: true
        });
    }
    // ### captureKeyboardPromise
    // capture keyboard events until the dialog closes,
    // then give control back to the current keyboard
    captureKeyboardPromise() {
        if (!(this.startPromise)) {
            this.completeNotifier.unbindKeyboardForModal(this);
            this.bindKeyboard();
            return;
        }
        const getKeys = () => {
            this.completeNotifier.unbindKeyboardForModal(this);
            this.bindKeyboard();
        };
        if (this.startPromise) {
            this.startPromise.then(getKeys);
        }
    }
    // ### handleKeydown
    // allow a dialog to be dismissed by esc.
    evKey(evdata) {
        if (evdata.key === 'Escape') {
            $(this.dgDom.element).find('.cancel-button').click();
            evdata.preventDefault();
        }
    }
    // ### bindKeyboard
    // generic logic to grab keyboard elements for modal
    bindKeyboard() {
        this.boundKeyboard = true;
        this.keydownHandler = this.eventSource.bindKeydownHandler(this, 'evKey');
    }
}
exports.SuiDialogBase = SuiDialogBase;
function dialogConstructor(type, parameters) {
    return new type(parameters);
}
exports.dialogConstructor = dialogConstructor;
function createAndDisplayDialog(ctor, parameters) {
    const instance = dialogConstructor(ctor, parameters);
    instance.display();
    return instance;
}
exports.createAndDisplayDialog = createAndDisplayDialog;


/***/ }),

/***/ "./src/ui/dialogs/dynamics.ts":
/*!************************************!*\
  !*** ./src/ui/dialogs/dynamics.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SuiDynamicModifierDialog = exports.SuiDynamicDialogAdapter = void 0;
const noteModifiers_1 = __webpack_require__(/*! ../../smo/data/noteModifiers */ "./src/smo/data/noteModifiers.ts");
const adapter_1 = __webpack_require__(/*! ./adapter */ "./src/ui/dialogs/adapter.ts");
class SuiDynamicDialogAdapter extends adapter_1.SuiComponentAdapter {
    constructor(view, modifier) {
        super(view);
        this.modifier = modifier;
        this.backup = new noteModifiers_1.SmoDynamicText(this.modifier);
        this.selection = this.view.tracker.modifierSelections[0].selection;
    }
    cancel() {
        this.view.addDynamic(this.selection, this.backup);
    }
    commit() { }
    get xOffset() {
        return this.modifier.xOffset;
    }
    remove() {
        this.view.removeDynamic(this.modifier);
    }
    set xOffset(value) {
        this.modifier.xOffset = value;
        this.view.addDynamic(this.selection, this.modifier);
    }
    get fontSize() {
        return this.modifier.fontSize;
    }
    set fontSize(value) {
        this.modifier.fontSize = value;
        this.view.addDynamic(this.selection, this.modifier);
    }
    get yOffsetLine() {
        return this.modifier.yOffsetLine;
    }
    set yOffsetLine(value) {
        this.modifier.yOffsetLine = value;
        this.view.addDynamic(this.selection, this.modifier);
    }
    get yOffsetPixels() {
        return this.modifier.yOffsetPixels;
    }
    set yOffsetPixels(value) {
        this.modifier.yOffsetPixels = value;
        this.view.addDynamic(this.selection, this.modifier);
    }
    get text() {
        return this.modifier.text;
    }
    set text(value) {
        this.modifier.text = value;
        this.view.addDynamic(this.selection, this.modifier);
    }
}
exports.SuiDynamicDialogAdapter = SuiDynamicDialogAdapter;
// ## SuiDynamicModifierDialog
// This is a poorly named class, it just allows you to placeText
// dynamic text so it doesn't collide with something.
class SuiDynamicModifierDialog extends adapter_1.SuiDialogAdapterBase {
    constructor(parameters) {
        const adapter = new SuiDynamicDialogAdapter(parameters.view, parameters.modifier);
        super(SuiDynamicModifierDialog.dialogElements, Object.assign({ adapter }, parameters));
        this.view.groupUndo(true);
        this.displayOptions = ['BINDCOMPONENTS', 'DRAGGABLE', 'KEYBOARD_CAPTURE', 'MODIFIERPOS'];
    }
}
exports.SuiDynamicModifierDialog = SuiDynamicModifierDialog;
SuiDynamicModifierDialog.dialogElements = {
    label: 'Dynamics Properties', elements: [{
            smoName: 'yOffsetLine',
            defaultValue: 11,
            control: 'SuiRockerComponent',
            label: 'Y Line'
        }, {
            smoName: 'yOffsetPixels',
            defaultValue: 0,
            control: 'SuiRockerComponent',
            label: 'Y Offset Px'
        }, {
            smoName: 'xOffset',
            defaultValue: 0,
            control: 'SuiRockerComponent',
            label: 'X Offset'
        }, {
            smoName: 'text',
            defaultValue: noteModifiers_1.SmoDynamicText.dynamics.P,
            options: [{
                    value: noteModifiers_1.SmoDynamicText.dynamics.P,
                    label: 'Piano'
                }, {
                    value: noteModifiers_1.SmoDynamicText.dynamics.PP,
                    label: 'Pianissimo'
                }, {
                    value: noteModifiers_1.SmoDynamicText.dynamics.MP,
                    label: 'Mezzo-Piano'
                }, {
                    value: noteModifiers_1.SmoDynamicText.dynamics.MF,
                    label: 'Mezzo-Forte'
                }, {
                    value: noteModifiers_1.SmoDynamicText.dynamics.F,
                    label: 'Forte'
                }, {
                    value: noteModifiers_1.SmoDynamicText.dynamics.FF,
                    label: 'Fortissimo'
                }, {
                    value: noteModifiers_1.SmoDynamicText.dynamics.SFZ,
                    label: 'Sforzando'
                }],
            control: 'SuiDropdownComponent',
            label: 'Text'
        }],
    staticText: []
};


/***/ }),

/***/ "./src/ui/dialogs/factory.ts":
/*!***********************************!*\
  !*** ./src/ui/dialogs/factory.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SuiModifierDialogFactory = exports.isModifierWithDialog = exports.ModifiersWithDialogNames = void 0;
const dialog_1 = __webpack_require__(/*! ./dialog */ "./src/ui/dialogs/dialog.ts");
const hairpin_1 = __webpack_require__(/*! ./hairpin */ "./src/ui/dialogs/hairpin.ts");
const slur_1 = __webpack_require__(/*! ./slur */ "./src/ui/dialogs/slur.ts");
const volta_1 = __webpack_require__(/*! ./volta */ "./src/ui/dialogs/volta.ts");
const lyric_1 = __webpack_require__(/*! ./lyric */ "./src/ui/dialogs/lyric.ts");
const tie_1 = __webpack_require__(/*! ./tie */ "./src/ui/dialogs/tie.ts");
const dynamics_1 = __webpack_require__(/*! ./dynamics */ "./src/ui/dialogs/dynamics.ts");
const textBlock_1 = __webpack_require__(/*! ./textBlock */ "./src/ui/dialogs/textBlock.ts");
const textBracket_1 = __webpack_require__(/*! ./textBracket */ "./src/ui/dialogs/textBracket.ts");
exports.ModifiersWithDialogNames = ['SmoStaffHairpin', 'SmoTie', 'SmoSlur', 'SmoDynamicText', 'SmoVolta',
    'SmoScoreText', 'SmoLoadScore', 'SmoLyric', 'SmoTextGroup', 'SmoStaffTextBracket'];
function isModifierWithDialog(modifier) {
    return exports.ModifiersWithDialogNames.indexOf(modifier.attrs.type) >= 0;
}
exports.isModifierWithDialog = isModifierWithDialog;
/**
 * Dialogs bound to selectable elements like slurs, dynamics, are created
 * directly from a button/menu option
 * @category SuiDialog
 */
class SuiModifierDialogFactory {
    static createModifierDialog(modifier, parameters) {
        if (!isModifierWithDialog(modifier)) {
            return null;
        }
        const ctor = modifier.attrs.type;
        parameters.modifier = modifier;
        if (ctor === 'SmoStaffHairpin') {
            return (0, dialog_1.createAndDisplayDialog)(hairpin_1.SuiHairpinAttributesDialog, parameters);
        }
        else if (ctor === 'SmoTie') {
            return (0, dialog_1.createAndDisplayDialog)(tie_1.SuiTieAttributesDialog, parameters);
        }
        else if (ctor === 'SmoSlur') {
            return (0, dialog_1.createAndDisplayDialog)(slur_1.SuiSlurAttributesDialog, parameters);
        }
        else if (ctor === 'SmoDynamicText') {
            return (0, dialog_1.createAndDisplayDialog)(dynamics_1.SuiDynamicModifierDialog, parameters);
        }
        else if (ctor === 'SmoVolta') {
            return (0, dialog_1.createAndDisplayDialog)(volta_1.SuiVoltaAttributeDialog, parameters);
        }
        else if (ctor === 'SmoTextGroup') {
            return (0, dialog_1.createAndDisplayDialog)(textBlock_1.SuiTextBlockDialog, parameters);
        }
        else if (ctor === 'SmoStaffTextBracket') {
            return (0, dialog_1.createAndDisplayDialog)(textBracket_1.SuiTextBracketDialog, parameters);
        }
        else {
            return (0, dialog_1.createAndDisplayDialog)(lyric_1.SuiLyricDialog, parameters);
        }
    }
}
exports.SuiModifierDialogFactory = SuiModifierDialogFactory;


/***/ }),

/***/ "./src/ui/dialogs/fileDialogs.ts":
/*!***************************************!*\
  !*** ./src/ui/dialogs/fileDialogs.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SuiSaveMidiDialog = exports.SuiMidiSaveAdapter = exports.SuiSaveXmlDialog = exports.SuiXmlSaveAdapter = exports.SuiSaveFileDialog = exports.SuiSmoSaveAdapter = exports.SuiPrintFileDialog = exports.SuiLoadMidiDialog = exports.SuiMidiLoadAdapter = exports.SuiLoadMxmlDialog = exports.SuiXmlLoadAdapter = exports.SuiLoadFileDialog = exports.SuiSmoLoadAdapter = void 0;
// [Smoosic](https://github.com/AaronDavidNewman/Smoosic)
// Copyright (c) Aaron David Newman 2021.
const dialog_1 = __webpack_require__(/*! ./dialog */ "./src/ui/dialogs/dialog.ts");
const score_1 = __webpack_require__(/*! ../../smo/data/score */ "./src/smo/data/score.ts");
const xmlToSmo_1 = __webpack_require__(/*! ../../smo/mxml/xmlToSmo */ "./src/smo/mxml/xmlToSmo.ts");
const smoToXml_1 = __webpack_require__(/*! ../../smo/mxml/smoToXml */ "./src/smo/mxml/smoToXml.ts");
const adapter_1 = __webpack_require__(/*! ./adapter */ "./src/ui/dialogs/adapter.ts");
const htmlHelpers_1 = __webpack_require__(/*! ../../common/htmlHelpers */ "./src/common/htmlHelpers.ts");
const smoToMidi_1 = __webpack_require__(/*! ../../smo/midi/smoToMidi */ "./src/smo/midi/smoToMidi.ts");
const midiToSmo_1 = __webpack_require__(/*! ../../smo/midi/midiToSmo */ "./src/smo/midi/midiToSmo.ts");
/**
 * internal state of FileLoadDialog is just the string for the filename.
 * @category SuiDialog
 */
class SuiSmoLoadAdapter extends adapter_1.SuiComponentAdapter {
    constructor(view) {
        super(view);
        this.jsonFile = '';
    }
    get loadFile() {
        return this.jsonFile;
    }
    set loadFile(value) {
        this.jsonFile = value;
    }
    commit() {
        let scoreWorks = false;
        if (this.jsonFile.length > 0) {
            try {
                const score = score_1.SmoScore.deserialize(this.jsonFile);
                scoreWorks = true;
                this.view.changeScore(score);
            }
            catch (e) {
                console.warn('unable to score ' + e);
            }
        }
    }
    cancel() { }
}
exports.SuiSmoLoadAdapter = SuiSmoLoadAdapter;
/**
 * Load a SMO JSON file
 * @category SuiDialog
 */
class SuiLoadFileDialog extends adapter_1.SuiDialogAdapterBase {
    constructor(parameters) {
        const adapter = new SuiSmoLoadAdapter(parameters.view);
        parameters.ctor = 'SuiLoadFileDialog';
        super(SuiLoadFileDialog.dialogElements, Object.assign({ adapter }, parameters));
        this.modifier = adapter;
    }
    get loadFileCtrl() {
        return this.cmap['loadFileCtrl'];
    }
    changed() {
        super.changed();
        const enable = this.modifier.loadFile.length < 1;
        $(this.dgDom.element).find('.ok-button').prop('disabled', enable);
    }
    commit() {
        this.modifier.commit();
    }
}
exports.SuiLoadFileDialog = SuiLoadFileDialog;
SuiLoadFileDialog.dialogElements = {
    label: 'Load File',
    elements: [{
            smoName: 'loadFile',
            defaultValue: '',
            control: 'SuiFileDownloadComponent',
            label: ''
        }
    ],
    staticText: []
};
/**
 * internal state of FileLoadDialog is just the string for the filename.
 * @category SuiDialog
 */
class SuiXmlLoadAdapter extends adapter_1.SuiComponentAdapter {
    constructor(view) {
        super(view);
        this.xmlFile = '';
        this.changeScore = false;
    }
    get loadFile() {
        return this.xmlFile;
    }
    set loadFile(value) {
        this.xmlFile = value;
    }
    commit() {
        try {
            const self = this;
            const parser = new DOMParser();
            const xml = parser.parseFromString(this.xmlFile, 'text/xml');
            const score = xmlToSmo_1.XmlToSmo.convert(xml);
            score.layoutManager.zoomToWidth($('body').width());
            this.changeScore = true;
            this.view.changeScore(score);
        }
        catch (e) {
            console.warn('unable to score ' + e);
        }
    }
    cancel() { }
}
exports.SuiXmlLoadAdapter = SuiXmlLoadAdapter;
/**
 * Load a music XML file
 * @category SuiDialog
 */
class SuiLoadMxmlDialog extends adapter_1.SuiDialogAdapterBase {
    constructor(parameters) {
        parameters.ctor = 'SuiLoadMxmlDialog';
        const adapter = new SuiXmlLoadAdapter(parameters.view);
        super(SuiLoadMxmlDialog.dialogElements, Object.assign({ adapter }, parameters));
    }
    changed() {
        super.changed();
        const enable = this.adapter.loadFile.length < 1;
        $(this.dgDom.element).find('.ok-button').prop('disabled', enable);
    }
}
exports.SuiLoadMxmlDialog = SuiLoadMxmlDialog;
SuiLoadMxmlDialog.dialogElements = {
    label: 'Load File',
    elements: [{
            smoName: 'loadFile',
            defaultValue: '',
            control: 'SuiFileDownloadComponent',
            label: ''
        },
    ],
    staticText: []
};
/**
 * internal state of FileLoadDialog is just the string for the filename.
 * @category SuiDialog
 */
class SuiMidiLoadAdapter extends adapter_1.SuiComponentAdapter {
    constructor(view) {
        super(view);
        this.midiFile = null;
        this.changeScore = false;
        this.quantize = midiToSmo_1.MidiToSmo.quantizeTicksDefault;
    }
    get loadFile() {
        return this.midiFile;
    }
    set loadFile(value) {
        this.midiFile = value;
    }
    get quantizeDuration() {
        return this.quantize;
    }
    set quantizeDuration(value) {
        this.quantize = value;
    }
    commit() {
        try {
            // midi parser expects data in UintArray form
            const ar = new Uint8Array(this.midiFile);
            const midi = parseMidi(ar);
            const midiParser = new midiToSmo_1.MidiToSmo(midi, this.quantize);
            this.view.changeScore(midiParser.convert());
        }
        catch (e) {
            console.warn('unable to score ' + e);
        }
    }
    cancel() { }
}
exports.SuiMidiLoadAdapter = SuiMidiLoadAdapter;
class SuiLoadMidiDialog extends adapter_1.SuiDialogAdapterBase {
    constructor(parameters) {
        parameters.ctor = 'SuiLoadMidiDialog';
        const adapter = new SuiMidiLoadAdapter(parameters.view);
        super(SuiLoadMidiDialog.dialogElements, Object.assign({ adapter }, parameters));
    }
    changed() {
        var _a, _b;
        super.changed();
        const enable = ((_b = (_a = this.adapter) === null || _a === void 0 ? void 0 : _a.loadFile) === null || _b === void 0 ? void 0 : _b.length) < 1;
        $(this.dgDom.element).find('.ok-button').prop('disabled', enable);
    }
}
exports.SuiLoadMidiDialog = SuiLoadMidiDialog;
SuiLoadMidiDialog.dialogElements = {
    label: 'Load File',
    elements: [{
            smoName: 'loadFile',
            defaultValue: '',
            control: 'SuiFileDownloadComponent',
            label: ''
        }, {
            smoName: 'quantizeDuration',
            defaultValue: score_1.SmoScore.engravingFonts.Bravura,
            control: 'SuiDropdownComponent',
            dataType: 'int',
            label: 'Quantize to:',
            options: [{
                    value: 1024,
                    label: '1/16th note'
                }, {
                    value: 512,
                    label: '1/32nd note'
                }, {
                    value: 2048,
                    label: '1/8th note'
                }]
        },
    ],
    staticText: []
};
class SuiPrintFileDialog extends dialog_1.SuiDialogBase {
    constructor(parameters) {
        parameters.ctor = 'SuiPrintFileDialog';
        super(SuiPrintFileDialog.dialogElements, parameters);
    }
    changed() { }
    bindElements() {
        const dgDom = this.dgDom;
        $(dgDom.element).find('.ok-button').off('click').on('click', () => {
            $('body').removeClass('printing');
            this.view.renderer.restoreLayoutAfterPrint();
            window.dispatchEvent(new Event('resize'));
            this.complete();
        });
        $(dgDom.element).find('.cancel-button').remove();
        $(dgDom.element).find('.remove-button').remove();
    }
    commit() { }
}
exports.SuiPrintFileDialog = SuiPrintFileDialog;
SuiPrintFileDialog.dialogElements = {
    label: 'Print Complete',
    elements: [],
    staticText: []
};
class SuiSmoSaveAdapter extends adapter_1.SuiComponentAdapter {
    constructor(view) {
        super(view);
        this.fileName = '';
        this.fileName = this.view.score.scoreInfo.name;
    }
    get saveFileName() {
        return this.fileName;
    }
    set saveFileName(value) {
        this.fileName = value;
    }
    _saveScore() {
        const json = this.view.storeScore.serialize();
        const jsonText = JSON.stringify(json);
        if (!this.fileName.endsWith('.json')) {
            this.fileName = this.fileName + '.json';
        }
        (0, htmlHelpers_1.addFileLink)(this.fileName, jsonText, $('.saveLink'));
        $('.saveLink a')[0].click();
    }
    commit() {
        let filename = this.fileName;
        const rawFile = filename.split('.')[0];
        if (!filename) {
            filename = 'myScore.json';
        }
        if (filename.indexOf('.json') < 0) {
            filename = filename + '.json';
        }
        const scoreInfo = this.view.score.scoreInfo;
        scoreInfo.name = rawFile;
        scoreInfo.version = scoreInfo.version + 1;
        this.view.updateScoreInfo(scoreInfo);
        this._saveScore();
    }
    cancel() { }
}
exports.SuiSmoSaveAdapter = SuiSmoSaveAdapter;
class SuiSaveFileDialog extends adapter_1.SuiDialogAdapterBase {
    constructor(parameters) {
        parameters.ctor = 'SuiSaveFileDialog';
        const adapter = new SuiSmoSaveAdapter(parameters.view);
        super(SuiSaveFileDialog.dialogElements, Object.assign({ adapter }, parameters));
    }
    commit() {
        this.adapter.commit();
    }
}
exports.SuiSaveFileDialog = SuiSaveFileDialog;
SuiSaveFileDialog.dialogElements = {
    label: 'Save Score',
    elements: [{
            smoName: 'saveFileName',
            defaultValue: '',
            control: 'SuiTextInputComponent',
            label: 'File Name'
        }],
    staticText: []
};
class SuiXmlSaveAdapter extends adapter_1.SuiComponentAdapter {
    constructor(view) {
        super(view);
        this.fileName = '';
    }
    get saveFileName() {
        return this.fileName;
    }
    set saveFileName(value) {
        this.fileName = value;
    }
    _saveXml() {
        const dom = smoToXml_1.SmoToXml.convert(this.view.storeScore);
        const ser = new XMLSerializer();
        const xmlText = ser.serializeToString(dom);
        if (!this.fileName.endsWith('.xml') && !this.fileName.endsWith('.mxml')) {
            this.fileName = this.fileName + '.xml';
        }
        (0, htmlHelpers_1.addFileLink)(this.fileName, xmlText, $('.saveLink'));
        $('.saveLink a')[0].click();
    }
    commit() {
        let filename = this.fileName;
        if (!filename) {
            filename = 'myScore.xml';
        }
        if (filename.indexOf('.xml') < 0) {
            filename = filename + '.xml';
        }
        this.view.score.scoreInfo.version += 1;
        this._saveXml();
    }
    // noop
    cancel() { }
}
exports.SuiXmlSaveAdapter = SuiXmlSaveAdapter;
class SuiSaveXmlDialog extends adapter_1.SuiDialogAdapterBase {
    constructor(parameters) {
        parameters.ctor = 'SuiSaveXmlDialog';
        const adapter = new SuiXmlSaveAdapter(parameters.view);
        super(SuiSaveXmlDialog.dialogElements, Object.assign({ adapter }, parameters));
    }
    commit() {
        this.adapter.commit();
    }
}
exports.SuiSaveXmlDialog = SuiSaveXmlDialog;
SuiSaveXmlDialog.dialogElements = {
    label: 'Save Score',
    elements: [{
            smoName: 'saveFileName',
            control: 'SuiTextInputComponent',
            label: 'File Name'
        }],
    staticText: []
};
class SuiMidiSaveAdapter extends adapter_1.SuiComponentAdapter {
    constructor(view) {
        super(view);
        this.fileName = '';
    }
    get saveFileName() {
        return this.fileName;
    }
    set saveFileName(value) {
        this.fileName = value;
    }
    _saveScore() {
        const bytes = smoToMidi_1.SmoToMidi.convert(this.view.storeScore);
        if (!this.fileName.endsWith('.mid')) {
            this.fileName = this.fileName + '.mid';
        }
        (0, htmlHelpers_1.addFileLink)(this.fileName, bytes, $('.saveLink'), 'audio/midi');
        $('.saveLink a')[0].click();
    }
    commit() {
        let filename = this.fileName;
        if (!filename) {
            filename = 'myScore.mid';
        }
        if (filename.indexOf('.mid') < 0) {
            filename = filename + '.mid';
        }
        this.view.score.scoreInfo.version += 1;
        this._saveScore();
    }
    cancel() { }
}
exports.SuiMidiSaveAdapter = SuiMidiSaveAdapter;
class SuiSaveMidiDialog extends adapter_1.SuiDialogAdapterBase {
    constructor(parameters) {
        parameters.ctor = 'SuiSaveMidiDialog';
        const adapter = new SuiMidiSaveAdapter(parameters.view);
        super(SuiSaveMidiDialog.dialogElements, Object.assign({ adapter }, parameters));
    }
    commit() {
        this.adapter.commit();
    }
}
exports.SuiSaveMidiDialog = SuiSaveMidiDialog;
SuiSaveMidiDialog.dialogElements = {
    label: 'Save Score as Midi',
    elements: [{
            smoName: 'saveFileName',
            control: 'SuiTextInputComponent',
            label: 'File Name'
        }],
    staticText: []
};
/*
export class SuiSaveActionsDialog extends SuiDialogBase {
  static dialogElements =
      {
        label: 'Save Score', elements:
          [{
            smoName: 'saveFileName',
            defaultValue: '',
            control: 'SuiTextInputComponent',
            label: 'File Name'
          }],
          staticText: []
      };
      value: string;
  constructor(parameters: SuiDialogParams) {
    super(SuiSaveActionsDialog.dialogElements, parameters);
    this.value = SuiSaveActionsDialog.createName(this.view.score);
  }
  changed() {
    this.value = this.saveFileNameCtrl.getValue();
  }
  get saveFileNameCtrl() {
    return this.cmap['saveFileNameCtrl'] as SuiTextInputComponent;
  }
  commit() {
    let filename = this.value;
    if (!filename) {
      filename = 'myScore.json';
    }
    if (filename.indexOf('.json') < 0) {
      filename = filename + '.json';
    }
    this.view.score.scoreInfo.version += 1;
    this.view.saveActions(filename);
    this.complete();
  }
  display() {
    this.applyDisplayOptions();
    this.saveFileNameCtrl.setValue(this.value);
    this.bindElements();
  }
  static createName(score: SmoScore) {
    return score.scoreInfo.name + '-' + score.scoreInfo.version + '-actions.json';
  }
  static createAndDisplay(params: SuiDialogParams) {
    var dg = new SuiSaveActionsDialog(params);
    dg.display();
  }
}  */


/***/ }),

/***/ "./src/ui/dialogs/fonts.ts":
/*!*********************************!*\
  !*** ./src/ui/dialogs/fonts.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SuiScoreFontDialog = exports.SuiScoreFontAdapter = void 0;
const score_1 = __webpack_require__(/*! ../../smo/data/score */ "./src/smo/data/score.ts");
const adapter_1 = __webpack_require__(/*! ./adapter */ "./src/ui/dialogs/adapter.ts");
class SuiScoreFontAdapter extends adapter_1.SuiComponentAdapter {
    constructor(view) {
        super(view);
        this.changed = false;
        this.fonts = this.view.score.fonts;
        this.backups = JSON.parse(JSON.stringify(this.fonts));
        this.view = view;
    }
    static get defaultFont() {
        return {
            family: 'Merriweather',
            size: 14,
            weight: 'normal',
            style: 'normal'
        };
    }
    cancel() {
        if (this.changed) {
            this.fonts = this.backups;
            // This takes advantage of setter/getter side-effect
            this.engravingFont = this.engravingFont;
            this.lyricFont = this.lyricFont;
            this.chordFont = this.chordFont;
        }
    }
    commit() {
    }
    changeFont(purpose, name, fontInfo) {
        const fp = {
            name,
            purpose,
            family: fontInfo.family,
            size: fontInfo.size,
            custom: false
        };
        const fonts = this.fonts.filter((ff) => ff.purpose !== purpose);
        fonts.push(fp);
        this.fonts = fonts;
        this.changed = true;
        return fp;
    }
    toInfo(fontPurpose) {
        return Object.assign({ weight: 'normal', style: 'normal' }, fontPurpose);
    }
    getInfo(purpose) {
        const font = this.fonts.find((ff) => ff.purpose === purpose);
        if (font) {
            return this.toInfo(font);
        }
        return SuiScoreFontAdapter.defaultFont;
    }
    // Only family can be editor for engraving font, so parameter is just a string
    get engravingFont() {
        const font = this.fonts.find((ff) => ff.purpose === score_1.SmoScore.fontPurposes.ENGRAVING);
        if (font) {
            return this.toInfo(font).family;
        }
        return 'Bravura';
    }
    set engravingFont(value) {
        this.changed = true;
        const current = this.getInfo(score_1.SmoScore.fontPurposes.ENGRAVING);
        current.family = value;
        const fp = this.changeFont(score_1.SmoScore.fontPurposes.ENGRAVING, 'engraving', current);
        if ((0, score_1.isEngravingFont)(fp.family)) {
            this.view.setEngravingFontFamily(fp.family);
        }
    }
    set chordFont(fontInfo) {
        const fp = this.changeFont(score_1.SmoScore.fontPurposes.CHORDS, 'chords', fontInfo);
        this.view.setChordFont(this.toInfo(fp));
        this.changed = true;
    }
    get chordFont() {
        return this.getInfo(score_1.SmoScore.fontPurposes.CHORDS);
    }
    set lyricFont(fontInfo) {
        this.changed = true;
        const fp = this.changeFont(score_1.SmoScore.fontPurposes.LYRICS, 'lyrics', fontInfo);
        this.view.setLyricFont(this.toInfo(fp));
    }
    get lyricFont() {
        return this.getInfo(score_1.SmoScore.fontPurposes.LYRICS);
    }
}
exports.SuiScoreFontAdapter = SuiScoreFontAdapter;
class SuiScoreFontDialog extends adapter_1.SuiDialogAdapterBase {
    constructor(params) {
        const adapter = new SuiScoreFontAdapter(params.view);
        super(SuiScoreFontDialog.dialogElements, Object.assign({ adapter }, params));
        this.modifier = params.modifier;
    }
    static createAndDisplay(parameters) {
        const dg = new SuiScoreFontDialog(parameters);
        dg.display();
    }
}
exports.SuiScoreFontDialog = SuiScoreFontDialog;
// ### dialogElements
// all dialogs have elements define the controls of the dialog.
SuiScoreFontDialog.dialogElements = {
    label: 'Score Fonts', elements: [{
            smoName: 'engravingFont',
            defaultValue: score_1.SmoScore.engravingFonts.Bravura,
            control: 'SuiDropdownComponent',
            label: 'Engraving Font',
            options: [{
                    value: 'Bravura',
                    label: 'Bravura'
                }, {
                    value: 'Gonville',
                    label: 'Gonville'
                }, {
                    value: 'Petaluma',
                    label: 'Petaluma'
                }, {
                    value: 'Leland',
                    label: 'Leland'
                }]
        }, {
            smoName: 'chordFont',
            classes: 'chord-font-component',
            defaultValue: 0,
            control: 'SuiFontComponent',
            label: 'Chord Font'
        }, {
            smoName: 'lyricFont',
            classes: 'lyric-font-component',
            defaultValue: 0,
            control: 'SuiFontComponent',
            label: 'Lyric Font'
        }],
    staticText: []
};


/***/ }),

/***/ "./src/ui/dialogs/globalLayout.ts":
/*!****************************************!*\
  !*** ./src/ui/dialogs/globalLayout.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SuiGlobalLayoutDialog = exports.SuiGlobalLayoutAdapter = void 0;
// [Smoosic](https://github.com/AaronDavidNewman/Smoosic)
// Copyright (c) Aaron David Newman 2021.
const score_1 = __webpack_require__(/*! ../../smo/data/score */ "./src/smo/data/score.ts");
const scoreModifiers_1 = __webpack_require__(/*! ../../smo/data/scoreModifiers */ "./src/smo/data/scoreModifiers.ts");
const adapter_1 = __webpack_require__(/*! ./adapter */ "./src/ui/dialogs/adapter.ts");
class SuiGlobalLayoutAdapter extends adapter_1.SuiComponentAdapter {
    constructor(view) {
        super(view);
        this.changed = false;
        this.scoreLayout = this.view.score.layoutManager.globalLayout;
        this.backup = this.view.score.layoutManager.getGlobalLayout();
        this.view = view;
    }
    writeValue(attr, value) {
        if (this.scoreLayout[attr] === value) {
            return;
        }
        this.scoreLayout[attr] = value;
        this.view.setGlobalLayout(this.scoreLayout);
        this.changed = true;
    }
    get noteSpacing() {
        return this.scoreLayout.noteSpacing;
    }
    set noteSpacing(value) {
        this.writeValue('noteSpacing', value);
    }
    get pageWidth() {
        return this.scoreLayout.pageWidth;
    }
    set pageWidth(value) {
        this.writeValue('pageWidth', value);
    }
    get pageHeight() {
        return this.scoreLayout.pageHeight;
    }
    set pageHeight(value) {
        this.writeValue('pageHeight', value);
    }
    get svgScale() {
        return this.scoreLayout.svgScale;
    }
    set svgScale(value) {
        this.writeValue('svgScale', value);
    }
    get zoomScale() {
        return this.scoreLayout.zoomScale;
    }
    set zoomScale(value) {
        this.writeValue('zoomScale', value);
    }
    get maxMeasureSystem() {
        return this.scoreLayout.maxMeasureSystem;
    }
    set maxMeasureSystem(value) {
        this.writeValue('maxMeasureSystem', value);
    }
    get pageSize() {
        const sz = score_1.SmoScore.pageSizeFromDimensions(this.scoreLayout.pageWidth, this.scoreLayout.pageHeight);
        if (sz === null) {
            return 'custom';
        }
        return sz;
    }
    set pageSize(value) {
        if (value === 'custom') {
            return;
        }
        if (score_1.SmoScore.pageDimensions[value]) {
            const dims = score_1.SmoScore.pageDimensions[value];
            this.scoreLayout.pageWidth = dims.width;
            this.scoreLayout.pageHeight = dims.height;
        }
        this.view.setGlobalLayout(this.scoreLayout);
    }
    commit() { }
    cancel() {
        if (this.changed) {
            this.view.setGlobalLayout(this.backup);
        }
    }
}
exports.SuiGlobalLayoutAdapter = SuiGlobalLayoutAdapter;
// ## SuiGlobalLayoutDialog
// change editor and formatting defaults for this score.
class SuiGlobalLayoutDialog extends adapter_1.SuiDialogAdapterBase {
    constructor(params) {
        const adapter = new SuiGlobalLayoutAdapter(params.view);
        super(SuiGlobalLayoutDialog.dialogElements, Object.assign({ adapter }, params));
    }
    get dimensionControls() {
        return [this.cmap.pageSizeCtrl, this.cmap.pageWidthCtrl, this.cmap.pageHeightCtrl];
    }
    changed() {
        super.changed();
        if (this.dimensionControls.find((x) => x.changeFlag)) {
            this.initialValue();
        }
    }
}
exports.SuiGlobalLayoutDialog = SuiGlobalLayoutDialog;
SuiGlobalLayoutDialog.dialogElements = {
    label: 'Global Settings', elements: [{
            smoName: 'noteSpacing',
            defaultValue: scoreModifiers_1.SmoLayoutManager.defaults.globalLayout.noteSpacing,
            control: 'SuiRockerComponent',
            dataType: 'percent',
            label: 'Note Spacing'
        }, {
            smoName: 'pageSize',
            defaultValue: score_1.SmoScore.pageSizes[0],
            control: 'SuiDropdownComponent',
            label: 'Page Size',
            options: [
                {
                    value: 'letter',
                    label: 'Letter (Portrait)'
                }, {
                    value: 'letterLandscape',
                    label: 'Letter (Landscape)'
                }, {
                    value: 'tabloid',
                    label: 'Tabloid (11x17)'
                }, {
                    value: 'A4',
                    label: 'A4'
                }, {
                    value: 'custom',
                    label: 'Custom'
                }
            ]
        }, {
            smoName: 'pageWidth',
            defaultValue: scoreModifiers_1.SmoLayoutManager.defaults.globalLayout.pageWidth,
            control: 'SuiRockerComponent',
            label: 'Page Width (px)'
        }, {
            smoName: 'pageHeight',
            defaultValue: scoreModifiers_1.SmoLayoutManager.defaults.globalLayout.pageHeight,
            control: 'SuiRockerComponent',
            label: 'Page Height (px)'
        }, {
            smoName: 'zoomScale',
            defaultValue: scoreModifiers_1.SmoLayoutManager.defaults.globalLayout.zoomScale,
            control: 'SuiRockerComponent',
            label: '% Zoom',
            dataType: 'percent'
        }, {
            smoName: 'svgScale',
            defaultValue: scoreModifiers_1.SmoLayoutManager.defaults.globalLayout.svgScale,
            control: 'SuiRockerComponent',
            label: '% Note size',
            dataType: 'percent'
        }, {
            smoName: 'maxMeasureSystem',
            defaultValue: scoreModifiers_1.SmoLayoutManager.defaults.globalLayout.maxMeasureSystem,
            control: 'SuiRockerComponent',
            label: 'Max Measure/System (0=auto)',
            dataType: 'int'
        }],
    staticText: []
};


/***/ }),

/***/ "./src/ui/dialogs/hairpin.ts":
/*!***********************************!*\
  !*** ./src/ui/dialogs/hairpin.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SuiHairpinAttributesDialog = exports.SuiHairpinAdapter = void 0;
const staffModifiers_1 = __webpack_require__(/*! ../../smo/data/staffModifiers */ "./src/smo/data/staffModifiers.ts");
const adapter_1 = __webpack_require__(/*! ./adapter */ "./src/ui/dialogs/adapter.ts");
class SuiHairpinAdapter extends adapter_1.SuiComponentAdapter {
    constructor(view, hairpin) {
        super(view);
        this.changed = false;
        this.hairpin = hairpin;
        this.view = view;
        this.backup = new staffModifiers_1.SmoStaffHairpin(this.hairpin);
        this.backup.attrs.id = hairpin.attrs.id;
        this.backup.associatedStaff = hairpin.associatedStaff;
    }
    cancel() {
        if (this.changed) {
            this.view.addOrUpdateStaffModifier(this.hairpin, this.backup);
        }
    }
    remove() {
        this.view.removeStaffModifier(this.hairpin);
    }
    commit() {
    }
    updateValue(param, val) {
        const current = new staffModifiers_1.SmoStaffHairpin(this.hairpin);
        this.hairpin[param] = val;
        this.view.addOrUpdateStaffModifier(current, this.hairpin);
        this.changed = true;
    }
    get xOffsetLeft() {
        return this.hairpin.xOffsetLeft;
    }
    set xOffsetLeft(val) {
        this.updateValue('xOffsetLeft', val);
    }
    get xOffsetRight() {
        return this.hairpin.xOffsetRight;
    }
    set xOffsetRight(val) {
        this.updateValue('xOffsetRight', val);
    }
    get yOffset() {
        return this.hairpin.yOffset;
    }
    set yOffset(val) {
        this.updateValue('yOffset', val);
    }
    get height() {
        return this.hairpin.height;
    }
    set height(val) {
        this.updateValue('height', val);
    }
    get position() {
        return this.hairpin.position;
    }
    set position(val) {
        this.updateValue('position', val);
    }
}
exports.SuiHairpinAdapter = SuiHairpinAdapter;
class SuiHairpinAttributesDialog extends adapter_1.SuiDialogAdapterBase {
    constructor(parameters) {
        const adapter = new SuiHairpinAdapter(parameters.view, parameters.modifier);
        super(SuiHairpinAttributesDialog.dialogElements, Object.assign({ adapter }, parameters));
        this.displayOptions = ['BINDCOMPONENTS', 'DRAGGABLE', 'KEYBOARD_CAPTURE', 'MODIFIERPOS'];
    }
}
exports.SuiHairpinAttributesDialog = SuiHairpinAttributesDialog;
SuiHairpinAttributesDialog.dialogElements = {
    label: 'Hairpin Properties', elements: [{
            smoName: 'height',
            defaultValue: 10,
            control: 'SuiRockerComponent',
            label: 'Height'
        }, {
            smoName: 'yOffset',
            defaultValue: 0,
            control: 'SuiRockerComponent',
            label: 'Y Shift'
        }, {
            smoName: 'xOffsetRight',
            defaultValue: 0,
            control: 'SuiRockerComponent',
            label: 'Right Shift'
        }, {
            smoName: 'xOffsetLeft',
            defaultValue: 0,
            control: 'SuiRockerComponent',
            label: 'Left Shift'
        }],
    staticText: []
};


/***/ }),

/***/ "./src/ui/dialogs/instrument.ts":
/*!**************************************!*\
  !*** ./src/ui/dialogs/instrument.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SuiInstrumentDialog = exports.SuiInstrumentAdapter = void 0;
const staffModifiers_1 = __webpack_require__(/*! ../../smo/data/staffModifiers */ "./src/smo/data/staffModifiers.ts");
const selections_1 = __webpack_require__(/*! ../../smo/xform/selections */ "./src/smo/xform/selections.ts");
const adapter_1 = __webpack_require__(/*! ./adapter */ "./src/ui/dialogs/adapter.ts");
class SuiInstrumentAdapter extends adapter_1.SuiComponentAdapter {
    constructor(view) {
        super(view);
        this.applies = SuiInstrumentDialog.applyTo.selected;
        const selection = this.view.tracker.selections[0];
        this.instrument = new staffModifiers_1.SmoInstrument(this.view.score.getStaffInstrument(selection.selector));
        this.selections = selections_1.SmoSelection.getMeasureList(this.view.tracker.selections);
        this.selector = JSON.parse(JSON.stringify(this.selections[0].selector));
        this.backup = new staffModifiers_1.SmoInstrument(this.instrument);
    }
    writeNumParam(paramName, value) {
        this.instrument[paramName] = value;
        this.view.changeInstrument(this.instrument, this.selections);
        this.instrument = new staffModifiers_1.SmoInstrument(this.instrument);
    }
    writeStringParam(paramName, value) {
        this.instrument[paramName] = value;
        this.view.changeInstrument(this.instrument, this.selections);
        this.instrument = new staffModifiers_1.SmoInstrument(this.instrument);
    }
    get transposeIndex() {
        return this.instrument.keyOffset;
    }
    set transposeIndex(value) {
        this.writeNumParam('keyOffset', value);
    }
    get instrumentName() {
        return this.instrument.instrumentName;
    }
    get subFamily() {
        return this.instrument.instrument;
    }
    set subFamily(value) {
        this.writeStringParam('instrument', value);
    }
    set instrumentName(value) {
        this.writeStringParam('instrumentName', value);
    }
    get clef() {
        return this.instrument.clef;
    }
    set clef(value) {
        this.instrument.clef = value;
        this.view.changeInstrument(this.instrument, this.selections);
        this.instrument = new staffModifiers_1.SmoInstrument(this.instrument);
    }
    get applyTo() {
        return this.applies;
    }
    set applyTo(value) {
        this.applies = value;
        if (value === SuiInstrumentDialog.applyTo.score) {
            this.selections = selections_1.SmoSelection.selectionsToEnd(this.view.score, this.selector.staff, 0);
        }
        else if (this.applyTo === SuiInstrumentDialog.applyTo.remaining) {
            this.selections = selections_1.SmoSelection.selectionsToEnd(this.view.score, this.selector.staff, this.selector.measure);
        }
        else {
            this.selections = this.view.tracker.selections;
        }
    }
    commit() {
        this.view.changeInstrument(this.instrument, this.selections);
    }
    cancel() {
        this.view.changeInstrument(this.backup, this.selections);
    }
    remove() { }
}
exports.SuiInstrumentAdapter = SuiInstrumentAdapter;
class SuiInstrumentDialog extends adapter_1.SuiDialogAdapterBase {
    constructor(parameters) {
        const adapter = new SuiInstrumentAdapter(parameters.view);
        super(SuiInstrumentDialog.dialogElements, Object.assign({ adapter }, parameters));
    }
    static get applyTo() {
        return {
            score: 0, selected: 1, remaining: 3
        };
    }
}
exports.SuiInstrumentDialog = SuiInstrumentDialog;
// export type Clef = 'treble' | 'bass' | 'tenor' | 'alto' | 'soprano' | 'percussion'
//| 'mezzo-soprano' | 'baritone-c' | 'baritone-f' | 'subbass' | 'french';
SuiInstrumentDialog.dialogElements = {
    label: 'Instrument Properties',
    elements: [{
            smoName: 'transposeIndex',
            defaultValue: 0,
            control: 'SuiRockerComponent',
            label: 'Transpose Index (1/2 steps)',
        }, {
            smoName: 'instrumentName',
            control: 'SuiTextInputComponent',
            label: 'Name'
        }, {
            smoName: 'subFamily',
            control: 'SuiDropdownComponent',
            label: 'Sample Sound',
            options: [{
                    value: 'piano',
                    label: 'Grand Piano'
                }, {
                    value: 'bass',
                    label: 'Bass (bowed)'
                }, {
                    value: 'jazzBass',
                    label: 'Bass (plucked)'
                }, {
                    value: 'eGuitar',
                    label: 'Electric Guitar'
                }, {
                    value: 'cello',
                    label: 'Cello'
                }, {
                    value: 'violin',
                    label: 'Violin'
                }, {
                    value: 'trumpet',
                    label: 'Bb Trumpet'
                }, {
                    value: 'horn',
                    label: 'F Horn'
                }, {
                    value: 'trombone',
                    label: 'Trombone'
                }, {
                    value: 'tuba',
                    label: 'Tuba'
                }, {
                    value: 'clarinet',
                    label: 'Bb Clarinet'
                }, {
                    value: 'altoSax',
                    label: 'Eb Alto Sax'
                }, {
                    value: 'tenorSax',
                    label: 'Bb Tenor Sax'
                }, {
                    value: 'bariSax',
                    label: 'Eb Bari Sax'
                }, {
                    value: 'pad',
                    label: 'Synth Pad'
                }, {
                    value: 'percussion',
                    label: 'Percussion'
                }, {
                    value: 'none',
                    label: 'None'
                }]
        }, {
            smoName: 'clef',
            control: 'SuiDropdownComponent',
            label: 'Clef',
            options: [{
                    value: 'treble',
                    label: 'Treble'
                }, {
                    value: 'bass',
                    label: 'Bass'
                }, {
                    value: 'tenor',
                    label: 'Tenor'
                }, {
                    value: 'alto',
                    label: 'Alto'
                }, {
                    label: 'Percussion',
                    value: 'percussion'
                }]
        }, {
            smoName: 'applyTo',
            defaultValue: SuiInstrumentDialog.applyTo.score,
            dataType: 'int',
            control: 'SuiDropdownComponent',
            label: 'Apply To',
            options: [{
                    value: SuiInstrumentDialog.applyTo.score,
                    label: 'Score'
                }, {
                    value: SuiInstrumentDialog.applyTo.selected,
                    label: 'Selected Measures'
                }, {
                    value: SuiInstrumentDialog.applyTo.remaining,
                    label: 'Remaining Measures'
                }]
        }
    ],
    staticText: []
};


/***/ }),

/***/ "./src/ui/dialogs/library.ts":
/*!***********************************!*\
  !*** ./src/ui/dialogs/library.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SuiLibraryDialog = exports.SuiLibraryAdapter = void 0;
const library_1 = __webpack_require__(/*! ../fileio/library */ "./src/ui/fileio/library.ts");
const adapter_1 = __webpack_require__(/*! ./adapter */ "./src/ui/dialogs/adapter.ts");
class SuiLibraryAdapter extends adapter_1.SuiComponentAdapter {
    constructor(view, config) {
        super(view);
        this.elements = null;
        this.selectedUrl = '';
        this.libHash = {};
        this.tree = {};
        // If the selected lib is a leaf node (a score), this is the same as that
        this.selectedScore = null;
        this.config = config;
        this.topLib = new library_1.SmoLibrary({ url: this.config.libraryUrl });
        this.libHash = {};
        this.selectedLib = null;
    }
    loadPromise() {
    }
    initialize() {
        const self = this;
        return new Promise((resolve) => {
            self.topLib.load().then(() => {
                self.libHash[self.topLib.url] = self.topLib;
                resolve();
            });
        });
    }
    static addChildRecurse(options, parent, child) {
        options.push({ label: child.metadata.name, value: child.url, parent: parent.url, format: child.format, expanded: false });
        child.children.forEach((gchild) => {
            SuiLibraryAdapter.addChildRecurse(options, child, gchild);
        });
    }
    static createOptions(topLib) {
        const options = [];
        topLib.children.forEach((child) => {
            SuiLibraryAdapter.addChildRecurse(options, topLib, child);
        });
        return options;
    }
    buildTreeRecurse(children) {
        children.forEach((child) => {
            this.tree[child.url] = child;
            this.buildTreeRecurse(child.children);
        });
    }
    buildTree() {
        this.tree = {};
        this.buildTreeRecurse(this.topLib.children);
    }
    commit() {
    }
    cancel() {
    }
    loadOptions(options) {
        const self = this;
        return new Promise((resolve) => {
            if (self.selectedLib.format === 'library') {
                if (!self.selectedLib.loaded) {
                    self.selectedLib.load().then(() => {
                        const nops = SuiLibraryAdapter.createOptions(self.topLib);
                        nops.forEach((option) => {
                            options.push(option);
                        });
                        resolve();
                    });
                }
                else {
                    const nops = SuiLibraryAdapter.createOptions(self.topLib);
                    nops.forEach((option) => {
                        options.push(option);
                    });
                    resolve();
                }
            }
            else {
                self.selectedScore = this.selectedLib;
                resolve();
            }
        });
    }
    _loadScore() {
        this.view.loadRemoteScore(this.selectedScore.url);
    }
    get selectedLibrary() {
        return this.selectedLib;
    }
    get smoLibrary() {
        return this.selectedUrl;
    }
    set smoLibrary(value) {
        this.selectedUrl = value;
        this.buildTree();
        this.selectedLib = this.tree[this.selectedUrl];
        if (this.selectedLib.format !== 'library') {
            this.selectedScore = this.selectedLib;
        }
        else {
            this.selectedScore = null;
        }
    }
}
exports.SuiLibraryAdapter = SuiLibraryAdapter;
// ## SuiLibraryDialog
// Traverse the library nodes or load a score
class SuiLibraryDialog extends adapter_1.SuiDialogAdapterBase {
    constructor(parameters, dialogElements, adapter) {
        super(dialogElements, Object.assign({ adapter }, parameters));
    }
    static _createElements(topLib) {
        const elements = JSON.parse(JSON.stringify(SuiLibraryDialog.dialogElements));
        const tree = elements.elements[0];
        tree.root = topLib.url;
        tree.options = SuiLibraryAdapter.createOptions(topLib);
        return elements;
    }
    static _createAndDisplay(parameters, adapter) {
        const elements = SuiLibraryDialog._createElements(adapter.topLib);
        const dg = new SuiLibraryDialog(parameters, elements, adapter);
        dg.display();
    }
    /** Library requires a load first, so createAndDisplayDialog won't work on it */
    static createAndDisplay(parameters, config) {
        const adapter = new SuiLibraryAdapter(parameters.view, config);
        adapter.initialize().then(() => SuiLibraryDialog._createAndDisplay(parameters, adapter));
    }
    commit() {
        if (this.adapter.selectedScore !== null) {
            this.adapter._loadScore();
        }
        else {
            this.complete();
        }
    }
    get smoLibraryCtrl() {
        return this.cmap.smoLibraryCtrl;
    }
    changed() {
        const okButton = $(this.dgDom.element).find('.ok-button');
        super.changed();
        if (this.adapter.selectedLib.format === 'library') {
            $(okButton).prop('disabled', true);
            const options = [];
            this.adapter.loadOptions(options).then(() => {
                this.smoLibraryCtrl.updateOptions(options);
                $(this.smoLibraryCtrl._getInputElement()).find('li[data-value="' + this.smoLibraryCtrl.getValue() + '"] button.expander').click();
            });
        }
        else {
            $(okButton).prop('disabled', false);
        }
    }
}
exports.SuiLibraryDialog = SuiLibraryDialog;
SuiLibraryDialog.dialogElements = {
    label: 'Music Library', elements: [{
            smoName: 'smoLibrary',
            control: 'SuiTreeComponent',
            root: '',
            label: 'Selection',
            options: []
        }],
    staticText: []
};


/***/ }),

/***/ "./src/ui/dialogs/lyric.ts":
/*!*********************************!*\
  !*** ./src/ui/dialogs/lyric.ts ***!
  \*********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SuiLyricDialog = void 0;
// [Smoosic](https://github.com/AaronDavidNewman/Smoosic)
// Copyright (c) Aaron David Newman 2021.
const dialog_1 = __webpack_require__(/*! ./dialog */ "./src/ui/dialogs/dialog.ts");
class SuiLyricDialog extends dialog_1.SuiDialogBase {
    constructor(parameters) {
        super(SuiLyricDialog.dialogElements, parameters);
        this.modifier = null;
        this.verse = 0;
        this.mouseMoveHandler = null;
        this.mouseClickHandler = null;
        this.lyric = null;
        this.config = this.view.config;
        this.displayOptions = ['BINDCOMPONENTS', 'DRAGGABLE', 'KEYBOARD_CAPTURE', 'SELECTIONPOS'];
        this.originalRefreshTimer = this.config.idleRedrawTime;
        this.config.idleRedrawTime = SuiLyricDialog.idleLyricTime;
        if (this.modifier) {
            this.verse = this.modifier.verse;
        }
    }
    static get ctor() {
        return 'SuiLyricDialog';
    }
    static get idleLyricTime() {
        return 5000;
    }
    get lyricEditorCtrl() {
        return this.cmap.lyricEditorCtrl;
    }
    get fontCtrl() {
        return this.cmap.fontCtrl;
    }
    get translateYCtrl() {
        return this.cmap.translateYCtrl;
    }
    get verseCtrl() {
        return this.cmap.verseCtrl;
    }
    display() {
        super.display();
        $(this.dgDom.element).find('.smoControl').each((ix, ctrl) => {
            if (!$(ctrl).hasClass('cbLyricEdit')) {
                $(ctrl).addClass('fold-textedit');
            }
        });
        this.mouseMoveHandler = this.eventSource.bindMouseMoveHandler(this, 'mouseMove');
        this.mouseClickHandler = this.eventSource.bindMouseClickHandler(this, 'mouseClick');
        if (this.lyricEditorCtrl.session && this.lyricEditorCtrl.session.lyric) {
            const lyric = this.lyricEditorCtrl.session.lyric;
            this.fontCtrl.setValue({
                family: lyric.fontInfo.family,
                size: lyric.fontInfo.size,
                weight: 'normal'
            });
        }
    }
    setLyric(lyric) {
        this.lyric = lyric;
        this.translateYCtrl.setValue(lyric.translateY);
    }
    _focusSelection() {
        var _a, _b;
        const selection = (_a = this.lyricEditorCtrl.session) === null || _a === void 0 ? void 0 : _a.selection;
        const note = selection === null || selection === void 0 ? void 0 : selection.note;
        const box = (_b = note === null || note === void 0 ? void 0 : note.logicalBox) !== null && _b !== void 0 ? _b : null;
        if (box) {
            this.view.scroller.scrollVisibleBox(this.view.renderer.pageMap.svgToClient(box));
        }
    }
    changed() {
        this.lyricEditorCtrl.verse = parseInt(this.verseCtrl.getValue().toString(), 10);
        // TODO: make these undoable
        if (this.fontCtrl.changeFlag) {
            const fontInfo = this.fontCtrl.getValue();
            this.view.setLyricFont({ 'family': fontInfo.family, size: fontInfo.size, weight: 'normal' });
        }
        if (this.translateYCtrl && this.lyric) {
            this.lyric.translateY = this.translateYCtrl.getValue();
        }
    }
    bindElements() {
        const dgDom = this.dgDom;
        $(dgDom.element).find('.ok-button').off('click').on('click', () => {
            this._complete();
        });
        $(dgDom.element).find('.cancel-button').off('click').on('click', () => {
            this._complete();
        });
        $(dgDom.element).find('.remove-button').remove();
        this.lyricEditorCtrl.startEditSession();
    }
    // ### handleKeydown
    // allow a dialog to be dismissed by esc.
    evKey(evdata) {
        return __awaiter(this, void 0, void 0, function* () {
            if (evdata.key === 'Escape') {
                $(this.dgDom.element).find('.cancel-button').click();
                evdata.preventDefault();
            }
            else {
                if (!this.lyricEditorCtrl.running) {
                    return;
                }
                const edited = yield this.lyricEditorCtrl.evKey(evdata);
                if (edited) {
                    evdata.stopPropagation();
                }
            }
        });
    }
    _complete() {
        if (this.lyricEditorCtrl.running) {
            this.lyricEditorCtrl.endSession();
        }
        if (this.mouseMoveHandler) {
            this.eventSource.unbindMouseMoveHandler(this.mouseMoveHandler);
        }
        if (this.mouseClickHandler) {
            this.eventSource.unbindMouseClickHandler(this.mouseClickHandler);
        }
        $('body').removeClass('showAttributeDialog');
        $('body').removeClass('textEditor');
        this.config.idleRedrawTime = this.originalRefreshTimer;
        this.complete();
    }
    mouseMove(ev) {
        if (this.lyricEditorCtrl && this.lyricEditorCtrl.running) {
            this.lyricEditorCtrl.mouseMove(ev);
        }
    }
    mouseClick(ev) {
        if (this.lyricEditorCtrl && this.lyricEditorCtrl.running) {
            this.lyricEditorCtrl.mouseClick(ev);
            ev.stopPropagation();
        }
    }
}
exports.SuiLyricDialog = SuiLyricDialog;
SuiLyricDialog.dialogElements = {
    label: 'Lyric Editor', elements: [{
            smoName: 'verse',
            defaultValue: 0,
            control: 'SuiDropdownComponent',
            label: 'Verse',
            classes: 'hide-when-editing',
            startRow: true,
            options: [{
                    value: 0,
                    label: '1'
                }, {
                    value: 1,
                    label: '2'
                }, {
                    value: 2,
                    label: '3'
                }, {
                    value: 3,
                    label: '4'
                }
            ]
        }, {
            smoName: 'translateY',
            classes: 'hide-when-editing',
            defaultValue: 0,
            control: 'SuiRockerComponent',
            label: 'Y Adjustment (Px)',
            dataType: 'int'
        }, {
            smoName: 'font',
            classes: 'hide-when-editing',
            defaultValue: 0,
            control: 'SuiFontComponent',
            label: 'Font'
        }, {
            smoName: 'lyricEditor',
            defaultValue: 0,
            classes: 'show-always',
            control: 'SuiLyricComponent',
            label: 'Edit Lyrics',
            options: []
        },
    ], staticText: [
        { doneEditing: 'Done Editing Lyrics' },
        { undo: 'Undo Lyrics' },
        { label: 'Lyric Editor' }
    ]
};


/***/ }),

/***/ "./src/ui/dialogs/measureFormat.ts":
/*!*****************************************!*\
  !*** ./src/ui/dialogs/measureFormat.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SuiMeasureDialog = exports.SuiMeasureFormatAdapter = void 0;
const measureModifiers_1 = __webpack_require__(/*! ../../smo/data/measureModifiers */ "./src/smo/data/measureModifiers.ts");
const adapter_1 = __webpack_require__(/*! ./adapter */ "./src/ui/dialogs/adapter.ts");
class SuiMeasureFormatAdapter extends adapter_1.SuiComponentAdapter {
    constructor(view, measure) {
        super(view);
        this.edited = false;
        this.format = measure.format;
        this.backup = new measureModifiers_1.SmoMeasureFormat(this.format);
        this.measure = measure;
    }
    writeNumber(param, value) {
        this.format.measureIndex = this.measure.measureNumber.measureIndex;
        this.format[param] = value;
        this.view.setMeasureFormat(this.format);
        this.edited = true;
    }
    writeBoolean(param, value) {
        this.format.measureIndex = this.measure.measureNumber.measureIndex;
        this.format[param] = value;
        this.view.setMeasureFormat(this.format);
        this.edited = true;
    }
    commit() { }
    cancel() {
        if (this.edited) {
            this.view.setMeasureFormat(this.backup);
        }
    }
    get padLeft() {
        return this.format.padLeft;
    }
    set padLeft(value) {
        if (value > 0) {
            $('.attributeDialog .attributeModal').addClass('pad-left-select');
        }
        else {
            $('.attributeDialog .attributeModal').removeClass('pad-left-select');
        }
        this.writeNumber('padLeft', value);
    }
    get skipMeasureCount() {
        return this.format.skipMeasureCount;
    }
    set skipMeasureCount(value) {
        this.writeBoolean('skipMeasureCount', value);
    }
    get forceRest() {
        return this.format.forceRest;
    }
    set forceRest(value) {
        this.writeBoolean('forceRest', value);
    }
    get repeatSymbol() {
        return this.measure.repeatSymbol;
    }
    set repeatSymbol(value) {
        const repeatCount = value ? 1 : 0;
        this.view.updateRepeatCount(repeatCount);
        this.measure.repeatSymbol = value;
        this.measure.repeatCount = repeatCount;
    }
    get restBreak() {
        return this.format.restBreak;
    }
    set restBreak(value) {
        this.writeBoolean('restBreak', value);
    }
    get customStretch() {
        return this.format.customStretch;
    }
    set customStretch(value) {
        this.writeNumber('customStretch', value);
    }
    get customProportion() {
        return this.format.proportionality;
    }
    set customProportion(value) {
        this.writeNumber('proportionality', value);
    }
    get autoJustify() {
        return this.format.autoJustify;
    }
    set autoJustify(value) {
        this.writeBoolean('autoJustify', value);
    }
    get padAllInSystem() {
        return this.format.padAllInSystem;
    }
    set padAllInSystem(value) {
        this.writeBoolean('padAllInSystem', value);
    }
    get systemBreak() {
        return this.format.systemBreak;
    }
    set systemBreak(value) {
        this.writeBoolean('systemBreak', value);
    }
}
exports.SuiMeasureFormatAdapter = SuiMeasureFormatAdapter;
// ## measureDialogs.js
// This file contains dialogs that affect all measures at a certain position,
// such as tempo or time signature.
class SuiMeasureDialog extends adapter_1.SuiDialogAdapterBase {
    constructor(parameters) {
        const selection = parameters.view.tracker.selections[0];
        const measure = selection.measure;
        const adapter = new SuiMeasureFormatAdapter(parameters.view, measure);
        super(SuiMeasureDialog.dialogElements, Object.assign({ adapter }, parameters));
    }
}
exports.SuiMeasureDialog = SuiMeasureDialog;
SuiMeasureDialog.dialogElements = {
    label: 'Measure Properties',
    elements: [{
            smoName: 'padLeft',
            control: 'SuiRockerComponent',
            label: 'Pad Left (px)'
        }, {
            smoName: 'customStretch',
            control: 'SuiRockerComponent',
            label: 'Stretch Contents'
        }, {
            smoName: 'customProportion',
            control: 'SuiRockerComponent',
            increment: 10,
            label: 'Proportionalality'
        }, {
            smoName: 'padAllInSystem',
            control: 'SuiToggleComponent',
            label: 'Pad all measures in system'
        }, {
            smoName: 'autoJustify',
            control: 'SuiToggleComponent',
            label: 'Justify Columns'
        }, {
            smoName: 'restBreak',
            control: 'SuiToggleComponent',
            label: 'Break Multimeasure Rest in Part'
        }, {
            smoName: 'forceRest',
            control: 'SuiToggleComponent',
            label: 'Force Multimeasure Rest'
        }, {
            smoName: 'repeatSymbol',
            control: 'SuiToggleComponent',
            label: 'Repeat Symbol'
        }, {
            smoName: 'skipMeasureCount',
            control: 'SuiToggleComponent',
            label: 'Skip in max measure count'
        }, {
            smoName: 'systemBreak',
            control: 'SuiToggleComponent',
            label: 'System break before this measure'
        }],
    staticText: []
};


/***/ }),

/***/ "./src/ui/dialogs/newPart.ts":
/*!***********************************!*\
  !*** ./src/ui/dialogs/newPart.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SuiNewPartDialog = exports.SuiNewPartAdapter = void 0;
const staffModifiers_1 = __webpack_require__(/*! ../../smo/data/staffModifiers */ "./src/smo/data/staffModifiers.ts");
const adapter_1 = __webpack_require__(/*! ./adapter */ "./src/ui/dialogs/adapter.ts");
const systemStaff_1 = __webpack_require__(/*! ../../smo/data/systemStaff */ "./src/smo/data/systemStaff.ts");
class SuiNewPartAdapter extends adapter_1.SuiComponentAdapter {
    constructor(view) {
        super(view);
        this.alignWithPreviousVal = true;
        const selection = this.view.tracker.selections[0];
        this.instrument = new staffModifiers_1.SmoInstrument(this.view.score.getStaffInstrument(selection.selector));
    }
    writeNumParam(paramName, value) {
        this.instrument[paramName] = value;
    }
    writeStringParam(paramName, value) {
        this.instrument[paramName] = value;
    }
    set alignWithPrevious(val) {
        this.alignWithPreviousVal = val;
    }
    get alignWithPrevious() {
        return this.alignWithPreviousVal;
    }
    get transposeIndex() {
        return this.instrument.keyOffset;
    }
    set transposeIndex(value) {
        this.writeNumParam('keyOffset', value);
    }
    get instrumentName() {
        return this.instrument.instrumentName;
    }
    get subFamily() {
        return this.instrument.instrument;
    }
    set subFamily(value) {
        this.writeStringParam('instrument', value);
    }
    set instrumentName(value) {
        this.writeStringParam('instrumentName', value);
    }
    get clef() {
        return this.instrument.clef;
    }
    set clef(value) {
        this.instrument.clef = value;
    }
    commit() {
        const staffParams = systemStaff_1.SmoSystemStaff.defaults;
        staffParams.staffId = this.view.storeScore.staves.length;
        staffParams.measureInstrumentMap[0] = this.instrument;
        staffParams.alignWithPrevious = this.alignWithPreviousVal;
        this.view.addStaff(staffParams);
    }
    cancel() {
    }
    remove() { }
}
exports.SuiNewPartAdapter = SuiNewPartAdapter;
class SuiNewPartDialog extends adapter_1.SuiDialogAdapterBase {
    constructor(parameters) {
        const adapter = new SuiNewPartAdapter(parameters.view);
        super(SuiNewPartDialog.dialogElements, Object.assign({ adapter }, parameters));
    }
    static get applyTo() {
        return {
            score: 0, selected: 1, remaining: 3
        };
    }
}
exports.SuiNewPartDialog = SuiNewPartDialog;
// export type Clef = 'treble' | 'bass' | 'tenor' | 'alto' | 'soprano' | 'percussion'
//| 'mezzo-soprano' | 'baritone-c' | 'baritone-f' | 'subbass' | 'french';
SuiNewPartDialog.dialogElements = {
    label: 'Instrument Properties',
    elements: [{
            smoName: 'transposeIndex',
            defaultValue: 0,
            control: 'SuiRockerComponent',
            label: 'Transpose Index (1/2 steps)',
        }, {
            smoName: 'instrumentName',
            control: 'SuiTextInputComponent',
            label: 'Part Name'
        }, {
            smoName: 'alignWithPrevious',
            control: 'SuiToggleComponent',
            label: 'Align Notes with Previous Staff'
        }, {
            smoName: 'subFamily',
            control: 'SuiDropdownComponent',
            label: 'Sample Sound',
            options: [{
                    value: 'piano',
                    label: 'Grand Piano'
                }, {
                    value: 'bass',
                    label: 'Bass'
                }, {
                    value: 'cello',
                    label: 'Cello'
                }, {
                    value: 'violin',
                    label: 'Violin'
                }, {
                    value: 'trumpet',
                    label: 'Bb Trumpet'
                }, {
                    value: 'horn',
                    label: 'F Horn'
                }, {
                    value: 'tuba',
                    label: 'Tuba'
                }, {
                    value: 'clarinet',
                    label: 'Bb Clarinet'
                }, {
                    value: 'pad',
                    label: 'Synth Pad'
                }, {
                    value: 'percussion',
                    label: 'Percussion'
                }, {
                    value: 'none',
                    label: 'None'
                }]
        }, {
            smoName: 'clef',
            control: 'SuiDropdownComponent',
            label: 'Clef',
            options: [{
                    label: 'Treble Clef Staff',
                    value: 'treble'
                }, {
                    label: 'Bass Clef Staff',
                    value: 'bass'
                }, {
                    label: 'Alto Clef Staff',
                    value: 'alto'
                }, {
                    label: 'Tenor',
                    value: 'tenor'
                }, {
                    label: 'Percussion',
                    value: 'percussion'
                }]
        }
    ],
    staticText: []
};


/***/ }),

/***/ "./src/ui/dialogs/pageLayout.ts":
/*!**************************************!*\
  !*** ./src/ui/dialogs/pageLayout.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SuiPageLayoutDialog = exports.SuiPageLayoutAdapter = void 0;
// [Smoosic](https://github.com/AaronDavidNewman/Smoosic)
// Copyright (c) Aaron David Newman 2021.
const scoreModifiers_1 = __webpack_require__(/*! ../../smo/data/scoreModifiers */ "./src/smo/data/scoreModifiers.ts");
const adapter_1 = __webpack_require__(/*! ./adapter */ "./src/ui/dialogs/adapter.ts");
class SuiPageLayoutAdapter extends adapter_1.SuiComponentAdapter {
    constructor(view) {
        super(view);
        this.backup = [];
        this.changed = false;
        this.applyTo = SuiPageLayoutAdapter.layoutTypes.all;
        this.options = [];
        let i = 0;
        this.view = view;
        this.layoutManager = this.view.score.layoutManager;
        this.currentPage = this.view.getFocusedPage();
        for (i = 0; i < this.layoutManager.pageLayouts.length; ++i) {
            this.backup.push(new scoreModifiers_1.SmoPageLayout(this.layoutManager.pageLayouts[i]));
        }
        for (i = 1; i < this.layoutManager.pageLayouts.length; ++i) {
            this.options.push({ value: i + 1, label: 'Page ' + (i + 1) });
        }
        this.layouts = this.layoutManager.getPageLayouts();
        this.currentLayout = this.layoutManager.pageLayouts[this.currentPage];
        if (this.layoutManager.pageLayouts.length === 1) {
            this.applyTo = SuiPageLayoutAdapter.layoutTypes.all;
        }
        else {
            if (this.currentPage >= 1) {
                this.applyTo = SuiPageLayoutAdapter.layoutTypes.remaining;
            }
            else {
                this.applyTo = SuiPageLayoutAdapter.layoutTypes.all;
            }
        }
    }
    static get layoutTypes() {
        return {
            'all': -1,
            'remaining': -2,
            'page': -3
        };
    }
    updateLayouts() {
        let i = 0;
        let startPage = this.currentPage;
        let endPage = this.layouts.length;
        if (this.applyTo === SuiPageLayoutAdapter.layoutTypes.page) {
            endPage = startPage;
        }
        else if (this.applyTo === SuiPageLayoutAdapter.layoutTypes.all) {
            startPage = 0;
        }
        this.view.setPageLayouts(this.currentLayout, startPage, endPage);
        this.changed = true;
    }
    get enablePages() {
        return this.layouts.length > 1;
    }
    get applyToPage() {
        return this.applyTo;
    }
    set applyToPage(value) {
        this.applyTo = value;
        this.updateLayouts();
    }
    set leftMargin(value) {
        this.currentLayout.leftMargin = value;
        this.updateLayouts();
    }
    get leftMargin() {
        return this.currentLayout.leftMargin;
    }
    get rightMargin() {
        return this.currentLayout.rightMargin;
    }
    set rightMargin(value) {
        this.currentLayout.rightMargin = value;
        this.updateLayouts();
    }
    get topMargin() {
        return this.currentLayout.topMargin;
    }
    set topMargin(value) {
        this.currentLayout.topMargin = value;
        this.updateLayouts();
    }
    get bottomMargin() {
        return this.currentLayout.bottomMargin;
    }
    set bottomMargin(value) {
        this.currentLayout.bottomMargin = value;
        this.updateLayouts();
    }
    get interGap() {
        return this.currentLayout.interGap;
    }
    set interGap(value) {
        this.currentLayout.interGap = value;
        this.updateLayouts();
    }
    get intraGap() {
        return this.currentLayout.intraGap;
    }
    set intraGap(value) {
        this.currentLayout.intraGap = value;
        this.updateLayouts();
    }
    cancel() {
        let i = 0;
        if (!this.changed) {
            return;
        }
        for (i = 0; i < this.backup.length; ++i) {
            // Avoid multiple page rerender...
            this.view._setPageLayout(this.backup[i], i);
        }
        this.view.refreshViewport();
    }
    commit() { }
}
exports.SuiPageLayoutAdapter = SuiPageLayoutAdapter;
// ## SuiLayoutDialog
// The layout dialog has page-specific layout parameters
class SuiPageLayoutDialog extends adapter_1.SuiDialogAdapterBase {
    constructor(params) {
        const adapter = new SuiPageLayoutAdapter(params.view);
        super(SuiPageLayoutDialog.dialogElements, Object.assign({ adapter }, params));
    }
    static get layoutParams() {
        return ['leftMargin', 'rightMargin', 'topMargin', 'bottomMargin', 'interGap', 'intraGap'];
    }
}
exports.SuiPageLayoutDialog = SuiPageLayoutDialog;
// ### dialogElements
// all dialogs have elements define the controls of the dialog.
SuiPageLayoutDialog.dialogElements = {
    label: 'Page Layouts', elements: [{
            smoName: 'applyToPage',
            defaultValue: -1,
            control: 'SuiDropdownComponent',
            label: 'Apply to Page',
            dataType: 'int',
            options: [{
                    value: -1,
                    label: 'All'
                }, {
                    value: -2,
                    label: 'All Remaining'
                }, {
                    value: 1,
                    label: 'Page 1'
                }]
        }, {
            smoName: 'leftMargin',
            defaultValue: scoreModifiers_1.SmoPageLayout.defaults.leftMargin,
            control: 'SuiRockerComponent',
            label: 'Left Margin (px)'
        }, {
            smoName: 'rightMargin',
            defaultValue: scoreModifiers_1.SmoPageLayout.defaults.rightMargin,
            control: 'SuiRockerComponent',
            label: 'Right Margin (px)'
        }, {
            smoName: 'topMargin',
            defaultValue: scoreModifiers_1.SmoPageLayout.defaults.topMargin,
            control: 'SuiRockerComponent',
            label: 'Top Margin (px)'
        }, {
            smoName: 'bottomMargin',
            defaultValue: scoreModifiers_1.SmoPageLayout.defaults.bottomMargin,
            control: 'SuiRockerComponent',
            label: 'Bottom Margin (px)'
        }, {
            smoName: 'interGap',
            defaultValue: scoreModifiers_1.SmoPageLayout.defaults.interGap,
            control: 'SuiRockerComponent',
            label: 'Inter-System Margin'
        }, {
            smoName: 'intraGap',
            defaultValue: scoreModifiers_1.SmoPageLayout.defaults.intraGap,
            control: 'SuiRockerComponent',
            label: 'Intra-System Margin'
        }],
    staticText: [
        { all: 'Entire Score' },
        { remaining: 'Remaining Pages' },
        { current: 'Current Page' }
    ]
};


/***/ }),

/***/ "./src/ui/dialogs/partInfo.ts":
/*!************************************!*\
  !*** ./src/ui/dialogs/partInfo.ts ***!
  \************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SuiPartInfoDialog = exports.SuiPartInfoAdapter = void 0;
// [Smoosic](https://github.com/AaronDavidNewman/Smoosic)
// Copyright (c) Aaron David Newman 2021.
const score_1 = __webpack_require__(/*! ../../smo/data/score */ "./src/smo/data/score.ts");
const scoreModifiers_1 = __webpack_require__(/*! ../../smo/data/scoreModifiers */ "./src/smo/data/scoreModifiers.ts");
const scoreText_1 = __webpack_require__(/*! ../../smo/data/scoreText */ "./src/smo/data/scoreText.ts");
const partInfo_1 = __webpack_require__(/*! ../../smo/data/partInfo */ "./src/smo/data/partInfo.ts");
const selections_1 = __webpack_require__(/*! ../../smo/xform/selections */ "./src/smo/xform/selections.ts");
const adapter_1 = __webpack_require__(/*! ./adapter */ "./src/ui/dialogs/adapter.ts");
class SuiPartInfoAdapter extends adapter_1.SuiComponentAdapter {
    constructor(view) {
        super(view);
        this.changed = false;
        this.currentView = [];
        this.resetPart = false;
        this.currentView = this.view.getView();
        const selector = selections_1.SmoSelector.default;
        this.selection = selections_1.SmoSelection.measureSelection(this.view.score, selector.staff, selector.measure);
        this.partInfo = new partInfo_1.SmoPartInfo(this.selection.staff.partInfo);
        this.backup = new partInfo_1.SmoPartInfo(this.selection.staff.partInfo);
    }
    update() {
        return __awaiter(this, void 0, void 0, function* () {
            this.changed = true;
            // Since update will change the displayed score, wait for any display change to complete first.
            yield this.view.renderer.updatePromise();
            yield this.view.updatePartInfo(this.partInfo);
        });
    }
    writeLayoutValue(attr, value) {
        // no change?
        if (this.partInfo.layoutManager.globalLayout[attr] === value) {
            return;
        }
        this.partInfo.layoutManager.globalLayout[attr] = value;
        this.update();
    }
    writeStringValue(attr, value) {
        if (this.partInfo[attr] === value) {
            return;
        }
        this.partInfo[attr] = value;
        this.changed = true;
    }
    get expandMultimeasureRest() {
        return this.partInfo.expandMultimeasureRests;
    }
    set expandMultimeasureRest(value) {
        this.partInfo.expandMultimeasureRests = value;
        this.resetPart = true;
        this.update();
    }
    get noteSpacing() {
        return this.partInfo.layoutManager.globalLayout.noteSpacing;
    }
    set noteSpacing(value) {
        this.writeLayoutValue('noteSpacing', value);
    }
    get pageWidth() {
        return this.partInfo.layoutManager.globalLayout.pageWidth;
    }
    set pageWidth(value) {
        this.writeLayoutValue('pageWidth', value);
    }
    get pageHeight() {
        return this.partInfo.layoutManager.globalLayout.pageHeight;
    }
    set pageHeight(value) {
        this.writeLayoutValue('pageHeight', value);
    }
    get svgScale() {
        return this.partInfo.layoutManager.globalLayout.svgScale;
    }
    set svgScale(value) {
        this.writeLayoutValue('svgScale', value);
    }
    get maxMeasureSystem() {
        return this.partInfo.layoutManager.globalLayout.maxMeasureSystem;
    }
    set maxMeasureSystem(value) {
        this.writeLayoutValue('maxMeasureSystem', value);
    }
    get zoomScale() {
        return this.partInfo.layoutManager.globalLayout.zoomScale;
    }
    set zoomScale(value) {
        this.writeLayoutValue('zoomScale', value);
    }
    get pageSize() {
        const sz = score_1.SmoScore.pageSizeFromDimensions(this.partInfo.layoutManager.globalLayout.pageWidth, this.partInfo.layoutManager.globalLayout.pageHeight);
        if (sz === null) {
            return 'custom';
        }
        return sz;
    }
    set pageSize(value) {
        if (value === 'custom') {
            return;
        }
        if (score_1.SmoScore.pageDimensions[value]) {
            const dims = score_1.SmoScore.pageDimensions[value];
            this.partInfo.layoutManager.globalLayout.pageWidth = dims.width;
            this.partInfo.layoutManager.globalLayout.pageHeight = dims.height;
        }
        this.update();
    }
    get partName() {
        return this.partInfo.partName;
    }
    set partName(value) {
        this.writeStringValue('partName', value);
    }
    get partAbbreviation() {
        return this.partInfo.partAbbreviation;
    }
    set partAbbreviation(value) {
        this.writeStringValue('partAbbreviation', value);
    }
    get includeNext() {
        return this.partInfo.stavesAfter === 1 && this.partInfo.stavesBefore === 0;
    }
    set includeNext(value) {
        const oldValue = this.partInfo.stavesAfter;
        if (value) {
            this.partInfo.stavesAfter = 1;
        }
        else {
            this.partInfo.stavesAfter = 0;
        }
        if (oldValue !== this.partInfo.stavesAfter) {
            // special case for a 2-stave score.  The score and the part are the same so we stick to 
            // score view.
            if (this.partInfo.stavesAfter === 1 && this.view.storeScore.staves.length === 2) {
                this.update().then(() => {
                    this.view.viewAll();
                });
                return;
            }
        }
        this.update();
    }
    get cueInScore() {
        return this.partInfo.cueInScore;
    }
    set cueInScore(value) {
        this.partInfo.cueInScore = value;
        this.update();
    }
    get preserveTextGroups() {
        return this.partInfo.preserveTextGroups;
    }
    set preserveTextGroups(value) {
        if (value === true && this.partInfo.textGroups.length === 0) {
            this.view.score.textGroups.forEach((tg) => {
                const ngrp = scoreText_1.SmoTextGroup.deserializePreserveId(tg.serialize());
                this.partInfo.textGroups.push(ngrp);
            });
        }
        this.partInfo.preserveTextGroups = value;
        this.update();
    }
    commit() {
        if (this.changed) {
            this.update();
        }
    }
    cancel() {
        if (this.changed) {
            this.partInfo = this.backup;
            this.update();
        }
    }
}
exports.SuiPartInfoAdapter = SuiPartInfoAdapter;
// ## SuiGlobalLayoutDialog
// change editor and formatting defaults for this score.
class SuiPartInfoDialog extends adapter_1.SuiDialogAdapterBase {
    constructor(params) {
        const adapter = new SuiPartInfoAdapter(params.view);
        super(SuiPartInfoDialog.dialogElements, Object.assign({ adapter }, params));
    }
    get dimensionControls() {
        return [this.cmap.pageSizeCtrl, this.cmap.pageWidthCtrl, this.cmap.pageHeightCtrl];
    }
    changed() {
        super.changed();
        if (this.dimensionControls.find((x) => x.changeFlag)) {
            this.initialValue();
        }
        if (this.cmap.includeNextCtrl.changeFlag) {
            const includeNext = this.cmap.includeNextCtrl;
            if (includeNext.getValue()) {
                const partMap = this.view.getPartMap();
                if (this.view.storeScore.staves.length === 2) {
                    this.complete();
                }
            }
        }
    }
}
exports.SuiPartInfoDialog = SuiPartInfoDialog;
SuiPartInfoDialog.dialogElements = {
    label: 'Part Settings', elements: [{
            smoName: 'partName',
            control: 'SuiTextInputComponent',
            label: 'Part Name'
        }, {
            smoName: 'partAbbreviation',
            control: 'SuiTextInputComponent',
            label: 'Part Abbrev.'
        }, {
            smoName: 'preserveTextGroups',
            control: 'SuiToggleComponent',
            label: 'Part-specific text'
        }, {
            smoName: 'cueInScore',
            control: 'SuiToggleComponent',
            label: 'Show as Cues in score'
        }, {
            smoName: 'includeNext',
            control: 'SuiToggleComponent',
            label: 'Include Next Staff in Part'
        }, {
            smoName: 'expandMultimeasureRest',
            control: 'SuiToggleComponent',
            label: 'Expand Multimeasure Rests'
        }, {
            smoName: 'noteSpacing',
            defaultValue: scoreModifiers_1.SmoLayoutManager.defaults.globalLayout.noteSpacing,
            control: 'SuiRockerComponent',
            dataType: 'percent',
            label: 'Note Spacing'
        }, {
            smoName: 'pageSize',
            defaultValue: score_1.SmoScore.pageSizes[0],
            control: 'SuiDropdownComponent',
            label: 'Page Size',
            options: [
                {
                    value: 'letter',
                    label: 'Letter (Portrait)'
                }, {
                    value: 'letterLandscape',
                    label: 'Letter (Landscape)'
                }, {
                    value: 'tabloid',
                    label: 'Tabloid (11x17)'
                }, {
                    value: 'A4',
                    label: 'A4'
                }, {
                    value: 'custom',
                    label: 'Custom'
                }
            ]
        }, {
            smoName: 'pageWidth',
            defaultValue: scoreModifiers_1.SmoLayoutManager.defaults.globalLayout.pageWidth,
            control: 'SuiRockerComponent',
            label: 'Page Width (px)'
        }, {
            smoName: 'pageHeight',
            defaultValue: scoreModifiers_1.SmoLayoutManager.defaults.globalLayout.pageHeight,
            control: 'SuiRockerComponent',
            label: 'Page Height (px)'
        }, {
            smoName: 'zoomScale',
            defaultValue: scoreModifiers_1.SmoLayoutManager.defaults.globalLayout.zoomScale,
            control: 'SuiRockerComponent',
            label: '% Zoom',
            dataType: 'percent'
        }, {
            smoName: 'svgScale',
            defaultValue: scoreModifiers_1.SmoLayoutManager.defaults.globalLayout.svgScale,
            control: 'SuiRockerComponent',
            label: '% Note size',
            dataType: 'percent'
        }, {
            smoName: 'maxMeasureSystem',
            defaultValue: scoreModifiers_1.SmoLayoutManager.defaults.globalLayout.maxMeasureSystem,
            control: 'SuiRockerComponent',
            label: 'Max Measures/System (0=auto)',
            dataType: 'int'
        }],
    staticText: []
};


/***/ }),

/***/ "./src/ui/dialogs/preferences.ts":
/*!***************************************!*\
  !*** ./src/ui/dialogs/preferences.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SuiScorePreferencesDialog = exports.SuiScorePreferencesAdapter = void 0;
// [Smoosic](https://github.com/AaronDavidNewman/Smoosic)
// Copyright (c) Aaron David Newman 2021.
const score_1 = __webpack_require__(/*! ../../smo/data/score */ "./src/smo/data/score.ts");
const adapter_1 = __webpack_require__(/*! ./adapter */ "./src/ui/dialogs/adapter.ts");
const deepCopy = (x) => JSON.parse(JSON.stringify(x));
class SuiScorePreferencesAdapter extends adapter_1.SuiComponentAdapter {
    constructor(view) {
        super(view);
        this.preferences = new score_1.SmoScorePreferences(view.score.preferences);
        this.backup = JSON.parse(JSON.stringify(this.preferences));
    }
    get autoAdvance() {
        return this.preferences.autoAdvance;
    }
    set autoAdvance(value) {
        this.preferences.autoAdvance = value;
        this.view.updateScorePreferences(this.preferences);
    }
    get autoPlay() {
        return this.preferences.autoPlay;
    }
    set autoPlay(value) {
        this.preferences.autoPlay = value;
        this.view.updateScorePreferences(this.preferences);
    }
    get showPiano() {
        return this.preferences.showPiano;
    }
    set showPiano(value) {
        this.preferences.showPiano = value;
        this.view.updateScorePreferences(this.preferences);
    }
    get hideEmptyLines() {
        return this.preferences.hideEmptyLines;
    }
    set hideEmptyLines(value) {
        this.preferences.hideEmptyLines = value;
        this.view.updateScorePreferences(this.preferences);
    }
    get defaultDupleDuration() {
        return this.preferences.defaultDupleDuration;
    }
    set defaultDupleDuration(value) {
        this.preferences.defaultDupleDuration = value;
        this.view.updateScorePreferences(this.preferences);
    }
    get defaultTripleDuration() {
        return this.preferences.defaultTripleDuration;
    }
    set defaultTripleDuration(value) {
        this.preferences.defaultTripleDuration = value;
        this.view.updateScorePreferences(this.preferences);
    }
    get transposingScore() {
        return this.preferences.transposingScore;
    }
    set transposingScore(value) {
        this.preferences.transposingScore = value;
        this.view.updateScorePreferences(this.preferences);
    }
    cancel() {
        const p1 = JSON.stringify(this.preferences);
        const p2 = JSON.stringify(this.backup);
        if (p1 !== p2) {
            this.view.updateScorePreferences(this.backup);
        }
    }
    commit() {
    }
}
exports.SuiScorePreferencesAdapter = SuiScorePreferencesAdapter;
class SuiScorePreferencesDialog extends adapter_1.SuiDialogAdapterBase {
    constructor(params) {
        const adapter = new SuiScorePreferencesAdapter(params.view);
        super(SuiScorePreferencesDialog.dialogElements, Object.assign({ adapter }, params));
    }
}
exports.SuiScorePreferencesDialog = SuiScorePreferencesDialog;
SuiScorePreferencesDialog.dialogElements = {
    label: 'Score Preferences',
    elements: [{
            smoName: 'autoAdvance',
            control: 'SuiToggleComponent',
            label: 'Auto-advance after pitch'
        }, {
            smoName: 'autoPlay',
            control: 'SuiToggleComponent',
            label: 'Auto-play sounds for note entry'
        }, {
            smoName: 'showPiano',
            control: 'SuiToggleComponent',
            label: 'Show Piano widget'
        }, {
            smoName: 'transposingScore',
            control: 'SuiToggleComponent',
            label: 'Tranpose Score'
        }, {
            smoName: 'hideEmptyLines',
            control: 'SuiToggleComponent',
            label: 'Hide Empty Lines'
        }, {
            smoName: 'defaultDupleDuration',
            control: 'SuiDropdownComponent',
            label: 'Default Duration (even meter)',
            dataType: 'int',
            options: [{
                    value: 4096,
                    label: '1/4'
                }, {
                    value: 2048,
                    label: '1/8'
                }]
        }, {
            smoName: 'defaultTripleDuration',
            control: 'SuiDropdownComponent',
            label: 'Default Duration (triple meter)',
            dataType: 'int',
            options: [{
                    value: 6144,
                    label: 'dotted 1/4'
                }, {
                    value: 2048,
                    label: '1/8'
                }]
        }],
    staticText: []
};


/***/ }),

/***/ "./src/ui/dialogs/scoreId.ts":
/*!***********************************!*\
  !*** ./src/ui/dialogs/scoreId.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SuiScoreIdentificationDialog = exports.SuiScoreIdentificationAdapter = void 0;
const scoreText_1 = __webpack_require__(/*! ../../smo/data/scoreText */ "./src/smo/data/scoreText.ts");
const adapter_1 = __webpack_require__(/*! ./adapter */ "./src/ui/dialogs/adapter.ts");
class SuiScoreIdentificationAdapter extends adapter_1.SuiComponentAdapter {
    constructor(view) {
        super(view);
        this.current = {};
        this.scoreInfo = this.view.score.scoreInfo;
        this.backup = JSON.parse(JSON.stringify(this.scoreInfo));
        Object.keys(scoreText_1.SmoTextGroup.purposes).forEach((purpose) => {
            const grp = this.view.score.textGroups.find((tg) => tg.purpose === scoreText_1.SmoTextGroup.purposes[purpose]);
            if (grp) {
                this.current[purpose] = { checked: true, text: grp.textBlocks[0].text.text };
            }
            else {
                this.current[purpose] = { checked: false, text: '' };
            }
        });
    }
    updateValues(purpose, infoKey, value) {
        const grp = this.view.score.textGroups.find((tg) => tg.purpose === scoreText_1.SmoTextGroup.purposes[purpose]);
        if (grp) {
            if (value.checked) {
                grp.textBlocks[0].text.text = value.text;
                this.view.updateTextGroup(grp, grp);
            }
            else {
                this.view.removeTextGroup(grp);
            }
        }
        else {
            if (value.checked) {
                const tg = scoreText_1.SmoTextGroup.createTextForLayout(scoreText_1.SmoTextGroup.purposes[purpose], value.text, this.view.score.layoutManager.getScaledPageLayout(0));
                this.view.addTextGroup(tg);
            }
        }
        this.current[purpose] = value;
        this.scoreInfo[infoKey] = value.text;
    }
    get title() {
        return this.current.TITLE;
    }
    set title(value) {
        this.updateValues('TITLE', 'title', value);
    }
    get subTitle() {
        return this.current.SUBTITLE;
    }
    set subTitle(value) {
        this.updateValues('SUBTITLE', 'subTitle', value);
    }
    get composer() {
        return this.current.COMPOSER;
    }
    set composer(value) {
        this.updateValues('COMPOSER', 'composer', value);
    }
    get copyright() {
        return this.current.COPYRIGHT;
    }
    set copyright(value) {
        this.updateValues('COPYRIGHT', 'copyright', value);
    }
    get name() {
        return this.scoreInfo.name;
    }
    set name(value) {
        this.scoreInfo.name = value;
    }
    commit() {
        this.view.updateScoreInfo(this.scoreInfo);
    }
    cancel() {
    }
}
exports.SuiScoreIdentificationAdapter = SuiScoreIdentificationAdapter;
// ## SuiScoreIdentificationDialog
// change editor and formatting defaults for this score.
class SuiScoreIdentificationDialog extends adapter_1.SuiDialogAdapterBase {
    constructor(params) {
        const adapter = new SuiScoreIdentificationAdapter(params.view);
        super(SuiScoreIdentificationDialog.dialogElements, Object.assign({ adapter }, params));
    }
    static createAndDisplay(parameters) {
        const dg = new SuiScoreIdentificationDialog(parameters);
        dg.display();
    }
}
exports.SuiScoreIdentificationDialog = SuiScoreIdentificationDialog;
SuiScoreIdentificationDialog.dialogElements = {
    label: 'Score Preferences', elements: [{
            smoName: 'name',
            defaultValue: '',
            control: 'SuiTextInputComponent',
            label: 'Score Name',
        }, {
            smoName: 'title',
            defaultValue: '',
            control: 'TextCheckComponent',
            label: 'Title',
        }, {
            smoName: 'subTitle',
            control: 'TextCheckComponent',
            label: 'Sub Title',
        }, {
            smoName: 'composer',
            control: 'TextCheckComponent',
            label: 'Composer',
        }, {
            smoName: 'copyright',
            control: 'TextCheckComponent',
            label: 'Copyright'
        }],
    staticText: [
        { titleText: 'Title' },
        { subTitleText: 'Sub-title' },
        { copyrightText: 'Copyright' },
        { composerText: 'Composer' },
        { show: 'Show' }
    ]
};


/***/ }),

/***/ "./src/ui/dialogs/scoreView.ts":
/*!*************************************!*\
  !*** ./src/ui/dialogs/scoreView.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SuiScoreViewDialog = exports.SuiScoreViewAdapter = void 0;
const adapter_1 = __webpack_require__(/*! ./adapter */ "./src/ui/dialogs/adapter.ts");
const deepCopy = (x) => JSON.parse(JSON.stringify(x));
class SuiScoreViewAdapter extends adapter_1.SuiComponentAdapter {
    constructor(view) {
        super(view);
        this.currentView = this.view.getView();
        this.originalView = JSON.parse(JSON.stringify(this.currentView));
    }
    cancel() {
        const s1 = JSON.stringify(this.originalView);
        const s2 = JSON.stringify(this.currentView);
        if (s1 !== s2) {
            this.view.setView(this.originalView);
        }
    }
    commit() {
        const s1 = JSON.stringify(this.originalView);
        const s2 = JSON.stringify(this.currentView);
        if (s1 !== s2) {
            this.view.setView(this.currentView);
        }
    }
    get scoreView() {
        return this.currentView;
    }
    set scoreView(value) {
        this.currentView = value;
    }
}
exports.SuiScoreViewAdapter = SuiScoreViewAdapter;
// ## SuiScoreViewDialog
// decide which rows of the score to look at
class SuiScoreViewDialog extends adapter_1.SuiDialogAdapterBase {
    constructor(parameters) {
        const adapter = new SuiScoreViewAdapter(parameters.view);
        super(SuiScoreViewDialog.dialogElements, Object.assign({ adapter }, parameters));
        this.originalValue = JSON.parse(JSON.stringify(this.view.getView()));
    }
    get scoreViewCtrl() {
        return this.cmap.scoreViewCtrl;
    }
}
exports.SuiScoreViewDialog = SuiScoreViewDialog;
SuiScoreViewDialog.dialogElements = {
    label: 'Score View', elements: [{
            smoName: 'scoreView',
            control: 'StaffCheckComponent',
            label: 'Show staff',
        }],
    staticText: []
};


/***/ }),

/***/ "./src/ui/dialogs/slur.ts":
/*!********************************!*\
  !*** ./src/ui/dialogs/slur.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SuiSlurAttributesDialog = exports.SuiSlurAdapter = void 0;
const staffModifiers_1 = __webpack_require__(/*! ../../smo/data/staffModifiers */ "./src/smo/data/staffModifiers.ts");
const adapter_1 = __webpack_require__(/*! ./adapter */ "./src/ui/dialogs/adapter.ts");
const operations_1 = __webpack_require__(/*! ../../smo/xform/operations */ "./src/smo/xform/operations.ts");
class SuiSlurAdapter extends adapter_1.SuiComponentAdapter {
    constructor(view, slur) {
        super(view);
        this.changed = false;
        this.updating = false;
        this.slur = slur;
        this.view = view;
        this.backup = new staffModifiers_1.SmoSlur(this.slur);
        // Set the same id so the erase works
        this.backup.attrs.id = slur.attrs.id;
        this.backup.associatedStaff = this.slur.associatedStaff;
    }
    writeSlurNumber(view, slur, key, value) {
        const current = new staffModifiers_1.SmoSlur(slur);
        slur[key] = value;
        view.addOrUpdateStaffModifier(current, slur);
        this.changed = true;
    }
    writeSlurBool(view, slur, key, value) {
        const current = new staffModifiers_1.SmoSlur(slur);
        slur[key] = value;
        view.addOrUpdateStaffModifier(current, slur);
        this.changed = true;
    }
    cancel() {
        if (!this.changed) {
            return;
        }
        this.view.addOrUpdateStaffModifier(this.slur, this.backup);
    }
    commit() {
    }
    get resetAll() {
        return false;
    }
    set resetAll(value) {
        this.resetDefaults = value;
        const slurs = [];
        const self = this;
        this.updating = true;
        const updateSlur = (score, slur) => {
            const params = operations_1.SmoOperation.getDefaultSlurDirection(score, slur.startSelector, slur.endSelector, staffModifiers_1.SmoSlur.positions.AUTO, staffModifiers_1.SmoSlur.orientations.AUTO);
            const original = new staffModifiers_1.SmoSlur(slur);
            staffModifiers_1.SlurNumberParams.forEach((key) => {
                slur[key] = params[key];
            });
            return self.view.addOrUpdateStaffModifier(original, slur);
        };
        new Promise((resolve) => {
            const nextSlur = () => {
                setTimeout(() => {
                    if (slurs.length) {
                        const slur = slurs.pop();
                        updateSlur(self.view.score, slur).then(() => {
                            nextSlur();
                        });
                    }
                    else {
                        self.updating = false;
                        resolve();
                    }
                }, 1);
            };
            nextSlur();
        });
        this.view.score.staves.forEach((staff) => {
            staff.modifiers.filter((x) => x.ctor === 'SmoSlur').forEach((smoObj) => {
                const slur = smoObj;
                slurs.push(slur);
            });
        });
        this.changed = true;
    }
    get resetDefaults() {
        return false;
    }
    set resetDefaults(value) {
        const params = operations_1.SmoOperation.getDefaultSlurDirection(this.view.score, this.slur.startSelector, this.slur.endSelector, staffModifiers_1.SmoSlur.positions.AUTO, staffModifiers_1.SmoSlur.orientations.AUTO);
        staffModifiers_1.SlurNumberParams.forEach((key) => {
            this.slur[key] = params[key];
        });
        this.view.addOrUpdateStaffModifier(this.backup, this.slur);
        this.changed = true;
    }
    get cp2y() {
        return this.slur.cp2y;
    }
    set cp2y(value) {
        this.writeSlurNumber(this.view, this.slur, 'cp2y', value);
    }
    get cp2x() {
        return this.slur.cp2x;
    }
    set cp2x(value) {
        this.writeSlurNumber(this.view, this.slur, 'cp2x', value);
    }
    get cp1y() {
        return this.slur.cp1y;
    }
    set cp1y(value) {
        this.writeSlurNumber(this.view, this.slur, 'cp1y', value);
    }
    get cp1x() {
        return this.slur.cp1x;
    }
    set cp1x(value) {
        this.writeSlurNumber(this.view, this.slur, 'cp1x', value);
    }
    get invert() {
        return this.slur.invert;
    }
    set invert(value) {
        this.writeSlurBool(this.view, this.slur, 'invert', value);
    }
    get position_end() {
        return this.slur.position_end;
    }
    set position_end(value) {
        this.writeSlurNumber(this.view, this.slur, 'position_end', value);
    }
    get position() {
        return this.slur.position;
    }
    set position(value) {
        this.writeSlurNumber(this.view, this.slur, 'position', value);
    }
    get yOffset() {
        return this.slur.yOffset;
    }
    set yOffset(value) {
        this.writeSlurNumber(this.view, this.slur, 'yOffset', value);
    }
    get xOffset() {
        return this.slur.xOffset;
    }
    set xOffset(value) {
        this.writeSlurNumber(this.view, this.slur, 'xOffset', value);
    }
    get thickness() {
        return this.slur.thickness;
    }
    set thickness(value) {
        this.writeSlurNumber(this.view, this.slur, 'thickness', value);
    }
    get spacing() {
        return this.slur.spacing;
    }
    set spacing(value) {
        this.writeSlurNumber(this.view, this.slur, 'spacing', value);
    }
    remove() {
        this.view.removeStaffModifier(this.backup);
    }
}
exports.SuiSlurAdapter = SuiSlurAdapter;
class SuiSlurAttributesDialog extends adapter_1.SuiDialogAdapterBase {
    constructor(parameters) {
        const adapter = new SuiSlurAdapter(parameters.view, parameters.modifier);
        super(SuiSlurAttributesDialog.dialogElements, Object.assign({ adapter }, parameters));
        this.displayOptions = ['BINDCOMPONENTS', 'DRAGGABLE', 'KEYBOARD_CAPTURE', 'MODIFIERPOS'];
    }
    disableClose() {
        $(this.dgDom.element).find('.ok-button').prop('disabled', true);
        $(this.dgDom.element).find('.cancel-button').prop('disabled', true);
        $(this.dgDom.element).find('.remove-button').prop('disabled', true);
    }
    enableClose() {
        $(this.dgDom.element).find('.ok-button').prop('disabled', false);
        $(this.dgDom.element).find('.cancel-button').prop('disabled', false);
        $(this.dgDom.element).find('.remove-button').prop('disabled', false);
    }
    modalPromise() {
        const self = this;
        return new Promise((resolve) => {
            const checkComplete = () => {
                setTimeout(() => {
                    if (self.adapter.updating === false) {
                        resolve();
                    }
                    else {
                        checkComplete();
                    }
                }, 200);
            };
            checkComplete();
        });
    }
    changed() {
        super.changed();
        if (this.adapter.updating) {
            const self = this;
            this.disableClose();
            this.modalPromise().then(() => {
                self.enableClose();
            });
        }
    }
}
exports.SuiSlurAttributesDialog = SuiSlurAttributesDialog;
SuiSlurAttributesDialog.dialogElements = {
    label: 'Slur Properties', elements: [{
            smoName: 'spacing',
            defaultValue: 2,
            control: 'SuiRockerComponent',
            label: 'Spacing'
        }, {
            smoName: 'thickness',
            defaultValue: 2,
            control: 'SuiRockerComponent',
            label: 'Thickness'
        }, {
            smoName: 'xOffset',
            defaultValue: 0,
            control: 'SuiRockerComponent',
            label: 'X Offset'
        }, {
            smoName: 'yOffset',
            defaultValue: 10,
            control: 'SuiRockerComponent',
            label: 'Y Offset'
        }, {
            smoName: 'position',
            defaultValue: staffModifiers_1.SmoSlur.positions.HEAD,
            dataType: 'int',
            options: [{
                    value: staffModifiers_1.SmoSlur.positions.HEAD,
                    label: 'Head'
                }, {
                    value: staffModifiers_1.SmoSlur.positions.TOP,
                    label: 'Top'
                }],
            control: 'SuiDropdownComponent',
            label: 'Start Position'
        }, {
            smoName: 'position_end',
            defaultValue: staffModifiers_1.SmoSlur.positions.HEAD,
            dataType: 'int',
            options: [{
                    value: staffModifiers_1.SmoSlur.positions.HEAD,
                    label: 'Head'
                }, {
                    value: staffModifiers_1.SmoSlur.positions.TOP,
                    label: 'Top'
                }],
            control: 'SuiDropdownComponent',
            label: 'End Position'
        }, {
            smoName: 'invert',
            control: 'SuiToggleComponent',
            label: 'Invert'
        }, {
            smoName: 'resetDefaults',
            control: 'SuiToggleComponent',
            label: 'Defaults'
        }, {
            smoName: 'resetAll',
            control: 'SuiToggleComponent',
            label: 'Reset All Slurs'
        }, {
            smoName: 'cp1x',
            defaultValue: 0,
            control: 'SuiRockerComponent',
            label: 'Control Point 1 X'
        }, {
            smoName: 'cp1y',
            defaultValue: 40,
            control: 'SuiRockerComponent',
            label: 'Control Point 1 Y'
        }, {
            smoName: 'cp2x',
            defaultValue: 0,
            control: 'SuiRockerComponent',
            label: 'Control Point 2 X'
        }, {
            smoName: 'cp2y',
            defaultValue: 40,
            control: 'SuiRockerComponent',
            label: 'Control Point 2 Y'
        }], staticText: []
};


/***/ }),

/***/ "./src/ui/dialogs/staffGroup.ts":
/*!**************************************!*\
  !*** ./src/ui/dialogs/staffGroup.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SuiStaffGroupDialog = exports.SuiStaffGroupDialogAdapter = void 0;
const scoreModifiers_1 = __webpack_require__(/*! ../../smo/data/scoreModifiers */ "./src/smo/data/scoreModifiers.ts");
const adapter_1 = __webpack_require__(/*! ./adapter */ "./src/ui/dialogs/adapter.ts");
class SuiStaffGroupDialogAdapter extends adapter_1.SuiComponentAdapter {
    constructor(view) {
        super(view);
        const selection = this.view.tracker.selections[0];
        // Reset the view so we can see all the staves
        this.view.viewAll();
        const staffGroup = this.view.score.getSystemGroupForStaff(selection);
        if (!staffGroup) {
            const params = scoreModifiers_1.SmoSystemGroup.defaults;
            params.startSelector = JSON.parse(JSON.stringify(selection.selector));
            params.endSelector = JSON.parse(JSON.stringify(selection.selector));
            this.staffGroup = new scoreModifiers_1.SmoSystemGroup(params);
        }
        else {
            this.staffGroup = staffGroup;
        }
    }
    commit() {
    }
    cancel() {
    }
    get leftConnector() {
        return this.staffGroup.leftConnector;
    }
    set leftConnector(val) {
        this.staffGroup.leftConnector = val;
        this.view.addOrUpdateStaffGroup(this.staffGroup);
    }
    get staffGroups() {
        return this.staffGroup;
    }
    set staffGroups(val) {
        this.staffGroup = val;
        this.view.addOrUpdateStaffGroup(this.staffGroup);
    }
}
exports.SuiStaffGroupDialogAdapter = SuiStaffGroupDialogAdapter;
// ## SuiStaffGroupDialog
// A staff group is a grouping of staves that can be bracketed and justified
class SuiStaffGroupDialog extends adapter_1.SuiDialogAdapterBase {
    constructor(parameters) {
        const adapter = new SuiStaffGroupDialogAdapter(parameters.view);
        super(SuiStaffGroupDialog.dialogElements, Object.assign({ adapter }, parameters));
    }
    static createAndDisplay(parameters) {
        const dg = new SuiStaffGroupDialog(parameters);
        dg.display();
    }
    getModifier() {
        return this.adapter.staffGroups;
    }
}
exports.SuiStaffGroupDialog = SuiStaffGroupDialog;
SuiStaffGroupDialog.dialogElements = {
    label: 'Staff Group', elements: [{
            smoName: 'staffGroups',
            control: 'StaffAddRemoveComponent',
            label: 'Staves in Group',
        }, {
            smoName: 'leftConnector',
            control: 'SuiDropdownComponent',
            dataType: 'int',
            label: 'Left Connector',
            options: [
                {
                    value: scoreModifiers_1.SmoSystemGroup.connectorTypes.bracket,
                    label: 'Bracket'
                }, {
                    value: scoreModifiers_1.SmoSystemGroup.connectorTypes.brace,
                    label: 'Brace'
                }, {
                    value: scoreModifiers_1.SmoSystemGroup.connectorTypes.single,
                    label: 'Single'
                }, {
                    value: scoreModifiers_1.SmoSystemGroup.connectorTypes.double,
                    label: 'Double'
                }
            ]
        }],
    staticText: [
        { includeStaff: 'Include Staff' }
    ]
};


/***/ }),

/***/ "./src/ui/dialogs/tempo.ts":
/*!*********************************!*\
  !*** ./src/ui/dialogs/tempo.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SuiTempoDialog = exports.SuiTempoAdapter = void 0;
// [Smoosic](https://github.com/AaronDavidNewman/Smoosic)
// Copyright (c) Aaron David Newman 2021.
const measureModifiers_1 = __webpack_require__(/*! ../../smo/data/measureModifiers */ "./src/smo/data/measureModifiers.ts");
const selections_1 = __webpack_require__(/*! ../../smo/xform/selections */ "./src/smo/xform/selections.ts");
const adapter_1 = __webpack_require__(/*! ./adapter */ "./src/ui/dialogs/adapter.ts");
class SuiTempoAdapter extends adapter_1.SuiComponentAdapter {
    constructor(view, measure) {
        super(view);
        this.applyToAllVal = false;
        this.applyToSelection = false;
        this.edited = false;
        this.measure = measure;
        this.smoTempoText = new measureModifiers_1.SmoTempoText(measure.tempo);
        this.backup = new measureModifiers_1.SmoTempoText(this.smoTempoText);
    }
    writeNumber(param, value) {
        this.smoTempoText[param] = value;
        this.view.updateTempoScore(this.measure, this.smoTempoText, this.applyToAll, this.applyToSelection);
        this.edited = true;
    }
    writeBoolean(param, value) {
        this.smoTempoText[param] = value;
        this.view.updateTempoScore(this.measure, this.smoTempoText, this.applyToAll, this.applyToSelection);
        this.edited = true;
    }
    writeString(param, value) {
        this.smoTempoText[param] = value;
        this.view.updateTempoScore(this.measure, this.smoTempoText, this.applyToAll, this.applyToSelection);
        this.edited = true;
    }
    remove() {
        this.view.removeTempo(this.measure, this.smoTempoText, this.applyToAll, this.applyToSelection);
    }
    cancel() {
        this.view.updateTempoScore(this.measure, this.backup, this.applyToAll, this.applyToSelection);
    }
    get applyToAll() {
        return this.applyToAllVal;
    }
    set applyToAll(val) {
        this.applyToAllVal = val;
        this.view.updateTempoScore(this.measure, this.smoTempoText, this.applyToAll, this.applyToSelection);
        this.edited = true;
    }
    commit() { }
    get tempoText() {
        return this.smoTempoText.tempoText;
    }
    set tempoText(value) {
        this.writeString('tempoText', value);
    }
    get tempoMode() {
        return this.smoTempoText.tempoMode;
    }
    set tempoMode(value) {
        this.writeString('tempoMode', value);
    }
    get customText() {
        return this.smoTempoText.customText;
    }
    set customText(value) {
        this.writeString('customText', value);
    }
    get bpm() {
        return this.smoTempoText.bpm;
    }
    set bpm(value) {
        this.writeNumber('bpm', value);
    }
    get display() {
        return this.smoTempoText.display;
    }
    set display(value) {
        this.writeBoolean('display', value);
    }
    get beatDuration() {
        return this.smoTempoText.beatDuration;
    }
    set beatDuration(value) {
        this.writeNumber('beatDuration', value);
    }
    get yOffset() {
        return this.smoTempoText.yOffset;
    }
    set yOffset(value) {
        this.writeNumber('yOffset', value);
    }
}
exports.SuiTempoAdapter = SuiTempoAdapter;
// ## SuiTempoDialog
// Allow user to choose a tempo or tempo change.
class SuiTempoDialog extends adapter_1.SuiDialogAdapterBase {
    constructor(parameters) {
        const measures = selections_1.SmoSelection.getMeasureList(parameters.view.tracker.selections)
            .map((sel) => sel.measure);
        const measure = measures[0];
        const adapter = new SuiTempoAdapter(parameters.view, measure);
        super(SuiTempoDialog.dialogElements, Object.assign({ adapter }, parameters));
    }
    showHideCustom() {
        if (this.adapter.tempoMode === 'custom') {
            this.cmap.customTextCtrl.show();
        }
        else {
            this.cmap.customTextCtrl.hide();
        }
    }
    changed() {
        super.changed();
        this.showHideCustom();
    }
    initialValue() {
        super.initialValue();
        this.showHideCustom();
    }
}
exports.SuiTempoDialog = SuiTempoDialog;
SuiTempoDialog.dialogElements = {
    label: 'Tempo Properties',
    elements: [
        {
            smoName: 'tempoMode',
            defaultValue: measureModifiers_1.SmoTempoText.tempoModes.durationMode,
            control: 'SuiDropdownComponent',
            label: 'Tempo Mode',
            options: [{
                    value: 'duration',
                    label: 'Duration (Beats/Minute)'
                }, {
                    value: 'text',
                    label: 'Tempo Text'
                }, {
                    value: 'custom',
                    label: 'Specify text and duration'
                }
            ]
        },
        {
            smoName: 'customText',
            defaultValue: '',
            control: 'SuiTextInputComponent',
            label: 'Custom Text',
            classes: 'hide-when-text-mode'
        },
        {
            smoName: 'bpm',
            defaultValue: 120,
            control: 'SuiRockerComponent',
            label: 'Notes/Minute'
        },
        {
            smoName: 'beatDuration',
            defaultValue: 4096,
            dataType: 'int',
            control: 'SuiDropdownComponent',
            label: 'Unit for Beat',
            options: [{
                    value: 4096,
                    label: 'Quarter Note',
                }, {
                    value: 2048,
                    label: '1/8 note'
                }, {
                    value: 6144,
                    label: 'Dotted 1/4 note'
                }, {
                    value: 8192,
                    label: '1/2 note'
                }
            ]
        },
        {
            smoName: 'tempoText',
            defaultValue: measureModifiers_1.SmoTempoText.tempoTexts.allegro,
            control: 'SuiDropdownComponent',
            label: 'Tempo Text',
            classes: 'hide-when-not-text-mode',
            options: [{
                    value: measureModifiers_1.SmoTempoText.tempoTexts.larghissimo,
                    label: 'Larghissimo'
                }, {
                    value: measureModifiers_1.SmoTempoText.tempoTexts.grave,
                    label: 'Grave'
                }, {
                    value: measureModifiers_1.SmoTempoText.tempoTexts.lento,
                    label: 'Lento'
                }, {
                    value: measureModifiers_1.SmoTempoText.tempoTexts.largo,
                    label: 'Largo'
                }, {
                    value: measureModifiers_1.SmoTempoText.tempoTexts.larghetto,
                    label: 'Larghetto'
                }, {
                    value: measureModifiers_1.SmoTempoText.tempoTexts.adagio,
                    label: 'Adagio'
                }, {
                    value: measureModifiers_1.SmoTempoText.tempoTexts.adagietto,
                    label: 'Adagietto'
                }, {
                    value: measureModifiers_1.SmoTempoText.tempoTexts.andante_moderato,
                    label: 'Andante moderato'
                }, {
                    value: measureModifiers_1.SmoTempoText.tempoTexts.andante,
                    label: 'Andante'
                }, {
                    value: measureModifiers_1.SmoTempoText.tempoTexts.andantino,
                    label: 'Andantino'
                }, {
                    value: measureModifiers_1.SmoTempoText.tempoTexts.moderator,
                    label: 'Moderato'
                }, {
                    value: measureModifiers_1.SmoTempoText.tempoTexts.allegretto,
                    label: 'Allegretto',
                }, {
                    value: measureModifiers_1.SmoTempoText.tempoTexts.allegro,
                    label: 'Allegro'
                }, {
                    value: measureModifiers_1.SmoTempoText.tempoTexts.vivace,
                    label: 'Vivace'
                }, {
                    value: measureModifiers_1.SmoTempoText.tempoTexts.presto,
                    label: 'Presto'
                }, {
                    value: measureModifiers_1.SmoTempoText.tempoTexts.prestissimo,
                    label: 'Prestissimo'
                }
            ]
        }, {
            smoName: 'applyToAll',
            control: 'SuiToggleComponent',
            label: 'Apply to all future measures?'
        }, {
            smoName: 'applyToSelection',
            control: 'SuiToggleComponent',
            label: 'Apply to selection?'
        }, {
            smoName: 'display',
            control: 'SuiToggleComponent',
            label: 'Display Tempo'
        }, {
            smoName: 'yOffset',
            defaultValue: 0,
            control: 'SuiRockerComponent',
            label: 'Y Offset'
        }
    ],
    staticText: []
};


/***/ }),

/***/ "./src/ui/dialogs/textBlock.ts":
/*!*************************************!*\
  !*** ./src/ui/dialogs/textBlock.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.helpModal = exports.SuiTextBlockDialog = void 0;
// [Smoosic](https://github.com/AaronDavidNewman/Smoosic)
// Copyright (c) Aaron David Newman 2021.
const scoreText_1 = __webpack_require__(/*! ../../smo/data/scoreText */ "./src/smo/data/scoreText.ts");
const htmlHelpers_1 = __webpack_require__(/*! ../../common/htmlHelpers */ "./src/common/htmlHelpers.ts");
const layoutDebug_1 = __webpack_require__(/*! ../../render/sui/layoutDebug */ "./src/render/sui/layoutDebug.ts");
const svgHelpers_1 = __webpack_require__(/*! ../../render/sui/svgHelpers */ "./src/render/sui/svgHelpers.ts");
const textEdit_1 = __webpack_require__(/*! ../../render/sui/textEdit */ "./src/render/sui/textEdit.ts");
const dialog_1 = __webpack_require__(/*! ./dialog */ "./src/ui/dialogs/dialog.ts");
const help_1 = __webpack_require__(/*! ../help */ "./src/ui/help.ts");
class SuiTextBlockDialog extends dialog_1.SuiDialogBase {
    constructor(parameters) {
        let edited = false;
        let isNew = false;
        const tracker = parameters.view.tracker;
        ['staffModifier', 'suggestion'].forEach((outlineType) => {
            if (tracker.outlines[outlineType]) {
                svgHelpers_1.SvgHelpers.eraseOutline(tracker.outlines[outlineType]);
            }
        });
        const layout = parameters.view.score.layoutManager.getGlobalLayout();
        // Create a new text modifier, if this is new text.   Else use selection
        if (!parameters.modifier) {
            isNew = true;
            const textParams = scoreText_1.SmoScoreText.defaults;
            textParams.position = scoreText_1.SmoScoreText.positions.custom;
            const newText = new scoreText_1.SmoScoreText(textParams);
            // convert scroll from screen coord to svg coord
            const svgScroll = tracker.renderer.pageMap.clientToSvg(svgHelpers_1.SvgHelpers.smoBox(tracker.scroller.scrollState));
            newText.y += svgScroll.y;
            newText.x += svgScroll.x;
            if (tracker.selections.length > 0) {
                const sel = tracker.selections[0].measure.svg;
                if (typeof (sel.logicalBox) !== 'undefined') {
                    if (sel.logicalBox.y >= newText.y) {
                        newText.y = sel.logicalBox.y;
                        newText.x = sel.logicalBox.x;
                    }
                }
            }
            const grpParams = scoreText_1.SmoTextGroup.defaults;
            grpParams.blocks = [{ text: newText, position: scoreText_1.SmoTextGroup.relativePositions.LEFT }];
            const newGroup = new scoreText_1.SmoTextGroup(grpParams);
            parameters.modifier = newGroup;
            parameters.modifier.setActiveBlock(newText);
            parameters.view.addTextGroup(parameters.modifier);
            edited = true;
        }
        else {
            // Make sure there is a score text to start the editing.
            parameters.modifier.setActiveBlock(parameters.modifier.textBlocks[0].text);
        }
        super(SuiTextBlockDialog.dialogElements, parameters);
        this.outlineRect = null;
        this.isNew = isNew;
        this.modifier = parameters.modifier;
        this.displayOptions = ['BINDCOMPONENTS', 'DRAGGABLE', 'KEYBOARD_CAPTURE', 'MODIFIERPOS'];
        this.edited = edited;
        this.view.groupUndo(true);
        this.backup = this.modifier.serialize();
        this.activeScoreText = this.modifier.getActiveBlock();
        this.mouseMoveHandler = null;
        this.mouseUpHandler = null;
        this.mouseDownHandler = null;
        this.mouseClickHandler = null;
    }
    get textEditorCtrl() {
        return this.cmap.textEditorCtrl;
    }
    get insertCodeCtrl() {
        return this.cmap.insertCodeCtrl;
    }
    get textDraggerCtrl() {
        return this.cmap.textDraggerCtrl;
    }
    get yCtrl() {
        return this.cmap.yCtrl;
    }
    get xCtrl() {
        return this.cmap.xCtrl;
    }
    get fontCtrl() {
        return this.cmap.fontCtrl;
    }
    get textBlockCtrl() {
        return this.cmap.textBlockCtrl;
    }
    get paginationCtrl() {
        return this.cmap.paginationCtrl;
    }
    get attachToSelectorCtrl() {
        return this.cmap.attachToSelectorCtrl;
    }
    populateInitial() {
        this.textBlockCtrl.setValue({
            activeScoreText: this.activeScoreText,
            modifier: this.modifier
        });
        const fontFamily = this.activeScoreText.fontInfo.family;
        const fontSize = this.activeScoreText.fontInfo.size;
        this.fontCtrl.setValue({
            family: fontFamily,
            size: fontSize,
            style: this.activeScoreText.fontInfo.style,
            weight: this.activeScoreText.fontInfo.weight
        });
        this.attachToSelectorCtrl.setValue(this.modifier.attachToSelector);
        const ul = this.modifier.ul();
        this.xCtrl.setValue(ul.x);
        this.yCtrl.setValue(ul.y);
        this.paginationCtrl.setValue(this.modifier.pagination);
        this.highlightActiveRegion();
    }
    display() {
        const pageContext = this.view.renderer.pageMap.getRendererFromModifier(this.activeScoreText);
        const svg = pageContext.svg;
        this.textElement = $(svg).find('.' + this.activeScoreText.attrs.id)[0];
        $('body').addClass('showAttributeDialog');
        $('body').addClass('textEditor');
        this.applyDisplayOptions();
        this.populateInitial();
        this.bindElements();
        if (!this.modifier.logicalBox) {
            this.view.renderer.renderTextGroup(this.modifier);
        }
        // If this control has not been edited this session, assume they want to
        // edit the text and just right into that.
        if (!this.modifier.edited) {
            this.modifier.edited = true;
            layoutDebug_1.layoutDebug.addDialogDebug('text transform db: startEditSession');
            this.textEditorCtrl.startEditSession();
        }
        this.mouseMoveHandler = this.eventSource.bindMouseMoveHandler(this, 'mouseMove');
        this.mouseUpHandler = this.eventSource.bindMouseUpHandler(this, 'mouseUp');
        this.mouseDownHandler = this.eventSource.bindMouseDownHandler(this, 'mouseDown');
        this.mouseClickHandler = this.eventSource.bindMouseClickHandler(this, 'mouseClick');
    }
    _resetAttachToSelector() {
        this.modifier.attachToSelector = false;
        this.modifier.selector = scoreText_1.SmoTextGroup.defaults.selector;
        this.modifier.musicXOffset = scoreText_1.SmoTextGroup.defaults.musicXOffset;
        this.modifier.musicYOffset = scoreText_1.SmoTextGroup.defaults.musicYOffset;
    }
    _activateAttachToSelector() {
        this.modifier.attachToSelector = true;
        this.modifier.selector = JSON.parse(JSON.stringify(this.view.tracker.selections[0].selector));
        if (this.modifier.logicalBox) {
            this.modifier.musicXOffset = this.modifier.logicalBox.x - this.view.tracker.selections[0].measure.svg.logicalBox.x;
            this.modifier.musicYOffset = this.modifier.logicalBox.y - this.view.tracker.selections[0].measure.svg.logicalBox.y;
        }
    }
    changed() {
        this.edited = true;
        if (this.insertCodeCtrl.changeFlag && this.textEditorCtrl.session) {
            const val = this.insertCodeCtrl.getValue().toString().split('');
            val.forEach((key) => {
                this.evKey({ key });
            });
            this.insertCodeCtrl.unselect();
        }
        if (this.textBlockCtrl.changeFlag) {
            const nval = this.textBlockCtrl.getValue();
            this.activeScoreText = nval.activeScoreText;
            this.highlightActiveRegion();
        }
        if (this.textEditorCtrl.changeFlag) {
            this.highlightActiveRegion();
        }
        if (this.attachToSelectorCtrl.changeFlag) {
            const toSet = this.attachToSelectorCtrl.getValue();
            if (toSet) {
                this._activateAttachToSelector();
                this.paginationCtrl.setValue(scoreText_1.SmoTextGroup.paginations.ONCE);
                this.modifier.pagination = scoreText_1.SmoTextGroup.paginations.ONCE;
            }
            else {
                this._resetAttachToSelector();
            }
        }
        const pos = this.modifier.ul();
        // position can change from drag or by dialog - only update from
        // dialog entries if that changed.
        if (this.xCtrl.changeFlag) {
            this.modifier.offsetX(this.xCtrl.getValue() - pos.x);
        }
        if (this.yCtrl.changeFlag) {
            this.modifier.offsetY(this.yCtrl.getValue() - pos.y);
        }
        if (this.textDraggerCtrl.changeFlag) {
            this.xCtrl.setValue(pos.x);
            this.yCtrl.setValue(pos.y);
        }
        if (this.paginationCtrl.changeFlag) {
            this.modifier.pagination = parseInt(this.paginationCtrl.getValue().toString(), 10);
            // Pagination and attach to measure don't mix.
            this._resetAttachToSelector();
            this.attachToSelectorCtrl.setValue(false);
        }
        if (this.fontCtrl.changeFlag) {
            const fontInfo = this.fontCtrl.getValue();
            this.activeScoreText.fontInfo.family = fontInfo.family;
            // transitioning away from non-point-based font size units
            this.activeScoreText.fontInfo.size = fontInfo.size;
            this.activeScoreText.fontInfo.weight = fontInfo.weight;
            this.activeScoreText.fontInfo.style = fontInfo.style;
        }
        // Use layout context because render may have reset svg.
        this.view.updateTextGroup(this.backup, this.modifier);
        this.backup = this.modifier.serialize();
    }
    highlightActiveRegion() {
        const pageContext = this.view.renderer.pageMap.getRendererFromModifier(this.activeScoreText);
        const svg = pageContext.svg;
        if (this.activeScoreText.logicalBox) {
            const stroke = textEdit_1.SuiTextEditor.strokes['text-highlight'];
            if (!this.outlineRect) {
                this.outlineRect = {
                    context: pageContext,
                    classes: '',
                    stroke,
                    box: this.activeScoreText.logicalBox,
                    scroll: this.scroller.scrollState,
                    timeOff: 1000
                };
            }
            svgHelpers_1.SvgHelpers.eraseOutline(this.outlineRect);
            this.outlineRect.box = this.activeScoreText.logicalBox;
            svgHelpers_1.SvgHelpers.outlineRect(this.outlineRect);
        }
    }
    // ### handleKeydown
    // allow a dialog to be dismissed by esc.
    evKey(evdata) {
        if (evdata.key === 'Escape') {
            $(this.dgDom.element).find('.cancel-button').click();
            evdata.preventDefault();
        }
        else {
            this.textEditorCtrl.evKey(evdata);
        }
    }
    // ### Event handlers, passed from dialog
    mouseUp() {
        if (this.textDraggerCtrl && this.textDraggerCtrl.running) {
            this.textDraggerCtrl.mouseUp(null);
        }
    }
    mouseMove(ev) {
        if (this.textDraggerCtrl && this.textDraggerCtrl.running) {
            this.textDraggerCtrl.mouseMove(ev);
        }
        else if (this.textEditorCtrl && this.textEditorCtrl.isRunning) {
            this.textEditorCtrl.mouseMove(ev);
        }
    }
    mouseClick(ev) {
        if (this.textEditorCtrl && this.textEditorCtrl.isRunning) {
            this.textEditorCtrl.mouseClick(ev);
            ev.stopPropagation();
        }
    }
    mouseDown(ev) {
        if (this.textDraggerCtrl && this.textDraggerCtrl.running) {
            this.textDraggerCtrl.mouseDown(ev);
        }
    }
    _complete() {
        this.view.groupUndo(false);
        this.modifier.setActiveBlock(null);
        this.view.tracker.updateMap(); // update the text map
        this.view.renderer.setDirty();
        if (this.mouseDownHandler) {
            this.eventSource.unbindMouseDownHandler(this.mouseDownHandler);
        }
        if (this.mouseUpHandler) {
            this.eventSource.unbindMouseUpHandler(this.mouseUpHandler);
        }
        if (this.mouseMoveHandler) {
            this.eventSource.unbindMouseMoveHandler(this.mouseMoveHandler);
        }
        if (this.mouseClickHandler) {
            this.eventSource.unbindMouseClickHandler(this.mouseClickHandler);
        }
        if (this.outlineRect) {
            svgHelpers_1.SvgHelpers.eraseOutline(this.outlineRect);
        }
        // Hack - this comes from SuiInlineText and SuiTextEdit.
        $('body').removeClass('showAttributeDialog');
        $('body').removeClass('textEditor');
        this.complete();
    }
    _removeText() {
        this.view.removeTextGroup(this.modifier);
    }
    bindElements() {
        const dgDom = this.dgDom;
        $(dgDom.element).find('.ok-button').off('click').on('click', () => {
            this.view.updateTextGroup(this.backup, this.modifier);
            this._complete();
        });
        $(dgDom.element).find('.cancel-button').off('click').on('click', () => {
            this.view.groupUndo(false);
            if (this.edited) {
                this.modifier.elements.forEach((element) => {
                    element.remove();
                });
                this.modifier.elements = [];
                this.view.undo();
            }
            this._complete();
        });
        $(dgDom.element).find('.remove-button').off('click').on('click', () => {
            this._removeText();
            this._complete();
        });
    }
}
exports.SuiTextBlockDialog = SuiTextBlockDialog;
SuiTextBlockDialog.dialogElements = {
    label: 'Text Properties', elements: [{
            smoName: 'textEditor',
            defaultValue: 0,
            control: 'SuiTextInPlace',
            classes: 'show-always hide-when-moving',
            label: 'Edit Text',
            options: []
        }, {
            smoName: 'insertCode',
            classes: 'show-when-editing hide-when-moving',
            control: 'SuiDropdownComponent',
            label: 'Insert Special',
            options: [
                { value: '@@@', label: 'Pages' },
                { value: '###', label: 'Page Number' }
            ]
        }, {
            smoName: 'textDragger',
            classes: 'hide-when-editing show-when-moving',
            defaultValue: 0,
            control: 'SuiDragText',
            label: 'Move Text',
            options: []
        }, {
            smoName: 'x',
            defaultValue: 0,
            classes: 'hide-when-editing hide-when-moving',
            control: 'SuiRockerComponent',
            label: 'X Position (Px)',
            dataType: 'int'
        }, {
            smoName: 'y',
            defaultValue: 0,
            classes: 'hide-when-editing hide-when-moving',
            control: 'SuiRockerComponent',
            label: 'Y Position (Px)',
            dataType: 'int'
        }, {
            smoName: 'font',
            classes: 'hide-when-editing hide-when-moving',
            defaultValue: scoreText_1.SmoScoreText.fontFamilies.times,
            control: 'SuiFontComponent',
            label: 'Font Information'
        },
        {
            smoName: 'textBlock',
            classes: 'hide-when-editing hide-when-moving',
            defaultValue: '',
            control: 'SuiTextBlockComponent',
            label: 'Text Block Properties'
        },
        {
            smoName: 'pagination',
            defaultValue: scoreText_1.SmoScoreText.paginations.every,
            classes: 'hide-when-editing hide-when-moving',
            control: 'SuiDropdownComponent',
            label: 'Page Behavior',
            startRow: true,
            options: [{ value: scoreText_1.SmoTextGroup.paginations.ONCE, label: 'Once' },
                { value: scoreText_1.SmoTextGroup.paginations.EVERY, label: 'Every' },
                { value: scoreText_1.SmoTextGroup.paginations.ODD, label: 'Odd' },
                { value: scoreText_1.SmoTextGroup.paginations.SUBSEQUENT, label: 'Subsequent' }
            ]
        }, {
            smoName: 'attachToSelector',
            classes: 'hide-when-editing hide-when-moving',
            control: 'SuiToggleComponent',
            label: 'Attach to Selection'
        }],
    staticText: [
        { label: 'Text Properties' },
        { editorLabel: 'Done Editing Text' },
        { draggerLabel: 'Done Dragging Text' }
    ]
};
class helpModal {
    static createAndDisplay() {
        help_1.SuiHelp.displayHelp();
        return (0, htmlHelpers_1.closeDialogPromise)();
    }
}
exports.helpModal = helpModal;


/***/ }),

/***/ "./src/ui/dialogs/textBracket.ts":
/*!***************************************!*\
  !*** ./src/ui/dialogs/textBracket.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SuiTextBracketDialog = exports.SuiTextBracketAdapter = void 0;
const staffModifiers_1 = __webpack_require__(/*! ../../smo/data/staffModifiers */ "./src/smo/data/staffModifiers.ts");
const adapter_1 = __webpack_require__(/*! ./adapter */ "./src/ui/dialogs/adapter.ts");
class SuiTextBracketAdapter extends adapter_1.SuiComponentAdapter {
    constructor(view, bracket) {
        super(view);
        this.changed = false;
        this.bracket = bracket;
        this.view = view;
        this.backup = new staffModifiers_1.SmoStaffTextBracket(this.bracket);
        this.backup.attrs.id = bracket.attrs.id;
        this.backup.associatedStaff = bracket.associatedStaff;
    }
    cancel() {
        if (this.changed) {
            this.view.removeTextBracket(this.bracket);
            this.view.addOrReplaceTextBracket(this.backup);
        }
    }
    remove() {
        this.view.removeStaffModifier(this.bracket);
    }
    commit() {
    }
    updateValue(param, val) {
        const current = new staffModifiers_1.SmoStaffTextBracket(this.bracket);
        this.bracket[param] = parseInt(val.toString(), 10);
        this.view.addOrUpdateStaffModifier(current, this.bracket);
        this.changed = true;
    }
    updateText(param, val) {
        const current = new staffModifiers_1.SmoStaffTextBracket(this.bracket);
        this.bracket[param] = val;
        this.view.addOrUpdateStaffModifier(current, this.bracket);
        this.changed = true;
    }
    get text() {
        return this.bracket.text;
    }
    set text(val) {
        this.updateText('text', val);
    }
    get superscript() {
        return this.bracket.superscript;
    }
    set superscript(val) {
        this.updateText('superscript', val);
    }
    get position() {
        return this.bracket.position;
    }
    set position(val) {
        this.updateValue('position', val);
    }
    get line() {
        return this.bracket.line;
    }
    set line(val) {
        this.updateValue('line', val);
    }
}
exports.SuiTextBracketAdapter = SuiTextBracketAdapter;
class SuiTextBracketDialog extends adapter_1.SuiDialogAdapterBase {
    constructor(parameters) {
        const adapter = new SuiTextBracketAdapter(parameters.view, parameters.modifier);
        super(SuiTextBracketDialog.dialogElements, Object.assign({ adapter }, parameters));
        this.displayOptions = ['BINDCOMPONENTS', 'DRAGGABLE', 'KEYBOARD_CAPTURE', 'MODIFIERPOS'];
    }
}
exports.SuiTextBracketDialog = SuiTextBracketDialog;
SuiTextBracketDialog.dialogElements = {
    label: 'Text Bracket Properties', elements: [{
            smoName: 'line',
            defaultValue: 1,
            control: 'SuiRockerComponent',
            label: 'Line'
        }, {
            smoName: 'position',
            control: 'SuiDropdownComponent',
            label: 'Position',
            options: [
                {
                    value: '1',
                    label: 'Above'
                }, {
                    value: '-1',
                    label: 'Below'
                }
            ]
        }, {
            smoName: 'text',
            control: 'SuiTextInputComponent',
            label: 'Text'
        }, {
            smoName: 'superscript',
            control: 'SuiTextInputComponent',
            label: 'SubText'
        }],
    staticText: []
};


/***/ }),

/***/ "./src/ui/dialogs/tie.ts":
/*!*******************************!*\
  !*** ./src/ui/dialogs/tie.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SuiTieAttributesDialog = exports.SuiTieAdapter = void 0;
const staffModifiers_1 = __webpack_require__(/*! ../../smo/data/staffModifiers */ "./src/smo/data/staffModifiers.ts");
const adapter_1 = __webpack_require__(/*! ./adapter */ "./src/ui/dialogs/adapter.ts");
class SuiTieAdapter extends adapter_1.SuiComponentAdapter {
    constructor(view, tie) {
        super(view);
        this.changed = false;
        this.tie = tie;
        this.backup = new staffModifiers_1.SmoTie(tie);
        // Make it have same ID so remove works.
        this.backup.attrs.id = tie.attrs.id;
        this.backup.associatedStaff = tie.associatedStaff;
    }
    writeTieNumber(value, param) {
        this.tie[param] = value;
        this.view.addOrUpdateStaffModifier(this.backup, this.tie);
        this.changed = true;
    }
    get lines() {
        return this.tie.lines;
    }
    set lines(value) {
        this.tie.lines = JSON.parse(JSON.stringify(value));
        this.view.addOrUpdateStaffModifier(this.backup, this.tie);
    }
    get tie_spacing() {
        return this.tie.tie_spacing;
    }
    set tie_spacing(value) {
        this.writeTieNumber(value, 'tie_spacing');
    }
    get first_x_shift() {
        return this.tie.first_x_shift;
    }
    set first_x_shift(value) {
        this.writeTieNumber(value, 'first_x_shift');
    }
    get last_x_shift() {
        return this.tie.last_x_shift;
    }
    set last_x_shift(value) {
        this.writeTieNumber(value, 'last_x_shift');
    }
    get y_shift() {
        return this.tie.y_shift;
    }
    set y_shift(value) {
        this.writeTieNumber(value, 'y_shift');
    }
    get cp1() {
        return this.tie.cp1;
    }
    set cp1(value) {
        this.writeTieNumber(value, 'cp1');
    }
    get cp2() {
        return this.tie.cp2;
    }
    set cp2(value) {
        this.writeTieNumber(value, 'cp2');
    }
    commit() {
    }
    cancel() {
        if (this.changed) {
            this.view.addOrUpdateStaffModifier(this.backup, this.backup);
        }
    }
    remove() {
        this.view.removeStaffModifier(this.backup);
    }
}
exports.SuiTieAdapter = SuiTieAdapter;
class SuiTieAttributesDialog extends adapter_1.SuiDialogAdapterBase {
    constructor(parameters) {
        if (!parameters.modifier) {
            throw new Error('modifier attribute dialog must have modifier');
        }
        const tie = parameters.modifier;
        const adapter = new SuiTieAdapter(parameters.view, tie);
        super(SuiTieAttributesDialog.dialogElements, Object.assign({ adapter }, parameters));
        this.displayOptions = ['BINDCOMPONENTS', 'DRAGGABLE', 'KEYBOARD_CAPTURE', 'MODIFIERPOS'];
    }
}
exports.SuiTieAttributesDialog = SuiTieAttributesDialog;
SuiTieAttributesDialog.dialogElements = {
    label: 'Tie Properties',
    staticText: [
        { label: 'Tie Properties' },
        { fromNote: 'From Note' },
        { toNote: 'To Note' }
    ], elements: [{
            smoName: 'lines',
            control: 'TieMappingComponent',
            label: 'Lines'
        }, {
            smoName: 'cp1',
            control: 'SuiRockerComponent',
            label: 'Control Point 1'
        }, {
            smoName: 'cp2',
            control: 'SuiRockerComponent',
            label: 'Control Point 2'
        }, {
            smoName: 'first_x_shift',
            control: 'SuiRockerComponent',
            label: 'X Offset 1'
        }, {
            smoName: 'last_x_shift',
            control: 'SuiRockerComponent',
            label: 'X Offset 2'
        }, {
            smoName: 'y_shift',
            defaultValue: 0,
            control: 'SuiRockerComponent',
            label: 'Y Offset'
        }, {
            smoName: 'tie_spacing',
            defaultValue: 40,
            control: 'SuiRockerComponent',
            label: 'Tie Spacing'
        }],
};


/***/ }),

/***/ "./src/ui/dialogs/timeSignature.ts":
/*!*****************************************!*\
  !*** ./src/ui/dialogs/timeSignature.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SuiTimeSignatureDialog = exports.SuiTimeSignatureAdapter = void 0;
const measureModifiers_1 = __webpack_require__(/*! ../../smo/data/measureModifiers */ "./src/smo/data/measureModifiers.ts");
const adapter_1 = __webpack_require__(/*! ./adapter */ "./src/ui/dialogs/adapter.ts");
class SuiTimeSignatureAdapter extends adapter_1.SuiComponentAdapter {
    constructor(view) {
        super(view);
        this.measure = this.view.tracker.selections[0].measure;
        this.backup = new measureModifiers_1.TimeSignature(this.measure.timeSignature);
        this.backupString = this.measure.timeSignatureString;
    }
    get numerator() {
        return this.measure.timeSignature.actualBeats;
    }
    set numerator(value) {
        this.measure.timeSignature.actualBeats = value;
    }
    get denominator() {
        return this.measure.timeSignature.beatDuration;
    }
    set denominator(value) {
        this.measure.timeSignature.beatDuration = value;
    }
    get display() {
        return this.measure.timeSignature.display;
    }
    set display(value) {
        this.measure.timeSignature.display = value;
    }
    get useSymbol() {
        return this.measure.timeSignature.useSymbol;
    }
    set useSymbol(value) {
        this.measure.timeSignature.useSymbol = value;
    }
    get customString() {
        return this.measure.timeSignatureString;
    }
    set customString(value) {
        const tr = value.trim();
        if (!(tr.indexOf('/') >= 0)) {
            if (tr === 'C' || tr === 'C|') {
                this.measure.timeSignatureString = tr;
                return;
            }
        }
        const ar = tr.split('/');
        if (isNaN(parseInt(ar[0], 10)) || isNaN(parseInt(ar[1], 10))) {
            this.measure.timeSignatureString = '';
            return;
        }
        this.measure.timeSignatureString = tr;
    }
    commit() {
        this.view.setTimeSignature(this.measure.timeSignature, this.measure.timeSignatureString);
    }
    cancel() {
        this.measure.timeSignature = this.backup;
    }
}
exports.SuiTimeSignatureAdapter = SuiTimeSignatureAdapter;
class SuiTimeSignatureDialog extends adapter_1.SuiDialogAdapterBase {
    constructor(parameters) {
        const adapter = new SuiTimeSignatureAdapter(parameters.view);
        super(SuiTimeSignatureDialog.dialogElements, Object.assign({ adapter }, parameters));
    }
}
exports.SuiTimeSignatureDialog = SuiTimeSignatureDialog;
SuiTimeSignatureDialog.dialogElements = {
    label: 'Custom Time Signature',
    elements: [
        {
            smoName: 'numerator',
            defaultValue: 3,
            control: 'SuiRockerComponent',
            label: 'Beats/Measure',
        },
        {
            smoName: 'denominator',
            defaultValue: 8,
            dataType: 'int',
            control: 'SuiDropdownComponent',
            label: 'Beat Value',
            options: [{
                    value: 16,
                    label: '16',
                }, {
                    value: 8,
                    label: '8',
                }, {
                    value: 4,
                    label: '4'
                }, {
                    value: 2,
                    label: '2'
                }]
        }, {
            smoName: 'display',
            control: 'SuiToggleComponent',
            label: 'Display',
        }, {
            smoName: 'useSymbol',
            control: 'SuiToggleComponent',
            label: 'Common/Cut',
        }, {
            smoName: 'customString',
            control: 'SuiTextInputComponent',
            label: 'Custom',
        }
    ],
    staticText: []
};


/***/ }),

/***/ "./src/ui/dialogs/volta.ts":
/*!*********************************!*\
  !*** ./src/ui/dialogs/volta.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SuiVoltaAttributeDialog = exports.SuiVoltaAdapter = void 0;
const measureModifiers_1 = __webpack_require__(/*! ../../smo/data/measureModifiers */ "./src/smo/data/measureModifiers.ts");
const adapter_1 = __webpack_require__(/*! ./adapter */ "./src/ui/dialogs/adapter.ts");
class SuiVoltaAdapter extends adapter_1.SuiComponentAdapter {
    constructor(view, volta) {
        super(view);
        this.changed = false;
        this.volta = volta;
        this.backup = new measureModifiers_1.SmoVolta(this.volta);
    }
    remove() {
        this.view.removeEnding(this.volta);
    }
    cancel() {
        if (this.changed) {
            this.view.updateEnding(this.backup);
        }
    }
    commit() {
    }
    updateVolta(param, value) {
        this.volta[param] = value;
        this.view.updateEnding(this.volta);
        this.changed = true;
    }
    get startBar() {
        return this.volta.startBar;
    }
    set startBar(val) {
        this.updateVolta('startBar', val);
    }
    get endBar() {
        return this.volta.endBar;
    }
    set endBar(val) {
        this.updateVolta('endBar', val);
    }
    get xOffsetStart() {
        return this.volta.xOffsetStart;
    }
    set xOffsetStart(val) {
        this.updateVolta('xOffsetStart', val);
    }
    get xOffsetEnd() {
        return this.volta.xOffsetEnd;
    }
    set xOffsetEnd(val) {
        this.updateVolta('xOffsetEnd', val);
    }
    get yOffset() {
        return this.volta.yOffset;
    }
    set yOffset(val) {
        this.updateVolta('yOffset', val);
    }
    get number() {
        return this.volta.number;
    }
    set number(val) {
        this.updateVolta('number', val);
    }
}
exports.SuiVoltaAdapter = SuiVoltaAdapter;
// ## SuiVoltaAttributeDialog
// aka first and second endings
class SuiVoltaAttributeDialog extends adapter_1.SuiDialogAdapterBase {
    constructor(parameters) {
        const adapter = new SuiVoltaAdapter(parameters.view, parameters.modifier);
        super(SuiVoltaAttributeDialog.dialogElements, Object.assign({ adapter }, parameters));
        this.displayOptions = ['BINDCOMPONENTS', 'DRAGGABLE', 'KEYBOARD_CAPTURE', 'MODIFIERPOS'];
    }
    static createAndDisplay(parameters) {
        if (parameters.modifier.logicalBox === null) {
            return null;
        }
        const dg = new SuiVoltaAttributeDialog(parameters);
        dg.display();
        return dg;
    }
}
exports.SuiVoltaAttributeDialog = SuiVoltaAttributeDialog;
SuiVoltaAttributeDialog.dialogElements = {
    label: 'Volta Properties', elements: [{
            smoName: 'number',
            defaultValue: 1,
            control: 'SuiRockerComponent',
            label: 'number'
        }, {
            smoName: 'xOffsetStart',
            defaultValue: 0,
            control: 'SuiRockerComponent',
            label: 'X1 Offset'
        }, {
            smoName: 'xOffsetEnd',
            defaultValue: 0,
            control: 'SuiRockerComponent',
            label: 'X2 Offset'
        }, {
            smoName: 'yOffset',
            defaultValue: 0,
            control: 'SuiRockerComponent',
            label: 'Y Offset'
        }],
    staticText: []
};


/***/ }),

/***/ "./src/ui/eventSource.ts":
/*!*******************************!*\
  !*** ./src/ui/eventSource.ts ***!
  \*******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BrowserEventSource = void 0;
const renderState_1 = __webpack_require__(/*! ../render/sui/renderState */ "./src/render/sui/renderState.ts");
/**
 * This is the event generating interface for Smoosic.  It is kept as
 * skeletal as possible so applications can call event handling methods from
 * their own event logic.
 * @category SuiUiBase
 */
class BrowserEventSource {
    constructor() {
        this.scoreChangeHandlers = [];
        this.handleMouseMove = null;
        this.handleMouseClick = null;
        this.handleMouseUp = null;
        this.handleMouseDown = null;
        this.keydownHandlers = [];
        this.mouseMoveHandlers = [];
        this.mouseClickHandlers = [];
        this.mouseUpHandlers = [];
        this.mouseDownHandlers = [];
        this.domTriggers = [];
        this.handleKeydown = this.evKey.bind(this);
        this.handleScoreChangeEvent = this.evScoreChange.bind(this);
        window.addEventListener("keydown", this.handleKeydown, true);
        window.addEventListener(renderState_1.scoreChangeEvent, this.handleScoreChangeEvent, true);
    }
    evKey(event) {
        return __awaiter(this, void 0, void 0, function* () {
            let i = 0;
            for (i = 0; i < this.keydownHandlers.length; ++i) {
                const handler = this.keydownHandlers[i];
                yield handler.sink[handler.method](event);
            }
        });
    }
    evScoreChange(event) {
        return __awaiter(this, void 0, void 0, function* () {
            let i = 0;
            for (i = 0; i < this.scoreChangeHandlers.length; ++i) {
                const handler = this.scoreChangeHandlers[i];
                yield handler.sink[handler.method](event);
            }
        });
    }
    mouseMove(event) {
        this.mouseMoveHandlers.forEach((handler) => {
            handler.sink[handler.method](event);
        });
    }
    mouseClick(event) {
        this.mouseClickHandlers.forEach((handler) => {
            handler.sink[handler.method](event);
        });
    }
    mouseDown(event) {
        this.mouseDownHandlers.forEach((handler) => {
            handler.sink[handler.method](event);
        });
    }
    mouseUp(event) {
        this.mouseUpHandlers.forEach((handler) => {
            handler.sink[handler.method](event);
        });
    }
    setRenderElement(renderElement) {
        this.renderElement = renderElement;
        var self = this;
        this.handleMouseMove = this.mouseMove.bind(this);
        this.handleMouseClick = this.mouseClick.bind(this);
        this.handleMouseUp = this.mouseUp.bind(this);
        this.handleMouseDown = this.mouseDown.bind(this);
        $(document)[0].addEventListener("mousemove", this.handleMouseMove);
        $(this.renderElement)[0].addEventListener("click", this.handleMouseClick);
        $(document)[0].addEventListener("mouseup", this.handleMouseUp);
        $(document)[0].addEventListener("mousedown", this.handleMouseDown);
    }
    _unbindHandlerArray(arSrc, arDest, handler) {
        arSrc.forEach((htest) => {
            if (handler.symbol !== htest.symbol) {
                arDest.push(htest);
            }
        });
    }
    unbindMouseMoveHandler(handler) {
        const handlers = [];
        this._unbindHandlerArray(this.mouseMoveHandlers, handlers, handler);
        this.mouseMoveHandlers = handlers;
    }
    unbindMouseDownHandler(handler) {
        const handlers = [];
        this._unbindHandlerArray(this.mouseDownHandlers, handlers, handler);
        this.mouseDownHandlers = handlers;
    }
    unbindMouseUpHandler(handler) {
        const handlers = [];
        this._unbindHandlerArray(this.mouseUpHandlers, handlers, handler);
        this.mouseUpHandlers = handlers;
    }
    unbindMouseClickHandler(handler) {
        const handlers = [];
        this._unbindHandlerArray(this.mouseClickHandlers, handlers, handler);
        this.mouseClickHandlers = handlers;
    }
    unbindKeydownHandler(handler) {
        const handlers = [];
        this._unbindHandlerArray(this.keydownHandlers, handlers, handler);
        this.keydownHandlers = handlers;
    }
    bindScroller() { }
    // ### bindKeydownHandler
    // add a handler for the evKey event, for keyboard data.
    bindKeydownHandler(sink, method) {
        var handler = { symbol: Symbol(), sink, method };
        this.keydownHandlers.push(handler);
        return handler;
    }
    bindMouseMoveHandler(sink, method) {
        var handler = { symbol: Symbol(), sink, method };
        this.mouseMoveHandlers.push(handler);
        return handler;
    }
    bindMouseUpHandler(sink, method) {
        var handler = { symbol: Symbol(), sink, method };
        this.mouseUpHandlers.push(handler);
        return handler;
    }
    bindScoreChangeHandler(sink, method) {
        var handler = { symbol: Symbol(), sink, method };
        this.scoreChangeHandlers.push(handler);
        return handler;
    }
    bindMouseDownHandler(sink, method) {
        var handler = { symbol: Symbol(), sink, method };
        this.mouseDownHandlers.push(handler);
        return handler;
    }
    bindMouseClickHandler(sink, method) {
        var handler = { symbol: Symbol(), sink, method };
        this.mouseClickHandlers.push(handler);
        return handler;
    }
    domClick(selector, sink, method, args) {
        $(selector).off('click').on('click', function (ev) {
            sink[method](ev, args);
        });
    }
}
exports.BrowserEventSource = BrowserEventSource;


/***/ }),

/***/ "./src/ui/exceptions.ts":
/*!******************************!*\
  !*** ./src/ui/exceptions.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SuiExceptionHandler = void 0;
// [Smoosic](https://github.com/AaronDavidNewman/Smoosic)
// Copyright (c) Aaron David Newman 2021.
const htmlHelpers_1 = __webpack_require__(/*! ../common/htmlHelpers */ "./src/common/htmlHelpers.ts");
const eventHandler_1 = __webpack_require__(/*! ../application/eventHandler */ "./src/application/eventHandler.ts");
class SuiExceptionHandler {
    constructor(params) {
        this.view = params.view;
        this.thrown = false;
        SuiExceptionHandler._instance = this;
    }
    static get instance() {
        return SuiExceptionHandler._instance;
    }
    exceptionHandler(e) {
        let stack = '';
        let doing = '';
        let scoreString = '';
        if (this.thrown) {
            return;
        }
        this.thrown = true;
        if (eventHandler_1.SuiEventHandler.reentry) {
            return;
        }
        eventHandler_1.SuiEventHandler.reentry = true;
        scoreString = 'Could not serialize score.';
        try {
            scoreString = this.view.score.serialize();
        }
        catch (e) {
            if (e.message) {
                scoreString += ' ' + e.message;
            }
        }
        const message = e.message;
        stack = 'No stack trace available';
        try {
            if (e.error && e.error.stack) {
                stack = e.error.stack;
            }
            else if (e.stack) {
                stack = e.stack;
            }
        }
        catch (e2) {
            stack = 'Error with stack: ' + e2.message;
        }
        doing = 'Last operation not available.';
        const lastOp = this.view.storeUndo.peek();
        if (lastOp) {
            doing = lastOp.title;
        }
        const url = 'https://github.com/AaronDavidNewman/Smoosic/issues';
        const bodyObject = JSON.stringify({
            message,
            stack,
            lastOperation: doing,
            scoreString
        }, null, ' ');
        (0, htmlHelpers_1.createTopDomContainer)('.bugDialog');
        const b = htmlHelpers_1.buildDom;
        const r = b('div').classes('bug-modal').append(b('img').attr('src', '../styles/images/logo.png').classes('bug-logo'))
            .append(b('button').classes('icon icon-cross bug-dismiss-button'))
            .append(b('span').classes('bug-title').text('oh nooooo!  You\'ve found a bug'))
            .append(b('p').text('It would be helpful if you would submit a bug report, and copy the data below into an issue'))
            .append(b('div')
            .append(b('textarea').attr('id', 'bug-text-area').text(bodyObject))
            .append(b('div').classes('button-container').append(b('button').classes('bug-submit-button').text('Submit Report'))));
        $('.bugDialog').html('');
        $('.bugDialog').append(r.dom());
        $('.bug-dismiss-button').off('click').on('click', () => {
            $('body').removeClass('bugReport');
            if (lastOp) {
                this.view.storeUndo.undo(this.view.score, {}, true);
                this.view.renderer.render();
                eventHandler_1.SuiEventHandler.reentry = false;
            }
        });
        $('.bug-submit-button').off('click').on('click', () => {
            $('#bug-text-area').select();
            document.execCommand('copy');
            window.open(url, 'Report Smoosic issues');
        });
        $('body').addClass('bugReport');
        if (!this.thrown) {
            this.thrown = true;
            throw (e);
        }
    }
}
exports.SuiExceptionHandler = SuiExceptionHandler;


/***/ }),

/***/ "./src/ui/fileio/fileInput.ts":
/*!************************************!*\
  !*** ./src/ui/fileio/fileInput.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SuiFileInput = void 0;
// ## SuiFileInput
// Get a string or binary file  from a file input control and transparently
// decompress it if it's mxml file (compressed).  This will read any text  or
// binary file,
// but it will only unzip .mxml files first and has a consistent async interface
class SuiFileInput {
    constructor(evt) {
        this.compressed = false;
        this.binary = false;
        this.compressed = false;
        this.binary = false;
        this.value = null;
        this.event = evt;
        if (evt.target.files[0].name.endsWith('.mxl')) {
            this.compressed = true;
            this.binary = true;
        }
        else if (evt.target.files[0].name.endsWith('.mid')) {
            this.binary = true;
        }
    }
    _handleZip() {
        const self = this;
        return new Promise((resolve) => {
            JSZip.loadAsync(self.value).then((zip) => {
                // Find the real xml file in the zip (not metadata)
                const filename = Object.keys(zip.files).find((ss) => ss.indexOf('META') < 0 && ss.endsWith('xml'));
                zip.file(filename).async('text').then((str) => {
                    self.value = str;
                    resolve();
                });
            });
        });
    }
    loadAsync() {
        const self = this;
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = (file) => {
                if (file === null || file.target === null || file.target.result === null) {
                    reject();
                    return;
                }
                self.value = file.target.result;
                if (!self.compressed) {
                    resolve();
                }
                else {
                    self._handleZip().then(() => {
                        resolve();
                    });
                }
            };
            if (self.binary) {
                reader.readAsArrayBuffer(self.event.target.files[0]);
            }
            else {
                reader.readAsText(self.event.target.files[0]);
            }
        });
    }
}
exports.SuiFileInput = SuiFileInput;


/***/ }),

/***/ "./src/ui/fileio/library.ts":
/*!**********************************!*\
  !*** ./src/ui/fileio/library.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SmoLibrary = void 0;
// [Smoosic](https://github.com/AaronDavidNewman/Smoosic)
// Copyright (c) Aaron David Newman 2021.
const xhrLoader_1 = __webpack_require__(/*! ./xhrLoader */ "./src/ui/fileio/xhrLoader.ts");
const promiseHelpers_1 = __webpack_require__(/*! ../../common/promiseHelpers */ "./src/common/promiseHelpers.ts");
const serializationHelpers_1 = __webpack_require__(/*! ../../common/serializationHelpers */ "./src/common/serializationHelpers.js");
// ## SmoLibrary
// A class to organize smoosic files (or any format smoosic accepts) into libraries.
class SmoLibrary {
    constructor(parameters) {
        this.url = '';
        this.format = 'smo';
        this.metadata = {};
        this.children = [];
        this.loaded = false;
        this.parentLib = {};
        if (parameters.url) {
            this.url = parameters.url;
        }
        else if (parameters.data) {
            this.initialize(parameters.data);
        }
    }
    initialize(parameters) {
        serializationHelpers_1.smoSerialize.serializedMerge(SmoLibrary.parameterArray, SmoLibrary.defaults, this);
        // if the object was loaded from URL, use that.
        if (!this.url) {
            this.url = parameters.url;
        }
        this.format = parameters.format;
        Object.keys(parameters.metadata).forEach((key) => {
            this.metadata[key] = parameters.metadata[key];
        });
        this.children = [];
        if (typeof (parameters.children) !== 'undefined') {
            parameters.children.forEach((childLib) => {
                this.children.push(new SmoLibrary({ data: childLib }));
            });
        }
        this.children.forEach((child) => {
            child._inheritMetadata(this);
        });
    }
    static get metadataNames() {
        return ['name', 'icon', 'tags', 'composer', 'artist', 'copyright',
            'title', 'subtitle', 'movement', 'source'];
    }
    static get formatTypes() {
        return ['smoosic', 'library', 'mxml', 'midi', 'abc'];
    }
    static get libraryTypes() {
        return ['work', 'transcription', 'library', 'collection'];
    }
    static get defaults() {
        if (typeof (SmoLibrary._defaults) === 'undefined') {
            SmoLibrary._defaults = { children: [], metadata: {} };
        }
        return SmoLibrary._defaults;
    }
    static get parameterArray() {
        return ['children', 'metadata', 'format', 'url'];
    }
    load() {
        const self = this;
        if (this.loaded) {
            return promiseHelpers_1.PromiseHelpers.emptyPromise();
        }
        const loader = new xhrLoader_1.SuiXhrLoader(this.url);
        return new Promise((resolve) => {
            loader.loadAsync().then(() => {
                const jsonObj = JSON.parse(loader.value);
                self.initialize(jsonObj);
                self.loaded = true;
                resolve();
            });
        });
    }
    _inheritMetadata(parent) {
        // eslint-disable-next-line
        for (const key in parent) {
            if (typeof (this.metadata[key]) === 'undefined') {
                this.metadata[key] = parent[key];
            }
        }
        this.parentLib = { name: parent.metadata.name, value: parent };
        this.children.forEach((child) => {
            child._inheritMetadata(this);
        });
    }
}
exports.SmoLibrary = SmoLibrary;


/***/ }),

/***/ "./src/ui/fileio/xhrLoader.ts":
/*!************************************!*\
  !*** ./src/ui/fileio/xhrLoader.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports) => {


// [Smoosic](https://github.com/AaronDavidNewman/Smoosic)
// Copyright (c) Aaron David Newman 2021.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SuiXhrLoader = void 0;
/**
 * Load a file.  Guess based on the extension whether the file is string or binary
 */
class SuiXhrLoader {
    constructor(path) {
        this.compressed = false;
        this.value = null;
        this.binary = false;
        this.isMidi = false;
        this.path = path;
        if (path.endsWith('mxl')) {
            this.compressed = true;
            this.binary = true;
        }
        else if (path.endsWith('mid')) {
            this.isMidi = true;
            this.binary = true;
        }
    }
    _uncompress(result) {
        const self = this;
        return new Promise((resolve) => {
            JSZip.loadAsync(result).then((zip) => {
                // Find the real xml file in the zip (not metadata)
                const filename = Object.keys(zip.files).find((ss) => ss.indexOf('META') < 0 && ss.endsWith('xml'));
                zip.file(filename).async('text').then((str) => {
                    self.value = str;
                    resolve();
                });
            });
        });
    }
    /**
     *
     * @returns promise resolved when the target file is loaded
     */
    loadAsync() {
        const req = new XMLHttpRequest();
        const self = this;
        const promise = new Promise((resolve) => {
            req.addEventListener('load', () => {
                const reader = new FileReader();
                reader.addEventListener('loadend', () => {
                    if (self.isMidi) {
                        self.value = new Uint8Array(reader.result);
                        resolve();
                    }
                    else if (!self.compressed) {
                        self.value = reader.result;
                        resolve();
                    }
                    else {
                        self._uncompress(reader.result).then(() => { resolve(); });
                    }
                });
                if (this.isMidi) {
                    reader.readAsArrayBuffer(req.response);
                }
                else if (this.binary) {
                    reader.readAsBinaryString(req.response);
                }
                else {
                    reader.readAsText(req.response);
                }
            });
        });
        req.responseType = 'blob';
        req.open('GET', this.path);
        req.send();
        return promise;
    }
}
exports.SuiXhrLoader = SuiXhrLoader;


/***/ }),

/***/ "./src/ui/help.ts":
/*!************************!*\
  !*** ./src/ui/help.ts ***!
  \************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SuiHelp = void 0;
// [Smoosic](https://github.com/AaronDavidNewman/Smoosic)
// Copyright (c) Aaron David Newman 2021.
const htmlHelpers_1 = __webpack_require__(/*! ../common/htmlHelpers */ "./src/common/htmlHelpers.ts");
const language_1 = __webpack_require__(/*! ./i18n/language */ "./src/ui/i18n/language.ts");
class SuiHelp {
    static displayHelp() {
        $('body').addClass('showHelpDialog');
        if (!SuiHelp.created) {
            (0, htmlHelpers_1.createTopDomContainer)('helpDialog');
            SuiHelp.created = true;
        }
        $('.helpDialog').html('');
        $('.helpDialog').append(SuiHelp.closeButton.dom());
        SuiHelp.helpHtml.forEach((cat, catIx) => {
            const r = SuiHelp._buildElements(cat);
            $('.helpDialog').append(r.dom());
        });
        $('button.help-title').off('click').on('click', (ev) => {
            $(ev.currentTarget).closest('div.helpLine').toggleClass('showSection');
            $(ev.currentTarget).find('span.icon').toggleClass('icon-plus');
            $(ev.currentTarget).find('span.icon').toggleClass('icon-minus');
        });
        $('.helpDialog button.icon-cross').off('click').on('click', () => {
            $('body').removeClass('showHelpDialog');
            $('.workspace').css('height', '');
        });
        const wsh = window.innerHeight;
        $('.workspace').css('height', '' + wsh + 'px');
        const cb = () => { };
        (0, htmlHelpers_1.createTopDomContainer)('.draganime');
        (0, htmlHelpers_1.draggable)({
            parent: $('.helpDialog'),
            handle: $('.helpDialog').find('.icon-move'),
            animateDiv: '.draganime',
            cb,
            moveParent: true
        });
        SuiHelp.setCards();
    }
    static setCards() {
        $('.helpDialog').addClass('card-view');
        const lines = $('.helpDialog .helpLine');
        const numLines = $(lines).length;
        $(lines).each((ix, line) => {
            const lineno = parseInt($(line).attr('data-index'));
            if (lineno !== SuiHelp.currentCard) {
                $(line).addClass('hide');
            }
            else {
                $(line).removeClass('hide');
                const prevButton = $(line).find('button.prev-topic');
                const nextButton = $(line).find('button.next-topic');
                if (lineno === numLines - 1) {
                    $(nextButton).addClass('hide');
                }
                if (lineno === 0) {
                    $(prevButton).addClass('hide');
                }
                $(prevButton).off('click').on('click', () => {
                    SuiHelp.currentCard = (SuiHelp.currentCard + (numLines - 1)) % numLines;
                    SuiHelp.setCards();
                });
                $(nextButton).off('click').on('click', () => {
                    SuiHelp.currentCard = (SuiHelp.currentCard + 1) % numLines;
                    SuiHelp.setCards();
                });
            }
        });
    }
    static get closeButton() {
        const b = htmlHelpers_1.buildDom;
        const r = b('div').append(b('span').classes('icon icon-move')).append('div').classes('help-closer').append(b('button').classes('icon-cross close'));
        return r;
    }
    static _buildElements(helps) {
        const b = htmlHelpers_1.buildDom;
        const r = b('div').classes('helpLine').attr('data-index', helps.index.toString())
            .append(b('div').classes('help-category-button')
            .append(b('button')
            .append(b('span').classes('icon icon-plus')).classes('help-title')
            .append(b('span').classes('help-category-text').text(helps.title))))
            .append(b('h3').text(helps.title))
            .append(b('div').classes('help-content').html(helps.html))
            .append(b('div').classes('button-container')
            .append(b('button').classes('prev-topic')
            .append(b('span').classes('icon icon-arrow-left'))
            .append(b('span').classes('prev-topic-text').text('Previous Topic')))
            .append(b('button').classes('next-topic')
            .append(b('span').classes('next-topic-text').text('Next Topic'))
            .append(b('span').classes(' icon icon-arrow-right'))));
        return r;
    }
    static get helpHtml() {
        /* [cardKeysHtmlEn, cardNotesLetterHtmlEn, cardNotesChromaticHtmlEn, cardNotesChordsHtmlEn,
      cardNotesRestsHtmlEn, cardDurationNotesHtmlEn, cardDurationTupletsHtmlEn,
      cardSelectionsNotesHtmlEn, cardSelectionsModifiersHtmlEn, cardSelectionsNonSelectableHtmlEn, cardSelectionsSlashHtmlEn,
      cardBeamsAndStemsDirectionHtmlEn, cardBeamsAndStemsGroupingHtmlEn,
      cardMeasuresAddDeleteHtmlEn, cardVoicesCreateDeleteHtmlEn, cardVoicesHiddenNotesHtmlEn
    ]; */
        const cards = [
            { title: 'Keys', html: language_1.SmoLanguage.getHelpFile('cardKeysHtml') },
            { title: 'Notes - letter notes', html: language_1.SmoLanguage.getHelpFile('cardNotesLetterHtml') },
            { title: 'Notes - chromatic and octave', html: language_1.SmoLanguage.getHelpFile('cardNotesChromaticHtml') },
            { title: 'Notes - chords', html: language_1.SmoLanguage.getHelpFile('cardNotesChordsHtml') },
            { title: 'Notes - rests', html: language_1.SmoLanguage.getHelpFile('cardNotesRestsHtml') },
            { title: 'Duration', html: language_1.SmoLanguage.getHelpFile('cardDurationNotesHtml') },
            { title: 'Duration - tuplets', html: language_1.SmoLanguage.getHelpFile('cardDurationTupletsHtml') },
            { title: 'Selections - notes', html: language_1.SmoLanguage.getHelpFile('cardSelectionsNotesHtml') },
            { title: 'Selections - modifiers', html: language_1.SmoLanguage.getHelpFile('cardSelectionsModifiersHtml') },
            { title: 'Selections - non-selectable modifiers', html: language_1.SmoLanguage.getHelpFile('cardSelectionsNonSelectableHtml') },
            { title: 'Selections - slash menus', html: language_1.SmoLanguage.getHelpFile('cardSelectionsSlashHtml') },
            { title: 'Beams and Stems - direction', html: language_1.SmoLanguage.getHelpFile('cardBeamsAndStemsDirectionHtml') },
            { title: 'Beams and Stems - grouping', html: language_1.SmoLanguage.getHelpFile('cardBeamsAndStemsGroupingHtml') },
            { title: 'Measures - insert and delete', html: language_1.SmoLanguage.getHelpFile('cardMeasuresAddDeleteHtml') },
            { title: 'Staves - add and delete', html: language_1.SmoLanguage.getHelpFile('cardPartAddDeleteHtml') },
            { title: 'Voices - create and delete', html: language_1.SmoLanguage.getHelpFile('cardVoicesCreateDeleteHtml') },
        ];
        const blocks = [];
        cards.forEach((card, cardIx) => {
            blocks.push(Object.assign({ index: cardIx }, card));
        });
        return blocks;
    }
}
exports.SuiHelp = SuiHelp;
SuiHelp.helpMode = 'cards';
SuiHelp.created = false;
SuiHelp.currentCard = 0;


/***/ }),

/***/ "./src/ui/i18n/language.ts":
/*!*********************************!*\
  !*** ./src/ui/i18n/language.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SmoLanguage = exports.SmoTranslator = void 0;
// [Smoosic](https://github.com/AaronDavidNewman/Smoosic)
// Copyright (c) Aaron David Newman 2021.
const language_ar_1 = __webpack_require__(/*! ./language_ar */ "./src/ui/i18n/language_ar.js");
const language_de_1 = __webpack_require__(/*! ./language_de */ "./src/ui/i18n/language_de.js");
const language_en_1 = __webpack_require__(/*! ./language_en */ "./src/ui/i18n/language_en.js");
const ribbon_1 = __webpack_require__(/*! ../buttons/ribbon */ "./src/ui/buttons/ribbon.ts");
class SmoTranslator {
    static registerMenu(_class) {
        if (!SmoTranslator.menus[_class]) {
            SmoTranslator.menus[_class] = true;
        }
    }
    static registerDialog(_class) {
        if (!SmoTranslator.dialogs[_class]) {
            SmoTranslator.dialogs[_class] = true;
        }
    }
    static printLanguages() {
        const dialogs = [];
        const menus = [];
        SmoTranslator.allDialogs.forEach((key) => {
            SmoTranslator.registerDialog(key);
            const translatable = eval('globalThis.Smo.' + key);
            dialogs.push(translatable.printTranslate(key));
        });
        SmoTranslator.allMenus.forEach((key) => {
            SmoTranslator.registerMenu(key);
            const translatable = eval('globalThis.Smo.' + key);
            menus.push(translatable.printTranslate(key));
        });
        const buttonText = JSON.parse(JSON.stringify(ribbon_1.RibbonButtons.translateButtons));
        console.log(JSON.stringify({ dialogs, menus, buttonText }, null, ' '));
    }
    static _updateDialog(dialogStrings, _dialogClass, dialogClass) {
        if (!dialogStrings) {
            console.log('no strings for Dialog ' + dialogClass);
            return;
        }
        _dialogClass.label = dialogStrings.label;
        const staticText = dialogStrings.staticText;
        if (staticText || _dialogClass.dialogElements.staticText) {
            const keys = Object.keys(staticText);
            keys.forEach((key) => {
                _dialogClass.dialogElements.staticText[key] = staticText[key];
            });
        }
        _dialogClass.dialogElements.label = dialogStrings.label;
        _dialogClass.dialogElements.elements.forEach((component) => {
            const componentStrings = dialogStrings.dialogElements.find((ds) => ds.id === component.smoName);
            if (componentStrings) {
                component.label = componentStrings.label;
                if (component.options) {
                    component.options.forEach((option) => {
                        const optionString = componentStrings.options.find((cs) => cs.value === option.value);
                        if (!optionString) {
                            console.log('no string for option ' + option.value + ' in component ' + component.smoName + ' in dialog ' + dialogClass);
                        }
                        else {
                            option.label = optionString.label;
                        }
                    });
                }
            }
            else {
                console.log('Untranslated component in  ' + dialogClass);
            }
        });
    }
    static _updateMenu(menuStrings, _menuClass, menuClass) {
        if (!menuStrings) {
            console.log('no strings for Menu ' + menuClass);
            return;
        }
        const defaults = _menuClass.defaults;
        defaults.menuItems.forEach((menuItem) => {
            const val = menuItem.value;
            const nvPair = menuStrings.menuItems.find((ff) => ff.value === val);
            if (!nvPair) {
                console.log('no xlate for ' + val + ' in menu ' + menuClass);
            }
            else {
                menuItem.text = nvPair.text;
                console.log('setting menu item value ' + val + ' to ' + nvPair.text);
            }
        });
    }
    static setLanguage(language) {
        if (!SmoLanguage[language]) {
            return; // no xlate exists
        }
        const trans = SmoLanguage[language];
        // Set the text in all the menus
        SmoTranslator.allMenus.forEach((menuClass) => {
            const _class = eval('globalThis.Smo.' + menuClass);
            const menuStrings = trans.strings.menus.find((mm) => mm.ctor === menuClass);
            if (menuStrings) {
                SmoTranslator._updateMenu(menuStrings, _class, menuClass);
                // Set text in ribbon buttons that invoke menus
                const menuButton = $('.ribbonButtonContainer button.' + menuClass).find('.left-text .text-span');
                if (menuButton.length && menuStrings) {
                    $(menuButton).text(menuStrings.label);
                }
            }
        });
        SmoTranslator.allDialogs.forEach((dialogClass) => {
            const _class = eval('globalThis.Smo.' + dialogClass);
            const dialogStrings = trans.strings.dialogs.find((mm) => mm.ctor === dialogClass);
            if (typeof (_class) === 'undefined') {
                console.log('no eval for class ' + dialogClass);
                return;
            }
            if (!dialogStrings) {
                return;
            }
            // Set text in ribbon buttons that invoke menus
            const dialogButton = $('.ribbonButtonContainer button.' + dialogClass).find('.left-text .text-span');
            if (dialogButton.length && dialogStrings) {
                $(dialogButton).text(dialogStrings.label);
            }
            SmoTranslator._updateDialog(dialogStrings, _class, dialogClass);
        });
        // Translate the buttons on the ribbon
        const langButtons = trans.strings.buttonText;
        if (langButtons) {
            ribbon_1.RibbonButtons.translateButtons.forEach((button) => {
                const langButton = langButtons.find((lb) => lb.buttonId === button.buttonId);
                if (langButton) {
                    const buttonDom = $('.ribbonButtonContainer #' + button.buttonId);
                    if (buttonDom.length) {
                        $(buttonDom).find('.left-text').text(langButton.buttonText);
                    }
                }
            });
        }
        // Handle rtl languages
        $('body').find('.language-dir').each((ix, dd) => { $(dd).attr('dir', trans.dir); });
    }
    static get allMenus() {
        return [
            'SuiDynamicsMenu',
            'SuiFileMenu',
            'SuiKeySignatureMenu',
            'SuiLanguageMenu',
            'SuiMeasureMenu',
            'SuiPartMenu',
            'SuiScoreMenu',
            'SuiStaffModifierMenu',
            'SuiTimeSignatureMenu',
        ];
    }
    static get allDialogs() {
        return [
            // file dialogs
            'SuiChordChangeDialog',
            'SuiDynamicModifierDialog',
            'SuiGlobalLayoutDialog',
            'SuiHairpinAttributesDialog',
            'SuiInsertMeasures',
            'SuiInstrumentDialog',
            'SuiLoadFileDialog',
            'SuiLoadMxmlDialog',
            'SuiLyricDialog',
            'SuiMeasureDialog',
            'SuiPageLayoutDialog',
            'SuiPartInfoDialog',
            'SuiPrintFileDialog',
            'SuiSaveFileDialog',
            'SuiSaveMidiDialog',
            'SuiSaveXmlDialog',
            'SuiScoreFontDialog',
            'SuiScorePreferencesDialog',
            'SuiScoreIdentificationDialog',
            'SuiScoreViewDialog',
            'SuiSlurAttributesDialog',
            'SuiStaffGroupDialog',
            'SuiTempoDialog',
            'SuiTextBlockDialog',
            'SuiTieAttributesDialog',
            'SuiTimeSignatureDialog',
            'SuiVoltaAttributeDialog'
        ];
    }
}
exports.SmoTranslator = SmoTranslator;
SmoTranslator.dialogs = [];
SmoTranslator.menus = [];
class SmoLanguage {
    static getHelpFile(category) {
        // TODO: how to express language if it is not part of the config?
        return eval('globalThis.Smo.' + category + 'En');
    }
    static get en() {
        const strings = JSON.parse(language_en_1.smoLanguageStringEn);
        const rv = { dir: 'ltr', strings, helpHtml: {} };
        return rv;
    }
    static get ar() {
        const strings = JSON.parse(language_ar_1.smoLanguageStringAr);
        const rv = { dir: 'rtl', strings, helpHtml: {} };
        return rv;
    }
    static get de() {
        const strings = JSON.parse(language_de_1.smoLanguageStringDe);
        const rv = { dir: 'ltr', strings, helpHtml: {} };
        return rv;
    }
}
exports.SmoLanguage = SmoLanguage;


/***/ }),

/***/ "./src/ui/i18n/language_ar.js":
/*!************************************!*\
  !*** ./src/ui/i18n/language_ar.js ***!
  \************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.enterPitchesHtmlar = exports.enterDurationsHtmlar = exports.selectionHtmlar = exports.quickStartHtmlar = exports.smoLanguageStringAr = void 0;
exports.smoLanguageStringAr = `{
    "dialogs": [
     {
      "ctor": "SuiLoadFileDialog",
      "label": "Load File",
      "dialogElements": [
       {}
      ],
      "staticText": {}
     },
     {
      "ctor": "SuiSaveFileDialog",
      "label": "Save Score",
      "dialogElements": [
       {
        "label": "File Name",
        "id": "saveFileName"
       }
      ],
      "staticText": {}
     },
     {
      "ctor": "SuiSaveXmlDialog",
      "label": "Save Score",
      "dialogElements": [
       {
        "label": "File Name",
        "id": "saveFileName"
       }
      ],
      "staticText": {}
     },
     {
      "ctor": "SuiPrintFileDialog",
      "label": "Print Complete",
      "dialogElements": [],
      "staticText": {}
     },
     {
      "ctor": "SuiSaveMidiDialog",
      "label": "Save Score as Midi",
      "dialogElements": [
       {
        "label": "File Name",
        "id": "saveFileName"
       }
      ],
      "staticText": {}
     },
     {
      "ctor": "SuiSaveActionsDialog",
      "label": "Save Score",
      "dialogElements": [
       {
        "label": "File Name",
        "id": "saveFileName"
       }
      ],
      "staticText": {}
     },
     {
      "ctor": "SuiLoadMxmlDialog",
      "label": "Load File",
      "dialogElements": [
       {},
       {
        "staticText": {
         "label": "Load File"
        }
       }
      ],
      "staticText": {}
     },
     {
      "ctor": "SuiLoadActionsDialog",
      "label": "Load Action File",
      "dialogElements": [
       {},
       {
        "staticText": {
         "label": "Load Action File"
        }
       }
      ],
      "staticText": {}
     },
     {
      "ctor": "SuiMeasureDialog",
      "label": "Measure Properties",
      "dialogElements": [
       {
        "label": "Pickup",
        "id": "pickup"
       },
       {
        "label": "Pad Left (px)",
        "id": "padLeft"
       },
       {
        "label": "Stretch Contents",
        "id": "customStretch"
       },
       {
        "label": "Proportionalality",
        "id": "customProportion"
       },
       {
        "label": "Pad all measures in system",
        "id": "padAllInSystem"
       },
       {
        "label": "Justify Columns",
        "id": "autoJustify"
       },
       {
        "label": "Text Position",
        "id": "measureTextPosition",
        "options": [
         {
          "value": 2,
          "label": "Left"
         },
         {
          "value": 3,
          "label": "Right"
         },
         {
          "value": 0,
          "label": "Above"
         },
         {
          "value": 1,
          "label": "Below"
         }
        ]
       },
       {
        "label": "System break before this measure",
        "id": "systemBreak"
       }
      ],
      "staticText": {}
     },
     {
      "ctor": "SuiTempoDialog",
      "label": "Tempo Properties",
      "dialogElements": [
       {
        "label": " ",
        "id": "tempoMode",
        "options": [
         {
          "value": "duration",
          "label": "Duration (Beats/Minute)"
         },
         {
          "value": "text",
          "label": "Tempo Text"
         },
         {
          "value": "custom",
          "label": "Specify text and duration"
         }
        ]
       },
       {
        "label": "Custom Text",
        "id": "customText"
       },
       {
        "label": "Notes/Minute",
        "id": "bpm"
       },
       {
        "label": "  ",
        "id": "beatDuration",
        "options": [
         {
          "value": 4096,
          "label": "Quarter Note"
         },
         {
          "value": 2048,
          "label": "1/8 note"
         },
         {
          "value": 6144,
          "label": "Dotted 1/4 note"
         },
         {
          "value": 8192,
          "label": "1/2 note"
         }
        ]
       },
       {
        "label": "Tempo Text",
        "id": "tempoText",
        "options": [
         {
          "value": "Larghissimo",
          "label": "Larghissimo"
         },
         {
          "value": "Grave",
          "label": "Grave"
         },
         {
          "value": "Lento",
          "label": "Lento"
         },
         {
          "value": "Largo",
          "label": "Largo"
         },
         {
          "value": "Larghetto",
          "label": "Larghetto"
         },
         {
          "value": "Adagio",
          "label": "Adagio"
         },
         {
          "value": "Adagietto",
          "label": "Adagietto"
         },
         {
          "value": "Andante moderato",
          "label": "Andante moderato"
         },
         {
          "value": "Andante",
          "label": "Andante"
         },
         {
          "value": "Andantino",
          "label": "Andantino"
         },
         {
          "value": "Moderato",
          "label": "Moderato"
         },
         {
          "value": "Allegretto",
          "label": "Allegretto"
         },
         {
          "value": "Allegro",
          "label": "Allegro"
         },
         {
          "value": "Vivace",
          "label": "Vivace"
         },
         {
          "value": "Presto",
          "label": "Presto"
         },
         {
          "value": "Prestissimo",
          "label": "Prestissimo"
         }
        ]
       },
       {
        "label": "Apply to all future measures?",
        "id": "applyToAll"
       },
       {
        "label": "Display Tempo",
        "id": "display"
       },
       {
        "label": "Y Offset",
        "id": "yOffset"
       }
      ],
      "staticText": {}
     },
     {
      "ctor": "SuiInstrumentDialog",
      "label": "Instrument Properties",
      "dialogElements": [
       {
        "label": "Transpose Index (1/2 steps)",
        "id": "transposeIndex"
       },
       {
        "label": "Apply To",
        "id": "applyTo",
        "options": [
         {
          "value": 0,
          "label": "Score"
         },
         {
          "value": 1,
          "label": "Selected Measures"
         },
         {
          "value": 3,
          "label": "Remaining Measures"
         }
        ]
       }
      ],
      "staticText": {}
     },
     {
      "ctor": "SuiInsertMeasures",
      "label": "Insert Measures",
      "dialogElements": [
       {
        "label": "Measures to Insert",
        "id": "measureCount"
       },
       {
        "label": "Append to Selection",
        "id": "append"
       }
      ],
      "staticText": {}
     },
     {
      "ctor": "SuiTimeSignatureDialog",
      "label": "Custom Time Signature",
      "dialogElements": [
       {
        "label": "Beats/Measure",
        "id": "numerator"
       },
       {
        "label": "Beat Value",
        "id": "denominator",
        "options": [
         {
          "value": 8,
          "label": "8"
         },
         {
          "value": 4,
          "label": "4"
         },
         {
          "value": 2,
          "label": "2"
         }
        ]
       },
       {
        "label": "Display",
        "id": "display"
       }
      ],
      "staticText": {}
     },
     {
      "ctor": "SuiScoreViewDialog",
      "label": "Score View",
      "dialogElements": [
       {
        "label": "Show staff",
        "id": "scoreView"
       }
      ],
      "staticText": {}
     },
     {
      "ctor": "SuiScoreIdentificationDialog",
      "label": "Score Preferences",
      "dialogElements": [
       {
        "label": "Title",
        "id": "title"
       },
       {
        "label": "Sub Title",
        "id": "subTitle"
       },
       {
        "label": "Composer",
        "id": "composer"
       },
       {
        "label": "Copyright",
        "id": "copyright"
       }
      ],
      "staticText": {
       "titleText": "Title",
       "subTitleText": "Sub-title",
       "copyrightText": "Copyright",
       "composerText": "Composer",
       "show": "Show"
      }
     },
     {
      "ctor": "SuiGlobalLayoutDialog",
      "label": "Global Settings",
      "dialogElements": [
       {
        "label": "Score Name",
        "id": "scoreName"
       },
       {
        "label": "Play Selections",
        "id": "autoPlay"
       },
       {
        "label": "Auto-Advance Cursor",
        "id": "autoAdvance"
       },
       {
        "label": "Note Spacing",
        "id": "noteSpacing"
       },
       {
        "label": "Page Size",
        "id": "pageSize",
        "options": [
         {
          "value": "letter",
          "label": "Letter (Portrait)"
         },
         {
          "value": "letterLandscape",
          "label": "Letter (Landscape)"
         },
         {
          "value": "tabloid",
          "label": "Tabloid (11x17)"
         },
         {
          "value": "A4",
          "label": "A4"
         },
         {
          "value": "custom",
          "label": "Custom"
         }
        ]
       },
       {
        "label": "Page Width (px)",
        "id": "pageWidth"
       },
       {
        "label": "Page Height (px)",
        "id": "pageHeight"
       },
       {
        "label": "% Zoom",
        "id": "zoomScale"
       },
       {
        "label": "% Note size",
        "id": "svgScale"
       }
      ],
      "staticText": {}
     },
     {
      "ctor": "SuiScoreFontDialog",
      "label": "Score Fonts",
      "dialogElements": [
       {
        "label": "Engraving Font",
        "id": "engravingFont",
        "options": [
         {
          "value": "Bravura",
          "label": "Bravura"
         },
         {
          "value": "Gonville",
          "label": "Gonville"
         },
         {
          "value": "Petaluma",
          "label": "Petaluma"
         },
         {
          "value": "Leland",
          "label": "Leland"
         }
        ]
       },
       {
        "label": "Chord Font",
        "id": "chordFont"
       },
       {
        "label": "Lyric Font",
        "id": "lyricFont"
       }
      ],
      "staticText": {}
     },
     {
      "ctor": "SuiLayoutDialog",
      "label": "Page Layouts",
      "dialogElements": [
       {
        "label": "Apply to Page",
        "id": "applyToPage",
        "options": [
         {
          "value": -1,
          "label": "All"
         },
         {
          "value": -2,
          "label": "All Remaining"
         },
         {
          "value": 1,
          "label": "Page 1"
         }
        ]
       },
       {
        "label": "Left Margin (px)",
        "id": "leftMargin"
       },
       {
        "label": "Right Margin (px)",
        "id": "rightMargin"
       },
       {
        "label": "Top Margin (px)",
        "id": "topMargin"
       },
       {
        "label": "Bottom Margin (px)",
        "id": "bottomMargin"
       },
       {
        "label": "Inter-System Margin",
        "id": "interGap"
       },
       {
        "label": "Intra-System Margin",
        "id": "intraGap"
       },
       {
        "staticText": {
         "label": "Page Layouts"
        }
       }
      ],
      "staticText": {}
     },
     {
      "ctor": "SuiSlurAttributesDialog",
      "label": "Slur Properties",
      "dialogElements": [
       {
        "label": "Spacing",
        "id": "spacing"
       },
       {
        "label": "Thickness",
        "id": "thickness"
       },
       {
        "label": "X Offset",
        "id": "xOffset"
       },
       {
        "label": "Y Offset",
        "id": "yOffset"
       },
       {
        "label": "Start Position",
        "id": "position",
        "options": [
         {
          "value": 1,
          "label": "Head"
         },
         {
          "value": 2,
          "label": "Top"
         }
        ]
       },
       {
        "label": "End Position",
        "id": "position_end",
        "options": [
         {
          "value": 1,
          "label": "Head"
         },
         {
          "value": 2,
          "label": "Top"
         }
        ]
       },
       {
        "label": "Invert",
        "id": "invert"
       },
       {
        "label": "Control Point 1 X",
        "id": "cp1x"
       },
       {
        "label": "Control Point 1 Y",
        "id": "cp1y"
       },
       {
        "label": "Control Point 2 X",
        "id": "cp2x"
       },
       {
        "label": "Control Point 2 Y",
        "id": "cp2y"
       }
      ],
      "staticText": {}
     },
     {
      "ctor": "SuiTieAttributesDialog",
      "label": "Tie Properties",
      "dialogElements": [
       {
        "label": "Lines",
        "id": "lines"
       }
      ],
      "staticText": {
       "label": "Tie Properties",
       "fromNote": "From Note",
       "toNote": "To Note"
      }
     },
     {
      "ctor": "SuiVoltaAttributeDialog",
      "label": "Volta Properties",
      "dialogElements": [
       {
        "label": "number",
        "id": "number"
       },
       {
        "label": "X1 Offset",
        "id": "xOffsetStart"
       },
       {
        "label": "X2 Offset",
        "id": "xOffsetEnd"
       },
       {
        "label": "Y Offset",
        "id": "yOffset"
       }
      ],
      "staticText": {}
     },
     {
      "ctor": "SuiHairpinAttributesDialog",
      "label": "Hairpin Properties",
      "dialogElements": [
       {
        "label": "Height",
        "id": "height"
       },
       {
        "label": "Y Shift",
        "id": "yOffset"
       },
       {
        "label": "Right Shift",
        "id": "xOffsetRight"
       },
       {
        "label": "Left Shift",
        "id": "xOffsetLeft"
       }
      ],
      "staticText": {}
     },
     {
      "ctor": "SuiStaffGroupDialog",
      "label": "Staff Group",
      "dialogElements": [
       {
        "label": "Staves in Group",
        "id": "staffGroups"
       },
       {
        "label": "Left Connector",
        "id": "leftConnector",
        "options": [
         {
          "value": 1,
          "label": "Bracket"
         },
         {
          "value": 0,
          "label": "Brace"
         },
         {
          "value": 2,
          "label": "Single"
         },
         {
          "value": 3,
          "label": "Double"
         }
        ]
       }
      ],
      "staticText": {
       "includeStaff": "Include Staff"
      }
     },
     {
      "ctor": "SuiDynamicModifierDialog",
      "label": "Dynamics Properties",
      "dialogElements": [
       {
        "label": "Y Line",
        "id": "yOffsetLine"
       },
       {
        "label": "Y Offset Px",
        "id": "yOffsetPixels"
       },
       {
        "label": "X Offset",
        "id": "xOffset"
       },
       {
        "label": "Text",
        "id": "text",
        "options": [
         {
          "value": "p",
          "label": "Piano"
         },
         {
          "value": "pp",
          "label": "Pianissimo"
         },
         {
          "value": "mp",
          "label": "Mezzo-Piano"
         },
         {
          "value": "mf",
          "label": "Mezzo-Forte"
         },
         {
          "value": "f",
          "label": "Forte"
         },
         {
          "value": "ff",
          "label": "Fortissimo"
         },
         {
          "value": "sfz",
          "label": "Sforzando"
         }
        ]
       }
      ],
      "staticText": {}
     },
     {
      "ctor": "SuiLyricDialog",
      "label": "Lyric Editor",
      "dialogElements": [
       {
        "label": "Verse",
        "id": "verse",
        "options": [
         {
          "value": 0,
          "label": "1"
         },
         {
          "value": 1,
          "label": "2"
         },
         {
          "value": 2,
          "label": "3"
         },
         {
          "value": 3,
          "label": "4"
         }
        ]
       },
       {
        "label": "Y Adjustment (Px)",
        "id": "translateY"
       },
       {
        "label": "Font",
        "id": "font"
       },
       {
        "label": "Edit Lyrics",
        "id": "lyricEditor",
        "options": []
       }
      ],
      "staticText": {
       "doneEditing": "Done Editing Lyrics",
       "undo": "Undo Lyrics",
       "label": "Lyric Editor"
      }
     },
     {
      "ctor": "SuiChordChangeDialog",
      "label": "Edit Chord Symbol",
      "dialogElements": [
       {
        "label": "Ordinality",
        "id": "verse",
        "options": [
         {
          "value": 0,
          "label": "1"
         },
         {
          "value": 1,
          "label": "2"
         },
         {
          "value": 2,
          "label": "3"
         }
        ]
       },
       {
        "label": "Y Adjustment (Px)",
        "id": "translateY"
       },
       {
        "label": "Edit Text",
        "id": "chordEditor",
        "options": []
       },
       {
        "label": "Chord Symbol",
        "id": "chordSymbol",
        "options": [
         {
          "value": "csymDiminished",
          "label": "Dim"
         },
         {
          "value": "csymHalfDiminished",
          "label": "Half dim"
         },
         {
          "value": "csymDiagonalArrangementSlash",
          "label": "Slash"
         },
         {
          "value": "csymMajorSeventh",
          "label": "Maj7"
         }
        ]
       },
       {
        "label": "Text Position",
        "id": "textPosition",
        "options": [
         {
          "value": 1,
          "label": "Superscript"
         },
         {
          "value": 2,
          "label": "Subscript"
         },
         {
          "value": 0,
          "label": "Normal"
         }
        ]
       },
       {
        "label": "Font",
        "id": "font"
       },
       {
        "label": "Adjust Note Width",
        "id": "adjustWidth",
        "options": []
       }
      ],
      "staticText": {
       "label": "Edit Chord Symbol",
       "undo": "Undo Chord Symbols",
       "doneEditing": "Done Editing Chord Symbols"
      }
     },
     {
      "ctor": "SuiTextBlockDialog",
      "label": "Text Properties",
      "dialogElements": [
       {
        "label": "Edit Text",
        "id": "textEditor",
        "options": []
       },
       {
        "label": "Insert Special",
        "id": "insertCode",
        "options": [
         {
          "value": "@@@",
          "label": "Pages"
         },
         {
          "value": "###",
          "label": "Page Number"
         }
        ]
       },
       {
        "label": "Move Text",
        "id": "textDragger",
        "options": []
       },
       {
        "label": "X Position (Px)",
        "id": "x"
       },
       {
        "label": "Y Position (Px)",
        "id": "y"
       },
       {
        "label": "Font Information",
        "id": "font"
       },
       {
        "label": "Text Block Properties",
        "id": "textBlock"
       },
       {
        "label": "Page Behavior",
        "id": "pagination",
        "options": [
         {
          "value": 4,
          "label": "Once"
         },
         {
          "value": 1,
          "label": "Every"
         },
         {
          "label": "Even"
         },
         {
          "value": 3,
          "label": "Odd"
         },
         {
          "value": 5,
          "label": "Subsequent"
         }
        ]
       },
       {
        "label": "Attach to Selection",
        "id": "attachToSelector"
       }
      ],
      "staticText": {
       "label": "Text Properties",
       "editorLabel": "Done Editing Text",
       "draggerLabel": "Done Dragging Text"
      }
     }
    ],
    "menus": [
     {
      "ctor": "SuiDynamicsMenu",
      "label": "Dynamics",
      "menuItems": [
       {
        "icon": "pianissimo",
        "text": "Pianissimo",
        "value": "pp"
       },
       {
        "icon": "piano",
        "text": "Piano",
        "value": "p"
       },
       {
        "icon": "mezzopiano",
        "text": "Mezzo-piano",
        "value": "mp"
       },
       {
        "icon": "mezzoforte",
        "text": "Mezzo-forte",
        "value": "mf"
       },
       {
        "icon": "forte",
        "text": "Forte",
        "value": "f"
       },
       {
        "icon": "fortissimo",
        "text": "Fortissimo",
        "value": "ff"
       },
       {
        "icon": "sfz",
        "text": "sfortzando",
        "value": "sfz"
       },
       {
        "icon": "",
        "text": "Cancel",
        "value": "cancel"
       }
      ]
     },
     {
      "ctor": "SuiFileMenu",
      "label": "",
      "menuItems": [
       {
        "icon": "folder-new",
        "text": "e",
        "value": "newFile"
       },
       {
        "icon": "folder-open",
        "text": "",
        "value": "openFile"
       },
       {
        "icon": "",
        "text": "Quick Save",
        "value": "quickSave"
       },
       {
        "icon": "folder-save",
        "text": "",
        "value": "saveFile"
       },
       {
        "icon": "",
        "text": "",
        "value": "printScore"
       },
       {
        "icon": "",
        "text": "Import MusicXML",
        "value": "importMxml"
       },
       {
        "icon": "",
        "text": "Export MusicXML",
        "value": "exportXml"
       },
       {
        "icon": "",
        "text": "Export Midi",
        "value": "exportMidi"
       },
       {
        "icon": "folder-save",
        "text": "Save Actions",
        "value": "saveActions"
       },
       {
        "icon": "icon-play3",
        "text": "Play Actions",
        "value": "playActions"
       },
       {
        "icon": "",
        "text": "",
        "value": "cancel"
       }
      ]
     },
     {
      "ctor": "SuiKeySignatureMenu",
      "label": "",
      "menuItems": [
       {
        "icon": "key-sig-c",
        "text": "C Major",
        "value": "KeyOfC"
       },
       {
        "icon": "key-sig-f",
        "text": "F Major",
        "value": "KeyOfF"
       },
       {
        "icon": "key-sig-g",
        "text": "G Major",
        "value": "KeyOfG"
       },
       {
        "icon": "key-sig-bb",
        "text": "Bb Major",
        "value": "KeyOfBb"
       },
       {
        "icon": "key-sig-d",
        "text": "D Major",
        "value": "KeyOfD"
       },
       {
        "icon": "key-sig-eb",
        "text": "Eb Major",
        "value": "KeyOfEb"
       },
       {
        "icon": "key-sig-a",
        "text": "A Major",
        "value": "KeyOfA"
       },
       {
        "icon": "key-sig-ab",
        "text": "Ab Major",
        "value": "KeyOfAb"
       },
       {
        "icon": "key-sig-e",
        "text": "E Major",
        "value": "KeyOfE"
       },
       {
        "icon": "key-sig-bd",
        "text": "Db Major",
        "value": "KeyOfDb"
       },
       {
        "icon": "key-sig-b",
        "text": "B Major",
        "value": "KeyOfB"
       },
       {
        "icon": "key-sig-fs",
        "text": "F# Major",
        "value": "KeyOfF#"
       },
       {
        "icon": "key-sig-cs",
        "text": "C# Major",
        "value": "KeyOfC#"
       },
       {
        "icon": "",
        "text": "Cancel",
        "value": "cancel"
       }
      ]
     },
     {
      "ctor": "SuiMeasureMenu",
      "label": "Measure",
      "menuItems": [
       {
        "icon": "",
        "text": "Add Measures",
        "value": "addMenuCmd"
       },
       {
        "icon": "icon-cross",
        "text": "Delete Selected Measures",
        "value": "deleteSelected"
       },
       {
        "icon": "",
        "text": "Format Measure",
        "value": "formatMeasureDialog"
       },
       {
        "icon": "",
        "text": "Cancel",
        "value": "cancel"
       }
      ]
     },
     {
      "ctor": "SuiTimeSignatureMenu",
      "label": " ",
      "menuItems": [
       {
        "icon": "sixeight",
        "text": "6/8",
        "value": "6/8"
       },
       {
        "icon": "fourfour",
        "text": "4/4",
        "value": "4/4"
       },
       {
        "icon": "threefour",
        "text": "3/4",
        "value": "3/4"
       },
       {
        "icon": "twofour",
        "text": "2/4",
        "value": "2/4"
       },
       {
        "icon": "twelveeight",
        "text": "12/8",
        "value": "12/8"
       },
       {
        "icon": "seveneight",
        "text": "7/8",
        "value": "7/8"
       },
       {
        "icon": "fiveeight",
        "text": "5/8",
        "value": "5/8"
       },
       {
        "icon": "",
        "text": "Other",
        "value": "TimeSigOther"
       },
       {
        "icon": "",
        "text": "Cancel",
        "value": "cancel"
       }
      ]
     },
     {
      "ctor": "SuiStaffModifierMenu",
      "label": "",
      "menuItems": [
       {
        "icon": "cresc",
        "text": "",
        "value": "crescendo"
       },
       {
        "icon": "decresc",
        "text": "",
        "value": "decrescendo"
       },
       {
        "icon": "slur",
        "text": " / ",
        "value": "slur"
       },
       {
        "icon": "slur",
        "text": "Tie",
        "value": "tie"
       },
       {
        "icon": "ending",
        "text": " ",
        "value": "ending"
       },
       {
        "icon": "",
        "text": "Cancel",
        "value": "cancel"
       }
      ]
     },
     {
      "ctor": "SuiLanguageMenu",
      "label": "Language",
      "menuItems": [
       {
        "icon": "",
        "text": "English",
        "value": "en"
       },
       {
        "icon": "",
        "text": "Deutsch",
        "value": "de"
       },
       {
        "icon": "",
        "text": "",
        "value": "ar"
       },
       {
        "icon": "",
        "text": "Cancel",
        "value": "cancel"
       }
      ]
     },
     {
      "ctor": "SuiLibraryMenu",
      "label": "Score",
      "menuItems": [
       {
        "icon": "",
        "text": "Bach Invention",
        "value": "bach"
       },
       {
        "icon": "",
        "text": "Postillion-Lied",
        "value": "postillion"
       },
       {
        "icon": "",
        "text": "Jesu Bambino",
        "value": "bambino"
       },
       {
        "icon": "",
        "text": "Handel Messiah 1-1",
        "value": "handel"
       },
       {
        "icon": "",
        "text": "Precious Lord",
        "value": "preciousLord"
       },
       {
        "icon": "",
        "text": "In Its Delightful Shade",
        "value": "shade"
       },
       {
        "icon": "",
        "text": "Yama",
        "value": "yamaJson"
       },
       {
        "icon": "",
        "text": "Dichterliebe (xml)",
        "value": "dichterliebe"
       },
       {
        "icon": "",
        "text": "Beethoven - An die ferne Gliebte (xml)",
        "value": "beethoven"
       },
       {
        "icon": "",
        "text": "Mozart - An Chloe (xml)",
        "value": "mozart"
       },
       {
        "icon": "",
        "text": "Joplin - The Entertainer (xml)",
        "value": "joplin"
       },
       {
        "icon": "",
        "text": "Cancel",
        "value": "cancel"
       }
      ]
     },
     {
      "ctor": "SuiScoreMenu",
      "label": "Score Settings",
      "menuItems": [
       {
        "icon": "",
        "text": "Layout",
        "value": "layout"
       },
       {
        "icon": "",
        "text": "Fonts",
        "value": "fonts"
       },
       {
        "icon": "",
        "text": "View",
        "value": "view"
       },
       {
        "icon": "",
        "text": "Score Info",
        "value": "identification"
       },
       {
        "icon": "",
        "text": "Global Settings",
        "value": "preferences"
       },
       {
        "icon": "",
        "text": "Cancel",
        "value": "cancel"
       }
      ]
     }
    ],
    "buttonText": [
     {
      "buttonId": "helpDialog",
      "buttonText": "Help"
     },
     {
      "buttonId": "languageMenu",
      "buttonText": "Language"
     },
     {
      "buttonId": "fileMenu",
      "buttonText": ""
     },
     {
      "buttonId": "libraryMenu",
      "buttonText": "Library"
     },
     {
      "buttonId": "addStaffMenu",
      "buttonText": "Staves"
     },
     {
      "buttonId": "measureModal",
      "buttonText": "Measure"
     },
     {
      "buttonId": "tempoModal",
      "buttonText": "Tempo"
     },
     {
      "buttonId": "timeSignatureMenu",
      "buttonText": "Time Signature"
     },
     {
      "buttonId": "keyMenu",
      "buttonText": "Key"
     },
     {
      "buttonId": "staffModifierMenu",
      "buttonText": "Lines"
     },
     {
      "buttonId": "instrumentModal",
      "buttonText": "Instrument"
     },
     {
      "buttonId": "pianoModal",
      "buttonText": "Piano"
     },
     {
      "buttonId": "layoutMenu",
      "buttonText": "Score"
     },
     {
      "buttonId": "UpOctaveButton",
      "buttonText": "8va"
     },
     {
      "buttonId": "DownOctaveButton",
      "buttonText": "8vb"
     },
     {
      "buttonId": "moreNavButtons",
      "buttonText": "..."
     },
     {
      "buttonId": "dcAlCoda",
      "buttonText": "DC Al Coda"
     },
     {
      "buttonId": "dsAlCoda",
      "buttonText": "DS Al Coda"
     },
     {
      "buttonId": "dcAlFine",
      "buttonText": "DC Al Fine"
     },
     {
      "buttonId": "dsAlFine",
      "buttonText": "DS Al Fine"
     },
     {
      "buttonId": "toCoda",
      "buttonText": "to "
     },
     {
      "buttonId": "fine",
      "buttonText": "Fine"
     },
     {
      "buttonId": "moreStaffButtons",
      "buttonText": "..."
     }
    ]
   }`;
exports.quickStartHtmlar = `(Arabic)
    <h3 id="quick-start-guide">Quick start guide</h3>
<p>If you don&#39;t like to read instructions, this cook&#39;s tour of Smoosic was made for you.</p>
<ul>
<li><p>One of buttons on the left is called &#39;File&#39;.  Click on it. The menu items before &#39;cancel&#39; are pre-canned projects that you can use as a template to get you started.</p>
</li>
<li><p>The cursor keys will navigate you to the different notes.</p>
</li>
<li><p>Letters a-g on the computer keyboard change the note to those pitches</p>
</li>
<li><p>&#39;Insert&#39; adds a new, blank measure.</p>
</li>
<li><p>The ribbon of thick blue buttons on the top expand to button groups, that contain most of the functionality of Smoosic.  </p>
</li>
<li><p>The buttons on the left bring up menus or dialogs that do basically what the buttons say.</p>
</li>
<li><p>There are a few &#39;instant gratification&#39; buttons for playing the music, refreshing the screen or changing the zoom level on the left part of the ribbon.</p>
</li>
<li><p>The piano tool is an alternate way of entering music, or can be dismissed by the close button in the lower left.</p>
</li>
</ul>
<p><img src="https://imgur.com/nP16PMI.gif" alt="" width="640" height="480"></p>
`;
exports.selectionHtmlar = `(Arabic)
<h3 id="selecting-things">Selecting things</h3>
<p>Almost all operations in Smoosic act on the selected music.  You can select notes in different ways:</p>
<ol>
<li>with the computer mouse</li>
<li>with the keyboard&#39;s navigation keys</li>
<li>with the navigation keys on the ribbon</li>
<li>with the piano tool, to some extent.</li>
</ol>
<p><img src="https://imgur.com/q1qK3Pn.gif" alt=""></p>
<p>You can select multiple things with the keyboard navigation keys, by selecting &#39;shift-arrow&#39;, just like many applications.  There is a similar control for selection in the navigation ribbon.  Some operations, like changing pitch for instance, act on all the selected notes.</p>
<p>Sometimes a selection of one line affects all the measures in that column (or all the measures of the system, if you like).  When you change the key, for instance, the selection determines where the key change starts.  If you have multiple measures selected, it applies to those measures, and then changes back to whatever it was before.</p>
`;
exports.enterDurationsHtmlar = `(Arabic)
<p>Note duration in Smoosic is done by changing the duration of an existing note.  Usually, doubling the duration or cutting it in two, or adding a dot - duration to a note.  You can also create tuplets for uneven sets of notes (3, 5, or 7).</p>
<p>There are actually 3 ways to do many duration operations - using the piano tool, using the computer keyboard, or using the button ribbon.  Like with many things, you should find entering duration using the keyboard fastest, once you have some experience with Smoosic.  But the ribbon or the </p>
<h2 id="changing-note-length-with-the-keyboard">Changing note length with the keyboard</h2>
<p>You can change the length of notes using the &#39;,&#39; and &#39;.&#39; (comma and period) keys, which halve and double the note lengths, respectively.  You can add a dot to the length of the note (multiplying length by 3/2 for the first dot, and 3/4 for the second dot, if you like to think of it that way) or remove a dot, using the &#39;&gt;&#39; and &#39;&lt;&#39;.  The mnemonic device for these is &#39;&gt;&#39; makes note duration greater.  &#39;&lt;&#39; makes note duration...less.  (On most QWERTY keyboards, comma shifted is &#39;&lt;&#39; and period shifted is &#39;&gt;&#39;).</p>
<p><img src="https://imgur.com/5ZWq2Xe.gif" alt=""></p>
<p>Note how the selection is preserved as the notes get shorter.  When you change something, Smoosic will try to keep the selection as close as possible to what you had.  You can use the cursor navigation keys to move to a specific selected note.</p>
<p><img src="https://imgur.com/woMw4RH.gif" alt=""></p>
<p>When you increase the length of a note, Smoosic always &#39;borrows&#39; from the next note in the measure that is eligible.  So when you double the length of the 8th note, it combines the 16th, and 2 32nd notes, and collapses them into a single quarter.  If Smoosic can&#39;t honor the request, it does nothing.  For instance, it can&#39;t remove the dot from a note with no dot, and it can&#39;t extend beyond the length of the measure.</p>
<p>You can create tuplets from the keyboard by typing Ctrl-3, Ctrl-5 or Ctrl-7 for triplets, quintuplets, and septuplets, respectively.  Individual notes in a tuplet can be doubled and halved with the duration keys &#39;-&#39; (minus) and &#39;=&#39; (equals), just like non-tuplets.  You &#39;untupletify&#39; a tuplet by Ctrl-0.</p>
<p><img src="https://imgur.com/uBpQwXD.gif" alt=""></p>
<h2 id="changing-note-length-with-piano-widget">Changing note length with piano widget</h2>
<p>The piano widget is shown when the application starts, and can be restored from the left menu &#39;Piano&#39; button when closed.</p>
<p>You can double or halve note duration, or add dot duration, to a note using the piano tool. </p>
<p><img src="https://imgur.com/Rw4yDxP.gif" alt=""></p>
<h2 id="changing-note-length-from-the-button-ribbon">Changing note length from the button ribbon</h2>
<p>All the duration commands can be accomplished from the ribbon buttons.  </p>
<p><img src="https://imgur.com/n9bmamg.gif" alt=""></p>
<p>Note that the equivalent keyboard commands are also indicated on the right of each button, when it&#39;s available.  (there are only so many keys, so there are some ribbon buttons with no key shortcut). </p>
`;
exports.enterPitchesHtmlar = `(Arabic)
<p>There are a few ways to enter notes in Smoosic.  You can click on the piano widget keys, or you can enter notes directly from the keyboard.</p>
<h2 id="your-first-smoosical-notes">Your first Smoosical notes</h2>
<h3 id="notes-from-the-keyboard">Notes from the keyboard</h3>
<p>The keys a-g on the computer keyboard will enter a corresponding note, A-G, on the staff (Most key commands in Smoosic have a mnemonic device).  The default behavior is for the cursor to advance when a note is entered in this way.  (Future behavior, auto-advance can be overridden). You navigate to the notes using the keyboard navigation arrows.</p>
<p><img src="https://imgur.com/lxR0NI7.gif" alt=""></p>
<p>You change the octave from the keyboard using the &#39;_&#39; and &#39;+&#39; (underscore, aka shift-minus, and plus), and change notes chromatically using &#39;-&#39; and &#39;=&#39; key.  The mnemonic device for this is &#39;plus and minus&#39; for raising and lowering pitches.  You can change the enharmonic spelling of the note using the &#39;Shift-E&#39; (mnemonic: E for enharmonic - get it?).  And Shift-F gives you a courtesy, or cautionary, accidental (mnemonic - F comes after E).</p>
<p><img src="https://imgur.com/1tC94sV.gif" alt=""></p>
<p>You can create chords and intervals using the number keys along the top of the keyboard.  The &#39;3&#39; key makes a third, the &#39;4&#39; key a fourth, and so on.  Shift+number gives you the interval down.</p>
<p><img src="https://imgur.com/IwoeWi3.gif" alt=""></p>
<p>Note that the interval starts from the highest note in the chord, for intervals going up, and the lowest note in the chord, for intervals going down.  You can select individual pitches in the chord using &#39;Shift-Up Arrow&#39; as shown.  This is similar to how modifiers like dynamics are selected.  Once you have the pitch selected, you can change it using the up-down commands shows above, or change the enharmonic spelling.</p>
<p>There is currently no way to remove a single pitch from the chord.  If you want to collapse the chord, just type a letter a-g on the keyboard, and it will be replaced with a single note.</p>
<h3 id="notes-from-the-piano-tool">Notes from the piano tool</h3>
<p>You can also add notes to your score with the piano tool, by clicking on the corresponding notes.</p>
<p><img src="https://imgur.com/MOMlIg3.gif" alt=""></p>
<p>Clicking on the piano gives the selected note the piano pitch.  The octave of the note is based on the clef, so for treble clef, the &#39;C&#39; is middle &#39;C&#39;.  You can change the octave of the note, and move the pitch up and down.  The top buttons affect the pitch, and the bottom buttons navigate or change the length of the note.  Clicking on the chord button acts like a &#39;sustain&#39; that puts additional notes in chords.</p>
<p>Everything that can be done from the piano widget, and most things in Smoosic generally, can be done more efficiently with keyboard commands. Once you are comfortable with the computer keyboard, you can free up some screen real-estate by closing the piano widget (cross control in lower left).  You can bring it up again with the piano menu button on the left.</p>
`;


/***/ }),

/***/ "./src/ui/i18n/language_de.js":
/*!************************************!*\
  !*** ./src/ui/i18n/language_de.js ***!
  \************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.smoLanguageStringDe = void 0;
exports.smoLanguageStringDe = `{
    "dialogs": [
        {
            "ctor": "SuiLoadFileDialog",
            "label": "Datei laden",
            "dialogElements": [
                {}
            ],
            "staticText": {}
        },
        {
            "ctor": "SuiSaveFileDialog",
            "label": "Score speichern",
            "dialogElements": [
                {
                    "label": "File Name",
                    "id": "saveFileName"
                }
            ],
            "staticText": {}
        },
        {
            "ctor": "SuiSaveXmlDialog",
            "label": "Score speichern",
            "dialogElements": [
                {
                    "label": "File Name",
                    "id": "saveFileName"
                }
            ],
            "staticText": {}
        },
        {
            "ctor": "SuiPrintFileDialog",
            "label": "Print Complete",
            "dialogElements": [],
            "staticText": {}
        },
        {
            "ctor": "SuiSaveMidiDialog",
            "label": "Save Score as Midi",
            "dialogElements": [
                {
                    "label": "File Name",
                    "id": "saveFileName"
                }
            ],
            "staticText": {}
        },
        {
            "ctor": "SuiSaveActionsDialog",
            "label": "Save Score",
            "dialogElements": [
                {
                    "label": "File Name",
                    "id": "saveFileName"
                }
            ],
            "staticText": {}
        },
        {
            "ctor": "SuiLoadMxmlDialog",
            "label": "Load File",
            "dialogElements": [
                {},
                {
                    "staticText": {
                        "label": "Load File"
                    }
                }
            ],
            "staticText": {}
        },
        {
            "ctor": "SuiLoadActionsDialog",
            "label": "Load Action File",
            "dialogElements": [
                {},
                {
                    "staticText": {
                        "label": "Load Action File"
                    }
                }
            ],
            "staticText": {}
        },
        {
            "ctor": "SuiMeasureDialog",
            "label": "Takt Voreinstellungen",
            "dialogElements": [
                {
                    "label": "Takt Pickup",
                    "id": "pickup"
                },
                {
                    "label": "Pad Left (px)",
                    "id": "padLeft"
                },
                {
                    "label": "Stretch Contents",
                    "id": "customStretch"
                },
                {
                    "label": "Proportionalality",
                    "id": "customProportion"
                },
                {
                    "label": "Pad all measures in system",
                    "id": "padAllInSystem"
                },
                {
                    "label": "Justify Columns",
                    "id": "autoJustify"
                },
                {
                    "label": "Text Position",
                    "id": "measureTextPosition",
                    "options": [
                        {
                            "value": 2,
                            "label": "Left"
                        },
                        {
                            "value": 3,
                            "label": "Right"
                        },
                        {
                            "value": 0,
                            "label": "Above"
                        },
                        {
                            "value": 1,
                            "label": "Below"
                        }
                    ]
                },
                {
                    "label": "System break before this measure",
                    "id": "systemBreak"
                }
            ],
            "staticText": {}
        },
        {
            "ctor": "SuiTempoDialog",
            "label": "Tempo Voreinstellungen",
            "dialogElements": [
                {
                    "label": "Tempo Modus",
                    "id": "tempoMode",
                    "options": [
                        {
                            "value": "duration",
                            "label": "Dauer (Beats/Minute)"
                        },
                        {
                            "value": "text",
                            "label": "Tempo Text"
                        },
                        {
                            "value": "custom",
                            "label": "Text und Dauer festlegen"
                        }
                    ]
                },
                {
                    "label": "Custom Text",
                    "id": "customText"
                },
                {
                    "label": "Notes/Minute",
                    "id": "bpm"
                },
                {
                    "label": "Einheit fr Beat",
                    "id": "beatDuration",
                    "options": [
                        {
                            "value": 4096,
                            "label": "Quarter Note"
                        },
                        {
                            "value": 2048,
                            "label": "1/8 note"
                        },
                        {
                            "value": 6144,
                            "label": "Dotted 1/4 note"
                        },
                        {
                            "value": 8192,
                            "label": "1/2 note"
                        }
                    ]
                },
                {
                    "label": "Tempo Text",
                    "id": "tempoText",
                    "options": [
                        {
                            "value": "Larghissimo",
                            "label": "Larghissimo"
                        },
                        {
                            "value": "Grave",
                            "label": "Grave"
                        },
                        {
                            "value": "Lento",
                            "label": "Lento"
                        },
                        {
                            "value": "Largo",
                            "label": "Largo"
                        },
                        {
                            "value": "Larghetto",
                            "label": "Larghetto"
                        },
                        {
                            "value": "Adagio",
                            "label": "Adagio"
                        },
                        {
                            "value": "Adagietto",
                            "label": "Adagietto"
                        },
                        {
                            "value": "Andante moderato",
                            "label": "Andante moderato"
                        },
                        {
                            "value": "Andante",
                            "label": "Andante"
                        },
                        {
                            "value": "Andantino",
                            "label": "Andantino"
                        },
                        {
                            "value": "Moderato",
                            "label": "Moderato"
                        },
                        {
                            "value": "Allegretto",
                            "label": "Allegretto"
                        },
                        {
                            "value": "Allegro",
                            "label": "Allegro"
                        },
                        {
                            "value": "Vivace",
                            "label": "Vivace"
                        },
                        {
                            "value": "Presto",
                            "label": "Presto"
                        },
                        {
                            "value": "Prestissimo",
                            "label": "Prestissimo"
                        }
                    ]
                },
                {
                    "label": "Apply to all future measures?",
                    "id": "applyToAll"
                },
                {
                    "label": "Display Tempo",
                    "id": "display"
                },
                {
                    "label": "Y Offset",
                    "id": "yOffset"
                }
            ],
            "staticText": {}
        },
        {
            "ctor": "SuiInstrumentDialog",
            "label": "Instrument Properties",
            "dialogElements": [
                {
                    "label": "Transpose Index (1/2 steps)",
                    "id": "transposeIndex"
                },
                {
                    "label": "Apply To",
                    "id": "applyTo",
                    "options": [
                        {
                            "value": 0,
                            "label": "Score"
                        },
                        {
                            "value": 1,
                            "label": "Selected Measures"
                        },
                        {
                            "value": 3,
                            "label": "Remaining Measures"
                        }
                    ]
                }
            ],
            "staticText": {}
        },
        {
            "ctor": "SuiInsertMeasures",
            "label": "Insert Measures",
            "dialogElements": [
                {
                    "label": "Measures to Insert",
                    "id": "measureCount"
                },
                {
                    "label": "Append to Selection",
                    "id": "append"
                }
            ],
            "staticText": {}
        },
        {
            "ctor": "SuiTimeSignatureDialog",
            "label": "Custom Time Signature",
            "dialogElements": [
                {
                    "label": "Beats/Measure",
                    "id": "numerator"
                },
                {
                    "label": "Beat Value",
                    "id": "denominator",
                    "options": [
                        {
                            "value": 8,
                            "label": "8"
                        },
                        {
                            "value": 4,
                            "label": "4"
                        },
                        {
                            "value": 2,
                            "label": "2"
                        }
                    ]
                },
                {
                    "label": "Display",
                    "id": "display"
                }
            ],
            "staticText": {}
        },
        {
            "ctor": "SuiScoreViewDialog",
            "label": "Score View",
            "dialogElements": [
                {
                    "label": "Show staff",
                    "id": "scoreView"
                }
            ],
            "staticText": {}
        },
        {
            "ctor": "SuiScoreIdentificationDialog",
            "label": "Score Preferences",
            "dialogElements": [
                {
                    "label": "Title",
                    "id": "title"
                },
                {
                    "label": "Sub Title",
                    "id": "subTitle"
                },
                {
                    "label": "Composer",
                    "id": "composer"
                },
                {
                    "label": "Copyright",
                    "id": "copyright"
                }
            ],
            "staticText": {
                "titleText": "Title",
                "subTitleText": "Sub-title",
                "copyrightText": "Copyright",
                "composerText": "Composer",
                "show": "Show"
            }
        },
        {
            "ctor": "SuiGlobalLayoutDialog",
            "label": "Global Settings",
            "dialogElements": [
                {
                    "label": "Score Name",
                    "id": "scoreName"
                },
                {
                    "label": "Play Selections",
                    "id": "autoPlay"
                },
                {
                    "label": "Auto-Advance Cursor",
                    "id": "autoAdvance"
                },
                {
                    "label": "Note Spacing",
                    "id": "noteSpacing"
                },
                {
                    "label": "Seitengre",
                    "id": "pageSize",
                    "options": [
                        {
                            "value": "letter",
                            "label": "Brief"
                        },
                        {
                            "value": "letterLandscape",
                            "label": "Brief (Landscape)"
                        },
                        {
                            "value": "tabloid",
                            "label": "Tabloid (11x17)"
                        },
                        {
                            "value": "A4",
                            "label": "A4"
                        },
                        {
                            "value": "custom",
                            "label": "benutzerdefiniert"
                        }
                    ]
                },
                {
                    "label": "Page Width (px)",
                    "id": "pageWidth"
                },
                {
                    "label": "Page Height (px)",
                    "id": "pageHeight"
                },
                {
                    "label": "% Zoom",
                    "id": "zoomScale"
                },
                {
                    "label": "% Note size",
                    "id": "svgScale"
                }
            ],
            "staticText": {}
        },
        {
            "ctor": "SuiScoreFontDialog",
            "label": "Schriftart",
            "dialogElements": [
                {
                    "label": "Schriftart",
                    "id": "engravingFont",
                    "options": [
                        {
                            "value": "Bravura",
                            "label": "Bravura"
                        },
                        {
                            "value": "Gonville",
                            "label": "Gonville"
                        },
                        {
                            "value": "Petaluma",
                            "label": "Petaluma"
                        },
                        {
                            "value": "Leland",
                            "label": "Leland"
                        }
                    ]
                },
                {
                    "label": "Chord Font",
                    "id": "chordFont"
                },
                {
                    "label": "Lyric Font",
                    "id": "lyricFont"
                }
            ],
            "staticText": {}
        },
        {
            "ctor": "SuiLayoutDialog",
            "label": "Page Layouts",
            "dialogElements": [
                {
                    "label": "Apply to Page",
                    "id": "applyToPage",
                    "options": [
                        {
                            "value": -1,
                            "label": "All"
                        },
                        {
                            "value": -2,
                            "label": "All Remaining"
                        },
                        {
                            "value": 1,
                            "label": "Page 1"
                        }
                    ]
                },
                {
                    "label": "Left Margin (px)",
                    "id": "leftMargin"
                },
                {
                    "label": "Right Margin (px)",
                    "id": "rightMargin"
                },
                {
                    "label": "Top Margin (px)",
                    "id": "topMargin"
                },
                {
                    "label": "Bottom Margin (px)",
                    "id": "bottomMargin"
                },
                {
                    "label": "Inter-System Margin",
                    "id": "interGap"
                },
                {
                    "label": "Intra-System Margin",
                    "id": "intraGap"
                },
                {
                    "staticText": {
                        "label": "Page Layouts"
                    }
                }
            ],
            "staticText": {}
        },
        {
            "ctor": "SuiSlurAttributesDialog",
            "label": "Slur Properties",
            "dialogElements": [
                {
                    "label": "Spacing",
                    "id": "spacing"
                },
                {
                    "label": "Thickness",
                    "id": "thickness"
                },
                {
                    "label": "X Offset",
                    "id": "xOffset"
                },
                {
                    "label": "Y Offset",
                    "id": "yOffset"
                },
                {
                    "label": "Startposition",
                    "id": "position",
                    "options": [
                        {
                            "value": 1,
                            "label": "Head"
                        },
                        {
                            "value": 2,
                            "label": "Top"
                        }
                    ]
                },
                {
                    "label": "Endposition",
                    "id": "position_end",
                    "options": [
                        {
                            "value": 1,
                            "label": "Head"
                        },
                        {
                            "value": 2,
                            "label": "Top"
                        }
                    ]
                },
                {
                    "label": "Invert",
                    "id": "invert"
                },
                {
                    "label": "Control Point 1 X",
                    "id": "cp1x"
                },
                {
                    "label": "Control Point 1 Y",
                    "id": "cp1y"
                },
                {
                    "label": "Control Point 2 X",
                    "id": "cp2x"
                },
                {
                    "label": "Control Point 2 Y",
                    "id": "cp2y"
                }
            ],
            "staticText": {}
        },
        {
            "ctor": "SuiTieAttributesDialog",
            "label": "Tie Properties",
            "dialogElements": [
                {
                    "label": "Lines",
                    "id": "lines"
                }
            ],
            "staticText": {
                "label": "Tie Properties",
                "fromNote": "From Note",
                "toNote": "To Note"
            }
        },
        {
            "ctor": "SuiVoltaAttributeDialog",
            "label": "Volta Properties",
            "dialogElements": [
                {
                    "label": "number",
                    "id": "number"
                },
                {
                    "label": "X1 Offset",
                    "id": "xOffsetStart"
                },
                {
                    "label": "X2 Offset",
                    "id": "xOffsetEnd"
                },
                {
                    "label": "Y Offset",
                    "id": "yOffset"
                }
            ],
            "staticText": {}
        },
        {
            "ctor": "SuiHairpinAttributesDialog",
            "label": "Hairpin Properties",
            "dialogElements": [
                {
                    "label": "Height",
                    "id": "height"
                },
                {
                    "label": "Y Shift",
                    "id": "yOffset"
                },
                {
                    "label": "Right Shift",
                    "id": "xOffsetRight"
                },
                {
                    "label": "Left Shift",
                    "id": "xOffsetLeft"
                }
            ],
            "staticText": {}
        },
        {
            "ctor": "SuiStaffGroupDialog",
            "label": "Staff Group",
            "dialogElements": [
                {
                    "label": "Staves in Group",
                    "id": "staffGroups"
                },
                {
                    "label": "Left Connector",
                    "id": "leftConnector",
                    "options": [
                        {
                            "value": 1,
                            "label": "Bracket"
                        },
                        {
                            "value": 0,
                            "label": "Brace"
                        },
                        {
                            "value": 2,
                            "label": "Single"
                        },
                        {
                            "value": 3,
                            "label": "Double"
                        }
                    ]
                }
            ],
            "staticText": {
                "includeStaff": "Include Staff"
            }
        },
        {
            "ctor": "SuiDynamicModifierDialog",
            "label": "Dynamics Properties",
            "dialogElements": [
                {
                    "label": "Y Line",
                    "id": "yOffsetLine"
                },
                {
                    "label": "Y Offset Px",
                    "id": "yOffsetPixels"
                },
                {
                    "label": "X Offset",
                    "id": "xOffset"
                },
                {
                    "label": "Text",
                    "id": "text",
                    "options": [
                        {
                            "value": "p",
                            "label": "Piano"
                        },
                        {
                            "value": "pp",
                            "label": "Pianissimo"
                        },
                        {
                            "value": "mp",
                            "label": "Mezzo-Piano"
                        },
                        {
                            "value": "mf",
                            "label": "Mezzo-Forte"
                        },
                        {
                            "value": "f",
                            "label": "Forte"
                        },
                        {
                            "value": "ff",
                            "label": "Fortissimo"
                        },
                        {
                            "value": "sfz",
                            "label": "Sforzando"
                        }
                    ]
                }
            ],
            "staticText": {}
        },
        {
            "ctor": "SuiLyricDialog",
            "label": "Lyric Editor",
            "dialogElements": [
                {
                    "label": "Verse",
                    "id": "verse",
                    "options": [
                        {
                            "value": 0,
                            "label": "1"
                        },
                        {
                            "value": 1,
                            "label": "2"
                        },
                        {
                            "value": 2,
                            "label": "3"
                        },
                        {
                            "value": 3,
                            "label": "4"
                        }
                    ]
                },
                {
                    "label": "Y Adjustment (Px)",
                    "id": "translateY"
                },
                {
                    "label": "Font",
                    "id": "font"
                },
                {
                    "label": "Edit Lyrics",
                    "id": "lyricEditor",
                    "options": []
                }
            ],
            "staticText": {
                "doneEditing": "Done Editing Lyrics",
                "undo": "Undo Lyrics",
                "label": "Lyric Editor"
            }
        },
        {
            "ctor": "SuiChordChangeDialog",
            "label": "Edit Chord Symbol",
            "dialogElements": [
                {
                    "label": "Ordinality",
                    "id": "verse",
                    "options": [
                        {
                            "value": 0,
                            "label": "1"
                        },
                        {
                            "value": 1,
                            "label": "2"
                        },
                        {
                            "value": 2,
                            "label": "3"
                        }
                    ]
                },
                {
                    "label": "Y Adjustment (Px)",
                    "id": "translateY"
                },
                {
                    "label": "Edit Text",
                    "id": "chordEditor",
                    "options": []
                },
                {
                    "label": "Chord Symbol",
                    "id": "chordSymbol",
                    "options": [
                        {
                            "value": "csymDiminished",
                            "label": "Dim"
                        },
                        {
                            "value": "csymHalfDiminished",
                            "label": "Half dim"
                        },
                        {
                            "value": "csymDiagonalArrangementSlash",
                            "label": "Slash"
                        },
                        {
                            "value": "csymMajorSeventh",
                            "label": "Maj7"
                        }
                    ]
                },
                {
                    "label": "Text Position",
                    "id": "textPosition",
                    "options": [
                        {
                            "value": 1,
                            "label": "Superscript"
                        },
                        {
                            "value": 2,
                            "label": "Subscript"
                        },
                        {
                            "value": 0,
                            "label": "Normal"
                        }
                    ]
                },
                {
                    "label": "Font",
                    "id": "font"
                },
                {
                    "label": "Adjust Note Width",
                    "id": "adjustWidth",
                    "options": []
                }
            ],
            "staticText": {
                "label": "Edit Chord Symbol",
                "undo": "Undo Chord Symbols",
                "doneEditing": "Done Editing Chord Symbols"
            }
        },
        {
            "ctor": "SuiTextBlockDialog",
            "label": "Text Properties",
            "dialogElements": [
                {
                    "label": "Edit Text",
                    "id": "textEditor",
                    "options": []
                },
                {
                    "label": "Insert Special",
                    "id": "insertCode",
                    "options": [
                        {
                            "value": "@@@",
                            "label": "Pages"
                        },
                        {
                            "value": "###",
                            "label": "Page Number"
                        }
                    ]
                },
                {
                    "label": "Move Text",
                    "id": "textDragger",
                    "options": []
                },
                {
                    "label": "X Position (Px)",
                    "id": "x"
                },
                {
                    "label": "Y Position (Px)",
                    "id": "y"
                },
                {
                    "label": "Font Information",
                    "id": "font"
                },
                {
                    "label": "Text Block Properties",
                    "id": "textBlock"
                },
                {
                    "label": "Page Behavior",
                    "id": "pagination",
                    "options": [
                        {
                            "value": 4,
                            "label": "Once"
                        },
                        {
                            "value": 1,
                            "label": "Every"
                        },
                        {
                            "label": "Even"
                        },
                        {
                            "value": 3,
                            "label": "Odd"
                        },
                        {
                            "value": 5,
                            "label": "Subsequent"
                        }
                    ]
                },
                {
                    "label": "Attach to Selection",
                    "id": "attachToSelector"
                }
            ],
            "staticText": {
                "label": "Text Properties",
                "editorLabel": "Done Editing Text",
                "draggerLabel": "Done Dragging Text"
            }
        }
    ],
    "menus": [
        {
            "ctor": "SuiDynamicsMenu",
            "label": "Dynamics",
            "menuItems": [
                {
                    "icon": "pianissimo",
                    "text": "Pianissimo",
                    "value": "pp"
                },
                {
                    "icon": "piano",
                    "text": "Piano",
                    "value": "p"
                },
                {
                    "icon": "mezzopiano",
                    "text": "Mezzo-piano",
                    "value": "mp"
                },
                {
                    "icon": "mezzoforte",
                    "text": "Mezzo-forte",
                    "value": "mf"
                },
                {
                    "icon": "forte",
                    "text": "Forte",
                    "value": "f"
                },
                {
                    "icon": "fortissimo",
                    "text": "Fortissimo",
                    "value": "ff"
                },
                {
                    "icon": "sfz",
                    "text": "sfortzando",
                    "value": "sfz"
                },
                {
                    "icon": "",
                    "text": "Abbrechen",
                    "value": "cancel"
                }
            ]
        },
        {
            "ctor": "SuiFileMenu",
            "label": "Datei",
            "menuItems": [
                {
                    "icon": "folder-new",
                    "text": "Neu",
                    "value": "newFile"
                },
                {
                    "icon": "folder-open",
                    "text": "ffnen",
                    "value": "openFile"
                },
                {
                    "icon": "",
                    "text": "Schnellspeichern",
                    "value": "quickSave"
                },
                {
                    "icon": "folder-save",
                    "text": "Speichern",
                    "value": "saveFile"
                },
                {
                    "icon": "",
                    "text": "Drucken",
                    "value": "printScore"
                },
                {
                    "icon": "",
                    "text": "Import MusicXML",
                    "value": "importMxml"
                },
                {
                    "icon": "",
                    "text": "Export MusicXML",
                    "value": "exportXml"
                },
                {
                    "icon": "",
                    "text": "Export Midi",
                    "value": "exportMidi"
                },
                {
                    "icon": "folder-save",
                    "text": "Save Actions",
                    "value": "saveActions"
                },
                {
                    "icon": "icon-play3",
                    "text": "Play Actions",
                    "value": "playActions"
                },
                {
                    "icon": "",
                    "text": "Abbrechen",
                    "value": "cancel"
                }
            ]
        },
        {
            "ctor": "SuiKeySignatureMenu",
            "label": "Tonlage",
            "menuItems": [
                {
                    "icon": "key-sig-c",
                    "text": "C Major",
                    "value": "KeyOfC"
                },
                {
                    "icon": "key-sig-f",
                    "text": "F Major",
                    "value": "KeyOfF"
                },
                {
                    "icon": "key-sig-g",
                    "text": "G Major",
                    "value": "KeyOfG"
                },
                {
                    "icon": "key-sig-bb",
                    "text": "Bb Major",
                    "value": "KeyOfBb"
                },
                {
                    "icon": "key-sig-d",
                    "text": "D Major",
                    "value": "KeyOfD"
                },
                {
                    "icon": "key-sig-eb",
                    "text": "Eb Major",
                    "value": "KeyOfEb"
                },
                {
                    "icon": "key-sig-a",
                    "text": "A Major",
                    "value": "KeyOfA"
                },
                {
                    "icon": "key-sig-ab",
                    "text": "Ab Major",
                    "value": "KeyOfAb"
                },
                {
                    "icon": "key-sig-e",
                    "text": "E Major",
                    "value": "KeyOfE"
                },
                {
                    "icon": "key-sig-bd",
                    "text": "Db Major",
                    "value": "KeyOfDb"
                },
                {
                    "icon": "key-sig-b",
                    "text": "B Major",
                    "value": "KeyOfB"
                },
                {
                    "icon": "key-sig-fs",
                    "text": "F# Major",
                    "value": "KeyOfF#"
                },
                {
                    "icon": "key-sig-cs",
                    "text": "C# Major",
                    "value": "KeyOfC#"
                },
                {
                    "icon": "",
                    "text": "Abbrechen",
                    "value": "cancel"
                }
            ]
        },
        {
            "ctor": "SuiMeasureMenu",
            "label": "Measure",
            "menuItems": [
                {
                    "icon": "",
                    "text": "Add Measures",
                    "value": "addMenuCmd"
                },
                {
                    "icon": "icon-cross",
                    "text": "Delete Selected Measures",
                    "value": "deleteSelected"
                },
                {
                    "icon": "",
                    "text": "Format Measure",
                    "value": "formatMeasureDialog"
                },
                {
                    "icon": "",
                    "text": "Cancel",
                    "value": "cancel"
                }
            ]
        },
        {
            "ctor": "SuiTimeSignatureMenu",
            "label": "Taktzeit",
            "menuItems": [
                {
                    "icon": "sixeight",
                    "text": "6/8",
                    "value": "6/8"
                },
                {
                    "icon": "fourfour",
                    "text": "4/4",
                    "value": "4/4"
                },
                {
                    "icon": "threefour",
                    "text": "3/4",
                    "value": "3/4"
                },
                {
                    "icon": "twofour",
                    "text": "2/4",
                    "value": "2/4"
                },
                {
                    "icon": "twelveeight",
                    "text": "12/8",
                    "value": "12/8"
                },
                {
                    "icon": "seveneight",
                    "text": "7/8",
                    "value": "7/8"
                },
                {
                    "icon": "fiveeight",
                    "text": "5/8",
                    "value": "5/8"
                },
                {
                    "icon": "",
                    "text": "benutzerdefiniert",
                    "value": "TimeSigOther"
                },
                {
                    "icon": "",
                    "text": "Abbrechen",
                    "value": "cancel"
                }
            ]
        },
        {
            "ctor": "SuiStaffModifierMenu",
            "label": "Lines",
            "menuItems": [
                {
                    "icon": "cresc",
                    "text": "Crescendo",
                    "value": "crescendo"
                },
                {
                    "icon": "decresc",
                    "text": "Decrescendo",
                    "value": "decrescendo"
                },
                {
                    "icon": "slur",
                    "text": "Bogen/Bindung",
                    "value": "slur"
                },
                {
                    "icon": "slur",
                    "text": "Tie",
                    "value": "tie"
                },
                {
                    "icon": "ending",
                    "text": "nth Ende",
                    "value": "ending"
                },
                {
                    "icon": "",
                    "text": "Abbrechen",
                    "value": "cancel"
                }
            ]
        },
        {
            "ctor": "SuiLanguageMenu",
            "label": "Language",
            "menuItems": [
                {
                    "icon": "",
                    "text": "English",
                    "value": "en"
                },
                {
                    "icon": "",
                    "text": "Deutsch",
                    "value": "de"
                },
                {
                    "icon": "",
                    "text": "",
                    "value": "ar"
                },
                {
                    "icon": "",
                    "text": "Cancel",
                    "value": "cancel"
                }
            ]
        },
        {
            "ctor": "SuiLibraryMenu",
            "label": "Score",
            "menuItems": [
                {
                    "icon": "",
                    "text": "Bach Invention",
                    "value": "bach"
                },
                {
                    "icon": "",
                    "text": "Postillion-Lied",
                    "value": "postillion"
                },
                {
                    "icon": "",
                    "text": "Jesu Bambino",
                    "value": "bambino"
                },
                {
                    "icon": "",
                    "text": "Handel Messiah 1-1",
                    "value": "handel"
                },
                {
                    "icon": "",
                    "text": "Precious Lord",
                    "value": "preciousLord"
                },
                {
                    "icon": "",
                    "text": "In Its Delightful Shade",
                    "value": "shade"
                },
                {
                    "icon": "",
                    "text": "Yama",
                    "value": "yamaJson"
                },
                {
                    "icon": "",
                    "text": "Dichterliebe (xml)",
                    "value": "dichterliebe"
                },
                {
                    "icon": "",
                    "text": "Beethoven - An die ferne Gliebte (xml)",
                    "value": "beethoven"
                },
                {
                    "icon": "",
                    "text": "Mozart - An Chloe (xml)",
                    "value": "mozart"
                },
                {
                    "icon": "",
                    "text": "Joplin - The Entertainer (xml)",
                    "value": "joplin"
                },
                {
                    "icon": "",
                    "text": "Cancel",
                    "value": "cancel"
                }
            ]
        },
        {
            "ctor": "SuiScoreMenu",
            "label": "Score Settings",
            "menuItems": [
                {
                    "icon": "",
                    "text": "Layout",
                    "value": "layout"
                },
                {
                    "icon": "",
                    "text": "Fonts",
                    "value": "fonts"
                },
                {
                    "icon": "",
                    "text": "View",
                    "value": "view"
                },
                {
                    "icon": "",
                    "text": "Score Info",
                    "value": "identification"
                },
                {
                    "icon": "",
                    "text": "Global Settings",
                    "value": "preferences"
                },
                {
                    "icon": "",
                    "text": "Cancel",
                    "value": "cancel"
                }
            ]
        }
    ],
    "buttonText": [
        {
            "buttonId": "helpDialog",
            "buttonText": "Help"
        },
        {
            "buttonId": "languageMenu",
            "buttonText": "Language"
        },
        {
            "buttonId": "fileMenu",
            "buttonText": "File"
        },
        {
            "buttonId": "libraryMenu",
            "buttonText": "Library"
        },
        {
            "buttonId": "addStaffMenu",
            "buttonText": "Staves"
        },
        {
            "buttonId": "measureModal",
            "buttonText": "Measure"
        },
        {
            "buttonId": "tempoModal",
            "buttonText": "Tempo"
        },
        {
            "buttonId": "timeSignatureMenu",
            "buttonText": "Time Signature"
        },
        {
            "buttonId": "keyMenu",
            "buttonText": "Key"
        },
        {
            "buttonId": "staffModifierMenu",
            "buttonText": "Lines"
        },
        {
            "buttonId": "instrumentModal",
            "buttonText": "Instrument"
        },
        {
            "buttonId": "pianoModal",
            "buttonText": "Piano"
        },
        {
            "buttonId": "layoutMenu",
            "buttonText": "Score"
        },
        {
            "buttonId": "UpOctaveButton",
            "buttonText": "8va"
        },
        {
            "buttonId": "DownOctaveButton",
            "buttonText": "8vb"
        },
        {
            "buttonId": "moreNavButtons",
            "buttonText": "..."
        },
        {
            "buttonId": "dcAlCoda",
            "buttonText": "DC Al Coda"
        },
        {
            "buttonId": "dsAlCoda",
            "buttonText": "DS Al Coda"
        },
        {
            "buttonId": "dcAlFine",
            "buttonText": "DC Al Fine"
        },
        {
            "buttonId": "dsAlFine",
            "buttonText": "DS Al Fine"
        },
        {
            "buttonId": "toCoda",
            "buttonText": "to "
        },
        {
            "buttonId": "fine",
            "buttonText": "Fine"
        },
        {
            "buttonId": "moreStaffButtons",
            "buttonText": "..."
        }
    ]
}`;


/***/ }),

/***/ "./src/ui/i18n/language_en.js":
/*!************************************!*\
  !*** ./src/ui/i18n/language_en.js ***!
  \************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.helpCards = exports.cardPartAddDeleteHtmlEn = exports.cardVoicesCreateDeleteHtmlEn = exports.cardMeasuresAddDeleteHtmlEn = exports.cardBeamsAndStemsGroupingHtmlEn = exports.cardBeamsAndStemsDirectionHtmlEn = exports.cardSelectionsSlashHtmlEn = exports.cardSelectionsNonSelectableHtmlEn = exports.cardSelectionsModifiersHtmlEn = exports.cardSelectionsNotesHtmlEn = exports.cardDurationTupletsHtmlEn = exports.cardDurationNotesHtmlEn = exports.cardNotesRestsHtmlEn = exports.cardNotesChordsHtmlEn = exports.cardNotesChromaticHtmlEn = exports.cardNotesLetterHtmlEn = exports.cardKeysHtmlEn = exports.smoLanguageStringEn = void 0;
exports.smoLanguageStringEn = `{
    "dialogs": [
     {
      "ctor": "SuiLoadFileDialog",
      "label": "Load File",
      "dialogElements": [
       {}
      ],
      "staticText": {}
     },
     {
      "ctor": "SuiSaveFileDialog",
      "label": "Save Score",
      "dialogElements": [
       {
        "label": "File Name",
        "id": "saveFileName"
       }
      ],
      "staticText": {}
     },
     {
      "ctor": "SuiSaveXmlDialog",
      "label": "Save Score",
      "dialogElements": [
       {
        "label": "File Name",
        "id": "saveFileName"
       }
      ],
      "staticText": {}
     },
     {
      "ctor": "SuiPrintFileDialog",
      "label": "Print Complete",
      "dialogElements": [],
      "staticText": {}
     },
     {
      "ctor": "SuiSaveMidiDialog",
      "label": "Save Score as Midi",
      "dialogElements": [
       {
        "label": "File Name",
        "id": "saveFileName"
       }
      ],
      "staticText": {}
     },
     {
      "ctor": "SuiSaveActionsDialog",
      "label": "Save Score",
      "dialogElements": [
       {
        "label": "File Name",
        "id": "saveFileName"
       }
      ],
      "staticText": {}
     },
     {
      "ctor": "SuiLoadMxmlDialog",
      "label": "Load File",
      "dialogElements": [
       {},
       {
        "staticText": {
         "label": "Load File"
        }
       }
      ],
      "staticText": {}
     },
     {
      "ctor": "SuiLoadActionsDialog",
      "label": "Load Action File",
      "dialogElements": [
       {},
       {
        "staticText": {
         "label": "Load Action File"
        }
       }
      ],
      "staticText": {}
     },
     {
      "ctor": "SuiMeasureDialog",
      "label": "Measure Properties",
      "dialogElements": [
       {
        "label": "Pickup",
        "id": "pickup"
       },
       {
        "label": "Pad Left (px)",
        "id": "padLeft"
       },
       {
        "label": "Stretch Contents",
        "id": "customStretch"
       },
       {
        "label": "Proportionalality",
        "id": "customProportion"
       },
       {
        "label": "Pad all measures in system",
        "id": "padAllInSystem"
       },
       {
        "label": "Justify Columns",
        "id": "autoJustify"
       },
       {
        "label": "Text Position",
        "id": "measureTextPosition",
        "options": [
         {
          "value": 2,
          "label": "Left"
         },
         {
          "value": 3,
          "label": "Right"
         },
         {
          "value": 0,
          "label": "Above"
         },
         {
          "value": 1,
          "label": "Below"
         }
        ]
       },
       {
        "label": "System break before this measure",
        "id": "systemBreak"
       }
      ],
      "staticText": {}
     },
     {
      "ctor": "SuiTempoDialog",
      "label": "Tempo Properties",
      "dialogElements": [
       {
        "label": "Tempo Mode",
        "id": "tempoMode",
        "options": [
         {
          "value": "duration",
          "label": "Duration (Beats/Minute)"
         },
         {
          "value": "text",
          "label": "Tempo Text"
         },
         {
          "value": "custom",
          "label": "Specify text and duration"
         }
        ]
       },
       {
        "label": "Custom Text",
        "id": "customText"
       },
       {
        "label": "Notes/Minute",
        "id": "bpm"
       },
       {
        "label": "Unit for Beat",
        "id": "beatDuration",
        "options": [
         {
          "value": 4096,
          "label": "Quarter Note"
         },
         {
          "value": 2048,
          "label": "1/8 note"
         },
         {
          "value": 6144,
          "label": "Dotted 1/4 note"
         },
         {
          "value": 8192,
          "label": "1/2 note"
         }
        ]
       },
       {
        "label": "Tempo Text",
        "id": "tempoText",
        "options": [
         {
          "value": "Larghissimo",
          "label": "Larghissimo"
         },
         {
          "value": "Grave",
          "label": "Grave"
         },
         {
          "value": "Lento",
          "label": "Lento"
         },
         {
          "value": "Largo",
          "label": "Largo"
         },
         {
          "value": "Larghetto",
          "label": "Larghetto"
         },
         {
          "value": "Adagio",
          "label": "Adagio"
         },
         {
          "value": "Adagietto",
          "label": "Adagietto"
         },
         {
          "value": "Andante moderato",
          "label": "Andante moderato"
         },
         {
          "value": "Andante",
          "label": "Andante"
         },
         {
          "value": "Andantino",
          "label": "Andantino"
         },
         {
          "value": "Moderato",
          "label": "Moderato"
         },
         {
          "value": "Allegretto",
          "label": "Allegretto"
         },
         {
          "value": "Allegro",
          "label": "Allegro"
         },
         {
          "value": "Vivace",
          "label": "Vivace"
         },
         {
          "value": "Presto",
          "label": "Presto"
         },
         {
          "value": "Prestissimo",
          "label": "Prestissimo"
         }
        ]
       },
       {
        "label": "Apply to all future measures?",
        "id": "applyToAll"
       },
       {
        "label": "Display Tempo",
        "id": "display"
       },
       {
        "label": "Y Offset",
        "id": "yOffset"
       }
      ],
      "staticText": {}
     },
     {
      "ctor": "SuiInstrumentDialog",
      "label": "Instrument Properties",
      "dialogElements": [
       {
        "label": "Transpose Index (1/2 steps)",
        "id": "transposeIndex"
       },
       {
        "label": "Apply To",
        "id": "applyTo",
        "options": [
         {
          "value": 0,
          "label": "Score"
         },
         {
          "value": 1,
          "label": "Selected Measures"
         },
         {
          "value": 3,
          "label": "Remaining Measures"
         }
        ]
       }
      ],
      "staticText": {}
     },
     {
      "ctor": "SuiInsertMeasures",
      "label": "Insert Measures",
      "dialogElements": [
       {
        "label": "Measures to Insert",
        "id": "measureCount"
       },
       {
        "label": "Append to Selection",
        "id": "append"
       }
      ],
      "staticText": {}
     },
     {
      "ctor": "SuiTimeSignatureDialog",
      "label": "Custom Time Signature",
      "dialogElements": [
       {
        "label": "Beats/Measure",
        "id": "numerator"
       },
       {
        "label": "Beat Value",
        "id": "denominator",
        "options": [
         {
          "value": 8,
          "label": "8"
         },
         {
          "value": 4,
          "label": "4"
         },
         {
          "value": 2,
          "label": "2"
         }
        ]
       },
       {
        "label": "Display",
        "id": "display"
       }
      ],
      "staticText": {}
     },
     {
      "ctor": "SuiScoreViewDialog",
      "label": "Score View",
      "dialogElements": [
       {
        "label": "Show staff",
        "id": "scoreView"
       }
      ],
      "staticText": {}
     },
     {
      "ctor": "SuiScoreIdentificationDialog",
      "label": "Score Preferences",
      "dialogElements": [
       {
        "label": "Title",
        "id": "title"
       },
       {
        "label": "Sub Title",
        "id": "subTitle"
       },
       {
        "label": "Composer",
        "id": "composer"
       },
       {
        "label": "Copyright",
        "id": "copyright"
       }
      ],
      "staticText": {
       "titleText": "Title",
       "subTitleText": "Sub-title",
       "copyrightText": "Copyright",
       "composerText": "Composer",
       "show": "Show"
      }
     },
     {
      "ctor": "SuiGlobalLayoutDialog",
      "label": "Global Settings",
      "dialogElements": [
       {
        "label": "Score Name",
        "id": "scoreName"
       },
       {
        "label": "Play Selections",
        "id": "autoPlay"
       },
       {
        "label": "Auto-Advance Cursor",
        "id": "autoAdvance"
       },
       {
        "label": "Note Spacing",
        "id": "noteSpacing"
       },
       {
        "label": "Page Size",
        "id": "pageSize",
        "options": [
         {
          "value": "letter",
          "label": "Letter (Portrait)"
         },
         {
          "value": "letterLandscape",
          "label": "Letter (Landscape)"
         },
         {
          "value": "tabloid",
          "label": "Tabloid (11x17)"
         },
         {
          "value": "A4",
          "label": "A4"
         },
         {
          "value": "custom",
          "label": "Custom"
         }
        ]
       },
       {
        "label": "Page Width (px)",
        "id": "pageWidth"
       },
       {
        "label": "Page Height (px)",
        "id": "pageHeight"
       },
       {
        "label": "% Zoom",
        "id": "zoomScale"
       },
       {
        "label": "% Note size",
        "id": "svgScale"
       }
      ],
      "staticText": {}
     },
     {
      "ctor": "SuiScoreFontDialog",
      "label": "Score Fonts",
      "dialogElements": [
       {
        "label": "Engraving Font",
        "id": "engravingFont",
        "options": [
         {
          "value": "Bravura",
          "label": "Bravura"
         },
         {
          "value": "Gonville",
          "label": "Gonville"
         },
         {
          "value": "Petaluma",
          "label": "Petaluma"
         },
         {
          "value": "Leland",
          "label": "Leland"
         }
        ]
       },
       {
        "label": "Chord Font",
        "id": "chordFont"
       },
       {
        "label": "Lyric Font",
        "id": "lyricFont"
       }
      ],
      "staticText": {}
     },
     {
      "ctor": "SuiLayoutDialog",
      "label": "Page Layouts",
      "dialogElements": [
       {
        "label": "Apply to Page",
        "id": "applyToPage",
        "options": [
         {
          "value": -1,
          "label": "All"
         },
         {
          "value": -2,
          "label": "All Remaining"
         },
         {
          "value": 1,
          "label": "Page 1"
         }
        ]
       },
       {
        "label": "Left Margin (px)",
        "id": "leftMargin"
       },
       {
        "label": "Right Margin (px)",
        "id": "rightMargin"
       },
       {
        "label": "Top Margin (px)",
        "id": "topMargin"
       },
       {
        "label": "Bottom Margin (px)",
        "id": "bottomMargin"
       },
       {
        "label": "Inter-System Margin",
        "id": "interGap"
       },
       {
        "label": "Intra-System Margin",
        "id": "intraGap"
       },
       {
        "staticText": {
         "label": "Page Layouts"
        }
       }
      ],
      "staticText": {}
     },
     {
      "ctor": "SuiSlurAttributesDialog",
      "label": "Slur Properties",
      "dialogElements": [
       {
        "label": "Spacing",
        "id": "spacing"
       },
       {
        "label": "Thickness",
        "id": "thickness"
       },
       {
        "label": "X Offset",
        "id": "xOffset"
       },
       {
        "label": "Y Offset",
        "id": "yOffset"
       },
       {
        "label": "Start Position",
        "id": "position",
        "options": [
         {
          "value": 1,
          "label": "Head"
         },
         {
          "value": 2,
          "label": "Top"
         }
        ]
       },
       {
        "label": "End Position",
        "id": "position_end",
        "options": [
         {
          "value": 1,
          "label": "Head"
         },
         {
          "value": 2,
          "label": "Top"
         }
        ]
       },
       {
        "label": "Invert",
        "id": "invert"
       },
       {
        "label": "Control Point 1 X",
        "id": "cp1x"
       },
       {
        "label": "Control Point 1 Y",
        "id": "cp1y"
       },
       {
        "label": "Control Point 2 X",
        "id": "cp2x"
       },
       {
        "label": "Control Point 2 Y",
        "id": "cp2y"
       }
      ],
      "staticText": {}
     },
     {
      "ctor": "SuiTieAttributesDialog",
      "label": "Tie Properties",
      "dialogElements": [
       {
        "label": "Lines",
        "id": "lines"
       }
      ],
      "staticText": {
       "label": "Tie Properties",
       "fromNote": "From Note",
       "toNote": "To Note"
      }
     },
     {
      "ctor": "SuiVoltaAttributeDialog",
      "label": "Volta Properties",
      "dialogElements": [
       {
        "label": "number",
        "id": "number"
       },
       {
        "label": "X1 Offset",
        "id": "xOffsetStart"
       },
       {
        "label": "X2 Offset",
        "id": "xOffsetEnd"
       },
       {
        "label": "Y Offset",
        "id": "yOffset"
       }
      ],
      "staticText": {}
     },
     {
      "ctor": "SuiHairpinAttributesDialog",
      "label": "Hairpin Properties",
      "dialogElements": [
       {
        "label": "Height",
        "id": "height"
       },
       {
        "label": "Y Shift",
        "id": "yOffset"
       },
       {
        "label": "Right Shift",
        "id": "xOffsetRight"
       },
       {
        "label": "Left Shift",
        "id": "xOffsetLeft"
       }
      ],
      "staticText": {}
     },
     {
      "ctor": "SuiStaffGroupDialog",
      "label": "Staff Group",
      "dialogElements": [
       {
        "label": "Staves in Group",
        "id": "staffGroups"
       },
       {
        "label": "Left Connector",
        "id": "leftConnector",
        "options": [
         {
          "value": 1,
          "label": "Bracket"
         },
         {
          "value": 0,
          "label": "Brace"
         },
         {
          "value": 2,
          "label": "Single"
         },
         {
          "value": 3,
          "label": "Double"
         }
        ]
       }
      ],
      "staticText": {
       "includeStaff": "Include Staff"
      }
     },
     {
      "ctor": "SuiDynamicModifierDialog",
      "label": "Dynamics Properties",
      "dialogElements": [
       {
        "label": "Y Line",
        "id": "yOffsetLine"
       },
       {
        "label": "Y Offset Px",
        "id": "yOffsetPixels"
       },
       {
        "label": "X Offset",
        "id": "xOffset"
       },
       {
        "label": "Text",
        "id": "text",
        "options": [
         {
          "value": "p",
          "label": "Piano"
         },
         {
          "value": "pp",
          "label": "Pianissimo"
         },
         {
          "value": "mp",
          "label": "Mezzo-Piano"
         },
         {
          "value": "mf",
          "label": "Mezzo-Forte"
         },
         {
          "value": "f",
          "label": "Forte"
         },
         {
          "value": "ff",
          "label": "Fortissimo"
         },
         {
          "value": "sfz",
          "label": "Sforzando"
         }
        ]
       }
      ],
      "staticText": {}
     },
     {
      "ctor": "SuiLyricDialog",
      "label": "Lyric Editor",
      "dialogElements": [
       {
        "label": "Verse",
        "id": "verse",
        "options": [
         {
          "value": 0,
          "label": "1"
         },
         {
          "value": 1,
          "label": "2"
         },
         {
          "value": 2,
          "label": "3"
         },
         {
          "value": 3,
          "label": "4"
         }
        ]
       },
       {
        "label": "Y Adjustment (Px)",
        "id": "translateY"
       },
       {
        "label": "Font",
        "id": "font"
       },
       {
        "label": "Edit Lyrics",
        "id": "lyricEditor",
        "options": []
       }
      ],
      "staticText": {
       "doneEditing": "Done Editing Lyrics",
       "undo": "Undo Lyrics",
       "label": "Lyric Editor"
      }
     },
     {
      "ctor": "SuiChordChangeDialog",
      "label": "Edit Chord Symbol",
      "dialogElements": [
       {
        "label": "Ordinality",
        "id": "verse",
        "options": [
         {
          "value": 0,
          "label": "1"
         },
         {
          "value": 1,
          "label": "2"
         },
         {
          "value": 2,
          "label": "3"
         }
        ]
       },
       {
        "label": "Y Adjustment (Px)",
        "id": "translateY"
       },
       {
        "label": "Edit Text",
        "id": "chordEditor",
        "options": []
       },
       {
        "label": "Chord Symbol",
        "id": "chordSymbol",
        "options": [
         {
          "value": "csymDiminished",
          "label": "Dim"
         },
         {
          "value": "csymHalfDiminished",
          "label": "Half dim"
         },
         {
          "value": "csymDiagonalArrangementSlash",
          "label": "Slash"
         },
         {
          "value": "csymMajorSeventh",
          "label": "Maj7"
         }
        ]
       },
       {
        "label": "Text Position",
        "id": "textPosition",
        "options": [
         {
          "value": 1,
          "label": "Superscript"
         },
         {
          "value": 2,
          "label": "Subscript"
         },
         {
          "value": 0,
          "label": "Normal"
         }
        ]
       },
       {
        "label": "Font",
        "id": "font"
       },
       {
        "label": "Adjust Note Width",
        "id": "adjustWidth",
        "options": []
       }
      ],
      "staticText": {
       "label": "Edit Chord Symbol",
       "undo": "Undo Chord Symbols",
       "doneEditing": "Done Editing Chord Symbols"
      }
     },
     {
      "ctor": "SuiTextBlockDialog",
      "label": "Text Properties",
      "dialogElements": [
       {
        "label": "Edit Text",
        "id": "textEditor",
        "options": []
       },
       {
        "label": "Insert Special",
        "id": "insertCode",
        "options": [
         {
          "value": "@@@",
          "label": "Pages"
         },
         {
          "value": "###",
          "label": "Page Number"
         }
        ]
       },
       {
        "label": "Move Text",
        "id": "textDragger",
        "options": []
       },
       {
        "label": "X Position (Px)",
        "id": "x"
       },
       {
        "label": "Y Position (Px)",
        "id": "y"
       },
       {
        "label": "Font Information",
        "id": "font"
       },
       {
        "label": "Text Block Properties",
        "id": "textBlock"
       },
       {
        "label": "Page Behavior",
        "id": "pagination",
        "options": [
         {
          "value": 4,
          "label": "Once"
         },
         {
          "value": 1,
          "label": "Every"
         },
         {
          "label": "Even"
         },
         {
          "value": 3,
          "label": "Odd"
         },
         {
          "value": 5,
          "label": "Subsequent"
         }
        ]
       },
       {
        "label": "Attach to Selection",
        "id": "attachToSelector"
       }
      ],
      "staticText": {
       "label": "Text Properties",
       "editorLabel": "Done Editing Text",
       "draggerLabel": "Done Dragging Text"
      }
     }
    ],
    "menus": [
     {
      "ctor": "SuiDynamicsMenu",
      "label": "Dynamics",
      "menuItems": [
       {
        "icon": "pianissimo",
        "text": "Pianissimo",
        "value": "pp"
       },
       {
        "icon": "piano",
        "text": "Piano",
        "value": "p"
       },
       {
        "icon": "mezzopiano",
        "text": "Mezzo-piano",
        "value": "mp"
       },
       {
        "icon": "mezzoforte",
        "text": "Mezzo-forte",
        "value": "mf"
       },
       {
        "icon": "forte",
        "text": "Forte",
        "value": "f"
       },
       {
        "icon": "fortissimo",
        "text": "Fortissimo",
        "value": "ff"
       },
       {
        "icon": "sfz",
        "text": "sfortzando",
        "value": "sfz"
       },
       {
        "icon": "",
        "text": "Cancel",
        "value": "cancel"
       }
      ]
     },
     {
      "ctor": "SuiFileMenu",
      "label": "File",
      "menuItems": [
       {
        "icon": "folder-new",
        "text": "New Score",
        "value": "newFile"
       },
       {
        "icon": "folder-open",
        "text": "Open",
        "value": "openFile"
       },
       {
        "icon": "",
        "text": "Quick Save",
        "value": "quickSave"
       },
       {
        "icon": "folder-save",
        "text": "Save",
        "value": "saveFile"
       },
       {
        "icon": "",
        "text": "Print",
        "value": "printScore"
       },
       {
        "icon": "",
        "text": "Import MusicXML",
        "value": "importMxml"
       },
       {
        "icon": "",
        "text": "Export MusicXML",
        "value": "exportXml"
       },
       {
        "icon": "",
        "text": "Export Midi",
        "value": "exportMidi"
       },
       {
        "icon": "folder-save",
        "text": "Save Actions",
        "value": "saveActions"
       },
       {
        "icon": "icon-play3",
        "text": "Play Actions",
        "value": "playActions"
       },
       {
        "icon": "",
        "text": "Cancel",
        "value": "cancel"
       }
      ]
     },     
     {
      "ctor": "SuiKeySignatureMenu",
      "label": "Key",
      "menuItems": [
       {
        "icon": "key-sig-c",
        "text": "C Major",
        "value": "KeyOfC"
       },
       {
        "icon": "key-sig-f",
        "text": "F Major",
        "value": "KeyOfF"
       },
       {
        "icon": "key-sig-g",
        "text": "G Major",
        "value": "KeyOfG"
       },
       {
        "icon": "key-sig-bb",
        "text": "Bb Major",
        "value": "KeyOfBb"
       },
       {
        "icon": "key-sig-d",
        "text": "D Major",
        "value": "KeyOfD"
       },
       {
        "icon": "key-sig-eb",
        "text": "Eb Major",
        "value": "KeyOfEb"
       },
       {
        "icon": "key-sig-a",
        "text": "A Major",
        "value": "KeyOfA"
       },
       {
        "icon": "key-sig-ab",
        "text": "Ab Major",
        "value": "KeyOfAb"
       },
       {
        "icon": "key-sig-e",
        "text": "E Major",
        "value": "KeyOfE"
       },
       {
        "icon": "key-sig-bd",
        "text": "Db Major",
        "value": "KeyOfDb"
       },
       {
        "icon": "key-sig-b",
        "text": "B Major",
        "value": "KeyOfB"
       },
       {
        "icon": "key-sig-fs",
        "text": "F# Major",
        "value": "KeyOfF#"
       },
       {
        "icon": "key-sig-cs",
        "text": "C# Major",
        "value": "KeyOfC#"
       },
       {
        "icon": "",
        "text": "Cancel",
        "value": "cancel"
       }
      ]
     },
     {
      "ctor": "SuiMeasureMenu",
      "label": "Measure",
      "menuItems": [
       {
        "icon": "",
        "text": "Add Measures",
        "value": "addMenuCmd"
       },
       {
        "icon": "icon-cross",
        "text": "Delete Selected Measures",
        "value": "deleteSelected"
       },
       {
        "icon": "",
        "text": "Format Measure",
        "value": "formatMeasureDialog"
       },
       {
        "icon": "",
        "text": "Cancel",
        "value": "cancel"
       }
      ]
     },
     {
      "ctor": "SuiTimeSignatureMenu",
      "label": "Time Sig",
      "menuItems": [
       {
        "icon": "sixeight",
        "text": "6/8",
        "value": "6/8"
       },
       {
        "icon": "fourfour",
        "text": "4/4",
        "value": "4/4"
       },
       {
        "icon": "threefour",
        "text": "3/4",
        "value": "3/4"
       },
       {
        "icon": "twofour",
        "text": "2/4",
        "value": "2/4"
       },
       {
        "icon": "twelveeight",
        "text": "12/8",
        "value": "12/8"
       },
       {
        "icon": "seveneight",
        "text": "7/8",
        "value": "7/8"
       },
       {
        "icon": "fiveeight",
        "text": "5/8",
        "value": "5/8"
       },
       {
        "icon": "",
        "text": "Other",
        "value": "TimeSigOther"
       },
       {
        "icon": "",
        "text": "Cancel",
        "value": "cancel"
       }
      ]
     },
     {
      "ctor": "SuiStaffModifierMenu",
      "label": "Lines",
      "menuItems": [
       {
        "icon": "cresc",
        "text": "Crescendo",
        "value": "crescendo"
       },
       {
        "icon": "decresc",
        "text": "Decrescendo",
        "value": "decrescendo"
       },
       {
        "icon": "slur",
        "text": "Slur",
        "value": "slur"
       },
       {
        "icon": "slur",
        "text": "Tie",
        "value": "tie"
       },
       {
        "icon": "ending",
        "text": "nth ending",
        "value": "ending"
       },
       {
        "icon": "",
        "text": "Cancel",
        "value": "cancel"
       }
      ]
     },
     {
      "ctor": "SuiLanguageMenu",
      "label": "Language",
      "menuItems": [
       {
        "icon": "",
        "text": "English",
        "value": "en"
       },
       {
        "icon": "",
        "text": "Deutsch",
        "value": "de"
       },
       {
        "icon": "",
        "text": "",
        "value": "ar"
       },
       {
        "icon": "",
        "text": "Cancel",
        "value": "cancel"
       }
      ]
     },
     {
      "ctor": "SuiLibraryMenu",
      "label": "Score",
      "menuItems": [
       {
        "icon": "",
        "text": "Bach Invention",
        "value": "bach"
       },
       {
        "icon": "",
        "text": "Postillion-Lied",
        "value": "postillion"
       },
       {
        "icon": "",
        "text": "Jesu Bambino",
        "value": "bambino"
       },
       {
        "icon": "",
        "text": "Handel Messiah 1-1",
        "value": "handel"
       },
       {
        "icon": "",
        "text": "Precious Lord",
        "value": "preciousLord"
       },
       {
        "icon": "",
        "text": "In Its Delightful Shade",
        "value": "shade"
       },
       {
        "icon": "",
        "text": "Yama",
        "value": "yamaJson"
       },
       {
        "icon": "",
        "text": "Dichterliebe (xml)",
        "value": "dichterliebe"
       },
       {
        "icon": "",
        "text": "Beethoven - An die ferne Gliebte (xml)",
        "value": "beethoven"
       },
       {
        "icon": "",
        "text": "Mozart - An Chloe (xml)",
        "value": "mozart"
       },
       {
        "icon": "",
        "text": "Joplin - The Entertainer (xml)",
        "value": "joplin"
       },
       {
        "icon": "",
        "text": "Cancel",
        "value": "cancel"
       }
      ]
     },
     {
      "ctor": "SuiScoreMenu",
      "label": "Score Settings",
      "menuItems": [
       {
        "icon": "",
        "text": "Layout",
        "value": "layout"
       },
       {
        "icon": "",
        "text": "Fonts",
        "value": "fonts"
       },
       {
        "icon": "",
        "text": "View",
        "value": "view"
       },
       {
        "icon": "",
        "text": "Score Info",
        "value": "identification"
       },
       {
        "icon": "",
        "text": "Global Settings",
        "value": "preferences"
       },
       {
        "icon": "",
        "text": "Cancel",
        "value": "cancel"
       }
      ]
     }
    ],
    "buttonText": [
     {
      "buttonId": "helpDialog",
      "buttonText": "Help"
     },
     {
      "buttonId": "languageMenu",
      "buttonText": "Language"
     },
     {
      "buttonId": "fileMenu",
      "buttonText": "File"
     },
     {
      "buttonId": "libraryMenu",
      "buttonText": "Library"
     },
     {
      "buttonId": "addStaffMenu",
      "buttonText": "Staves"
     },
     {
      "buttonId": "measureModal",
      "buttonText": "Measure"
     },
     {
      "buttonId": "tempoModal",
      "buttonText": "Tempo"
     },
     {
      "buttonId": "timeSignatureMenu",
      "buttonText": "Time Signature"
     },
     {
      "buttonId": "keyMenu",
      "buttonText": "Key"
     },
     {
      "buttonId": "staffModifierMenu",
      "buttonText": "Lines"
     },
     {
      "buttonId": "instrumentModal",
      "buttonText": "Instrument"
     },
     {
      "buttonId": "pianoModal",
      "buttonText": "Piano"
     },
     {
      "buttonId": "layoutMenu",
      "buttonText": "Score"
     },
     {
      "buttonId": "UpOctaveButton",
      "buttonText": "8va"
     },
     {
      "buttonId": "DownOctaveButton",
      "buttonText": "8vb"
     },
     {
      "buttonId": "moreNavButtons",
      "buttonText": "..."
     },
     {
      "buttonId": "dcAlCoda",
      "buttonText": "DC Al Coda"
     },
     {
      "buttonId": "dsAlCoda",
      "buttonText": "DS Al Coda"
     },
     {
      "buttonId": "dcAlFine",
      "buttonText": "DC Al Fine"
     },
     {
      "buttonId": "dsAlFine",
      "buttonText": "DS Al Fine"
     },
     {
      "buttonId": "toCoda",
      "buttonText": "to "
     },
     {
      "buttonId": "fine",
      "buttonText": "Fine"
     },
     {
      "buttonId": "moreStaffButtons",
      "buttonText": "..."
     }
    ]
   }`;
exports.cardKeysHtmlEn = `
<h3 id="welcome-to-smoosic">Welcome to Smoosic</h3>
<p>Smoosic was designed to allow you to enter music as fast as you can type, once you learn some basic commands and patterns.  While music can be entered in multiple ways, the fastest/easiest way to create or edit in Smoosic is to use some basic keyboard shortcuts.</p>
<p>You can customize the key bindings (which keys do what) by changing the files in <code>src/ui/keyBindings/</code> directory, or by providing your own bindings.  See the <code>custom-keybinding.html</code> in the project that demonstrates how to create your own key bindings.
<img src="https://imgur.com/jJ5utJm.gif" alt=""></p>
`;
exports.cardNotesLetterHtmlEn = `
<p>Most key commands in Smoosic have a mnemonic device.  The keys <strong>a-g</strong> on the computer keyboard will enter a corresponding note, A-G, on the staff.  The default behavior is for the cursor to advance when a note is entered in this way.  This can be overridden in the &#39;Score Preferences&#39; dialog. You navigate to the notes using the keyboard navigation arrows.</p>
<p><img src="https://imgur.com/lxR0NI7.gif" alt=""></p>
<p>Some conventions used in this documentation: </p>
<p>Keystrokes are specified in <strong>bold</strong>, e.g. <strong>x</strong> means the &#39;x&#39; key.  <strong>Shift+E</strong> means to press the <strong>Shift</strong> and <strong>E</strong> keys at the same time.</p>
<p>Key sequences are specified on their own line:</p>
<p><strong>/</strong> <strong>a</strong></p>
<p>means to press the <strong>/</strong> key followed by the <strong>a</strong> key.</p>
`;
exports.cardNotesChromaticHtmlEn = `
<p>You change notes chromatically using <strong>-</strong> and <strong>=</strong> key.  You can change the octave using the <strong>_</strong> (underscore) and <strong>+</strong> (plus) keys.   The mnemonic device for this is &#39;plus and minus&#39; for raising and lowering pitches.  You can change the enharmonic spelling of the note using the <strong>Shift+E</strong> (mnemonic: E for enharmonic - get it?).  And <strong>Shift+F</strong> gives you a courtesy, or cautionary, accidental (mnemonic - F comes after E).</p>
<p><img src="https://imgur.com/1tC94sV.gif" alt=""></p>
`;
exports.cardNotesChordsHtmlEn = `
<p>You can create chords and intervals using the number keys along the top of the keyboard.  The <strong>3</strong> key makes a third, the <strong>4</strong> key a fourth, and so on.  <strong>Shift+3</strong> gives you the 3rd below.</p>
<p>You can toggle selection to individual pitches by using <strong>Shift+UpArrow</strong>. So to create a G triad, starting with <strong>g</strong>, hit <strong>3</strong> for the &#39;B&#39;, <strong>3</strong> again for the &#39;D&#39;.  So far, we have G major.  To lower the 3rd, <strong>Shift+up</strong> to select the &#39;B&#39;, then <strong>-</strong> to lower the pitch.</p>
<p><img src="https://imgur.com/NGXRJQZ.gif" alt=""></p>
`;
exports.cardNotesRestsHtmlEn = `
<p>You can toggle notes to rests by pressing <strong>r</strong> or <strong>Delete</strong>.</p>
<p>In Smoosic, you can&#39;t truly delete a note - a 4/4 bar will always have 4 beats of music.  But you can &#39;hide&#39; notes by creating invisible rests.  This is another use of <strong>Delete</strong>.</p>
<p><strong>Delete</strong> follows standard toggle behavior - deleted notes become rests, and delete rests become invisible rests.  Hitting <strong>Delete</strong> a third time restores the note.</p>
<p>Invisible rests show up as partially opaque in the display.  But when printed, they are truly invisible.</p>
<p><img src="https://imgur.com/c2FVZi3.gif" alt=""></p>
`;
exports.cardDurationNotesHtmlEn = `
<p>Changing duration is a little different in Smoosic than other programs.  Rather than selecting a duration (quarter note, etc.), you change (increase/decrease) the duration of existing notes.</p>
<p>You can change the length of notes using the <strong>,</strong> and <strong>.</strong> (comma and period) keys, which halve and double the note lengths, respectively.  You can add a dot to the length of the note (multiplying length by 3/2 for the first dot, and 5/4 for the second dot, if you like to think of it that way) or remove a dot, using the <strong>&gt;</strong> (<strong>Shift+,</strong>) and <strong>,</strong>.  The mnemonic device for these is <strong>&gt;</strong> makes note duration greater. <strong>&lt;</strong>  makes note duration less.  (On most QWERTY keyboards, comma shifted is <strong>&lt;</strong> and period shifted is <strong>&gt;</strong>).</p>
<p><img src="https://imgur.com/5ZWq2Xe.gif" alt=""></p>`;
exports.cardDurationTupletsHtmlEn = `
<p>You can create tuplets from the keyboard by typing <strong>Ctrl+3</strong>, <strong>Ctrl+5</strong> or <strong>Ctrl+7</strong> for triplets, quintuplets, and septuplets, respectively.  Individual notes in a tuplet can be doubled and halved with the duration keys <strong>-</strong> (minus) and <strong>=</strong> (equals), just like non-tuplets.  You &#39;untupletify&#39; a tuplet by <strong>Ctrl+0</strong>.</p>
<p><img src="https://imgur.com/uBpQwXD.gif" alt=""></p>`;
exports.cardSelectionsNotesHtmlEn = ` <p>Many operations in Smoosic act on the selected music.  You select the music the way you select text in a text app, with the <strong></strong> to move right, <strong></strong> to move left.   <strong>Shift+</strong> expands the selection left, etc. </p>
<p><img src="https://imgur.com/5ZWq2Xe.gif" alt=""></p>
<p>In the last example, note how the selection is preserved as the notes get shorter.  When you change something, Smoosic will try to keep the selection as close as possible to what you had when the music changes.
You can also use the mouse to select notes.  Selecting a range across multiple staves is not supported (yet).  But you can use <strong>Control+click</strong> to select notes in multiple staves.</p>
`;
exports.cardSelectionsModifiersHtmlEn = ` 
<p>A modifier is anything that affects a note, such as an articulation or dynamic.  Many modifiers, especially those that affect multiple notes, can be selected with the keyboard.  To select a modifier such as a slur, crescendo, or ending, use &#39;Alt-left arrow&#39; or &#39;Alt-right arrow&#39; when the first or last note of the modifier is selected.  This will move the selecttion between modifiers that apply to that note.</p>
<p>You can also select modifiers with the mouse. </p>
<p>Once selected, you can bring up the modifier dialog by hitting &#39;Enter&#39;.</p>
<p><img src="https://imgur.com/rhOyIKD.gif" alt=""></p>
`;
exports.cardSelectionsNonSelectableHtmlEn = `
<p>Some modifiers, such as articulations, aren&#39;t selectable.  The keys <strong>h</strong>, <strong>i</strong>, <strong>j</strong>, and <strong>k</strong> bring up articulations that aren&#39;t selectable, but are placed on the note automatically.  You can toggle position and on/off by repeating the key.</p>
<p>Additional articulations are available from the of articulation button group.</p>
<p>You can customize the articulations selected by the key bindings by changing the <code>ui/keyBindings/editorKeys.ts</code> file, or by providing your own bindings.  See the <code>custom-keybinding.html</code> example in the project.</p>
<p><img src="https://imgur.com/RqY9Nzo.gif" alt=""></p>`;
exports.cardSelectionsSlashHtmlEn = `
<p>The buttons on the left (for L-to-R languages) bring up menus and dialogs.  These dialogs can also be accessed via the &#39;Slash&#39; menus.</p>
<p>For instance, slurs, ties, hairpins and other modifiers that work on a range of music are created from the &#39;Lines&#39; menu.  You can access this via the slash menu:</p>
<p><strong>/</strong> <strong>l</strong> (el, not one) <strong>2</strong></p>
<p>Then you can use the modifier selection to edit the phrase marking to your taste.</p>
<p>You can also select modifiers or any menu option with the mouse.</p>
<p><img src="https://imgur.com/4QfEfSs.gif" alt=""></p>`;
exports.cardBeamsAndStemsDirectionHtmlEn = `
<h3 id="beams-and-stems-part-1-direction">Beams and Stems part 1: Direction</h3>
<p>The direction of beams and stems is controlled selecting the notes you want to affect and typing <strong>Shift+B</strong>.  The selection will be toggled between auto (default), up, and down. &#39;Auto&#39; means stems are up if the notes are below 3rd line, so the beam direction will change if the notes do. </p>
<p>Note that there are 3 settings, even though only 2 will produce a visible change for any given stem, since &#39;auto&#39; will be either up or down.  </p>
<p><img src="https://imgur.com/itUMVBF.gif" alt=""></p>
`;
exports.cardBeamsAndStemsGroupingHtmlEn = `
<p>By default, notes are auto-beamed so that a 1/4 note is beamed.  So 1/8 notes in 4/4 time will be beamed in 2&#39;s, 16th notes in 4&#39;s etc.  In triple time (e.g. 6/8, 9/8), 1/8 notes are beamed in 3&#39;s.  You can change this default in the Score Preferences.</p>
<p>You can split a beam at any point using the <strong>x</strong> (mnemonic: <strong>x</strong> to cancel beaming.  You can create a beam by selecting the notes and typing <strong>Shift-X</strong>.  Only notes with 1/8 note duration or less can be beamed.</p>
<p><img src="https://imgur.com/wZmXKq8.gif" alt=""></p>
`;
exports.cardMeasuresAddDeleteHtmlEn = `
<p>You can add a single measure at the current selection point by pressing <strong>Insert</strong>.  <strong>Shift+Insert</strong> appends the new measure to the selected measure.</p>
<p>To add many measures, you can do this from the &#39;Add Measures&#39; dialog.  This can be brought up through the &#39;Measure&#39; button on the left, or by pressing </p>
<p><strong>/</strong>  <strong>a</strong>  <strong>0</strong> (zero)</p>
<p>Deleting the selected measures can be done from the &#39;Measures&#39; menu on the left, or by pressing </p>
<p><strong>/</strong>  <strong>a</strong> <strong>1</strong>.</p>
<p>Note the insert and delete key behavior is asymmetric.  The <strong>Delete</strong> key is used to toggle notes to rests, and also I thought this made it too easy to accidentally delete a lot of music. </p>
<p><img src="https://imgur.com/gGuxP7G.gif" alt=""></p>
`;
exports.cardVoicesCreateDeleteHtmlEn = `
<p>If you need different rhythms in the same stave, you can do this by creating multiple voices.  You add a voice to a measure using the voice buttons - you can have up to 4 voices in a measure.  </p>
<p>You can select a differnt voice using the voice buttons also.  </p>
<p>You can delete any voice except voice 1 by selecting the voice, and selecting the <strong>Vx</strong> button.  When a voice is deleted, any voices with a higher number are bumped down - e.g., if you delete voice 2, voice 3 becomes voice 2, etc.</p>
<p>By default, the odd-numbered voices (indexed from 1) have stems that point up.  You can use the <strong>Ctrl+B</strong> to change the staff direction if you want.</p>
<p>Notes in voices &gt; 1 have different colors in the editor.  This is to make editing easier.  All voices are black when the music is printed.</p>
<p><img src="https://imgur.com/HIUH2Pp.gif" alt=""></p>
`;
exports.cardPartAddDeleteHtmlEn = `    <p>You can add a new stave/part from the parts menu.</p>
<p><strong>/</strong>  <strong>p</strong>  <strong>0</strong> (zero)</p>
<p>From the dialog, you can select the initial properties of the new stave, such as the clef and transposition.</p>
<p>To delete the selected staves:
<strong>/</strong>  <strong>p</strong>  <strong>1</strong> (zero)</p>
<p>Note that you can&#39;t delete the only stave - the music will always contain at least one stave.</p>
<p>Note:  The &#39;Part&#39; menu may show different options depending on what else is in the score.  Other characteristics of the part and staff are covered in the &#39;Working with Scores&#39; section.</p>
<p><img src="https://imgur.com/7GAia6G.gif" alt=""></p>
`;
exports.helpCards = [exports.cardKeysHtmlEn, exports.cardNotesLetterHtmlEn, exports.cardNotesChromaticHtmlEn, exports.cardNotesChordsHtmlEn,
    exports.cardNotesRestsHtmlEn, exports.cardDurationNotesHtmlEn, exports.cardDurationTupletsHtmlEn,
    exports.cardSelectionsNotesHtmlEn, exports.cardSelectionsModifiersHtmlEn, exports.cardSelectionsNonSelectableHtmlEn, exports.cardSelectionsSlashHtmlEn,
    exports.cardBeamsAndStemsDirectionHtmlEn, exports.cardBeamsAndStemsGroupingHtmlEn,
    exports.cardMeasuresAddDeleteHtmlEn, exports.cardVoicesCreateDeleteHtmlEn, exports.cardPartAddDeleteHtmlEn
];


/***/ }),

/***/ "./src/ui/i18n/translationEditor.ts":
/*!******************************************!*\
  !*** ./src/ui/i18n/translationEditor.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SmoTranslationEditor = void 0;
// [Smoosic](https://github.com/AaronDavidNewman/Smoosic)
// Copyright (c) Aaron David Newman 2021.
const htmlHelpers_1 = __webpack_require__(/*! ../../common/htmlHelpers */ "./src/common/htmlHelpers.ts");
const language_1 = __webpack_require__(/*! ./language */ "./src/ui/i18n/language.ts");
const ribbon_1 = __webpack_require__(/*! ../buttons/ribbon */ "./src/ui/buttons/ribbon.ts");
// ## SmoTranslationEditor
// Create a somewhat user-friendly editor DOM to translate SMO
// dialogs and menus, and any subset, into other languages.
class SmoTranslationEditor {
    // ### _getHtmlTextInput
    // All the editable text elements contain: the code label or value from the
    // UI element, the En string, and  the translated string, or a copy of the
    // EN string if the string has not been translated.
    static _getHtmlTextInput(dbLabel, enLabel, langLabel, labelType, labelId) {
        var b = htmlHelpers_1.buildDom;
        const compHtml = b('div').classes('dialog-element-container')
            .attr('data-' + labelType, labelId).append(b('div').classes('dialog-component-label').append(b('span').classes('trans-label').append(b('span').classes('trans-db-text').text(dbLabel)).append(b('span').classes('trans-en-text').text(enLabel)).append(b('input').classes('trans-label-input')).append(b('span').classes('plaintext-translate hide').text(langLabel)))).dom();
        return compHtml;
    }
    // ### _getMenuTextDialogHtml
    // Get all the menu item labels for translation
    static _getMenuTextDialogHtml(menuCtor, enStrings, langStrings) {
        const menuClass = eval('globalThis.Smo.' + menuCtor);
        const menuItems = menuClass['defaults'].menuItems;
        var enMenu = enStrings.menus.find((mn) => mn.ctor === menuCtor);
        // Get the JSON EN menu, or copy the DB strings if it doesn't exist
        if (!enMenu) {
            enMenu = JSON.parse(JSON.stringify(menuClass['defaults']));
            enMenu.ctor = menuCtor;
        }
        // Get the JSON language menu strings, or copy the EN strings if it doesn't exist
        var langMenu = langStrings.menus.find((mn) => mn.ctor === menuCtor);
        if (!langMenu) {
            langMenu = JSON.parse(JSON.stringify(menuClass['defaults']));
            langMenu.ctor = menuCtor;
        }
        // create the DOM menu container
        var b = htmlHelpers_1.buildDom;
        const container = b('div').classes('menu-translate-container')
            .attr('data-menucontainer', menuCtor).append(b('button').classes('icon-plus trans-expander')).append(b('span').classes('menu-translate-title').text(menuCtor)).dom();
        const menuItemsDom = b('div').classes('menu-element-container').dom();
        // create the label editor
        const menuLabel = SmoTranslationEditor._getHtmlTextInput(menuClass['defaults'].label, enMenu.label, langMenu.label, 'menulabel', menuCtor);
        $(menuItemsDom).append(menuLabel);
        $(container).append(menuItemsDom);
        // create the editor for each item
        menuItems.forEach((item) => {
            var enItem = enMenu.menuItems.find((mi) => mi.value === item.value);
            if (!enItem) {
                enItem = JSON.parse(JSON.stringify(item));
            }
            var langItem = langMenu.menuItems.find((mi) => mi.value === item.value);
            if (!langItem) {
                langItem = JSON.parse(JSON.stringify(item));
            }
            const menuItemDom = b('div').classes('menu-item-container').dom();
            const itemEditDom = SmoTranslationEditor._getHtmlTextInput(item.value, enItem.text, langItem.text, 'itemtext', item.value);
            $(menuItemDom).append(itemEditDom);
            $(menuItemsDom).append(menuItemDom);
        });
        return container;
    }
    static getButtonTranslateHtml(enStrings, langStrings, transContainer) {
        var b = htmlHelpers_1.buildDom;
        var buttonDom = b('div').classes('ribbon-translate-container')
            .attr('data-ribbon-translate', 'buttons').append(b('button').classes('icon-plus trans-expander')).append(b('span').classes('ribbon-translate-title').text('Button Text')).dom();
        var enKeys = enStrings.buttonText;
        if (!enKeys) {
            enKeys = JSON.parse(JSON.stringify(ribbon_1.RibbonButtons.translateButtons));
        }
        var langKeys = langStrings.buttonText;
        if (!langKeys) {
            langKeys = JSON.parse(JSON.stringify(ribbon_1.RibbonButtons.translateButtons));
        }
        enKeys.forEach((button) => {
            const langObj = langKeys.find((langText) => langText.buttonId === button.buttonId);
            const langString = langObj ? langObj.buttonText : button.buttonText;
            var buttonContainer = b('div').classes('ribbon-button-container')
                .attr('data-buttoncontainer', button.buttonId).dom();
            $(buttonContainer).append(SmoTranslationEditor._getHtmlTextInput(button.buttonId, button.buttonText, langString, 'ribbon-button', button.buttonId));
            $(buttonDom).append(buttonContainer);
        });
        $(transContainer).append(buttonDom);
    }
    // ### _getStaticTextDialogHtml
    // create DOM for the static text section of the dialogs.
    static _getStaticTextDialogHtml(elements, enDb, langDb, htmlContainer) {
        var b = htmlHelpers_1.buildDom;
        const keys = Object.keys(elements.staticText);
        const nodeContainer = b('div')
            .classes('dialog-element-container')
            .attr('data-component', 'staticText')
            .dom();
        elements.staticText.forEach((nv) => {
            const name = Object.keys(nv)[0];
            const value = nv[name];
            var enVal = enDb[name] ? enDb[name] : value;
            var langVal = langDb[name] ? langDb[name] : enDb[name];
            const translateElement = SmoTranslationEditor._getHtmlTextInput(name, enVal, langVal, 'statictext', name);
            $(nodeContainer).append(translateElement);
        });
        $(htmlContainer).append(nodeContainer);
    }
    static _getDialogComponentHtml(element, enDb, langDb, container) {
        var b = htmlHelpers_1.buildDom;
        var label = element.label;
        var smoName = element.smoName;
        if (typeof (enDb.dialogElements.find) !== 'function') {
            console.warn('no ENDB!');
        }
        var enComponent = enDb.dialogElements.find((st) => st.id === smoName);
        if (!enComponent) {
            enComponent = JSON.parse(JSON.stringify(element));
        }
        var langComponent = langDb.dialogElements.find((st) => st.id === smoName);
        if (!langComponent) {
            langComponent = JSON.parse(JSON.stringify(element));
        }
        const enLabel = enComponent.label ? enComponent.label : label;
        const langLabel = langComponent.label ? langComponent.label : label;
        const compHtml = SmoTranslationEditor._getHtmlTextInput(label, enLabel, langLabel, 'component', smoName);
        if (element.options) {
            const optionsHtml = b('div').classes('dialog-component-options').dom();
            $(compHtml).append(optionsHtml);
            if (!enComponent.options) {
                enComponent.options = JSON.parse(JSON.stringify(element.options));
            }
            if (!langComponent.options) {
                langComponent.options = JSON.parse(JSON.stringify(element.options));
            }
            element.options.forEach((option) => {
                var enOption = enComponent.options.find((op) => op.value === option.value);
                var langOption = langComponent.options.find((op) => op.value === option.value);
                if (!enOption || !enOption.label) {
                    enOption = JSON.parse(JSON.stringify(option));
                }
                if (!langOption || !langOption.label) {
                    langOption = JSON.parse(JSON.stringify(option));
                }
                const optionHtml = SmoTranslationEditor._getHtmlTextInput(option.value.toString(), enOption.label, langOption.label, 'component-option', option.value.toString());
                $(optionsHtml).append(optionHtml);
            });
        }
        $(container).append(compHtml);
    }
    static getDialogTranslationHtml(dialogCtor, enStrings, langStrings) {
        var b = htmlHelpers_1.buildDom;
        var container = b('div').classes('db-translate-container').attr('data-dbcontainer', dialogCtor)
            .append(b('button').classes('icon-plus trans-expander'))
            .append(b('span').classes('db-translate-title').text(dialogCtor)).dom();
        var ctor = eval('globalThis.Smo.' + dialogCtor);
        if (!ctor) {
            console.warn('Bad dialog in translate: ' + dialogCtor);
            return;
        }
        var elements = ctor.dialogElements;
        var enDb = enStrings.dialogs.find((dbStr) => dbStr.ctor === dialogCtor);
        if (!enDb) {
            enDb = JSON.parse(JSON.stringify({
                ctor: dialogCtor, label: elements.label, dialogElements: elements.elements, staticText: elements.staticText
            }));
        }
        var langDb = langStrings.dialogs.find((dbStr) => dbStr.ctor === dialogCtor);
        if (!langDb) {
            langDb = JSON.parse(JSON.stringify({
                ctor: dialogCtor, label: elements.label, dialogElements: elements.elements, staticText: elements.staticText
            }));
        }
        const htmlText = SmoTranslationEditor._getHtmlTextInput(dialogCtor, enDb.label, langDb.label, 'dialog-label', dialogCtor);
        $(container).append(htmlText);
        if (elements.staticText) {
            SmoTranslationEditor._getStaticTextDialogHtml(elements, enDb.staticText, langDb.staticText, container);
        }
        elements.elements.forEach((element) => {
            if (element.smoName && element.label) {
                SmoTranslationEditor._getDialogComponentHtml(element, enDb, langDb, container);
            }
        });
        return container;
    }
    static getAllTranslationHtml(lang) {
        const enStr = language_1.SmoLanguage.en.strings;
        const langStr = language_1.SmoLanguage[lang].strings;
        var b = htmlHelpers_1.buildDom;
        var container = b('div').classes('top-translate-container')
            .attr('dir', language_1.SmoLanguage[lang].dir).dom();
        language_1.SmoTranslator.allDialogs.forEach((dialog) => {
            const htmlDom = SmoTranslationEditor.getDialogTranslationHtml(dialog, enStr, langStr);
            if (htmlDom) {
                $(container).append(htmlDom);
            }
        });
        language_1.SmoTranslator.allMenus.forEach((menu) => {
            $(container).append(SmoTranslationEditor._getMenuTextDialogHtml(menu, enStr, langStr));
        });
        SmoTranslationEditor.getButtonTranslateHtml(enStr, langStr, container);
        var resultDom = b('div').classes('translation-json-container').append(b('textarea').classes('translation-json-text')).append(b('div').append(b('button').classes('translate-submit-button').text('Submit'))).dom();
        $(container).append(resultDom);
        return container;
    }
    static parseDom() {
        var json = [];
        // $('.top-translate-container .db-translate-container[data-dbcontainer] [data-component="staticText"]')
        $('.top-translate-container .db-translate-container[data-dbcontainer]').each((ix, dbEl) => {
            var db = $(dbEl).attr('data-dbcontainer');
            var obj = { ctor: db };
            var elements = [];
            var domComponents = $(dbEl).find('[data-component]');
            $(domComponents).each(function (ix, domComponent) {
                const compType = $(domComponent).attr('data-component');
                if (compType === 'staticText') {
                    var stElements = [];
                    $(domComponent).find('[data-statictext]').each((ix, stDom) => {
                        const key = $(stDom).attr('data-statictext');
                        const value = $(stDom).find('input.trans-label-input').val();
                        const stNode = JSON.parse('{"' + key + '":"' + value + '"}');
                        stElements.push(stNode);
                    });
                    elements.push({ staticText: stElements });
                }
                else {
                    var dbComponent = { id: compType, label: '', options: {} };
                    dbComponent.label = $(domComponent).find('input.trans-label-input').val();
                    var compOptions = [];
                    $(domComponent).find('[data-component-option]').each(function (ix, optionDom) {
                        const value = $(optionDom).find('.trans-db-text').text();
                        const label = $(optionDom).find('input.trans-label-input').val();
                        compOptions.push({ value: value, label: label });
                    });
                    dbComponent.options = compOptions;
                    elements.push(dbComponent);
                }
            });
            obj.dialogElements = elements;
            json.push(obj);
        });
        $('.menu-translate-container[data-menucontainer]').each((ix, menuEl) => {
            var menuId = $(menuEl).attr('data-menucontainer');
            var obj = { ctor: menuId, label: '', options: {}, menuItems: {} };
            const menuLabel = $(menuEl)
                .find('.dialog-element-container[data-menulabel] .trans-label-input')
                .val();
            obj.label = menuLabel;
            var menuItems = [];
            var itemsDom = $(menuEl).find('.menu-item-container .dialog-element-container');
            $(itemsDom).each((ix, itemDom) => {
                const value = $(itemDom).find('.trans-db-text').text();
                const text = $(itemDom).find('input.trans-label-input').val();
                menuItems.push({ value: value, text: text });
            });
            obj.menuItems = menuItems;
            json.push(obj);
        });
        var ribbonText = [];
        $('.ribbon-translate-container .ribbon-button-container').each((ix, buttonEl) => {
            const buttonId = $(buttonEl).find('.trans-db-text').text();
            const buttonText = $(buttonEl).find('input.trans-label-input').val();
            ribbonText.push({ buttonId: buttonId, buttonText: buttonText });
        });
        json.push({ ribbonText: ribbonText });
        return json;
    }
    static startEditor(lang) {
        (0, htmlHelpers_1.createTopDomContainer)('.translation-editor');
        var transDom = SmoTranslationEditor.getAllTranslationHtml(lang);
        $('.translation-editor').append(transDom);
        $('body').addClass('translation-mode');
        $('.plaintext-translate').each(function (ix, el) {
            var txt = $(el).text();
            $(el).closest('.trans-label').find('input.trans-label-input').val(txt);
        });
        $('.db-translate-container button.trans-expander').off('click').on('click', function (ev) {
            var exp = $(ev.target).closest('.db-translate-container');
            if ($(exp).hasClass('expanded')) {
                $(exp).removeClass('expanded');
                $(ev.target).removeClass('icon-minus');
                $(ev.target).addClass('icon-plus');
            }
            else {
                $(exp).addClass('expanded');
                $(ev.target).addClass('icon-minus');
                $(ev.target).removeClass('icon-plus');
            }
        });
        $('.menu-translate-container button.trans-expander').off('click').on('click', function (ev) {
            var exp = $(ev.target).closest('.menu-translate-container');
            if ($(exp).hasClass('expanded')) {
                $(exp).removeClass('expanded');
                $(ev.target).removeClass('icon-minus');
                $(ev.target).addClass('icon-plus');
            }
            else {
                $(exp).addClass('expanded');
                $(ev.target).addClass('icon-minus');
                $(ev.target).removeClass('icon-plus');
            }
        });
        $('.ribbon-translate-container button.trans-expander').off('click').on('click', function () {
            const dom = $('.ribbon-translate-container button.trans-expander');
            var exp = $(dom).closest('.ribbon-translate-container');
            if ($(exp).hasClass('expanded')) {
                $(exp).removeClass('expanded');
                $(dom).removeClass('icon-minus');
                $(dom).addClass('icon-plus');
            }
            else {
                $(exp).addClass('expanded');
                $(dom).addClass('icon-minus');
                $(dom).removeClass('icon-plus');
            }
        });
        $('.translate-submit-button').off('click').on('click', () => {
            var json = SmoTranslationEditor.parseDom();
            $('.translation-json-text').val(JSON.stringify(json, null, ' '));
        });
    }
}
exports.SmoTranslationEditor = SmoTranslationEditor;


/***/ }),

/***/ "./src/ui/keyBindings/default/editorKeys.ts":
/*!**************************************************!*\
  !*** ./src/ui/keyBindings/default/editorKeys.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.defaultEditorKeys = void 0;
class defaultEditorKeys {
    static get keys() {
        return [{
                event: "keydown",
                key: "=",
                ctrlKey: false,
                altKey: false,
                shiftKey: false,
                action: "transposeUp"
            }, {
                event: "keydown",
                key: "-",
                ctrlKey: false,
                altKey: false,
                shiftKey: false,
                action: "transposeDown"
            }, {
                event: "keydown",
                key: "+",
                ctrlKey: false,
                altKey: false,
                shiftKey: true,
                action: "upOctave"
            }, {
                event: "keydown",
                key: "_",
                ctrlKey: false,
                altKey: false,
                shiftKey: true,
                action: "downOctave"
            }, {
                event: "keydown",
                key: "F",
                ctrlKey: false,
                altKey: false,
                shiftKey: true,
                action: "toggleCourtesyAccidental"
            }, {
                event: "keydown",
                key: ".",
                ctrlKey: false,
                altKey: false,
                shiftKey: false,
                action: "doubleDuration"
            }, {
                event: "keydown",
                key: ",",
                ctrlKey: false,
                altKey: false,
                shiftKey: false,
                action: "halveDuration"
            }, {
                event: "keydown",
                key: ">",
                ctrlKey: false,
                altKey: false,
                shiftKey: true,
                action: "dotDuration"
            }, {
                event: "keydown",
                key: "<",
                ctrlKey: false,
                altKey: false,
                shiftKey: true,
                action: "undotDuration"
            }, {
                event: "keydown",
                key: "a",
                ctrlKey: false,
                altKey: false,
                shiftKey: false,
                action: "setPitch"
            }, {
                event: "keydown",
                key: "A",
                ctrlKey: false,
                altKey: false,
                shiftKey: true,
                action: "slashGraceNotes"
            }, {
                event: "keydown",
                key: "b",
                ctrlKey: false,
                altKey: false,
                shiftKey: false,
                action: "setPitch"
            }, {
                event: "keydown",
                key: "G",
                ctrlKey: false,
                altKey: false,
                shiftKey: true,
                action: "addGraceNote"
            }, {
                event: "keydown",
                key: "g",
                ctrlKey: false,
                altKey: true,
                shiftKey: false,
                action: "removeGraceNote"
            }, {
                event: "keydown",
                key: "c",
                ctrlKey: false,
                altKey: false,
                shiftKey: false,
                action: "setPitch"
            }, {
                event: "keydown",
                key: "d",
                ctrlKey: false,
                altKey: false,
                shiftKey: false,
                action: "setPitch"
            }, {
                event: "keydown",
                key: "e",
                ctrlKey: false,
                altKey: false,
                shiftKey: false,
                action: "setPitch"
            }, {
                event: "keydown",
                key: "f",
                ctrlKey: false,
                altKey: false,
                shiftKey: false,
                action: "setPitch"
            }, {
                event: "keydown",
                key: "g",
                ctrlKey: false,
                altKey: false,
                shiftKey: false,
                action: "setPitch"
            }, {
                event: "keydown",
                key: "r",
                ctrlKey: false,
                altKey: false,
                shiftKey: false,
                action: "makeRest"
            }, {
                event: "keydown",
                key: "r",
                ctrlKey: false,
                altKey: true,
                shiftKey: false,
                action: "rerender"
            }, {
                event: "keydown",
                key: "p",
                ctrlKey: false,
                altKey: false,
                shiftKey: false,
                action: "playScore"
            }, {
                event: "keydown",
                key: "P",
                ctrlKey: false,
                altKey: false,
                shiftKey: true,
                action: "pausePlayer"
            },
            {
                event: "keydown",
                key: "s",
                ctrlKey: false,
                altKey: false,
                shiftKey: false,
                action: "stopPlayer"
            }, {
                event: "keydown",
                key: "t",
                ctrlKey: false,
                altKey: false,
                shiftKey: false,
                action: "tempoDialog"
            },
            {
                event: "keydown",
                key: "3",
                ctrlKey: true,
                altKey: false,
                shiftKey: false,
                action: "makeTuplet"
            }, {
                event: "keydown",
                key: "5",
                ctrlKey: true,
                altKey: false,
                shiftKey: false,
                action: "makeTuplet"
            }, {
                event: "keydown",
                key: "7",
                ctrlKey: true,
                altKey: false,
                shiftKey: false,
                action: "makeTuplet"
            },
            // interval commands
            {
                event: "keydown",
                key: "2",
                ctrlKey: false,
                altKey: false,
                shiftKey: false,
                action: "interval"
            }, {
                event: "keydown",
                key: "3",
                ctrlKey: false,
                altKey: false,
                shiftKey: false,
                action: "interval"
            }, {
                event: "keydown",
                key: "4",
                ctrlKey: false,
                altKey: false,
                shiftKey: false,
                action: "interval"
            }, {
                event: "keydown",
                key: "5",
                ctrlKey: false,
                altKey: false,
                shiftKey: false,
                action: "interval"
            }, {
                event: "keydown",
                key: "6",
                ctrlKey: false,
                altKey: false,
                shiftKey: false,
                action: "interval"
            }, {
                event: "keydown",
                key: "7",
                ctrlKey: false,
                altKey: false,
                shiftKey: false,
                action: "interval"
            }, {
                event: "keydown",
                key: "8",
                ctrlKey: false,
                altKey: false,
                shiftKey: false,
                action: "interval"
            }, {
                event: "keydown",
                key: "@",
                ctrlKey: false,
                altKey: false,
                shiftKey: true,
                action: "interval"
            }, {
                event: "keydown",
                key: "$",
                ctrlKey: false,
                altKey: false,
                shiftKey: true,
                action: "interval"
            }, {
                event: "keydown",
                key: "#",
                ctrlKey: false,
                altKey: false,
                shiftKey: true,
                action: "interval"
            }, {
                event: "keydown",
                key: "%",
                ctrlKey: false,
                altKey: false,
                shiftKey: true,
                action: "interval"
            }, {
                event: "keydown",
                key: "^",
                ctrlKey: false,
                altKey: false,
                shiftKey: true,
                action: "interval"
            }, {
                event: "keydown",
                key: "&",
                ctrlKey: false,
                altKey: false,
                shiftKey: true,
                action: "interval"
            }, {
                event: "keydown",
                key: "*",
                ctrlKey: false,
                altKey: false,
                shiftKey: true,
                action: "interval"
            }, {
                event: "keydown",
                key: "8",
                ctrlKey: false,
                altKey: false,
                shiftKey: true,
                action: "interval"
            }, {
                event: "keydown",
                key: "0",
                ctrlKey: true,
                altKey: false,
                shiftKey: false,
                action: "unmakeTuplet"
            }, {
                event: "keydown",
                key: "Insert",
                ctrlKey: false,
                altKey: false,
                shiftKey: false,
                action: "addMeasure"
            }, {
                event: "keydown",
                key: "Insert",
                ctrlKey: false,
                altKey: false,
                shiftKey: true,
                action: "addMeasure"
            }, {
                event: "keydown",
                key: "i",
                ctrlKey: true,
                altKey: false,
                shiftKey: false,
                action: "addMeasure"
            }, {
                event: "keydown",
                key: "I",
                ctrlKey: true,
                altKey: false,
                shiftKey: true,
                action: "addMeasure"
            }, {
                event: "keydown",
                key: "B",
                ctrlKey: false,
                altKey: false,
                shiftKey: true,
                action: "toggleBeamDirection"
            }, {
                event: "keydown",
                key: "Delete",
                ctrlKey: false,
                altKey: false,
                shiftKey: false,
                action: "deleteNote"
            }, {
                event: "keydown",
                key: "d",
                ctrlKey: true,
                altKey: false,
                shiftKey: false,
                action: "deleteNote"
            }, {
                event: "keydown",
                key: "z",
                ctrlKey: true,
                altKey: false,
                shiftKey: false,
                action: "undo"
            }, {
                event: "keydown",
                key: "c",
                ctrlKey: true,
                altKey: false,
                shiftKey: false,
                action: "copy"
            }, {
                event: "keydown",
                key: "x",
                ctrlKey: false,
                altKey: false,
                shiftKey: false,
                action: "toggleBeamGroup"
            }, {
                event: "keydown",
                key: "X",
                ctrlKey: false,
                altKey: false,
                shiftKey: true,
                action: "beamSelections"
            }, {
                event: "keydown",
                key: "v",
                ctrlKey: true,
                altKey: false,
                shiftKey: false,
                action: "paste"
            }, {
                event: "keydown",
                key: "h",
                ctrlKey: false,
                altKey: false,
                shiftKey: false,
                action: "addRemoveAccent"
            }, {
                event: "keydown",
                key: "i",
                ctrlKey: false,
                altKey: false,
                shiftKey: false,
                action: "addRemoveTenuto"
            }, {
                event: "keydown",
                key: "j",
                ctrlKey: false,
                altKey: false,
                shiftKey: false,
                action: "addRemoveStaccato"
            }, {
                event: "keydown",
                key: "k",
                ctrlKey: false,
                altKey: false,
                shiftKey: false,
                action: "addRemoveMarcato"
            }, {
                event: "keydown",
                key: "l",
                ctrlKey: false,
                altKey: false,
                shiftKey: false,
                action: "addRemovePizzicato"
            }, {
                event: "keydown",
                key: "H",
                ctrlKey: false,
                altKey: false,
                shiftKey: true,
                action: "addRemoveAccent"
            }, {
                event: "keydown",
                key: "I",
                ctrlKey: false,
                altKey: false,
                shiftKey: true,
                action: "addRemoveTenuto"
            }, {
                event: "keydown",
                key: "J",
                ctrlKey: false,
                altKey: false,
                shiftKey: true,
                action: "addRemoveStaccato"
            }, {
                event: "keydown",
                key: "K",
                ctrlKey: false,
                altKey: false,
                shiftKey: true,
                action: "addRemoveMarcato"
            }, {
                event: "keydown",
                key: "L",
                ctrlKey: false,
                altKey: false,
                shiftKey: true,
                action: "addRemovePizzicato"
            }, {
                event: "keydown",
                key: "E",
                ctrlKey: false,
                altKey: false,
                shiftKey: true,
                action: "toggleEnharmonic"
            }
        ];
    }
}
exports.defaultEditorKeys = defaultEditorKeys;


/***/ }),

/***/ "./src/ui/keyBindings/default/trackerKeys.ts":
/*!***************************************************!*\
  !*** ./src/ui/keyBindings/default/trackerKeys.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.defaultTrackerKeys = void 0;
class defaultTrackerKeys {
    static get keys() {
        return [{
                event: "keydown",
                key: "Home",
                ctrlKey: false,
                altKey: false,
                shiftKey: false,
                action: "moveHome"
            }, {
                event: "keydown",
                key: "Home",
                ctrlKey: true,
                altKey: false,
                shiftKey: false,
                action: "moveHome"
            }, {
                event: "keydown",
                key: "Home",
                ctrlKey: false,
                altKey: false,
                shiftKey: true,
                action: "moveHome"
            }, {
                event: "keydown",
                key: "Home",
                ctrlKey: true,
                altKey: false,
                shiftKey: true,
                action: "moveHome"
            }, {
                event: "keydown",
                key: "End",
                ctrlKey: false,
                altKey: false,
                shiftKey: false,
                action: "moveEnd"
            }, {
                event: "keydown",
                key: "End",
                ctrlKey: false,
                altKey: false,
                shiftKey: true,
                action: "moveHome"
            }, {
                event: "keydown",
                key: "End",
                ctrlKey: true,
                altKey: false,
                shiftKey: false,
                action: "moveEnd"
            }, {
                event: "keydown",
                key: "End",
                ctrlKey: true,
                altKey: false,
                shiftKey: true,
                action: "moveEnd"
            }, {
                event: "keydown",
                key: "ArrowRight",
                ctrlKey: false,
                altKey: false,
                shiftKey: false,
                action: "moveSelectionRight"
            }, {
                event: "keydown",
                key: "ArrowRight",
                ctrlKey: false,
                altKey: true,
                shiftKey: false,
                action: "advanceModifierSelection"
            }, {
                event: "keydown",
                key: "ArrowLeft",
                ctrlKey: false,
                altKey: true,
                shiftKey: false,
                action: "advanceModifierSelection"
            }, {
                event: "keydown",
                key: "ArrowLeft",
                ctrlKey: false,
                altKey: false,
                shiftKey: false,
                action: "moveSelectionLeft"
            }, {
                event: "keydown",
                key: "ArrowRight",
                ctrlKey: false,
                altKey: false,
                shiftKey: true,
                action: "growSelectionRight"
            }, {
                event: "keydown",
                key: "ArrowRight",
                ctrlKey: true,
                altKey: false,
                shiftKey: true,
                action: "growSelectionRightMeasure"
            }, {
                event: "keydown",
                key: "ArrowLeft",
                ctrlKey: false,
                altKey: false,
                shiftKey: true,
                action: "growSelectionLeft"
            }, {
                event: "keydown",
                key: "ArrowUp",
                ctrlKey: false,
                altKey: false,
                shiftKey: false,
                action: "moveSelectionUp"
            }, {
                event: "keydown",
                key: "ArrowDown",
                ctrlKey: false,
                altKey: false,
                shiftKey: false,
                action: "moveSelectionDown"
            }, {
                event: "keydown",
                key: "ArrowRight",
                ctrlKey: true,
                altKey: false,
                shiftKey: false,
                action: "moveSelectionRightMeasure"
            }, {
                event: "keydown",
                key: "ArrowLeft",
                ctrlKey: true,
                altKey: false,
                shiftKey: false,
                action: "moveSelectionLeftMeasure"
            }, {
                event: "keydown",
                key: "ArrowUp",
                ctrlKey: false,
                altKey: false,
                shiftKey: true,
                action: "moveSelectionPitchUp"
            }, {
                event: "keydown",
                key: "ArrowDown",
                ctrlKey: false,
                altKey: false,
                shiftKey: true,
                action: "moveSelectionPitchDown"
            }
        ];
    }
}
exports.defaultTrackerKeys = defaultTrackerKeys;


/***/ }),

/***/ "./src/ui/menus/dynamics.ts":
/*!**********************************!*\
  !*** ./src/ui/menus/dynamics.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SuiDynamicsMenu = void 0;
const noteModifiers_1 = __webpack_require__(/*! ../../smo/data/noteModifiers */ "./src/smo/data/noteModifiers.ts");
const menu_1 = __webpack_require__(/*! ./menu */ "./src/ui/menus/menu.ts");
class SuiDynamicsMenu extends menu_1.SuiMenuBase {
    constructor(params) {
        super(params);
    }
    getDefinition() {
        return SuiDynamicsMenu.defaults;
    }
    selection(ev) {
        const text = $(ev.currentTarget).attr('data-value');
        const props = noteModifiers_1.SmoDynamicText.defaults;
        props.text = text;
        const dynamic = new noteModifiers_1.SmoDynamicText(props);
        this.view.addDynamic(this.tracker.selections[0], dynamic);
        this.complete();
    }
    keydown() { }
}
exports.SuiDynamicsMenu = SuiDynamicsMenu;
SuiDynamicsMenu.defaults = {
    label: 'Dynamics',
    menuItems: [{
            icon: 'pianissimo',
            text: 'Pianissimo',
            value: 'pp'
        }, {
            icon: 'piano',
            text: 'Piano',
            value: 'p'
        }, {
            icon: 'mezzopiano',
            text: 'Mezzo-piano',
            value: 'mp'
        }, {
            icon: 'mezzoforte',
            text: 'Mezzo-forte',
            value: 'mf'
        }, {
            icon: 'forte',
            text: 'Forte',
            value: 'f'
        }, {
            icon: 'fortissimo',
            text: 'Fortissimo',
            value: 'ff'
        }, {
            icon: 'sfz',
            text: 'sfortzando',
            value: 'sfz'
        }, {
            icon: '',
            text: 'Cancel',
            value: 'cancel'
        }]
};


/***/ }),

/***/ "./src/ui/menus/file.ts":
/*!******************************!*\
  !*** ./src/ui/menus/file.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SuiFileMenu = void 0;
const menu_1 = __webpack_require__(/*! ./menu */ "./src/ui/menus/menu.ts");
const dialog_1 = __webpack_require__(/*! ../dialogs/dialog */ "./src/ui/dialogs/dialog.ts");
const fileDialogs_1 = __webpack_require__(/*! ../dialogs/fileDialogs */ "./src/ui/dialogs/fileDialogs.ts");
const score_1 = __webpack_require__(/*! ../../smo/data/score */ "./src/smo/data/score.ts");
class SuiFileMenu extends menu_1.SuiMenuBase {
    constructor(params) {
        super(params);
    }
    getDefinition() {
        return SuiFileMenu.defaults;
    }
    systemPrint() {
        window.print();
        (0, dialog_1.createAndDisplayDialog)(fileDialogs_1.SuiPrintFileDialog, {
            ctor: 'SuiPrintFileDialog',
            id: 'print',
            eventSource: this.eventSource,
            modifier: null,
            view: this.view,
            completeNotifier: this.completeNotifier,
            startPromise: this.closePromise,
            tracker: this.tracker
        });
    }
    selection(ev) {
        const text = $(ev.currentTarget).attr('data-value');
        const self = this;
        if (text === 'saveFile') {
            (0, dialog_1.createAndDisplayDialog)(fileDialogs_1.SuiSaveFileDialog, {
                ctor: 'SuiSaveFileDialog',
                id: 'save',
                modifier: null,
                completeNotifier: this.completeNotifier,
                tracker: this.tracker,
                eventSource: this.eventSource,
                view: this.view,
                startPromise: this.closePromise
            });
        }
        else if (text === 'openFile') {
            (0, dialog_1.createAndDisplayDialog)(fileDialogs_1.SuiLoadFileDialog, {
                ctor: 'SuiLoadFileDialog',
                id: 'loadFile',
                modifier: null,
                completeNotifier: this.completeNotifier,
                tracker: this.tracker,
                eventSource: this.eventSource,
                view: this.view,
                startPromise: this.closePromise
            });
        }
        else if (text === 'newFile') {
            const score = score_1.SmoScore.getDefaultScore(score_1.SmoScore.defaults, null);
            this.view.changeScore(score);
        }
        else if (text === 'quickSave') {
            this.view.quickSave();
        }
        else if (text === 'printScore') {
            const systemPrint = () => {
                self.systemPrint();
            };
            this.view.renderer.renderForPrintPromise().then(systemPrint);
        }
        else if (text === 'exportXml') {
            (0, dialog_1.createAndDisplayDialog)(fileDialogs_1.SuiSaveXmlDialog, {
                ctor: 'SuiSaveXmlDialog',
                id: 'save',
                modifier: null,
                completeNotifier: this.completeNotifier,
                tracker: this.tracker,
                eventSource: this.eventSource,
                view: this.view,
                startPromise: this.closePromise
            });
        }
        else if (text === 'exportMidi') {
            (0, dialog_1.createAndDisplayDialog)(fileDialogs_1.SuiSaveMidiDialog, {
                ctor: 'SuiSaveMidiDialog',
                id: 'save',
                modifier: null,
                completeNotifier: this.completeNotifier,
                tracker: this.tracker,
                eventSource: this.eventSource,
                view: this.view,
                startPromise: this.closePromise
            });
        }
        else if (text === 'importMxml') {
            (0, dialog_1.createAndDisplayDialog)(fileDialogs_1.SuiLoadMxmlDialog, {
                ctor: 'SuiLoadMxmlDialog',
                id: 'save',
                modifier: null,
                completeNotifier: this.completeNotifier,
                tracker: this.tracker,
                eventSource: this.eventSource,
                view: this.view,
                startPromise: this.closePromise
            });
        }
        else if (text === 'importMidi') {
            (0, dialog_1.createAndDisplayDialog)(fileDialogs_1.SuiLoadMidiDialog, {
                ctor: 'SuiLoadMidiDialog',
                id: 'save',
                modifier: null,
                completeNotifier: this.completeNotifier,
                tracker: this.tracker,
                eventSource: this.eventSource,
                view: this.view,
                startPromise: this.closePromise
            });
        }
        this.complete();
    }
    keydown() { }
}
exports.SuiFileMenu = SuiFileMenu;
SuiFileMenu.defaults = {
    label: 'File',
    menuItems: [{
            icon: 'folder-new',
            text: 'New Score',
            value: 'newFile'
        }, {
            icon: 'folder-open',
            text: 'Open',
            value: 'openFile'
        }, {
            icon: '',
            text: 'Quick Save',
            value: 'quickSave'
        }, {
            icon: 'folder-save',
            text: 'Save',
            value: 'saveFile'
        }, {
            icon: '',
            text: 'Print',
            value: 'printScore'
        }, {
            icon: '',
            text: 'Import MusicXML',
            value: 'importMxml'
        }, {
            icon: '',
            text: 'Export MusicXML',
            value: 'exportXml'
        }, {
            icon: '',
            text: 'Export Midi',
            value: 'exportMidi'
        }, {
            icon: '',
            text: 'Import Midi',
            value: 'importMidi'
        }, {
            icon: '',
            text: 'Cancel',
            value: 'cancel'
        }]
};


/***/ }),

/***/ "./src/ui/menus/keySignature.ts":
/*!**************************************!*\
  !*** ./src/ui/menus/keySignature.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SuiKeySignatureMenu = void 0;
const menu_1 = __webpack_require__(/*! ./menu */ "./src/ui/menus/menu.ts");
class SuiKeySignatureMenu extends menu_1.SuiMenuBase {
    constructor(params) {
        super(params);
    }
    static get ctor() {
        return 'SuiKeySignatureMenu';
    }
    getDefinition() {
        return SuiKeySignatureMenu.defaults;
    }
    selection(ev) {
        let keySig = $(ev.currentTarget).attr('data-value');
        keySig = (keySig === 'cancel' ? keySig : keySig.substring(5, keySig.length));
        if (keySig === 'cancel') {
            return;
        }
        this.view.addKeySignature(keySig);
        this.complete();
    }
    keydown() { }
}
exports.SuiKeySignatureMenu = SuiKeySignatureMenu;
SuiKeySignatureMenu.defaults = {
    label: 'Key',
    menuItems: [{
            icon: 'key-sig-c',
            text: 'C Major',
            value: 'KeyOfC',
        }, {
            icon: 'key-sig-f',
            text: 'F Major',
            value: 'KeyOfF',
        }, {
            icon: 'key-sig-g',
            text: 'G Major',
            value: 'KeyOfG',
        }, {
            icon: 'key-sig-bb',
            text: 'Bb Major',
            value: 'KeyOfBb'
        }, {
            icon: 'key-sig-d',
            text: 'D Major',
            value: 'KeyOfD'
        }, {
            icon: 'key-sig-eb',
            text: 'Eb Major',
            value: 'KeyOfEb'
        }, {
            icon: 'key-sig-a',
            text: 'A Major',
            value: 'KeyOfA'
        }, {
            icon: 'key-sig-ab',
            text: 'Ab Major',
            value: 'KeyOfAb'
        }, {
            icon: 'key-sig-e',
            text: 'E Major',
            value: 'KeyOfE'
        }, {
            icon: 'key-sig-bd',
            text: 'Db Major',
            value: 'KeyOfDb'
        }, {
            icon: 'key-sig-b',
            text: 'B Major',
            value: 'KeyOfB'
        }, {
            icon: 'key-sig-fs',
            text: 'F# Major',
            value: 'KeyOfF#'
        }, {
            icon: 'key-sig-cs',
            text: 'C# Major',
            value: 'KeyOfC#'
        },
        {
            icon: '',
            text: 'Cancel',
            value: 'cancel'
        }]
};


/***/ }),

/***/ "./src/ui/menus/language.ts":
/*!**********************************!*\
  !*** ./src/ui/menus/language.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SuiLanguageMenu = void 0;
const menu_1 = __webpack_require__(/*! ./menu */ "./src/ui/menus/menu.ts");
const language_1 = __webpack_require__(/*! ../i18n/language */ "./src/ui/i18n/language.ts");
class SuiLanguageMenu extends menu_1.SuiMenuBase {
    constructor(params) {
        super(params);
    }
    static get ctor() {
        return 'SuiLanguageMenu';
    }
    getDefinition() {
        return SuiLanguageMenu.defaults;
    }
    selection(ev) {
        var op = $(ev.currentTarget).attr('data-value');
        language_1.SmoTranslator.setLanguage(op);
        this.complete();
    }
    keydown() {
    }
}
exports.SuiLanguageMenu = SuiLanguageMenu;
SuiLanguageMenu.defaults = {
    label: 'Language',
    menuItems: [{
            icon: '',
            text: 'English',
            value: 'en'
        }, {
            icon: '',
            text: 'Deutsch',
            value: 'de'
        }, {
            icon: '',
            text: '',
            value: 'ar'
        }, {
            icon: '',
            text: 'Cancel',
            value: 'cancel'
        }]
};


/***/ }),

/***/ "./src/ui/menus/manager.ts":
/*!*********************************!*\
  !*** ./src/ui/menus/manager.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SuiMenuManager = void 0;
// [Smoosic](https://github.com/AaronDavidNewman/Smoosic)
// Copyright (c) Aaron David Newman 2021.
const htmlHelpers_1 = __webpack_require__(/*! ../../common/htmlHelpers */ "./src/common/htmlHelpers.ts");
const layoutDebug_1 = __webpack_require__(/*! ../../render/sui/layoutDebug */ "./src/render/sui/layoutDebug.ts");
const qwerty_1 = __webpack_require__(/*! ../qwerty */ "./src/ui/qwerty.ts");
class SuiMenuManager {
    constructor(params) {
        var _a;
        this.bound = false;
        this.hotkeyBindings = {};
        this.closeMenuPromise = null;
        this.menu = null;
        this.keydownHandler = null;
        this.menuPosition = { x: 250, y: 40, width: 1, height: 1 };
        this.menuBind = SuiMenuManager.menuKeyBindingDefaults;
        this.eventSource = params.eventSource;
        this.view = params.view;
        this.bound = false;
        this.menuContainer = (_a = params.menuContainer) !== null && _a !== void 0 ? _a : (0, htmlHelpers_1.createTopDomContainer)('.menuContainer');
        this.completeNotifier = params.completeNotifier;
        this.undoBuffer = params.undoBuffer;
        this.tracker = params.view.tracker;
    }
    static get defaults() {
        return {
            menuBind: SuiMenuManager.menuKeyBindingDefaults,
            menuContainer: '.menuContainer'
        };
    }
    get closeModalPromise() {
        return this.closeMenuPromise;
    }
    setController(c) {
        this.completeNotifier = c;
    }
    get score() {
        return this.view.score;
    }
    // ### Description:
    // slash ('/') menu key bindings.  The slash key followed by another key brings up
    // a menu.
    static get menuKeyBindingDefaults() {
        return [
            {
                event: 'keydown',
                key: 'n',
                ctrlKey: false,
                altKey: false,
                shiftKey: false,
                action: 'SuiLanguageMenu'
            }, {
                event: 'keydown',
                key: 'k',
                ctrlKey: false,
                altKey: false,
                shiftKey: false,
                action: 'SuiKeySignatureMenu'
            }, {
                event: 'keydown',
                key: 'p',
                ctrlKey: false,
                altKey: false,
                shiftKey: false,
                action: 'SuiPartMenu'
            }, {
                event: 'keydown',
                key: 'l',
                ctrlKey: false,
                altKey: false,
                shiftKey: false,
                action: 'SuiStaffModifierMenu'
            }, {
                event: 'keydown',
                key: 'd',
                ctrlKey: false,
                altKey: false,
                shiftKey: false,
                action: 'SuiDynamicsMenu'
            }, {
                event: 'keydown',
                key: 'f',
                ctrlKey: false,
                altKey: false,
                shiftKey: false,
                action: 'SuiFileMenu'
            }, {
                event: 'keydown',
                key: 'm',
                ctrlKey: false,
                altKey: false,
                shiftKey: false,
                action: 'SuiTimeSignatureMenu'
            }, {
                event: 'keydown',
                key: 'a',
                ctrlKey: false,
                altKey: false,
                shiftKey: false,
                action: 'SuiMeasureMenu'
            }, {
                event: 'partSelection',
                key: '',
                ctrlKey: false,
                altKey: false,
                shiftKey: false,
                action: 'SuiPartSelectionMenu'
            }
        ];
    }
    _advanceSelection(inc) {
        if (!this.menu) {
            return;
        }
        const options = $('.menuContainer ul.menuElement li.menuOption');
        inc = inc < 0 ? options.length - 1 : 1;
        this.menu.focusIndex = (this.menu.focusIndex + inc) % options.length;
        $(options[this.menu.focusIndex]).find('button').focus();
    }
    unattach() {
        if (!this.keydownHandler) {
            return;
        }
        this.eventSource.unbindKeydownHandler(this.keydownHandler);
        $('body').removeClass('modal');
        $(this.menuContainer).html('');
        $('body').off('dismissMenu');
        this.bound = false;
        this.menu = null;
    }
    attach() {
        if (!this.menu) {
            return;
        }
        let hotkey = 0;
        $(this.menuContainer).html('');
        $(this.menuContainer).attr('z-index', '12');
        const b = htmlHelpers_1.buildDom;
        const r = b('ul').classes('menuElement').attr('size', this.menu.menuItems.length.toString())
            .css('left', '' + this.menuPosition.x + 'px')
            .css('top', '' + this.menuPosition.y + 'px');
        this.menu.menuItems.forEach((item) => {
            var vkey = (hotkey < 10) ? String.fromCharCode(48 + hotkey) :
                String.fromCharCode(87 + hotkey);
            r.append(b('li').classes('menuOption').append(b('button').attr('data-value', item.value).append(b('span').classes('menuText').text(item.text))
                .append(b('span').classes('icon icon-' + item.icon))
                .append(b('span').classes('menu-key').text('' + vkey))));
            item.hotkey = vkey;
            hotkey += 1;
        });
        $(this.menuContainer).append(r.dom());
        $('body').addClass('modal');
        this.bindEvents();
    }
    slashMenuMode(completeNotifier) {
        var self = this;
        if (this.closeMenuPromise) {
            console.log('menu already open, skipping');
            return;
        }
        this.bindEvents();
        layoutDebug_1.layoutDebug.addDialogDebug('slash menu creating closeMenuPromise');
        // A menu asserts this event when it is done.
        this.closeMenuPromise = new Promise((resolve) => {
            $('body').off('menuDismiss').on('menuDismiss', () => {
                layoutDebug_1.layoutDebug.addDialogDebug('menuDismiss received, resolve closeMenuPromise');
                self.unattach();
                $('body').removeClass('slash-menu');
                self.closeMenuPromise = null;
                resolve();
            });
        });
        // take over the keyboard
        if (this.closeModalPromise) {
            completeNotifier.unbindKeyboardForModal(this);
        }
    }
    dismiss() {
        $('body').trigger('menuDismiss');
    }
    displayMenu(menu) {
        this.menu = menu;
        if (!this.menu) {
            return;
        }
        this.menu.preAttach();
        this.attach();
        this.menu.menuItems.forEach((item) => {
            if (typeof (item.hotkey) !== 'undefined') {
                this.hotkeyBindings[item.hotkey] = item.value;
            }
        });
    }
    createMenu(action) {
        if (!this.completeNotifier) {
            return;
        }
        this.menuPosition = { x: 250, y: 40, width: 1, height: 1 };
        // If we were called from the ribbon, we notify the controller that we are
        // taking over the keyboard.  If this was a key-based command we already did.
        layoutDebug_1.layoutDebug.addDialogDebug('createMenu creating ' + action);
        const ctor = eval('globalThis.Smo.' + action);
        const params = {
            position: this.menuPosition,
            tracker: this.tracker,
            score: this.score,
            completeNotifier: this.completeNotifier,
            closePromise: this.closeMenuPromise,
            view: this.view,
            eventSource: this.eventSource,
            undoBuffer: this.undoBuffer,
            ctor: action
        };
        this.displayMenu(new ctor(params));
    }
    // ### evKey
    // We have taken over menu commands from controller.  If there is a menu active, send the key
    // to it.  If there is not, see if the keystroke creates one.  If neither, dismissi the menu.
    evKey(event) {
        qwerty_1.Qwerty.handleKeyEvent(event);
        if (['Tab', 'Enter'].indexOf(event.code) >= 0) {
            return;
        }
        event.preventDefault();
        if (event.code === 'Escape') {
            this.dismiss();
        }
        if (this.menu) {
            if (event.code === 'ArrowUp') {
                this._advanceSelection(-1);
            }
            else if (event.code === 'ArrowDown') {
                this._advanceSelection(1);
            }
            else if (this.hotkeyBindings[event.key]) {
                $('button[data-value="' + this.hotkeyBindings[event.key] + '"]').click();
            }
            else {
                this.menu.keydown();
            }
            return;
        }
        const binding = this.menuBind.find((ev) => ev.key === event.key);
        if (!binding) {
            this.dismiss();
            return;
        }
        this.createMenu(binding.action);
    }
    bindEvents() {
        this.hotkeyBindings = {};
        $('body').addClass('slash-menu');
        // We need to keep track of is bound, b/c the menu can be created from
        // different sources.
        if (!this.bound) {
            this.keydownHandler = this.eventSource.bindKeydownHandler(this, 'evKey');
            this.bound = true;
        }
        $(this.menuContainer).find('button').off('click').on('click', (ev) => {
            if ($(ev.currentTarget).attr('data-value') === 'cancel') {
                this.menu.complete();
                return;
            }
            this.menu.selection(ev);
        });
    }
}
exports.SuiMenuManager = SuiMenuManager;


/***/ }),

/***/ "./src/ui/menus/measure.ts":
/*!*********************************!*\
  !*** ./src/ui/menus/measure.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SuiMeasureMenu = void 0;
const menu_1 = __webpack_require__(/*! ./menu */ "./src/ui/menus/menu.ts");
const dialog_1 = __webpack_require__(/*! ../dialogs/dialog */ "./src/ui/dialogs/dialog.ts");
const addMeasure_1 = __webpack_require__(/*! ../dialogs/addMeasure */ "./src/ui/dialogs/addMeasure.ts");
const measureFormat_1 = __webpack_require__(/*! ../dialogs/measureFormat */ "./src/ui/dialogs/measureFormat.ts");
const measureModifiers_1 = __webpack_require__(/*! ../../smo/data/measureModifiers */ "./src/smo/data/measureModifiers.ts");
class SuiMeasureMenu extends menu_1.SuiMenuBase {
    constructor(params) {
        super(params);
    }
    getDefinition() {
        return SuiMeasureMenu.defaults;
    }
    selection(ev) {
        const text = $(ev.currentTarget).attr('data-value');
        if (text === 'formatMeasureDialog') {
            (0, dialog_1.createAndDisplayDialog)(measureFormat_1.SuiMeasureDialog, {
                view: this.view,
                completeNotifier: this.completeNotifier,
                startPromise: this.closePromise,
                eventSource: this.eventSource,
                tracker: this.tracker,
                ctor: 'SuiMeasureDialog',
                id: 'measure-dialog',
                modifier: null
            });
            this.complete();
            return;
        }
        if (text === 'addMenuCmd') {
            (0, dialog_1.createAndDisplayDialog)(addMeasure_1.SuiInsertMeasures, {
                view: this.view,
                completeNotifier: this.completeNotifier,
                startPromise: this.closePromise,
                eventSource: this.eventSource,
                tracker: this.tracker,
                ctor: 'SuiMeasureDialog',
                id: 'insert-dialog',
                modifier: null
            });
            this.complete();
        }
        if (text === 'addMenuAfterCmd') {
            this.view.addMeasure(true);
            this.complete();
        }
        if (text === 'deleteSelected') {
            this.view.deleteMeasure();
        }
        if (text === 'removeSystemBreaks') {
            this.view.removeSystemBreaks();
        }
        if (text === 'resetFormatting') {
            this.view.setMeasureFormat(new measureModifiers_1.SmoMeasureFormat(measureModifiers_1.SmoMeasureFormat.defaults));
        }
        this.complete();
    }
}
exports.SuiMeasureMenu = SuiMeasureMenu;
SuiMeasureMenu.defaults = {
    label: 'Measure',
    menuItems: [
        {
            icon: '',
            text: 'Add Measures',
            value: 'addMenuCmd'
        }, {
            icon: 'icon-cross',
            text: 'Delete Selected Measures',
            value: 'deleteSelected'
        }, {
            icon: '',
            text: 'Format Measure',
            value: 'formatMeasureDialog'
        }, {
            icon: '',
            text: 'Remove system breaks selection',
            value: 'removeSystemBreaks'
        }, {
            icon: '',
            text: 'Reset formatting selection',
            value: 'resetFormatting'
        }, {
            icon: '',
            text: 'Cancel',
            value: 'cancel'
        }
    ]
};


/***/ }),

/***/ "./src/ui/menus/menu.ts":
/*!******************************!*\
  !*** ./src/ui/menus/menu.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SuiMenuBase = void 0;
const language_1 = __webpack_require__(/*! ../i18n/language */ "./src/ui/i18n/language.ts");
class SuiMenuBase {
    constructor(params) {
        this.focusIndex = -1;
        this.ctor = params.ctor;
        const definition = this.getDefinition();
        this.label = definition.label;
        this.menuItems = definition.menuItems;
        this.completeNotifier = params.completeNotifier;
        this.score = params.score;
        this.view = params.view;
        this.undoBuffer = params.undoBuffer;
        this.eventSource = params.eventSource;
        this.closePromise = params.closePromise;
        this.tracker = params.tracker;
        language_1.SmoTranslator.registerMenu(this.ctor);
    }
    /**
     * Base class can override this, called before display and event binding to
     * add or remove options from the static list
     */
    preAttach() { }
    static printTranslate(_class) {
        const xx = eval('Smo.' + _class);
        const items = xx.defaults.menuItems;
        const rvItems = [];
        items.forEach((item) => {
            rvItems.push({ value: item.value, text: item.text, icon: '' });
        });
        return { ctor: _class, label: xx.defaults.label, menuItems: items };
    }
    complete() {
        $('body').trigger('menuDismiss');
    }
    // Most menus don't process their own events
    keydown() { }
}
exports.SuiMenuBase = SuiMenuBase;


/***/ }),

/***/ "./src/ui/menus/note.ts":
/*!******************************!*\
  !*** ./src/ui/menus/note.ts ***!
  \******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SuiNoteMenu = void 0;
const menu_1 = __webpack_require__(/*! ./menu */ "./src/ui/menus/menu.ts");
class SuiNoteMenu extends menu_1.SuiMenuBase {
    constructor(params) {
        super(params);
    }
    getDefinition() {
        return SuiNoteMenu.defaults;
    }
    selection(ev) {
        return __awaiter(this, void 0, void 0, function* () {
            const text = $(ev.currentTarget).attr('data-value');
            if (text === 'toggleCueCmd') {
                yield this.view.toggleCue();
            }
            this.complete();
        });
    }
}
exports.SuiNoteMenu = SuiNoteMenu;
SuiNoteMenu.defaults = {
    label: 'Measure',
    menuItems: [
        {
            icon: '',
            text: 'Toggle Cue',
            value: 'toggleCueCmd'
        }, {
            icon: '',
            text: 'Cancel',
            value: 'cancel'
        }
    ]
};


/***/ }),

/***/ "./src/ui/menus/partSelection.ts":
/*!***************************************!*\
  !*** ./src/ui/menus/partSelection.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SuiPartSelectionMenu = void 0;
const menu_1 = __webpack_require__(/*! ./menu */ "./src/ui/menus/menu.ts");
class SuiPartSelectionMenu extends menu_1.SuiMenuBase {
    constructor(params) {
        super(params);
        this.partMap = { keys: [], partMap: {} };
    }
    getDefinition() {
        return SuiPartSelectionMenu.defaults;
    }
    selectPart(val) {
        if (val < 0) {
            this.view.viewAll();
            this.complete();
            return;
        }
        const partInfo = this.partMap.partMap[val];
        this.view.exposePart(this.view.storeScore.staves[partInfo.associatedStaff]);
        this.complete();
    }
    preAttach() {
        const defs = [];
        this.partMap = this.view.getPartMap();
        if (this.view.score.staves.length < this.view.storeScore.staves.length) {
            defs.push({
                icon: '',
                text: 'View All',
                value: '-1'
            });
        }
        this.partMap.keys.forEach((key) => {
            defs.push({
                icon: '',
                text: this.partMap.partMap[key].partName,
                value: key.toString()
            });
        });
        defs.push({
            icon: '',
            text: 'Cancel',
            value: 'cancel'
        });
        this.menuItems = defs;
    }
    selection(ev) {
        const op = $(ev.currentTarget).attr('data-value');
        const choice = parseInt(op);
        if (isNaN(choice)) {
            this.complete(); // cancel
        }
        this.selectPart(choice);
    }
    keydown() { }
}
exports.SuiPartSelectionMenu = SuiPartSelectionMenu;
SuiPartSelectionMenu.defaults = {
    label: 'Parts',
    menuItems: [
        {
            icon: '',
            text: 'Cancel',
            value: 'cancel'
        }
    ]
};


/***/ }),

/***/ "./src/ui/menus/parts.ts":
/*!*******************************!*\
  !*** ./src/ui/menus/parts.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SuiPartMenu = void 0;
const menu_1 = __webpack_require__(/*! ./menu */ "./src/ui/menus/menu.ts");
const dialog_1 = __webpack_require__(/*! ../dialogs/dialog */ "./src/ui/dialogs/dialog.ts");
const scoreView_1 = __webpack_require__(/*! ../dialogs/scoreView */ "./src/ui/dialogs/scoreView.ts");
const instrument_1 = __webpack_require__(/*! ../dialogs/instrument */ "./src/ui/dialogs/instrument.ts");
const partInfo_1 = __webpack_require__(/*! ../dialogs/partInfo */ "./src/ui/dialogs/partInfo.ts");
const pageLayout_1 = __webpack_require__(/*! ../dialogs/pageLayout */ "./src/ui/dialogs/pageLayout.ts");
const newPart_1 = __webpack_require__(/*! ../dialogs/newPart */ "./src/ui/dialogs/newPart.ts");
class SuiPartMenu extends menu_1.SuiMenuBase {
    constructor(params) {
        super(params);
    }
    getDefinition() {
        return SuiPartMenu.defaults;
    }
    createPart() {
        (0, dialog_1.createAndDisplayDialog)(newPart_1.SuiNewPartDialog, {
            completeNotifier: this.completeNotifier,
            view: this.view,
            eventSource: this.eventSource,
            id: 'newPartDialog',
            ctor: 'SuiNewPartDialog',
            tracker: this.view.tracker,
            modifier: null,
            startPromise: this.closePromise
        });
    }
    execView() {
        (0, dialog_1.createAndDisplayDialog)(scoreView_1.SuiScoreViewDialog, {
            completeNotifier: this.completeNotifier,
            view: this.view,
            eventSource: this.eventSource,
            id: 'scoreViewDialog',
            ctor: 'SuiScoreViewDialog',
            tracker: this.view.tracker,
            modifier: null,
            startPromise: this.closePromise
        });
    }
    editPart() {
        const selection = this.view.tracker.selections[0];
        const self = this;
        if (this.view.score.staves.length !== selection.staff.partInfo.stavesAfter + selection.staff.partInfo.stavesBefore + 1) {
            this.view.exposePart(selection.staff);
        }
        this.view.renderPromise().then(() => {
            (0, dialog_1.createAndDisplayDialog)(partInfo_1.SuiPartInfoDialog, {
                completeNotifier: self.completeNotifier,
                view: self.view,
                eventSource: self.eventSource,
                id: 'editPart',
                ctor: 'SuiPartInfoDialog',
                tracker: self.view.tracker,
                modifier: null,
                startPromise: self.closePromise
            });
        });
    }
    editInstrument() {
        (0, dialog_1.createAndDisplayDialog)(instrument_1.SuiInstrumentDialog, {
            completeNotifier: this.completeNotifier,
            view: this.view,
            eventSource: this.eventSource,
            id: 'instrumentModal',
            ctor: 'SuiInstrumentDialog',
            tracker: this.view.tracker,
            modifier: null,
            startPromise: this.closePromise
        });
    }
    removePart() {
        this.view.removeStaff();
        this.complete();
    }
    pageLayout() {
        (0, dialog_1.createAndDisplayDialog)(pageLayout_1.SuiPageLayoutDialog, {
            completeNotifier: this.completeNotifier,
            view: this.view,
            eventSource: this.eventSource,
            id: 'layoutDialog',
            ctor: 'SuiPageLayoutDialog',
            tracker: this.view.tracker,
            modifier: null,
            startPromise: this.closePromise
        });
    }
    preAttach() {
        const fullScore = this.view.score.staves.length < this.view.storeScore.staves.length;
        const defs = [];
        this.menuItems.forEach((item) => {
            // Only show 'display all' if the full score is not already displayed
            if (item.value === 'viewAll') {
                if (!fullScore) {
                    defs.push(item);
                }
            }
            else if (item.value === 'pageLayout') {
                // only show the page layout in part menu if we are in part mode
                if (this.view.isPartExposed()) {
                    defs.push(item);
                }
            }
            else if (item.value === 'view') {
                if (this.view.isPartExposed() === false) {
                    // don't let the user restrict the view if we are already viewing a part.
                    defs.push(item);
                }
            }
            else if (item.value === 'editPart') {
                if (this.view.isPartExposed()) {
                    item.text = 'Part Properties';
                    defs.push(item);
                }
            }
            else {
                defs.push(item);
            }
        });
        this.menuItems = defs;
    }
    selection(ev) {
        const op = $(ev.currentTarget).attr('data-value');
        if (op === 'pageLayout') {
            this.pageLayout();
            this.complete();
        }
        else if (op === 'view') {
            this.execView();
            this.complete();
        }
        else if (op === 'createPart') {
            this.createPart();
            this.complete();
        }
        else if (op === 'removePart') {
            this.removePart();
            this.complete();
        }
        else if (op === 'editPart') {
            this.editPart();
            this.complete();
        }
        else if (op === 'editInstrument') {
            this.editInstrument();
            this.complete();
        }
        else if (op === 'cancel') {
            this.complete();
        }
        else if (op === 'viewAll') {
            this.view.viewAll();
            this.complete();
        }
    }
    keydown() { }
}
exports.SuiPartMenu = SuiPartMenu;
SuiPartMenu.defaults = {
    label: 'Parts',
    menuItems: [
        {
            icon: '',
            text: 'Create New Part/Stave',
            value: 'createPart'
        }, {
            icon: 'cancel-circle',
            text: 'Remove Selected Parts/Staves',
            value: 'removePart'
        }, {
            icon: '',
            text: 'Part Properties',
            value: 'editPart'
        }, {
            icon: '',
            text: 'Page Layout',
            value: 'pageLayout'
        }, {
            icon: '',
            text: 'View Partial Score',
            value: 'view'
        }, {
            icon: '',
            text: 'View All',
            value: 'viewAll'
        }, {
            icon: '',
            text: 'Instrument Properties',
            value: 'editInstrument'
        }, {
            icon: '',
            text: 'Cancel',
            value: 'cancel'
        }
    ]
};


/***/ }),

/***/ "./src/ui/menus/score.ts":
/*!*******************************!*\
  !*** ./src/ui/menus/score.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SuiScoreMenu = void 0;
const menu_1 = __webpack_require__(/*! ./menu */ "./src/ui/menus/menu.ts");
const preferences_1 = __webpack_require__(/*! ../dialogs/preferences */ "./src/ui/dialogs/preferences.ts");
const scoreId_1 = __webpack_require__(/*! ../dialogs/scoreId */ "./src/ui/dialogs/scoreId.ts");
const pageLayout_1 = __webpack_require__(/*! ../dialogs/pageLayout */ "./src/ui/dialogs/pageLayout.ts");
const fonts_1 = __webpack_require__(/*! ../dialogs/fonts */ "./src/ui/dialogs/fonts.ts");
const globalLayout_1 = __webpack_require__(/*! ../dialogs/globalLayout */ "./src/ui/dialogs/globalLayout.ts");
const dialog_1 = __webpack_require__(/*! ../dialogs/dialog */ "./src/ui/dialogs/dialog.ts");
const staffGroup_1 = __webpack_require__(/*! ../dialogs/staffGroup */ "./src/ui/dialogs/staffGroup.ts");
const audioSettings_1 = __webpack_require__(/*! ../dialogs/audioSettings */ "./src/ui/dialogs/audioSettings.ts");
class SuiScoreMenu extends menu_1.SuiMenuBase {
    constructor(params) {
        super(params);
    }
    getDefinition() {
        return SuiScoreMenu.defaults;
    }
    preAttach() {
        const defs = [];
        this.menuItems.forEach((item) => {
            // show these options no matter what
            if (['fonts', 'cancel', 'identification', 'preferences', 'audioSettings'].findIndex((x) => x === item.value) >= 0) {
                defs.push(item);
            }
            else if (item.value === 'pageLayout' || item.value === 'globalLayout' || item.value === 'staffGroups') {
                if (this.view.isPartExposed() === false) {
                    // only show the page layout in score menu if we are in score mode
                    defs.push(item);
                }
            }
            else if (item.value === 'viewAll') {
                // Only show 'view all' if we are not viewing all
                if (this.score.staves.length < this.view.storeScore.staves.length) {
                    defs.push(item);
                }
            }
        });
        this.menuItems = defs;
    }
    execStaffGroups() {
        (0, dialog_1.createAndDisplayDialog)(staffGroup_1.SuiStaffGroupDialog, {
            completeNotifier: this.completeNotifier,
            view: this.view,
            eventSource: this.eventSource,
            id: 'staffGroups',
            ctor: 'SuiStaffGroupDialog',
            tracker: this.view.tracker,
            modifier: null,
            startPromise: this.closePromise
        });
    }
    execScoreId() {
        scoreId_1.SuiScoreIdentificationDialog.createAndDisplay({
            completeNotifier: this.completeNotifier,
            view: this.view,
            eventSource: this.eventSource,
            id: 'scoreIdDialog',
            ctor: 'SuiScoreIdentificationDialog',
            tracker: this.view.tracker,
            modifier: null,
            startPromise: this.closePromise
        });
    }
    execPageLayout() {
        (0, dialog_1.createAndDisplayDialog)(pageLayout_1.SuiPageLayoutDialog, {
            completeNotifier: this.completeNotifier,
            view: this.view,
            eventSource: this.eventSource,
            id: 'layoutDialog',
            ctor: 'SuiPageLayoutDialog',
            tracker: this.view.tracker,
            modifier: null,
            startPromise: this.closePromise
        });
    }
    execFonts() {
        fonts_1.SuiScoreFontDialog.createAndDisplay({
            completeNotifier: this.completeNotifier,
            view: this.view,
            eventSource: this.eventSource,
            id: 'fontDialog',
            ctor: 'SuiScoreFontDialog',
            tracker: this.view.tracker,
            modifier: null,
            startPromise: this.closePromise
        });
    }
    execGlobalLayout() {
        (0, dialog_1.createAndDisplayDialog)(globalLayout_1.SuiGlobalLayoutDialog, {
            completeNotifier: this.completeNotifier,
            view: this.view,
            eventSource: this.eventSource,
            id: 'globalLayout',
            ctor: 'SuiGlobalLayoutDialog',
            tracker: this.view.tracker,
            modifier: null,
            startPromise: this.closePromise
        });
    }
    execPreferences() {
        (0, dialog_1.createAndDisplayDialog)(preferences_1.SuiScorePreferencesDialog, {
            completeNotifier: this.completeNotifier,
            view: this.view,
            eventSource: this.eventSource,
            id: 'preferences',
            ctor: 'SuiScorePreferencesDialog',
            tracker: this.view.tracker,
            modifier: null,
            startPromise: this.closePromise
        });
    }
    execAudioSettings() {
        (0, dialog_1.createAndDisplayDialog)(audioSettings_1.SuiAudioSettingsDialog, {
            completeNotifier: this.completeNotifier,
            view: this.view,
            eventSource: this.eventSource,
            id: 'audioSettings',
            ctor: 'SuiAudioSettingsDialog',
            tracker: this.view.tracker,
            modifier: null,
            startPromise: this.closePromise
        });
    }
    selection(ev) {
        const text = $(ev.currentTarget).attr('data-value');
        if (text === 'pageLayout') {
            this.execPageLayout();
        }
        else if (text === 'staffGroups') {
            this.execStaffGroups();
        }
        else if (text === 'preferences') {
            this.execPreferences();
        }
        else if (text === 'fonts') {
            this.execFonts();
        }
        else if (text === 'globalLayout') {
            this.execGlobalLayout();
        }
        else if (text === 'identification') {
            this.execScoreId();
        }
        else if (text === 'viewAll') {
            this.view.viewAll();
        }
        else if (text === 'audioSettings') {
            this.execAudioSettings();
        }
        this.complete();
    }
    keydown() { }
}
exports.SuiScoreMenu = SuiScoreMenu;
SuiScoreMenu.defaults = {
    label: 'Score Settings',
    menuItems: [{
            icon: '',
            text: 'Smoosic Preferences',
            value: 'preferences'
        }, {
            icon: '',
            text: 'View All',
            value: 'viewAll'
        }, {
            icon: '',
            text: 'Global Layout',
            value: 'globalLayout'
        }, {
            icon: '',
            text: 'Page Layout',
            value: 'pageLayout'
        }, {
            icon: '',
            text: 'Audio Settings',
            value: 'audioSettings'
        }, {
            icon: '',
            text: 'System Groups',
            value: 'staffGroups'
        }, {
            icon: '',
            text: 'Score Fonts',
            value: 'fonts'
        }, {
            icon: '',
            text: 'Score Info',
            value: 'identification'
        }, {
            icon: '',
            text: 'Cancel',
            value: 'cancel'
        }]
};


/***/ }),

/***/ "./src/ui/menus/staffModifier.ts":
/*!***************************************!*\
  !*** ./src/ui/menus/staffModifier.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SuiStaffModifierMenu = void 0;
const menu_1 = __webpack_require__(/*! ./menu */ "./src/ui/menus/menu.ts");
class SuiStaffModifierMenu extends menu_1.SuiMenuBase {
    constructor(params) {
        super(params);
    }
    getDefinition() {
        return SuiStaffModifierMenu.defaults;
    }
    selection(ev) {
        var op = $(ev.currentTarget).attr('data-value');
        if (op === 'ending') {
            this.view.addEnding();
        }
        else if (op === 'slur') {
            this.view.slur();
        }
        else if (op === 'tie') {
            this.view.tie();
        }
        else if (op === 'accel') {
            this.view.accelerando();
        }
        else if (op === 'dimenuendo') {
            this.view.dimenuendo();
        }
        else if (op === 'ritard') {
            this.view.ritard();
        }
        else if (op === 'crescendoBracket') {
            this.view.crescendoBracket();
        }
        else if (op === 'crescendo') {
            this.view.crescendo();
        }
        else if (op === 'decrescendo') {
            this.view.decrescendo();
        }
        else if (op === 'resetSlurs') {
            const self = this;
            this.view.refreshViewport().then(() => {
                self.complete();
            });
            return;
        }
        // else cancel...
        this.complete();
    }
    keydown() {
    }
}
exports.SuiStaffModifierMenu = SuiStaffModifierMenu;
SuiStaffModifierMenu.defaults = {
    label: 'Lines',
    menuItems: [{
            icon: 'cresc',
            text: 'Cresc. Hairpin',
            value: 'crescendo'
        }, {
            icon: 'decresc',
            text: 'Dim. Hairpin',
            value: 'decrescendo'
        }, {
            icon: 'slur',
            text: 'Slur',
            value: 'slur'
        }, {
            icon: 'slur',
            text: 'Tie',
            value: 'tie'
        }, {
            icon: 'ending',
            text: 'nth ending',
            value: 'ending'
        }, {
            icon: '',
            text: 'Dim. Bracket',
            value: 'dimenuendo'
        }, {
            icon: '',
            text: 'Cresc. Bracket',
            value: 'crescendoBracket'
        }, {
            icon: '',
            text: 'Accelerando',
            value: 'accel'
        }, {
            icon: '',
            text: 'Ritard',
            value: 'ritard'
        }, {
            icon: 'slur',
            text: 'Reset slurs',
            value: 'resetSlurs'
        }, {
            icon: '',
            text: 'Cancel',
            value: 'cancel'
        }]
};


/***/ }),

/***/ "./src/ui/menus/timeSignature.ts":
/*!***************************************!*\
  !*** ./src/ui/menus/timeSignature.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SuiTimeSignatureMenu = void 0;
// [Smoosic](https://github.com/AaronDavidNewman/Smoosic)
// Copyright (c) Aaron David Newman 2021.
const menu_1 = __webpack_require__(/*! ./menu */ "./src/ui/menus/menu.ts");
const measure_1 = __webpack_require__(/*! ../../smo/data/measure */ "./src/smo/data/measure.ts");
const dialog_1 = __webpack_require__(/*! ../dialogs/dialog */ "./src/ui/dialogs/dialog.ts");
const timeSignature_1 = __webpack_require__(/*! ../dialogs/timeSignature */ "./src/ui/dialogs/timeSignature.ts");
class SuiTimeSignatureMenu extends menu_1.SuiMenuBase {
    constructor(params) {
        super(params);
    }
    getDefinition() {
        return SuiTimeSignatureMenu.defaults;
    }
    selection(ev) {
        var text = $(ev.currentTarget).attr('data-value');
        if (text === 'TimeSigOther') {
            (0, dialog_1.createAndDisplayDialog)(timeSignature_1.SuiTimeSignatureDialog, {
                completeNotifier: this.completeNotifier,
                view: this.view,
                eventSource: this.eventSource,
                id: 'staffGroups',
                ctor: 'SuiStaffGroupDialog',
                tracker: this.view.tracker,
                modifier: null,
                startPromise: this.closePromise
            });
            this.complete();
            return;
        }
        this.view.setTimeSignature(measure_1.SmoMeasure.convertLegacyTimeSignature(text), '');
        this.complete();
    }
    keydown() { }
}
exports.SuiTimeSignatureMenu = SuiTimeSignatureMenu;
SuiTimeSignatureMenu.defaults = {
    label: 'Time Sig',
    menuItems: [{
            icon: 'sixeight',
            text: '6/8',
            value: '6/8',
        }, {
            icon: 'fourfour',
            text: '4/4',
            value: '4/4',
        }, {
            icon: 'threefour',
            text: '3/4',
            value: '3/4',
        }, {
            icon: 'twofour',
            text: '2/4',
            value: '2/4',
        }, {
            icon: 'twelveeight',
            text: '12/8',
            value: '12/8',
        }, {
            icon: 'seveneight',
            text: '7/8',
            value: '7/8',
        }, {
            icon: 'fiveeight',
            text: '5/8',
            value: '5/8',
        }, {
            icon: '',
            text: 'Other',
            value: 'TimeSigOther',
        }, {
            icon: '',
            text: 'Cancel',
            value: 'cancel'
        }]
};


/***/ }),

/***/ "./src/ui/qwerty.ts":
/*!**************************!*\
  !*** ./src/ui/qwerty.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Qwerty = void 0;
// [Smoosic](https://github.com/AaronDavidNewman/Smoosic)
// Copyright (c) Aaron David Newman 2021.
const htmlHelpers_1 = __webpack_require__(/*! ../common/htmlHelpers */ "./src/common/htmlHelpers.ts");
;
;
class Qwerty {
    static get navigationElements() {
        const kbRows = [
            { row: '1234567890-=', shifted: '!@#$%^&*()_+' },
            { row: 'QWERTYUIOP[]', shifted: 'QWERTYUIOP{}' },
            { row: "ASDFGHJKL;'", shifted: 'ASDFGHJKL:"' },
            { row: 'ZXCVBNM,./', shifted: 'ZXCVBNM<>?' }
        ];
        const arrows = [
            { icon: 'icon-arrow-left', text: '', shifted: '', classes: 'helpKey', dataKey: 'ArrowLeft' },
            { icon: 'icon-arrow-right', text: '', shifted: '', classes: 'helpKey', dataKey: 'ArrowRight' },
            { icon: '', text: 'Space', classes: 'wideKey', shifted: '', dataKey: 'Space' },
            { icon: 'icon-arrow-up', text: '', shifted: '', classes: 'helpKey', dataKey: 'ArrowUp' },
            { icon: 'icon-arrow-down', text: '', shifted: '', classes: 'helpKey', dataKey: 'ArrowDown' },
            { icon: '', text: 'Ins', shifted: '', classes: 'helpKey', dataKey: 'Insert' },
            { icon: '', text: 'Del', shifted: '', classes: 'helpKey', dataKey: 'Delete' },
            { icon: '', text: 'Enter', shifted: '', classes: 'wideKey', dataKey: 'Enter' }
        ];
        let keyRows = {};
        const labels = ['topNumbers', 'keys1', 'keys2', 'keys3', 'arrows'];
        let j = 0;
        kbRows.forEach((kbRow) => {
            var str = kbRow.row;
            var shifted = kbRow.shifted;
            var keys = [];
            for (var i = 0; i < str.length; ++i) {
                if (j === 2 && i === 0) {
                    keys.push({ icon: '', text: 'Shift', shifted: '', classes: 'wideKey', dataKey: 'shift' });
                }
                if (j === 3 && i === 0) {
                    keys.push({ icon: '', text: 'Ctrl', shifted: '', classes: 'wideKey', dataKey: 'ctrl' });
                    keys.push({ icon: '', text: 'Alt', shifted: '', classes: 'helpKey', dataKey: 'alt' });
                }
                keys.push({ icon: '', text: str[i], shifted: shifted[i], classes: 'helpKey', dataKey: str[i] });
            }
            keyRows[labels[j]] = keys;
            j += 1;
        });
        keyRows[labels[j]] = arrows;
        return keyRows;
    }
    static flashShift() {
        if (Qwerty._shiftTime) {
            Qwerty._shiftTime = 0;
            setTimeout(function () {
                Qwerty.flashShift();
            }, 1000);
        }
        else {
            $('.kb-float').removeClass('shifted');
        }
    }
    static displayForDuration() {
        Qwerty.displayAll();
        $('#row-0').hide();
        $('#row-1').hide();
        $('#row-4').hide();
    }
    static displayForTuplet() {
        Qwerty.displayAll();
        $('#row-1').hide();
        $('#row-2').hide();
    }
    static displayForNav() {
        Qwerty.displayAll();
        $('#row-0').hide();
        $('#row-1').hide();
    }
    static displayAll() {
        $('#row-0').show();
        $('#row-1').show();
        $('#row-2').show();
        $('#row-3').show();
        $('#row-4').show();
    }
    static _flashButton(key) {
        var e = $('[data-key="' + key + '"]');
        if (!e.length) {
            e = $('[data-shift="' + key + '"]');
        }
        if (e.length) {
            $(e).removeClass('transition-button');
            $(e).addClass('reverse-button');
            setTimeout(function () {
                $(e).removeClass('reverse-button');
                $(e).addClass('transition-button');
            }, 750);
        }
    }
    static get editingKeys() {
        return ['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown', 'Insert', 'Delete'];
    }
    static handleKeyEvent(evdata) {
        if (Qwerty.editingKeys.indexOf(evdata.code) >= 0) {
            Qwerty._flashButton(evdata.code);
        }
        else if (evdata.key.length === 1
            && evdata.key.charCodeAt(0) > 32
            && evdata.key.charCodeAt(0) < 127) {
            Qwerty._flashButton(evdata.key.toUpperCase());
        }
        if (evdata.code === 'Space') {
            Qwerty._flashButton('Space');
        }
        if (evdata.code === 'Enter') {
            Qwerty._flashButton('Enter');
        }
        if (evdata.ctrlKey) {
            Qwerty._flashButton('ctrl');
        }
        if (evdata.shiftKey) {
            Qwerty._flashButton('shift');
            $('.kb-float').addClass('shifted');
            Qwerty._shiftTime = 1;
            Qwerty.flashShift();
        }
        if (evdata.altKey) {
            Qwerty._flashButton('alt');
        }
    }
    static _kbButton(buttons) {
        var b = htmlHelpers_1.buildDom;
        var r = b('span').classes('keyContainer');
        buttons.forEach((button) => {
            var text = button.text;
            var shiftedText = button.shifted ? button.shifted : text;
            r.append(b('span').classes(button.icon + ' ' + button.classes)
                .attr('data-key', button.dataKey).attr('data-shift', shiftedText)
                .append(b('span').classes('button-text').text(text))
                .append(b('span').classes('button-shifted').text(shiftedText)));
        });
        return r;
    }
    static _buttonBlock(buttons, id) {
        var b = htmlHelpers_1.buildDom;
        var r = b('div').classes('keyBlock').attr('id', id);
        r.append(Qwerty._kbButton(buttons));
        return r;
    }
    static _buildElements(rows) {
        const b = htmlHelpers_1.buildDom;
        const r = b('div').classes('buttonLine')
            .append(b('span').classes('icon icon-move'));
        const keys = Object.keys(rows);
        keys.forEach((key, rowIx) => {
            const row = rows[key];
            r.append(Qwerty._buttonBlock(row, 'row-' + rowIx));
        });
        return r;
    }
    static hideKb() {
        $('body').removeClass('showQwerty');
        Qwerty.displayed = false;
    }
    static displayKb() {
        if (Qwerty.created) {
            $('body').addClass('showQwerty');
            Qwerty.displayed = true;
            return;
        }
        (0, htmlHelpers_1.createTopDomContainer)('.qwertyKb');
        $('body').addClass('showQwerty');
        $('.qwertyKb').html('');
        var b = htmlHelpers_1.buildDom;
        var r = b('div').classes('kb-float');
        r.append(Qwerty._buildElements(Qwerty.navigationElements));
        $('.qwertyKb').append(r.dom());
        var cb = function (x, y) { };
        (0, htmlHelpers_1.createTopDomContainer)('.draganime');
        (0, htmlHelpers_1.draggable)({
            parent: $('.qwertyKb'),
            handle: $('.qwertyKb').find('.icon-move'),
            animateDiv: '.draganime',
            cb: cb,
            moveParent: true
        });
        Qwerty.displayed = true;
        Qwerty.created = true;
    }
}
exports.Qwerty = Qwerty;
Qwerty._shiftTime = 0;
Qwerty.displayed = false;
Qwerty.created = false;


/***/ }),

/***/ "./src/ui/ribbonLayout/default/defaultRibbon.ts":
/*!******************************************************!*\
  !*** ./src/ui/ribbonLayout/default/defaultRibbon.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {


// [Smoosic](https://github.com/AaronDavidNewman/Smoosic)
// Copyright (c) Aaron David Newman 2021.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.defaultRibbonLayout = void 0;
class defaultRibbonLayout {
    static get ribbons() {
        var left = defaultRibbonLayout.leftRibbonIds;
        var top = defaultRibbonLayout.displayIds.concat(defaultRibbonLayout.noteButtonIds).concat(defaultRibbonLayout.navigateButtonIds)
            .concat(defaultRibbonLayout.articulateButtonIds).concat(defaultRibbonLayout.microtoneIds)
            .concat(defaultRibbonLayout.durationIds)
            .concat(defaultRibbonLayout.beamIds).concat(defaultRibbonLayout.measureIds)
            .concat(defaultRibbonLayout.staveIds)
            .concat(defaultRibbonLayout.textIds).concat(defaultRibbonLayout.playerIds)
            .concat(defaultRibbonLayout.voiceButtonIds).concat(defaultRibbonLayout.debugIds);
        return {
            left: left,
            top: top
        };
    }
    static get ribbonButtons() {
        return defaultRibbonLayout.leftRibbonButtons.concat(defaultRibbonLayout.navigationButtons).concat(defaultRibbonLayout.noteRibbonButtons).concat(defaultRibbonLayout.articulationButtons).concat(defaultRibbonLayout.microtoneButtons).concat(defaultRibbonLayout.chordButtons).concat(defaultRibbonLayout.durationRibbonButtons).concat(defaultRibbonLayout.beamRibbonButtons).concat(defaultRibbonLayout.measureRibbonButtons)
            .concat(defaultRibbonLayout.staveRibbonButtons)
            .concat(defaultRibbonLayout.textRibbonButtons).concat(defaultRibbonLayout.playerButtons)
            .concat(defaultRibbonLayout.voiceRibbonButtons).concat(defaultRibbonLayout.displayButtons).concat(defaultRibbonLayout.debugRibbonButtons);
    }
    static get leftRibbonIds() {
        return ['helpDialog', 'languageMenu', 'fileMenu', 'libraryMenu',
            'scoreMenu', 'partMenu', 'noteMenu', 'addStaffMenu', 'measureModal',
            'tempoModal', 'timeSignatureMenu', 'keyMenu', 'staffModifierMenu',
            'pianoModal'];
    }
    static get noteButtonIds() {
        return ['NoteButtons',
            'UpNoteButton', 'DownNoteButton', 'AddGraceNote', 'RemoveGraceNote', 'SlashGraceNote',
            'XNoteHead', 'TriUpNoteHead', 'CircleXNoteHead', 'DiamondNoteHead',
            'UpOctaveButton', 'DownOctaveButton', 'ToggleRestButton', 'ToggleSlashButton', 'ToggleAccidental', 'ToggleCourtesy'];
    }
    static get voiceButtonIds() {
        return ['VoiceButtons', 'V1Button', 'V2Button', 'V3Button', 'V4Button', 'VXButton'];
    }
    static get navigateButtonIds() {
        return ['NavigationButtons', 'navLeftButton', 'navRightButton', 'navUpButton', 'navDownButton', 'moreNavButtons', 'navFastForward', 'navRewind',
            'navGrowLeft', 'navGrowRight'];
    }
    static get articulateButtonIds() {
        return ['articulationButtons', 'accentButton', 'tenutoButton', 'staccatoButton', 'marcatoButton', 'fermataButton', 'pizzicatoButton', 'mordentButton', 'mordentInvertedButton', 'trillButton',
            'scoopButton', 'dropButton', 'dropLongButton', 'doitButton', 'doitLongButton', 'flipButton', 'smearButton'];
    }
    static get intervalIds() {
        return ['CreateChordButtons', 'SecondUpButton', 'SecondDownButton', 'ThirdUpButton', 'ThirdDownButton', 'FourthUpButton', 'FourthDownButton',
            'FifthUpButton', 'FifthDownButton', 'SixthUpButton', 'SixthDownButton',
            'SeventhUpButton', 'SeventhDownButton', 'OctaveUpButton', 'OctaveDownButton', 'CollapseChordButton'];
    }
    static get debugIds() {
        return ['DebugGroup', 'DebugButton2'];
    }
    static get durationIds() {
        return ['DurationButtons', 'GrowDuration', 'LessDuration', 'GrowDurationDot', 'LessDurationDot', 'TripletButton', 'QuintupletButton', 'SeptupletButton', 'NoTupletButton'];
    }
    static get measureIds() {
        return ['MeasureButtons', 'endRepeat', 'startRepeat', 'endBar', 'doubleBar', 'singleBarEnd', 'singleBarStart', 'nthEnding', 'dcAlCoda', 'dsAlCoda', 'dcAlFine', 'dsAlFine', 'coda', 'toCoda', 'segno', 'toSegno', 'fine'];
    }
    static get staveIds() {
        return ['StaveButtons', 'clefTreble', 'clefBass', 'clefAddRemove', 'clefMoveUp', 'clefMoveDown', 'moreStaffButtons',
            'clefTenor', 'clefAlto', 'clefPercussion',
            'staffBracketLower', 'staffBraceLower', 'staffDoubleConnectorLower', 'staffSingleConnectorLower'];
    }
    static get textIds() {
        return ['TextButtons', 'addTextMenu', 'rehearsalMark', 'lyrics', 'chordChanges', 'addDynamicsMenu'];
    }
    static get beamIds() {
        return ['BeamButtons', 'breakBeam', 'beamSelections', 'toggleBeamDirection'];
    }
    static get playerIds() {
        return ['playerButtons', 'playButton', 'pauseButton', 'stopButton'];
    }
    static get microtoneIds() {
        return ['MicrotoneButtons', 'flat75sz', 'flat25sz', 'flat25ar', 'flat125ar', 'sharp75', 'sharp125', 'sharp25', 'sori', 'koron'];
    }
    static get displayIds() {
        return ['quickButtons', 'selectPart', 'refresh', 'zoomout', 'zoomin', 'playButton2', 'stopButton2'];
    }
    static get textRibbonButtons() {
        return [
            {
                leftText: '',
                rightText: '',
                classes: 'icon  collapseParent measure',
                icon: 'icon-text',
                action: 'collapseParent',
                ctor: 'CollapseRibbonControl',
                group: 'textEdit',
                id: 'TextButtons'
            }, {
                leftText: '',
                rightText: '/t',
                classes: 'icon collapsed textButton',
                icon: 'icon-textBasic',
                action: 'collapseChild',
                ctor: 'TextButtons',
                group: 'textEdit',
                id: 'addTextMenu'
            }, {
                leftText: '',
                rightText: '',
                classes: 'icon collapsed textButton',
                icon: 'icon-rehearsemark',
                action: 'collapseChild',
                ctor: 'TextButtons',
                group: 'textEdit',
                id: 'rehearsalMark'
            }, {
                leftText: '',
                rightText: '',
                classes: 'icon collapsed textButton',
                icon: 'icon-lyric',
                action: 'collapseChild',
                ctor: 'TextButtons',
                group: 'textEdit',
                id: 'lyrics'
            }, {
                leftText: '',
                rightText: '',
                classes: 'icon collapsed textButton',
                icon: 'icon-chordSymbol',
                action: 'collapseChild',
                ctor: 'TextButtons',
                group: 'textEdit',
                id: 'chordChanges'
            }, {
                leftText: '',
                rightText: '/d',
                classes: 'icon collapsed textButton',
                icon: 'icon-mezzopiano',
                action: 'collapseChild',
                ctor: 'TextButtons',
                group: 'textEdit',
                id: 'addDynamicsMenu'
            }
        ];
    }
    static get displayButtons() {
        return [{
                leftText: '',
                rightText: '',
                classes: 'icon  hide',
                icon: 'icon-zoomplus',
                action: 'collapseParent',
                ctor: 'CollapseRibbonControl',
                group: 'quickButtons',
                id: 'quickButtons'
            }, {
                leftText: '',
                rightText: 'Select Part',
                classes: 'icon select-part-button',
                icon: 'icon-circle-down',
                action: 'collapseChild',
                ctor: 'DisplaySettings',
                group: 'quickButtons',
                id: 'selectPart'
            }, {
                leftText: '',
                rightText: '',
                classes: 'icon   refresh',
                icon: 'icon-refresh',
                action: 'collapseChild',
                ctor: 'DisplaySettings',
                group: 'quickButtons',
                id: 'refresh'
            }, {
                leftText: '',
                rightText: '',
                classes: 'icon   refresh',
                icon: 'icon-zoomplus',
                action: 'collapseChild',
                ctor: 'DisplaySettings',
                group: 'quickButtons',
                id: 'zoomout'
            }, {
                leftText: '',
                rightText: '',
                classes: 'icon   refresh',
                icon: 'icon-zoomminus',
                action: 'collapseChild',
                ctor: 'DisplaySettings',
                group: 'quickButtons',
                id: 'zoomin'
            }, {
                leftText: '',
                rightText: '',
                classes: 'icon   play',
                icon: 'icon-play3',
                action: 'collapseChild',
                ctor: 'DisplaySettings',
                group: 'quickButtons',
                id: 'playButton2'
            }, {
                leftText: '',
                rightText: '',
                classes: 'icon   stop2',
                icon: 'icon-stop2',
                action: 'collapseChild',
                ctor: 'DisplaySettings',
                group: 'quickButtons',
                id: 'stopButton2'
            }
        ];
    }
    static get microtoneButtons() {
        return [{
                leftText: '',
                rightText: '',
                classes: 'icon  collapseParent microtones',
                icon: 'icon-microtone',
                action: 'collapseParent',
                ctor: 'CollapseRibbonControl',
                group: 'microtone',
                id: 'MicrotoneButtons'
            }, {
                leftText: '',
                rightText: '',
                classes: 'icon  collapsed microtones',
                icon: 'icon-flat25sz',
                action: 'collapseChild',
                ctor: 'MicrotoneButtons',
                group: 'microtone',
                id: 'flat25sz'
            }, {
                leftText: '',
                rightText: '',
                classes: 'icon  collapsed microtones',
                icon: 'icon-flat75sz',
                action: 'collapseChild',
                ctor: 'MicrotoneButtons',
                group: 'microtone',
                id: 'flat75sz'
            }, {
                leftText: '',
                rightText: '',
                classes: 'icon  collapsed microtones',
                icon: 'icon-flat25ar',
                action: 'collapseChild',
                ctor: 'MicrotoneButtons',
                group: 'microtone',
                id: 'flat25ar'
            }, {
                leftText: '',
                rightText: '',
                classes: 'icon  collapsed microtones',
                icon: 'icon-sharp75',
                action: 'collapseChild',
                ctor: 'MicrotoneButtons',
                group: 'microtone',
                id: 'sharp75'
            }, {
                leftText: '',
                rightText: '',
                classes: 'icon  collapsed microtones',
                icon: 'icon-sharp125',
                action: 'collapseChild',
                ctor: 'MicrotoneButtons',
                group: 'microtone',
                id: 'sharp125'
            }, {
                leftText: '',
                rightText: '',
                classes: 'icon  collapsed microtones',
                icon: 'icon-sharp25',
                action: 'collapseChild',
                ctor: 'MicrotoneButtons',
                group: 'microtone',
                id: 'sharp25'
            }, {
                leftText: '',
                rightText: '',
                classes: 'icon  collapsed microtones',
                icon: 'icon-sori',
                action: 'collapseChild',
                ctor: 'MicrotoneButtons',
                group: 'microtone',
                id: 'sori'
            }, {
                leftText: '',
                rightText: '',
                classes: 'icon  collapsed microtones',
                icon: 'icon-koron',
                action: 'collapseChild',
                ctor: 'MicrotoneButtons',
                group: 'microtone',
                id: 'koron'
            }];
    }
    static get staveRibbonButtons() {
        return [{
                leftText: '',
                rightText: '',
                classes: 'icon  collapseParent staves',
                icon: 'icon-treble',
                action: 'collapseParent',
                ctor: 'CollapseRibbonControl',
                group: 'staves',
                id: 'StaveButtons'
            }, {
                leftText: '',
                rightText: '',
                classes: 'icon  collapsed staves',
                icon: 'icon-treble',
                action: 'collapseChild',
                ctor: 'StaveButtons',
                group: 'staves',
                id: 'clefTreble'
            }, {
                leftText: '',
                rightText: '',
                classes: 'icon  collapsed staves',
                icon: 'icon-bass',
                action: 'collapseChild',
                ctor: 'StaveButtons',
                group: 'staves',
                id: 'clefBass'
            },
            {
                leftText: '',
                rightText: '',
                classes: 'icon  collapsed staves',
                icon: 'icon-arrow-up',
                action: 'collapseChild',
                ctor: 'StaveButtons',
                group: 'staves',
                id: 'clefMoveUp'
            }, {
                leftText: '',
                rightText: '',
                classes: 'icon  collapsed staves',
                icon: 'icon-arrow-down',
                action: 'collapseChild',
                ctor: 'StaveButtons',
                group: 'staves',
                id: 'clefMoveDown'
            },
            {
                leftText: '...',
                rightText: '',
                icon: 'icon-circle-left',
                classes: 'collapsed expander',
                action: 'collapseMore',
                ctor: 'ExtendedCollapseParent',
                group: 'staves',
                id: 'moreStaffButtons'
            }, {
                leftText: '',
                rightText: '',
                classes: 'icon  collapsed staves',
                icon: 'icon-tenor',
                action: 'collapseGrandchild',
                ctor: 'StaveButtons',
                group: 'staves',
                id: 'clefTenor'
            }, {
                leftText: '',
                rightText: '',
                classes: 'icon  collapsed staves',
                icon: 'icon-alto',
                action: 'collapseGrandchild',
                ctor: 'StaveButtons',
                group: 'staves',
                id: 'clefAlto'
            }, {
                leftText: '',
                rightText: '',
                classes: 'icon  collapsed staves',
                icon: 'icon-percussion',
                action: 'collapseGrandchild',
                ctor: 'StaveButtons',
                group: 'staves',
                id: 'clefPercussion'
            }, {
                leftText: '',
                rightText: '',
                classes: 'icon  collapsed staves',
                icon: 'icon-brace',
                action: 'collapseGrandchild',
                ctor: 'StaveButtons',
                group: 'staves',
                id: 'staffBraceLower'
            }, {
                leftText: '',
                rightText: '',
                classes: 'icon  collapsed staves',
                icon: 'icon-bracket',
                action: 'collapseGrandchild',
                ctor: 'StaveButtons',
                group: 'staves',
                id: 'staffBracketLower'
            }
        ];
    }
    static get beamRibbonButtons() {
        return [{
                leftText: '',
                rightText: '',
                classes: 'icon  collapseParent beams',
                icon: 'icon-flag',
                action: 'collapseParent',
                ctor: 'CollapseRibbonControl',
                group: 'beams',
                id: 'BeamButtons'
            }, {
                leftText: '',
                rightText: 'x',
                icon: 'icon-beamBreak',
                classes: 'collapsed beams',
                action: 'collapseChild',
                ctor: 'BeamButtons',
                group: 'beams',
                id: 'breakBeam'
            },
            {
                leftText: '',
                rightText: 'Shift-X',
                icon: 'icon-beam',
                classes: 'collapsed beams',
                action: 'collapseChild',
                ctor: 'BeamButtons',
                group: 'beams',
                id: 'beamSelections'
            },
            {
                leftText: '',
                rightText: 'Shift-B',
                icon: 'icon-flagFlip',
                classes: 'collapsed beams',
                action: 'collapseChild',
                ctor: 'BeamButtons',
                group: 'beams',
                id: 'toggleBeamDirection'
            }
        ];
    }
    static get measureRibbonButtons() {
        return [{
                leftText: '',
                rightText: '',
                classes: 'icon  collapseParent measure',
                icon: 'icon-end_rpt',
                action: 'collapseParent',
                ctor: 'CollapseRibbonControl',
                group: 'measure',
                id: 'MeasureButtons'
            }, {
                leftText: '',
                rightText: '',
                icon: 'icon-end_rpt',
                classes: 'collapsed duration',
                action: 'collapseChild',
                ctor: 'MeasureButtons',
                group: 'measure',
                id: 'endRepeat'
            },
            {
                leftText: '',
                rightText: '',
                icon: 'icon-start_rpt',
                classes: 'collapsed duration',
                action: 'collapseChild',
                ctor: 'MeasureButtons',
                group: 'measure',
                id: 'startRepeat'
            },
            {
                leftText: '',
                rightText: '',
                icon: 'icon-end_bar',
                classes: 'collapsed duration',
                action: 'collapseChild',
                ctor: 'MeasureButtons',
                group: 'measure',
                id: 'endBar'
            },
            {
                leftText: '',
                rightText: '',
                icon: 'icon-double_bar',
                classes: 'collapsed duration',
                action: 'collapseChild',
                ctor: 'MeasureButtons',
                group: 'measure',
                id: 'doubleBar'
            },
            {
                leftText: '',
                rightText: '',
                icon: 'icon-single_bar',
                classes: 'collapsed duration',
                action: 'collapseChild',
                ctor: 'MeasureButtons',
                group: 'measure',
                id: 'singleBarEnd'
            },
            {
                leftText: '',
                rightText: '',
                icon: 'icon-single_bar_start',
                classes: 'collapsed duration',
                action: 'collapseChild',
                ctor: 'MeasureButtons',
                group: 'measure',
                id: 'singleBarStart'
            },
            {
                leftText: '',
                rightText: '',
                icon: 'icon-ending',
                classes: 'collapsed duration',
                action: 'collapseChild',
                ctor: 'MeasureButtons',
                group: 'measure',
                id: 'nthEnding'
            },
            {
                leftText: 'DC Al Coda',
                rightText: '',
                icon: '',
                classes: 'collapsed repetext',
                action: 'collapseChild',
                ctor: 'MeasureButtons',
                group: 'measure',
                id: 'dcAlCoda'
            },
            {
                leftText: 'DS Al Coda',
                rightText: '',
                icon: '',
                classes: 'collapsed repetext',
                action: 'collapseChild',
                ctor: 'MeasureButtons',
                group: 'measure',
                id: 'dsAlCoda'
            },
            {
                leftText: 'DC Al Fine',
                rightText: '',
                icon: '',
                classes: 'collapsed repetext',
                action: 'collapseChild',
                ctor: 'MeasureButtons',
                group: 'measure',
                id: 'dcAlFine'
            },
            {
                leftText: 'DS Al Fine',
                rightText: '',
                icon: '',
                classes: 'collapsed repetext',
                action: 'collapseChild',
                ctor: 'MeasureButtons',
                group: 'measure',
                id: 'dsAlFine'
            },
            {
                leftText: '',
                rightText: '',
                icon: 'icon-coda',
                classes: 'collapsed duration',
                action: 'collapseChild',
                ctor: 'MeasureButtons',
                group: 'measure',
                id: 'coda'
            },
            {
                leftText: 'to ',
                rightText: '',
                icon: 'icon-coda',
                classes: 'collapsed duration',
                action: 'collapseChild',
                ctor: 'MeasureButtons',
                group: 'measure',
                id: 'toCoda'
            },
            {
                leftText: '',
                rightText: '',
                icon: 'icon-segno',
                classes: 'collapsed duration',
                action: 'collapseChild',
                ctor: 'MeasureButtons',
                group: 'measure',
                id: 'segno'
            },
            {
                leftText: 'Fine',
                rightText: '',
                icon: '',
                classes: 'collapsed repetext',
                action: 'collapseChild',
                ctor: 'MeasureButtons',
                group: 'measure',
                id: 'fine'
            }
        ];
    }
    static get debugRibbonButtons() {
        return [{
                leftText: '',
                rightText: '',
                classes: 'icon  collapseParent',
                icon: 'icon-new-tab',
                action: 'collapseParent',
                ctor: 'CollapseRibbonControl',
                group: 'debug',
                id: 'DebugGroup'
            }, {
                leftText: '',
                rightText: '',
                classes: 'icon  collapsed',
                icon: 'icon-new-tab',
                action: 'collapseChild',
                ctor: 'DebugButtons',
                group: 'debug',
                id: 'DebugButton2'
            }];
    }
    static get durationRibbonButtons() {
        return [{
                leftText: '',
                rightText: '',
                classes: 'icon  collapseParent duration',
                icon: 'icon-duration',
                action: 'collapseParent',
                ctor: 'CollapseRibbonControl',
                group: 'duration',
                id: 'DurationButtons'
            }, {
                leftText: '',
                rightText: '.',
                icon: 'icon-duration_grow',
                classes: 'collapsed duration',
                action: 'collapseChild',
                ctor: 'DurationButtons',
                group: 'duration',
                id: 'GrowDuration'
            }, {
                leftText: '',
                rightText: ',',
                icon: 'icon-duration_less',
                classes: 'collapsed duration',
                action: 'collapseChild',
                ctor: 'DurationButtons',
                group: 'duration',
                id: 'LessDuration'
            }, {
                leftText: '',
                rightText: '>',
                icon: 'icon-duration_grow_dot',
                classes: 'collapsed duration',
                action: 'collapseChild',
                ctor: 'DurationButtons',
                group: 'duration',
                id: 'GrowDurationDot'
            }, {
                leftText: '',
                rightText: '<',
                icon: 'icon-duration_less_dot',
                classes: 'collapsed duration',
                action: 'collapseChild',
                ctor: 'DurationButtons',
                group: 'duration',
                id: 'LessDurationDot'
            }, {
                leftText: '',
                rightText: 'Ctrl-3',
                icon: 'icon-triplet',
                classes: 'collapsed duration tuplet',
                action: 'collapseChild',
                ctor: 'DurationButtons',
                group: 'duration',
                id: 'TripletButton'
            }, {
                leftText: '',
                rightText: 'Ctrl-5',
                icon: 'icon-quint',
                classes: 'collapsed duration tuplet',
                action: 'collapseChild',
                ctor: 'DurationButtons',
                group: 'duration',
                id: 'QuintupletButton'
            }, {
                leftText: '',
                rightText: 'Ctrl-7',
                icon: 'icon-septuplet',
                classes: 'collapsed duration tuplet',
                action: 'collapseChild',
                ctor: 'DurationButtons',
                group: 'duration',
                id: 'SeptupletButton'
            },
            {
                leftText: '',
                rightText: 'Ctrl-0',
                icon: 'icon-no_tuplet',
                classes: 'collapsed duration tuplet',
                action: 'collapseChild',
                ctor: 'DurationButtons',
                group: 'duration',
                id: 'NoTupletButton'
            }
        ];
    }
    static get voiceRibbonButtons() {
        return [{
                leftText: '',
                rightText: '',
                classes: 'icon  collapseParent',
                icon: 'icon-Vo',
                action: 'collapseParent',
                ctor: 'CollapseRibbonControl',
                group: 'voices',
                id: 'VoiceButtons'
            }, {
                leftText: '',
                rightText: '',
                icon: 'icon-V1',
                classes: 'collapsed',
                action: 'collapseChild',
                ctor: 'VoiceButtons',
                group: 'voices',
                id: 'V1Button'
            }, {
                leftText: '',
                rightText: '',
                icon: 'icon-V2',
                classes: 'collapsed',
                action: 'collapseChild',
                ctor: 'VoiceButtons',
                group: 'voices',
                id: 'V2Button'
            }, {
                leftText: '',
                rightText: '',
                icon: 'icon-V3',
                classes: 'collapsed',
                action: 'collapseChild',
                ctor: 'VoiceButtons',
                group: 'voices',
                id: 'V3Button'
            }, {
                leftText: '',
                rightText: '',
                icon: 'icon-V4',
                classes: 'collapsed',
                action: 'collapseChild',
                ctor: 'VoiceButtons',
                group: 'voices',
                id: 'V4Button'
            }, {
                leftText: '',
                rightText: '',
                icon: 'icon-Vx',
                classes: 'collapsed',
                action: 'collapseChild',
                ctor: 'VoiceButtons',
                group: 'voices',
                id: 'VXButton'
            }
        ];
    }
    static get noteRibbonButtons() {
        return [{
                leftText: '',
                rightText: '',
                classes: 'icon  collapseParent',
                icon: 'icon-note',
                action: 'collapseParent',
                ctor: 'CollapseRibbonControl',
                group: 'notes',
                id: 'NoteButtons'
            }, {
                leftText: 'A',
                rightText: 'a',
                icon: '',
                classes: 'collapsed',
                action: 'collapseChild',
                ctor: 'NoteButtons',
                group: 'notes',
                id: 'ANoteButton'
            }, {
                leftText: 'B',
                rightText: 'b',
                icon: '',
                classes: 'collapsed',
                action: 'collapseChild',
                ctor: 'NoteButtons',
                group: 'notes',
                id: 'BNoteButton'
            }, {
                leftText: 'C',
                rightText: 'c',
                icon: '',
                classes: 'collapsed',
                action: 'collapseChild',
                ctor: 'NoteButtons',
                group: 'notes',
                id: 'CNoteButton'
            }, {
                leftText: 'D',
                rightText: 'd',
                icon: '',
                classes: 'collapsed',
                action: 'collapseChild',
                ctor: 'NoteButtons',
                group: 'notes',
                id: 'DNoteButton'
            }, {
                leftText: 'E',
                rightText: 'e',
                icon: '',
                classes: 'collapsed',
                action: 'collapseChild',
                ctor: 'NoteButtons',
                group: 'notes',
                id: 'ENoteButton'
            }, {
                leftText: 'F',
                rightText: 'f',
                icon: '',
                classes: 'collapsed',
                action: 'collapseChild',
                ctor: 'NoteButtons',
                group: 'notes',
                id: 'FNoteButton'
            }, {
                leftText: 'G',
                rightText: 'g',
                icon: '',
                classes: 'collapsed',
                action: 'collapseChild',
                ctor: 'NoteButtons',
                group: 'notes',
                id: 'GNoteButton'
            }, {
                leftText: '',
                rightText: '-',
                icon: 'icon-sharp',
                classes: 'collapsed',
                action: 'collapseChild',
                ctor: 'NoteButtons',
                group: 'notes',
                id: 'UpNoteButton'
            }, {
                leftText: '',
                rightText: '=',
                icon: 'icon-flat',
                classes: 'collapsed',
                action: 'collapseChild',
                ctor: 'NoteButtons',
                group: 'notes',
                id: 'DownNoteButton'
            }, {
                leftText: '',
                rightText: 'r',
                icon: 'icon-rest',
                classes: 'collapsed',
                action: 'collapseChild',
                ctor: 'NoteButtons',
                group: 'notes',
                id: 'ToggleRestButton'
            }, {
                leftText: '',
                rightText: 'r',
                icon: 'icon-slash',
                classes: 'collapsed',
                action: 'collapseChild',
                ctor: 'NoteButtons',
                group: 'notes',
                id: 'ToggleSlashButton'
            }, {
                leftText: '...',
                rightText: '',
                icon: 'icon-circle-left',
                classes: 'collapsed expander',
                action: 'collapseMore',
                ctor: 'ExtendedCollapseParent',
                group: 'notes',
                id: 'moreNoteButtons'
            }, {
                leftText: '',
                rightText: 'G',
                icon: 'icon-grace_note',
                classes: 'collapsed graceIcon',
                action: 'collapseChild',
                ctor: 'NoteButtons',
                group: 'notes',
                id: 'AddGraceNote'
            }, {
                leftText: '',
                rightText: '',
                icon: 'icon-grace_slash',
                classes: 'collapsed graceIcon',
                action: 'collapseChild',
                ctor: 'NoteButtons',
                group: 'notes',
                id: 'SlashGraceNote'
            }, {
                leftText: '',
                rightText: 'alt-g',
                icon: 'icon-grace_remove',
                classes: 'collapsed graceIcon',
                action: 'collapseChild',
                ctor: 'NoteButtons',
                group: 'notes',
                id: 'RemoveGraceNote'
            }, {
                leftText: '',
                rightText: '',
                icon: 'icon-notex',
                classes: 'collapsed graceIcon',
                action: 'collapseChild',
                ctor: 'NoteButtons',
                group: 'notes',
                id: 'XNoteHead'
            }, {
                leftText: '',
                rightText: '',
                icon: 'icon-notehead-triangleup',
                classes: 'collapsed graceIcon',
                action: 'collapseChild',
                ctor: 'NoteButtons',
                group: 'notes',
                id: 'TriUpNoteHead'
            }, {
                leftText: '',
                rightText: '',
                icon: 'icon-notehead-circlex',
                classes: 'collapsed graceIcon',
                action: 'collapseChild',
                ctor: 'NoteButtons',
                group: 'notes',
                id: 'CircleXNoteHead'
            }, {
                leftText: '',
                rightText: '',
                icon: 'icon-notehead-diamondblack',
                classes: 'collapsed graceIcon',
                action: 'collapseChild',
                ctor: 'NoteButtons',
                group: 'notes',
                id: 'DiamondNoteHead'
            }, {
                leftText: '8va',
                rightText: 'Shift=',
                icon: '',
                classes: 'collapsed',
                action: 'collapseChild',
                ctor: 'NoteButtons',
                group: 'notes',
                id: 'UpOctaveButton'
            }, {
                leftText: '8vb',
                rightText: 'Shift-',
                icon: '',
                classes: 'collapsed',
                action: 'collapseChild',
                ctor: 'NoteButtons',
                group: 'notes',
                id: 'DownOctaveButton'
            }, {
                leftText: '',
                rightText: 'ShiftE',
                icon: 'icon-accident',
                classes: 'collapsed',
                action: 'collapseChild',
                ctor: 'NoteButtons',
                group: 'notes',
                id: 'ToggleAccidental'
            }, {
                leftText: '',
                rightText: 'ShiftF',
                icon: 'icon-courtesy',
                classes: 'collapsed',
                action: 'collapseChild',
                ctor: 'NoteButtons',
                group: 'notes',
                id: 'ToggleCourtesy'
            }
        ];
    }
    static get playerButtons() {
        // .icon-play3
        return [{
                leftText: '',
                rightText: '',
                icon: 'icon-equalizer2',
                classes: 'icon collapseParent player',
                action: 'collapseParent',
                ctor: 'CollapseRibbonControl',
                group: 'playerButtons',
                id: 'playerButtons'
            }, {
                leftText: '',
                rightText: 'p',
                icon: 'icon-play3',
                classes: 'icon collapsed player',
                action: 'collapseChild',
                ctor: 'PlayerButtons',
                group: 'playerButtons',
                id: 'playButton'
            },
            {
                leftText: '',
                rightText: 's',
                icon: 'icon-stop2',
                classes: 'icon collapsed player',
                action: 'collapseChild',
                ctor: 'PlayerButtons',
                group: 'playerButtons',
                id: 'stopButton'
            },
            {
                leftText: '',
                rightText: 'P',
                icon: 'icon-pause2',
                classes: 'icon collapsed player',
                action: 'collapseChild',
                ctor: 'PlayerButtons',
                group: 'playerButtons',
                id: 'pauseButton'
            }];
    }
    static get articulationButtons() {
        return [{
                leftText: '',
                rightText: '',
                icon: 'icon-articulation',
                classes: 'icon collapseParent articulation',
                action: 'collapseParent',
                ctor: 'CollapseRibbonControl',
                group: 'articulations',
                id: 'articulationButtons'
            }, {
                leftText: '',
                rightText: 'h',
                icon: 'icon-accent_above',
                classes: 'icon collapsed articulation',
                action: 'collapseChild',
                ctor: 'ArticulationButtons',
                group: 'articulations',
                id: 'accentButton'
            }, {
                leftText: '',
                rightText: 'i',
                icon: 'icon-tenuto_above',
                classes: 'icon collapsed articulation',
                action: 'collapseChild',
                ctor: 'ArticulationButtons',
                group: 'articulations',
                id: 'tenutoButton'
            }, {
                leftText: '',
                rightText: 'j',
                icon: 'icon-staccato_above',
                classes: 'icon collapsed articulation',
                action: 'collapseChild',
                ctor: 'ArticulationButtons',
                group: 'articulations',
                id: 'staccatoButton'
            }, {
                leftText: '',
                rightText: 'k',
                icon: 'icon-marcato_above',
                classes: 'icon collapsed articulation',
                action: 'collapseChild',
                ctor: 'ArticulationButtons',
                group: 'articulations',
                id: 'marcatoButton'
            }, {
                leftText: '',
                rightText: '',
                icon: 'icon-fermata',
                classes: 'icon collapsed articulation',
                action: 'collapseChild',
                ctor: 'ArticulationButtons',
                group: 'articulations',
                id: 'fermataButton'
            }, {
                leftText: '',
                rightText: 'l',
                icon: 'icon-pitz_above',
                classes: 'icon collapsed articulation',
                action: 'collapseChild',
                ctor: 'ArticulationButtons',
                group: 'articulations',
                id: 'pizzicatoButton'
            }, {
                leftText: '',
                rightText: '',
                icon: 'icon-mordent-inv',
                classes: 'icon collapsed articulation',
                action: 'collapseChild',
                ctor: 'ArticulationButtons',
                group: 'articulations',
                id: 'mordentInvertedButton'
            }, {
                leftText: '',
                rightText: '',
                icon: 'icon-mordent',
                classes: 'icon collapsed articulation',
                action: 'collapseChild',
                ctor: 'ArticulationButtons',
                group: 'articulations',
                id: 'mordentButton'
            }, {
                leftText: '',
                rightText: '',
                icon: 'icon-trill',
                classes: 'icon collapsed articulation',
                action: 'collapseChild',
                ctor: 'ArticulationButtons',
                group: 'articulations',
                id: 'trillButton'
            }, {
                leftText: '',
                rightText: '',
                icon: 'icon-scoop',
                classes: 'icon collapsed articulation',
                action: 'collapseChild',
                ctor: 'ArticulationButtons',
                group: 'articulations',
                id: 'scoopButton'
            },
            {
                leftText: '',
                rightText: '',
                icon: 'icon-drop',
                classes: 'icon collapsed articulation',
                action: 'collapseChild',
                ctor: 'ArticulationButtons',
                group: 'articulations',
                id: 'dropButton'
            },
            {
                leftText: '',
                rightText: '',
                icon: 'icon-drop-long',
                classes: 'icon collapsed articulation',
                action: 'collapseChild',
                ctor: 'ArticulationButtons',
                group: 'articulations',
                id: 'dropLongButton'
            },
            {
                leftText: '',
                rightText: '',
                icon: 'icon-doit',
                classes: 'icon collapsed articulation',
                action: 'collapseChild',
                ctor: 'ArticulationButtons',
                group: 'articulations',
                id: 'doitButton'
            },
            {
                leftText: '',
                rightText: '',
                icon: 'icon-doit-long',
                classes: 'icon collapsed articulation',
                action: 'collapseChild',
                ctor: 'ArticulationButtons',
                group: 'articulations',
                id: 'doitLongButton'
            },
            {
                leftText: '',
                rightText: '',
                icon: 'icon-flip',
                classes: 'icon collapsed articulation',
                action: 'collapseChild',
                ctor: 'ArticulationButtons',
                group: 'articulations',
                id: 'flipButton'
            },
            {
                leftText: '',
                rightText: '',
                icon: 'icon-smear',
                classes: 'icon collapsed articulation',
                action: 'collapseChild',
                ctor: 'ArticulationButtons',
                group: 'articulations',
                id: 'smearButton'
            }
        ];
    }
    static get navigationButtons() {
        return [{
                leftText: '',
                rightText: '',
                classes: 'icon  collapseParent',
                icon: 'icon-navigate',
                action: 'collapseParent',
                ctor: 'CollapseRibbonControl',
                group: 'navigation',
                id: 'NavigationButtons'
            }, {
                leftText: '',
                rightText: '',
                icon: 'icon-arrow-left',
                classes: 'collapsed',
                action: 'collapseChild',
                ctor: 'NavigationButtons',
                group: 'navigation',
                id: 'navLeftButton'
            }, {
                leftText: '',
                rightText: '',
                icon: 'icon-arrow-right',
                classes: 'collapsed',
                action: 'collapseChild',
                ctor: 'NavigationButtons',
                group: 'navigation',
                id: 'navRightButton'
            }, {
                leftText: '',
                rightText: '',
                icon: 'icon-arrow-up',
                classes: 'collapsed',
                action: 'collapseChild',
                ctor: 'NavigationButtons',
                group: 'navigation',
                id: 'navUpButton'
            }, {
                leftText: '',
                rightText: '',
                icon: 'icon-arrow-down',
                classes: 'collapsed',
                action: 'collapseChild',
                ctor: 'NavigationButtons',
                group: 'navigation',
                id: 'navDownButton'
            }, {
                leftText: '...',
                rightText: '',
                icon: '',
                classes: 'collapsed expander',
                action: 'collapseMore',
                ctor: 'ExtendedCollapseParent',
                group: 'navigation',
                id: 'moreNavButtons'
            }, {
                leftText: '',
                rightText: '',
                icon: 'icon-fforward',
                classes: 'collapsed',
                action: 'collapseGrandchild',
                ctor: 'NavigationButtons',
                group: 'navigation',
                id: 'navFastForward'
            }, {
                leftText: '',
                rightText: '',
                icon: 'icon-rewind',
                classes: 'collapsed',
                action: 'collapseGrandchild',
                ctor: 'NavigationButtons',
                group: 'navigation',
                id: 'navRewind'
            }, {
                leftText: '',
                rightText: '',
                icon: 'icon-note_select_left',
                classes: 'collapsed selection-icon',
                action: 'collapseGrandchild',
                ctor: 'NavigationButtons',
                group: 'navigation',
                id: 'navGrowLeft'
            }, {
                leftText: '',
                rightText: '',
                icon: 'icon-note_select_right',
                classes: 'collapsed selection-icon',
                action: 'collapseGrandchild',
                ctor: 'NavigationButtons',
                group: 'navigation',
                id: 'navGrowRight'
            }
        ];
    }
    static get chordButtons() {
        return [{
                icon: 'icon-chords',
                leftText: '',
                rightText: '',
                classes: 'icon collapseParent',
                action: 'collapseParent',
                ctor: 'CollapseRibbonControl',
                group: 'chords',
                id: 'CreateChordButtons'
            }, {
                icon: 'icon-arrow-up',
                leftText: '2nd',
                rightText: '2',
                classes: 'collapsed addChord',
                action: 'collapseChild',
                dataElements: {
                    interval: '1',
                    direction: '1'
                },
                ctor: 'ChordButtons',
                group: 'chords',
                id: 'SecondUpButton'
            }, {
                icon: 'icon-arrow-down',
                leftText: '2nd',
                rightText: 'Shift 2',
                classes: 'collapsed addChord dirdown',
                action: 'collapseChild',
                dataElements: {
                    interval: '1',
                    direction: '1'
                },
                ctor: 'ChordButtons',
                group: 'chords',
                id: 'SecondDownButton'
            }, {
                icon: 'icon-arrow-up',
                leftText: '3rd',
                rightText: '3',
                classes: 'collapsed addChord',
                action: 'collapseChild',
                dataElements: {
                    interval: '2',
                    direction: '1'
                },
                ctor: 'ChordButtons',
                group: 'chords',
                id: 'ThirdUpButton'
            }, {
                icon: 'icon-arrow-down',
                leftText: '3rd',
                rightText: 'Shift 3',
                classes: 'collapsed addChord dirdown',
                action: 'collapseChild',
                dataElements: {
                    interval: '2',
                    direction: '-1'
                },
                ctor: 'ChordButtons',
                group: 'chords',
                id: 'ThirdDownButton'
            }, {
                icon: 'icon-arrow-up',
                leftText: '4th',
                rightText: '4',
                classes: 'collapsed addChord',
                action: 'collapseChild',
                dataElements: {
                    interval: '3',
                    direction: '1'
                },
                ctor: 'ChordButtons',
                group: 'chords',
                id: 'FourthUpButton'
            }, {
                icon: 'icon-arrow-down',
                leftText: '4th',
                rightText: 'Shift 4',
                classes: 'collapsed addChord dirdown',
                action: 'collapseChild',
                dataElements: {
                    interval: '3',
                    direction: '-1'
                },
                ctor: 'ChordButtons',
                group: 'chords',
                id: 'FourthDownButton'
            }, {
                icon: 'icon-arrow-up',
                leftText: '5th',
                rightText: '5',
                classes: 'collapsed addChord dirdown',
                action: 'collapseChild',
                dataElements: {
                    interval: '4',
                    direction: '1'
                },
                ctor: 'ChordButtons',
                group: 'chords',
                id: 'FifthUpButton'
            }, {
                icon: 'icon-arrow-down',
                leftText: '5th',
                rightText: 'Shift 5',
                classes: 'collapsed addChord dirdown',
                action: 'collapseChild',
                dataElements: {
                    interval: '4',
                    direction: '-1'
                },
                ctor: 'ChordButtons',
                group: 'chords',
                id: 'FifthDownButton'
            }, {
                icon: 'icon-arrow-up',
                leftText: '6th',
                rightText: '6',
                classes: 'collapsed addChord dirdown',
                action: 'collapseChild',
                dataElements: {
                    interval: '5',
                    direction: '1'
                },
                ctor: 'ChordButtons',
                group: 'chords',
                id: 'SixthUpButton'
            }, {
                icon: 'icon-arrow-down',
                leftText: '6th',
                rightText: 'Shift 6',
                classes: 'collapsed addChord dirdown',
                action: 'collapseChild',
                dataElements: {
                    interval: '5',
                    direction: '-1'
                },
                ctor: 'ChordButtons',
                group: 'chords',
                id: 'SixthDownButton'
            }, {
                icon: 'icon-arrow-up',
                leftText: '7th',
                rightText: '7',
                classes: 'collapsed addChord dirdown',
                action: 'collapseChild',
                dataElements: {
                    interval: '6',
                    direction: '1'
                },
                ctor: 'ChordButtons',
                group: 'chords',
                id: 'SeventhUpButton'
            }, {
                icon: 'icon-arrow-down',
                leftText: '7th',
                rightText: 'Shift 7',
                classes: 'collapsed addChord dirdown',
                action: 'collapseChild',
                dataElements: {
                    interval: '6',
                    direction: '-1'
                },
                ctor: 'ChordButtons',
                group: 'chords',
                id: 'SeventhDownButton'
            }, {
                icon: 'icon-arrow-up',
                leftText: '8va',
                rightText: '8',
                classes: 'collapsed addChord dirdown',
                action: 'collapseChild',
                dataElements: {
                    interval: '7',
                    direction: '1'
                },
                ctor: 'ChordButtons',
                group: 'chords',
                id: 'OctaveUpButton'
            }, {
                icon: 'icon-arrow-down',
                leftText: '7th',
                rightText: 'Shift 7',
                classes: 'collapsed addChord dirdown',
                action: 'collapseChild',
                dataElements: {
                    interval: '7',
                    direction: '-1'
                },
                ctor: 'ChordButtons',
                group: 'chords',
                id: 'OctaveDownButton'
            }, {
                icon: '',
                leftText: 'Collapse',
                rightText: '',
                classes: 'collapsed addChord dirdown',
                action: 'collapseChild',
                ctor: 'ChordButtons',
                group: 'chords',
                id: 'CollapseChordButton'
            }
        ];
    }
    static get leftRibbonButtons() {
        return [{
                icon: '',
                leftText: 'Help',
                rightText: '?',
                classes: 'help-button',
                action: 'modal',
                ctor: 'helpModal',
                group: 'scoreEdit',
                id: 'helpDialog'
            }, {
                leftText: 'Language',
                rightText: '/n',
                icon: '',
                classes: 'language-select menu-select',
                action: 'menu',
                ctor: 'SuiLanguageMenu',
                group: 'scoreEdit',
                id: 'languageMenu'
            }, {
                leftText: 'File',
                rightText: '/f',
                icon: '',
                classes: 'file-modify menu-select',
                action: 'menu',
                ctor: 'SuiFileMenu',
                group: 'scoreEdit',
                id: 'fileMenu'
            }, {
                leftText: 'Library',
                rightText: '/L',
                icon: '',
                classes: 'file-modify menu-select',
                action: 'modal',
                ctor: 'SuiLibraryDialog',
                group: 'scoreEdit',
                id: 'libraryMenu'
            }, {
                leftText: 'Score',
                rightText: '',
                icon: '',
                classes: 'icon ',
                action: 'menu',
                ctor: 'SuiScoreMenu',
                group: 'scoreEdit',
                id: 'scoreMenu'
            },
            {
                leftText: 'Parts',
                rightText: '/p',
                icon: '',
                classes: 'icon',
                action: 'menu',
                ctor: 'SuiPartMenu',
                group: 'scoreEdit',
                id: 'partMenu'
            }, {
                leftText: 'Notes',
                rightText: '',
                icon: 'icon-note',
                classes: 'icon',
                action: 'menu',
                ctor: 'SuiNoteMenu',
                group: 'scoreEdit',
                id: 'noteMenu'
            }, {
                leftText: 'Measure',
                rightText: '/a',
                icon: '',
                classes: 'icon menu-select',
                action: 'menu',
                ctor: 'SuiMeasureMenu',
                group: 'scoreEdit',
                id: 'measureModal'
            }, {
                leftText: 'Tempo',
                rightText: 't',
                icon: '',
                classes: 'icon ',
                action: 'modal',
                ctor: 'SuiTempoDialog',
                group: 'scoreEdit',
                id: 'tempoModal'
            }, {
                leftText: 'Time Signature',
                rightText: '/m',
                icon: '',
                classes: 'staff-modify menu-select',
                action: 'menu',
                ctor: 'SuiTimeSignatureMenu',
                group: 'scoreEdit',
                id: 'timeSignatureMenu'
            },
            {
                leftText: 'Key',
                rightText: '/k',
                icon: '',
                classes: 'note-modify menu-select',
                action: 'menu',
                ctor: 'SuiKeySignatureMenu',
                group: 'scoreEdit',
                id: 'keyMenu'
            }, {
                leftText: 'Lines',
                rightText: '/l',
                icon: '',
                classes: 'icon note-modify menu-select',
                action: 'menu',
                ctor: 'SuiStaffModifierMenu',
                group: 'scoreEdit',
                id: 'staffModifierMenu'
            },
        ];
    }
}
exports.defaultRibbonLayout = defaultRibbonLayout;


/***/ }),

/***/ "./src/ui/ribbonLayout/default/tabletRibbon.ts":
/*!*****************************************************!*\
  !*** ./src/ui/ribbonLayout/default/tabletRibbon.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports) => {


// [Smoosic](https://github.com/AaronDavidNewman/Smoosic)
// Copyright (c) Aaron David Newman 2021.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.simpleRibbonLayout = void 0;
class simpleRibbonLayout {
    static get ribbons() {
        var left = simpleRibbonLayout.leftRibbonIds;
        var top = simpleRibbonLayout.displayIds.concat(simpleRibbonLayout.noteButtonIds).concat(simpleRibbonLayout.navigateButtonIds)
            .concat(simpleRibbonLayout.durationIds);
        return {
            left: left,
            top: top
        };
    }
    static get simpleRibbonLayout() {
        return simpleRibbonLayout.leftRibbonButtons.concat(simpleRibbonLayout.navigationButtons).concat(simpleRibbonLayout.noteRibbonButtons).concat(simpleRibbonLayout.durationRibbonButtons);
    }
    static get leftRibbonIds() {
        return ['libraryMenu',
            'layoutMenu',
            'tempoModal', 'timeSignatureMenu', 'keyMenu', 'staffModifierMenu',
            'pianoModal'];
    }
    static get noteButtonIds() {
        return ['NoteButtons',
            'UpNoteButton', 'DownNoteButton',
            'UpOctaveButton', 'DownOctaveButton', 'ToggleRestButton', 'ToggleSlashButton', 'ToggleAccidental', 'ToggleCourtesy'];
    }
    static get navigateButtonIds() {
        return ['NavigationButtons', 'navLeftButton', 'navRightButton', 'navUpButton', 'navDownButton', 'moreNavButtons', 'navFastForward', 'navRewind',
            'navGrowLeft', 'navGrowRight'];
    }
    static get intervalIds() {
        return ['CreateChordButtons', 'SecondUpButton', 'SecondDownButton', 'ThirdUpButton', 'ThirdDownButton', 'FourthUpButton', 'FourthDownButton',
            'FifthUpButton', 'FifthDownButton', 'SixthUpButton', 'SixthDownButton',
            'SeventhUpButton', 'SeventhDownButton', 'OctaveUpButton', 'OctaveDownButton', 'CollapseChordButton'];
    }
    static get durationIds() {
        return ['DurationButtons', 'GrowDuration', 'LessDuration', 'GrowDurationDot', 'LessDurationDot', 'TripletButton', 'QuintupletButton', 'SeptupletButton', 'NoTupletButton'];
    }
    static get playerIds() {
        return ['playerButtons', 'playButton', 'pauseButton', 'stopButton'];
    }
    static get displayIds() {
        return ['quickButtons', 'refresh', 'zoomout', 'zoomin', 'playButton2', 'stopButton2'];
    }
    static get displayButtons() {
        return [{
                leftText: '',
                rightText: '',
                classes: 'icon  hide',
                icon: 'icon-zoomplus',
                action: 'collapseParent',
                ctor: 'CollapseRibbonControl',
                group: 'quickButtons',
                id: 'quickButtons'
            }, {
                leftText: '',
                rightText: '',
                classes: 'icon   refresh',
                icon: 'icon-refresh',
                action: 'collapseChild',
                ctor: 'DisplaySettings',
                group: 'quickButtons',
                id: 'refresh'
            }, {
                leftText: '',
                rightText: '',
                classes: 'icon   refresh',
                icon: 'icon-zoomplus',
                action: 'collapseChild',
                ctor: 'DisplaySettings',
                group: 'quickButtons',
                id: 'zoomout'
            }, {
                leftText: '',
                rightText: '',
                classes: 'icon   refresh',
                icon: 'icon-zoomminus',
                action: 'collapseChild',
                ctor: 'DisplaySettings',
                group: 'quickButtons',
                id: 'zoomin'
            }, {
                leftText: '',
                rightText: '',
                classes: 'icon   play',
                icon: 'icon-play3',
                action: 'collapseChild',
                ctor: 'DisplaySettings',
                group: 'quickButtons',
                id: 'playButton2'
            }, {
                leftText: '',
                rightText: '',
                classes: 'icon   stop2',
                icon: 'icon-stop2',
                action: 'collapseChild',
                ctor: 'DisplaySettings',
                group: 'quickButtons',
                id: 'stopButton2'
            }
        ];
    }
    static get durationRibbonButtons() {
        return [{
                leftText: '',
                rightText: '',
                classes: 'icon  collapseParent duration',
                icon: 'icon-duration',
                action: 'collapseParent',
                ctor: 'CollapseRibbonControl',
                group: 'duration',
                id: 'DurationButtons'
            }, {
                leftText: '',
                rightText: '.',
                icon: 'icon-duration_grow',
                classes: 'collapsed duration',
                action: 'collapseChild',
                ctor: 'DurationButtons',
                group: 'duration',
                id: 'GrowDuration'
            }, {
                leftText: '',
                rightText: ',',
                icon: 'icon-duration_less',
                classes: 'collapsed duration',
                action: 'collapseChild',
                ctor: 'DurationButtons',
                group: 'duration',
                id: 'LessDuration'
            }, {
                leftText: '',
                rightText: '>',
                icon: 'icon-duration_grow_dot',
                classes: 'collapsed duration',
                action: 'collapseChild',
                ctor: 'DurationButtons',
                group: 'duration',
                id: 'GrowDurationDot'
            }, {
                leftText: '',
                rightText: '<',
                icon: 'icon-duration_less_dot',
                classes: 'collapsed duration',
                action: 'collapseChild',
                ctor: 'DurationButtons',
                group: 'duration',
                id: 'LessDurationDot'
            }, {
                leftText: '',
                rightText: 'Ctrl-3',
                icon: 'icon-triplet',
                classes: 'collapsed duration tuplet',
                action: 'collapseChild',
                ctor: 'DurationButtons',
                group: 'duration',
                id: 'TripletButton'
            }, {
                leftText: '',
                rightText: 'Ctrl-5',
                icon: 'icon-quint',
                classes: 'collapsed duration tuplet',
                action: 'collapseChild',
                ctor: 'DurationButtons',
                group: 'duration',
                id: 'QuintupletButton'
            }, {
                leftText: '',
                rightText: 'Ctrl-7',
                icon: 'icon-septuplet',
                classes: 'collapsed duration tuplet',
                action: 'collapseChild',
                ctor: 'DurationButtons',
                group: 'duration',
                id: 'SeptupletButton'
            },
            {
                leftText: '',
                rightText: 'Ctrl-0',
                icon: 'icon-no_tuplet',
                classes: 'collapsed duration tuplet',
                action: 'collapseChild',
                ctor: 'DurationButtons',
                group: 'duration',
                id: 'NoTupletButton'
            }
        ];
    }
    static get noteRibbonButtons() {
        return [{
                leftText: '',
                rightText: '',
                classes: 'icon  collapseParent',
                icon: 'icon-note',
                action: 'collapseParent',
                ctor: 'CollapseRibbonControl',
                group: 'notes',
                id: 'NoteButtons'
            }, {
                leftText: 'A',
                rightText: 'a',
                icon: '',
                classes: 'collapsed',
                action: 'collapseChild',
                ctor: 'NoteButtons',
                group: 'notes',
                id: 'ANoteButton'
            }, {
                leftText: 'B',
                rightText: 'b',
                icon: '',
                classes: 'collapsed',
                action: 'collapseChild',
                ctor: 'NoteButtons',
                group: 'notes',
                id: 'BNoteButton'
            }, {
                leftText: 'C',
                rightText: 'c',
                icon: '',
                classes: 'collapsed',
                action: 'collapseChild',
                ctor: 'NoteButtons',
                group: 'notes',
                id: 'CNoteButton'
            }, {
                leftText: 'D',
                rightText: 'd',
                icon: '',
                classes: 'collapsed',
                action: 'collapseChild',
                ctor: 'NoteButtons',
                group: 'notes',
                id: 'DNoteButton'
            }, {
                leftText: 'E',
                rightText: 'e',
                icon: '',
                classes: 'collapsed',
                action: 'collapseChild',
                ctor: 'NoteButtons',
                group: 'notes',
                id: 'ENoteButton'
            }, {
                leftText: 'F',
                rightText: 'f',
                icon: '',
                classes: 'collapsed',
                action: 'collapseChild',
                ctor: 'NoteButtons',
                group: 'notes',
                id: 'FNoteButton'
            }, {
                leftText: 'G',
                rightText: 'g',
                icon: '',
                classes: 'collapsed',
                action: 'collapseChild',
                ctor: 'NoteButtons',
                group: 'notes',
                id: 'GNoteButton'
            }, {
                leftText: '',
                rightText: '-',
                icon: 'icon-sharp',
                classes: 'collapsed',
                action: 'collapseChild',
                ctor: 'NoteButtons',
                group: 'notes',
                id: 'UpNoteButton'
            }, {
                leftText: '',
                rightText: '=',
                icon: 'icon-flat',
                classes: 'collapsed',
                action: 'collapseChild',
                ctor: 'NoteButtons',
                group: 'notes',
                id: 'DownNoteButton'
            }, {
                leftText: '',
                rightText: 'r',
                icon: 'icon-rest',
                classes: 'collapsed',
                action: 'collapseChild',
                ctor: 'NoteButtons',
                group: 'notes',
                id: 'ToggleRestButton'
            }, {
                leftText: '',
                rightText: 'r',
                icon: 'icon-slash',
                classes: 'collapsed',
                action: 'collapseChild',
                ctor: 'NoteButtons',
                group: 'notes',
                id: 'ToggleSlashButton'
            }, {
                leftText: '...',
                rightText: '',
                icon: 'icon-circle-left',
                classes: 'collapsed expander',
                action: 'collapseMore',
                ctor: 'ExtendedCollapseParent',
                group: 'notes',
                id: 'moreNoteButtons'
            }, {
                leftText: '',
                rightText: 'G',
                icon: 'icon-grace_note',
                classes: 'collapsed graceIcon',
                action: 'collapseChild',
                ctor: 'NoteButtons',
                group: 'notes',
                id: 'AddGraceNote'
            }, {
                leftText: '',
                rightText: '',
                icon: 'icon-grace_slash',
                classes: 'collapsed graceIcon',
                action: 'collapseChild',
                ctor: 'NoteButtons',
                group: 'notes',
                id: 'SlashGraceNote'
            }, {
                leftText: '',
                rightText: 'alt-g',
                icon: 'icon-grace_remove',
                classes: 'collapsed graceIcon',
                action: 'collapseChild',
                ctor: 'NoteButtons',
                group: 'notes',
                id: 'RemoveGraceNote'
            }, {
                leftText: '',
                rightText: '',
                icon: 'icon-notex',
                classes: 'collapsed graceIcon',
                action: 'collapseChild',
                ctor: 'NoteButtons',
                group: 'notes',
                id: 'XNoteHead'
            }, {
                leftText: '',
                rightText: '',
                icon: 'icon-notehead-triangleup',
                classes: 'collapsed graceIcon',
                action: 'collapseChild',
                ctor: 'NoteButtons',
                group: 'notes',
                id: 'TriUpNoteHead'
            }, {
                leftText: '',
                rightText: '',
                icon: 'icon-notehead-circlex',
                classes: 'collapsed graceIcon',
                action: 'collapseChild',
                ctor: 'NoteButtons',
                group: 'notes',
                id: 'CircleXNoteHead'
            }, {
                leftText: '',
                rightText: '',
                icon: 'icon-notehead-diamondblack',
                classes: 'collapsed graceIcon',
                action: 'collapseChild',
                ctor: 'NoteButtons',
                group: 'notes',
                id: 'DiamondNoteHead'
            }, {
                leftText: '8va',
                rightText: 'Shift=',
                icon: '',
                classes: 'collapsed',
                action: 'collapseChild',
                ctor: 'NoteButtons',
                group: 'notes',
                id: 'UpOctaveButton'
            }, {
                leftText: '8vb',
                rightText: 'Shift-',
                icon: '',
                classes: 'collapsed',
                action: 'collapseChild',
                ctor: 'NoteButtons',
                group: 'notes',
                id: 'DownOctaveButton'
            }, {
                leftText: '',
                rightText: 'ShiftE',
                icon: 'icon-accident',
                classes: 'collapsed',
                action: 'collapseChild',
                ctor: 'NoteButtons',
                group: 'notes',
                id: 'ToggleAccidental'
            }, {
                leftText: '',
                rightText: 'ShiftF',
                icon: 'icon-courtesy',
                classes: 'collapsed',
                action: 'collapseChild',
                ctor: 'NoteButtons',
                group: 'notes',
                id: 'ToggleCourtesy'
            }
        ];
    }
    static get playerButtons() {
        // .icon-play3
        return [{
                leftText: '',
                rightText: '',
                icon: 'icon-equalizer2',
                classes: 'icon collapseParent player',
                action: 'collapseParent',
                ctor: 'CollapseRibbonControl',
                group: 'playerButtons',
                id: 'playerButtons'
            }, {
                leftText: '',
                rightText: 'p',
                icon: 'icon-play3',
                classes: 'icon collapsed player',
                action: 'collapseChild',
                ctor: 'PlayerButtons',
                group: 'playerButtons',
                id: 'playButton'
            },
            {
                leftText: '',
                rightText: 's',
                icon: 'icon-stop2',
                classes: 'icon collapsed player',
                action: 'collapseChild',
                ctor: 'PlayerButtons',
                group: 'playerButtons',
                id: 'stopButton'
            },
            {
                leftText: '',
                rightText: 'P',
                icon: 'icon-pause2',
                classes: 'icon collapsed player',
                action: 'collapseChild',
                ctor: 'PlayerButtons',
                group: 'playerButtons',
                id: 'pauseButton'
            }];
    }
    static get navigationButtons() {
        return [{
                leftText: '',
                rightText: '',
                classes: 'icon  collapseParent',
                icon: 'icon-navigate',
                action: 'collapseParent',
                ctor: 'CollapseRibbonControl',
                group: 'navigation',
                id: 'NavigationButtons'
            }, {
                leftText: '',
                rightText: '',
                icon: 'icon-arrow-left',
                classes: 'collapsed',
                action: 'collapseChild',
                ctor: 'NavigationButtons',
                group: 'navigation',
                id: 'navLeftButton'
            }, {
                leftText: '',
                rightText: '',
                icon: 'icon-arrow-right',
                classes: 'collapsed',
                action: 'collapseChild',
                ctor: 'NavigationButtons',
                group: 'navigation',
                id: 'navRightButton'
            }, {
                leftText: '',
                rightText: '',
                icon: 'icon-arrow-up',
                classes: 'collapsed',
                action: 'collapseChild',
                ctor: 'NavigationButtons',
                group: 'navigation',
                id: 'navUpButton'
            }, {
                leftText: '',
                rightText: '',
                icon: 'icon-arrow-down',
                classes: 'collapsed',
                action: 'collapseChild',
                ctor: 'NavigationButtons',
                group: 'navigation',
                id: 'navDownButton'
            }, {
                leftText: '...',
                rightText: '',
                icon: '',
                classes: 'collapsed expander',
                action: 'collapseMore',
                ctor: 'ExtendedCollapseParent',
                group: 'navigation',
                id: 'moreNavButtons'
            }, {
                leftText: '',
                rightText: '',
                icon: 'icon-fforward',
                classes: 'collapsed',
                action: 'collapseGrandchild',
                ctor: 'NavigationButtons',
                group: 'navigation',
                id: 'navFastForward'
            }, {
                leftText: '',
                rightText: '',
                icon: 'icon-rewind',
                classes: 'collapsed',
                action: 'collapseGrandchild',
                ctor: 'NavigationButtons',
                group: 'navigation',
                id: 'navRewind'
            }, {
                leftText: '',
                rightText: '',
                icon: 'icon-note_select_left',
                classes: 'collapsed selection-icon',
                action: 'collapseGrandchild',
                ctor: 'NavigationButtons',
                group: 'navigation',
                id: 'navGrowLeft'
            }, {
                leftText: '',
                rightText: '',
                icon: 'icon-note_select_right',
                classes: 'collapsed selection-icon',
                action: 'collapseGrandchild',
                ctor: 'NavigationButtons',
                group: 'navigation',
                id: 'navGrowRight'
            }
        ];
    }
    static get leftRibbonButtons() {
        return [{
                leftText: 'Library',
                rightText: '/L',
                icon: '',
                classes: 'file-modify menu-select',
                action: 'modal',
                ctor: 'SuiLibraryDialog',
                group: 'scoreEdit',
                id: 'libraryMenu'
            }, {
                leftText: 'Score',
                rightText: '',
                icon: '',
                classes: 'icon ',
                action: 'menu',
                ctor: 'SuiScoreMenu',
                group: 'scoreEdit',
                id: 'layoutMenu'
            }, {
                leftText: 'Tempo',
                rightText: 't',
                icon: '',
                classes: 'icon ',
                action: 'modal',
                ctor: 'SuiTempoDialog',
                group: 'scoreEdit',
                id: 'tempoModal'
            }, {
                leftText: 'Time Signature',
                rightText: '/m',
                icon: '',
                classes: 'staff-modify menu-select',
                action: 'menu',
                ctor: 'SuiTimeSignatureMenu',
                group: 'scoreEdit',
                id: 'timeSignatureMenu'
            },
            {
                leftText: 'Key',
                rightText: '/k',
                icon: '',
                classes: 'note-modify menu-select',
                action: 'menu',
                ctor: 'SuiKeySignatureMenu',
                group: 'scoreEdit',
                id: 'keyMenu'
            },
        ];
    }
}
exports.simpleRibbonLayout = simpleRibbonLayout;


/***/ }),

/***/ "./tests/file-load.ts":
/*!****************************!*\
  !*** ./tests/file-load.ts ***!
  \****************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createLoadTests = void 0;
const application_1 = __webpack_require__(/*! ../src/application/application */ "./src/application/application.ts");
const smoToXml_1 = __webpack_require__(/*! ../src/smo/mxml/smoToXml */ "./src/smo/mxml/smoToXml.ts");
const xmlToSmo_1 = __webpack_require__(/*! ../src/smo/mxml/xmlToSmo */ "./src/smo/mxml/xmlToSmo.ts");
const xhrLoader_1 = __webpack_require__(/*! ../src/ui/fileio/xhrLoader */ "./src/ui/fileio/xhrLoader.ts");
const midiToSmo_1 = __webpack_require__(/*! ../src/smo/midi/midiToSmo */ "./src/smo/midi/midiToSmo.ts");
function createLoadTests() {
    const jsonPath = 'https://aarondavidnewman.github.io/Smoosic/release/library/hymns/Precious Lord.json';
    const midiTiesPath = 'https://aarondavidnewman.github.io/Smoosic/release/library/miditest/ties.mid';
    const midiTripletPath = 'https://aarondavidnewman.github.io/Smoosic/release/library/miditest/triplet.mid';
    const midiKeyPath = 'https://aarondavidnewman.github.io/Smoosic/release/library/miditest/keytime.mid';
    var app = (application) => __awaiter(this, void 0, void 0, function* () {
        const view = application.view;
        yield view.loadRemoteScore(jsonPath);
        yield view.renderPromise();
        QUnit.test('loaded', assert => {
            assert.equal(view.score.staves[0].measures.length, 17);
            assert.equal($('#boo .vf-annotation').length, 82);
        });
        const xml = smoToXml_1.SmoToXml.convert(view.score);
        const newScore = xmlToSmo_1.XmlToSmo.convert(xml);
        yield view.changeScore(newScore);
        QUnit.test('loadXml', assert => {
            assert.equal(view.score.staves[0].measures.length, 17);
            assert.equal($('#boo .vf-annotation').length, 82);
        });
        let midiData = new xhrLoader_1.SuiXhrLoader(midiTiesPath);
        yield midiData.loadAsync();
        let midiScore = (new midiToSmo_1.MidiToSmo(parseMidi(midiData.value), 1024)).convert();
        yield view.changeScore(midiScore);
        QUnit.test('loadMidi1', assert => {
            assert.equal(midiScore.staves[0].getTiesEndingAt({ staff: 0, measure: 1, voice: 0, tick: 0, pitches: [] }).length, 1);
        });
        midiData = new xhrLoader_1.SuiXhrLoader(midiTripletPath);
        yield midiData.loadAsync();
        midiScore = (new midiToSmo_1.MidiToSmo(parseMidi(midiData.value), 1024)).convert();
        yield view.changeScore(midiScore);
        QUnit.test('loadMidi2', assert => {
            assert.equal(midiScore.staves[0].measures[0].tuplets.length, 1);
        });
        midiData = new xhrLoader_1.SuiXhrLoader(midiKeyPath);
        yield midiData.loadAsync();
        midiScore = (new midiToSmo_1.MidiToSmo(parseMidi(midiData.value), 1024)).convert();
        yield view.changeScore(midiScore);
        QUnit.test('loadMidi2', assert => {
            assert.equal(midiScore.staves.length, 2);
            assert.equal(midiScore.staves[0].measures[0].keySignature, 'eb');
        });
        // console.log('measures ' + view.score.staves[0].measures.length);
    });
    application_1.SuiApplication.configure({
        mode: 'library',
        idleRedrawTime: 5,
        scoreDomContainer: 'outer-container'
    }).then((application) => {
        app(application);
    });
}
exports.createLoadTests = createLoadTests;


/***/ }),

/***/ "./typedoc.ts":
/*!********************!*\
  !*** ./typedoc.ts ***!
  \********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./src/application/application */ "./src/application/application.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/application/common */ "./src/application/common.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/application/configuration */ "./src/application/configuration.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/application/dom */ "./src/application/dom.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/application/eventHandler */ "./src/application/eventHandler.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/application/exports */ "./src/application/exports.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/application/keyCommands */ "./src/application/keyCommands.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/common/promiseHelpers */ "./src/common/promiseHelpers.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/common/htmlHelpers */ "./src/common/htmlHelpers.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/render/audio/oscillator */ "./src/render/audio/oscillator.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/render/audio/player */ "./src/render/audio/player.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/render/audio/samples */ "./src/render/audio/samples.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/render/sui/configuration */ "./src/render/sui/configuration.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/render/sui/formatter */ "./src/render/sui/formatter.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/render/sui/layoutDebug */ "./src/render/sui/layoutDebug.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/render/sui/mapper */ "./src/render/sui/mapper.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/render/sui/piano */ "./src/render/sui/piano.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/render/sui/renderState */ "./src/render/sui/renderState.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/render/sui/scoreRender */ "./src/render/sui/scoreRender.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/render/sui/scoreView */ "./src/render/sui/scoreView.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/render/sui/scoreViewOperations */ "./src/render/sui/scoreViewOperations.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/render/sui/scroller */ "./src/render/sui/scroller.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/render/sui/svgHelpers */ "./src/render/sui/svgHelpers.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/render/sui/svgPageMap */ "./src/render/sui/svgPageMap.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/render/sui/textEdit */ "./src/render/sui/textEdit.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/render/sui/textRender */ "./src/render/sui/textRender.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/render/sui/tracker */ "./src/render/sui/tracker.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/render/vex/glyphDimensions */ "./src/render/vex/glyphDimensions.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/render/vex/vxMeasure */ "./src/render/vex/vxMeasure.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/render/vex/vxSystem */ "./src/render/vex/vxSystem.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/smo/data/common */ "./src/smo/data/common.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/smo/data/measure */ "./src/smo/data/measure.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/smo/data/measureModifiers */ "./src/smo/data/measureModifiers.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/smo/data/music */ "./src/smo/data/music.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/smo/data/note */ "./src/smo/data/note.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/smo/data/noteModifiers */ "./src/smo/data/noteModifiers.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/smo/data/partInfo */ "./src/smo/data/partInfo.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/smo/data/score */ "./src/smo/data/score.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/smo/data/scoreText */ "./src/smo/data/scoreText.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/smo/data/scoreModifiers */ "./src/smo/data/scoreModifiers.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/smo/data/staffModifiers */ "./src/smo/data/staffModifiers.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/smo/data/systemStaff */ "./src/smo/data/systemStaff.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/smo/data/tuplet */ "./src/smo/data/tuplet.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/smo/midi/smoToMidi */ "./src/smo/midi/smoToMidi.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/smo/mxml/smoToXml */ "./src/smo/mxml/smoToXml.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/smo/mxml/xmlHelpers */ "./src/smo/mxml/xmlHelpers.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/smo/mxml/xmlToSmo */ "./src/smo/mxml/xmlToSmo.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/smo/mxml/xmlState */ "./src/smo/mxml/xmlState.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/smo/xform/audioTrack */ "./src/smo/xform/audioTrack.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/smo/xform/beamers */ "./src/smo/xform/beamers.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/smo/xform/copypaste */ "./src/smo/xform/copypaste.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/smo/xform/operations */ "./src/smo/xform/operations.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/smo/xform/selections */ "./src/smo/xform/selections.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/smo/xform/tickDuration */ "./src/smo/xform/tickDuration.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/smo/xform/tickMap */ "./src/smo/xform/tickMap.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/smo/xform/toVex */ "./src/smo/xform/toVex.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/smo/xform/undo */ "./src/smo/xform/undo.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/ui/buttons/articulation */ "./src/ui/buttons/articulation.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/ui/buttons/beam */ "./src/ui/buttons/beam.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/ui/buttons/button */ "./src/ui/buttons/button.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/ui/buttons/chord */ "./src/ui/buttons/chord.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/ui/buttons/collapsable */ "./src/ui/buttons/collapsable.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/ui/buttons/display */ "./src/ui/buttons/display.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/ui/buttons/duration */ "./src/ui/buttons/duration.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/ui/buttons/measure */ "./src/ui/buttons/measure.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/ui/buttons/microtone */ "./src/ui/buttons/microtone.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/ui/buttons/navigation */ "./src/ui/buttons/navigation.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/ui/buttons/note */ "./src/ui/buttons/note.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/ui/buttons/player */ "./src/ui/buttons/player.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/ui/buttons/ribbon */ "./src/ui/buttons/ribbon.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/ui/buttons/stave */ "./src/ui/buttons/stave.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/ui/buttons/text */ "./src/ui/buttons/text.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/ui/buttons/voice */ "./src/ui/buttons/voice.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/ui/common */ "./src/ui/common.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/ui/configuration */ "./src/ui/configuration.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/ui/dialogs/adapter */ "./src/ui/dialogs/adapter.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/ui/dialogs/addMeasure */ "./src/ui/dialogs/addMeasure.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/ui/dialogs/chordChange */ "./src/ui/dialogs/chordChange.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/ui/dialogs/components/baseComponent */ "./src/ui/dialogs/components/baseComponent.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/ui/dialogs/components/button */ "./src/ui/dialogs/components/button.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/ui/dialogs/components/checkdrop */ "./src/ui/dialogs/components/checkdrop.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/ui/dialogs/components/dragText */ "./src/ui/dialogs/components/dragText.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/ui/dialogs/components/dropdown */ "./src/ui/dialogs/components/dropdown.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/ui/dialogs/components/fileDownload */ "./src/ui/dialogs/components/fileDownload.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/ui/dialogs/components/fontComponent */ "./src/ui/dialogs/components/fontComponent.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/ui/dialogs/components/noteText */ "./src/ui/dialogs/components/noteText.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/ui/dialogs/components/rocker */ "./src/ui/dialogs/components/rocker.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/ui/dialogs/components/staffComponents */ "./src/ui/dialogs/components/staffComponents.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/ui/dialogs/components/textCheck */ "./src/ui/dialogs/components/textCheck.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/ui/dialogs/components/textInPlace */ "./src/ui/dialogs/components/textInPlace.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/ui/dialogs/components/textInput */ "./src/ui/dialogs/components/textInput.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/ui/dialogs/components/tie */ "./src/ui/dialogs/components/tie.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/ui/dialogs/components/toggle */ "./src/ui/dialogs/components/toggle.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/ui/dialogs/components/tree */ "./src/ui/dialogs/components/tree.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/ui/dialogs/dialog */ "./src/ui/dialogs/dialog.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/ui/dialogs/dynamics */ "./src/ui/dialogs/dynamics.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/ui/dialogs/factory */ "./src/ui/dialogs/factory.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/ui/dialogs/fileDialogs */ "./src/ui/dialogs/fileDialogs.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/ui/dialogs/fonts */ "./src/ui/dialogs/fonts.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/ui/dialogs/globalLayout */ "./src/ui/dialogs/globalLayout.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/ui/dialogs/hairpin */ "./src/ui/dialogs/hairpin.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/ui/dialogs/instrument */ "./src/ui/dialogs/instrument.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/ui/dialogs/library */ "./src/ui/dialogs/library.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/ui/dialogs/lyric */ "./src/ui/dialogs/lyric.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/ui/dialogs/measureFormat */ "./src/ui/dialogs/measureFormat.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/ui/dialogs/pageLayout */ "./src/ui/dialogs/pageLayout.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/ui/dialogs/partInfo */ "./src/ui/dialogs/partInfo.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/ui/dialogs/preferences */ "./src/ui/dialogs/preferences.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/ui/dialogs/scoreId */ "./src/ui/dialogs/scoreId.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/ui/dialogs/scoreView */ "./src/ui/dialogs/scoreView.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/ui/dialogs/slur */ "./src/ui/dialogs/slur.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/ui/dialogs/staffGroup */ "./src/ui/dialogs/staffGroup.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/ui/dialogs/tempo */ "./src/ui/dialogs/tempo.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/ui/dialogs/textBlock */ "./src/ui/dialogs/textBlock.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/ui/dialogs/textBracket */ "./src/ui/dialogs/textBracket.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/ui/dialogs/tie */ "./src/ui/dialogs/tie.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/ui/dialogs/timeSignature */ "./src/ui/dialogs/timeSignature.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/ui/dialogs/volta */ "./src/ui/dialogs/volta.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/ui/eventSource */ "./src/ui/eventSource.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/ui/fileio/fileInput */ "./src/ui/fileio/fileInput.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/ui/fileio/library */ "./src/ui/fileio/library.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/ui/fileio/xhrLoader */ "./src/ui/fileio/xhrLoader.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/ui/i18n/language */ "./src/ui/i18n/language.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/ui/i18n/translationEditor */ "./src/ui/i18n/translationEditor.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/ui/keyBindings/default/editorKeys */ "./src/ui/keyBindings/default/editorKeys.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/ui/keyBindings/default/trackerKeys */ "./src/ui/keyBindings/default/trackerKeys.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/ui/menus/dynamics */ "./src/ui/menus/dynamics.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/ui/menus/file */ "./src/ui/menus/file.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/ui/menus/keySignature */ "./src/ui/menus/keySignature.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/ui/menus/language */ "./src/ui/menus/language.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/ui/menus/manager */ "./src/ui/menus/manager.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/ui/menus/measure */ "./src/ui/menus/measure.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/ui/menus/menu */ "./src/ui/menus/menu.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/ui/menus/parts */ "./src/ui/menus/parts.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/ui/menus/score */ "./src/ui/menus/score.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/ui/menus/staffModifier */ "./src/ui/menus/staffModifier.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/ui/menus/timeSignature */ "./src/ui/menus/timeSignature.ts"), exports);
__exportStar(__webpack_require__(/*! ./src/ui/ribbonLayout/default/defaultRibbon */ "./src/ui/ribbonLayout/default/defaultRibbon.ts"), exports);


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/application/exports.ts");
/******/ 	__webpack_exports__ = __webpack_exports__["default"];
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=smoosic.js.map