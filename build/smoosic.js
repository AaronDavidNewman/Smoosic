
var smoLanguageStringDe = `[
 {
  "ctor": "SuiLoadFileDialog",
  "dialogElements": [
   {
    "staticText": [
     {
      "label": "Datei laden"
     }
    ]
   }
  ]
 },
 {
  "ctor": "SuiSaveFileDialog",
  "dialogElements": [
   {
    "staticText": [
     {
      "label": "Score speichern"
     }
    ]
   }
  ]
 },
 {
  "ctor": "SuiPrintFileDialog",
  "dialogElements": [
   {
    "staticText": [
     {
      "label": "Druck abgeschlossen"
     }
    ]
   }
  ]
 },
 {
  "ctor": "SuiMeasureDialog",
  "dialogElements": [
   {
    "staticText": [
     {
      "label": "Takt Voreinstellungen"
     }
    ]
   },
   {
    "id": "pickupMeasure",
    "label": "Takt Pickup",
    "options": [
     {
      "value": "2048",
      "label": "Eighth Note"
     },
     {
      "value": "4096",
      "label": "Quarter Note"
     },
     {
      "value": "6144",
      "label": "Dotted Quarter"
     },
     {
      "value": "8192",
      "label": "Half Note"
     }
    ]
   },
   {
    "id": "measureTextPosition",
    "label": "Text Position",
    "options": [
     {
      "value": "2",
      "label": "Left"
     },
     {
      "value": "3",
      "label": "Right"
     },
     {
      "value": "0",
      "label": "Above"
     },
     {
      "value": "1",
      "label": "Below"
     }
    ]
   }
  ]
 },
 {
  "ctor": "SuiTempoDialog",
  "dialogElements": [
   {
    "staticText": [
     {
      "label": "Tempo Voreinstellungen"
     }
    ]
   },
   {
    "id": "tempoMode",
    "label": "Tempo Modus",
    "options": [
     {
      "value": "duration",
      "label": "Dauer (Beats/Minute)"
     },
     {
      "value": "text",
      "label": "Tempo Text"
     },
     {
      "value": "custom",
      "label": "Text und Dauer festlegen"
     }
    ]
   },
   {
    "id": "beatDuration",
    "label": "Einheit für Beat",
    "options": [
     {
      "value": "4096",
      "label": "Quarter Note"
     },
     {
      "value": "2048",
      "label": "1/8 note"
     },
     {
      "value": "6144",
      "label": "Dotted 1/4 note"
     },
     {
      "value": "8192",
      "label": "1/2 note"
     }
    ]
   },
   {
    "id": "tempoText",
    "label": "Tempo Text",
    "options": [
     {
      "value": "Larghissimo",
      "label": "Larghissimo"
     },
     {
      "value": "Grave",
      "label": "Grave"
     },
     {
      "value": "Lento",
      "label": "Lento"
     },
     {
      "value": "Largo",
      "label": "Largo"
     },
     {
      "value": "Larghetto",
      "label": "Larghetto"
     },
     {
      "value": "Adagio",
      "label": "Adagio"
     },
     {
      "value": "Adagietto",
      "label": "Adagietto"
     },
     {
      "value": "Andante moderato",
      "label": "Andante moderato"
     },
     {
      "value": "Andante",
      "label": "Andante"
     },
     {
      "value": "Andantino",
      "label": "Andantino"
     },
     {
      "value": "Moderato",
      "label": "Moderato"
     },
     {
      "value": "Allegretto",
      "label": "Allegretto"
     },
     {
      "value": "Allegro",
      "label": "Allegro"
     },
     {
      "value": "Vivace",
      "label": "Vivace"
     },
     {
      "value": "Presto",
      "label": "Presto"
     },
     {
      "value": "Prestissimo",
      "label": "Prestissimo"
     }
    ]
   }
  ]
 },
 {
  "ctor": "SuiInstrumentDialog",
  "dialogElements": [
   {
    "staticText": [
     {
      "label": "Instrument Properties"
     }
    ]
   },
   {
    "id": "applyTo",
    "label": "Apply To",
    "options": [
     {
      "value": "0",
      "label": "Score"
     },
     {
      "value": "1",
      "label": "Selected Measures"
     },
     {
      "value": "3",
      "label": "Remaining Measures"
     }
    ]
   }
  ]
 },
 {
  "ctor": "SuiTimeSignatureDialog",
  "dialogElements": [
   {
    "staticText": [
     {
      "label": "Custom Time Signature"
     }
    ]
   },
   {
    "id": "denominator",
    "label": "Beat Value",
    "options": [
     {
      "value": "8",
      "label": "8"
     },
     {
      "value": "4",
      "label": "4"
     },
     {
      "value": "2",
      "label": "2"
     }
    ]
   }
  ]
 },
 {
  "ctor": "SuiLayoutDialog",
  "dialogElements": [
   {
    "id": "pageSize",
    "label": "Seitengröße",
    "options": [
     {
      "value": "letter",
      "label": "Brief"
     },
     {
      "value": "tabloid",
      "label": "Tabloid (11x17)"
     },
     {
      "value": "A4",
      "label": "A4"
     },
     {
      "value": "custom",
      "label": "benutzerdefiniert"
     }
    ]
   },
   {
    "id": "orientation",
    "label": "Ausrichtung",
    "options": [
     {
      "value": "0",
      "label": "Portrait"
     },
     {
      "value": "1",
      "label": "Landscape"
     }
    ]
   },
   {
    "id": "engravingFont",
    "label": "Schriftart",
    "options": [
     {
      "value": "Bravura",
      "label": "Bravura"
     },
     {
      "value": "Gonville",
      "label": "Gonville"
     },
     {
      "value": "Petaluma",
      "label": "Petaluma"
     }
    ]
   },
   {
    "staticText": [
     {
      "label": "Score Layout"
     }
    ]
   }
  ]
 },
 {
  "ctor": "SuiDynamicModifierDialog",
  "dialogElements": [
   {
    "id": "text",
    "label": "Text",
    "options": [
     {
      "value": "p",
      "label": "Piano"
     },
     {
      "value": "pp",
      "label": "Pianissimo"
     },
     {
      "value": "mp",
      "label": "Mezzo-Piano"
     },
     {
      "value": "mf",
      "label": "Mezzo-Forte"
     },
     {
      "value": "f",
      "label": "Forte"
     },
     {
      "value": "ff",
      "label": "Fortissimo"
     },
     {
      "value": "sfz",
      "label": "Sforzando"
     }
    ]
   },
   {
    "staticText": [
     {
      "label": "Dynamics Properties"
     }
    ]
   }
  ]
 },
 {
  "ctor": "SuiSlurAttributesDialog",
  "dialogElements": [
   {
    "staticText": [
     {
      "label": "Slur Properties"
     }
    ]
   },
   {
    "id": "position",
    "label": "Startposition",
    "options": [
     {
      "value": "1",
      "label": "Head"
     },
     {
      "value": "2",
      "label": "Top"
     }
    ]
   },
   {
    "id": "position_end",
    "label": "Endposition",
    "options": [
     {
      "value": "1",
      "label": "Head"
     },
     {
      "value": "2",
      "label": "Top"
     }
    ]
   }
  ]
 },
 {
  "ctor": "SuiVoltaAttributeDialog",
  "dialogElements": [
   {
    "staticText": [
     {
      "label": "Volta Properties"
     }
    ]
   }
  ]
 },
 {
  "ctor": "SuiHairpinAttributesDialog",
  "dialogElements": [
   {
    "staticText": [
     {
      "label": "Hairpin Properties"
     }
    ]
   }
  ]
 },
 {
  "ctor": "SuiLyricDialog",
  "dialogElements": [
   {
    "id": "verse",
    "label": "Verse",
    "options": [
     {
      "value": "0",
      "label": "1"
     },
     {
      "value": "1",
      "label": "2"
     },
     {
      "value": "2",
      "label": "3"
     }
    ]
   },
   {
    "id": "textEditor",
    "label": "Edit Text",
    "options": []
   },
   {
    "staticText": [
     {
      "doneEditing": "Done Editing Lyrics"
     },
     {
      "undo": "Undo Lyrics"
     },
     {
      "label": "Lyric Editor"
     }
    ]
   }
  ]
 },
 {
  "ctor": "SuiChordChangeDialog",
  "dialogElements": [
   {
    "id": "verse",
    "label": "Verse",
    "options": [
     {
      "value": "0",
      "label": "1"
     },
     {
      "value": "1",
      "label": "2"
     },
     {
      "value": "2",
      "label": "3"
     }
    ]
   },
   {
    "id": "textEditor",
    "label": "Edit Text",
    "options": []
   },
   {
    "staticText": [
     {
      "doneEditing": "Done Editing Lyrics"
     },
     {
      "undo": "Undo Lyrics"
     },
     {
      "label": "Lyric Editor"
     }
    ]
   }
  ]
 },
 {
  "ctor": "SuiTextTransformDialog",
  "dialogElements": [
   {
    "id": "textEditor",
    "label": "Edit Text",
    "options": []
   },
   {
    "id": "textDragger",
    "label": "Move Text",
    "options": []
   },
   {
    "id": "textResizer",
    "label": "Resize Text",
    "options": []
   },
   {
    "id": "justification",
    "label": "Justification",
    "options": [
     {
      "value": "left",
      "label": "Left"
     },
     {
      "value": "right",
      "label": "Right"
     },
     {
      "value": "center",
      "label": "Center"
     }
    ]
   },
   {
    "id": "fontFamily",
    "label": "Font Family",
    "options": [
     {
      "value": "Merriweather,serif",
      "label": "Serif"
     },
     {
      "value": "Roboto,sans-serif",
      "label": "Sans-Serif"
     },
     {
      "value": "monospace",
      "label": "Monospace"
     },
     {
      "value": "cursive",
      "label": "Cursive"
     },
     {
      "value": "Merriweather",
      "label": "times"
     },
     {
      "value": "Arial",
      "label": "arial"
     },
     {
      "value": "Helvetica",
      "label": "Helvetica"
     }
    ]
   },
   {
    "id": "fontUnit",
    "label": "Units",
    "options": [
     {
      "value": "em",
      "label": "em"
     },
     {
      "value": "px",
      "label": "px"
     },
     {
      "value": "pt",
      "label": "pt"
     }
    ]
   },
   {
    "id": "pagination",
    "label": "Page Behavior",
    "options": [
     {
      "value": "once",
      "label": "Once"
     },
     {
      "value": "every",
      "label": "Every"
     },
     {
      "value": "even",
      "label": "Even"
     },
     {
      "value": "odd",
      "label": "Odd"
     },
     {
      "value": "subsequent",
      "label": "Subsequent"
     }
    ]
   },
   {
    "staticText": [
     {
      "label": "Text Properties"
     }
    ]
   }
  ]
 },
 {
  "ctor": "SuiAddStaffMenu",
  "label": "Notenschlüssel",
  "menuItems": [
   {
    "value": "trebleInstrument",
    "text": "Violinschlüssel"
   },
   {
    "value": "bassInstrument",
    "text": "Basschlüssel"
   },
   {
    "value": "altoInstrument",
    "text": "Altschlüssel"
   },
   {
    "value": "tenorInstrument",
    "text": "Tenorschlüssel"
   },
   {
    "value": "remove",
    "text": "Notenschlüssel entfernen"
   },
   {
    "value": "cancel",
    "text": "Abbrechen"
   }
  ]
 },
 {
  "ctor": "SuiMeasureMenu",
  "label": "Measure",
  "menuItems": [
   {
    "value": "addMenuBeforeCmd",
    "text": "Add Measure Before"
   },
   {
    "value": "addMenuAfterCmd",
    "text": "Add Measure After"
   },
   {
    "value": "deleteSelected",
    "text": "Delete Selected Measures"
   },
   {
    "value": "formatMeasureDialog",
    "text": "Format Measure"
   },
   {
    "value": "cancel",
    "text": "Cancel"
   }
  ]
 },
 {
  "ctor": "SuiFileMenu",
  "label": "Datei",
  "menuItems": [
   {
    "value": "newFile",
    "text": "Neu"
   },
   {
    "value": "openFile",
    "text": "Öffnen"
   },
   {
    "value": "saveFile",
    "text": "Speichern"
   },
   {
    "value": "quickSave",
    "text": "Schnellspeichern"
   },
   {
    "value": "printScore",
    "text": "Drucken"
   },
   {
    "value": "bach",
    "text": "Bach Invention"
   },
   {
    "value": "bambino",
    "text": "Jesu Bambino"
   },
   {
    "value": "microtone",
    "text": "Microtone Sample"
   },
   {
    "value": "preciousLord",
    "text": "Precious Lord"
   },
   {
    "value": "yamaJson",
    "text": "Yama"
   },
   {
    "value": "cancel",
    "text": "Abbrechen"
   }
  ]
 },
 {
  "ctor": "SuiTimeSignatureMenu",
  "label": "Taktzeit",
  "menuItems": [
   {
    "value": "6/8",
    "text": "6/8"
   },
   {
    "value": "3/4",
    "text": "3/4"
   },
   {
    "value": "2/4",
    "text": "2/4"
   },
   {
    "value": "12/8",
    "text": "12/8"
   },
   {
    "value": "7/8",
    "text": "7/8"
   },
   {
    "value": "5/8",
    "text": "5/8"
   },
   {
    "value": "TimeSigOther",
    "text": "benutzerdefiniert"
   },
   {
    "value": "cancel",
    "text": "Abbrechen"
   }
  ]
 },
 {
  "ctor": "SuiKeySignatureMenu",
  "label": "Tonlage",
  "menuItems": [
   {
    "value": "KeyOfC",
    "text": "C Major"
   },
   {
    "value": "KeyOfF",
    "text": "F Major"
   },
   {
    "value": "KeyOfG",
    "text": "G Major"
   },
   {
    "value": "KeyOfBb",
    "text": "Bb Major"
   },
   {
    "value": "KeyOfD",
    "text": "D Major"
   },
   {
    "value": "KeyOfEb",
    "text": "Eb Major"
   },
   {
    "value": "KeyOfA",
    "text": "A Major"
   },
   {
    "value": "KeyOfAb",
    "text": "Ab Major"
   },
   {
    "value": "KeyOfE",
    "text": "E Major"
   },
   {
    "value": "KeyOfDb",
    "text": "Db Major"
   },
   {
    "value": "KeyOfB",
    "text": "B Major"
   },
   {
    "value": "KeyOfF#",
    "text": "F# Major"
   },
   {
    "value": "KeyOfC#",
    "text": "C# Major"
   },
   {
    "value": "cancel",
    "text": "Abbrechen"
   }
  ]
 },
 {
  "ctor": "SuiTimeSignatureMenu",
  "label": "Taktzeit",
  "menuItems": [
   {
    "value": "6/8",
    "text": "6/8"
   },
   {
    "value": "3/4",
    "text": "3/4"
   },
   {
    "value": "2/4",
    "text": "2/4"
   },
   {
    "value": "12/8",
    "text": "12/8"
   },
   {
    "value": "7/8",
    "text": "7/8"
   },
   {
    "value": "5/8",
    "text": "5/8"
   },
   {
    "value": "TimeSigOther",
    "text": "benutzerdefiniert"
   },
   {
    "value": "cancel",
    "text": "Abbrechen"
   }
  ]
 },
 {
  "ctor": "SuiKeySignatureMenu",
  "label": "Tonlage",
  "menuItems": [
   {
    "value": "KeyOfC",
    "text": "C Major"
   },
   {
    "value": "KeyOfF",
    "text": "F Major"
   },
   {
    "value": "KeyOfG",
    "text": "G Major"
   },
   {
    "value": "KeyOfBb",
    "text": "Bb Major"
   },
   {
    "value": "KeyOfD",
    "text": "D Major"
   },
   {
    "value": "KeyOfEb",
    "text": "Eb Major"
   },
   {
    "value": "KeyOfA",
    "text": "A Major"
   },
   {
    "value": "KeyOfAb",
    "text": "Ab Major"
   },
   {
    "value": "KeyOfE",
    "text": "E Major"
   },
   {
    "value": "KeyOfDb",
    "text": "Db Major"
   },
   {
    "value": "KeyOfB",
    "text": "B Major"
   },
   {
    "value": "KeyOfF#",
    "text": "F# Major"
   },
   {
    "value": "KeyOfC#",
    "text": "C# Major"
   },
   {
    "value": "cancel",
    "text": "Abbrechen"
   }
  ]
 },
 {
  "ctor": "SuiStaffModifierMenu",
  "label": "Lines",
  "menuItems": [
   {
    "value": "crescendo",
    "text": "Crescendo"
   },
   {
    "value": "decrescendo",
    "text": "Decrescendo"
   },
   {
    "value": "slur",
    "text": "Bogen/Bindung"
   },
   {
    "value": "ending",
    "text": "nth Ende"
   },
   {
    "value": "cancel",
    "text": "Abbrechen"
   }
  ]
 },
 {
  "ctor": "SuiDynamicsMenu",
  "label": "Dynamics",
  "menuItems": [
   {
    "value": "pp",
    "text": "Pianissimo"
   },
   {
    "value": "p",
    "text": "Piano"
   },
   {
    "value": "mp",
    "text": "Mezzo-piano"
   },
   {
    "value": "mf",
    "text": "Mezzo-forte"
   },
   {
    "value": "f",
    "text": "Forte"
   },
   {
    "value": "ff",
    "text": "Fortissimo"
   },
   {
    "value": "sfz",
    "text": "sfortzando"
   },
   {
    "value": "cancel",
    "text": "Abbrechen"
   }
  ]
 },
 {
  "ctor": "SuiLanguageMenu",
  "label": "Language",
  "menuItems": [
   {
    "value": "en",
    "text": "English"
   },
   {
    "value": "de",
    "text": "Deutsch"
   },
   {
    "value": "ar",
    "text": "اَلْعَرَبِيَّةُ"
   },
   {
    "value": "cancel",
    "text": "Cancel"
   }
  ]
 },
 {
  "ribbonText": [
   {
    "buttonId": "helpDialog",
    "buttonText": "(de)Help"
   },
   {
    "buttonId": "languageMenu",
    "buttonText": "Language"
   },
   {
    "buttonId": "fileMenu",
    "buttonText": "File"
   },
   {
    "buttonId": "addStaffMenu",
    "buttonText": "Staves"
   },
   {
    "buttonId": "measureModal",
    "buttonText": "Measure"
   },
   {
    "buttonId": "tempoModal",
    "buttonText": "Tempo"
   },
   {
    "buttonId": "timeSignatureMenu",
    "buttonText": "Time Signature"
   },
   {
    "buttonId": "keyMenu",
    "buttonText": "Key"
   },
   {
    "buttonId": "staffModifierMenu",
    "buttonText": "Lines"
   },
   {
    "buttonId": "instrumentModal",
    "buttonText": "Instrument"
   },
   {
    "buttonId": "pianoModal",
    "buttonText": "Piano"
   },
   {
    "buttonId": "layoutModal",
    "buttonText": "Layout"
   },
   {
    "buttonId": "UpOctaveButton",
    "buttonText": "8va"
   },
   {
    "buttonId": "DownOctaveButton",
    "buttonText": "8vb"
   },
   {
    "buttonId": "moreNavButtons",
    "buttonText": "..."
   },
   {
    "buttonId": "dcAlCoda",
    "buttonText": "DC Al Coda"
   },
   {
    "buttonId": "dsAlCoda",
    "buttonText": "DS Al Coda"
   },
   {
    "buttonId": "dcAlFine",
    "buttonText": "DC Al Fine"
   },
   {
    "buttonId": "dsAlFine",
    "buttonText": "DS Al Fine"
   },
   {
    "buttonId": "toCoda",
    "buttonText": "to "
   },
   {
    "buttonId": "fine",
    "buttonText": "Fine"
   },
   {
    "buttonId": "moreStaffButtons",
    "buttonText": "..."
   }
  ]
 }
]`;
;
var smoLanguageStringAr = `[
 {
  "ctor": "SuiLoadFileDialog",
  "dialogElements": [
   {
    "staticText": [
     {
      "label": "Load File"
     }
    ]
   }
  ]
 },
 {
  "ctor": "SuiSaveFileDialog",
  "dialogElements": [
   {
    "staticText": [
     {
      "label": "Save Score"
     }
    ]
   }
  ]
 },
 {
  "ctor": "SuiPrintFileDialog",
  "dialogElements": [
   {
    "staticText": [
     {
      "label": "Print Complete"
     }
    ]
   }
  ]
 },
 {
  "ctor": "SuiMeasureDialog",
  "dialogElements": [
   {
    "staticText": [
     {
      "label": "Measure Properties"
     }
    ]
   },
   {
    "id": "pickupMeasure",
    "label": "Pickup Measure",
    "options": [
     {
      "value": "2048",
      "label": "Eighth Note"
     },
     {
      "value": "4096",
      "label": "Quarter Note"
     },
     {
      "value": "6144",
      "label": "Dotted Quarter"
     },
     {
      "value": "8192",
      "label": "Half Note"
     }
    ]
   },
   {
    "id": "measureTextPosition",
    "label": "Text Position",
    "options": [
     {
      "value": "2",
      "label": "Left"
     },
     {
      "value": "3",
      "label": "Right"
     },
     {
      "value": "0",
      "label": "Above"
     },
     {
      "value": "1",
      "label": "Below"
     }
    ]
   }
  ]
 },
 {
  "ctor": "SuiTempoDialog",
  "dialogElements": [
   {
    "staticText": [
     {
      "label": "Tempo Properties"
     }
    ]
   },
   {
    "id": "tempoMode",
    "label": "وضع الإيقاع",
    "options": [
     {
      "value": "duration",
      "label": "Duration (Beats/Minute)"
     },
     {
      "value": "text",
      "label": "Tempo Text"
     },
     {
      "value": "custom",
      "label": "Specify text and duration"
     }
    ]
   },
   {
    "id": "beatDuration",
    "label": "وحدة لكل ضربه",
    "options": [
     {
      "value": "4096",
      "label": "Quarter Note"
     },
     {
      "value": "2048",
      "label": "1/8 note"
     },
     {
      "value": "6144",
      "label": "Dotted 1/4 note"
     },
     {
      "value": "8192",
      "label": "1/2 note"
     }
    ]
   },
   {
    "id": "tempoText",
    "label": "Tempo Text",
    "options": [
     {
      "value": "Larghissimo",
      "label": "Larghissimo"
     },
     {
      "value": "Grave",
      "label": "Grave"
     },
     {
      "value": "Lento",
      "label": "Lento"
     },
     {
      "value": "Largo",
      "label": "Largo"
     },
     {
      "value": "Larghetto",
      "label": "Larghetto"
     },
     {
      "value": "Adagio",
      "label": "Adagio"
     },
     {
      "value": "Adagietto",
      "label": "Adagietto"
     },
     {
      "value": "Andante moderato",
      "label": "Andante moderato"
     },
     {
      "value": "Andante",
      "label": "Andante"
     },
     {
      "value": "Andantino",
      "label": "Andantino"
     },
     {
      "value": "Moderato",
      "label": "Moderato"
     },
     {
      "value": "Allegretto",
      "label": "Allegretto"
     },
     {
      "value": "Allegro",
      "label": "Allegro"
     },
     {
      "value": "Vivace",
      "label": "Vivace"
     },
     {
      "value": "Presto",
      "label": "Presto"
     },
     {
      "value": "Prestissimo",
      "label": "Prestissimo"
     }
    ]
   }
  ]
 },
 {
  "ctor": "SuiInstrumentDialog",
  "dialogElements": [
   {
    "staticText": [
     {
      "label": "Instrument Properties"
     }
    ]
   },
   {
    "id": "applyTo",
    "label": "Apply To",
    "options": [
     {
      "value": "0",
      "label": "Score"
     },
     {
      "value": "1",
      "label": "Selected Measures"
     },
     {
      "value": "3",
      "label": "Remaining Measures"
     }
    ]
   }
  ]
 },
 {
  "ctor": "SuiTimeSignatureDialog",
  "dialogElements": [
   {
    "staticText": [
     {
      "label": "Custom Time Signature"
     }
    ]
   },
   {
    "id": "denominator",
    "label": "Beat Value",
    "options": [
     {
      "value": "8",
      "label": "8"
     },
     {
      "value": "4",
      "label": "4"
     },
     {
      "value": "2",
      "label": "2"
     }
    ]
   }
  ]
 },
 {
  "ctor": "SuiLayoutDialog",
  "dialogElements": [
   {
    "id": "pageSize",
    "label": "Page Size",
    "options": [
     {
      "value": "letter",
      "label": "Letter"
     },
     {
      "value": "tabloid",
      "label": "Tabloid (11x17)"
     },
     {
      "value": "A4",
      "label": "A4"
     },
     {
      "value": "custom",
      "label": "Custom"
     }
    ]
   },
   {
    "id": "orientation",
    "label": "Orientation",
    "options": [
     {
      "value": "0",
      "label": "Portrait"
     },
     {
      "value": "1",
      "label": "Landscape"
     }
    ]
   },
   {
    "id": "engravingFont",
    "label": "Engraving Font",
    "options": [
     {
      "value": "Bravura",
      "label": "Bravura"
     },
     {
      "value": "Gonville",
      "label": "Gonville"
     },
     {
      "value": "Petaluma",
      "label": "Petaluma"
     }
    ]
   },
   {
    "staticText": [
     {
      "label": "Score Layout"
     }
    ]
   }
  ]
 },
 {
  "ctor": "SuiDynamicModifierDialog",
  "dialogElements": [
   {
    "id": "text",
    "label": "Text",
    "options": [
     {
      "value": "p",
      "label": "Piano"
     },
     {
      "value": "pp",
      "label": "Pianissimo"
     },
     {
      "value": "mp",
      "label": "Mezzo-Piano"
     },
     {
      "value": "mf",
      "label": "Mezzo-Forte"
     },
     {
      "value": "f",
      "label": "Forte"
     },
     {
      "value": "ff",
      "label": "Fortissimo"
     },
     {
      "value": "sfz",
      "label": "Sforzando"
     }
    ]
   },
   {
    "staticText": [
     {
      "label": "Dynamics Properties"
     }
    ]
   }
  ]
 },
 {
  "ctor": "SuiSlurAttributesDialog",
  "dialogElements": [
   {
    "staticText": [
     {
      "label": "Slur Properties"
     }
    ]
   },
   {
    "id": "position",
    "label": "Start Position",
    "options": [
     {
      "value": "1",
      "label": "Head"
     },
     {
      "value": "2",
      "label": "Top"
     }
    ]
   },
   {
    "id": "position_end",
    "label": "End Position",
    "options": [
     {
      "value": "1",
      "label": "Head"
     },
     {
      "value": "2",
      "label": "Top"
     }
    ]
   }
  ]
 },
 {
  "ctor": "SuiVoltaAttributeDialog",
  "dialogElements": [
   {
    "staticText": [
     {
      "label": "Volta Properties"
     }
    ]
   }
  ]
 },
 {
  "ctor": "SuiHairpinAttributesDialog",
  "dialogElements": [
   {
    "staticText": [
     {
      "label": "Hairpin Properties"
     }
    ]
   }
  ]
 },
 {
  "ctor": "SuiLyricDialog",
  "dialogElements": [
   {
    "id": "verse",
    "label": "Verse",
    "options": [
     {
      "value": "0",
      "label": "1"
     },
     {
      "value": "1",
      "label": "2"
     },
     {
      "value": "2",
      "label": "3"
     }
    ]
   },
   {
    "id": "textEditor",
    "label": "Edit Text",
    "options": []
   },
   {
    "staticText": [
     {
      "doneEditing": "Done Editing Lyrics"
     },
     {
      "undo": "Undo Lyrics"
     },
     {
      "label": "Lyric Editor"
     }
    ]
   }
  ]
 },
 {
  "ctor": "SuiChordChangeDialog",
  "dialogElements": [
   {
    "id": "verse",
    "label": "Verse",
    "options": [
     {
      "value": "0",
      "label": "1"
     },
     {
      "value": "1",
      "label": "2"
     },
     {
      "value": "2",
      "label": "3"
     }
    ]
   },
   {
    "id": "textEditor",
    "label": "Edit Text",
    "options": []
   },
   {
    "staticText": [
     {
      "doneEditing": "Done Editing Lyrics"
     },
     {
      "undo": "Undo Lyrics"
     },
     {
      "label": "Lyric Editor"
     }
    ]
   }
  ]
 },
 {
  "ctor": "SuiTextTransformDialog",
  "dialogElements": [
   {
    "id": "textEditor",
    "label": "Edit Text",
    "options": []
   },
   {
    "id": "textDragger",
    "label": "Move Text",
    "options": []
   },
   {
    "id": "textResizer",
    "label": "Resize Text",
    "options": []
   },
   {
    "id": "justification",
    "label": "Justification",
    "options": [
     {
      "value": "left",
      "label": "Left"
     },
     {
      "value": "right",
      "label": "Right"
     },
     {
      "value": "center",
      "label": "Center"
     }
    ]
   },
   {
    "id": "fontFamily",
    "label": "Font Family",
    "options": [
     {
      "value": "Merriweather,serif",
      "label": "Serif"
     },
     {
      "value": "Roboto,sans-serif",
      "label": "Sans-Serif"
     },
     {
      "value": "monospace",
      "label": "Monospace"
     },
     {
      "value": "cursive",
      "label": "Cursive"
     },
     {
      "value": "Merriweather",
      "label": "times"
     },
     {
      "value": "Arial",
      "label": "arial"
     },
     {
      "value": "Helvetica",
      "label": "Helvetica"
     }
    ]
   },
   {
    "id": "fontUnit",
    "label": "Units",
    "options": [
     {
      "value": "em",
      "label": "em"
     },
     {
      "value": "px",
      "label": "px"
     },
     {
      "value": "pt",
      "label": "pt"
     }
    ]
   },
   {
    "id": "pagination",
    "label": "Page Behavior",
    "options": [
     {
      "value": "once",
      "label": "Once"
     },
     {
      "value": "every",
      "label": "Every"
     },
     {
      "value": "even",
      "label": "Even"
     },
     {
      "value": "odd",
      "label": "Odd"
     },
     {
      "value": "subsequent",
      "label": "Subsequent"
     }
    ]
   },
   {
    "staticText": [
     {
      "label": "Text Properties"
     }
    ]
   }
  ]
 },
 {
  "ctor": "SuiAddStaffMenu",
  "label": "المفاتيح",
  "menuItems": [
   {
    "value": "trebleInstrument",
    "text": "طاقم التريبل مفتاح"
   },
   {
    "value": "bassInstrument",
    "text": "طاقم باس كلف"
   },
   {
    "value": "altoInstrument",
    "text": "طاقم ألتو مفتاح"
   },
   {
    "value": "tenorInstrument",
    "text": "طاقم تينور مفتاح"
   },
   {
    "value": "remove",
    "text": "حذف الطواقم"
   },
   {
    "value": "cancel",
    "text": "إلغاء"
   }
  ]
 },
 {
  "ctor": "SuiMeasureMenu",
  "label": "Measure",
  "menuItems": [
   {
    "value": "addMenuBeforeCmd",
    "text": "Add Measure Before"
   },
   {
    "value": "addMenuAfterCmd",
    "text": "Add Measure After"
   },
   {
    "value": "deleteSelected",
    "text": "Delete Selected Measures"
   },
   {
    "value": "formatMeasureDialog",
    "text": "Format Measure"
   },
   {
    "value": "cancel",
    "text": "Cancel"
   }
  ]
 },
 {
  "ctor": "SuiFileMenu",
  "label": "ملف",
  "menuItems": [
   {
    "value": "newFile",
    "text": "جديدe"
   },
   {
    "value": "openFile",
    "text": "فتح"
   },
   {
    "value": "saveFile",
    "text": "حفظ"
   },
   {
    "value": "quickSave",
    "text": "Quick Save"
   },
   {
    "value": "printScore",
    "text": "طباعه"
   },
   {
    "value": "bach",
    "text": "Bach Invention"
   },
   {
    "value": "bambino",
    "text": "Jesu Bambino"
   },
   {
    "value": "microtone",
    "text": "Microtone Sample"
   },
   {
    "value": "preciousLord",
    "text": "Precious Lord"
   },
   {
    "value": "yamaJson",
    "text": "Yama"
   },
   {
    "value": "cancel",
    "text": "إلغاء"
   }
  ]
 },
 {
  "ctor": "SuiTimeSignatureMenu",
  "label": "وزن الإيقاع",
  "menuItems": [
   {
    "value": "6/8",
    "text": "6/8"
   },
   {
    "value": "3/4",
    "text": "3/4"
   },
   {
    "value": "2/4",
    "text": "2/4"
   },
   {
    "value": "12/8",
    "text": "12/8"
   },
   {
    "value": "7/8",
    "text": "7/8"
   },
   {
    "value": "5/8",
    "text": "5/8"
   },
   {
    "value": "TimeSigOther",
    "text": "Other"
   },
   {
    "value": "cancel",
    "text": "Cancel"
   }
  ]
 },
 {
  "ctor": "SuiKeySignatureMenu",
  "label": "الدليل",
  "menuItems": [
   {
    "value": "KeyOfC",
    "text": "C Major"
   },
   {
    "value": "KeyOfF",
    "text": "F Major"
   },
   {
    "value": "KeyOfG",
    "text": "G Major"
   },
   {
    "value": "KeyOfBb",
    "text": "Bb Major"
   },
   {
    "value": "KeyOfD",
    "text": "D Major"
   },
   {
    "value": "KeyOfEb",
    "text": "Eb Major"
   },
   {
    "value": "KeyOfA",
    "text": "A Major"
   },
   {
    "value": "KeyOfAb",
    "text": "Ab Major"
   },
   {
    "value": "KeyOfE",
    "text": "E Major"
   },
   {
    "value": "KeyOfDb",
    "text": "Db Major"
   },
   {
    "value": "KeyOfB",
    "text": "B Major"
   },
   {
    "value": "KeyOfF#",
    "text": "F# Major"
   },
   {
    "value": "KeyOfC#",
    "text": "C# Major"
   },
   {
    "value": "cancel",
    "text": "Cancel"
   }
  ]
 },
 {
  "ctor": "SuiTimeSignatureMenu",
  "label": "وزن الإيقاع",
  "menuItems": [
   {
    "value": "6/8",
    "text": "6/8"
   },
   {
    "value": "3/4",
    "text": "3/4"
   },
   {
    "value": "2/4",
    "text": "2/4"
   },
   {
    "value": "12/8",
    "text": "12/8"
   },
   {
    "value": "7/8",
    "text": "7/8"
   },
   {
    "value": "5/8",
    "text": "5/8"
   },
   {
    "value": "TimeSigOther",
    "text": "Other"
   },
   {
    "value": "cancel",
    "text": "إلغاء"
   }
  ]
 },
 {
  "ctor": "SuiKeySignatureMenu",
  "label": "الدليل",
  "menuItems": [
   {
    "value": "KeyOfC",
    "text": "C Major"
   },
   {
    "value": "KeyOfF",
    "text": "F Major"
   },
   {
    "value": "KeyOfG",
    "text": "G Major"
   },
   {
    "value": "KeyOfBb",
    "text": "Bb Major"
   },
   {
    "value": "KeyOfD",
    "text": "D Major"
   },
   {
    "value": "KeyOfEb",
    "text": "Eb Major"
   },
   {
    "value": "KeyOfA",
    "text": "A Major"
   },
   {
    "value": "KeyOfAb",
    "text": "Ab Major"
   },
   {
    "value": "KeyOfE",
    "text": "E Major"
   },
   {
    "value": "KeyOfDb",
    "text": "Db Major"
   },
   {
    "value": "KeyOfB",
    "text": "B Major"
   },
   {
    "value": "KeyOfF#",
    "text": "F# Major"
   },
   {
    "value": "KeyOfC#",
    "text": "C# Major"
   },
   {
    "value": "cancel",
    "text": "Cancel"
   }
  ]
 },
 {
  "ctor": "SuiStaffModifierMenu",
  "label": "خطوط",
  "menuItems": [
   {
    "value": "crescendo",
    "text": "تصاعد"
   },
   {
    "value": "decrescendo",
    "text": "تهابط"
   },
   {
    "value": "slur",
    "text": "طمس / تعادل"
   },
   {
    "value": "ending",
    "text": "النهاية التاسعة"
   },
   {
    "value": "cancel",
    "text": "إلغاء"
   }
  ]
 },
 {
  "ctor": "SuiDynamicsMenu",
  "label": "Dynamics",
  "menuItems": [
   {
    "value": "pp",
    "text": "Pianissimo"
   },
   {
    "value": "p",
    "text": "Piano"
   },
   {
    "value": "mp",
    "text": "Mezzo-piano"
   },
   {
    "value": "mf",
    "text": "Mezzo-forte"
   },
   {
    "value": "f",
    "text": "Forte"
   },
   {
    "value": "ff",
    "text": "Fortissimo"
   },
   {
    "value": "sfz",
    "text": "sfortzando"
   },
   {
    "value": "cancel",
    "text": "Cancel"
   }
  ]
 }
]`;


var quickStartHtmlar = `(Arabic)
    <h3 id="quick-start-guide">Quick start guide</h3>
<p>If you don&#39;t like to read instructions, this cook&#39;s tour of Smoosic was made for you.</p>
<ul>
<li><p>One of buttons on the left is called &#39;File&#39;.  Click on it. The menu items before &#39;cancel&#39; are pre-canned projects that you can use as a template to get you started.</p>
</li>
<li><p>The cursor keys will navigate you to the different notes.</p>
</li>
<li><p>Letters a-g on the computer keyboard change the note to those pitches</p>
</li>
<li><p>&#39;Insert&#39; adds a new, blank measure.</p>
</li>
<li><p>The ribbon of thick blue buttons on the top expand to button groups, that contain most of the functionality of Smoosic.  </p>
</li>
<li><p>The buttons on the left bring up menus or dialogs that do basically what the buttons say.</p>
</li>
<li><p>There are a few &#39;instant gratification&#39; buttons for playing the music, refreshing the screen or changing the zoom level on the left part of the ribbon.</p>
</li>
<li><p>The piano tool is an alternate way of entering music, or can be dismissed by the close button in the lower left.</p>
</li>
</ul>
<p><img src="https://imgur.com/nP16PMI.gif" alt="" width="640" height="480"></p>
`;


var selectionHtmlar = `(Arabic)
<h3 id="selecting-things">Selecting things</h3>
<p>Almost all operations in Smoosic act on the selected music.  You can select notes in different ways:</p>
<ol>
<li>with the computer mouse</li>
<li>with the keyboard&#39;s navigation keys</li>
<li>with the navigation keys on the ribbon</li>
<li>with the piano tool, to some extent.</li>
</ol>
<p><img src="https://imgur.com/q1qK3Pn.gif" alt=""></p>
<p>You can select multiple things with the keyboard navigation keys, by selecting &#39;shift-arrow&#39;, just like many applications.  There is a similar control for selection in the navigation ribbon.  Some operations, like changing pitch for instance, act on all the selected notes.</p>
<p>Sometimes a selection of one line affects all the measures in that column (or all the measures of the system, if you like).  When you change the key, for instance, the selection determines where the key change starts.  If you have multiple measures selected, it applies to those measures, and then changes back to whatever it was before.</p>
`;


var enterDurationsHtmlar = `(Arabic)
<p>Note duration in Smoosic is done by changing the duration of an existing note.  Usually, doubling the duration or cutting it in two, or adding a dot - duration to a note.  You can also create tuplets for uneven sets of notes (3, 5, or 7).</p>
<p>There are actually 3 ways to do many duration operations - using the piano tool, using the computer keyboard, or using the button ribbon.  Like with many things, you should find entering duration using the keyboard fastest, once you have some experience with Smoosic.  But the ribbon or the </p>
<h2 id="changing-note-length-with-the-keyboard">Changing note length with the keyboard</h2>
<p>You can change the length of notes using the &#39;,&#39; and &#39;.&#39; (comma and period) keys, which halve and double the note lengths, respectively.  You can add a dot to the length of the note (multiplying length by 3/2 for the first dot, and 3/4 for the second dot, if you like to think of it that way) or remove a dot, using the &#39;&gt;&#39; and &#39;&lt;&#39;.  The mnemonic device for these is &#39;&gt;&#39; makes note duration greater.  &#39;&lt;&#39; makes note duration...less.  (On most QWERTY keyboards, comma shifted is &#39;&lt;&#39; and period shifted is &#39;&gt;&#39;).</p>
<p><img src="https://imgur.com/5ZWq2Xe.gif" alt=""></p>
<p>Note how the selection is preserved as the notes get shorter.  When you change something, Smoosic will try to keep the selection as close as possible to what you had.  You can use the cursor navigation keys to move to a specific selected note.</p>
<p><img src="https://imgur.com/woMw4RH.gif" alt=""></p>
<p>When you increase the length of a note, Smoosic always &#39;borrows&#39; from the next note in the measure that is eligible.  So when you double the length of the 8th note, it combines the 16th, and 2 32nd notes, and collapses them into a single quarter.  If Smoosic can&#39;t honor the request, it does nothing.  For instance, it can&#39;t remove the dot from a note with no dot, and it can&#39;t extend beyond the length of the measure.</p>
<p>You can create tuplets from the keyboard by typing Ctrl-3, Ctrl-5 or Ctrl-7 for triplets, quintuplets, and septuplets, respectively.  Individual notes in a tuplet can be doubled and halved with the duration keys &#39;-&#39; (minus) and &#39;=&#39; (equals), just like non-tuplets.  You &#39;untupletify&#39; a tuplet by Ctrl-0.</p>
<p><img src="https://imgur.com/uBpQwXD.gif" alt=""></p>
<h2 id="changing-note-length-with-piano-widget">Changing note length with piano widget</h2>
<p>The piano widget is shown when the application starts, and can be restored from the left menu &#39;Piano&#39; button when closed.</p>
<p>You can double or halve note duration, or add dot duration, to a note using the piano tool. </p>
<p><img src="https://imgur.com/Rw4yDxP.gif" alt=""></p>
<h2 id="changing-note-length-from-the-button-ribbon">Changing note length from the button ribbon</h2>
<p>All the duration commands can be accomplished from the ribbon buttons.  </p>
<p><img src="https://imgur.com/n9bmamg.gif" alt=""></p>
<p>Note that the equivalent keyboard commands are also indicated on the right of each button, when it&#39;s available.  (there are only so many keys, so there are some ribbon buttons with no key shortcut). </p>
`;


var enterPitchesHtmlar = `(Arabic)
<p>There are a few ways to enter notes in Smoosic.  You can click on the piano widget keys, or you can enter notes directly from the keyboard.</p>
<h2 id="your-first-smoosical-notes">Your first Smoosical notes</h2>
<h3 id="notes-from-the-keyboard">Notes from the keyboard</h3>
<p>The keys a-g on the computer keyboard will enter a corresponding note, A-G, on the staff (Most key commands in Smoosic have a mnemonic device).  The default behavior is for the cursor to advance when a note is entered in this way.  (Future behavior, auto-advance can be overridden). You navigate to the notes using the keyboard navigation arrows.</p>
<p><img src="https://imgur.com/lxR0NI7.gif" alt=""></p>
<p>You change the octave from the keyboard using the &#39;_&#39; and &#39;+&#39; (underscore, aka shift-minus, and plus), and change notes chromatically using &#39;-&#39; and &#39;=&#39; key.  The mnemonic device for this is &#39;plus and minus&#39; for raising and lowering pitches.  You can change the enharmonic spelling of the note using the &#39;Shift-E&#39; (mnemonic: E for enharmonic - get it?).  And Shift-F gives you a courtesy, or cautionary, accidental (mnemonic - F comes after E).</p>
<p><img src="https://imgur.com/1tC94sV.gif" alt=""></p>
<p>You can create chords and intervals using the number keys along the top of the keyboard.  The &#39;3&#39; key makes a third, the &#39;4&#39; key a fourth, and so on.  Shift+number gives you the interval down.</p>
<p><img src="https://imgur.com/IwoeWi3.gif" alt=""></p>
<p>Note that the interval starts from the highest note in the chord, for intervals going up, and the lowest note in the chord, for intervals going down.  You can select individual pitches in the chord using &#39;Shift-Up Arrow&#39; as shown.  This is similar to how modifiers like dynamics are selected.  Once you have the pitch selected, you can change it using the up-down commands shows above, or change the enharmonic spelling.</p>
<p>There is currently no way to remove a single pitch from the chord.  If you want to collapse the chord, just type a letter a-g on the keyboard, and it will be replaced with a single note.</p>
<h3 id="notes-from-the-piano-tool">Notes from the piano tool</h3>
<p>You can also add notes to your score with the piano tool, by clicking on the corresponding notes.</p>
<p><img src="https://imgur.com/MOMlIg3.gif" alt=""></p>
<p>Clicking on the piano gives the selected note the piano pitch.  The octave of the note is based on the clef, so for treble clef, the &#39;C&#39; is middle &#39;C&#39;.  You can change the octave of the note, and move the pitch up and down.  The top buttons affect the pitch, and the bottom buttons navigate or change the length of the note.  Clicking on the chord button acts like a &#39;sustain&#39; that puts additional notes in chords.</p>
<p>Everything that can be done from the piano widget, and most things in Smoosic generally, can be done more efficiently with keyboard commands. Once you are comfortable with the computer keyboard, you can free up some screen real-estate by closing the piano widget (cross control in lower left).  You can bring it up again with the piano menu button on the left.</p>
`;
;
var smoLanguageStringEn = `[
 {
  "ctor": "SuiLoadFileDialog",
  "dialogElements": [
   {
    "staticText": [
     {
      "label": "Load File"
     }
    ]
   }
  ]
 },
 {
  "ctor": "SuiSaveFileDialog",
  "dialogElements": [
   {
    "staticText": [
     {
      "label": "Save Score"
     }
    ]
   }
  ]
 },
 {
  "ctor": "SuiPrintFileDialog",
  "dialogElements": [
   {
    "staticText": [
     {
      "label": "Print Complete"
     }
    ]
   }
  ]
 },
 {
  "ctor": "SuiMeasureDialog",
  "dialogElements": [
   {
    "staticText": [
     {
      "label": "Measure Properties"
     }
    ]
   },
   {
    "id": "pickupMeasure",
    "label": "Pickup Measure",
    "options": [
     {
      "value": "2048",
      "label": "Eighth Note"
     },
     {
      "value": "4096",
      "label": "Quarter Note"
     },
     {
      "value": "6144",
      "label": "Dotted Quarter"
     },
     {
      "value": "8192",
      "label": "Half Note"
     }
    ]
   },
   {
    "id": "measureTextPosition",
    "label": "Text Position",
    "options": [
     {
      "value": "2",
      "label": "Left"
     },
     {
      "value": "3",
      "label": "Right"
     },
     {
      "value": "0",
      "label": "Above"
     },
     {
      "value": "1",
      "label": "Below"
     }
    ]
   }
  ]
 },
 {
  "ctor": "SuiTempoDialog",
  "dialogElements": [
   {
    "staticText": [
     {
      "label": "Tempo Properties"
     }
    ]
   },
   {
    "id": "tempoMode",
    "label": "Tempo Mode",
    "options": [
     {
      "value": "duration",
      "label": "Duration (Beats/Minute)"
     },
     {
      "value": "text",
      "label": "Tempo Text"
     },
     {
      "value": "custom",
      "label": "Specify text and duration"
     }
    ]
   },
   {
    "id": "beatDuration",
    "label": "Unit for Beat",
    "options": [
     {
      "value": "4096",
      "label": "Quarter Note"
     },
     {
      "value": "2048",
      "label": "1/8 note"
     },
     {
      "value": "6144",
      "label": "Dotted 1/4 note"
     },
     {
      "value": "8192",
      "label": "1/2 note"
     }
    ]
   },
   {
    "id": "tempoText",
    "label": "Tempo Text",
    "options": [
     {
      "value": "Larghissimo",
      "label": "Larghissimo"
     },
     {
      "value": "Grave",
      "label": "Grave"
     },
     {
      "value": "Lento",
      "label": "Lento"
     },
     {
      "value": "Largo",
      "label": "Largo"
     },
     {
      "value": "Larghetto",
      "label": "Larghetto"
     },
     {
      "value": "Adagio",
      "label": "Adagio"
     },
     {
      "value": "Adagietto",
      "label": "Adagietto"
     },
     {
      "value": "Andante moderato",
      "label": "Andante moderato"
     },
     {
      "value": "Andante",
      "label": "Andante"
     },
     {
      "value": "Andantino",
      "label": "Andantino"
     },
     {
      "value": "Moderato",
      "label": "Moderato"
     },
     {
      "value": "Allegretto",
      "label": "Allegretto"
     },
     {
      "value": "Allegro",
      "label": "Allegro"
     },
     {
      "value": "Vivace",
      "label": "Vivace"
     },
     {
      "value": "Presto",
      "label": "Presto"
     },
     {
      "value": "Prestissimo",
      "label": "Prestissimo"
     }
    ]
   }
  ]
 },
 {
  "ctor": "SuiInstrumentDialog",
  "dialogElements": [
   {
    "staticText": [
     {
      "label": "Instrument Properties"
     }
    ]
   },
   {
    "id": "applyTo",
    "label": "Apply To",
    "options": [
     {
      "value": "0",
      "label": "Score"
     },
     {
      "value": "1",
      "label": "Selected Measures"
     },
     {
      "value": "3",
      "label": "Remaining Measures"
     }
    ]
   }
  ]
 },
 {
  "ctor": "SuiTimeSignatureDialog",
  "dialogElements": [
   {
    "staticText": [
     {
      "label": "Custom Time Signature"
     }
    ]
   },
   {
    "id": "denominator",
    "label": "Beat Value",
    "options": [
     {
      "value": "8",
      "label": "8"
     },
     {
      "value": "4",
      "label": "4"
     },
     {
      "value": "2",
      "label": "2"
     }
    ]
   }
  ]
 },
 {
  "ctor": "SuiLayoutDialog",
  "dialogElements": [
   {
    "id": "pageSize",
    "label": "Page Size",
    "options": [
     {
      "value": "letter",
      "label": "Letter"
     },
     {
      "value": "tabloid",
      "label": "Tabloid (11x17)"
     },
     {
      "value": "A4",
      "label": "A4"
     },
     {
      "value": "custom",
      "label": "Custom"
     }
    ]
   },
   {
    "id": "orientation",
    "label": "Orientation",
    "options": [
     {
      "value": "0",
      "label": "Portrait"
     },
     {
      "value": "1",
      "label": "Landscape"
     }
    ]
   },
   {
    "id": "engravingFont",
    "label": "Engraving Font",
    "options": [
     {
      "value": "Bravura",
      "label": "Bravura"
     },
     {
      "value": "Gonville",
      "label": "Gonville"
     },
     {
      "value": "Petaluma",
      "label": "Petaluma"
     }
    ]
   },
   {
    "staticText": [
     {
      "label": "Score Layout"
     }
    ]
   }
  ]
 },
 {
  "ctor": "SuiDynamicModifierDialog",
  "dialogElements": [
   {
    "id": "text",
    "label": "Text",
    "options": [
     {
      "value": "p",
      "label": "Piano"
     },
     {
      "value": "pp",
      "label": "Pianissimo"
     },
     {
      "value": "mp",
      "label": "Mezzo-Piano"
     },
     {
      "value": "mf",
      "label": "Mezzo-Forte"
     },
     {
      "value": "f",
      "label": "Forte"
     },
     {
      "value": "ff",
      "label": "Fortissimo"
     },
     {
      "value": "sfz",
      "label": "Sforzando"
     }
    ]
   },
   {
    "staticText": [
     {
      "label": "Dynamics Properties"
     }
    ]
   }
  ]
 },
 {
  "ctor": "SuiSlurAttributesDialog",
  "dialogElements": [
   {
    "staticText": [
     {
      "label": "Slur Properties"
     }
    ]
   },
   {
    "id": "position",
    "label": "Start Position",
    "options": [
     {
      "value": "1",
      "label": "Head"
     },
     {
      "value": "2",
      "label": "Top"
     }
    ]
   },
   {
    "id": "position_end",
    "label": "End Position",
    "options": [
     {
      "value": "1",
      "label": "Head"
     },
     {
      "value": "2",
      "label": "Top"
     }
    ]
   }
  ]
 },
 {
  "ctor": "SuiVoltaAttributeDialog",
  "dialogElements": [
   {
    "staticText": [
     {
      "label": "Volta Properties"
     }
    ]
   }
  ]
 },
 {
  "ctor": "SuiHairpinAttributesDialog",
  "dialogElements": [
   {
    "staticText": [
     {
      "label": "Hairpin Properties"
     }
    ]
   }
  ]
 },
 {
  "ctor": "SuiLyricDialog",
  "dialogElements": [
   {
    "id": "verse",
    "label": "Verse",
    "options": [
     {
      "value": "0",
      "label": "1"
     },
     {
      "value": "1",
      "label": "2"
     },
     {
      "value": "2",
      "label": "3"
     }
    ]
   },
   {
    "id": "textEditor",
    "label": "Edit Text",
    "options": []
   },
   {
    "staticText": [
     {
      "doneEditing": "Done Editing Lyrics"
     },
     {
      "undo": "Undo Lyrics"
     },
     {
      "label": "Lyric Editor"
     }
    ]
   }
  ]
 },
 {
  "ctor": "SuiChordChangeDialog",
  "dialogElements": [
   {
    "id": "verse",
    "label": "Verse",
    "options": [
     {
      "value": "0",
      "label": "1"
     },
     {
      "value": "1",
      "label": "2"
     },
     {
      "value": "2",
      "label": "3"
     }
    ]
   },
   {
    "id": "textEditor",
    "label": "Edit Text",
    "options": []
   },
   {
    "staticText": [
     {
      "doneEditing": "Done Editing Lyrics"
     },
     {
      "undo": "Undo Lyrics"
     },
     {
      "label": "Lyric Editor"
     }
    ]
   }
  ]
 },
 {
  "ctor": "SuiTextTransformDialog",
  "dialogElements": [
   {
    "id": "textEditor",
    "label": "Edit Text",
    "options": []
   },
   {
    "id": "textDragger",
    "label": "Move Text",
    "options": []
   },
   {
    "id": "textResizer",
    "label": "Resize Text",
    "options": []
   },
   {
    "id": "justification",
    "label": "Justification",
    "options": [
     {
      "value": "left",
      "label": "Left"
     },
     {
      "value": "right",
      "label": "Right"
     },
     {
      "value": "center",
      "label": "Center"
     }
    ]
   },
   {
    "id": "fontFamily",
    "label": "Font Family",
    "options": [
     {
      "value": "Merriweather,serif",
      "label": "Serif"
     },
     {
      "value": "Roboto,sans-serif",
      "label": "Sans-Serif"
     },
     {
      "value": "monospace",
      "label": "Monospace"
     },
     {
      "value": "cursive",
      "label": "Cursive"
     },
     {
      "value": "Merriweather",
      "label": "times"
     },
     {
      "value": "Arial",
      "label": "arial"
     },
     {
      "value": "Helvetica",
      "label": "Helvetica"
     }
    ]
   },
   {
    "id": "fontUnit",
    "label": "Units",
    "options": [
     {
      "value": "em",
      "label": "em"
     },
     {
      "value": "px",
      "label": "px"
     },
     {
      "value": "pt",
      "label": "pt"
     }
    ]
   },
   {
    "id": "pagination",
    "label": "Page Behavior",
    "options": [
     {
      "value": "once",
      "label": "Once"
     },
     {
      "value": "every",
      "label": "Every"
     },
     {
      "value": "even",
      "label": "Even"
     },
     {
      "value": "odd",
      "label": "Odd"
     },
     {
      "value": "subsequent",
      "label": "Subsequent"
     }
    ]
   },
   {
    "staticText": [
     {
      "label": "Text Properties"
     }
    ]
   }
  ]
 },
 {
  "ctor": "SuiAddStaffMenu",
  "label": "Staves",
  "menuItems": [
   {
    "value": "trebleInstrument",
    "text": "Treble Clef Staff"
   },
   {
    "value": "bassInstrument",
    "text": "Bass Clef Staff"
   },
   {
    "value": "altoInstrument",
    "text": "Alto Clef Staff"
   },
   {
    "value": "tenorInstrument",
    "text": "Tenor Clef Staff"
   },
   {
    "value": "remove",
    "text": "Remove Staff"
   },
   {
    "value": "cancel",
    "text": "Cancel"
   }
  ]
 },
 {
  "ctor": "SuiMeasureMenu",
  "label": "Measure",
  "menuItems": [
   {
    "value": "addMenuBeforeCmd",
    "text": "Add Measure Before"
   },
   {
    "value": "addMenuAfterCmd",
    "text": "Add Measure After"
   },
   {
    "value": "deleteSelected",
    "text": "Delete Selected Measures"
   },
   {
    "value": "formatMeasureDialog",
    "text": "Format Measure"
   },
   {
    "value": "cancel",
    "text": "Cancel"
   }
  ]
 },
 {
  "ctor": "SuiFileMenu",
  "label": "File",
  "menuItems": [
   {
    "value": "newFile",
    "text": "New Score"
   },
   {
    "value": "openFile",
    "text": "Open"
   },
   {
    "value": "saveFile",
    "text": "Save"
   },
   {
    "value": "quickSave",
    "text": "Quick Save"
   },
   {
    "value": "printScore",
    "text": "Print"
   },
   {
    "value": "bach",
    "text": "Bach Invention"
   },
   {
    "value": "bambino",
    "text": "Jesu Bambino"
   },
   {
    "value": "microtone",
    "text": "Microtone Sample"
   },
   {
    "value": "preciousLord",
    "text": "Precious Lord"
   },
   {
    "value": "yamaJson",
    "text": "Yama"
   },
   {
    "value": "cancel",
    "text": "Cancel"
   }
  ]
 },
 {
  "ctor": "SuiTimeSignatureMenu",
  "label": "Time Signature",
  "menuItems": [
   {
    "value": "6/8",
    "text": "6/8"
   },
   {
    "value": "3/4",
    "text": "3/4"
   },
   {
    "value": "2/4",
    "text": "2/4"
   },
   {
    "value": "12/8",
    "text": "12/8"
   },
   {
    "value": "7/8",
    "text": "7/8"
   },
   {
    "value": "5/8",
    "text": "5/8"
   },
   {
    "value": "TimeSigOther",
    "text": "Other"
   },
   {
    "value": "cancel",
    "text": "Cancel"
   }
  ]
 },
 {
  "ctor": "SuiKeySignatureMenu",
  "label": "Key",
  "menuItems": [
   {
    "value": "KeyOfC",
    "text": "C Major"
   },
   {
    "value": "KeyOfF",
    "text": "F Major"
   },
   {
    "value": "KeyOfG",
    "text": "G Major"
   },
   {
    "value": "KeyOfBb",
    "text": "Bb Major"
   },
   {
    "value": "KeyOfD",
    "text": "D Major"
   },
   {
    "value": "KeyOfEb",
    "text": "Eb Major"
   },
   {
    "value": "KeyOfA",
    "text": "A Major"
   },
   {
    "value": "KeyOfAb",
    "text": "Ab Major"
   },
   {
    "value": "KeyOfE",
    "text": "E Major"
   },
   {
    "value": "KeyOfDb",
    "text": "Db Major"
   },
   {
    "value": "KeyOfB",
    "text": "B Major"
   },
   {
    "value": "KeyOfF#",
    "text": "F# Major"
   },
   {
    "value": "KeyOfC#",
    "text": "C# Major"
   },
   {
    "value": "cancel",
    "text": "Cancel"
   }
  ]
 },
 {
  "ctor": "SuiTimeSignatureMenu",
  "label": "Time Signature",
  "menuItems": [
   {
    "value": "6/8",
    "text": "6/8"
   },
   {
    "value": "3/4",
    "text": "3/4"
   },
   {
    "value": "2/4",
    "text": "2/4"
   },
   {
    "value": "12/8",
    "text": "12/8"
   },
   {
    "value": "7/8",
    "text": "7/8"
   },
   {
    "value": "5/8",
    "text": "5/8"
   },
   {
    "value": "TimeSigOther",
    "text": "Other"
   },
   {
    "value": "cancel",
    "text": "Cancel"
   }
  ]
 },
 {
  "ctor": "SuiKeySignatureMenu",
  "label": "Key",
  "menuItems": [
   {
    "value": "KeyOfC",
    "text": "C Major"
   },
   {
    "value": "KeyOfF",
    "text": "F Major"
   },
   {
    "value": "KeyOfG",
    "text": "G Major"
   },
   {
    "value": "KeyOfBb",
    "text": "Bb Major"
   },
   {
    "value": "KeyOfD",
    "text": "D Major"
   },
   {
    "value": "KeyOfEb",
    "text": "Eb Major"
   },
   {
    "value": "KeyOfA",
    "text": "A Major"
   },
   {
    "value": "KeyOfAb",
    "text": "Ab Major"
   },
   {
    "value": "KeyOfE",
    "text": "E Major"
   },
   {
    "value": "KeyOfDb",
    "text": "Db Major"
   },
   {
    "value": "KeyOfB",
    "text": "B Major"
   },
   {
    "value": "KeyOfF#",
    "text": "F# Major"
   },
   {
    "value": "KeyOfC#",
    "text": "C# Major"
   },
   {
    "value": "cancel",
    "text": "Cancel"
   }
  ]
 },
 {
  "ctor": "SuiStaffModifierMenu",
  "label": "Lines",
  "menuItems": [
   {
    "value": "crescendo",
    "text": "Crescendo"
   },
   {
    "value": "decrescendo",
    "text": "Decrescendo"
   },
   {
    "value": "slur",
    "text": "Slur/Tie"
   },
   {
    "value": "ending",
    "text": "nth ending"
   },
   {
    "value": "cancel",
    "text": "Cancel"
   }
  ]
 },
 {
  "ctor": "SuiDynamicsMenu",
  "label": "Dynamics",
  "menuItems": [
   {
    "value": "pp",
    "text": "Pianissimo"
   },
   {
    "value": "p",
    "text": "Piano"
   },
   {
    "value": "mp",
    "text": "Mezzo-piano"
   },
   {
    "value": "mf",
    "text": "Mezzo-forte"
   },
   {
    "value": "f",
    "text": "Forte"
   },
   {
    "value": "ff",
    "text": "Fortissimo"
   },
   {
    "value": "sfz",
    "text": "sfortzando"
   },
   {
    "value": "cancel",
    "text": "Cancel"
   }
  ]
 },
 {
  "ctor": "SuiLanguageMenu",
  "label": "Language",
  "menuItems": [
   {
    "value": "en",
    "text": "English"
   },
   {
    "value": "de",
    "text": "Deutsch"
   },
   {
    "value": "ar",
    "text": "اَلْعَرَبِيَّةُ"
   },
   {
    "value": "cancel",
    "text": "Cancel"
   }
  ]
 },
 {
  "ribbonText": [
   {
    "buttonId": "helpDialog",
    "buttonText": "Help"
   },
   {
    "buttonId": "languageMenu",
    "buttonText": "Language"
   },
   {
    "buttonId": "fileMenu",
    "buttonText": "File"
   },
   {
    "buttonId": "addStaffMenu",
    "buttonText": "Staves"
   },
   {
    "buttonId": "measureModal",
    "buttonText": "Measure"
   },
   {
    "buttonId": "tempoModal",
    "buttonText": "Tempo"
   },
   {
    "buttonId": "timeSignatureMenu",
    "buttonText": "Time Signature"
   },
   {
    "buttonId": "keyMenu",
    "buttonText": "Key"
   },
   {
    "buttonId": "staffModifierMenu",
    "buttonText": "Lines"
   },
   {
    "buttonId": "instrumentModal",
    "buttonText": "Instrument"
   },
   {
    "buttonId": "pianoModal",
    "buttonText": "Piano"
   },
   {
    "buttonId": "layoutModal",
    "buttonText": "Layout"
   },
   {
    "buttonId": "UpOctaveButton",
    "buttonText": "8va"
   },
   {
    "buttonId": "DownOctaveButton",
    "buttonText": "8vb"
   },
   {
    "buttonId": "moreNavButtons",
    "buttonText": "..."
   },
   {
    "buttonId": "dcAlCoda",
    "buttonText": "DC Al Coda"
   },
   {
    "buttonId": "dsAlCoda",
    "buttonText": "DS Al Coda"
   },
   {
    "buttonId": "dcAlFine",
    "buttonText": "DC Al Fine"
   },
   {
    "buttonId": "dsAlFine",
    "buttonText": "DS Al Fine"
   },
   {
    "buttonId": "toCoda",
    "buttonText": "to "
   },
   {
    "buttonId": "fine",
    "buttonText": "Fine"
   },
   {
    "buttonId": "moreStaffButtons",
    "buttonText": "..."
   }
  ]
 }
]`;

var quickStartHtmlen = `
    <h3 id="quick-start-guide">Quick start guide</h3>
<p>If you don&#39;t like to read instructions, this cook&#39;s tour of Smoosic was made for you.</p>
<ul>
<li><p>One of buttons on the left is called &#39;File&#39;.  Click on it. The menu items before &#39;cancel&#39; are pre-canned projects that you can use as a template to get you started.</p>
</li>
<li><p>The cursor keys will navigate you to the different notes.</p>
</li>
<li><p>Letters a-g on the computer keyboard change the note to those pitches</p>
</li>
<li><p>&#39;Insert&#39; adds a new, blank measure.</p>
</li>
<li><p>The ribbon of thick blue buttons on the top expand to button groups, that contain most of the functionality of Smoosic.  </p>
</li>
<li><p>The buttons on the left bring up menus or dialogs that do basically what the buttons say.</p>
</li>
<li><p>There are a few &#39;instant gratification&#39; buttons for playing the music, refreshing the screen or changing the zoom level on the left part of the ribbon.</p>
</li>
<li><p>The piano tool is an alternate way of entering music, or can be dismissed by the close button in the lower left.</p>
</li>
</ul>
<p><img src="https://imgur.com/nP16PMI.gif" alt="" width="640" height="480"></p>
`;


var selectionHtmlen = `
<h3 id="selecting-things">Selecting things</h3>
<p>Almost all operations in Smoosic act on the selected music.  You can select notes in different ways:</p>
<ol>
<li>with the computer mouse</li>
<li>with the keyboard&#39;s navigation keys</li>
<li>with the navigation keys on the ribbon</li>
<li>with the piano tool, to some extent.</li>
</ol>
<p><img src="https://imgur.com/q1qK3Pn.gif" alt=""></p>
<p>You can select multiple things with the keyboard navigation keys, by selecting &#39;shift-arrow&#39;, just like many applications.  There is a similar control for selection in the navigation ribbon.  Some operations, like changing pitch for instance, act on all the selected notes.</p>
<p>Sometimes a selection of one line affects all the measures in that column (or all the measures of the system, if you like).  When you change the key, for instance, the selection determines where the key change starts.  If you have multiple measures selected, it applies to those measures, and then changes back to whatever it was before.</p>
`;


var enterDurationsHtmlen = `
<p>Note duration in Smoosic is done by changing the duration of an existing note.  Usually, doubling the duration or cutting it in two, or adding a dot - duration to a note.  You can also create tuplets for uneven sets of notes (3, 5, or 7).</p>
<p>There are actually 3 ways to do many duration operations - using the piano tool, using the computer keyboard, or using the button ribbon.  Like with many things, you should find entering duration using the keyboard fastest, once you have some experience with Smoosic.  But the ribbon or the </p>
<h2 id="changing-note-length-with-the-keyboard">Changing note length with the keyboard</h2>
<p>You can change the length of notes using the &#39;,&#39; and &#39;.&#39; (comma and period) keys, which halve and double the note lengths, respectively.  You can add a dot to the length of the note (multiplying length by 3/2 for the first dot, and 3/4 for the second dot, if you like to think of it that way) or remove a dot, using the &#39;&gt;&#39; and &#39;&lt;&#39;.  The mnemonic device for these is &#39;&gt;&#39; makes note duration greater.  &#39;&lt;&#39; makes note duration...less.  (On most QWERTY keyboards, comma shifted is &#39;&lt;&#39; and period shifted is &#39;&gt;&#39;).</p>
<p><img src="https://imgur.com/5ZWq2Xe.gif" alt=""></p>
<p>Note how the selection is preserved as the notes get shorter.  When you change something, Smoosic will try to keep the selection as close as possible to what you had.  You can use the cursor navigation keys to move to a specific selected note.</p>
<p><img src="https://imgur.com/woMw4RH.gif" alt=""></p>
<p>When you increase the length of a note, Smoosic always &#39;borrows&#39; from the next note in the measure that is eligible.  So when you double the length of the 8th note, it combines the 16th, and 2 32nd notes, and collapses them into a single quarter.  If Smoosic can&#39;t honor the request, it does nothing.  For instance, it can&#39;t remove the dot from a note with no dot, and it can&#39;t extend beyond the length of the measure.</p>
<p>You can create tuplets from the keyboard by typing Ctrl-3, Ctrl-5 or Ctrl-7 for triplets, quintuplets, and septuplets, respectively.  Individual notes in a tuplet can be doubled and halved with the duration keys &#39;-&#39; (minus) and &#39;=&#39; (equals), just like non-tuplets.  You &#39;untupletify&#39; a tuplet by Ctrl-0.</p>
<p><img src="https://imgur.com/uBpQwXD.gif" alt=""></p>
<h2 id="changing-note-length-with-piano-widget">Changing note length with piano widget</h2>
<p>The piano widget is shown when the application starts, and can be restored from the left menu &#39;Piano&#39; button when closed.</p>
<p>You can double or halve note duration, or add dot duration, to a note using the piano tool. </p>
<p><img src="https://imgur.com/Rw4yDxP.gif" alt=""></p>
<h2 id="changing-note-length-from-the-button-ribbon">Changing note length from the button ribbon</h2>
<p>All the duration commands can be accomplished from the ribbon buttons.  </p>
<p><img src="https://imgur.com/n9bmamg.gif" alt=""></p>
<p>Note that the equivalent keyboard commands are also indicated on the right of each button, when it&#39;s available.  (there are only so many keys, so there are some ribbon buttons with no key shortcut). </p>
`;


var enterPitchesHtmlen = `
<p>There are a few ways to enter notes in Smoosic.  You can click on the piano widget keys, or you can enter notes directly from the keyboard.</p>
<h2 id="your-first-smoosical-notes">Your first Smoosical notes</h2>
<h3 id="notes-from-the-keyboard">Notes from the keyboard</h3>
<p>The keys a-g on the computer keyboard will enter a corresponding note, A-G, on the staff (Most key commands in Smoosic have a mnemonic device).  The default behavior is for the cursor to advance when a note is entered in this way.  (Future behavior, auto-advance can be overridden). You navigate to the notes using the keyboard navigation arrows.</p>
<p><img src="https://imgur.com/lxR0NI7.gif" alt=""></p>
<p>You change the octave from the keyboard using the &#39;_&#39; and &#39;+&#39; (underscore, aka shift-minus, and plus), and change notes chromatically using &#39;-&#39; and &#39;=&#39; key.  The mnemonic device for this is &#39;plus and minus&#39; for raising and lowering pitches.  You can change the enharmonic spelling of the note using the &#39;Shift-E&#39; (mnemonic: E for enharmonic - get it?).  And Shift-F gives you a courtesy, or cautionary, accidental (mnemonic - F comes after E).</p>
<p><img src="https://imgur.com/1tC94sV.gif" alt=""></p>
<p>You can create chords and intervals using the number keys along the top of the keyboard.  The &#39;3&#39; key makes a third, the &#39;4&#39; key a fourth, and so on.  Shift+number gives you the interval down.</p>
<p><img src="https://imgur.com/IwoeWi3.gif" alt=""></p>
<p>Note that the interval starts from the highest note in the chord, for intervals going up, and the lowest note in the chord, for intervals going down.  You can select individual pitches in the chord using &#39;Shift-Up Arrow&#39; as shown.  This is similar to how modifiers like dynamics are selected.  Once you have the pitch selected, you can change it using the up-down commands shows above, or change the enharmonic spelling.</p>
<p>There is currently no way to remove a single pitch from the chord.  If you want to collapse the chord, just type a letter a-g on the keyboard, and it will be replaced with a single note.</p>
<h3 id="notes-from-the-piano-tool">Notes from the piano tool</h3>
<p>You can also add notes to your score with the piano tool, by clicking on the corresponding notes.</p>
<p><img src="https://imgur.com/MOMlIg3.gif" alt=""></p>
<p>Clicking on the piano gives the selected note the piano pitch.  The octave of the note is based on the clef, so for treble clef, the &#39;C&#39; is middle &#39;C&#39;.  You can change the octave of the note, and move the pitch up and down.  The top buttons affect the pitch, and the bottom buttons navigate or change the length of the note.  Clicking on the chord button acts like a &#39;sustain&#39; that puts additional notes in chords.</p>
<p>Everything that can be done from the piano widget, and most things in Smoosic generally, can be done more efficiently with keyboard commands. Once you are comfortable with the computer keyboard, you can free up some screen real-estate by closing the piano widget (cross control in lower left).  You can bring it up again with the piano menu button on the left.</p>
`;

var workingWithTexten = `
<h2 id="text-modes-in-smoosic">Text Modes in Smoosic</h2>
<p>Working with text in Smoosic is slightly different experience than editing music notation.  While you are entering, moving. or resizing the text, normal navigation with the cursor keys and music entry is suspended, and only the text you are working with is fully visible.  There is a dialog box with a few limited options, such as exiting text-entry mode.  This is true of text block, lyrics, and chords.  Once you finish entering the text, you get a different dialog box similar to the one you can use to edit modifiers such as slurs, crescendos, etc.</p>
<p><img src="https://imgur.com/EKDIUi5.png" alt=""></p>
<h2 id="text-blocks">Text Blocks</h2>
<p>Text blocks, also called &#39;Score text&#39; because it is not tied to a musical element, is free-form text that can be placed anywhere.  It can be used for titles, credits, etc.  It can also be set up for pagination using escape sequences. <strong>**</strong>  Unicode characters are also allowed.</p>
<p>You create a text block by selecting the big &#39;T&#39; on the text ribbon, with the cursor symbol (diagram).  You enter the text as you like it (only a single line is supported right now, if you want multiple lines you have to stack them).  </p>
<p><img src="https://imgur.com/kSMHoDl.png" alt=""></p>
<h2 id="lyrics">Lyrics</h2>
<p>Lyrics are entered by clicking on the lyrics button (do-re-mi).  Lyrics are entered per note.  When you hit space bar or - sign, the focus is advanced to the next note/lyric.  A &#39;-&#39; sign by itself in a lyric gives you a horizontal line.  When you want to leave lyric editing mode, just like other text entry modes, click on the &#39;Done editing&#39; button on the dialog. Note that the dialog can be moved around if it interferes with the music you are trying to edit.  (This is true of all dialog boxes in Smoosic.)  The final dialog box allows you to switch to a different verse.</p>
<p><img src="https://imgur.com/FfKOUUQ.png" alt=""></p>
<h2 id="chord-changes">Chord changes</h2>
<p>Chord changes button is in the same ribbon group as lyrics, and the editing experience is pretty similar.  There are some magic key strokes:</p>
<ul>
<li>^ (shift-6) starts or ends superscript mode</li>
<li>%  (shift-5) starts or ends subscript mode</li>
<li>If you immediately follow subscript mode by superscript mode, the scripts are &#39;stacked&#39;.</li>
<li>b, #, + , (, ) , &#39;/&#39; result in their respective symbols.</li>
</ul>
<p>Right now chord symbol entry is not too WYSIWYG - the actual chord rendering is done when the editing mode is done, which is a bit annoying.  I will be improving this as time goes on.</p>
<p><img src="https://imgur.com/a2ldLDX" alt=""></p>`;
;
class SmoTranslator {
  static get dialogs() {
    SmoTranslator._dialogs =  SmoTranslator._dialogs ? SmoTranslator._dialogs : {};
    return SmoTranslator._dialogs;
  }

  static get menus() {
    SmoTranslator._menus =  SmoTranslator._menus ? SmoTranslator._menus : {};
    return SmoTranslator._menus;
  }

  static registerMenu(_class) {
    if (!SmoTranslator.menus[_class]) {
      SmoTranslator.menus[_class] = true;
    }
  }


  static registerDialog(_class) {
    if (!SmoTranslator.dialogs[_class]) {
      SmoTranslator.dialogs[_class] = true;
    }
  }

  static printLanguages() {
    var translatables = [];
    SmoTranslator.allDialogs.forEach((key) => {
      SmoTranslator.registerDialog(key);
      translatables.push(SuiDialogBase.printTranslate(key));
    });
    SmoTranslator.allMenus.forEach((key) => {
      SmoTranslator.registerMenu(key);
      translatables.push(suiMenuBase.printTranslate(key));
    });

    console.log(JSON.stringify(translatables,null,' '));
  }

  static _updateDialog(dialogStrings,_dialogClass,dialogClass) {
    if (!dialogStrings) {
      console.log('no strings for Dialog '+dialogClass);
      return;
    }
    _dialogClass['label'] = dialogStrings.label;
    var staticText = dialogStrings.dialogElements.find((ds) => ds.staticText);
    _dialogClass['dialogElements'].forEach((component) => {
      var componentStrings = dialogStrings.dialogElements.find((ds) => {
        return ds.id === component.smoName;
      });
      if (component.staticText && staticText) {
        component.staticText.forEach((st) => {
          const trans = staticText.staticText.find((dst) => Object.keys(dst)[0] == Object.keys(st)[0]);
          if (trans) {
            const key = Object.keys(st)[0];
            st[key] = trans[key];
          }
        });
      }  else if (componentStrings) {
        component.label = componentStrings.label;
        if (component['options']) {
          component['options'].forEach((option) => {
            var optionString = componentStrings.options.find((cs) => cs.value === option.value);
            if (!optionString) {
              console.log('no string for option '+ option.value+' in component '+component.smoName+' in dialog ' + dialogClass);
            } else {
              option.label = optionString.label;
            }
          });
        }
      } else {
        console.log('Untranslated component in  ' + dialogClass);
      }
    });
  }

  static _updateMenu(menuStrings,_menuClass,menuClass) {
    if (!menuStrings) {
      console.log('no strings for Menu '+menuClass);
      return;
    }

    _menuClass['defaults'].menuItems.forEach((menuItem) => {
      var val = menuItem.value;
      var nvPair = menuStrings.menuItems.find((ff) => ff.value === val);
      if (!nvPair) {
        console.log('no xlate for '+ val+' in menu '+menuClass);
      } else {
        menuItem.text = nvPair.text;
        console.log('setting menu item value '+val+' to '+nvPair.text);
      }
    });
  }

  static setLanguage(language) {
    if (!SmoLanguage[language]) {
      return; // no xlate exists
    }
    var trans = SmoLanguage[language];
    // Set the text in all the menus
    SmoTranslator.allMenus.forEach((menuClass) => {
      var _class = eval(menuClass);
      var menuStrings = trans.strings.find((mm) => {
        return mm.ctor == menuClass;
      });
      SmoTranslator._updateMenu(menuStrings,_class,menuClass);

      // Set text in ribbon buttons that invoke menus
      var menuButton = $('.ribbonButtonContainer button.'+menuClass).find('.left-text .text-span');
      if (menuButton.length && menuStrings) {
        $(menuButton).text(menuStrings.label);
      }
    });

    SmoTranslator.allDialogs.forEach((dialogClass) => {
      var _class = eval(dialogClass);
      var dialogStrings = trans.strings.find((mm) => {
        return mm.ctor == dialogClass;
      });
      // Set text in ribbon buttons that invoke menus
      var dialogButton = $('.ribbonButtonContainer button.'+dialogClass).find('.left-text .text-span');
      if (dialogButton.length && dialogStrings) {
        $(dialogButton).text(dialogStrings.label);
      }

      SmoTranslator._updateDialog(dialogStrings,_class,dialogClass);
    });

    // Translate the buttons on the ribbon
    const langButtons = trans.strings.find((buttonObj) => buttonObj.ribbonText);
    if (langButtons) {
      RibbonButtons.translateButtons.forEach((button) => {
        var domButton = $(button);
        var langButton = langButtons.ribbonText.find((lb) => lb.buttonId === button.buttonId);
        if (langButton) {
          var buttonDom = $('.ribbonButtonContainer #'+button.buttonId);
          if (buttonDom.length) {
            $(buttonDom).find('.left-text').text(langButton.buttonText);
          }
        }
      });
    }
    // Handle rtl languages
    $('body').find('.language-dir').each((ix,dd) => {$(dd).attr('dir',trans.dir)});
  }

  static get allMenus() {
    return [
      'SuiAddStaffMenu',
      'SuiMeasureMenu',
      'SuiFileMenu',
      'SuiTimeSignatureMenu',
      'SuiKeySignatureMenu',
      'SuiTimeSignatureMenu',
      'SuiKeySignatureMenu',
      'SuiStaffModifierMenu',
      'SuiDynamicsMenu',
      'SuiLanguageMenu'
    ]
  }

  static get allDialogs() {
    return [
      'SuiLoadFileDialog',
      'SuiSaveFileDialog',
      'SuiPrintFileDialog',
      'SuiMeasureDialog',
      'SuiTempoDialog',
      'SuiInstrumentDialog',
      'SuiTimeSignatureDialog',
      'SuiLayoutDialog',
      'SuiDynamicModifierDialog',
      'SuiSlurAttributesDialog',
      'SuiVoltaAttributeDialog',
      'SuiHairpinAttributesDialog',
      'SuiLyricDialog',
      'SuiChordChangeDialog',
      'SuiTextTransformDialog'
    ]
  }
  static get allHelpFiles() {
    return [
      'quickStartHtml',
      'selectionHtml',
      'enterPitchesHtml',
      'enterDurationsHtml'
    ];
  }
}

class SmoLanguage {
  static getHelpFile(category) {
    return eval(category + SmoConfig.language);
  }
  static get en() {
    var strings = JSON.parse(smoLanguageStringEn);
    var rv = {dir:'ltr',strings:strings,helpHtml:{}};
    return rv;
   }

   static get ar() {
     var strings = JSON.parse(smoLanguageStringAr);
     var rv = {dir:'rtl',strings:strings,helpHtml:{}};
     return rv;
   }

   static get de() {
     var strings = JSON.parse(smoLanguageStringDe);
     var rv = {dir:'ltr',strings:strings,helpHtml:{}};
     return rv;
   }
}
;
class PromiseHelpers {
  // ### makePromise
  // poll on endCondition at a rate of pollTime.  Resolve the promise
  // when endCondition is met, calling preResolveMethod first.   On
  // polls where the end condition is not met, call pollMethod
  // Resolve method and pollMethod are optional
  static makePromise(instance,endCondition,preResolveMethod,pollMethod,pollTime) {
    return new Promise((resolve) => {
      var checkit = () => {
        setTimeout(() => {
          if (instance[endCondition]) {
            if (preResolveMethod) {
              instance[preResolveMethod]();
            }
            resolve();
          }
          else {
            if (pollMethod) {
              instance[pollMethod]();
            }
            checkit();
          }
        },pollTime);
      }
      checkit();
    });
  }

  static makePromiseObj(instance,endCondition,preResolveMethod,pollMethod,pollTime) {
    return {
      instance: instance,
      endCondition: endCondition,
      preResolveMethod: preResolveMethod,
      pollMethod: pollMethod,
      pollTime: pollTime
    };
  }

  // ### afterPromise
  // Call a method after a promise is resolved that may
  // also return a promise
  static afterPromise(obj, promise, functionName) {
    const f = () => {
      obj[functionName]();
    }
    return promise.then(f);
  }
  // ### promiseChainThen
  // Call a chain of promises in array order, with parameters of makePromise
  static async promiseChainThen(promiseParameters) {
    const promiseArray = [];
    promiseParameters.forEach((promiseParameter) => {

      promiseArray.push(
        async () => {
          return PromiseHelpers.makePromise(
            promiseParameter.instance,
            promiseParameter.endCondition,
            promiseParameter.preResolveMethod,
            promiseParameter.pollMethod,
            promiseParameter.pollTime
          );
      });
    });

    let result;
    for (const f of promiseArray) {
      result = await f(result);
    }

		return result;
  }
}
;
VF = Vex.Flow;
Vex.Xform = (typeof(Vex.Xform) == 'undefined' ? {}
	 : Vex.Xform);
VX = Vex.Xform;

// ## smoMusic
// Helper functions that build on the VX music theory routines, and other
// utilities I wish were in VF.Music but aren't
// ### Note on pitch and duration format
// We use some VEX music theory routines and frequently need to convert
// formats from SMO format.
//
// `Smo` uses pitch JSON:
// ``javascript``
//  {note:'c',accidental:'#',octave:4}
// `Vex` usually uses a canonical string:
//  'c#/4'
//  Depending on the operation, the octave might be omitted
//
// `Smo` uses a JSON for duration always:
// ``javascript``
// {numerator:4096,denominator:1,remainder:0}
//
// `VexFlow` uses a letter duration ('4' for 1/4 note) and 'd' for dot.
// I try to indicate whether I am using vex or smo notation
// ## smoMusic static methods:
// ---
class smoMusic {


	// ### vexToCannonical
	// return Vex canonical note enharmonic - e.g. Bb to A#
	// Get the canonical form
	static vexToCannonical(vexKey) {
		vexKey = smoMusic.stripVexOctave(vexKey);
		return VF.Music.canonical_notes[VF.Music.noteValues[vexKey].int_val];
	}

	// ### circleOfFifths
	// A note array in key-signature order
	static get circleOfFifths() {
		return [{
				letter: 'c',
				accidental: 'n'
			}, {
				letter: 'g',
				accidental: 'n'
			}, {
				letter: 'd',
				accidental: 'n'
			}, {
				letter: 'a',
				accidental: 'n'
			}, {
				letter: 'e',
				accidental: 'n'
			}, {
				letter: 'b',
				accidental: 'n'
			}, {
				letter: 'f',
				accidental: '#'
			}, {
				letter: 'c',
				accidental: '#'
			}, {
				letter: 'a',
				accidental: 'b'
			}, {
				letter: 'e',
				accidental: 'b'
			}, {
				letter: 'b',
				accidental: 'b'
			}, {
				letter: 'f',
				accidental: 'n'
			}
		];
	}

	// ### circleOfFifthsIndex
	// gives the index into circle-of-fifths array for a pitch, considering enharmonics.
	static circleOfFifthsIndex(smoPitch) {
		var en1 = smoMusic.vexToSmoPitch(smoMusic.getEnharmonic(smoMusic.pitchToVexKey(smoPitch)));
		var en2 = smoMusic.vexToSmoPitch(smoMusic.getEnharmonic(smoMusic.getEnharmonic(smoMusic.pitchToVexKey(smoPitch))));
		var ix = smoMusic.circleOfFifths.findIndex((el) => {
				return (el.letter === smoPitch.letter && el.accidental == smoPitch.accidental) ||
				(el.letter == en1.letter && el.accidental == en1.accidental) ||
				(el.letter == en2.letter && el.accidental == en2.accidental);
			});
		return ix;
	}

	// ### addSharp
	// Get pitch to the right in circle of fifths
	static addSharp(smoPitch) {
		var rv = smoMusic.circleOfFifths[
				(smoMusic.circleOfFifthsIndex(smoPitch) + 1) % smoMusic.circleOfFifths.length];
		rv = JSON.parse(JSON.stringify(rv));
		rv.octave = smoPitch.octave;
		return rv;
	}

	// ### addFlat
	// Get pitch to the left in circle of fifths
	static addFlat(smoPitch) {
		var rv = smoMusic.circleOfFifths[
				((smoMusic.circleOfFifths.length - 1) + smoMusic.circleOfFifthsIndex(smoPitch)) % smoMusic.circleOfFifths.length];
		rv = JSON.parse(JSON.stringify(rv));
		rv.octave = smoPitch.octave;
		return rv;
	}

	// ### addSharps
	// Add *distance* sharps/flats to given key
	static addSharps(smoPitch, distance) {
		if (distance == 0) {
			return JSON.parse(JSON.stringify(smoPitch));
		}
		var rv = smoMusic.addSharp(smoPitch);
		for (var i = 1; i < distance; ++i) {
			rv = smoMusic.addSharp(rv);
		}
		var octaveAdj = smoMusic.letterPitchIndex[smoPitch.letter] > smoMusic.letterPitchIndex[rv.letter] ? 1 : 0;
		rv.octave += octaveAdj;
		return rv;
	}

	// ### addFlats
	// Add *distance* sharps/flats to given key
	static addFlats(smoPitch, distance) {
		if (distance == 0) {
			return JSON.parse(JSON.stringify(smoPitch));
		}
		var rv = smoMusic.addFlat(smoPitch);
		for (var i = 1; i < distance; ++i) {
			rv = smoMusic.addFlat(rv);
		}
		var octaveAdj = smoMusic.letterPitchIndex[smoPitch.letter] > smoMusic.letterPitchIndex[rv.letter] ? 1 : 0;
		rv.octave += octaveAdj;
		return rv;
	}

	// ### smoPitchesToVexKeys
	// Transpose and convert from SMO to VEX format so we can use the VexFlow tables and methods
	static smoPitchesToVexKeys(pitchAr, keyOffset,noteHead) {
		var noopFunc = keyOffset > 0 ? 'addSharps' : 'addFlats';

		var rv = [];
		pitchAr.forEach((pitch) => {
			rv.push(smoMusic.pitchToVexKey(smoMusic[noopFunc](pitch, keyOffset),noteHead));
		});
		return rv;
	}

	static get scaleIntervals() {
		return {
			up: [2, 2, 1, 2, 2, 2, 1],
			down: [1, 2, 2, 2, 1, 2, 2]
		};
	}

	// ### smoScalePitchMatch
	// return true if the pitches match, but maybe not in same octave
	static smoScalePitchMatch(p1, p2) {
		var pp1 = JSON.parse(JSON.stringify(p1));
		var pp2 = JSON.parse(JSON.stringify(p2));
		pp1.octave = 0;
		pp2.octave = 0;

		return smoMusic.smoPitchToInt(pp1) == smoMusic.smoPitchToInt(pp2);
	}

  // ### pitchToLedgerLineInt
  static pitchToLedgerLine(clef,pitch) {
    // return the distance from the top ledger line, as 0.5 per line/space
    return -1.0*(VF.keyProperties(smoMusic.pitchToVexKey(pitch,clef)).line-4.5)
     - VF.clefProperties.values[clef].line_shift;
  }

  // ### pitchToVexKey
  // convert from SMO to VEX format so we can use the VexFlow tables and methods
  // example:
  // 	`{letter,octave,accidental}` object to vexKey string `'f#'`
  static _pitchToVexKey(smoPitch) {
    // Convert to vex keys, where f# is a string like 'f#'.
    var vexKey = smoPitch.letter.toLowerCase();
    if (smoPitch.accidental.length === 0) {
      vexKey = vexKey + 'n';
    } else {
      vexKey = vexKey + smoPitch.accidental;
    }
    if (smoPitch['octave']) {
      vexKey = vexKey + '/' + smoPitch.octave;
    }
    return vexKey;
  }

  static pitchToVexKey(smoPitch,head) {
    if (!head) {
      return smoMusic._pitchToVexKey(smoPitch);
    }
    return smoMusic._pitchToVexKey(smoPitch)+'/'+head;
  }

	static smoPitchToInt(pitch) {
    if (typeof(pitch.octave) === 'undefined') {
      pitch.octave = 0;
    }
		var intVal = VF.Music.noteValues[
				smoMusic.stripVexOctave(smoMusic.pitchToVexKey(pitch))].int_val;
    var octave =  (pitch.letter === 'c' && pitch.accidental === 'b' && pitch.octave > 0) ?
       pitch.octave - 1 : pitch.octave;
		return octave * 12 + intVal;
	}

	static smoIntToPitch(intValue) {

		var letterInt = intValue >= 0 ? intValue % 12 :
       12 - (Math.abs(intValue) % 12);
		var noteKey = Object.keys(VF.Music.noteValues).find((key) => {
				return VF.Music.noteValues[key].int_val === letterInt && key.length === 1
			});
    if (!noteKey) {
      noteKey = Object.keys(VF.Music.noteValues).find((key) => {
  				return VF.Music.noteValues[key].int_val === letterInt && key.length === 2
  			});
    }
		var octave = Math.floor(intValue / 12);
    octave = octave >= 0 ? octave : 0;
    var accidental = noteKey.substring(1, noteKey.length);
    accidental = accidental ? accidental : 'n';
		return {
			letter: noteKey[0],
			accidental: accidental,
			octave: octave
		};
	}

	// ### get enharmonics
	// return a map of enharmonics for choosing or cycling.  notes are in vexKey form.
	static get enharmonics() {
		var rv = {};
		var keys = Object.keys(VF.Music.noteValues);
		for (var i = 0; i < keys.length; ++i) {
			var key = keys[i];
			var int_val = VF.Music.noteValues[key].int_val;
			if (typeof(rv[int_val.toString()]) == 'undefined') {
				rv[int_val.toString()] = [];
			}
			// only consider natural note 1 time.  It is in the list twice for some reason.
			if (key.indexOf('n') == -1) {
				rv[int_val.toString()].push(key);
			}
		}
		return rv;
	}

	static getEnharmonics(vexKey) {
		var proto = smoMusic.stripVexOctave(vexKey);
		var rv = [];
		var ne = smoMusic.getEnharmonic(vexKey);
		rv.push(proto);
		while (ne[0] != proto[0]) {
			rv.push(ne);
			ne = smoMusic.getEnharmonic(ne);
		}
		return rv;
	}

    // ### getEnharmonic(noteProp)
	// cycle through the enharmonics for a note.
	static getEnharmonic(vexKey) {
		vexKey = smoMusic.stripVexOctave(vexKey);
		var intVal = VF.Music.noteValues[vexKey.toLowerCase()].int_val;
		var ar = smoMusic.enharmonics[intVal.toString()];
		var len = ar.length;
		// 'n' for natural in key but not in value
		vexKey = vexKey.length > 1 && vexKey[1] === 'n' ? vexKey[0] : vexKey;
		var ix = ar.indexOf(vexKey);
		vexKey = ar[(ix + 1) % len];
		return vexKey;
	}

	// ### getKeyFriendlyEnharmonic
	// fix the enharmonic to match the key, if possible
	// `getKeyFriendlyEnharmonic('b','eb');  => returns 'bb'
	static getKeyFriendlyEnharmonic(letter, keySignature) {
		var rv = letter;
		var muse = new VF.Music();
		var scale = Object.values(muse.createScaleMap(keySignature));
		var prop = smoMusic.getEnharmonic(letter.toLowerCase());
		while (prop.toLowerCase() != letter.toLowerCase()) {
			for (var i = 0; i < scale.length; ++i) {
				var skey = scale[i];
				if ((skey[0] == prop && skey[1] == 'n') ||
					(skey.toLowerCase() == prop.toLowerCase())) {
					rv = skey;
					break;
				}
			}
			prop = (prop[1] == 'n' ? prop[0] : prop);
			prop = smoMusic.getEnharmonic(prop);
		}
		return rv;
	}
	static closestTonic(smoPitch, vexKey, direction) {
		direction = Math.sign(direction) < 0 ? -1 : 1;
		var tonic = smoMusic.vexToSmoPitch(vexKey);
		tonic.octave=smoPitch.octave;
		var iix = smoMusic.smoPitchToInt(smoPitch);
		var smint=smoMusic.smoPitchToInt(tonic);
		if (Math.sign(smint - iix) != direction) {
			tonic.octave += direction
		}
		return tonic;
	}

  // ### toValidKeySignature
  // When transposing, make sure key signature is valid, e.g. g# should be
  // Ab
  static toValidKeySignature(vexKey) {
    var map = {'a#':'bb','g#':'ab','cb':'b','d#':'eb'}
    if (map[vexKey.toLowerCase()]) {
      return map[vexKey.toLowerCase()];
    }
    return vexKey;
  }

	static getEnharmonicInKey(smoPitch, keySignature) {
    if (typeof(smoPitch.octave) === 'undefined') {
      smoPitch.octave = 1;
    }
    var sharpKey = keySignature.indexOf('#') >= 0 ? true : false;
    var flatKey = keySignature.indexOf('b') >= 0 ? true : false;
		var ar = smoMusic.getEnharmonics(smoMusic.pitchToVexKey(smoPitch));
		var rv = smoMusic.stripVexOctave(smoMusic.pitchToVexKey(smoPitch));
		var scaleMap = new VF.Music().createScaleMap(keySignature);
    var match = false;
		ar.forEach((vexKey) => {
			if (vexKey.length === 1) {
				vexKey += 'n';
			}
			if (vexKey === scaleMap[vexKey[0]]) {
				rv = vexKey;
        match = true;
			} else if (!match) {
        // In the absence of a match of a key tone, we bias towards more
        // 'common', like Bb is more common than A#, esp. as a chord.  This maybe
        // just be my horn player bias towards flat keys
        if (vexKey === 'a#' && !sharpKey) {
          rv = 'bb';
        } else if (vexKey === 'g#' && !sharpKey) {
          rv = 'ab';
        } else if (vexKey === 'c#' && !sharpKey) {
          rv = 'db';
        } else if (vexKey === 'd#' && !sharpKey) {
          rv = 'eb';
        } else if (vexKey === 'f#' && flatKey) {
          rv = 'gb';
        }
      }
		});
		var smoRv = smoMusic.vexToSmoPitch(rv);
		smoRv.octave = smoPitch.octave;
		var rvi = smoMusic.smoPitchToInt(smoRv);
		var ori = smoMusic.smoPitchToInt(smoPitch);
		// handle the case of c0 < b0, pitch-wise
		smoRv.octave += Math.sign(ori - rvi);
		return smoRv;
	}

	// ### getIntervalInKey
	// give a pitch and a key signature, return another pitch at the given
	// diatonic interval.  Similar to getKeyOffset but diatonic.
	static getIntervalInKey(pitch, keySignature, interval) {
		if (interval === 0)
			return JSON.parse(JSON.stringify(pitch));

		var delta = interval > 0 ? 1 : -1;
		var inv = -1 * delta;
		var tonic = smoMusic.closestTonic(pitch, keySignature, inv);
		var intervals = delta > 0 ? smoMusic.scaleIntervals.up : smoMusic.scaleIntervals.down;
		var pitchInt = smoMusic.smoPitchToInt(pitch);
		var scaleIx = 0;
		var diatonicIx=0;

		var nkey = tonic;
		var nkeyInt = smoMusic.smoPitchToInt(nkey);
		while (Math.sign(nkeyInt - pitchInt) != delta && Math.sign(nkeyInt - pitchInt) != 0) {
			nkey = smoMusic.smoIntToPitch(smoMusic.smoPitchToInt(nkey) + delta * intervals[scaleIx]);
			scaleIx = (scaleIx + 1) % 7;
			nkeyInt = smoMusic.smoPitchToInt(nkey);
		}
		while (diatonicIx != interval) {
			nkey = smoMusic.smoIntToPitch(smoMusic.smoPitchToInt(nkey) + delta * intervals[scaleIx]);
			scaleIx = (scaleIx + 1) % 7;
			diatonicIx += delta;
		}
		return smoMusic.getEnharmonicInKey(nkey,keySignature);
	}

	static vexKeySignatureTranspose(key, transposeIndex) {
		var key = smoMusic.vexToSmoPitch(key);
		key = smoMusic.smoPitchesToVexKeys([key], transposeIndex)[0];
		key = smoMusic.stripVexOctave(key);
		key = key[0].toUpperCase() + key.substring(1, key.length);
		if (key.length > 1 && key[1] === 'n') {
			key = key[0];
		}
		return key;
	}
    static get frequencyMap() {
        return suiAudioPitch.pitchFrequencyMap;
    }

	// ### get letterPitchIndex
	// Used to adjust octave when transposing.
	// Pitches are measured from c, so that b0 is higher than c0, c1 is 1 note higher etc.
	static get letterPitchIndex() {
		return {
			'c': 0,
			'd': 1,
			'e': 2,
			'f': 3,
			'g': 4,
			'a': 5,
			'b': 6
		};
	}

	// ### letterChangedOctave
	// Indicate if a change from letter note 'one' to 'two' needs us to adjust the
	// octave due to the `smoMusic.letterPitchIndex` (b0 is higher than c0)
	static letterChangedOctave(one, two) {
		var p1 = smoMusic.letterPitchIndex[one];
		var p2 = smoMusic.letterPitchIndex[two];
		if (p1 < p2 && p2 - p1 > 2)
			return -1;
		if (p1 > p2 && p1 - p2 > 2)
			return 1;
		return 0;

	}

	// ### vexToSmoPitch
	// #### Example:
	// ['f#'] => [{letter:'f',accidental:'#'}]
	static vexToSmoPitch(vexPitch) {
		var accidental = vexPitch.length < 2 ? 'n' : vexPitch.substring(1, vexPitch.length);
		return {
			letter: vexPitch[0].toLowerCase(),
			accidental: accidental
		};
	}

    // ### smoPitchToVes
	// #### Example:
    // {letter:'f',accidental:'#'} => [f#/
    static smoPitchesToVex(pitchAr) {
        var rv = [];
        pitchAr.forEach((p) => {
            rv.push(smoMusic.pitchToVexKey(p));
        });
        return rv;
    }

	static stripVexOctave(vexKey) {
		if (vexKey.indexOf('/') > 0) {
			vexKey = vexKey.substring(0, vexKey.indexOf('/'))
		}
		return vexKey;
	}


	// ### getKeyOffset
	// Given a vex noteProp and an offset, offset that number
	// of 1/2 steps.
	// #### Input:  smoPitch
	// #### Output:  smoPitch offset, not key-adjusted.
	static getKeyOffset(pitch, offset) {
		var canon = VF.Music.canonical_notes;

		// Convert to vex keys, where f# is a string like 'f#'.
		var vexKey = smoMusic.pitchToVexKey(pitch);
		vexKey = smoMusic.vexToCannonical(vexKey);
		var rootIndex = canon.indexOf(vexKey);
		var index = (rootIndex + canon.length + offset) % canon.length;
		var octave = pitch.octave;
		if (Math.abs(offset) >= 12) {
			var octaveOffset = Math.sign(offset) * Math.floor(Math.abs(offset) / 12);
			octave += octaveOffset;
			offset = offset % 12;
		}
		if (rootIndex + offset >= canon.length) {
			octave += 1;
		}
		if (rootIndex + offset < 0) {
			octave -= 1;
		}
		var rv = JSON.parse(JSON.stringify(pitch));
		vexKey = canon[index];
		if (vexKey.length > 1) {
			rv.accidental = vexKey.substring(1);
			vexKey = vexKey[0];
		} else {
			rv.accidental = '';
		}
		rv.letter = vexKey;
		rv.octave = octave;
		return rv;
	}

	// ### keySignatureLength
	// return the number of sharp/flat in a key signature for sizing guess.
	static get keySignatureLength() {
		return {
			'C': 0,
			'B': 5,
			'A': 3,
			'F#': 6,
			'Bb': 2,
			'Ab': 4,
			'Gg': 6,
			'G': 1,
			'F': 1,
			'Eb': 3,
			'Db': 5,
			'Cb': 7,
			'C#': 7,
			'F#': 6,
			'E': 4,
			'D': 2
		};
	}

	static getSharpsInKeySignature(key) {
		var sharpKeys = ['B','G','D','A','E','B','F#','C#'];
		if (sharpKeys.indexOf(key) < 0) {
			return 0;
		}
		return smoMusic.keySignatureLength[key];
	}

	static getFlatsInKeySignature(key) {
		var flatKeys = ['F','Bb','Eb','Ab','Db','Gb','Cb'];
		if (flatKeys.indexOf(key) < 0) {
			return 0;
		}
		return smoMusic.keySignatureLength[key];
	}

    static timeSignatureToTicks(timeSignature) {
        var nd = timeSignature.split('/');
        var num = parseInt(nd[0]);
        var den = parseInt(nd[1]);

        var base = 2048*(8/den);
        return base*num;
    }
    static smoTicksToVexDots(ticks) {
        var vd = smoMusic.ticksToDuration[ticks];
        var dots = (vd.match(/d/g) || []).length;
        return dots;
    }
	// ## closestVexDuration
	// ## Description:
	// return the closest vex duration >= to the actual number of ticks. Used in beaming
	// triplets which have fewer ticks then their stem would normally indicate.
	static closestVexDuration(ticks) {
		var stemTicks = VF.RESOLUTION;

		// The stem value is the type on the non-tuplet note, e.g. 1/8 note
		// for a triplet.
		while (ticks <= stemTicks) {
			stemTicks = stemTicks / 2;
		}

		stemTicks = stemTicks * 2;
		return smoMusic.ticksToDuration[stemTicks];
		var ix = Object.keys(smoMusic.ticksToDuration).findIndex((x) => {
				return x >= ticks
			});
		return smoMusic.ticksToDuration[durations[ix]];
	}

	// ### getKeySignatureKey
	// given a letter pitch (a,b,c etc.), and a key signature, return the actual note
	// that you get without accidentals
	// ### Usage:
	//   smoMusic.getKeySignatureKey('F','G'); // returns f#
	static getKeySignatureKey(letter, keySignature) {
		var km = new VF.KeyManager(keySignature);
		return km.scaleMap[letter];
	}

    static getAccidentalForKeySignature(smoPitch,keySignature) {
        var vexKey = smoMusic.getKeySignatureKey(smoPitch.letter,keySignature);
        return vexKey.length == 1 ? 'n' : vexKey.substr(1,vexKey.length - 1);
    }

    // ### isPitchInKeySignature
    // Return true if the pitch is not an accidental in the give key, e.g.
    // f# in 'g' or c in 'Bb'
    static isPitchInKeySignature(smoPitch,keySignature) {
        var vexKey = smoMusic.getKeySignatureKey(smoPitch.letter,keySignature);
        return (vexKey.length == 1 && smoPitch.accidental == 'n' ||
            (vexKey[1]==smoPitch.accidental));
    }

	// ### Description:
	// Get ticks for this note with an added dot.  Return
	// identity if that is not a supported value.
	static getNextDottedLevel(ticks) {
		var ttd = smoMusic.ticksToDuration;
		var vals = Object.values(ttd);

		var ix = vals.indexOf(ttd[ticks]);
		if (ix >= 0 && ix < vals.length && vals[ix][0] == vals[ix + 1][0]) {
			return smoMusic.durationToTicks(vals[ix + 1]);
		}
		return ticks;
	}

	// ### Description:
	// Get ticks for this note with one fewer dot.  Return
	// identity if that is not a supported value.
	static getPreviousDottedLevel(ticks) {
		var ttd = smoMusic.ticksToDuration;
		var vals = Object.values(ttd);
		var ix = vals.indexOf(ttd[ticks]);
		if (ix > 0 && vals[ix][0] == vals[ix - 1][0]) {
			return smoMusic.durationToTicks(vals[ix - 1]);
		}
		return ticks;
	}


	// ### ticksToDuration
	// Frequently we double/halve a note duration, and we want to find the vex tick duration that goes with that.
	static get ticksToDuration() {
		var durations = ["1/2", "1", "2", "4", "8", "16", "32", "64", "128", "256"];
		smoMusic._ticksToDuration = smoMusic['_ticksToDuration'] ? smoMusic._ticksToDuration : null;
		var _ticksToDurationsF = function () {
            var ticksToDuration = smoMusic._ticksToDuration = {};
			for (var i = 0; i < durations.length - 1; ++i) {
				var dots = '';
				var ticks = 0;

				// We support up to 4 'dots'
				for (var j = 0; j <= 4 && j + i < durations.length; ++j) {
					ticks += VF.durationToTicks.durations[durations[i + j]];
					ticksToDuration[ticks.toString()] = durations[i] + dots;
					dots += 'd'
				}
			}
			return ticksToDuration;
		}
        if (!smoMusic._ticksToDuration) {
		   _ticksToDurationsF();
        }
		return smoMusic._ticksToDuration;
	};

	// ### durationToTicks
	// Uses VF.durationToTicks, but handles dots.
	static durationToTicks(duration) {
		var dots = duration.indexOf('d');
		if (dots < 0) {
			return VF.durationToTicks(duration);
		} else {
			var vfDuration = VF.durationToTicks(duration.substring(0, dots));
			dots = duration.length - dots; // number of dots
			var split = vfDuration / 2;
			for (var i = 0; i < dots; ++i) {
				vfDuration += split;
				split = split / 2;
			}

			return vfDuration;
		}
	}


	static gcdMap(duration) {
        var keys = Object.keys(smoMusic.ticksToDuration).map((x) => parseInt(x));
        var dar = [];

        var gcd = function(td) {
            var rv = keys[0];
            for (var k = 1;k<keys.length;++k) {
                if (td % keys[k] == 0) {
                    rv = keys[k]
                }
            }
            return rv;
        }
        while (duration > 0 && !smoMusic.ticksToDuration[duration]) {
            var div = gcd(duration);
            duration = duration - div;
            dar.push(div);
        }
        if (duration > 0) {
            dar.push(duration);
        }
        return dar.sort((a,b) => a > b ? -1 : 1);
    }

}
;
VF = Vex.Flow;
Vex.Xform = (typeof(Vex.Xform) == 'undefined' ? {}
	 : Vex.Xform);
VX = Vex.Xform;

// ## smoSerialize
// Helper functions that perform serialized merges, general JSON
// types of routines.
// ---
class smoSerialize {

	// ### filteredMerge
	// Like vexMerge, but only for specific attributes.
	static filteredMerge(attrs, src, dest) {
		attrs.forEach(function (attr) {
			if (typeof(src[attr]) != 'undefined') {
				dest[attr] = src[attr];
			}
		});
	}

    static get localScore() {
        return '_smoosicScore';
    }

    // This is the token map we use to reduce the size of
    // serialized data.
    static get tokenMap() {
 var _tm=`{
     "a": "score",
     "b": "layout",
     "c": "leftMargin",
     "d": "rightMargin",
     "e": "topMargin",
     "f": "bottomMargin",
     "g": "pageWidth",
     "h": "pageHeight",
     "i": "orientation",
     "j": "interGap",
     "k": "intraGap",
     "l": "svgScale",
     "m": "zoomScale",
     "n": "zoomMode",
     "o": "pages",
     "p": "pageSize",
     "q": "startIndex",
     "r": "renumberingMap",
     "s": "staves",
     "t": "staffId",
     "u": "staffX",
     "v": "staffY",
     "w": "adjY",
     "x": "staffWidth",
     "y": "staffHeight",
     "z": "keySignatureMap",
     "aa": "instrumentInfo",
     "ba": "instrumentName",
     "ca": "keyOffset",
     "da": "clef",
     "ea": "modifiers",
     "fa": "startSelector",
     "ga": "staff",
     "ha": "measure",
     "ia": "voice",
     "ja": "tick",
     "ka": "pitches",
     "la": "endSelector",
     "ma": "xOffset",
     "na": "cp1y",
     "oa": "cp2y",
     "pa": "attrs",
     "qa": "id",
     "ra": "type",
     "sa": "ctor",
     "ta": "yOffset",
     "ua": "position",
     "va": "measures",
     "wa": "timeSignature",
     "xa": "keySignature",
     "ya": "measureNumber",
     "za": "measureIndex",
     "ab": "systemIndex",
     "bb": "adjX",
     "cb": "tuplets",
     "db": "voices",
     "eb": "notes",
     "fb": "ticks",
     "gb": "numerator",
     "hb": "denominator",
     "ib": "remainder",
     "jb": "letter",
     "kb": "octave",
     "lb": "accidental",
     "mb": "symbol",
     "nb": "bpm",
     "ob": "display",
     "pb": "beatDuration",
     "qb": "beamBeats",
     "rb": "endBeam",
     "sb": "textModifiers",
     "tb": "text",
     "ub": "endChar",
     "vb": "fontInfo",
     "wb": "size",
     "xb": "family",
     "yb": "style",
     "zb": "weight",
     "ac": "classes",
     "bc": "verse",
     "cc": "fill",
     "dc": "scaleX",
     "ec": "scaleY",
     "fc": "translateX",
     "gc": "translateY",
     "hc": "selector",
     "ic": "renderedBox",
     "jc": "x",
     "kc": "y",
     "lc": "width",
     "mc": "height",
     "nc": "logicalBox",
     "oc": "noteType",
     "pc": "cautionary",
     "qc": "articulations",
     "rc": "articulation",
     "sc": "activeVoice",
     "tc": "flagState",
     "uc": "invert",
     "vc": "fontSize",
     "wc": "yOffsetLine",
     "xc": "yOffsetPixels",
     "yc": "scoreText",
     "zc": "backup",
     "ad": "edited",
     "bd": "pagination",
     "cd": "boxModel",
     "dd": "justification",
     "ed": "autoLayout",
     "fd": "ornaments",
     "gd": "offset",
     "hd": "ornament",
     "id": "tempoMode",
     "jd": "tempoText",
     "kd": "barline",
     "ld": "systemBreak",
     "md": "graceNotes",
    "nd": "tones",
    "od": "tuplet",
    "pd": "beam_group",
    "qd": "renderId",
    "rd": "numNotes",
    "sd": "totalTicks",
    "td": "stemTicks",
    "ud": "durationMap",
    "vd": "bracketed",
    "wd": "ratioed",
    "xd": "location",
     "yd": "systemGroups",
     "zd": "leftConnector",
     "ae": "padLeft",
     "be": "customStretch",
      "ce": "engravingFont",
      "de": "customProportion",
      "ee": "columnAttributeMap",
      "fe": "tempo"
    }`
      ;
     return JSON.parse(_tm);
    }

    static get valueTokens() {
        var vm = `{"@sn","SmoNote"}`;
        return JSON.parse(vm);
    }

    static reverseMap(map) {
        var rv = {};
        var keys = Object.keys(map);
        keys.forEach((key) => {
            rv[map[key]] = key;
        });
        return rv;
    }

    static get tokenValues() {
        return smoSerialize.reverseMap(smoSerialize.tokenMap);
    }

    // ## detokenize
    // If we are saving, replace token values with keys, since the keys are smaller.
    // if we are loading, replace the token keys with values so the score can
    // deserialize it
    static detokenize(json,dictionary) {
        var rv = {};

        var smoKey = (key) => {
            return dictionary[key] ? dictionary[key] : key;
        }

        var n1 = 0;
        var n2=-1;
        var _tokenRecurse = (input,output) =>  {
            var keys = Object.keys(input);
            keys.forEach((key) => {
                var val = input[key];
                var dkey = smoKey(key);
                if (typeof(val) == 'string' || typeof(val) == 'number' || typeof(val) == 'boolean') {
                    output[dkey] = val;
                }
                if (typeof(val) == 'object' && key != 'dictionary') {
                    if (Array.isArray(val)) {
                        output[dkey] = [];
                        val.forEach((arobj) => {
                            if (typeof(arobj) == 'string' || typeof(arobj) == 'number' || typeof(arobj) == 'boolean') {
                                output[dkey].push(arobj);
                            }
                            else if (arobj && typeof(arobj) == 'object') {
                                var nobj = {};
                                _tokenRecurse(arobj,nobj);
                                output[dkey].push(nobj);
                            }
                        });
                    } else {
                        var nobj = {};
                      _tokenRecurse(val,nobj);
                      output[dkey] = nobj;
                   }
                }
            });

        }
        _tokenRecurse(json,rv);
        // console.log(JSON.stringify(rv,null,' '));
        return rv;
    }

    static incrementIdentifier(label) {
        var increcurse = (ar,ix) => {
            var n1 = (ar[ix].charCodeAt(0)-97)+1;
            if (n1 > 25) {
                ar[ix]='a';
                if (ar.length <= ix+1) {
                    ar.push('a');
                } else {
                   increcurse(ar,ix+1);
                }
            } else {
                ar[ix] = String.fromCharCode(97+n1);
            }
        }
        if (!label) {
            label = 'a';
        }
        var ar = label.split('');
        increcurse(ar,0);
        label = ar.join('');
        return label;
    }

    // used to generate a tokenization scheme that I will use to make
    // saved files smaller
    static jsonTokens(json) {
        var map = {};
        var valmap = {};
        var startKeys = Object.keys(smoSerialize.tokenMap);
        var keyLabel = startKeys[startKeys.length - 1];
        keyLabel = smoSerialize.incrementIdentifier(keyLabel);

        var exist = smoSerialize.tokenValues;
        var addMap = (key) => {
            if (!exist[key] && !map[key] && key.length > keyLabel.length) {
                map[key] = keyLabel;
                keyLabel = smoSerialize.incrementIdentifier(keyLabel);
            }
        }
        var _tokenRecurse = (obj) =>  {
            var keys = Object.keys(obj);
            keys.forEach((key) => {
                var val = obj[key];
                if (typeof(val) == 'string' || typeof(val) == 'number'
                 || typeof(val) == 'boolean') {
                    addMap(key);
                }
                if (typeof(val) == 'object') {
                    if (Array.isArray(val)) {
                        addMap(key);
                        val.forEach((arobj) => {
                            if (arobj && typeof(arobj) == 'object') {
                                _tokenRecurse(arobj);
                            }
                        });
                    } else {
                        addMap(key);
                      _tokenRecurse(val);
                   }
                }

            });
        }
        _tokenRecurse(json);
        var mkar = Object.keys(map);
        var m2 = {};
        mkar.forEach((mk) => {
            m2[map[mk]] = mk;
        })
        console.log(JSON.stringify(m2,null,' '));
    }
	// ### serializedMerge
	// serialization-friendly, so merged, copied objects are deep-copied
	static serializedMerge(attrs, src, dest) {
		attrs.forEach(function (attr) {
			if (typeof(src[attr]) != 'undefined') {
				// copy the number 0
				if (typeof(src[attr]) === 'number' ||
					typeof(src[attr]) === 'boolean' ||
                    typeof(src[attr]) === 'string') {
					dest[attr] = src[attr];
					// copy the empty array
				} else if (Array.isArray(src[attr])) {
					dest[attr] = JSON.parse(JSON.stringify(src[attr]));
				} else {
					// but don't copy empty/null objects
					if (src[attr]) {
						if (typeof(src[attr]) == 'object') {
							dest[attr] = JSON.parse(JSON.stringify(src[attr]));
						} else {
							dest[attr] = src[attr];
						}
					}
				}
			}
		});
	}

    // ### serializedMergeNonDefault
    // Used to reduce size of serializations.  Create a serialzation of
    // the object, but don't serialize attributes that are already the default
    // since the default will be set when the object is deserialized
    // #### parameters:
    //     defaults - default Array
    //     attrs - array of attributes to save
    //     src - the object to serialize
    //     dest - the json object that is the target.
    static serializedMergeNonDefault(defaults,attrs,src,dest) {
        attrs.forEach(function (attr) {
			if (typeof(src[attr]) != 'undefined') {
				// copy the number 0
				if (typeof(src[attr]) === 'number' ||
					typeof(src[attr]) === 'boolean' ||
                    typeof(src[attr]) === 'string' ) {
                        if (src[attr] != defaults[attr]) {
					        dest[attr] = src[attr];
                        }
					// copy the empty array
				} else if (Array.isArray(src[attr])) {
                    var defval = JSON.stringify(defaults[attr]);
                    var srcval = JSON.stringify(src[attr]);
                    if (defval != srcval) {
					    dest[attr] = JSON.parse(srcval);
                    }
				} else {
					// but don't copy empty/null objects
					if (src[attr]) {
						if (typeof(src[attr]) == 'object') {
                            var defval = JSON.stringify(defaults[attr]);
                            var srcval = JSON.stringify(src[attr]);
                            if (defval != srcval) {
                                dest[attr] = JSON.parse(srcval);
                            }
						} else {
                            if (src[attr] != defaults[attr]) {
							    dest[attr] = src[attr];
                            }
						}
					}
				}
			}
		});
    }

	static stringifyAttrs(attrs, obj) {
		var rv = '';
		attrs.forEach((attr) => {
			if (obj[attr]) {
				rv += attr + ':' + obj[attr] + ', ';
			} else {
				rv += attr + ': null,';
			}
		});
		return rv;
	}

  // ### printXlate
  // print json with string labels to use as a translation file seed.
  static printTranslate(_class) {
    var xxx = eval(_class+'.printTranslate');
    if (typeof(xxx) === 'function') {
      xxx();
    }

  }
}
;

// ## svgHelpers
// Mostly utilities for converting coordinate spaces based on transforms, etc.
// ### static class methods:
// ---
class svgHelpers {


	static get namespace() {
		return "http://www.w3.org/2000/svg";
	}

  // ### gradient
  // Create an svg linear gradient.
  // Stops look like this:
  // `[{color:"#eee", offset:"0%",opacity:0.5}]`
  // orientation is horizontal or vertical
  static gradient(svg,id,orientation,stops) {
    var ns = svgHelpers.namespace;
    var x2 = orientation === 'vertical' ? 0 : 1;
    var y2 = orientation === 'vertical' ? 1 : 0;

    var e = document.createElementNS(ns, 'linearGradient');
    e.setAttributeNS('','id',id);
    e.setAttributeNS('','x1',0);
    e.setAttributeNS('','x2',x2);
    e.setAttributeNS('','y1',0);
    e.setAttributeNS('','y2',y2);
    stops.forEach((stop) => {
      var s = document.createElementNS(ns, 'stop');
      var opacity = stop.opacity ? 1 : stop.opacity;
      s.setAttributeNS('','stop-opacity',opacity);
      s.setAttributeNS('','stop-color',stop.color);
      s.setAttributeNS('','offset',stop.offset);
      e.appendChild(s);

    });
    svg.appendChild(e);
  }

  static renderCursor(svg,x,y,height) {
    var ns = svgHelpers.namespace;
    const width = height * 0.4;
    x = x - (width / 2);
    var mcmd = (d,x,y) => {
      return d + 'M '+x+' '+y+' ';
    };
    var qcmd = (d,x1,y1,x2,y2) => {
      return d + 'q ' + x1 + ' ' + y1 + ' ' + x2 + ' ' + y2 + ' ';
    };
    var lcmd = (d,x,y) => {
      return d + 'L ' + x + ' ' + y + ' ';
    };
    var x1 = (width / 2) * .333;
    var y1 = -1*(x1 / 4);
    var x2 = (width / 2);
    var y2 = x2 / 4;
    var ns = svgHelpers.namespace;
    var e = document.createElementNS(ns, 'path');
    var d = '';
    d = mcmd(d,x,y);
    d = qcmd(d,x1,y1,x2,y2);
    d = lcmd(d,x + (width / 2),y + height - (width / 8));
    d = mcmd(d,x+width,y);
    d = qcmd(d,-1*x1,y1,-1*x2,y2);
    d = mcmd(d,x,y + height);
    d = qcmd(d,x1,-1*y1,x2,-1*y2);
    d = mcmd(d,x+width,y + height);
    d = qcmd(d,-1*x1, -1 * y1, -1 * x2, -1 * y2);
    e.setAttributeNS('','d',d);
    e.setAttributeNS('','stroke-width','1');
    e.setAttributeNS('','stroke','#555');
    e.setAttributeNS('','fill','none');
    svg.appendChild(e);
  }

	static buildSvg(el) {

		var smoSvgBuilder = function (el) {
			var ns = svgHelpers.namespace;
			this.e = document.createElementNS(ns, el);
			var self = this;
			this.classes = function (cl) {
				self.e.setAttributeNS('', 'class', cl);
				return self;
			}
			this.attr = function (name, value) {
				self.e.setAttributeNS('', name, value);
				return self;
			}

			this.text = function (x, y, classes, text) {
				x = typeof(x) == 'string' ? x : x.toString();
				y = typeof(y) == 'string' ? y : y.toString();
				this.e.setAttributeNS('', 'class', classes);
				this.e.setAttributeNS('', 'x', x);
				this.e.setAttributeNS('', 'y', y);

				this.e.textContent = text;
				return this;
			}
			this.rect = function (x, y, width, height, classes) {
				x = typeof(x) == 'string' ? x : x.toString();
				y = typeof(y) == 'string' ? y : y.toString();
				width = typeof(width) == 'string' ? width : width.toString();
				height = typeof(height) == 'string' ? height : height.toString();
				this.e.setAttributeNS('', 'x', x);
				this.e.setAttributeNS('', 'y', y);
				this.e.setAttributeNS('', 'width', width);
				this.e.setAttributeNS('', 'height', height);
				if (classes) {
					this.e.setAttributeNS('', 'class', classes);
				}
				return this;
			}
			this.line = function (x1, y1, x2, y2, classes) {
				x1 = typeof(x1) == 'string' ? x1 : x1.toString();
				y1 = typeof(y1) == 'string' ? y1 : y1.toString();
				x2 = typeof(x2) == 'string' ? x2 : x2.toString();
				y2 = typeof(y2) == 'string' ? y2 : y2.toString();

				this.e.setAttributeNS('', 'x1', x1);
				this.e.setAttributeNS('', 'y1', y1);
				this.e.setAttributeNS('', 'x2', x2);
				this.e.setAttributeNS('', 'y2', y2);
				if (classes) {
					this.e.setAttributeNS('', 'class', classes);
				}
				return this;
			}
			this.append = function (el) {
				self.e.appendChild(el.e);
				return self;
			}
			this.dom = function () {
				return self.e;
			}
			return this;
		}
		return new smoSvgBuilder(el);
	}

	// ### boxNote
	// update the note geometry based on current viewbox conditions.
	// This may not be the appropriate place for this...maybe in layout
	static updateArtifactBox(svg,element,artifact) {
		artifact.renderedBox = svgHelpers.smoBox(element.getBoundingClientRect());
		artifact.logicalBox = svgHelpers.smoBox(element.getBBox());
	}

  // ### eraseOutline
  // Erases old outlineRects.
  static eraseOutline(context,style) {
  		$(context.svg).find('g.vf-' + style).remove();
  }

  static _outlineRect(params) {
    const stroke = params.outlineStroke;
    const scroller = params.scroller;
    const context = params.context;
    svgHelpers.eraseOutline(context,params.classes);
    // Don't highlight in print mode.
    if ($('body').hasClass('printing')) {
      return;
    }
    var grp = context.openGroup(params.classes, params.classes + '-outline');
    const boxes = Array.isArray(params.box) ? params.box : [params.box];

    boxes.forEach((box) => {
      if (box) {
        var strokeObj = params.outlineStroke;
        var margin = 5;
        if (params.clientToLogical === true) {
          box = svgHelpers.clientToLogical(context.svg, svgHelpers.adjustScroll(box,scroller.netScroll));
        }
        context.rect(box.x - margin, box.y - margin, box.width + margin * 2, box.height + margin * 2, strokeObj);
      }
    });
    context.closeGroup(grp);
  }


  // ### outlineRect
  // Usage:
  //  outlineRect(params)
  // params ({context,box,outlineStroke,classes,scroller})
  // outlineStroke: {stroke, strokeWidth, strokeDashArray, fill}
  static outlineRect(params) {
    params.clientToLogical = true;
    svgHelpers._outlineRect(params);
  }

  static outlineLogicalRect(params) {
    svgHelpers._outlineRect(params);
  }


  static rect(svg,box,attrs,classes) {
    var rect = document.createElementNS(svgHelpers.namespace,'rect');
    var attrKeys = Object.keys(attrs);
    attrKeys.forEach((key) => {
      var val = attrs[key];
      key = (key == 'strokewidth') ? 'stroke-width' : key;
      rect.setAttributeNS('', key, val);
    });
    if (classes) {
      rect.setAttributeNS('','class',classes);
    }
    svg.appendChild(rect);
    return rect;
  }

  static line(svg,x1,y1,x2,y2,attrs,classes) {
    var line = document.createElementNS(svgHelpers.namespace,'line');
    x1 = typeof(x1) == 'string' ? x1 : x1.toString();
    y1 = typeof(y1) == 'string' ? y1 : y1.toString();
    x2 = typeof(x2) == 'string' ? x2 : x2.toString();
    y2 = typeof(y2) == 'string' ? y2 : y2.toString();

    line.setAttributeNS('', 'x1', x1);
    line.setAttributeNS('', 'y1', y1);
    line.setAttributeNS('', 'x2', x2);
    line.setAttributeNS('', 'y2', y2);
    attrs = (attrs) ? attrs : [];
    attrs.forEach((attr) => {
      var key = Object.keys(attr)[0];
      var val = attr[key];
      key = (key == 'strokewidth') ? 'stroke-width' : key;
      line.setAttributeNS('', key, val);
    });
    if (classes) {
      line.setAttributeNS('', 'class', classes);
    }
    svg.appendChild(line);
  }

  static arrowDown(svg,box,attrs,classes) {
    svgHelpers.line(svg,box.x+box.width/2,box.y,box.x+box.width/2,box.y+box.height);
    var arrowY=box.y + box.height/4;
    svgHelpers.line(svg,box.x,arrowY,box.x+box.width/2,box.y+box.height);
    svgHelpers.line(svg,box.x+box.width,arrowY,box.x+box.width/2,box.y+box.height);
  }


	// ### getTextBox
	// Get the logical bounding box of the text for placement.
	static getTextBox(svg,attributes,classes,text) {
		var el = svgHelpers.placeSvgText(svg,attributes,classes,text);
		var box = el.getBBox();
		svg.removeChild(el);
		return box;
	}

	static debugBox(svg, box, classes, voffset) {
		voffset = voffset ? voffset : 0;
		classes = classes ? classes : '';
        if (!box)
           return;
		classes += ' svg-debug-box';
		var b = svgHelpers.buildSvg;
		var mid = box.x + box.width / 2;
		var xtext = 'x1: ' + Math.round(box.x);
		var wtext = 'x2: ' + Math.round(box.width+box.x);
		var ytext = 'y1: ' + Math.round(box.y);
		var htext = 'y2: ' + Math.round(box.height+box.y);
		var ytextp = Math.round(box.y+box.height);
		var ytextp2 = Math.round(box.y+box.height-30);

		var r = b('g').classes(classes)
			.append(
				b('text').text(box.x + 20, box.y - 14+voffset, 'svg-debug-text', xtext))
			.append(
				b('text').text(mid - 20, box.y - 14+voffset, 'svg-debug-text', wtext))
			.append(
				b('line').line(box.x, box.y - 2, box.x + box.width, box.y - 2))
			.append(
				b('line').line(box.x, box.y - 8, box.x, box.y + 5))
			.append(
				b('line').line(box.x + box.width, box.y - 8, box.x + box.width, box.y + 5))
			.append(
				b('text').text(Math.round(box.x-14+voffset), ytextp, 'svg-vdebug-text', ytext)
				  .attr('transform','rotate(-90,'+Math.round(box.x-14+voffset)+','+ytextp+')'));
		if (box.height > 2) {
			r.append(
				b('text').text(Math.round(box.x-14+voffset), ytextp2, 'svg-vdebug-text', htext)
				  .attr('transform','rotate(-90,'+Math.round(box.x-14+voffset)+','+(ytextp2)+')'))
				  .append(
				b('line').line(Math.round(box.x-2), Math.round(box.y +box.height),box.x-2,box.y))
				  .append(
				b('line').line(Math.round(box.x-8), Math.round(box.y +box.height),box.x+6,Math.round(box.y+box.height)))
				  .append(
				b('line').line(Math.round(box.x-8), Math.round(box.y),Math.round(box.x+6),Math.round(box.y)));
		}
		svg.appendChild(r.dom());
	}

  static fontIntoToSvgAttributes(fontInfo) {
    var rv = [];
    var fkeys = Object.keys(fontInfo);
  	fkeys.forEach((key) => {
  		var n='{"font-'+key+'":"'+fontInfo[key]+'"}';
  		rv.push(JSON.parse(n));
  	});
      return rv;
  }

  static debugSvgGlyph(glyphCode,fontSize) {
    var rr = new VF.Renderer($('#boo')[0],VF.Renderer.Backends.SVG);
    const glyph=new Vex.Flow.Glyph(glyphCode, fontSize);
    var context = suiLayoutBase._renderer.getContext();
    $('.debugSvgGlyph').remove();
    var group = context.openGroup();
    group.classList.add('debugSvgGlyph');
    glyph.render(context, 150, 50);
    context.closeGroup();
    return svgHelpers.copyBox($('.debugSvgGlyph')[0].getBBox());
  }

  static debugSvgFont(fontFamily,fontSize,str) {
    const xoff = 20;
    const yoff = 50;
    str = str.replace('&','&amp;');
    str = str.replace('<','&lt;');
    var svg = $('#boo svg')[0];
    var attributes = [{x:xoff},{y:yoff},{"font-family":fontFamily},{"font-size":fontSize}];
    var classes = 'dbg-svg-font';
    $('.dbg-svg-font').remove();
    svgHelpers.placeSvgText(svg,attributes,classes,str,'debugSvgFont');
    var box = svgHelpers.smoBox($('#debugSvgFont')[0].getBBox());
    return svgHelpers.boxPoints(box.x - xoff,box.y - (yoff - box.height),box.width,box.height);
  }

  static svgFontInfo(fontFamily,fontSize) {
    var metrics = [];
    for (var i = 33;i < 95; ++i) {
      var st = String.fromCharCode(i);
      var metric = svgHelpers.debugSvgFont(fontFamily,fontSize,st);
      metrics.push({charCode:st,...metric});
    }
    return metrics;
  }

	static placeSvgText(svg,attributes,classes,text,id) {
		var ns = svgHelpers.namespace;
		var e = document.createElementNS(ns, 'text');
		attributes.forEach((attr) => {
			var key = Object.keys(attr)[0];
		    e.setAttributeNS('', key, attr[key]);
		})
		if (classes) {
			e.setAttributeNS('', 'class', classes);
		}
    var dp = new DOMParser();
    var id = id ? id : 'smootext';
    var tn = dp.parseFromString('<tspan xmlns="http://www.w3.org/2000/svg" id="'+id+'">'+text+'</tspan>','application/xml');
    var st = tn.getElementById(id);
		e.appendChild(st);
		svg.appendChild(e);
		return e;
	}

    // ### findIntersectingArtifactFromMap
    // Same as findIntersectionArtifact but uses a map of keys instead of an array
    static findIntersectingArtifactFromMap(clientBox,map,netScroll) {
        var box = svgHelpers.smoBox(clientBox); //svgHelpers.untransformSvgPoint(this.context.svg,clientBox);

		// box.y = box.y - this.renderElement.offsetTop;
		// box.x = box.x - this.renderElement.offsetLeft;
		var rv = [];

		Object.keys(map).forEach((k) => {
            var object = map[k];
			// Measure has been updated, but not drawn.
			if (!object.box) {
				// console.log('there is no box');
			} else {
				var obox = svgHelpers.adjustScroll(svgHelpers.smoBox(object.box),netScroll);
				var i1 = box.x - obox.x; // handle edge not believe in x and y
				var i2 = box.y - obox.y;
				if (i1 > 0 && i1 < object.box.width && i2 > 0 && i2 < object.box.height) {
					rv.push(object);
				}
			}
		});

		return rv;

    }

  static containsPoint(box,point, netScroll) {
    var obox = svgHelpers.adjustScroll(svgHelpers.smoBox(box),netScroll);
    const i1 = point.x - box.x; // handle edge not believe in x and y
    const i2 = point.y - box.y;
    if (i1 > 0 && i1 < obox.width && i2 > 0 && i2 < obox.height) {
      return true;
    }
    return false;
  }

	// ### findIntersectionArtifact
	// find all object that intersect with the rectangle
	static findIntersectingArtifact(clientBox, objects,netScroll) {
		var box = svgHelpers.smoBox(clientBox); //svgHelpers.untransformSvgPoint(this.context.svg,clientBox);

		// box.y = box.y - this.renderElement.offsetTop;
		// box.x = box.x - this.renderElement.offsetLeft;
		var rv = [];
		if (typeof(objects['forEach']) != 'function') {
			console.log('corrupt objects in findIntersectingArtifact');
		}
		objects.forEach((object) => {
			// Measure has been updated, but not drawn.
			if (!object.box) {
				// console.log('there is no box');
			} else {
				var obox = svgHelpers.adjustScroll(svgHelpers.smoBox(object.box),netScroll);
				var i1 = box.x - obox.x; // handle edge not believe in x and y
				var i2 = box.y - obox.y;
				if (i1 > 0 && i1 < object.box.width && i2 > 0 && i2 < object.box.height) {
					rv.push(object);
				}
			}
		});

		return rv;
	}
	static findSmallestIntersection(clientBox, objects, netScroll) {
		var ar = svgHelpers.findIntersectingArtifact(clientBox, objects, netScroll);
		if (!ar.length) {
			return null;
		}
		var rv = ar[0];
		var min = ar[0].box.width * ar[0].box.height;
		ar.forEach((obj) => {
			var tst = obj.box.width * obj.box.height;
			if (tst < min) {
				rv = obj;
				min = tst;
			}
		});
		return rv;
	}

    static translateElement(g,x,y) {
        g.setAttributeNS('','transform','translate('+x+' '+y+')');
    }

	// ### measureBBox
	// Return the bounding box of the measure
	static measureBBox(b1, measure, staff) {
		if (measure.renderedBox) {
			if (b1['width']) {
				return svgHelpers.unionRect(b1, measure.renderedBox);
			} else {
				return measure.renderedBox;
			}
		} else {
			var mbox = {
				x: measure.staffX,
				y: staff.staffY,
				width: measure.staffWidth,
				height: staff.staffHeight
			};
			if (b1['width']) {
				return mbox;
			}
			return svgHelpers.unionRect(b1, mbox);
		}
	}
    // ### measurePerInch
    // Supported font units
    static get unitsPerInch() {
        var rv = {};

        rv['pt']=72.0;
        rv['px']=96.0;
        rv['em']=6.0;
        return rv;
    }

    // ### getFontSize
    // Given '1em' return {size:1.0,unit:em}
    static getFontSize(fs) {
        var size=parseFloat(fs);
        var measure = fs.substr(fs.length-2,2);
        return {size:size,unit:measure};
    }

    static convertFont(size,o,n) {
        return size*(svgHelpers.unitsPerInch[o]/svgHelpers.unitsPerInch[n]);
    }

	static stringify(box) {
		if (box['width']) {

			return JSON.stringify({
				x: box.x,
				y: box.y,
				width: box.width,
				height: box.height
			}, null, ' ');
		} else {
			return JSON.stringify({
				x: box.x,
				y: box.y
			}, null, ' ');
		}
	}

	static log(box) {
		if (box['width']) {
			console.log(JSON.stringify({
					x: box.x,
					y: box.y,
					width: box.width,
					height: box.height
				}, null, ' '));
		} else {
			console.log('{}');
		}
	}

	// ### pointBox
	// return a point-sized box at the given coordinate
	static pointBox(x, y) {
		return {
			x: x,
			y: y,
			width: 0,
			height: 0
		};
	}


	// ### smoBox:
	// return a simple box object that can be serialized, copied
	// (from svg DOM box)
	static smoBox(box) {
    var hround = (f) => {
      return Math.round((f + Number.EPSILON) * 100) / 100;
    }
        var x = typeof(box.x) == 'undefined' ? hround(box.left) : hround(box.x);
        var y = typeof(box.y) == 'undefined' ? hround(box.top) : hround(box.y);
		return ({
			x: hround(x),
			y: hround(y),
			width: hround(box.width),
			height: hround(box.height)
		});
	}
  // ### unionRect
  // grow the bounding box two objects to include both.
  static unionRect(b1, b2) {
    var x = Math.min(b1.x, b2.x);
    var y = Math.min(b1.y, b2.y);
    var width = Math.max(b1.x + b1.width, b2.x + b2.width) - x;
    var height = Math.max(b1.y + b1.height, b2.y + b2.height) - y;
    return {
      x: x,
      y: y,
      width: width,
      height: height
    };
  }

    // ### adjustScroll
    // Add the scroll to the screen coordinates so we can find the mapped
    // location of something.
    static adjustScroll(box,scroll) {
        // WIP...
        if (typeof(box) == 'undefined' || typeof(scroll) == 'undefined') {
            console.log('bad values to scroll thing');
            return;
        }
        return svgHelpers.boxPoints(box.x - scroll.x,box.y-scroll.y,box.width,box.height);
        // return box;
    }

	static boxPoints(x, y, w, h) {
		return ({
			x: x,
			y: y,
			width: w,
			height: h
		});
	}

	static copyBox(box) {
        box = svgHelpers.smoBox(box);
		return {
			x: box.x,
			y: box.y,
			width: box.width,
			height: box.height
		};
	}

	// ### svgViewport
	// set `svg` element to `width`,`height` and viewport `scale`
	static svgViewport(svg, xOffset,yOffset,width, height, scale) {
		svg.setAttributeNS('', 'width', '' + width);
		svg.setAttributeNS('', 'height', '' + height);
		svg.setAttributeNS('', 'viewBox', ''+xOffset + ' ' + yOffset + ' ' + Math.round(width / scale) + ' ' +
			Math.round(height / scale));
	}

	// ### logicalToClient
	// Convert a point from logical (pixels) to actual screen dimensions based on current
	// zoom, aspect ratio
	/* static logicalToClient(svg, logicalPoint) {
	var rect = svg.getBoundingClientRect();
	var rv = svgHelpers.copyBox(logicalPoint);
	rv.x += rect.x;
	rv.y += rect.y;
	return rv;
	}   */

	// ### clientToLogical
	// return a box or point in svg coordintes from screen coordinates
	static clientToLogical(svg, point) {
		var pt = svg.createSVGPoint();
        if (!point)
           return;
        var x = typeof(point.x) != 'undefined' ? point.x : point.left;
        var y = typeof(point.y) != 'undefined' ? point.y : point.top;
		pt.x = x;
		pt.y = y;
		var sp = pt.matrixTransform(svg.getScreenCTM().inverse());
		if (typeof(point['width']) == 'undefined') {
			return {
				x: sp.x,
				y: sp.y
			};
		}

		var endPt = svg.createSVGPoint();
		endPt.x = pt.x + point.width;
		endPt.y = pt.y + point.height;
		var ep = endPt.matrixTransform(svg.getScreenCTM().inverse());
		return {
			x: sp.x,
			y: sp.y,
			width: ep.x - sp.x,
			height: ep.y - sp.y
		};
	}

	// ### logicalToClient
	// return a box or point in screen coordinates from svg coordinates
	static logicalToClient(svg, point) {
		var pt = svg.createSVGPoint();
		pt.x = point.x;
		pt.y = point.y;
		var sp = pt.matrixTransform(svg.getScreenCTM());
		if (!point['width']) {
			return {
				x: sp.x,
				y: sp.y
			};
		}
		var endPt = svg.createSVGPoint();
		endPt.x = pt.x + point.width;
		endPt.y = pt.y + point.height;
		var ep = endPt.matrixTransform(svg.getScreenCTM());
		return {
			x: sp.x,
			y: sp.y,
			width: ep.x - sp.x,
			height: ep.y - sp.y
		};
	}
}
;
var smoDomBuilder = function (el) {}

// # htmlHelpers
// # Description:
//  Helper functions for buildling UI elements
class htmlHelpers {
	// ## buildDom
	// ## Description:
	// returns an object that  lets you build a DOM in a somewhat readable way.
	// ## Usage:
	// var b = htmlHelpers.buildDom;
	//  var r =
	// b('tr').classes('jsSharingMember').data('entitykey', key).data('name', name).data('entitytype', entityType).append(
	// b('td').classes('noSideBorderRight').append(
	// ...
	// $(parent).append(r.dom());
	//
	// Don't forget the '.dom()' !  That is the actual jquery element object
	static buildDom(el) {
		var smoDomBuilder = function (el) {
			this.e = $('<' + el + '/>');
			var self = this;
			this.classes = function (cl) {
				$(self.e).addClass(cl);
				return self;
			}
      this.html = function(value) {
        $(self.e).html(value);
        return self;
      }
			this.data = function (name, value) {
				$(self.e).attr('data-' + name, value);
				return self;
			}
			this.attr = function (name, value) {
				$(self.e).attr(name, value);
				return self;
			}
			this.css = function (name, value) {
				$(self.e).css(name, value);
				return self;
			}
			this.append = function (el) {
				$(self.e).append(el.e);
				return self;
			}
			this.text = function (tx) {
				$(self.e).append(document.createTextNode(tx));
				return self;
			}
			this.dom = function () {
				return self.e;
			}
			return this;
		}
		return new smoDomBuilder(el);
	}
	static draggable(parameters) {
		return new draggable(parameters);
	}

	static get focusableElements() {
		return ['a', 'input', 'select', 'textarea', 'button', 'li[tabindex]', 'div[tabindex]'];
	}
    static addFileLink(filename,txt,parent) {
        var anchor = $('<a></a>');
        var url = URL.createObjectURL(new Blob([txt],{type:'application/octet-stream'}));
        $(anchor).attr('href',url);
        $(anchor).attr('download',filename);
        $(anchor).text('save');
        $(parent).html('');
        $(parent).append(anchor);
    }

	static inputTrapper(selector) {
		var trapper = function () {
			this.parent = $(selector);
			this.id = $(this.parent).attr('id');
			this.parentId = $(this.parent).parent().attr('id');
			var idstr = Math.round(Math.random() * (999999 - 1) + 1);
			if (!this.id) {
				$(this.parent).attr('id', idstr + '-element');
				this.id = $(this.parent).attr('id');
			}
			if (!this.parentId) {
				$(this.parent).parent().attr('id', idstr + '-parent');
				this.parentId = $(this.parent).parent().attr('id');
			}
			this.modalInputs = [];
			this.disabledInputs = [];
			this.siblingInputs = [];

			// aria-hide peers of dialog and peers of parent that are not the parent.
			var peers = $(this.parent).parent().children().toArray();

			peers.forEach((node) => {
				var ptag = $(node)[0].tagName;
				if (ptag === 'SCRIPT' || ptag === 'LINK' || ptag === 'STYLE') { ;
				} else if ($(node).attr('id') === this.parentId ||
					$(node).attr('id') === this.id) { ;
				} else {
					var hidden = $(node).attr('aria-hidden');
					if (!hidden || hidden != 'true') {
						$(node).attr('aria-hidden', 'true');
						this.siblingInputs.push(node);
					}
				}
			});
			htmlHelpers.focusableElements.forEach((etype) => {
				var elements = $(etype).toArray();

				elements.forEach((element) => {
					var tagName = $(element)[0].tagName;
					if ($(element).attr('id') === this.id) { ;
					} else if ($(element).prop('disabled')) { ;
					} else if ($(element).hasClass('hide')) { ;
					} else if ($(element).closest(selector).length) {
						// inside
						this.modalInputs.push(element);
					} else if ((tagName === 'A' || tagName === 'DIV' || tagName === 'LI') && $(element).attr('tabIndex') === '-1') { ;
					} else {
						this.disabledInputs.push(element);
						if (tagName === 'A' || tagName === 'DIV' || tagName === 'LI') {
							$(element).attr('tabIndex', '-1');
						} else {
							$(element).prop('disabled', true);
						}
					}
				});
			});

			this.close = function () {
				this.disabledInputs.forEach(function (element) {
					var tagName = $(element)[0].tagName;
					if (tagName === 'A' || tagName === 'DIV' || tagName === 'LI') {
						$(element).attr('tabIndex', '0');
					} else {
						$(element).prop('disabled', false);
					}
				});
				this.siblingInputs.forEach((el) => {
					$(el).removeAttr('aria-hidden');
				});
			}
		}

		return new trapper(selector);
	}

	static closeDialogPromise() {
		return new Promise((resolve, reject) => {
			$('body').off('dialogDismiss').on('dialogDismiss', function () {
				resolve();
			});
		});
	}
}

class draggable {

	constructor(parameters) {
		this.parent = parameters.parent;
		this.handle = parameters.handle;
    this.animeClass = parameters.animateDiv;
    this.dragParent = parameters.dragParent;

    // TODO: make '.dom-container' a part of the configuration
    this.domOffset =  $('.dom-container').offset();

		this.svg=parameters['svg'];
		this.width = $(this.parent).outerWidth();
		this.height = $(this.parent).outerHeight();
		this.lastX = $(this.handle).offset().left - this.domOffset.left;
		this.lastY = $(this.handle).offset().top - this.domOffset.top;
		this.cb = parameters.cb;
		this.moveParent = parameters.moveParent;

		var self = this;

		// $('.itemMenu input[name="itemTitle"]').css('width','60%');
		$(this.handle)
		.off('mousedown').on('mousedown',
			function (e) {
			self.mousedown(e);
		});
		$(document)
		.on('mousemove',
			function (e) {
			self.mousemove(e);

		})
		.on('mouseup',
			function (e) {
			self.mouseup(e);
		});
	}
  disconnect() {
    $(this.handle).off('mousedown');
    $(this.document).off('mousemove');
    $(this.handle).off('mouseup');
  }
	_animate(e) {
		this.lastX = e.clientX;
		this.lastY = e.clientY;
		$(this.animeClass).css('left', this.lastX - this.domOffset.left);
		$(this.animeClass).css('top', this.lastY - this.domOffset.top);

    if (this.dragParent) {
      $(this.parent).css('left', this.lastX + 'px');
		  $(this.parent).css('top', this.lastY + 'px');
    }
	}
	mousedown(e) {
		if (!this.dragging) {
			$(this.animeClass).removeClass('hide');

			$(this.animeClass).css('width', this.width);
			$(this.animeClass).css('height', this.height);
		}

		this.dragging = true;
		this._animate(e);
	}
	enddrag(e) {
    this.lastX = this.lastX - this.domOffset.left;
    this.lastY = this.lastY - this.domOffset.top;
		if (this.moveParent) {
			$(this.parent).css('left', this.lastX + 'px');
			$(this.parent).css('top', this.lastY + 'px');
		}
		$(this.animeClass).addClass('hide');
		this.cb(this.lastX, this.lastY);
	}

	mouseup(e) {
		// stop resizing
		if (this.dragging) {
			this.dragging = false;
			this.lastX = e.clientX;
			this.lastY = e.clientY;

			this.enddrag();
		}
	}
	mousemove(e) {
		// we don't want to do anything if we aren't resizing.
		if (!this.dragging)
			return;
		this._animate(e);
	}
}
;// ## SmoNote
// ## Description:
// Data for a musical note.  THe most-contained-thing, except there can be note modifiers
// Basic note information.  Leaf node of the SMO dependency tree (so far)
// ## SmoNote Methods
// ---
class SmoNote {
    // ### Description:
    // see defaults for params format.
    constructor(params) {
        Vex.Merge(this, SmoNote.defaults);
        smoSerialize.serializedMerge(SmoNote.parameterArray, params, this);

        // this.keys=JSON.parse(JSON.stringify(this.keys));

        if (!this['attrs']) {
            this.attrs = {
                id: VF.Element.newID(),
                type: 'SmoNote'
            };
        } else {
            // inherit attrs id for deserialized
        }
    }
    static get flagStates() {
        return {auto:0,up:1,down:2};
    }
    static get parameterArray() {
        return ['ticks', 'pitches', 'noteType', 'tuplet', 'clef', 'endBeam','beamBeats','flagState','noteHead'];
    }

    toggleFlagState() {
        this.flagState = (this.flagState + 1) % 3;
    }

    toVexStemDirection() {
        return (this.flagState == SmoNote.flagStates.up ? VF.Stem.UP : VF.Stem.DOWN);

    }
    get id() {
        return this.attrs.id;
    }

    get dots() {
        if (this.isTuplet) {
            return 0;
        }
        var vexDuration = smoMusic.ticksToDuration[this.tickCount];
        if (!vexDuration) {
            return 0;
        }
        return vexDuration.split('d').length - 1;
    }

    set dots(value) {
        // ignore - dots are a function of duration only.
    }

    // ### _addModifier
    // ### Description
    // add or remove sFz, mp, etc.
    _addModifier(dynamic, toAdd) {
        var tms = [];
        this.textModifiers.forEach((tm) => {
            if (tm.attrs.type != dynamic.attrs.type) {
                tms.push(tm);
            }
        });
        if (toAdd) {
            tms.push(dynamic);
        }
        this.textModifiers = tms;
    }

    _addArticulation(articulation, toAdd) {
        var tms = [];
        this.articulations.forEach((tm) => {
            if (tm.articulation != articulation.articulation) {
                tms.push(tm);
            }
        });
        if (toAdd) {
            tms.push(articulation);
        }
        this.articulations = tms;
    }

    addModifier(dynamic) {
        this._addModifier(dynamic, true);
    }
    removeModifier(dynamic) {
        this._addModifier(dynamic, false);
    }
    getModifiers(type) {
        var ms = this.textModifiers.filter((mod)=> {
            return mod.attrs.type === type;
        });
        return ms;
    }

    longestLyric() {
      var tms = this.textModifiers.filter((mod) => {
        return mod.attrs.type == 'SmoLyric' && mod.parser === SmoLyric.parsers.lyric;
      });
      if (!tms.length) {
        return null;
      }
      return tms.reduce((m1,m2) => {
        return m1.text.length > m2.text.length;
      });
    }

  addLyric(lyric) {
    var tms = this.textModifiers.filter((mod) => {
      return mod.attrs.type != 'SmoLyric' || mod.parser !==lyric.parser ||
        mod.verse != lyric.verse;
    });
    tms.push(lyric);
    this.textModifiers = tms;
  }

  getTrueLyrics() {
    var ms = this.textModifiers.filter((mod)=> {
      return mod.attrs.type === 'SmoLyric' && mod.parser === SmoLyric.parsers.lyric;
    });
    return ms;
  }


  removeLyric(lyric) {
    var tms = this.textModifiers.filter((mod) => {
      return mod.attrs.type != 'SmoLyric' || mod.verse != lyric.verse || mod.parser != lyric.parser;
    });
    this.textModifiers = tms;
  }

  getLyricForVerse(verse,parser) {
      return this.textModifiers.filter((mod) => {
        return mod.attrs.type == 'SmoLyric' && mod.parser === parser && mod.verse === verse;
      });
  }

  getOrnaments() {
    return this.ornaments.filter((oo) => oo.isJazz() === false);
  }

  getJazzOrnaments() {
    return this.ornaments.filter((oo) => oo.isJazz());
  }

  toggleOrnament(ornament) {
    var aix = this.ornaments.filter((a) => {
      return a.attrs.type === 'SmoOrnament' && a.ornament === ornament.ornament;
    });
    if (!aix.length) {
      this.ornaments.push(ornament);
    } else {
      this.ornaments=[];
    }
  }

    // Toggle between articulation above, below, or remove
    toggleArticulation(articulation) {
        var aix = this.articulations.findIndex((a) => {
                return a.articulation === articulation.articulation;
            });
        if (aix >= 0) {
            var cur = this.articulations[aix];
            if (cur.position == SmoArticulation.positions.above) {
                cur.position = SmoArticulation.positions.below;
                return;
            }
            else {
                this._addArticulation(articulation,false);
                return;
            }
        }
        this._addArticulation(articulation, true);
    }

    static _sortPitches(note) {
        var canon = VF.Music.canonical_notes;
        var keyIndex = ((pitch) => {
            return canon.indexOf(pitch.letter) + pitch.octave * 12;
        });
        note.pitches.sort((a, b) => {
            return keyIndex(a) - keyIndex(b);
        });
    }
    setNoteHead(noteHead) {
      if (this.noteHead === noteHead) {
        this.noteHead = '';
      } else {
        this.noteHead = noteHead;
      }
    }
    addGraceNote(params,offset) {
        params.clef = this.clef;
        if (this.graceNotes.length > offset) {
            this.graceNotes[offset]= new SmoGraceNote(params);
        } else {
            this.graceNotes.push(new SmoGraceNote(params));
        }
    }
    removeGraceNote(offset) {
        if (offset >= this.graceNotes.length) {
            return;
        }
        this.graceNotes.splice(offset,1);
    }
    getGraceNotes() {
        return this.graceNotes;
    }
    addPitchOffset(offset) {
      if (this.pitches.length == 0) {
          return this;
      }
      this.noteType = 'n';
      var pitch = this.pitches[0];
      this.pitches.push(smoMusic.getKeyOffset(pitch, offset));

      SmoNote._sortPitches(this);
    }

    makeRest() {
        this.noteType = (this.noteType == 'r' ? 'n' : 'r');
    }

    makeNote() {
        this.noteType = 'n';
    }

    get isTuplet() {
        return this['tuplet'] && this.tuplet['id'];
    }

    addMicrotone(tone) {
        var ar = this.tones.filter((tn) => tn.pitch != tone.pitch);
        ar.push(tone);
        this.tones = ar;
    }
    removeMicrotone(tone) {
        var ar = this.tones.filter((tn) => tn.pitch != tone.pitch
            && tone.tone != tn.tone);
        this.tones = ar;
    }

    getMicrotones() {
        return this.tones;
    }

    transpose(pitchArray, offset, keySignature) {
        return SmoNote._transpose(this,pitchArray,offset,keySignature);
    }
    static _transpose(note,pitchArray, offset, keySignature) {
        var pitches = [];
        note.noteType = 'n';
        if (pitchArray.length == 0) {
            note.pitches.forEach((m) => {
                pitchArray.push(note.pitches.indexOf(m));
            });
        }
        for (var j = 0; j < pitchArray.length; ++j) {
            var index = pitchArray[j];
            if (index + 1 > note.pitches.length) {
                note.addPitchOffset(offset);
            } else {
                var pitch = smoMusic.getKeyOffset(note.pitches[index], offset);
                if (keySignature) {
                    var letterKey = pitch.letter + pitch.accidental;
                    letterKey = smoMusic.getKeyFriendlyEnharmonic(letterKey, keySignature);
                    pitch.letter = letterKey[0];
                    if (letterKey.length < 2) {
                        pitch.accidental = 'n';
                    } else {
                        pitch.accidental = letterKey.substring(1);
                    }
                }
                note.pitches[index] = pitch;
            }
        }
        SmoNote._sortPitches(note);
        return note;
    }
    get tickCount() {
        return this.ticks.numerator / this.ticks.denominator + this.ticks.remainder;
    }

    describe() {
        return this.attrs.id + ' ' + this.tickCount;
    }

    static clone(note) {
        var rv = SmoNote.deserialize(note.serialize());

        // make sure id is unique
        rv.attrs = {
            id: VF.Element.newID(),
            type: 'SmoNote'
        };
        return rv;
    }

    // ## Description:
    // Clone the note, but use the different duration.  Changes the length
    // of the note but nothing else.
    static cloneWithDuration(note, ticks) {
        if (typeof(ticks) === 'number') {
            ticks = {numerator:ticks,denominator:1,remainder:0};
        }
        var rv = SmoNote.clone(note);

        rv.ticks = ticks;

        return rv;
    }

    _serializeModifiers(params) {
        ['textModifiers','graceNotes','articulations','ornaments','tones'].forEach((attr) => {
            if (this[attr] && this[attr].length) {
                params[attr] = [];
                this[attr].forEach((mod) => {
                    params[attr].push(mod.serialize());
                });
            }
        });
    }
    serialize() {
        var params = {};
        smoSerialize.serializedMergeNonDefault(SmoNote.defaults,SmoNote.parameterArray, this, params);
        if (params.ticks) {
            params.ticks = JSON.parse(JSON.stringify(params.ticks));
        }
        this._serializeModifiers(params);
        return params;
    }

    static get defaults() {
        return {
            noteType: 'n',
            noteHead: 'n',
            textModifiers: [],
            articulations: [],
            graceNotes:[],
            ornaments:[],
            tones:[],
            endBeam: false,
            beamBeats:4096,
            flagState:SmoNote.flagStates.auto,
            ticks: {
                numerator: 4096,
                denominator: 1,
                remainder: 0
            },
            pitches: [{
                    letter: 'b',
                    octave: 4,
                    accidental: ''
                }
            ],
        }
    }
    static deserialize(jsonObj) {
        var note = new SmoNote(jsonObj);
        ['textModifiers','graceNotes','ornaments','articulations','tones'].forEach((attr) =>
        {
            if (!jsonObj[attr]) {
                note[attr] = [];
            } else {
                jsonObj[attr].forEach((mod) => {
                    note[attr].push(SmoNoteModifierBase.deserialize(mod));
                });
            }
        });
        // Due to a bug, text modifiers were serialized into noteModifiers array
        if (jsonObj.noteModifiers) {
            jsonObj.noteModifiers.forEach((mod) => {
                note.textModifiers.push(mod);
            });
        }

        return note;
    }
}

class SmoBeamGroup {
    constructor(params) {
        this.notes = params.notes;
        Vex.Merge(this, params);

        if (!this['attrs']) {
            this.attrs = {
                id: VF.Element.newID(),
                type: 'SmoBeamGroup'
            };
        } else {
        }
        for (var i = 0; i < this.notes.length; ++i) {
            var note = this.notes[i];
            if (note.tickCount < 4096)
                note.beam_group = this.attrs;
        }
    }
}
;
class SmoTuplet {
  constructor(params) {
    this.notes = params.notes;
    Vex.Merge(this, SmoTuplet.defaults);
    smoSerialize.serializedMerge(SmoTuplet.parameterArray, params, this);
    if (!this['attrs']) {
      this.attrs = {
        id: VF.Element.newID(),
        type: 'SmoTuplet'
      };
    } else {
    }
    this._adjustTicks();
  }

	static get longestTuplet() {
		return 8192;
	}

  get clonedParams() {
    var paramAr = ['stemTicks', 'ticks', 'totalTicks', 'durationMap'];
    var rv = {};
    smoSerialize.serializedMerge(paramAr, this, rv);
    return rv;

  }

  static get parameterArray() {
    return ['stemTicks', 'ticks', 'totalTicks', 'durationMap','attrs','ratioed','bracketed','voice','startIndex'];
  }

  serialize() {
    var params = {};
    smoSerialize.serializedMergeNonDefault(SmoTuplet.defaults,
     SmoTuplet.parameterArray,this,params);
    return params;
  }

	static calculateStemTicks(totalTicks,numNotes) {
    var stemValue = totalTicks / numNotes;
    var stemTicks = SmoTuplet.longestTuplet;

    // The stem value is the type on the non-tuplet note, e.g. 1/8 note
    // for a triplet.
    while (stemValue < stemTicks) {
      stemTicks = stemTicks / 2;
    }
		return stemTicks * 2;
	}

  static cloneTuplet(tuplet) {
    var noteAr = tuplet.notes;
    var durationMap = JSON.parse(JSON.stringify(tuplet.durationMap)); // deep copy array

    // Add any remainders for oddlets
    var totalTicks = noteAr.map((nn) => nn.ticks.numerator+nn.ticks.remainder).reduce((acc, nn) => acc+nn);

    var numNotes = tuplet.numNotes;
    var stemValue = totalTicks / numNotes;
    var stemTicks = SmoTuplet.calculateStemTicks(totalTicks,numNotes);

    var tupletNotes = [];

    var i = 0;
    noteAr.forEach((note) => {
      var textModifiers = note.textModifiers;
      // Note preserver remainder
      note = SmoNote.cloneWithDuration(note, {
        numerator: stemTicks*tuplet.durationMap[i],
        denominator: 1,
        remainder: note.ticks.remainder
      });

      // Don't clone modifiers, except for first one.
      if (i === 0) {
        var ntmAr = [];
        textModifiers.forEach((tm) => {
          var ntm = SmoNoteModifierBase.deserialize(tm);
          ntmAr.push(ntm);
        });
        note.textModifiers = ntmAr;
      }
      i += 1;

      tupletNotes.push(note);
    });
    var rv = new SmoTuplet({
      notes: tupletNotes,
      stemTicks: stemTicks,
      totalTicks: totalTicks,
      ratioed: false,
      bracketed: true,
      startIndex: tuplet.startIndex,
      durationMap: durationMap
    });
    return rv;
  }

  _adjustTicks() {
    var sum = this.durationSum;
    for (var i = 0; i < this.notes.length; ++i) {
      var note = this.notes[i];
      var normTicks = smoMusic.durationToTicks(smoMusic.ticksToDuration[this.stemTicks]);
      // TODO:  notes_occupied needs to consider vex duration
      var tupletBase = normTicks * this.note_ticks_occupied;
      note.ticks.denominator = 1;
      note.ticks.numerator = Math.floor((this.totalTicks * this.durationMap[i]) / sum);

      note.tuplet = this.attrs;
    }

		// put all the remainder in the first note of the tuplet
		var noteTicks = this.notes.map((nn) => {return nn.tickCount;}).reduce((acc,dd) => {return acc+dd;});
    // bug fix:  if this is a clones tuplet, remainder is already set
		this.notes[0].ticks.remainder = this.notes[0].ticks.remainder + this.totalTicks-noteTicks;
  }
  getIndexOfNote(note) {
    var rv = -1;
    for (var i = 0; i < this.notes.length; ++i) {
      var tn = this.notes[i];
      if (note.attrs.id === tn.attrs.id) {
          rv = i;
      }
    }
    return rv;
  }

  split(combineIndex) {
    var multiplier = 0.5;
    var nnotes = [];
    var nmap = [];

    for (var i = 0; i < this.notes.length; ++i) {
      var note = this.notes[i];
      if (i === combineIndex) {
        nmap.push(this.durationMap[i] * multiplier);
        nmap.push(this.durationMap[i] * multiplier);
        note.ticks.numerator *= multiplier;

        var onote = SmoNote.clone(note);
        // remainder is for the whole tuplet, so don't duplicate that.
        onote.ticks.remainder=0;
        nnotes.push(note);
        nnotes.push(onote);
      } else {
        nmap.push(this.durationMap[i]);
        nnotes.push(note);
      }
    }
    this.notes = nnotes;
    this.durationMap = nmap;
  }
  combine(startIndex, endIndex) {
    // can't combine in this way, too many notes
    if (this.notes.length <= endIndex || startIndex >= endIndex) {
      return this;
    }
    var acc = 0.0;
    var i;
    var base = 0.0;
    for (i = startIndex; i <= endIndex; ++i) {
      acc += this.durationMap[i];
      if (i == startIndex) {
        base = this.durationMap[i];
      } else if (this.durationMap[i] != base) {
        // Can't combine non-equal tuplet notes
        return this;
      }
    }
    // how much each combined value will be multiplied by
    var multiplier = acc / base;

    var nmap = [];
    var nnotes = [];
    // adjust the duration map
    for (i = 0; i < this.notes.length; ++i) {
      var note = this.notes[i];
      // notes that don't change are unchanged
      if (i < startIndex || i > endIndex) {
        nmap.push(this.durationMap[i]);
        nnotes.push(note);
      }
      // changed note with combined duration
      if (i == startIndex) {
        note.ticks.numerator = note.ticks.numerator * multiplier;
        nmap.push(acc);
        nnotes.push(note);
      }
      // other notes after startIndex are removed from the map.
    }
    this.notes = nnotes;
    this.durationMap = nmap;
  }

  // ### getStemDirection
  // Return the stem direction, so we can bracket the correct place
  getStemDirection(clef) {
    const note = this.notes.find((nn) => nn.noteType === 'n');
    if (!note) {
      return SmoNote.flagStates.down;;
    }
    if (note.flagState != SmoNote.flagStates.auto) {
      return note.flagState;
    }
    return smoMusic.pitchToLedgerLine(clef,note.pitches[0])
       >= 2 ? SmoNote.flagStates.up : SmoNote.flagStates.down;
  }
  get durationSum() {
    var acc = 0;
    for (var i = 0; i < this.durationMap.length; ++i) {
      acc += this.durationMap[i];
    }
    return Math.round(acc);
  }
  get num_notes() {
    return this.durationSum;
  }
  get notes_occupied() {
    return Math.floor(this.totalTicks / this.stemTicks);
  }
  get note_ticks_occupied() {
    return this.totalTicks / this.stemTicks;
  }
  get tickCount() {
    var rv = 0;
    for (var i = 0; i < this.notes.length; ++i) {
      var note = this.notes[i];
      rv += (note.ticks.numerator / note.ticks.denominator) + note.ticks.remainder;
    }
    return rv;
  }

  static get defaults() {
    return {
      numNotes: 3,
      totalTicks: 4096, // how many ticks this tuple takes up
      stemTicks: 2048, // the stem ticks, for drawing purposes.  >16th, draw as 8th etc.
      durationMap: [1.0, 1.0, 1.0],
      bracketed: true,
      voice:0,
      ratioed: false
    }
  }
}
;
class SmoNoteModifierBase {
	constructor(ctor) {
        this.attrs = {
            id: VF.Element.newID(),
            type: ctor
        };
		this.ctor = ctor;
	}
	static deserialize(jsonObj) {
		var ctor = eval(jsonObj.ctor);
		var rv = new ctor(jsonObj);
		return rv;
	}
}

class SmoGraceNote extends SmoNoteModifierBase {
    static get defaults() {
        return {
            flagState:SmoGraceNote.flagStates.auto,
            noteType: 'n',
            beamBeats:4096,
            endBeam:false,
            clef:'treble',
            slash:false,

            ticks: {
                numerator: 4096,
                denominator: 1,
                remainder: 0
            },
            pitches: [{
                    letter: 'b',
                    octave: 4,
                    accidental: ''
                }
            ],
        }
    }
    // TODO: Matches SmoNote - move to smoMusic?
    static get flagStates() {
        return {auto:0,up:1,down:2};
    }
    static get parameterArray() {
        return ['ticks', 'pitches', 'noteType', 'clef', 'endBeam','beamBeats','flagState','slash','ctor'];
    }
    tickCount() {
        return this.ticks.numerator / this.ticks.denominator + this.ticks.remainder;
    }

    toVexGraceNote() {
        var p = smoMusic.smoPitchesToVex(this.pitches);
        var rv = {duration:smoMusic.closestVexDuration(this.tickCount()),keys:p, slash: this.slash };
        return rv;
    }

    serialize() {
        var params = {};
        smoSerialize.serializedMergeNonDefault(SmoGraceNote.defaults,
           SmoGraceNote.parameterArray,this,params);
        return params;
    }

    constructor(parameters) {
        super('SmoGraceNote');
    	smoSerialize.serializedMerge(SmoGraceNote.parameterArray,SmoGraceNote.defaults,this);
		smoSerialize.serializedMerge(SmoGraceNote.parameterArray, parameters, this);
    }

}

class SmoMicrotone extends SmoNoteModifierBase {
    static get smoToVex() {
        return {
            flat75sz:'db',
            flat25sz:'d',
            flat25ar:'bs',
            flat125ar:'afhf',
            sharp75:'++',
            sharp125:'ashs',
            sharp25:'+',
            sori:'o',
            koron:'k'
        }
    }

    static get pitchCoeff() {
        return {
        flat75sz:-1.5,
        flat25sz:-0.5,
        flat25ar:-0.5,
        flat125ar:-2.5,
        sharp75:1.5,
        sharp125:2.5,
        sharp25:0.5,
        sori:0.5,
        koron:-0.5
        };
    }

    get toPitchCoeff() {
        return SmoMicrotone.pitchCoeff[this.tone];
    }

    get toVex() {
        return SmoMicrotone.smoToVex[this.tone];
    }
    static get defaults() {
        return {
            tone:'flat25sz',
            pitch:0
        };
    }
    static get parameterArray() {
		return ['tone', 'pitch','ctor'];
	}
    serialize() {
        var params = {};
        smoSerialize.serializedMergeNonDefault(SmoMicrotone.defaults,
           SmoMicrotone.parameterArray,this,params);
        return params;
    }
    constructor(parameters) {
        super('SmoMicrotone');
        smoSerialize.serializedMerge(SmoMicrotone.parameterArray,SmoMicrotone.defaults,this);
        smoSerialize.serializedMerge(SmoMicrotone.parameterArray, parameters, this);
    }
}
class SmoOrnament extends SmoNoteModifierBase {
    static get ornaments() {
		return {
			mordent: 'mordent',
			mordentInverted: 'mordent_inverted',
			turn: 'turn',
			turnInverted: 'turn_inverted',
			trill: 'tr',
			upprail: 'upprail',
			prailup: 'prailup',
			praildown: 'praildown',
      upmordent:'upmordent',
      downmordent:'downmordent',
      lineprail:'linepraile',
      prailprail:'prailprail',
      scoop:'SCOOP',
      drop:'FALL_SHORT',
      dropLong:'FALL_LONG',
      doit:'DOIT',
      doitLong:'LIFT',
      flip:'FLIP',
      smear:'SMEAR'
		};
	}
  static get jazzOrnaments() {
    return ['SCOOP','FALL_SHORT','FALL_LONG','DOIT','LIFT','FLIP','SMEAR'];
  }
  static get toVexJazz() {
    var rv = {};
    rv[SmoOrnament.ornaments.scoop] = VF.JazzTechnique.Type.SCOOP;
    rv[SmoOrnament.ornaments.drop] = VF.JazzTechnique.Type.FALL_SHORT;
    rv[SmoOrnament.ornaments.dropLong] = VF.JazzTechnique.Type.FALL_LONG;
    rv[SmoOrnament.ornaments.doit] = VF.JazzTechnique.Type.DOIT;
    rv[SmoOrnament.ornaments.doitLong] = VF.JazzTechnique.Type.LIFT;
    rv[SmoOrnament.ornaments.flip] = VF.JazzTechnique.Type.FLIP;
    rv[SmoOrnament.ornaments.smear] = VF.JazzTechnique.Type.SMEAR;
    return rv;
  }
  toVex() {
    return SmoOrnament.toVexJazz[this.ornament];
  }

  isJazz() {
    return SmoOrnament.jazzOrnaments.indexOf(this.ornament) >= 0;
  }

  static get parameterArray() {
		return ['position', 'offset','ornament','ctor'];
	}

    static get positions() {
		return {
			above: 'above',
			below: 'below'
		};
	}
    static get offsets() {
		return {
			on: 'on',
			after: 'after'
		};
	}
    static get defaults() {
        return {
            ornament:SmoOrnament.ornaments.mordent,
            position:SmoOrnament.positions.above,
            offset:SmoOrnament.offsets.on
        };
    }
    serialize() {
        var params = {};
        smoSerialize.serializedMergeNonDefault(SmoOrnament.defaults,
           SmoOrnament.parameterArray,this,params);
        return params;
    }
    constructor(parameters) {
		super('SmoOrnament');
		smoSerialize.serializedMerge(SmoOrnament.parameterArray,SmoOrnament.defaults,this);
		smoSerialize.serializedMerge(SmoOrnament.parameterArray, parameters, this);
		this.selector = parameters.selector;
	}
}
class SmoArticulation extends SmoNoteModifierBase {
	static get articulations() {
		return {
			accent: 'accent',
			staccato: 'staccato',
			marcato: 'marcato',
			tenuto: 'tenuto',
			upStroke: 'upStroke',
			downStroke: 'downStroke',
			pizzicato: 'pizzicato',
			fermata: 'fermata'
		};
	}
	static get positions() {
		return {
			above: 'above',
			below: 'below'
		};
	}
	static get articulationToVex() {
		return {
			accent: 'a>',
			staccato: 'a.',
			marcato: 'a^',
			tenuto: 'a-',
			upStroke: 'a|',
			downStroke: 'am',
			pizzicato: 'ao',
			fermata: 'a@a'
		};
	}

	static get vexToArticulation() {
		return {
			"a>": "accent",
			"a.": "staccato",
			"a^": "marcato",
			"a-": "tenuto",
			"a|": "upStroke",
			"am": "downStroke",
			"ao": "pizzicato",
			'a@a': "fermata"
		};
	}
	static get parameterArray() {
		return ['position', 'articulation','ctor'];
	}

	static get positionToVex() {
		return {
			'above': 3,
			'below': 4
		};
	}
	static get defaults() {
		return {
			position: SmoArticulation.positions.above,
			articulation: SmoArticulation.articulations.accent
		};

	}
    serialize() {
        var params = {};
        smoSerialize.serializedMergeNonDefault(SmoArticulation.defaults,
           SmoArticulation.parameterArray,this,params);
        return params;
    }
	constructor(parameters) {
		super('SmoArticulation');
		smoSerialize.serializedMerge(SmoArticulation.parameterArray,SmoArticulation.defaults,this);
		smoSerialize.serializedMerge(SmoArticulation.parameterArray, parameters, this);
		this.selector = parameters.selector;
        this.adjX = 0;
	}

}

class SmoLyric extends SmoNoteModifierBase {
	static get defaults() {
		return {
      _text:'\xa0',
      endChar:'',
      verse:0,
			fontInfo: {
				size: 12,
				family: 'times',
				style: 'normal',
				weight: 'normal'
			},
      fill:'black',
			rotate:0,
			classes:'score-text',
			scaleX:1.0,
			scaleY:1.0,
			translateX:0,
			translateY:0,
      symbolBlocks:[],
      parser:SmoLyric.parsers.lyric
		};
	}
  static get parsers() {
    return {lyric:0,anaylysis:1,chord:2}
  }
  static get symbolPosition() {
    return {
      SUPERSCRIPT: 1,
      SUBSCRIPT: 2,
      NORMAL: 3
    };
  }

  static toVexPosition(chordPos) {
    if (chordPos === SmoLyric.symbolPosition.NORMAL) {
      return VF.ChordSymbol.symbolModifiers.NONE;
    } else if (chordPos === SmoLyric.symbolPosition.SUPERSCRIPT) {
      return VF.ChordSymbol.symbolModifiers.SUPERSCRIPT;
    }
    return VF.ChordSymbol.symbolModifiers.SUBSCRIPT;
  }

  static get parameterArray() {
    return ['endChar','fontInfo','classes','verse','parser',
    'fill','scaleX','scaleY','translateX','translateY','ctor','_text'];
  }
  serialize() {
    var params = {};
    smoSerialize.serializedMergeNonDefault(SmoLyric.defaults,
       SmoLyric.parameterArray,this,params);
    return params;
  }

  // ### getClassSelector
  // returns a selector used to find this text block within a note.
  getClassSelector() {
    var parser = (this.parser === SmoLyric.parsers.lyric ? 'lyric' : 'chord');
    return 'g.'+parser+'-'+this.verse;
  }

  setText(text) {
    // For chords, trim all whitespace
    if (this.parser !== SmoLyric.parsers.lyric) {
      if (text.trim().length) {
        text.replace(/\s/g,'');
      }
    }
    this._text = text;
  }

  getText() {
    return this._text;
  }

  static _chordGlyphFromCode(code) {
    const obj = Object.keys(VF.ChordSymbol.glyphs).find((glyph)=> VF.ChordSymbol.glyphs[glyph].code === code)
    return obj;
  }
  static _tokenizeChordString(str) {
    // var str = this._text;
    let reg = /^([A-Z|a-z|0-9|]+)/g;
    let mmm = str.match(reg);
    let tokeType = '';
    let toke = '';
    const tokens = [];
    while (str.length) {
      if (!mmm) {
        tokeType = str[0];
        tokens.push(tokeType);
        str = str.slice(1,str.length);
      } else {
        toke = mmm[0].substr(0,mmm[0].length);
        str = str.slice(toke.length,str.length);
        tokens.push(toke);
        tokeType = '';
        toke = '';
      }
      mmm = str.match(reg);
    }
    return tokens;
  }

  getVexChordBlocks() {
    let mod = VF.ChordSymbol.symbolModifiers.NONE;
    let isGlyph = false;
    const tokens = SmoLyric._tokenizeChordString(this._text);
    let blocks = [];
    tokens.forEach((token) => {
      if (token === '^') {
        mod = (mod === VF.ChordSymbol.symbolModifiers.SUPERSCRIPT) ?
          VF.ChordSymbol.symbolModifiers.NONE : VF.ChordSymbol.symbolModifiers.SUPERSCRIPT;
      }
      else if (token === '%') {
        mod = (mod === VF.ChordSymbol.symbolModifiers.SUBSCRIPT) ?
          VF.ChordSymbol.symbolModifiers.NONE : VF.ChordSymbol.symbolModifiers.SUBSCRIPT;
       }
      else if (token === '@') {
         isGlyph = !isGlyph;
       } else if (token.length) {
         if (isGlyph) {
           const glyph = SmoLyric._chordGlyphFromCode(token);
           blocks.push({glyph: glyph, symbolModifier: mod,
            symbolType: VF.ChordSymbol.symbolTypes.GLYPH});
         } else {
           blocks.push({text: token, symbolModifier: mod,
            symbolType: VF.ChordSymbol.symbolTypes.TEXT});
         }
       }
    });
    return blocks;
  }

  constructor(parameters) {
  	super('SmoLyric');
  	smoSerialize.serializedMerge(SmoLyric.parameterArray, SmoLyric.defaults,this);
  	smoSerialize.serializedMerge(SmoLyric.parameterArray, parameters, this);

    // backwards-compatibility for lyric text
    if (parameters.text) {
      this._text = parameters.text;
    }

    // Return these for the text editor that expects them.
    // this.translateX = this.translateY = 0;
    this.scaleX = this.scaleY = 1.0;
    this.boxModel = 'none';

    // calculated adjustments for alignment purposes
	  this.adjY=0;
    this.adjX = 0;

	  if (!this['attrs']) {
		  this.attrs = {
			  id: VF.Element.newID(),
			  type: 'SmoLyric'
		  };
  	} else {

  	}
	}
}

// ## SmoDynamicText
// ## Description:
// standard dynamics text
class SmoDynamicText extends SmoNoteModifierBase {
	static get defaults() {
		return {
			xOffset: 0,
			fontSize: 38,
			yOffsetLine: 11,
			yOffsetPixels: 0,
			text: SmoDynamicText.dynamics.MP,
		};
	}

	static get dynamics() {
		// matches VF.modifier
		return {
			PP: 'pp',
			P: 'p',
			MP: 'mp',
			MF: 'mf',
			F: 'f',
			FF: 'ff',
			SFZ: 'sfz'
		};
	}

  serialize() {
    var params = {};
    smoSerialize.serializedMergeNonDefault(SmoDynamicText.defaults,
      SmoDynamicText.parameterArray,this,params);
    return params;
  }
	constructor(parameters) {
		super('SmoDynamicText');
		Vex.Merge(this, SmoDynamicText.defaults);
		smoSerialize.filteredMerge(SmoDynamicText.parameterArray, parameters, this);
		this.selector = parameters.selector;

		if (!this['attrs']) {
			this.attrs = {
				id: VF.Element.newID(),
				type: 'SmoDynamicText'
			};
		} else {
		}
	}

	static get parameterArray() {
		return ['xOffset', 'fontSize', 'yOffsetLine', 'yOffsetPixels', 'text','ctor'];
	}
	backupOriginal() {
		if (!this['original']) {
			this.original = {};
			smoSerialize.filteredMerge(
				SmoDynamicText.parameterArray,
				this, this.original);
		}
	}
	restoreOriginal() {
		if (this['original']) {
			smoSerialize.filteredMerge(
				SmoDynamicText.parameterArray,
				this.original, this);
			this.original = null;
		}
	}
}
;
// ## SmoMeasure - data for a measure of music
// Many rules of musical engraving are enforced at a measure level, e.g. the duration of
// notes, accidentals, etc.
// ### See Also:
// Measures contain *notes*, *tuplets*, and *beam groups*.  So see `SmoNote`, etc.
// Measures are contained in staves, see also `SystemStaff.js`
// ## SmoMeasure Methods:
class SmoMeasure {
	constructor(params) {
		this.tuplets = [];
    this.svg = {};
		this.beamGroups = [];
		this.modifiers = [];
    this.pageGap = 0;
		this.changed = true;
    this.timestamp=0;
    this.prevY = 0;
    this.prevX = 0;
    this.padLeft=0;
    this.prevFrame=0;
    this.svg.staffWidth=200;
    this.svg.staffX = 0;
    this.svg.staffY = 0;
    this.svg.history=[];
    this.svg.logicalBox={};
    this.svg.yTop = 0;

		var defaults = SmoMeasure.defaults;

		smoSerialize.serializedMerge(SmoMeasure.defaultAttributes, defaults, this);
		smoSerialize.serializedMerge(SmoMeasure.defaultAttributes, params, this);
		this.voices = params.voices ? params.voices : [];
		this.tuplets = params.tuplets ? params.tuplets : [];
		this.modifiers = params.modifiers ? params.modifiers : defaults.modifiers;

    this.setDefaultBarlines();

		if (!this['attrs']) {
			this.attrs = {
				id: VF.Element.newID(),
				type: 'SmoMeasure'
			};
		} else {
			// inherit attrs id for deserialized
		}
	}


	// ### defaultAttributes
	// attributes that are to be serialized for a measure.
	static get defaultAttributes() {
		return [
			'timeSignature', 'keySignature','systemBreak','pageBreak',
			'measureNumber',
			'activeVoice', 'clef', 'transposeIndex',
      'adjX','customStretch','customProportion','padLeft', 'padRight', 'rightMargin'
    ];
	}

  static get formattingOptions() {
    return ['customStretch','customProportion'];
  }
  static get systemOptions() {
    return ['systemBreak','pageBreak'];
  }
  static get columnMappedAttributes() {
    return ['timeSignature','keySignature','tempo'];
  }
  static get serializableAttributes() {
    var rv = [];
    SmoMeasure.defaultAttributes.forEach((attr) => {
      if (SmoMeasure.columnMappedAttributes.indexOf(attr) < 0) {
        rv.push(attr);
      }
    });
      return rv;
  }

  // ### serializeColumnMapped
  // Some measure attributes that apply to the entire column are serialized
  // separately.  Serialize those attributes, but only add them to the
  // hash if they already exist for an earlier measure
  serializeColumnMapped(attrColumnHash,attrCurrentValue) {
    SmoMeasure.columnMappedAttributes.forEach((attr) => {
      if (this[attr]) {
        if (!attrColumnHash[attr]) {
          attrColumnHash[attr] = {};
          attrCurrentValue[attr] = {};
        }
        var curAttrHash  = attrColumnHash[attr];
        if (this[attr].ctor && this[attr].ctor == 'SmoTempoText') {
          if (this[attr].compare(attrCurrentValue[attr]) === false) {
            curAttrHash[this.measureNumber.measureIndex] = this[attr];
            attrCurrentValue[attr] = this[attr];
          }
        } else if (attrCurrentValue[attr] != this[attr]) {
          curAttrHash[this.measureNumber.measureIndex] = this[attr];
          attrCurrentValue[attr] = this[attr];
        }
      } // ekse attr doesn't exist in this measure
    });
  }

	// ### serialize
	// Convert this measure object to a JSON object, recursively serializing all the notes,
	// note modifiers, etc.
	serialize() {
		var params = {};
		smoSerialize.serializedMergeNonDefault(SmoMeasure.defaults,SmoMeasure.serializableAttributes, this, params);
		params.tuplets = [];
		params.voices = [];
		params.modifiers=[];

		this.tuplets.forEach((tuplet) => {
			params.tuplets.push(tuplet.serialize());
		});

		this.voices.forEach((voice) => {
			var obj = {
				notes: []
			};
			voice.notes.forEach((note) => {
				obj.notes.push(note.serialize());
			});
			params.voices.push(obj);
		});

		this.modifiers.forEach((modifier) => {
      /* don't serialize default modifiers */
      if (modifier.ctor == 'SmoBarline' && modifier.position == SmoBarline.positions.start && modifier.barline == SmoBarline.barlines.singleBar) {
          ;
      }
      else if (modifier.ctor == 'SmoBarline' && modifier.position == SmoBarline.positions.end && modifier.barline == SmoBarline.barlines.singleBar) {
          ;
      }
      // we don't save tempo text as a modifier anymore
      else if (modifier.ctor == 'SmoTempoText') {
          ;
      }
      else if (modifier.ctor == 'SmoRepeatSymbol' && modifier.position == SmoRepeatSymbol.positions.start && modifier.symbol == SmoRepeatSymbol.symbols.None) {
          ;
      } else {
        params.modifiers.push(modifier.serialize());
      }
		});
		return params;
	}

	// ### deserialize
	// restore a serialized measure object.  Usually called as part of deserializing a score,
	// but can also be used to restore a measure due to an undo operation.
	static deserialize(jsonObj) {
		var voices = [];
        var noteSum = [];
		for (var j = 0; j < jsonObj.voices.length; ++j) {
			var voice = jsonObj.voices[j];
			var notes = [];
			voices.push({
				notes: notes
			});
			for (var i = 0; i < voice.notes.length; ++i) {
				var noteParams = voice.notes[i];
				var smoNote = SmoNote.deserialize(noteParams);
				notes.push(smoNote);
                noteSum.push(smoNote);
			}
		}

		var tuplets = [];
		for (j = 0; j < jsonObj.tuplets.length; ++j) {
      var tupJson = jsonObj.tuplets[j];
      var noteAr = noteSum.filter((nn) => {
          return nn.isTuplet && nn.tuplet.id === tupJson.attrs.id;
      });

      // Bug fix:  A tuplet with no notes may be been overwritten
      // in a copy/paste operation
      if (noteAr.length > 0) {
        tupJson.notes = noteAr;
  			var tuplet = new SmoTuplet(tupJson);
  			tuplets.push(tuplet);
      }
		}

		/* var beamGroups = [];
		for (j = 0; j < jsonObj.beamGroups.length; ++j) {
			var smoBeam = new SmoBeamGroup(jsonObj.beamGroups[j]);
			beamGroups.push(smoBeam);
		}  */

		var modifiers = [];
		jsonObj.modifiers.forEach((modParams) => {
			var ctor = eval(modParams.ctor);
			var modifier = new ctor(modParams);
			modifiers.push(modifier);
		});

		var params = {
			voices: voices,
			tuplets: tuplets,
			beamGroups: [],
			modifiers:modifiers
		};

		smoSerialize.serializedMerge(SmoMeasure.defaultAttributes, jsonObj, params);
        var rv = new SmoMeasure(params);
        if (jsonObj.tempo) {
            rv.tempo = new SmoTempoText(jsonObj.tempo);
        }

        // Handle migration for measure-mapped parameters
        rv.modifiers.forEach((mod) => {
            if (mod.ctor == 'SmoTempoText') {
                rv.tempo = mod;
            }
        });

		return rv;
    }

    // ### defaultPitchForClef
	// Accessor for clef objects, which are set at a measure level.
	// #### TODO: learn what all these clefs are
	static get defaultPitchForClef() {
		return {
			'treble': {
				letter: 'b',
				accidental: 'n',
				octave: 4
			},
			'bass': {
				letter: 'd',
				accidental: 'n',
				octave: 3
			},
			'tenor': {
				letter: 'a',
				accidental: 'n',
				octave: 3
			},
			'alto': {
				letter: 'c',
				accidental: 'n',
				octave: 4
			},
			'soprano': {
				letter: 'b',
				accidental: 'n',
				octave: 4
			},
			'percussion': {
				letter: 'b',
				accidental: 'n',
				octave: 4
			},
			'mezzo-soprano': {
				letter: 'b',
				accidental: 'n',
				octave: 4
			},
			'baritone-c': {
				letter: 'b',
				accidental: 'n',
				octave: 3
			},
			'baritone-f': {
				letter: 'e',
				accidental: 'n',
				octave: 3
			},
			'subbass': {
				letter: 'd',
				accidental: '',
				octave: 2
			},
			'french': {
				letter: 'b',
				accidental: '',
				octave: 4
			} // no idea
		}
	}
  static set emptyMeasureNoteType(tt) {
    SmoMeasure._emptyMeasureNoteType = tt;
  }
  static get emptyMeasureNoteType() {
    SmoMeasure._emptyMeasureNoteType = SmoMeasure._emptyMeasureNoteType ? SmoMeasure._emptyMeasureNoteType : 'r';
    return SmoMeasure._emptyMeasureNoteType;
  }
	// ### getDefaultNotes
	// Get a measure full of default notes for a given timeSignature/clef.
	// returns 8th notes for triple-time meters, etc.
	static getDefaultNotes(params) {
		if (params == null) {
			params = {};
		}
		params.timeSignature = params.timeSignature ? params.timeSignature : '4/4';
		params.clef = params.clef ? params.clef : 'treble';
		var meterNumbers = params.timeSignature.split('/').map(number => parseInt(number, 10));
		var ticks = {
			numerator: 4096,
			denominator: 1,
			remainder: 0
		};
    var beamBeats = ticks.numerator;
		if (meterNumbers[1]  == 8) {
			ticks = {
				numerator: 2048,
				denominator: 1,
				remainder: 0
			};
      beamBeats = 2048*3;
		}
		var pitches =
     JSON.parse(JSON.stringify(SmoMeasure.defaultPitchForClef[params.clef]));
		var rv = [];
    var beats = meterNumbers[0];

    // Treat 2/2 like 4/4 time.
    if (meterNumbers[1] == 2) {
      beats = beats * 2;
    }

		for (var i = 0; i < beats; ++i) {
      var note = new SmoNote({
				clef: params.clef,
				pitches: [pitches],
				ticks: ticks,
				timeSignature: params.timeSignature,
        beamBeats:beamBeats,
        noteType:SmoMeasure.emptyMeasureNoteType
			});
      rv.push(note);
		}
		return rv;
	}

	// ### getDefaultMeasure
	// For create the initial or new measure, get a measure with notes.
	static getDefaultMeasure(params) {
		var obj = {};
		smoSerialize.serializedMerge(SmoMeasure.defaultAttributes, SmoMeasure.defaults, obj);
		smoSerialize.serializedMerge(SmoMeasure.defaultAttributes, params, obj);
		return new SmoMeasure(obj);
	}

	// ### SmoMeasure.getDefaultMeasureWithNotes
	// Get a new measure with the appropriate notes for the supplied clef, instrument
	static getDefaultMeasureWithNotes(params) {
		var measure = SmoMeasure.getDefaultMeasure(params);
		measure.voices.push({
			notes: SmoMeasure.getDefaultNotes(params)
		});
		return measure;
	}


	static get defaultVoice44() {
		return SmoMeasure.getDefaultNotes({
			clef: 'treble',
			timeSignature: '4/4'
		});
	}

    setDefaultBarlines() {
        if (!this.getStartBarline()) {
            this.modifiers.push(new SmoBarline({
    				position: SmoBarline.positions.start,
    				barline: SmoBarline.barlines.singleBar
    			}));
        }
        if (!this.getEndBarline()) {
            this.modifiers.push(new SmoBarline({
    				position: SmoBarline.positions.end,
    				barline: SmoBarline.barlines.singleBar
    			}));
        }
    }
	static get defaults() {
		// var noteDefault = SmoMeasure.defaultVoice44;
		const modifiers = [];
		modifiers.push(new SmoBarline({
				position: SmoBarline.positions.start,
				barline: SmoBarline.barlines.singleBar
			}));
		modifiers.push(new SmoBarline({
				position: SmoBarline.positions.end,
				barline: SmoBarline.barlines.singleBar
			}));
		modifiers.push(new SmoRepeatSymbol({
				position: SmoRepeatSymbol.positions.start,
				symbol: SmoRepeatSymbol.symbols.None
			}));
	    // modifiers.push(new SmoTempoText({tempoMode:SmoTempoText.tempoModes.textMode}));
		// modifiers.push(new SmoRepeatSymbol({symbol:SmoRepeatSymbol.symbols.None});
		return {
			timeSignature: '4/4',
			keySignature: "C",
			canceledKeySignature: null,
			adjX: 0,
      pageBreak:false,
      systemBreak:false,
			adjRight:0,
			padRight: 10,
      padLeft:0,
      tuplets:[],
			transposeIndex: 0,
      customStretch:0,
      customProportion:2,
			modifiers: modifiers,
      autoJustify:false,
			rightMargin: 2,
			staffY: 40,
			// bars: [1, 1], // follows enumeration in VF.Barline
			measureNumber: {
				localIndex: 0,
				systemIndex: 0,
				measureNumber: 0,
				staffId: 0
			},
			clef: 'treble',
			changed: true,
			forceClef: false,
			forceKeySignature: false,
			forceTimeSignature: false,
			voices: [],
			activeVoice: 0,
      tempo:new SmoTempoText()
		};
	}

    setForcePageBreak(val) {
        this.pageBreak = val;
    }

    setForceSystemBreak(val) {
        this.systemBreak = val;
    }

    getForceSystemBreak() {
        return this.systemBreak;
    }

    getForcePageBreak() {
        return this.pageBreak;
    }

    // ###   SVG mixins
    // We store some rendering data in the instance for UI mapping.
    get staffWidth() {
        return this.svg.staffWidth;
    }

    setWidth(width,description) {
        if (layoutDebug.flagSet('measureHistory')) {
           this.svg.history.push('setWidth '+this.staffWidth+'=> '+width + ' ' + description);
        }
        this.svg.staffWidth = width;
    }

    get staffX() {
        return this.svg.staffX;
    }

    setX(x,description) {
        layoutDebug.measureHistory(this,'staffX',x,description);
        this.svg.staffX = Math.round(x);
    }

    get staffY() {
        return this.svg.staffY;
    }

    setY(y,description) {
        layoutDebug.measureHistory(this,'staffY',y,description);
        this.svg.staffY = Math.round(y);
    }

    get logicalBox() {
        return typeof(this.svg.logicalBox['x']) == 'number'  ? this.svg.logicalBox : null;
    }

    get yTop() {
        return this.svg.yTop;
    }

    setYTop(y,description) {
        layoutDebug.measureHistory(this,'yTop',y,description);
        this.svg.yTop = y;
    }

    deleteLogicalBox(description) {
        this.svg.logicalBox = {};
        this.svg.history.push('delete box ' +description);
    }

    setBox(box,description) {
        layoutDebug.measureHistory(this,'logicalBox',box,description);
        this.svg.logicalBox = svgHelpers.smoBox(box);
    }

    saveUnjustifiedWidth() {
        this.svg.unjustifiedWidth = this.svg.staffWidth;
    }

    // ### getClassId
    // create a identifier unique to this measure index so it can be easily removed.
    getClassId() {
        return 'mm-'+this.measureNumber.staffId+'-'+this.measureNumber.measureIndex;
    }

    pickupMeasure(duration) {
        var proto = SmoMeasure.deserialize(this.serialize());
        proto.attrs.id =  VF.Element.newID();
        var note = proto.voices[0].notes[0];
        proto.voices = [];
        note.pitches = [note.pitches[0]];
        note.ticks.numerator = duration;
        note.makeRest();
        proto.voices.push({notes:[note]});
        return proto;
    }

	// ### getRenderedNote
	// The renderer puts a mapping between rendered svg groups and
	// the logical notes in SMO.  The UI needs this mapping to be interactive,
	// figure out where a note is rendered, what its bounding box is, etc.
	getRenderedNote(id) {
		for (var j = 0; j < this.voices.length; ++j) {
			var voice = this.voices[j];
			for (var i = 0; i < voice.notes.length; ++i) {
				var note = voice.notes[i];
				if (note.renderId === id) {
					return {
						smoNote: note,
						voice: j,
						tick: i
					};
				}
			}
		}
		return null;
	}

	/* set notes(val) {
		this.voices[this.activeVoice].notes = val;
	}  */

    getNotes() {
        return this.voices[this.activeVoice].notes;
    }

    getActiveVoice() {
        return this.activeVoice;
    }

    setActiveVoice(vix) {
        if (vix >= 0 && vix < this.voices.length) {
            this.activeVoice=vix;
        }
    }



    tickmapForVoice(voiceIx) {
        var tickmap = new smoTickIterator(this,{voice:voiceIx});
        tickmap.iterate(smoTickIterator.nullActor,this);
        return tickmap;
    }

    // ### createMeasureTickmaps
    // A tickmap is a map of notes to ticks for the measure.  It is speciifc per-voice
    // since each voice may have different numbers of ticks.  The accidental map is
    // overall since accidentals in one voice apply to accidentals in the other
    // voices.  So we return the tickmaps and the overall accidental map.
    createMeasureTickmaps() {
        var tickmapArray=[];
        var accidentalMap = {};
        for (var i = 0;i< this.voices.length;++i) {
            tickmapArray.push(this.tickmapForVoice(i));
        }

        for (var i = 0;i< this.voices.length;++i) {
            var voice = this.voices[i];
            var tickmap = tickmapArray[i];
            var durationKeys = Object.keys(tickmap.durationAccidentalMap)

            durationKeys.forEach((durationKey) => {
                if (!accidentalMap[durationKey]) {
                    accidentalMap[durationKey] = tickmap.durationAccidentalMap[durationKey];
                } else {
                    var amap = accidentalMap[durationKey];
                    var amapKeys = Object.keys(amap);
                    var pitchKeys = Object.keys(tickmap.durationAccidentalMap[durationKey]);
                    pitchKeys.forEach((pitchKey) => {
                        if (!amap[pitchKey]) {
                            amap[pitchKey] = tickmap.durationAccidentalMap[durationKey][pitchKey];
                        }
                    });
                }
            });
        }
        var accidentalArray = [];
        Object.keys(accidentalMap).forEach((durationKey) => {
            accidentalArray.push({duration:durationKey,pitches:accidentalMap[durationKey]});
        });
        return {
            tickmaps:tickmapArray,
            accidentalMap:accidentalMap,
            accidentalArray:accidentalArray
        };
    }

    getTicksFromVoice() {
        var ticks = 0;
        this.voices[0].notes.forEach((note) => {
            ticks += note.tickCount;
        });
        return ticks;
    }

    isPickup() {
        var ticks = this.getTicksFromVoice();
        var goal = smoMusic.timeSignatureToTicks(this.timeSignature);
        return (ticks < goal);
    }

	// ### getDynamicMap
	// ### Description:
	// returns the dynamic text for each tick index.  If
	// there are no dynamics, the empty array is returned.
	getDynamicMap() {
		var rv = [];
		var hasDynamic = false;
		this.voices.forEach((voice) => {
			voice.notes.forEach((note) => {
				if (note.dynamicText) {
					rv.push({
						note: note,
						text: note.dynamicText
					});
					hasDynamic = true;
				} else {
					rv.push({
						note: note,
						text: ''
					});
				}
			});
		});

		if (hasDynamic) {
			return rv;
		}
		return [];
	}

	clearBeamGroups() {
		this.beamGroups = [];
	}

    // ### tuplet methods.

    // #### tupletNotes
	tupletNotes(tuplet) {
		var notes = [];
		for (var j = 0; j < this.voices.length; ++j) {
			var notes = this.voices[j].notes;
			for (var i = 0; i < notes.length; ++i) {
				if (notes[i]['tuplet'] && notes[i].tuplet.id === tuplet.attrs.id) {
					notes.push(notes[i]);
				}
			}
		}
		return notes;
	}

    // #### tupletIndex
    // return the index of the given tuplet
	tupletIndex(tuplet) {
		for (var j = 0; j < this.voices.length; ++j) {
			var notes = this.voices[j].notes;
			for (var i = 0; i < notes.length; ++i) {
				if (notes[i]['tuplet'] && notes[i].tuplet.id === tuplet.attrs.id) {
					return i;
				}
			}
		}
		return -1;
	}

    // #### getTupletForNote
    // Finds the tuplet for a given note, or null if there isn't one.
    getTupletForNote(note) {
		if (!note.isTuplet) {
			return null;
		}
		for (var i = 0; i < this.tuplets.length; ++i) {
			var tuplet = this.tuplets[i];
			if (tuplet.attrs.id === note.tuplet.id) {
				return tuplet;
			}
		}
		return null;
	}
	removeTupletForNote(note) {
		var tuplets = [];
		for (var i = 0; i < this.tuplets.length; ++i) {
			var tuplet = this.tuplets[i];
			if (note.tuplet.id !== tuplet.attrs.id) {
				tuplets.push(tuplet);
			}
		}
		this.tuplets = tuplets;
	}

    // ### populateVoice
    // Create a new voice in this measure, and populate it with the default note
    // for this measure/key/clef
    populateVoice(index) {
        if (index !=  this.voices.length ) {
            return;
        }
        this.voices.push({notes:SmoMeasure.getDefaultNotes(this)});
        this.activeVoice = index;
        this.changed = true;
    }

    // ### measure modifier mixins
    _addSingletonModifier(name,parameters) {
        var ctor = eval(name);
        var ar= this.modifiers.filter(obj => obj.attrs.type != name);
        this.modifiers=ar;
        this.modifiers.push(new ctor(parameters));
    }
    _removeSingletonModifier(name) {
        var ar= this.modifiers.filter(obj => obj.attrs.type != name);
        this.modifiers=ar;
    }

    _getSingletonModifier(name) {
        return this.modifiers.find(obj => obj.attrs.type == name);
    }

    addRehearsalMark(parameters) {
        this._addSingletonModifier('SmoRehearsalMark',parameters);
    }
	removeRehearsalMark() {
        this._removeSingletonModifier('SmoRehearsalMark');
    }
    getRehearsalMark() {
        return this._getSingletonModifier('SmoRehearsalMark');
    }
    getModifiersByType(type) {
        return this.modifiers.filter((mm) => {
            return type == mm.attrs.type;
        });
    }

    addTempo(params) {
        this.tempo = new SmoTempoText(params);
    }
    removeTempo(params) {
        this.tempo = new SmoTempoText();
    }
    getTempo() {
        return this.tempo;
    }
	addMeasureText(mod) {
		var added = false;
		var exist = this.modifiers.filter((mm) => {
			return mm.attrs.id === mod.attrs.id;
		});
		if (exist.length) {
			this.setChanged(); // already added but set changed===true to re-justify
			return;
		}
		this.modifiers.push(mod);
		this.setChanged();
	}

	getMeasureText() {
		return this.modifiers.filter(obj => obj.ctor === 'SmoMeasureText');
	}

	removeMeasureText(id) {
		var ar= this.modifiers.filter(obj => obj.attrs.id != id);
		this.modifiers=ar;
		this.setChanged();
	}

	setRepeatSymbol(rs) {
		var ar = [];
		var toAdd = true;
		var exSymbol = this.getRepeatSymbol();
		if (exSymbol && exSymbol.symbol === rs.symbol) {
			toAdd = false;
		}
		this.modifiers.forEach((modifier) => {
			if (modifier.ctor != 'SmoRepeatSymbol') {
				ar.push(modifier);
			}
		});
		this.modifiers = ar;
		if (toAdd) {
			ar.push(rs);
		}
	}
	getRepeatSymbol() {
		var rv = this.modifiers.filter(obj => obj.ctor === 'SmoRepeatSymbol');
		return rv.length ? rv[0] : null;
	}
	clearRepeatSymbols() {
		var ar = [];
		this.modifiers.forEach((modifier) => {
			if (modifier.ctor != 'SmoRepeatSymbol') {
				ar.push(modifier);
			}
		});
		this.modifiers = ar;
	}
	setBarline(barline) {
		var ar = [];
		this.modifiers.forEach((modifier) => {
			if (modifier.ctor != 'SmoBarline' || modifier.position != barline.position) {
				ar.push(modifier);
			}
		});
		this.modifiers = ar;
		ar.push(barline);
	}

	_getBarline(pos) {
		var rv = null;
		this.modifiers.forEach((modifier) => {
			if (modifier.ctor === 'SmoBarline' && modifier.position === pos) {
				rv = modifier;
			}
		});
		return rv;
	}
	getEndBarline() {
		return this._getBarline(SmoBarline.positions.end);
	}
	getStartBarline() {
		return this._getBarline(SmoBarline.positions.start);
	}

	addNthEnding(ending) {
		var mods = [];
		this.modifiers.forEach((modifier) => {
			if (modifier.ctor != 'SmoVolta' || modifier.startBar != ending.startBar || modifier.endBar != ending.endBar) {
				mods.push(modifier);
			}
		});
		mods.push(ending);
		this.modifiers = mods;
	}

	removeNthEnding(number) {
		var mods = [];
		this.modifiers.forEach((modifier) => {
			if (modifier.ctor != 'SmoVolta' || modifier.number != number) {
				mods.push(modifier);
			}
		});
		this.modifiers = mods;
	}

	getNthEndings() {
		var rv = [];
		this.modifiers.forEach((modifier) => {
			if (modifier.ctor === 'SmoVolta') {
				rv.push(modifier);
			}
		});
		return rv;
	}
	getEndEndings() {
		var rv = null;
		this.modifiers.forEach((modifier) => {
			if (modifier.ctor === 'SmoVolta' && modifier.endBar === this.measureNumber.systemIndex
				 && modifier.startBar != this.measureNumber.systemIdnex) {
				rv.push(modifier);
			}
		});
		return rv;
	}
	getMidEndings() {
		var rv = null;
		this.modifiers.forEach((modifier) => {
			if (modifier.ctor === 'SmoVolta' && modifier.endBar > this.measureNumber.systemIndex
				 && modifier.startBar < this.measureNumber.systemIndex) {
				rv.push(modifier);
			}
		});
		return rv;
	}



	get numBeats() {
		return this.timeSignature.split('/').map(number => parseInt(number, 10))[0];
	}
	setKeySignature(sig) {
		this.keySignature = sig;
		this.setChanged();
		this.voices.forEach((voice) => {
			voice.notes.forEach((note) => {
				note.keySignature = sig;
			});
		});
	}
    setChanged() {
        this.changed = true;
        this.prevFrame=0;
        this.timestamp = Date.now();
    }
	get beatValue() {
		return this.timeSignature.split('/').map(number => parseInt(number, 10))[1];
	}

	setMeasureNumber(num) {
		this.measureNumber = num;
	}

	getBeamGroupForNote(note) {
		for (var i = 0; i < this.beamGroups.length; ++i) {
			var bg = this.beamGroups[i];
			for (var j = 0; j < bg.notes.length; ++j) {
				if (bg.notes[j].attrs.id === note.attrs.id) {
					return bg;
				}
			}
		}
		return null;
	}
}
;
// ## Measure modifiers are elements that are attached to the bar itself, like barlines or measure-specific text,
// repeats - lots of stuff
class SmoMeasureModifierBase {
    constructor(ctor) {
        this.ctor = ctor;
		 if (!this['attrs']) {
            this.attrs = {
                id: VF.Element.newID(),
                type: ctor
            };
        } else {
            console.log('inherit attrs');
        }
    }
    static deserialize(jsonObj) {
        var ctor = eval(jsonObj.ctor);
        var rv = new ctor(jsonObj);
        return rv;
    }
}

class SmoBarline extends SmoMeasureModifierBase {
    static get positions() {
        return {
            start: 0,
            end: 1
        }
    };

    static get barlines() {
        return {
            singleBar: 0,
            doubleBar: 1,
            endBar: 2,
            startRepeat: 3,
            endRepeat: 4,
            noBar: 5
        }
    }

	static get _barlineToString() {
		return  ['singleBar','doubleBar','endBar','startRepeat','endRepeat','noBar'];
	}
	static barlineString(inst) {
		return SmoBarline._barlineToString[inst.barline];
	}

    static get defaults() {
        return {
            position: SmoBarline.positions.end,
            barline: SmoBarline.barlines.singleBar
        };
    }

    static get attributes() {
        return ['position', 'barline'];
    }
	serialize() {
        var params = {};
        smoSerialize.serializedMergeNonDefault(SmoBarline.defaults,SmoBarline.attributes,this,params);
        params.ctor = 'SmoBarline';
        return params;
	}

    constructor(parameters) {
        super('SmoBarline');
        parameters = parameters ? parameters : {};
        smoSerialize.serializedMerge(SmoBarline.attributes, SmoBarline.defaults, this);
        smoSerialize.serializedMerge(SmoBarline.attributes, parameters, this);
    }

    static get toVexBarline() {
        return [VF.Barline.type.SINGLE, VF.Barline.type.DOUBLE, VF.Barline.type.END,
            VF.Barline.type.REPEAT_BEGIN, VF.Barline.type.REPEAT_END, VF.Barline.type.NONE];

    }
    static get toVexPosition() {
        return [VF.StaveModifier.BEGIN, VF.StaveModifier.END];
    }

    toVexBarline() {
        return SmoBarline.toVexBarline[this.barline];
    }
    toVexPosition() {
        return SmoBarline.toVexPosition[this.position];
    }
}

class SmoRepeatSymbol extends SmoMeasureModifierBase {
    static get symbols() {
        return {
            None: 0,
            Coda: 1,
            Segno: 2,
            Dc: 3,
			ToCoda:1,
            DcAlCoda: 4,
            DcAlFine: 5,
            Ds: 6,
            DsAlCoda: 7,
            DsAlFine: 8,
            Fine: 9
        };
    }

	static get defaultXOffset() {
		return [0,0,0,-20,-60,-60,-50,-60,-50,-40];
	}
    static get positions() {
        return {
            start: 0,
            end: 1
        }
    };
    static get defaults() {
        return {
            symbol: SmoRepeatSymbol.Coda,
            xOffset: 0,
            yOffset: 30,
            position: SmoRepeatSymbol.positions.end
        }
    }
    static get toVexSymbol() {
        return [VF.Repetition.type.NONE, VF.Repetition.type.CODA_LEFT, VF.Repetition.type.SEGNO_LEFT, VF.Repetition.type.DC,
            VF.Repetition.type.DC_AL_CODA, VF.Repetition.type.DC_AL_FINE, VF.Repetition.type.DS, VF.Repetition.type.DS_AL_CODA, VF.Repetition.type.DS_AL_FINE, VF.Repetition.type.FINE];
    }
    static get attributes() {
        return ['symbol', 'xOffset', 'yOffset', 'position'];
    }
    toVexSymbol() {
        return SmoRepeatSymbol.toVexSymbol[this.symbol];
    }
	serialize() {
        var params = {};
        smoSerialize.serializedMergeNonDefault(SmoRepeatSymbol.defaults,SmoRepeatSymbol.attributes,this,params);
        params.ctor = 'SmoRepeatSymbol';
        return params;
	}
    constructor(parameters) {
        super('SmoRepeatSymbol');
        smoSerialize.serializedMerge(SmoRepeatSymbol.attributes, SmoRepeatSymbol.defaults, this);
		this.xOffset = SmoRepeatSymbol.defaultXOffset[parameters.symbol];
        smoSerialize.serializedMerge(SmoRepeatSymbol.attributes, parameters, this);
    }
}

class SmoVolta extends SmoMeasureModifierBase {
    constructor(parameters) {
        super('SmoVolta');
		this.original={};


        smoSerialize.serializedMerge(SmoVolta.attributes, SmoVolta.defaults, this);
		smoSerialize.serializedMerge(SmoVolta.attributes, parameters, this);
    }
	get id() {
		return this.attrs.id;
	}

	get type() {
		return this.attrs.type;
	}
    static get attributes() {
        return ['startBar', 'endBar', 'endingId','startSelector','endSelector','xOffsetStart', 'xOffsetEnd', 'yOffset', 'number'];
    }
	static get editableAttributes() {
		return ['xOffsetStart','xOffsetEnd','yOffset','number'];
	}

	serialize() {
        var params = {};
        smoSerialize.serializedMergeNonDefault(SmoVolta.defaults,SmoVolta.attributes,this,params);
        params.ctor = 'SmoVolta';
        return params;
	}

    static get defaults() {
        return {
            startBar: 1,
            endBar: 1,
            xOffsetStart: 0,
            xOffsetEnd: 0,
            yOffset: 20,
            number: 1
        }
    }

	 backupOriginal() {
        if (!this['original']) {
            this.original = {};
            smoSerialize.filteredMerge(
                SmoVolta.attributes,
                this, this.original);
        }
    }
    restoreOriginal() {
        if (this['original']) {
            smoSerialize.filteredMerge(
                SmoVolta.attributes,
                this.original, this);
            this.original = null;
        }
    }

	toVexVolta(measureNumber) {
		if (this.startBar === measureNumber && this.startBar === this.endBar) {
			return VF.Volta.type.BEGIN_END;
		}
		if (this.startBar === measureNumber) {
			return VF.Volta.type.BEGIN;
		}
		if (this.endBar === measureNumber) {
			return VF.Volta.type.END;
		}
		if (this.startBar < measureNumber && this.endBar > measureNumber) {
			return VF.Volta.type.MID;
		}
		return VF.Volta.type.NONE;
	}
}

class SmoMeasureText extends SmoMeasureModifierBase {
	static get positions() {
		return {above:0,below:1,left:2,right:3,none:4};
	}

	static get justifications() {
		return {left:0,right:1,center:2}
	}

	static get _positionToString() {
		return ['above','below','left','right'];
	}

	static get toVexPosition() {
		return [VF.Modifier.Position.ABOVE,VF.Modifier.Position.BELOW,VF.Modifier.Position.LEFT,VF.Modifier.Position.RIGHT];
	}
	static get toVexJustification() {
		return [VF.TextNote.LEFT,VF.TextNote.RIGHT,VF.TextNote.CENTER];
	}

	toVexJustification() {
		return SmoMeasureText.toVexJustification[this.justification];
	}
	toVexPosition() {
		return SmoMeasureText.toVexPosition[parseInt(this.position)];
	}
	static get attributes() {
		return ['position','fontInfo','text','adjustX','adjustY','justification'];
	}

	static get defaults() {
		return {
			position:SmoMeasureText.positions.above,
			fontInfo: {
				size: '9',
				family:'times',
				style:'normal',
				weight:'normal'
			},
			text:'Smo',
			adjustX:0,
			adjustY:0,
			justification:SmoMeasureText.justifications.center
		};
	}
	serialize() {
        var params = {};
        smoSerialize.serializedMergeNonDefault(SmoMeasureText.defaults,SmoMeasureText.attributes,this,params)
        params.ctor = 'SmoMeasureText';
        return params;
	}

	constructor(parameters) {
		super('SmoMeasureText');
        parameters = parameters ? parameters : {};
        smoSerialize.serializedMerge(SmoMeasureText.attributes, SmoMeasureText.defaults, this);
        smoSerialize.serializedMerge(SmoMeasureText.attributes, parameters, this);

		// right-justify left text and left-justify right text by default
		if (!parameters['justification']) {
			this.justification = (this.position === SmoMeasureText.positions.left) ? SmoMeasureText.justifications.right :
			     (this.position === SmoMeasureText.positions.right ? SmoMeasureText.justifications.left : this.justification);
		}
	}
}

class SmoRehearsalMark extends SmoMeasureModifierBase {

	static get cardinalities() {
		return {capitals:'capitals',lowerCase:'lowerCase',numbers:'numbers'};
	}
	static get positions() {
		return {above:0,below:1,left:2,right:3};
	}
	static get _positionToString() {
		return ['above','below','left','right'];
	}

	// TODO: positions don't work.
	static get defaults() {
		return {
			position:SmoRehearsalMark.positions.above,
			cardinality:SmoRehearsalMark.cardinalities.capitals,
			symbol:'A',
            increment:true
		}
	}
	static get attributes() {
		return ['cardinality','symbol','position','increment'];
	}
	getIncrement() {
		if (!this.cardinality != 'number') {
			var code = this.symbol.charCodeAt(0);
			code += 1;
			var symbol=String.fromCharCode(code);
			return symbol;
		} else {
            return parseInt(symbol)+1;
        }
	}
    getInitial() {
        return this.cardinality == SmoRehearsalMark.cardinalities.capitals ? 'A' :
            (this.cardinality == SmoRehearsalMark.cardinalities.lowerCase ? 'a' : '1');
    }
	serialize() {
        var params = {};
        smoSerialize.serializedMergeNonDefault(SmoRehearsalMark.defaults,SmoRehearsalMark.attributes,this,params)
        params.ctor = 'SmoRehearsalMark';
        return params;
	}
	constructor(parameters) {
		super('SmoRehearsalMark');
        parameters = parameters ? parameters : {};
        smoSerialize.serializedMerge(SmoRehearsalMark.attributes, SmoRehearsalMark.defaults, this);
        smoSerialize.serializedMerge(SmoRehearsalMark.attributes, parameters, this);
        if (!parameters.symbol) {
            this.symbol=this.getInitial();
        }
	}
}


// ### SmoTempoText
// Tempo marking and also the information about the tempo.
class SmoTempoText extends SmoMeasureModifierBase {
	static get tempoModes() {
		return {
			durationMode: 'duration',
			textMode: 'text',
			customMode: 'custom'
		};
	}

	static get tempoTexts() {
		return {
			larghissimo: 'Larghissimo',
			grave: 'Grave',
			lento: 'Lento',
			largo: 'Largo',
			larghetto: 'Larghetto',
			adagio: 'Adagio',
			adagietto: 'Adagietto',
			andante_moderato: 'Andante moderato',
			andante: 'Andante',
			andantino: 'Andantino',
			moderator: 'Moderato',
			allegretto: 'Allegretto',
			allegro: 'Allegro',
			vivace: 'Vivace',
			presto: 'Presto',
			prestissimo: 'Prestissimo'
		};
	}

	static get defaults() {
		return {
			tempoMode: SmoTempoText.tempoModes.durationMode,
			bpm: 120,
			beatDuration: 4096,
			tempoText: SmoTempoText.tempoTexts.allegro,
      yOffset:0,
      display:false
		};
	}
	static get attributes() {
		return ['tempoMode', 'bpm', 'display', 'beatDuration', 'tempoText','yOffset'];
	}
    compare(instance) {
        var rv = true;
        SmoTempoText.attributes.forEach((attr) => {
            if (this[attr] != instance[attr]) {
                rv = false;
            }
        });
        return rv;
    }
    _toVexTextTempo() {
        return {name:this.tempoText};
    }

    // ### eq
    // Return equality wrt the tempo marking, e.g. 2 allegro in textMode will be equal but
    // an allegro and duration 120bpm will not.
    static eq (t1,t2) {
    	if (t1.tempoMode != t2.tempoMode) {
    		return false;
    	}
    	if (t1.tempoMode == SmoTempoText.tempoModes.durationMode) {
    		return t1.bpm == t2.bpm && t1.beatDuration == t2.beatDuration;
    	}
    	if (t1.tempoMode == SmoTempoText.tempoModes.textMode) {
    		return t1.tempoText == t2.tempoText;
    	} else {
    		return t1.bpm == t2.bpm && t1.beatDuration == t2.beatDuration &&
    		    t1.tempoText == t2.tempoText;
    	}
    }

    static get bpmFromText() {
        // TODO: learn these
        var rv = {};
        rv[SmoTempoText.tempoTexts.larghissimo] = 40;
        rv[SmoTempoText.tempoTexts.grave] = 40;
		rv[SmoTempoText.tempoTexts.lento] = 42;
		rv[SmoTempoText.tempoTexts.largo] = 46;
		rv[SmoTempoText.tempoTexts.larghetto] = 52;
		rv[SmoTempoText.tempoTexts.adagio] = 72;
		rv[SmoTempoText.tempoTexts.adagietto] = 72;
		rv[SmoTempoText.tempoTexts.andante_moderato] = 72;
		rv[SmoTempoText.tempoTexts.andante] = 72;
		rv[SmoTempoText.tempoTexts.andantino] = 84;
		rv[SmoTempoText.tempoTexts.moderator] = 96;
		rv[SmoTempoText.tempoTexts.allegretto] = 96;
		rv[SmoTempoText.tempoTexts.allegro] = 120;
		rv[SmoTempoText.tempoTexts.vivace] = 144;
		rv[SmoTempoText.tempoTexts.presto] = 168;
		rv[SmoTempoText.tempoTexts.prestissimo] = 240;
        return rv;
    }

    _toVexDurationTempo() {
        var vd = smoMusic.ticksToDuration[this.beatDuration];
        var dots = (vd.match(/d/g) || []).length;
        vd=vd.replace(/d/g,'');
        return {duration: vd, dots: dots, bpm: this.bpm };
    }
    toVexTempo() {
        if (this.tempoMode ==  SmoTempoText.tempoModes.durationMode) {
            return this._toVexDurationTempo();
        }
        return this._toVexTextTempo();
    }
    backupOriginal() {
        this.backup = {};
        smoSerialize.serializedMerge(SmoTempoText.attributes, this, this.backup);
    }
    restoreOriginal() {
        smoSerialize.serializedMerge(SmoTempoText.attributes, this.backup, this);
    }
    serialize() {
        var params = {};
        smoSerialize.serializedMergeNonDefault(SmoTempoText.defaults,SmoTempoText.attributes,this,params)
        params.ctor = 'SmoTempoText';
        return params;
	}
	constructor(parameters) {
		super('SmoTempoText');
        parameters = parameters ? parameters : {};
		smoSerialize.serializedMerge(SmoTempoText.attributes, SmoTempoText.defaults, this);
		smoSerialize.serializedMerge(SmoTempoText.attributes, parameters, this);
	}
}
;

// ## SmoSystemStaff
// A staff is a line of music that can span multiple measures.
// A system is a line of music for each staff in the score.  So a staff
// spans multiple systems.
// A staff modifier connects 2 points in the staff.
class SmoSystemStaff {
  constructor(params) {
    this.measures = [];
    Vex.Merge(this, SmoSystemStaff.defaults);
    Vex.Merge(this, params);
    if (this.measures.length) {
      this.numberMeasures();
    }
    if (!this['attrs']) {
      this.attrs = {
        id: VF.Element.newID(),
        type: 'SmoSystemStaff'
      };
    } else {
    }
  }

    // ### defaultParameters
    // the parameters that get saved with the score.
	static get defaultParameters() {
		return [
		'staffId','staffX','staffY','adjY','staffWidth','staffHeight','startIndex',
            'renumberingMap','keySignatureMap','instrumentInfo'];
	}

    // ### defaults
    // default values for all instances
    static get defaults() {
        return {
            staffX: 10,
            staffY: 40,
            adjY: 0,
            staffWidth: 1600,
            staffHeight: 90,
            startIndex: 0,
			staffId:0,
            renumberingMap: {},
            keySignatureMap: {},
            instrumentInfo: {
                instrumentName: 'Treble Instrument',
                keyOffset: '0',
                clef: 'treble'
            },
            measures: [],
            modifiers: []
        };
    }

    // ### serialize
    // JSONify self.
	serialize() {
		var params={};
		smoSerialize.serializedMerge(SmoSystemStaff.defaultParameters,this,params);
		params.modifiers=[];
		params.measures=[];


		this.measures.forEach((measure) => {
			params.measures.push(measure.serialize());
		});

		this.modifiers.forEach((modifier) => {
			params.modifiers.push(modifier.serialize());
		});

		return params;
	}

     // ### deserialize
     // parse formerly serialized staff.
    static deserialize(jsonObj) {
        var params = {};
        smoSerialize.serializedMerge(
            ['staffId','staffX', 'staffY', 'staffWidth', 'startIndex', 'renumberingMap', 'renumberIndex', 'instrumentInfo'],
            jsonObj, params);
        params.measures = [];
        jsonObj.measures.forEach(function (measureObj) {
            var measure = SmoMeasure.deserialize(measureObj);
            params.measures.push(measure);
        });

        var rv = new SmoSystemStaff(params);

        if (jsonObj.modifiers) {
            jsonObj.modifiers.forEach((params) => {
                var mod = StaffModifierBase.deserialize(params);
                rv.modifiers.push(mod);
            });
        }
		return rv;
    }

   // ### addStaffModifier
   // add a staff modifier, or replace a modifier of same type
   // with same endpoints.
    addStaffModifier(modifier) {
        this.removeStaffModifier(modifier);
        this.modifiers.push(modifier);
    }

    // ### removeStaffModifier
    // Remove a modifier of given type and location
    removeStaffModifier(modifier) {
        var mods = [];
        this.modifiers.forEach((mod) => {
            if (mod.attrs.id != modifier.attrs.id) {
                mods.push(mod);
            }
        });
        this.modifiers = mods;
    }

    // ### getModifiersAt
    // get any modifiers at the selected location
	getModifiersAt(selector) {
		var rv = [];
		this.modifiers.forEach((mod) => {
			if (SmoSelector.sameNote(mod.startSelector,selector)) {
				rv.push(mod);
			}
		});
		return rv;
	}

    // ### getSlursStartingAt
    // like it says.  Used by audio player to slur notes
    getSlursStartingAt(selector) {
        return this.modifiers.filter((mod) => {
            return SmoSelector.sameNote(mod.startSelector,selector)
               && mod.attrs.type == 'SmoSlur';
        });
    }

    // ### getSlursEndingAt
    // like it says.
    getSlursEndingAt(selector) {
        return this.modifiers.filter((mod) => {
            return SmoSelector.sameNote(mod.endSelector,selector);
        });
    }

    // ### accesor getModifiers
    getModifiers() {
        return this.modifiers;
    }

    // ### applyBeams
    // group all the measures' notes into beam groups.
    applyBeams() {
        for (var i = 0; i < this.measures.length; ++i) {
            var measure = this.measures[i];
            smoBeamerFactory.applyBeams(measure);
        }
    }

    // ### getRenderedNote
    // used by mapper to get the rendered note from it's SVG DOM ID.
    getRenderedNote(id) {
        for (var i = 0; i < this.measures.length; ++i) {
            var measure = this.measures[i];
            var note = measure.getRenderedNote(id);
            if (note)
                return {
                    smoMeasure: measure,
                    smoNote: note.smoNote,
                    smoSystem: this,
                    selection: {
                        measureIndex: measure.measureNumber.measureIndex,
                        voice: measure.activeVoice,
                        tick: note.tick,
                        maxTickIndex: measure.notes.length,
                        maxMeasureIndex: this.measures.length
                    },
                    type: note.smoNote.attrs.type,
                    id: note.smoNote.attrs.id
                };
        }
        return null;
    }

    // ### addRehearsalMark
    // for all measures in the system, and also bump the
    // auto-indexing
    addRehearsalMark(index,parameters) {
        var mark = new SmoRehearsalMark(parameters);
        if (!mark.increment) {
            this.measures[index].addRehearsalMark(mark);
            return;
        }

        var symbol = mark.symbol;
        for (var i=0;i<this.measures.length;++i) {
            var mm = this.measures[i];
            if (i < index) {
                var rm = mm.getRehearsalMark();
                if (rm && rm.cardinality==mark.cardinality && rm.increment) {
                   symbol = rm.getIncrement();
                   mark.symbol=symbol;
                }
            }
            if (i === index) {
                mm.addRehearsalMark(mark);
                symbol = mark.getIncrement();
            }
            if (i > index) {
                var rm = mm.getRehearsalMark();
                if (rm && rm.cardinality==mark.cardinality && rm.increment) {
                    rm.symbol = symbol;
                    symbol = rm.getIncrement();
                }
            }
        }
    }

    removeTempo(index) {
        this.measures[index].removeTempo();
    }

    addTempo(tempo,index) {
        this.measures[index].addTempo(tempo);
    }

    // ### removeRehearsalMark
    // for all measures in the system, and also decrement the
    // auto-indexing
    removeRehearsalMark(index) {
        var ix = 0;
        var symbol=null;
        var card = null;
        this.measures.forEach((measure) => {
            if (ix == index) {
                var mark = measure.getRehearsalMark();
                if (mark) {
                    symbol = mark.symbol;
                    card = mark.cardinality;
                }
                measure.removeRehearsalMark();
            }
            if (ix > index && symbol && card) {
                var mark = measure.getRehearsalMark();
                if (mark && mark.increment) {
                    mark.symbol = symbol;
                    symbol = mark.getIncrement();
                }
            }

            ix += 1;
        });
    }

    // ### deleteMeasure
    // delete the measure, and any staff modifiers that start/end there.
	deleteMeasure(index) {
		if (this.measures.length < 2) {
			return; // don't delete last measure.
		}
		var nm=[];
		this.measures.forEach((measure) => {
			if (measure.measureNumber.measureIndex != index) {
				nm.push(measure);
			}
		});
		var sm=[];
		this.modifiers.forEach((mod)=> {
            // Bug: if we are deleting a measure before the selector, change the measure number.
			if (mod.startSelector.measure != index && mod.endSelector.measure != index) {
                if (index < mod.startSelector.measure) {
                    mod.startSelector.measure -= 1;
                }
                if (index < mod.endSelector.measure) {
                    mod.endSelector.measure -= 1;
                }
				sm.push(mod);
			}
		});
		this.measures=nm;
		this.modifiers=sm;
		this.numberMeasures();
	}

    // ### addKeySignature
    // Add key signature to the given measure and update map so we know
    // when it changes, cancels etc.
    addKeySignature(measureIndex, key) {
        this.keySignatureMap[measureIndex] = key;
		var target = this.measures[measureIndex];
		target.keySignature = key;
        // this._updateKeySignatures();
    }

    // ### removeKeySignature
    // remove key signature and update map so we know
    // when it changes, cancels etc.
    removeKeySignature(measureIndex) {
        var keys = Object.keys(this.keySignatureMap);
        var nmap = {};
        keys.forEach((key) => {
            if (key !== measureIndex) {
                nmap[key] = this.keySignatureMap[key];
            }
        });
        this.keySignatureMap = nmap;
        this._updateKeySignatures();
    }
    _updateKeySignatures() {
        var currentSig = this.measures[0].keySignature;

        for (var i = 0; i < this.measures.length; ++i) {
            var measure = this.measures[i];

            var nextSig = this.keySignatureMap[i] ? this.keySignatureMap[i] : currentSig;
            measure.setKeySignature(nextSig);
        }
    }

    // ### numberMeasures
    // After anything that might change the measure numbers, update them iteratively
    numberMeasures() {
        this.renumberIndex = this.startIndex;
        var currentOffset = 0;
        if (this.measures[0].getTicksFromVoice(0) < smoMusic.timeSignatureToTicks(this.measures[0].timeSignature)) {
            currentOffset = -1;
        }

        for (var i = 0; i < this.measures.length; ++i) {
            var measure = this.measures[i];

            this.renumberIndex = this.renumberingMap[i] ? this.renumberingMap[i].startIndex : this.renumberIndex;
            var localIndex = this.renumberIndex + i + currentOffset;
            // If this is the first full measure, call it '1'
            var numberObj = {
                measureNumber: localIndex,
                measureIndex: i + this.startIndex,
                systemIndex: i,
				staffId:this.staffId
            }
            measure.setMeasureNumber(numberObj);
			// If we are renumbering measures, we assume we want to redo the layout so set measures to changed.
			measure.changed=true;
        }
    }
    getSelection(measureNumber, voice, tick, pitches) {
        for (var i = 0; i < this.measures.length; ++i) {
            var measure = this.measures[i];
            if (measure.measureNumber.measureNumber === measureNumber) {
                var target = this.measures[i].getSelection(voice, tick, pitches);
                if (!target) {
                    return null;
                }
                return ({
                    measure: measure,
                    note: target.note,
                    selection: target.selection
                });
            }
        }
        return null;
    }

    addDefaultMeasure(index, params) {
        var measure = SmoMeasure.getDefaultMeasure(params);
        this.addMeasure(index, measure);
    }

    // ## addMeasure
    // ## Description:
    // Add the measure at the specified index, splicing the array as required.
    addMeasure(index, measure) {

        if (index === 0 && this.measures.length) {
            measure.setMeasureNumber(this.measures[0].measureNumber);
        }
        if (index >= this.measures.length) {
            this.measures.push(measure);
        } else {
            this.measures.splice(index, 0, measure);
        }
        var modifiers = this.modifiers.filter((mod) => mod.startSelector.measure >= index);
        modifiers.forEach((mod) => {
            if (mod.startSelector.measure < this.measures.length) {
                mod.startSelector.measure += 1;
            }
            if (mod.endSelector.measure < this.measures.length) {
                mod.endSelector.measure += 1;
            }
        });

        this.numberMeasures();
    }
}
;// ## SmoScore
// ## Description:
// The whole score.
// ## Score methods:
// ---
class SmoScore {
    constructor(params) {
        Vex.Merge(this, SmoScore.defaults);
        Vex.Merge(this, params);
        if (!this.layout.pages) {
            this.layout.pages = 1;
        }
        if (this.staves.length) {
            this._numberStaves();
        }
    }
    static get engravingFonts() {
        return {Bravura:'Bravura',Gonville:'Gonville',Petaluma:'Petaluma'};
    }
  static get zoomModes() {
    return {fitWidth:0,wholePage:1,zoomScale:2}
  }
  static get defaults() {
    return {
      layout :{
        leftMargin:30,
        rightMargin:30,
        topMargin:40,
        bottomMargin:40,
        pageWidth: 8 * 96 + 48,
        pageHeight: 11 * 96,
        orientation:SmoScore.orientations.portrait,
        interGap: 30,
        intraGap:10,
        svgScale: 1.0,
        zoomScale: 2.0,
        zoomMode:SmoScore.zoomModes.fitWidth,
        pages:1
      },
      engravingFont:SmoScore.engravingFonts.Bravura,
      staffWidth: 1600,
      startIndex: 0,
      renumberingMap: {},
      keySignatureMap: {},
      measureTickmap: [],
      staves: [],
      activeStaff: 0,
      scoreText:[],
      textGroups:[],
      systemGroups:[]
    };
  }
  static get pageSizes() {
    return ['letter','tabloid','A4','custom'];
  }
  static get pageDimensions() {
    return {
      'letter':{width:8*96+48,height:11*96},
      'tabloid':{width:1056,height:1632},
      'A4':{width:794,height:1122},
      'custom':{width:1,height:1}
    }
  }

  static get orientationLabels() {
    return ['portrait','landscape'];
  }
  static get orientations() {
    return {'portrait':0,'landscape':1};
  }

    static get defaultAttributes() {
        return ['layout' ,'startIndex',  'renumberingMap', 'renumberIndex','engravingFont'];
    }

  serializeColumnMapped() {
    var attrColumnHash = {};
    var attrCurrentValue  = {};
    this.staves[0].measures.forEach((measure) => {
      measure.serializeColumnMapped(attrColumnHash,attrCurrentValue);
    });
    return attrColumnHash;
  }
  static deserializeColumnMapped(scoreObj) {
    // var attrColumnHash = scoreObj
    if (!scoreObj.columnAttributeMap) {
      return;
    }
    var attrs = Object.keys(scoreObj.columnAttributeMap);
    scoreObj.staves.forEach((staff) => {
      var attrIxMap = {};
      attrs.forEach((attr) => {
        attrIxMap[attr] = 0;
      });

      staff.measures.forEach((measure) => {
        attrs.forEach((attr) => {
          var mapIx = attrIxMap[attr];
          var curHash = scoreObj.columnAttributeMap[attr];
          var attrKeys = Object.keys(curHash);
          var curValue = curHash[attrKeys[mapIx.toString()]];
          attrKeys.sort((a,b) => parseInt(a) > parseInt(b) ? 1 : -1);
          if (attrKeys.length > mapIx + 1) {
            if (measure.measureNumber.measureIndex >= attrKeys[mapIx + 1]) {
              mapIx += 1;
              curValue = curHash[attrKeys[mapIx.toString()]];
            }
          }
          measure[attr] = curValue;
          attrIxMap[attr] = mapIx;
        });
      });
    });
  }

    // ### serialize
    // ### Serialize the score.  The resulting JSON string will contain all the staves, measures, etc.
  serialize() {
    var params = {};
    smoSerialize.serializedMerge(SmoScore.defaultAttributes, this, params);
    var obj = {
      score: params,
      staves: [],
      scoreText: [],
      textGroups: [],
      systemGroups: []
    };
    this.staves.forEach((staff) => {
      obj.staves.push(staff.serialize());
    });

    this.scoreText.forEach((tt) => {
      obj.scoreText.push(tt.serialize());
    });
    this.textGroups.forEach((tg) => {
      obj.textGroups.push(tg);
    });
    this.systemGroups.forEach((gg) => {
      obj.systemGroups.push(gg.serialize());
    });
    obj.columnAttributeMap = this.serializeColumnMapped();
    smoSerialize.jsonTokens(obj);
    obj = smoSerialize.detokenize(obj,smoSerialize.tokenValues);
    obj.dictionary = smoSerialize.tokenMap;
    return obj;
  }

  // ### deserialize
  // ### Restore an earlier JSON string.  Unlike other deserialize methods, this one expects the string.
  static deserialize(jsonString) {
    var jsonObj = JSON.parse(jsonString);
    if (jsonObj.dictionary) {
        jsonObj = smoSerialize.detokenize(jsonObj,jsonObj.dictionary);
    }
    var params = {};
    var staves = [];
    jsonObj.textGroups = jsonObj.textGroups ? jsonObj.textGroups : [];

    // Explode the sparse arrays of attributes into the measures
    SmoScore.deserializeColumnMapped(jsonObj);
    smoSerialize.serializedMerge(
        SmoScore.defaultAttributes,
        jsonObj.score, params);
    jsonObj.staves.forEach((staffObj) => {
        var staff = SmoSystemStaff.deserialize(staffObj);
        staves.push(staff);
    });
    var scoreText=[];
    jsonObj.scoreText.forEach((tt) => {
      var st = SmoScoreModifierBase.deserialize(tt);
      st.autoLayout = false; // since this has been layed out, presumably, before save
      st.classes = 'score-text '+ st.attrs.id;
      scoreText.push(st);
    });

    var textGroups = [];
    jsonObj.textGroups.forEach((tg) => {
      textGroups.push(SmoTextGroup.deserialize(tg));
    });

    var systemGroups = [];
    if (jsonObj['systemGroups']) {
      jsonObj.systemGroups.forEach((tt) => {
        var st = SmoScoreModifierBase.deserialize(tt);
        st.autoLayout = false; // since this has been layed out, presumably, before save
        systemGroups.push(st);
      });
    }
    params.staves = staves;

    let score = new SmoScore(params);
    score.scoreText=scoreText;
    score.textGroups = textGroups;
    score.systemGroups = systemGroups;
    return score;
  }

  // ### getDefaultScore
  // ### Description:
  // Gets a score consisting of a single measure with all the defaults.
  static getDefaultScore(scoreDefaults, measureDefaults) {
    scoreDefaults = (scoreDefaults != null ? scoreDefaults : SmoScore.defaults);
    measureDefaults = (measureDefaults != null ? measureDefaults : SmoMeasure.defaults);
    var score = new SmoScore(scoreDefaults);
    score.addStaff({measureDefaults:measureDefaults});
    var measure = SmoMeasure.getDefaultMeasure(measureDefaults);
    score.addMeasure(0, measure);
    measure.voices.push({
      notes: SmoMeasure.getDefaultNotes(measureDefaults)
    });
    return score;
  }

  // ### getEmptyScore
  // ### Description:
  // Create a score object, but don't populate it with anything.
  static getEmptyScore(scoreDefaults) {
    var score = new SmoScore(scoreDefaults);
    score.addStaff();
    return score;
  }

    // ### _numberStaves
    // recursively renumber staffs and measures.
  _numberStaves() {
    for (var i = 0; i < this.staves.length; ++i) {
      var stave = this.staves[i];
      stave.staffId=i;
      stave.numberMeasures();
    }
  }

    // ### addDefaultMeasureWithNotes
    // ### Description:
    // Add a measure to the score with the supplied parameters at the supplied index.
    // The defaults per staff may be different depending on the clef, key of the staff.
    addDefaultMeasureWithNotes(measureIndex, parameters) {
        this.staves.forEach((staff) => {
            var defaultMeasure =
                SmoMeasure.getDefaultMeasureWithNotes(parameters);
            staff.addMeasure(measureIndex, defaultMeasure);
        });
    }

    // ### deleteMeasure
    // Delete the measure at the supplied index in all the staves.
    deleteMeasure(measureIndex) {
        this.staves.forEach((staff) => {
            staff.deleteMeasure(measureIndex);
        });

    }

    convertToPickupMeasure(measureIndex,duration) {
        for (var i = 0; i < this.staves.length; ++i) {

            var staff = this.staves[i];
            var protomeasure = staff.measures[measureIndex].pickupMeasure(duration);
            staff.measures[measureIndex] = protomeasure;
        }
        this._numberStaves();
    }

    addPickupMeasure(measureIndex,duration) {
        for (var i = 0; i < this.staves.length; ++i) {

            var staff = this.staves[i];
            var protomeasure = staff.measures[measureIndex].pickupMeasure(duration);
            staff.addMeasure(measureIndex,protomeasure);
        }
        this._numberStaves();
    }

    // ### addMeasure
    // Give a measure prototype, create a new measure and add it to each staff, with the
    // correct settings for current time signature/clef.
    addMeasure(measureIndex, measure) {

        for (var i = 0; i < this.staves.length; ++i) {
            var protomeasure = measure;
            var staff = this.staves[i];
            // Since this staff may already have instrument settings, use the
            // immediately preceeding or post-ceding measure if it exists.
            if (measureIndex < staff.measures.length) {
                protomeasure = staff.measures[measureIndex];
            } else if (staff.measures.length) {
                protomeasure = staff.measures[staff.measures.length - 1];
            }
            var nmeasure = SmoMeasure.getDefaultMeasureWithNotes(protomeasure);
            if (nmeasure.voices.length <= nmeasure.getActiveVoice()) {
                nmeasure.setActiveVoice(0);
            }
            staff.addMeasure(measureIndex, nmeasure);
        }
        this._numberStaves();
    }

    // ### replaceMeasure
    // Replace the measure at the given location.  Probably due to an undo operation or paste.
    replaceMeasure(selector, measure) {
        var staff = this.staves[selector.staff];
        staff.measures[selector.measure] = measure;
    }

    getSystemGroupForStaff(selection) {
        var exist = this.systemGroups.find((sg) => {
            return sg.startSelector.staff <= selection.staff.staffId &&
            sg.endSelector.staff >= selection.staff.staffId &&
            (sg.mapType == SmoSystemGroup.mapTypes.allMeasures ||
            (sg.startSelector.measure <= selection.measure.measureNumber.measureIndex &&
            sg.endSelector.measure >= selection.measure.measureNumber.measureIndex));
        });
        return exist;
    }

    addOrReplaceSystemGroup(newGroup) {
        var ar = [];
        this.systemGroups = this.systemGroups.filter((sg) => {
            return sg.startSelector.staff >= newGroup.startSelector.staff ||
               sg.endSelector.staff <= newGroup.startSelector.staff ||
               (newGroup.mapType == SmoSystemGroup.mapType.measureMap &&
                sg.mapType ==  SmoSystemGroup.mapType.measureMap &&
                (sg.startSelector.measure >= newGroup.startSelector.measure ||
                sg.endSelector.measure <= newGroup.startSelector.measure))
        });
        this.systemGroups.push(newGroup);
    }


    // ### replace staff
  // Probably due to an undo operation, replace the staff at the given index.
    replaceStaff(index, staff) {
        var staves = [];
        for (var i = 0; i < this.staves.length; ++i) {
            if (i != index) {
                staves.push(this.staves[i]);
            } else {
                staves.push(staff);
            }
        }
        this.staves = staves;
    }
    // ### addKeySignature
    // Add a key signature at the specified index in all staves.
    addKeySignature(measureIndex, key) {
        this.staves.forEach((staff) => {
            staff.addKeySignature(measureIndex, key);
        });
    }

    // ### addInstrument
    // add a new staff (instrument) to the score
    addStaff(parameters) {
        if (this.staves.length == 0) {
            this.staves.push(new SmoSystemStaff(parameters));
            this.activeStaff = 0;
            return;
        }
        if (!parameters) {
            parameters = SmoSystemStaff.defaults;
        }
        var proto = this.staves[0];
        var measures = [];
        for (var i = 0; i < proto.measures.length; ++i) {
            var newParams = {};
            var measure = proto.measures[i];
            smoSerialize.serializedMerge(SmoMeasure.defaultAttributes, measure, newParams);
            newParams.clef = parameters.instrumentInfo.clef;
            newParams.transposeIndex = parameters.instrumentInfo.keyOffset;
            var newMeasure = SmoMeasure.getDefaultMeasureWithNotes(newParams);
            newMeasure.measureNumber = measure.measureNumber;
      newMeasure.modifiers=[];
      measure.modifiers.forEach((modifier) => {
        var ctor = eval(modifier.ctor);
                var nmod = new ctor(modifier);
        newMeasure.modifiers.push(nmod);
      });
            measures.push(newMeasure);
        }
        parameters.measures = measures;
        var staff = new SmoSystemStaff(parameters);
        this.staves.push(staff);
        this.activeStaff = this.staves.length - 1;
    this._numberStaves();
    }

    // ### removeStaff
  // Remove stave at the given index
    removeStaff(index) {
        var staves = [];
        var ix = 0;
        this.staves.forEach((staff) => {
            if (ix != index) {
                staves.push(staff);
            }
            ix += 1;
        });
        this.staves = staves;
        this._numberStaves();
    }

    swapStaves(index1,index2) {
        if (this.staves.length < index1 || this.staves.length < index2) {
            return;
        }
        var tmpStaff = this.staves[index1];
        this.staves[index1] = this.staves[index2];
        this.staves[index2] = tmpStaff;
        this._numberStaves();
    }

  _updateScoreText(textObject,toAdd) {
    var texts=[];
    this.scoreText.forEach((tt) => {
      if (textObject.attrs.id !=  tt.attrs.id) {
        texts.push(tt);
      }
    });
      if (toAdd) {
      texts.push(textObject);
    }
    this.scoreText = texts;
  }
  _updateTextGroup(textGroup,toAdd) {
    var tgid = typeof(textGroup) === 'string' ? textGroup :
      textGroup.attrs.id;
    var ar = this.textGroups.filter((tg) => tg.attrs.id !== tgid);
    this.textGroups = ar;
    if (toAdd) {
      this.textGroups.push(textGroup);
    }
  }

  addTextGroup(textGroup) {
    this._updateTextGroup(textGroup,true);
  }
  getTextGroup(textGroup) {
    var tgid = typeof(textGroup) === 'string' ? textGroup :
      textGroup.attrs.id;
    return this.textGroups.find((tg) => tg.tgid === tg.attrs.id);
  }
  removeTextGroup(textGroup) {
    var tgid = typeof(textGroup) === 'string' ? textGroup :
      textGroup.attrs.id;
      this._updateTextGroup(textGroup,false);
  }

  addScoreText(textObject) {
    this._updateScoreText(textObject,true);
  }

  getScoreText(id) {
    if (!this.scoreText.length) {
      return null;
    }
    var ar = this.scoreText.filter((tt) => {
      return tt.attrs.id=id;
    });
    if(ar.length) {
      return ar[0];
    }
    return null;
  }

  removeScoreText(textObject) {
    this._updateScoreText(textObject,false);
  }

    get measures() {
        if (this.staves.length === 0)
            return [];
        return this.staves[this.activeStaff].measures;
    }
  incrementActiveStaff(offset) {
    if (offset < 0) {
      offset = offset + this.staves.length;
    }
    var nextStaff = (this.activeStaff + offset) % this.staves.length;
    if (nextStaff >= 0 && nextStaff < this.staves.length) {
      this.activeStaff = nextStaff;
    }
    return this.activeStaff;
  }

    setActiveStaff(index) {
        this.activeStaff = index <= this.staves.length ? index : this.activeStaff;
    }

    getRenderedNote(id) {
        for (var i = 0; i < this.staves.length; ++i) {
            var stave = this.staves[i];
            var note = stave.getRenderedNote(id);
            if (note) {
                note.selection.staffIndex = i;
                return note;
            }
        }
        return null;
    }
}
;
// ## StaffModifiers
// ## Description:
// This file contains modifiers that might take up multiple measures, and are thus associated
// with the staff.
// ## Staff Modifier Classes:
// ---
// ## StaffModifierBase
// ## Description:
// Base class that mostly standardizes the interface and deals with serialization.
class StaffModifierBase {
    constructor(ctor) {
        this.ctor = ctor;
    }
    static deserialize(params) {
        var ctor = eval(params.ctor);
        var rv = new ctor(params);
		return rv;
    }
}

// ## SmoStaffHairpin
// ## Descpription:
// crescendo/decrescendo
class SmoStaffHairpin extends StaffModifierBase {
    constructor(params) {
        super('SmoStaffHairpin');
        Vex.Merge(this, SmoStaffHairpin.defaults);
        smoSerialize.filteredMerge(['position', 'xOffset', 'yOffset', 'hairpinType', 'height'], params, this);
        this.startSelector = params.startSelector;
        this.endSelector = params.endSelector;

        if (!this['attrs']) {
            this.attrs = {
                id: VF.Element.newID(),
                type: 'SmoStaffHairpin'
            };
        } else {
            console.log('inherit attrs');
        }
    }
	static get editableAttributes() {
		return ['xOffsetLeft', 'xOffsetRight', 'yOffset', 'height'];
	}
    static get attributes() {
        return ['position', 'startSelector','endSelector','xOffset', 'yOffset', 'hairpinType', 'height'];
    }
    serialize() {
        var params = {};
        smoSerialize.serializedMergeNonDefault(SmoStaffHairpin.defaults,SmoStaffHairpin.attributes,this,params);
        params.ctor = 'SmoStaffHairpin';
        return params;
    }
    get id() {
        return this.attrs.id;
    }
    get type() {
        return this.attrs.type;
    }

    backupOriginal() {
        if (!this['original']) {
            this.original = {};
            smoSerialize.filteredMerge(
                ['xOffsetLeft', 'xOffsetRight', 'yOffset', 'height', 'position', 'hairpinType'],
                this, this.original);
        }
    }
    restoreOriginal() {
        if (this['original']) {
            smoSerialize.filteredMerge(
                ['xOffsetLeft', 'xOffsetRight', 'yOffset', 'height', 'position', 'hairpinType'],
                this.original, this);
            this.original = null;
        }
    }
    static get defaults() {
        return {
            xOffsetLeft: -2,
            xOffsetRight: 0,
            yOffset: -50,
            height: 10,
            position: SmoStaffHairpin.positions.BELOW,
            hairpinType: SmoStaffHairpin.types.CRESCENDO

        };
    }
    static get positions() {
        // matches VF.modifier
        return {
            LEFT: 1,
            RIGHT: 2,
            ABOVE: 3,
            BELOW: 4,
        };
    }
    static get types() {
        return {
            CRESCENDO: 1,
            DECRESCENDO: 2
        };
    }
}

// ## SmoSlur
// ## Description:
// slur staff modifier
// ## SmoSlur Methods:
// ---
class SmoSlur extends StaffModifierBase {
    static get defaults() {
        return {
            spacing: 2,
            thickness: 2,
            xOffset: -5,
            yOffset: 10,
            position: SmoSlur.positions.HEAD,
            position_end: SmoSlur.positions.HEAD,
            invert: false,
            cp1x: 0,
            cp1y: 15,
            cp2x: 0,
            cp2y: 15,
            pitchesStart:[],
            pitchesEnd:[]
        };
    }

    // matches VF curve
    static get positions() {
        return {
            HEAD: 1,
            TOP: 2
        };
    }
    static get parameterArray() {
        return ['startSelector','endSelector','spacing', 'xOffset', 'yOffset', 'position', 'position_end', 'invert',
            'cp1x', 'cp1y', 'cp2x', 'cp2y','thickness','pitchesStart','pitchesEnd'];
    }

    serialize() {
        var params = {};
        smoSerialize.serializedMergeNonDefault(SmoSlur.defaults,
            SmoSlur.parameterArray,this,params);

        // smoMusic.filteredMerge(SmoSlur.parameterArray, this, params);
        params.ctor = 'SmoSlur';
        return params;
    }

    backupOriginal() {
        if (!this['original']) {
            this.original = {};
            smoSerialize.filteredMerge(
                SmoSlur.parameterArray,
                this, this.original);
        }
    }
    restoreOriginal() {
        if (this['original']) {
            smoSerialize.filteredMerge(
                SmoSlur.parameterArray,
                this.original, this);
            this.original = null;
        }
    }
    get controlPoints() {
        var ar = [{
                x: this.cp1x,
                y: this.cp1y
            }, {
                x: this.cp2x,
                y: this.cp2y
            }
        ];
        return ar;
    }

    constructor(params) {
        super('SmoSlur');
        smoSerialize.serializedMerge(SmoSlur.parameterArray,SmoSlur.defaults,this);
		// Vex.Merge(this,SmoSlur.defaults);
		// smoMusic.filteredMerge(SmoSlur.parameterArray,params,this);
        smoSerialize.serializedMerge(SmoSlur.parameterArray, params, this);
        this.startSelector = params.startSelector;
        this.endSelector = params.endSelector;

        // TODO: allow user to customize these

        if (!this['attrs']) {
            this.attrs = {
                id: VF.Element.newID(),
                type: 'SmoSlur'
            };
        }
    }
}
;
class SmoScoreModifierBase {
  constructor(ctor) {
    this.ctor = ctor;
    if (!this['attrs']) {
      this.attrs = {
        id: VF.Element.newID(),
        type: ctor
      };
    } else {
            console.log('inherit attrs');
    }
  }

  static deserialize(jsonObj) {
    var ctor = eval(jsonObj.ctor);
    var rv = new ctor(jsonObj);
    return rv;
  }
}

class SmoSystemGroup extends SmoScoreModifierBase {
  constructor(params) {
    super('SmoSystemGroup');
    smoSerialize.serializedMerge(SmoSystemGroup.attributes,SmoSystemGroup.defaults,this);
    smoSerialize.serializedMerge(SmoSystemGroup.attributes, params, this);

    if (!this['attrs']) {
      this.attrs = {
        id: VF.Element.newID(),
        type: 'SmoStaffHairpin'
      };
    } else {
      console.log('inherit attrs');
    }
  }
  static get defaults() {
    return {
      leftConnector:SmoSystemGroup.connectorTypes.single,
      rightConnector:SmoSystemGroup.connectorTypes.single,
      mapType:SmoSystemGroup.mapTypes.allMeasures,
      text:'',
      shortText:'',
      justify:true,
      startSelector:{staff:0,measure:0},
      endSelector:{staff:0,measure:0}
    }
  }
  leftConnectorVx() {
    switch (this.leftConnector) {
      case SmoSystemGroup.connectorTypes.single:
        return VF.StaveConnector.type.SINGLE_LEFT;
      case SmoSystemGroup.connectorTypes.double:
        return VF.StaveConnector.type.DOUBLE_LEFT;
      case SmoSystemGroup.connectorTypes.brace:
        return VF.StaveConnector.type.BRACE;
     case SmoSystemGroup.connectorTypes.bracket:
     default:
      return VF.StaveConnector.type.BRACKET;
    };
  }
    rightConnectorVx() {
        switch (this.rightConnector) {
            case SmoSystemGroup.connectorTypes.single:
               return StaveConnector.type.SINGLE_RIGHT;
            case SmoSystemGroup.connectorTypes.double:
            default:
               return StaveConnector.type.DOUBLE_RIGHT;
        };
    }
    static get connectorTypes() {
        return {brace:0,bracket:1,single:2,double:3};
    }
    static get mapTypes() {
        return {allMeasures:0,range:1};
    }
    static get attributes() {
        return ['leftConnector', 'rightConnector','text','shortText','justify',
       'startSelector','endSelector','mapType'];
    }
  serialize() {
		var params = {};
    smoSerialize.serializedMergeNonDefault(SmoSystemGroup.defaults,SmoSystemGroup.attributes,this,params);
    params.ctor = 'SmoSystemGroup';
    return params;
	}
}

// ## SmoTextGroup
// A grouping of text that can be used as a block for
// justification, alignment etc.
class SmoTextGroup extends SmoScoreModifierBase {
  static get justifications() {
    return {
      LEFT: 1,
      RIGHT: 2,
      CENTER: 3
    };
  }
  // The position of block n relative to block n-1.  Each block
  // has it's own position.  Justification is inter-block.
  static get relativePosition() {
    return { ABOVE: 1, BELOW: 2, LEFT: 3, RIGHT: 4 };
  }
  static get defaults() {
    return { textBlocks:[],
      justification: SmoTextGroup.justifications.LEFT
    };
  }
  static get attributes() {
    return ['textBlocks','justification'];
  }
  static deserialize(jObj) {
    var blocks = [];
    jObj.textBlocks.forEach((st) => {
      var tx = new SmoScoreText(st.text);
      blocks.push({text: tx, position: st.position});
    });
    return new SmoTextGroup({blocks: blocks});
  }
  serialize() {
    smoSerialize.serializedMergeNonDefault(SmoTextGroup.defaults,SmoTextGroup.attributes,this,params);
    params.ctor = 'SmoTextGroup';
    return params;
  }
  _isScoreText(st) {
    return st.ctor && st.ctor === 'SmoScoreText';
  }
  constructor(params) {
    params = params ? params : {};
    super('SmoTextGroup');
    this.textBlocks = [];
    this.backupBlocks = [];
    Vex.Merge(this,SmoTextGroup.defaults);
    Vex.Merge(this,params);
    if (params.blocks) {
      params.blocks.forEach((block) => {
        if (this._isScoreText(block)) {
          this.textBlocks.push({text: block, position: SmoTextGroup.relativePosition.RIGHT});
        } else if (this._isScoreText(block.text)) {
          this.textBlocks.push(block);
        } else {
          throw("Invalid object in SmoTextGroup");
        }
      });
    }
  }
  addScoreText(scoreText,prevBlock,position) {
    if (!this._isScoreText(scoreText)) {
      throw('Need SmoScoreText to add to TextGroup');
    }
    if (!prevBlock) {
      this.textBlocks.push({text:scoreText,position: position});
    } else {
      var bbid =  (typeof(prevBlock) === 'string') ? prevBlock : prevBlock.attrs.id;
      var ix = this.textBlocks.findIndex((bb) => bb.attrs.id === bbid);
      this.textBlocks.splice(ix,0,nextBlock);
    }
  }
  ul() {
    var rv = {x:0,y:0};
    this.textBlocks.forEach((block) => {
      rv.x = block.text.x > rv.x ? block.text.x : rv.x;
      rv.y = block.text.y > rv.y ? block.text.y : rv.y;
    });
    return rv;
  }
  removeBlock(scoreText) {
    if (!this._isScoreText(scoreText)) {
      throw('Need SmoScoreText to add to TextGroup');
    }
    var bbid =  (typeof(scoreText) === 'string') ? scoreText : scoreText.attrs.id;
    var ix = this.textBlocks.findIndex((bb) => bb.attrs.id === bbid);
    this.textBlocks.splice(ix,1);
  }
  offsetX(offset) {
    this.textBlocks.forEach((block) => {
      block.text.offsetX(offset);
    });
  }
  offsetY(offset) {
    this.textBlocks.forEach((block) => {
      block.text.offsetY(offset);
    });
  }

  scaleInPlace(factor) {
    this.textBlocks.forEach((block) => {
      block.text.scaleInPlace(factor);
    });
  }
  scaleXInPlace(factor) {
    this.textBlocks.forEach((block) => {
      block.text.scaleXInPlace(factor);
    });
  }
  scaleYInPlace(factor) {
    this.textBlocks.forEach((block) => {
      block.text.scaleYInPlace(factor);
    });
  }

  backupParams() {
    this.textBlocks.forEach((block) => {
      block.text.backupParams();
    });
  }

  restoreParams() {
    this.textBlocks.forEach((block) => {
      block.text.restoreParams();
    });
  }
}
// ## SmoScoreText
// Identify some text in the score, not associated with any musical element, like page
// decorations, titles etc.
class SmoScoreText extends SmoScoreModifierBase {

  static _pointFromEm(size) {
    var ptString = size.substring(0,scoreText.fontInfo.size.length - 2);
    return parseFloat(ptString) * 14;
  }
  // convert EM to a number, or leave as a number etc.
  static fontPointSize(size) {
    if (typeof(size) === 'number') {
      return size;
    }
    var ptString = size.substring(0,size.length - 2); // TODO: work with px, pt
    return parseFloat(ptString) * 14;
  }

  static get paginations() {
		return {every:'every',even:'even',odd:'odd',once:'once',subsequent:'subsequent'}
	}
	static get positions() {
		return {title:'title',copyright:'copyright',footer:'footer',header:'header',custom:'custom'};
	}
	static get justifications() {
		return {left:'left',right:'right',center:'center'};
	}
  static get fontFamilies() {
    return {serif:'Merriweather,serif',sansSerif:'Roboto,sans-serif',monospace:'monospace',cursive:'cursive',
      times:'Merriweather',arial:'Arial',helvitica:'Helvitica'};
  }
	// If box model is 'none', the font and location determine the size.
	// spacing and spacingGlyph fit the box into a container based on the svg policy
	static get boxModels() {
		return {none:'none',spacing:'spacing',spacingAndGlyphs:'spacingAndGlyphs',wrap:'wrap'};
	}
  static get defaults() {
      return {
          x:15,
		y:15,
		width:0,
		height:0,
          text: 'Smoosic',
		fontInfo: {
			size: '1em',
			family:SmoScoreText.fontFamilies.times,
			style:'normal',
			weight:'normal'
		},
		fill:'black',
		rotate:0,
		justification:SmoScoreText.justifications.left,
		classes:'score-text',
		boxModel:'none',
		scaleX:1.0,
		scaleY:1.0,
		translateX:0,
		translateY:0,
		pagination:'once',
		position:'custom',
		autoLayout:false // set to true if one of the pre-canned positions are used.
    };
  }
	static toSvgAttributes(inst) {
		var rv=[];
		var fkeys = Object.keys(inst.fontInfo);
    var fontFamily = SmoScoreText[inst.fontInfo.family] ? SmoScoreText[inst.fontInfo.family] : inst.fontInfo.family;
    fkeys.forEach((key) => {
			var n=JSON.parse('{"font-'+key+'":"'+inst.fontInfo[key]+'"}');
      if (n['font-family']) {
        n['font-family'] = fontFamily;
      }
			rv.push(n);
		});

		var attrs = SmoScoreText.attributes.filter((x) => {return x != 'fontInfo' && x != 'boxModel'});
		rv.push({fill:inst.fill});
		rv.push({x:inst.x});
		rv.push({y:inst.y});
		if (inst.boxModel != 'none' && inst.width) {
			var len = ''+inst.width+'px';
			rv.push({textLength:len});
			// rv.push({lengthAdjust:inst.boxModel});
		}
		rv.push({transform:'translate ('+inst.translateX+' '+inst.translateY+') scale ('+
		    inst.scaleX+' '+inst.scaleY+')'});
		return rv;
	}

  getText() {
    return this.text;
  }

	toSvgAttributes() {
		return SmoScoreText.toSvgAttributes(this);
	}

	// ### backupParams
	// For animation or estimation, create a copy of the attributes that can be modified without affecting settings.
	backupParams() {
		this.backup={};
		smoSerialize.serializedMerge(SmoScoreText.attributes, this, this.backup);
		return this.backup;
	}

  restoreParams() {
    smoSerialize.serializedMerge(SmoScoreText.attributes, this.backup, this);
  }//

  offsetX(offset) {
    this.x += offset;
  }
  offsetY(offset) {
    this.y += offset;
  }

	serialize() {
	var params = {};
    smoSerialize.serializedMergeNonDefault(SmoScoreText.defaults,SmoScoreText.attributes,this,params);
    params.ctor = 'SmoScoreText';
    return params;
	}
  static get attributes() {
    return ['x','y','text','pagination','position','fontInfo','classes',
    'boxModel','justification','fill','width','height','scaleX','scaleY','translateX','translateY','autoLayout'];
  }

	// scale the text without moving it.
	scaleInPlace(factor) {
    this.fontInfo.size = SmoScoreText.fontPointSize(this.fontInfo.size) * factor;
	}
  scaleXInPlace(factor) {
		this.scaleX = factor;
		var deltax = this.x - this.x*this.scaleX;
		this.translateX = deltax;
  }
  scaleYInPlace(factor) {
		this.scaleY = factor;
		var deltay = this.y - this.y*this.scaleY;
		this.translateY = deltay;
  }
  constructor(parameters) {
    super('SmoScoreText');
    parameters = parameters ? parameters : {};
    this.backup={};
    this.edited = false; // indicate to UI that the actual text has not been edited.

		smoSerialize.serializedMerge(SmoScoreText.attributes, SmoScoreText.defaults, this);
    smoSerialize.serializedMerge(SmoScoreText.attributes, parameters, this);
		if (!this.classes) {
			this.classes='';
		}
    if (this.classes.indexOf(this.attrs.id) < 0) {
      this.classes += ' '+this.attrs.id;
    }
		if (this.boxModel === SmoScoreText.boxModels.wrap) {
			this.width = parameters.width ? this.width : 200;
			this.height = parameters.height ? this.height : 150;
			if (!parameters.justification) {
				this.justification = this.position === SmoScoreText.positions.copyright
						? SmoScoreText.justifications.right : SmoScoreText.justifications.center;

			}
		}
		if (this.position != SmoScoreText.positions.custom && !parameters['autoLayout']) {
			this.autoLayout = true;
			if (this.position == SmoScoreText.positions.title) {
				this.fontInfo.size='1.8em';
			} else {
				this.fontInfo.size='.6em';
			}
		}
  }
}
;
VF = Vex.Flow;
Vex.Xform = (typeof(Vex.Xform) == 'undefined' ? {}
     : Vex.Xform);
VX = Vex.Xform;

// ## smoTickIterator
// This file implements over the notes in a single measure.
// This is useful when redrawing the notes to transform them into something else.
// E.g. changing the duration of a note in a measure.  It keeps track of accidentals,
// ticks used etc.
// ### Usage:
// ``javascript``
// `var iterator=new smoTickIterator(measure)
// `iterator.iterate (actor)`
// where actor is a function that is called at each tick in the voice.
//
// ### iterator format:
//   iterator: {
//      notes:[note1,note2...],
//      delta: tick value of this note
//      totalDuration: ticks up until this point
//      note: current note,
//      index: running index
//
// ### Tickmap format
// `VX.TICKMAP(measure)`
// Iterate through all notes and creates information about the notes, like
// tuplet ticks, index-to-tick map.  The tickmap is useful for finding things out like how much
// time is left in a measure at a given note index (tickIndex).
//
//     tickmap = {
//        totalDuration: 16384,
//        accidentalMap:[{'F':'#','G':'b'},....
//        durationMap:[2048,4096,..],  // A running total
//        deltaMap:[2048,2048...], a map of deltas
//        tupletMap: {
//          noteId1:
//          {startIndex:1,endIndex:3,numNotes:3,startTick:4096,endTick:8196,durations:[1365,...],smallestDuration:2048}
//
//
// ## method documentation follows
// ---
class smoTickIterator {

    constructor(measure, options) {
        this.keySignature = measure.keySignature;

        Vex.Merge(this, options);
        this.voice = typeof(options['voice']) == 'number' ? options.voice : measure.activeVoice;
        this.notes = measure.voices[this.voice].notes;
        this.index = 0;
        this.startIndex = 0;
        this.endIndex = this.notes.length;

        // so a client can tell if the iterator's been run or not
        var states = ['CREATED', 'RUNNING', 'COMPLETE'];
        this.state = 'CREATED';

        // ticks as we iterate.
        // duration is duration of the current range
        this.duration = 0;
        // duration is the accumulated duraition over all the notes
        this.totalDuration = 0;
        // delta is the tick contribution of this note
        this.delta = 0;
        // the tick start location of notes[x]
        this.durationMap = [];
        this.deltaMap = [];

        this.tupletMap = {};
        this.accidentalMap = [];
        this.durationAccidentalMap={};

        this.hasRun = false;
        this.beattime = 4096;
    }

    // empty function for a default iterator (tickmap)
    static nullActor() {}

    // ### _getAccidentalsForKey
    // Update `map` with the correct accidental based on the key signature.
    static _getAccidentalsForKey(keySignature, map) {
        var music = new VF.Music();
        var keys = music.createScaleMap(keySignature);
        var keyKeys = Object.keys(keys);
        keyKeys.forEach((keyKey) => {
            var vexKey = keys[keyKey];
            if (vexKey.length > 1 && (vexKey[1] === 'b' || vexKey[1] === '#')) {
                var pitch = {
                    letter: vexKey[0],
                    accidental: vexKey[1]
                };
                map[vexKey[0]] = {
                    duration:0,
                    pitch:pitch
                }
            }
        });
    }

	// ### updateAccidentalMap
	// Keep a running tally of the accidentals for this voice
    // based on the key and previous accidentals.
    static updateAccidentalMap(note, iterator, keySignature, accidentalMap) {
        var sigObj = {};
        var newObj = {};
        if (iterator.index === 0) {
            smoTickIterator._getAccidentalsForKey(keySignature, newObj);
            sigObj = newObj;
        } else {
            sigObj = accidentalMap[iterator.index - 1];
        }
        for (var i = 0; i < note.pitches.length; ++i) {
            if (note.noteType != 'n') {
                continue;
            }
            var pitch = note.pitches[i];
            var letter = pitch.letter.toLowerCase();
            var sigLetter = letter + pitch.accidental;
            var sigKey = smoMusic.getKeySignatureKey(letter, keySignature);

            if (sigObj && sigObj[letter]) {
                var currentVal = sigObj[letter].key + sigObj[letter].accidental;
                if (sigLetter != currentVal) {
                    newObj[letter] = {pitch:pitch,duration:iterator.duration};
                }
            } else {
                if (sigLetter != sigKey) {
                    newObj[letter] = {pitch:pitch,duration:iterator.duration};
                }
            }
        }
        accidentalMap.push(newObj);
        // Mark the accidental with the start of this note.
        iterator.durationAccidentalMap[iterator.durationMap[iterator.index]] = newObj;
    }

	// ### getActiveAccidental
	// return the active accidental for the given note
    getActiveAccidental(pitch, iteratorIndex, keySignature) {
		var defaultAccidental = smoMusic.getKeySignatureKey(pitch.letter, keySignature);
		defaultAccidental = defaultAccidental.length > 1 ? defaultAccidental[1] : 'n';
        if (iteratorIndex === 0)
            return defaultAccidental;
        var accidental = pitch.accidental.length > 0 ? pitch.accidental : 'n';
		var letter = pitch.letter;

        // Back up the accidental map until we have a match, or until we run out
        for (var i = iteratorIndex; i > 0; --i) {
            var map = this.accidentalMap[i - 1];
            var mapKeys = Object.keys(map);
            for (var j = 0; j < mapKeys.length; ++j) {
                var mapKey = mapKeys[j];
                // The letter name + accidental in the map
                var mapLetter = map[mapKey];
                var mapAcc = mapLetter.accidental ? mapLetter.accidental : 'n';

                // if the letters match and the accidental...
                if (mapLetter.pitch.letter.toLowerCase() === letter) {
                    return mapAcc;
                }
            }
        }
        return defaultAccidental;
    }

    // ### _iterate
    // Internal callback for iterator.
    _iterate(actor) {
        this.state = 'RUNNING';
        for (this.index = this.startIndex; this.index < this.endIndex; ++this.index) {
            var note = this.notes[this.index];

            // save the starting point, tickwise
            this.durationMap.push(this.totalDuration);

            // the number of ticks for this note
            this.delta = (note.ticks.numerator / note.ticks.denominator) + note.ticks.remainder;
            this.deltaMap.push(this.delta);

            if (note['tuplet'] && note.tuplet['attrs']) {
                var normalizedTicks = VF.durationToTicks(note.duration);
                if (typeof(this.tupletMap[note.tuplet.attrs.id]) == 'undefined') {
                    this.tupletMap[note.tuplet.attrs.id] = {
                        startIndex: this.index,
                        tupletIndex: 0,
                        startTick: this.totalDuration,
                        smallestDuration: normalizedTicks,
                        num_notes: note.tuplet.num_notes,
                        durations: [this.delta]
                    };
                } else {
                    var entry = this.tupletMap[note.tuplet.attrs.id];

                    entry.endIndex = this.index;
                    entry.endTick = this.totalDuration + this.delta;
                    entry.smallestDuration = ((normalizedTicks < entry.smallestDuration) ? normalizedTicks : entry.smallestDuration);
                    entry.durations.push(this.delta);
                }
            }

            // update the tick count for the current range.
            this.duration += this.delta;

            // update the tick count for the whole array/measure
            this.totalDuration += this.delta;

            smoTickIterator.updateAccidentalMap(note, this, this.keySignature, this.accidentalMap);

            var rv = actor(this, note, this.accidentalMap);
            if (rv === false) {
                break;
            }
        }
        this.state = 'COMPLETE';
    }

    // ### iterate
    // Call `actor` for each iterator tick
    iterate(actor) {
        // todo add promise
        this._iterate(actor);
    }

    // ### getTickIndex
    // get the index into notes array that takes up
    // duration of ticks */
    getTickIndex(index, duration) {
        if (index == 0)
            return 0;
        var initial = this.durationMap[index];
        var delta = 0;
        while (index < this.notes.length && delta < duration) {
            index += 1;
            delta += this.durationMap[index] - this.durationMap[index - 1];
        }
        return index;
    }
    // ### skipNext
    // skip some number of notes in the iteration, because we want to skip over them.
    skipNext(skipCount) {
        var rv = [];
        var startRange = this.index;
        // var tuplen = note.tupletStack[0].notes.length;
        var endRange = this.index + skipCount;
        rv = this.notes.slice(startRange, endRange);
        this.index = endRange;
        // this.startRange = this.index;
        return rv;
    }
}
;
class BeamModifierBase {
    constructor() {}
    beamNote(note, tickmap, accidentalMap) {}
}

class smoBeamerFactory {
    static applyBeams(measure) {
        for (var i = 0;i < measure.voices.length;++i) {
            var beamer = new smoBeamModifier(measure,i);
            var apply = new smoBeamerIterator(measure, beamer,i);
            apply.run();
        }
    }
}

class smoBeamerIterator {
    constructor(measure, actor,voice) {
        this.actor = actor;
        this.measure = measure;
        this.voice = voice;
    }

    //  ### run
    //  ###  Description:  start the iteration on this set of notes
    run() {
        var tickmap = this.measure.tickmapForVoice(this.voice);
        for (var i = 0;i < tickmap.durationMap.length;++i) {
            this.actor.beamNote(tickmap, i,this.measure.voices[this.voice].notes[i]);
        }
    }
}

class smoBeamModifier extends BeamModifierBase {
    constructor(measure,voice) {
        super();
        this.measure = measure;
        this._removeVoiceBeam(measure,voice);
        this.duration = 0;
        this.timeSignature = measure.timeSignature;
        this.meterNumbers = this.timeSignature.split('/').map(number => parseInt(number, 10));

        this.duration = 0;
        // beam on 1/4 notes in most meter, triple time dotted quarter
        this.beamBeats = 2 * 2048;
        if (this.meterNumbers[0] % 3 == 0) {
            this.beamBeats = 3 * 2048;
        }
        this.skipNext = 0;
        this.currentGroup = [];
    }

    get beamGroups() {
        return this.measure.beamGroups;
    }
    _removeVoiceBeam(measure,voice) {
        var beamGroups = [];
        measure.beamGroups.forEach((gr) => {
            if (gr.voice != voice) {
                beamGroups.push(gr);
            }
        });

        measure.beamGroups = beamGroups;
    }

    _completeGroup(voice) {
        // don't beam groups of 1
        if (this.currentGroup.length > 1) {
            this.measure.beamGroups.push(new SmoBeamGroup({
                    notes: this.currentGroup,
                    voice:voice
                }));
        }
    }

    _advanceGroup() {
        this.currentGroup = [];
        this.duration = 0;
    }

    // ### _isRemainingTicksBeamable
    // look ahead, and see if we need to beam the tuplet now or if we
    // can combine current beam with future notes.
    _isRemainingTicksBeamable(tickmap,index) {
      if (this.duration >= this.beamBeats) {
        return false;
      }
      var acc = this.duration;
      for (var i = index + 1;i < tickmap.deltaMap.length; ++i) {
        acc += tickmap.deltaMap[i]
        if (acc === this.beamBeats) {
          return true;
        }
        if (acc > this.beamBeats) {
          return false;
        }
      }
      return false;
    }
    beamNote(tickmap, index, note, accidentalMap) {
        this.beamBeats = note.beamBeats;

        this.duration += tickmap.deltaMap[index];

        // beam tuplets
        if (note.isTuplet) {
            var tuplet = this.measure.getTupletForNote(note);
            var ult = tuplet.notes[tuplet.notes.length - 1];
            var first = tuplet.notes[0];

            if (first.endBeam) {
                this._advanceGroup();
                return note;
            }

            // is this beamable length-wise
            var vexDuration = smoMusic.closestVexDuration(note.tickCount);
            var stemTicks = VF.durationToTicks.durations[vexDuration];
            if (stemTicks < 4096) {
                this.currentGroup.push(note);
            }
            // Ultimate note in tuplet
            if (ult.attrs.id === note.attrs.id && !this._isRemainingTicksBeamable(tickmap,index)) {
                this._completeGroup(tickmap.voice);
                this._advanceGroup();
            }
            return note;
        }

        // don't beam > 1/4 note in 4/4 time
        if (tickmap.deltaMap[index] >= 4096) {
			this._completeGroup(tickmap.voice);
            this._advanceGroup();
            return note;
        }

        this.currentGroup.push(note);
        if (note.endBeam) {
            this._completeGroup(tickmap.voice);
            this._advanceGroup();
        }

        if (this.duration == this.beamBeats) {
            this._completeGroup(tickmap.voice);
            this._advanceGroup();
            return note;
        }

        // If this does not align on a beat, don't beam it
        if (this.duration > this.beamBeats) {
            this._advanceGroup()
            return note;
        }
    }
}
;VF = Vex.Flow;
Vex.Xform = (typeof(Vex.Xform) == 'undefined' ? {}
     : Vex.Xform);
VX = Vex.Xform;


class SmoDuration {
    static doubleDurationNonTuplet(selection) {
        var note = selection.note;
		var measure = selection.measure;
        var selector = selection.selector;
        var notes = measure.voices[selector.voice].notes;
		var tuplet = measure.getTupletForNote(note);
        var i;
        var nticks = note.tickCount * 2;
        var replNote = SmoNote.cloneWithDuration(note,nticks);
        var ticksUsed = note.tickCount;
        var newNotes = [];
        for (i = 0;i < selector.tick;++i) {
            newNotes.push(notes[i]);
        }
        for (i = selector.tick + 1;i < notes.length;++i) {
            var nnote = notes[i];
            ticksUsed += nnote.tickCount;
            if (ticksUsed >= nticks) {
                break;
            }
        }
        var remainder = ticksUsed - nticks;
        if (remainder < 0) {
            return;
        }
        newNotes.push(replNote);
        if (remainder > 0) {
            var lmap = smoMusic.gcdMap(remainder);
            lmap.forEach((duration) => {
                newNotes.push(SmoNote.cloneWithDuration(note,duration));
            });
        }

        for (i = i + 1;i<notes.length;++i) {
            newNotes.push(notes[i]);
        }
        measure.voices[selector.voice].notes = newNotes;
    }

    static doubleDurationTuplet(selection) {
        var notes = selection.measure.voices[selection.selector.voice].notes;
        var tuplet = selection.measure.getTupletForNote(selection.note);
        var measure = selection.measure
        var startIndex = selection.selector.tick - tuplet.startIndex;
        var tupletIndex = measure.tupletIndex(tuplet);

        var startLength = tuplet.notes.length;
        tuplet.combine(startIndex,startIndex + 1);
        if (tuplet.notes.length >= startLength) {
            return;
        }
        var newNotes = [];
        var i;

        for (i = 0;i < tuplet.startIndex;++i) {
            newNotes.push(notes[i]);
        }
        tuplet.notes.forEach((note) => {
            newNotes.push(note);
        });
        for (i = i+tuplet.notes.length+1;i<notes.length;++i) {
            newNotes.push(notes[i]);
        }
        measure.voices[selection.selector.voice].notes=newNotes;
    }
}
// this file contains utilities that change the duration of notes in a measure.

// ## SmoTickTransformer
//  Base class for duration transformations.  I call them transformations because this can
//  create and delete notes, as opposed to modifiers which act on existing notes.
class SmoTickTransformer {
    constructor(measure, actors, voiceIndex) {
        this.notes = measure.voices[voiceIndex].notes;
        this.measure = measure;
        this.voice = typeof(voiceIndex) === 'number' ?  voiceIndex : 0;
        this.vxNotes = [];
        this.actors = actors ? actors : [];
        this.keySignature = 'C';
        this.accidentalMap = [];
    }
    static nullActor(note) {
        return note;
    }
	// ## applyTransform
	// create a transform with the given actors and run it against the supplied measure
	static applyTransform(measure,actors,voiceIndex) {
		var actAr = (Array.isArray(actors)) ? actors : [actors];
		measure.clearBeamGroups();
        var transformer = new SmoTickTransformer(measure, actAr,voiceIndex);
        transformer.run();
        var vix = measure.getActiveVoice();
        measure.voices[vix].notes = transformer.notes;
	}
    // ## transformNote
    // call the actors for each note, and put the result in the note array.
    // The note from the original array is copied and sent to each actor.
    //
    // Because the resulting array can have a different number of notes than the existing
    // array, the actors communicate with the transformer in the following, jquery-ish
    // but somewhat unintuitive way:
    //
    // 1. if the actor returns null, the next actor is called and the results of that actor are used
    // 2. if all the actors return null, the copy is used.
    // 3. if a note object is returned, that is used for the current tick and no more actors are called.
    // 4. if an array of notes is returned, it is concatenated to the existing note array and no more actors are called.
    //     Note that *return note;* and *return [note];* produce the same result.
    // 5. if an empty array [] is returned, that copy is not added to the result.  The note is effectively deleted.
    transformTick(tickmap, index,note) {
        var self = this;

        for (var i = 0; i < this.actors.length; ++i) {
			var actor=this.actors[i];
            var newNote = actor.transformTick(note, tickmap, index);
            if (newNote == null) {
				this.vxNotes.push(note); // no change
                continue;
            }
            if (Array.isArray(newNote)) {
                if (newNote.length === 0) {
                    return;
                }
                this.vxNotes = this.vxNotes.concat(newNote);
                return;
            }
            this.vxNotes.push(newNote);
            return;
        }
    }

    run() {
        var self = this;
        var tickmap = this.measure.tickmapForVoice(this.voice);
        for (var i = 0;i < tickmap.durationMap.length;++i) {
            this.transformTick(tickmap,i,this.measure.voices[this.voice].notes[i]);
        }
        this.notes = this.vxNotes;
        return this.vxNotes;
    }
}

// ## A note transformer is just a function that modifies a note in some way.
// Any number of transformers can be applied to a note.
class TickTransformBase {
    constructor() {}
    transformTick(note, tickmap, index) {
        return note;
    }
}
// ## VxContractActor
// Contract the duration of a note, filling in the space with another note
// or rest.
//
class SmoContractNoteActor extends TickTransformBase {
    constructor(params) {
        super();
        Vex.Merge(this, params);
    }
    transformTick(note, tickmap, index) {
        if (index == this.startIndex) {
            var notes = [];
            var noteCount = Math.floor(note.ticks.numerator / this.newTicks);
            var notes = [];
			var remainder = note.ticks.numerator;
            /**
             *  Replace 1 note with noteCOunt notes of newTIcks duration
             *      old map:
             *     d  .  d  .  .
             *     new map:
             *     d  d  d  .  .
             */
            for (var i = 0; i < noteCount; ++i) {
                notes.push(new SmoNote({
                        clef: note.clef,
                        pitches: JSON.parse(JSON.stringify(note.pitches)),
                        ticks: {numerator:this.newTicks,denominator:1,remainder:0},
                        beamBeats:note.beamBeats
                    }));
				remainder = remainder - this.newTicks;
            }

            // make sure remnainder is not too short
			if (remainder > 0) {
                if (remainder < 128) {
                    return null;
                }
				notes.push(new SmoNote({
                        clef: note.clef,
                        pitches: JSON.parse(JSON.stringify(note.pitches)),
                        ticks: {numerator:remainder,denominator:1,remainder:0},
                        beamBeats:note.beamBeats
                    }));
			}
            return notes;
        }

        return null;
    }
}

// ## VxStretchTupletActor
// Stretch a note in a tuplet, removing or shortening other notes in the tuplet
// ## Parameters:
//   {changeIndex:changeIndex, multiplier:multiplier,measure:measure}
//
class SmoStretchTupletActor extends TickTransformBase {
    constructor(params) {
        super();
        Vex.Merge(this, params);
        this.tuplet = this.measure.getTupletForNote(this.measure.notes[this.changeIndex]);
        this.oldLength = this.tuplet.notes.length;
        this.tupletIndex = this.measure.tupletIndex(this.tuplet);

        this.tuplet.combine(this.startIndex, this.endIndex);
        this.durationMap = this.tuplet.durationMap;
    }
    transformTick(note, tickmap,index) {

        /*
        ## Strategy:
        Before A, after C, leave alone
        At A, send all notes of the tuplet
        Between A+1 and C, return empty array for removed note

        5
        ---------
        | | | | |
        n n n n n
        A | B | C
         */

        if (index < this.tupletIndex)
            return note;
        if (index >= this.tupletIndex + this.oldLength)
            return note;
        if (index === this.tupletIndex) {
            return this.tuplet.notes;
        }
        return [];

    }

}

// ## VxContractActor
// Contract the duration of a note in a tuplet by duplicate
// notes of fractional length
//
class SmoContractTupletActor extends TickTransformBase {
    constructor(params) {
        super();
        Vex.Merge(this, params);
        this.tuplet = this.measure.getTupletForNote(this.measure.voices[this.voice].notes[this.changeIndex]);
        this.oldLength = this.tuplet.notes.length;
        this.tupletIndex = this.measure.tupletIndex(this.tuplet);
        this.splitIndex = this.changeIndex - this.tupletIndex;
        this.tuplet.split(this.splitIndex);
    }
    transformTick(note, tickmap, index, accidentalMap) {
        if (index < this.tupletIndex)
            return note;
        if (index >= this.tupletIndex + this.oldLength)
            return note;
        if (index == this.changeIndex) {
            return this.tuplet.notes;
        }
        return [];
    }
}

// ## VxUnmakeTupletActor
// Turn a tuplet into a non-tuplet of the same length
// ## Parameters:
// startIndex: start index of tuplet
// endIndex: end index of tuplet
// measure: Smo measure that the tuplet is contained in.
class SmoUnmakeTupletActor extends TickTransformBase {
    constructor(parameters) {
        super();
        Vex.Merge(this, parameters);
    }
    transformTick(note, tickmap, index, accidentalMap) {
        if (index < this.startIndex || index > this.endIndex) {
            return null;
        }
        if (index == this.startIndex) {
            var tuplet = this.measure.getTupletForNote(note);
            var ticks = tuplet.totalTicks;
            var nn = SmoNote.cloneWithDuration(note, {numerator:ticks,denominator:1,remainder:0});
            nn.tuplet = {};
            this.measure.removeTupletForNote(note);
            return [nn];
        }
        return [];
    }
}

// ## VxUnmakeTupletActor
// Turn a tuplet into a non-tuplet of the same length
// parameters:
//  {tickmap:tickmap,ticks:ticks,
class SmoMakeTupletActor extends TickTransformBase {
    constructor(params) {
        super();
        Vex.Merge(this, params);
        this.measure = this.selection.measure;
        this.durationMap = [];
        var sum = 0.0; // 819.2
        for (var i = 0; i < this.numNotes; ++i) {
            this.durationMap.push(1.0);
            sum += 1.0;
        }
		/*
		var stemValue = this.totalTicks / this.numNotes;
        var stemTicks = 8192;

        // The stem value is the type on the non-tuplet note, e.g. 1/8 note
        // for a triplet.
        while (stemValue < stemTicks) {
            stemTicks = stemTicks / 2;
        }

        this.stemTicks = stemTicks * 2;
		*/
        this.stemTicks = SmoTuplet.calculateStemTicks(this.totalTicks ,this.numNotes);

        this.rangeToSkip = this._rangeToSkip();

        // special case - is this right?  this is needed for tuplets in 6/8
        /* if (this.rangeToSkip[1] > this.rangeToSkip[0]) {
            this.stemTicks = stemTicks;
        } else {
            this.stemTicks = stemTicks * 2;
        }  */

        this.vexDuration = smoMusic.ticksToDuration[this.stemTicks];
        this.tuplet = [];
        // skip notes in the original array if we are taking up
        // multiple notes

    }
    _rangeToSkip() {
        var ticks = this.selection.measure.tickmapForVoice(this.selection.selector.voice);
        var accum = 0;
        var rv = [];
        rv.push(this.index);
        for (var i = 0; i < ticks.deltaMap.length; ++i) {
            if (i >= this.index) {
                accum += ticks.deltaMap[i];
            }
            if (accum >= this.totalTicks) {
                rv.push(i);
                break;
            }
        }
        return rv;
    }
    transformTick(note, tickmap, index) {
        // if our tuplet replaces this note, make sure we make it go away.
        if (index > this.index && index <= this.rangeToSkip[1]) {
            return [];
        }
        if (index != this.index) {
            return null;
        }
        for (var i = 0; i < this.numNotes; ++i) {
            note = SmoNote.cloneWithDuration(note, {numerator:this.stemTicks,denominator:1,remainder:0});

			// Don't clone modifiers, except for first one.
			note.textModifiers = i===0 ? note.textModifiers : [];

            this.tuplet.push(note);
        }
        var tuplet = new SmoTuplet({
                notes: this.tuplet,
                stemTicks: this.stemTicks,
                totalTicks: this.totalTicks,
                ratioed: false,
                bracketed: true,
                startIndex: index,
                durationMap: this.durationMap,
                location: 1,
                voice:tickmap.voice
            });
        this.measure.tuplets.push(tuplet);
        return this.tuplet;
    }
}

class SmoStretchNoteActor extends TickTransformBase {
  constructor(parameters) {
    super();
    Vex.Merge(this, parameters);
    this.startTick = this.tickmap.durationMap[this.startIndex];
		var currentTicks = this.tickmap.deltaMap[this.startIndex];

    var endTick = this.tickmap.durationMap[this.startIndex] + this.newTicks;
    this.divisor = -1;
    this.durationMap = [];
    this.skipFromStart = this.startIndex + 1;
    this.skipFromEnd = this.startIndex + 1;
    this.durationMap.push(this.newTicks);

    var mapIx = this.tickmap.durationMap.indexOf(endTick);

    var remaining = this.tickmap.deltaMap.slice(this.startIndex, this.tickmap.durationMap.length).reduce((accum, x) => x + accum);
    if (remaining === this.newTicks) {
      mapIx = this.tickmap.deltaMap.length;
    }

    // If there is no tickable at the end point, try to split the next note
    /**
     *      old map:
     *     d  . d  .
     *     split map:
     *     d  .  d  d
     *     new map:
     *     d .   .  d
     */
    if (mapIx < 0) {
      var npos = this.tickmap.durationMap[this.startIndex + 1];
      var ndelta = this.tickmap.deltaMap[this.startIndex + 1];
			var needed = this.newTicks - currentTicks;
			var exp = ndelta/needed;

			// Next tick does not divide evenly into this, or next tick is shorter than this
			if (Math.round(ndelta/exp)-ndelta/exp != 0 || ndelta < 256) {
				this.durationMap = [];
			}
      else if (ndelta / exp + this.startTick + this.newTicks <= this.tickmap.totalDuration) {
        this.durationMap.push(ndelta - (ndelta / exp));
      } else {
        // there is no way to do this...
  			this.durationMap = [];
      }
    } else {
      // If this note now takes up the space of other notes, remove those notes
      for (var i = this.startIndex + 1; i < mapIx; ++i) {
          this.durationMap.push(0);
      }
  }
    }
    transformTick(note, tickmap, index) {
        if (this.durationMap.length == 0) {
            return null;
        }
        if (index >= this.startIndex && index < this.startIndex + this.durationMap.length) {
            var mapIndex = index - this.startIndex;
            var ticks = this.durationMap[mapIndex];
            if (ticks == 0) {
                return [];
            }
            var vexDuration = smoMusic.ticksToDuration[ticks];
            var note = SmoNote.cloneWithDuration(note, {numerator:ticks,denominator:1,remainder:0});
            return [note];
        }
        return null;
    }
}
;/////////////////
// # selections.js
// Editing operations are performed on selections.  A selection can be different things, from a single pitch
// to many notes.  These classes standardize some standard selection operations.
//
//
// ## SmoSelector
// ## Description:
// There are 2 parts to a selection: the actual musical bits that are selected, and the
// indices that define what was selected.  This is the latter.  The actual object does not
// have any methods so there is no constructor.
class SmoSelector {
	// TODO:  tick in selector s/b tickIndex
	static sameNote(sel1, sel2) {
		return (sel1.staff == sel2.staff && sel1.measure == sel2.measure && sel1.voice == sel2.voice
			 && sel1.tick == sel2.tick);
	}
	static sameMeasure(sel1, sel2) {
		return (sel1.staff == sel2.staff && sel1.measure == sel2.measure);
	}

	static sameStaff(sel1, sel2) {
		return sel1.staff === sel2.staff;
	}

	// ## return true if sel1 > sel2.
	static gt(sel1, sel2) {
		// Note: voice is not considered b/c it's more of a vertical component
		return sel1.staff > sel2.staff ||
		(sel1.staff == sel2.staff && sel1.measure > sel2.measure) ||
		(sel1.staff == sel2.staff && sel1.measure == sel2.measure && sel1.tick > sel2.tick);
	}

	static eq(sel1, sel2) {
		return (sel1.staff == sel2.staff && sel1.measure == sel2.measure && sel1.tick == sel2.tick);
	}
	static neq(sel1,sel2) {
		return !(SmoSelector.eq(sel1,sel2));
	}

	static lt(sel1, sel2) {
		return SmoSelector.gt(sel2, sel1);
	}

	static gteq(sel1, sel2) {
		return SmoSelector.gt(sel1, sel2) || SmoSelector.eq(sel1, sel2);
	}
	static lteq(sel1, sel2) {
		return SmoSelector.lt(sel1, sel2) || SmoSelector.eq(sel1, sel2);
	}

    // ### getNoteKey
    // Get a key useful for a hash map of notes.
    static getNoteKey(selector) {
        return ''+selector.staff + '-' +selector.measure  + '-' + selector.voice + '-' + selector.tick;
    }

    static getMeasureKey(selector) {
        return ''+selector.staff + '-' +selector.measure;
    }

	// ## applyOffset
	// ### Description:
	// offset 'selector' the difference between src and target, return the result
	static applyOffset(src, target, selector) {
		var rv = JSON.parse(JSON.stringify(selector));
		rv.staff += target.staff - src.staff;
		rv.measure += target.measure - src.measure;
		rv.voice += target.voice - src.voice;
		rv.note += target.staff - src.staff;
		return rv;
	}

	// return true if testSel is contained in the selStart to selEnd range.
	static contains(testSel, selStart, selEnd) {
		var geStart =
			selStart.measure < testSel.measure ||
			(selStart.measure === testSel.measure && selStart.tick <= testSel.tick);
		var leEnd =
			selEnd.measure > testSel.measure ||
			(selEnd.measure === testSel.measure && testSel.tick <= selEnd.tick);

		return geStart && leEnd;
	}

	// create a hashmap key for a single note, used to organize modifiers
	static selectorNoteKey(selector) {
		return 'staff-' + selector.staff + '-measure-' + selector.measure + '-voice-' + selector.voice + '-tick-' + selector.tick;
	}
}

// ## SmoSelection
// ## Description:
// A selection is a selector and a set of references to musical elements, like measure etc.
// The staff and measure are always a part of the selection, and possible a voice and note,
// and one or more pitches.  Selections can also be made from the UI by clicking on an element
// or navigating to an element with the keyboard.
class SmoSelection {

	// ### measureSelection
	// A selection that does not contain a specific note
	static measureSelection(score, staffIndex, measureIndex) {
		staffIndex = staffIndex != null ? staffIndex : score.activeStaff;
		var selector = {
			staff: staffIndex,
			measure: measureIndex
		};
		if (score.staves.length <= staffIndex) {
			return null;
		}
		var staff = score.staves[staffIndex];
		if (staff.measures.length <= measureIndex) {
			return null;
		}
		var measure = staff.measures[measureIndex];

		return new SmoSelection
		({
			selector: selector,
			_staff: staff,
			_measure: measure,
			type: 'measure'
		});
	}

  static measuresInColumn(score,staffIndex) {
    var rv = [];
    for (var i = 0;i<score.staves.length;++i) {
      rv.push(SmoSelection.measureSelection(score,i,staffIndex));
    }
    return rv;
  }

	static noteFromSelection(score, selection) {
		return SmoSelection(score, selection.staffIndex, selection.measureIndex, selection.voiceIndex, selection.tickIndex);
	}

	// ### noteSelection
	// a selection that specifies a note in the score
	static noteSelection(score, staffIndex, measureIndex, voiceIndex, tickIndex) {
		staffIndex = staffIndex != null ? staffIndex : score.activeStaff;
		measureIndex = measureIndex ? measureIndex : 0;
		voiceIndex = voiceIndex ? voiceIndex : 0;
		var staff = score.staves[staffIndex];
    if (!staff) {
      return null;
    }
		var measure = staff.measures[measureIndex];
    if (!measure) {
      return null;
    }
    if (measure.voices.length <= voiceIndex) {
      return null;
    }
    if (measure.voices[voiceIndex].notes.length <= tickIndex) {
      return null;
    }
		var note = measure.voices[voiceIndex].notes[tickIndex];
		var selector = {
			staff: staffIndex,
			measure: measureIndex,
			voice: voiceIndex,
			tick: tickIndex
		};
		return new SmoSelection({
			selector: selector,
			_staff: staff,
			_measure: measure,
			_note: note,
			_pitches: [],
			type: 'note'
		});
	}

  static noteFromSelector(score,selector) {
    return SmoSelection.noteSelection(score,
      selector.staff,selector.measure,selector.voice,selector.tick);
  }

	// ### renderedNoteSelection
	// this is a special selection that we associated with all he rendered notes, so that we
	// can map from a place in the display to a place in the score.
	static renderedNoteSelection(score, nel, box) {
		var elementId = nel.getAttribute('id');
		for (var i = 0; i < score.staves.length; ++i) {
			var staff = score.staves[i];
			for (var j = 0; j < staff.measures.length; ++j) {
				var measure = staff.measures[j];
				for (var k = 0; k < measure.voices.length; ++k) {
					var voice = measure.voices[k];
					for (var m = 0; m < voice.notes.length; ++m) {
						var note = voice.notes[m];
						if (note.renderId === elementId) {
							var selector = {
								staff: i,
								measure: j,
								voice: k,
								tick: m,
								pitches: []
							};
							// var box = document.getElementById(nel.id).getBBox();
							var rv = new SmoSelection({
									selector: selector,
									_staff: staff,
									_measure: measure,
									_note: note,
									_pitches: [],
									box: box,
									type: 'rendered'
								});

							return rv;
						}
					}
				}
			}
		}
		return null;
	}

	static pitchSelection(score, staffIndex, measureIndex, voiceIndex, tickIndex, pitches) {
		staffIndex = staffIndex != null ? staffIndex : score.activeStaff;
		measureIndex = measureIndex ? measureIndex : 0;
		voiceIndex = voiceIndex ? voiceIndex : 0;
		var staff = score.staves[staffIndex];
		var measure = staff.measures[measureIndex];
		var note = measure.voices[voiceIndex].notes[tickIndex];
		pitches = pitches ? pitches : [];
		var pa = [];
		pitches.forEach((ix) => {
			pa.push(JSON.parse(JSON.stringify(note.pitches[ix])));
		});
		var selector = {
			staff: staffIndex,
			measure: measureIndex,
			voice: voiceIndex,
			tick: tickIndex,
			pitches: pitches
		};
		return new SmoSelection({
			selector: selector,
			_staff: staff,
			_measure: measure,
			_note: note,
			_pitches: pa,
			type: 'pitches'
		});
	}

	// ## nextNoteSelection
	// ## Description:
	// Return the next note in this measure, or the first note of the next measure, if it exists.
	static nextNoteSelection(score, staffIndex, measureIndex, voiceIndex, tickIndex) {
		var nextTick = tickIndex + 1;
		var nextMeasure = measureIndex + 1;
		var staff = score.staves[staffIndex];
		var measure = staff.measures[measureIndex];
		if (measure.voices[voiceIndex].notes.length > nextTick) {
			return SmoSelection.noteSelection(score, staffIndex, measureIndex, voiceIndex, nextTick);
		}
		if (staff.measures.length > nextMeasure) {
			return SmoSelection.noteSelection(score, staffIndex, nextMeasure, voiceIndex, 0);
		}
		return null;
	}

  static nextNoteSelectionFromSelector(score, selector) {
    return SmoSelection.nextNoteSelection(score, selector.staff, selector.measure, selector.voice, selector.tick);
  }
  static lastNoteSelectionFromSelector(score, selector) {
    return SmoSelection.lastNoteSelection(score, selector.staff, selector.measure, selector.voice, selector.tick);
  }

	// ### getMeasureList
	// Gets the list of measures in an array from the selections
	static getMeasureList(selections) {
		var rv = [];
		if (!selections.length) {
			return rv;
		}
        var cur = selections[0].selector.measure;
		for (var i=0;i<selections.length;++i) {
			var sel = selections[i];
			if (i == 0 ||
                 (sel.selector.measure != cur)) {
				rv.push({
                    selector:{
                        staff:sel.selector.staff,
                        measure:sel.selector.measure
                    },
                    staff:sel.staff,
                    measure:sel.measure
                    });
			}
            cur = sel.selector.measure;
		}
		return rv;
	}

	static lastNoteSelection(score, staffIndex, measureIndex, voiceIndex, tickIndex) {
		var lastTick = tickIndex - 1;
		var lastMeasure = measureIndex - 1;
		var staff = score.staves[staffIndex];
		var measure = staff.measures[measureIndex];
		if (tickIndex > 0) {
			return SmoSelection.noteSelection(score, staffIndex, measureIndex, voiceIndex, lastTick);
		}
		if (lastMeasure >= 0) {
			measure = staff.measures[lastMeasure];
            if (voiceIndex >= measure.voices.length) {
                return null;
            }
			var noteIndex = measure.voices[voiceIndex].notes.length - 1;
			return SmoSelection.noteSelection(score, staffIndex, lastMeasure, voiceIndex, noteIndex);
		}
		return SmoSelection.noteSelection(score, staffIndex, 0, 0,0);
	}

	// ### selectionsSameMeasure
	// Return true if the selections are all in the same measure.  Used to determine what
	// type of undo we need.
	static selectionsSameMeasure(selections) {
		if (selections.length < 2) {
			return true;
		}
		var sel1 = selections[0].selector;
		for (var i = 1; i < selections.length; ++i) {
			if (!SmoSelector.sameMeasure(sel1, selections[i].selector)) {
				return false;
			}
		}
		return true;
	}

	static selectionsSameStaff(selections) {
		if (selections.length < 2) {
			return true;
		}
		var sel1 = selections[0].selector;
		for (var i = 1; i < selections.length; ++i) {
			if (!SmoSelector.sameStaff(sel1, selections[i].selector)) {
				return false;
			}
		}
		return true;
	}

	constructor(params) {
		this.selector = {
			staff: 0,
			measure: 0,
			voice: 0,
			note: 0,
			pitches: []
		}
		this._staff = null;
		this._measure = null;
		this._note = null;
		this._pitches = [];
		this._box = svgHelpers.pointBox(0, 0);

		this.selectionGroup = {
			id: VF.Element.newID(),
			type: 'SmoSelection'
		};
		Vex.Merge(this, params);
	}

	get staff() {
		return this._staff;
	}
	get measure() {
		return this._measure;
	}

	get note() {
		return this._note;
	}
	get pitches() {
		if (this._pitches.length) {
			return this._pitches;
		} else if (this._note) {
			this._pitches = JSON.parse(JSON.stringify(this.note.pitches));
			return this._pitches;
		}
		return [];
	}
}
;
// An operation works on a selection or set of selections to edit the music
class SmoOperation {

   static setForcePageBreak(score,selection,value) {
       score.staves.forEach((staff) => {
          staff.measures[selection.selector.measure].setForcePageBreak(value);
       });
   }
   static setForceSystemBreak(score,selection,value) {
       score.staves.forEach((staff) => {
          staff.measures[selection.selector.measure].setForceSystemBreak(value);
       });
   }

  static addKeySignature(score, selection, keySignature) {
  score.addKeySignature(selection.selector.measure, keySignature);
  }

  static deleteMeasure(score, selection) {
  var measureIndex = selection.selector.measure;

  score.deleteMeasure(measureIndex);
  }

  static addPickupMeasure(score,duration) {
    score.addPickupMeasure(0,duration);
  }

  static addConnectorDown(score,selections,parameters) {
    var msel = SmoSelection.getMeasureList(selections);
    var len = msel.length - 1;
    if (score.staves.length <= msel[len].selector.staff) {
      return;
    }
    var existing = score.getSystemGroupForStaff(msel[0]);
    if (existing && existing.endSelector.staff < selections[len].selector.staff) {
      existing.endSelector.staff = msel[len].selector.staff+1;
    } else {
      parameters.startSelector = {staff:msel[0].selector.staff,measure:msel[0].selector.measure};
      parameters.endSelector = {staff:msel[len].selector.staff + 1,measure:msel[len].selector.measure};
      score.addOrReplaceSystemGroup(new SmoSystemGroup(parameters));
    }
    msel.forEach((mm) => {
      mm.measure.setChanged();
    });
  }

  static convertToPickupMeasure(score,duration) {
      score.convertToPickupMeasure(0,duration);
  }
  static toggleBeamGroup(noteSelection) {
  noteSelection.measure.setChanged();
  noteSelection.note.endBeam = !(noteSelection.note.endBeam);
  }

  static padMeasureLeft(selection,padding) {
    selection.measure.padLeft = padding;
    selection.measure.setChanged();
  }

    static setActiveVoice(score,voiceIx) {
        score.staves.forEach((staff) => {
            staff.measures.forEach((measure) => {
                measure.setActiveVoice(voiceIx);
            });
        });
    }

    static addRemoveMicrotone(ignore,selections,tone) {
        selections.forEach((sel) => {
            if (sel.note.tones.findIndex((tt) => tt.tone==tone.tone
              && tt.pitch==tone.pitch) >= 0) {
                  sel.note.removeMicrotone(tone);
              } else {
                  sel.note.addMicrotone(tone);
              }
              sel.measure.setChanged();
        });
    }

    static moveStaffUpDown(score,selection,index) {
        var index1 = selection.selector.staff;
        var index2 = selection.selector.staff + index;
        if (index2 < score.staves.length && index2 >= 0) {
            score.swapStaves(index1,index2);
        }
    }

    static depopulateVoice(selection,voiceIx) {
        var ix = 0;
        var voices = [];
        var measure = selection.measure;
        measure.voices.forEach((voice) => {
            if (measure.voices.length <2 || ix != voiceIx)  {
                voices.push(voice);
            }
            ix += 1;
        });
        measure.voices = voices;

        if (measure.getActiveVoice() >= measure.voices.length) {
            measure.setActiveVoice(0);
        }
    }

    static populateVoice(selection,voiceIx) {
        selection.measure.populateVoice(voiceIx);
        selection.measure.setChanged();
    }

    static setTimeSignature(score,selections,timeSignature) {
        var selectors = [];
        selections.forEach((selection) => {
            for (var i=0;i<score.staves.length;++i) {
                var measureSel = {
                    staff: i,
                    measure: selection.selector.measure
                };
                selectors.push(measureSel);
            }
        });
        var tsTicks = smoMusic.timeSignatureToTicks(timeSignature);

        selectors.forEach((selector) => {
            var params={};
            var attrs = SmoMeasure.defaultAttributes.filter((aa) => aa != 'timeSignature');
            var psel =  SmoSelection.measureSelection(score,selector.staff,selector.measure);
            if (!psel['measure']) {
                console.log('Error: score has changed in time signature change');
            } else {
                var proto = SmoSelection.measureSelection(score,selector.staff,selector.measure).measure;
                smoSerialize.serializedMerge(attrs,proto,params);
                params.timeSignature = timeSignature;
                var nm = SmoMeasure.getDefaultMeasure(params);
                var spareNotes = SmoMeasure.getDefaultNotes(params);
                var ticks = 0;
                var voices = [];
                proto.voices.forEach((voice) => {
                    var nvoice=[];
                    for (var i=0;i<voice.notes.length;++i) {
                        var pnote = voice.notes[i];
                        var nnote = SmoNote.deserialize(pnote.serialize());
                        if (ticks + pnote.tickCount <= tsTicks) {
                            nnote.ticks = JSON.parse(JSON.stringify(pnote.ticks))
                            nvoice.push(nnote);
                            ticks += nnote.tickCount;
                        } else {
                            var remain = (ticks + pnote.tickCount)-tsTicks;
                            nnote.ticks = {numerator:remain,denominator:1,remainder:0};
                            nvoice.push(nnote);
                            ticks += nnote.tickCount;
                        }
                        if (ticks >= tsTicks) {
                            break;
                        }
                    }
                    if (ticks < tsTicks) {
                        var adjNote = SmoNote.cloneWithDuration(nvoice[nvoice.length - 1],{numerator:tsTicks - ticks,denominator:1,remainder:0});
                        nvoice.push(adjNote);
                    }
                    voices.push({notes:nvoice});

                });
            }
            nm.voices=voices;
            score.replaceMeasure(selector,nm);
        });
    }

  static batchSelectionOperation(score, selections, operation) {
  var measureTicks = [];
  selections.forEach((selection) => {
  var measureSel = {
  staff: selection.selector.staff,
  measure: selection.selector.measure,
  voice: selection.selector.voice
  };
  selection.measure.setChanged();
  if (!measureTicks[measureSel]) {
  var tm = selection.measure.tickmapForVoice(selection.selector.voice);
  var tickOffset = tm.durationMap[selection.selector.tick];
  var selector = JSON.parse(JSON.stringify(selection.selector));
  measureTicks.push({
  selector: selector,
  tickOffset: tickOffset
  });
  }
  });
  measureTicks.forEach((measureTick) => {
  var selection = SmoSelection.measureSelection(score, measureTick.selector.staff, measureTick.selector.measure);
  var tickmap = selection.measure.tickmapForVoice(measureTick.selector.voice);
  var ix = tickmap.durationMap.indexOf(measureTick.tickOffset);
  if (ix >= 0) {
  var nsel = SmoSelection.noteSelection(score, measureTick.selector.staff, measureTick.selector.measure,
  measureTick.selector.voice, ix);
  SmoOperation[operation](nsel);
  }
  });
  }
  // ## doubleDuration
  // ## Description
  // double the duration of a note in a measure, at the expense of the following
  // note, if possible.  Works on tuplets also.
  static doubleDuration(selection) {
  var note = selection.note;
  var measure = selection.measure;
        var selector = selection.selector;
        var notes = measure.voices[selector.voice].notes;
  var tuplet = measure.getTupletForNote(note);
  if (!tuplet) {
            SmoDuration.doubleDurationNonTuplet(selection);

  } else {
            SmoDuration.doubleDurationTuplet(selection);
  }
  selection.measure.setChanged();
  return true;
  }

  // ## halveDuration
  // ## Description
  // Replace the note with 2 notes of 1/2 duration, if possible
  // Works on tuplets also.
  static halveDuration(selection) {
  var note = selection.note;
  var measure = selection.measure;
  var tuplet = measure.getTupletForNote(note);
  var divisor = 2;
  if (measure.numBeats % 3 === 0 && selection.note.tickCount === 6144) {
  // special behavior, if this is dotted 1/4 in 6/8, split to 3
  divisor = 3;
  }
  if (!tuplet) {
  var nticks = note.tickCount / divisor;
  if (!smoMusic.ticksToDuration[nticks]) {
  return;
  }
  var actor = new SmoContractNoteActor({
  startIndex: selection.selector.tick,
  tickmap: measure.tickmapForVoice(selection.selector.voice),
  newTicks: nticks
  });
  SmoTickTransformer.applyTransform(measure, actor,selection.selector.voice);
            smoBeamerFactory.applyBeams(measure);

  } else {
  var startIndex = measure.tupletIndex(tuplet) + tuplet.getIndexOfNote(note);
  var actor = new SmoContractTupletActor({
  changeIndex: startIndex,
  measure: measure,
                    voice:selection.selector.voice
  });
  SmoTickTransformer.applyTransform(measure, actor,selection.selector.voice);
  }
  selection.measure.setChanged();
  }

  // ## makeTuplet
  // ## Description
  // Makes a non-tuplet into a tuplet of equal value.
  static makeTuplet(selection, numNotes) {
  var note = selection.note;
  var measure = selection.measure;

  if (measure.getTupletForNote(note))
  return;
  var nticks = note.tickCount;

  var actor = new SmoMakeTupletActor({
  index: selection.selector.tick,
  totalTicks: nticks,
  numNotes: numNotes,
  selection: selection
  });
  SmoTickTransformer.applyTransform(measure, actor,selection.selector.voice);
  selection.measure.setChanged();

  return true;
  }

    static removeStaffModifier(selection,modifier) {
        selection.staff.removeStaffModifier(modifier);
    }

  static makeRest(selection) {
  selection.measure.setChanged();
  selection.note.makeRest();
  }
  static makeNote(selection) {
  selection.measure.setChanged();
  selection.note.makeNote();
  }
  static setNoteHead(selections,noteHead) {
    selections.forEach((selection) => {
      selection.note.setNoteHead(noteHead);
    });
  }

  static addGraceNote(selection,offset,g) {
      selection.note.addGraceNote(offset,g);
      selection.measure.changed= true;
  }


  static removeGraceNote(selection,offset) {
    selection.note.removeGraceNote(offset);
    selection.measure.changed= true;
  }

  static doubleGraceNoteDuration(selection,modifiers) {
    if (!Array.isArray(modifiers)) {
      modifiers=[modifiers];
    }
    modifiers.forEach((mm) => {
      mm.ticks.numerator = mm.ticks.numerator * 2;
    });
    selection.measure.changed = true;
  }
  static halveGraceNoteDuration(selection,modifiers) {
    if (!Array.isArray(modifiers)) {
        modifiers=[modifiers];
    }
    modifiers.forEach((mm) => {
        mm.ticks.numerator = mm.ticks.numerator / 2;
    });
    selection.measure.changed = true;
  }

    static toggleGraceNoteCourtesy(selection,modifiers) {
        if (!Array.isArray(modifiers)) {
            modifiers=[modifiers];
        }
        modifiers.forEach((mm) => {
            mm.modifiers.pitches.forEach((pitch)=> {
                pitch.cautionary = pitch.cautionary ? false : true;
            });
        });
    }

  static transposeGraceNotes(selection,modifiers,offset) {
    if (!Array.isArray(modifiers)) {
      modifiers=[modifiers];
    }
    modifiers.forEach((mm) => {
      var par = [];
      mm.pitches.forEach((pitch)=> {
          par.push(par.length);
      });
      SmoNote._transpose(mm,par, offset, selection.measure.keySignature);
    });
  }

  static slashGraceNotes(selections) {
    if (!Array.isArray(selections)) {
      selections=[selections];
    }
    selections.forEach((mm) => {
      if (mm.modifier && mm.modifier.ctor === 'SmoGraceNote') {
        mm.modifier.slash = !mm.modifier.slash;
      }
    });
  }


  // ## unmakeTuplet
  // ## Description
  // Makes a tuplet into a single with the duration of the whole tuplet
  static unmakeTuplet(selection) {
  var note = selection.note;
  var measure = selection.measure;
  if (!measure.getTupletForNote(note))
  return;
  var tuplet = measure.getTupletForNote(note);
  if (tuplet === null)
  return;
  var startIndex = measure.tupletIndex(tuplet);
  var endIndex = tuplet.notes.length + startIndex - 1;

  var actor = new SmoUnmakeTupletActor({
  startIndex: startIndex,
  endIndex: endIndex,
  measure: measure
  });
  SmoTickTransformer.applyTransform(measure, actor,selection.selector.voice);
  measure.setChanged();
  return true;
  }

  // ## dotDuration
  // ## Description
  // Add a dot to a note, if possible, and make the note ahead of it shorter
  // to compensate.
  static dotDuration(selection) {

  var note = selection.note;
  var measure = selection.measure;
  var nticks = smoMusic.getNextDottedLevel(note.tickCount);
  if (nticks == note.tickCount) {
  return;
  }

        // Don't dot if the thing on the right of the . is too small
        var dotCount = smoMusic.smoTicksToVexDots(nticks);
        var multiplier = Math.pow(2,dotCount);
        var baseDot = VF.durationToTicks(smoMusic.closestVexDuration(nticks))/(multiplier*2);
        if (baseDot <= 128) {
            return;
        }

  // If this is the ultimate note in the measure, we can't increase the length
  if (selection.selector.tick + 1 === selection.measure.voices[selection.selector.voice].notes.length) {
  return;
  }
  if (selection.measure.voices[selection.selector.voice].notes[selection.selector.tick + 1].tickCount > selection.note.tickCount) {
  console.log('too long');
  return;
  }
  // is dot too short?
  if (!smoMusic.ticksToDuration[selection.measure.voices[selection.selector.voice].notes[selection.selector.tick + 1].tickCount/2]) {
  return;
  }
  var actor = new SmoStretchNoteActor({
  startIndex: selection.selector.tick,
  tickmap: measure.tickmapForVoice(selection.selector.voice),
  newTicks: nticks
  });
  SmoTickTransformer.applyTransform(measure, actor,selection.selector.voice);
  measure.setChanged();
  return true;
  }

  // ## undotDuration
  // ## Description
  // Add the value of the last dot to the note, increasing length and
  // reducing the number of dots.
  static undotDuration(selection) {
  var note = selection.note;
  var measure = selection.measure;
  var nticks = smoMusic.getPreviousDottedLevel(note.tickCount);
  if (nticks == note.tickCount) {
  return;
  }
  var actor = new SmoContractNoteActor({
  startIndex: selection.selector.tick,
  tickmap: measure.tickmapForVoice(selection.selector.voice),
  newTicks: nticks
  });
  SmoTickTransformer.applyTransform(measure, actor,selection.selector.voice);
  selection.measure.setChanged();
  return true;
  }

  // ## transpose
  // ## Description
  // Transpose the selected note, trying to find a key-signature friendly value
  static transpose(selection, offset) {
  var measure = selection.measure;
  var note = selection.note;
  if (measure && note) {
      var pitchar = [];
      var pitchIx = 0;
      var voiceIx = 0;
      var accidentalMap = {};
      var activeTm = measure.tickmapForVoice(measure.getActiveVoice());
      var targetDuration = activeTm.durationMap[selection.selector.tick];

      note.pitches.forEach((opitch) => {
        // Only translate selected pitches
        var shouldXpose = selection.selector.pitches.length == 0 ||
          selection.selector.pitches.indexOf(pitchIx) >= 0;

        // Translate the pitch, ignoring enharmonic
        var trans =  shouldXpose ? smoMusic.getKeyOffset(opitch,offset)
          : JSON.parse(JSON.stringify(opitch));
        trans = smoMusic.getEnharmonicInKey(trans,measure.keySignature);
        if (!trans.accidental) {
          trans.accidental = 'n';
        }
        var transInt = smoMusic.smoPitchToInt(trans);

        // Look through the earlier notes in the measure and try
        // to find an equivalent note, and convert it if it exists.
        var voiceIx = 0;
        measure.voices.forEach((voice) => {
          for (var i = 0;i<selection.selector.tick
            && i < voice.notes.length;++i)  {
            var prevNote = voice.notes[i];
            prevNote.pitches.forEach((prevPitch) => {
                var prevInt = smoMusic.smoPitchToInt(prevPitch);
                if (prevInt == transInt) {
                  trans = JSON.parse(JSON.stringify(prevPitch));
                }
             });
           }
          });
          pitchar.push(trans);
          pitchIx += 1;
      });
      note.pitches = pitchar;
  measure.setChanged();
  return true;
  }
  return false;
  }

  // ## setPitch
  // ## Description:
  // pitches can be either an array, a single pitch, or a letter.  In the latter case,
  // the letter value appropriate for the key signature is used, e.g. c in A major becomes
  // c#
  static setPitch(selection, pitches) {
  var measure = selection.measure;
  var note = selection.note;
    selection.note.makeNote();
  measure.setChanged();
  // TODO allow hint for octave
  var octave = note.pitches[0].octave;
  note.pitches = [];
  if (!Array.isArray(pitches)) {
  pitches = [pitches];
  }
    var earlierAccidental = (pitch) => {
      selection.measure.voices.forEach((voice) => {
        for (var i=0;i<selection.selector.tick
           && i < voice.notes.length;++i) {
          var prevNote = voice.notes[i];
          if (prevNote == null || prevNote.pitches == null) {
            console.log('this will die null');
          }
          prevNote.pitches.forEach((prevPitch) => {
            if (prevNote.noteType == 'n' && prevPitch.letter == pitch.letter) {
              pitch.accidental = prevPitch.accidental;
            }
          });
        }
      });
    }
  pitches.forEach((pitch) => {
  var letter = pitch;
  if (typeof(pitch) === 'string') {
  var letter = smoMusic.getKeySignatureKey(pitch[0], measure.keySignature);
  pitch = {
  letter: letter[0],
  accidental: letter.length > 1 ? letter.substring(1) : '',
  octave: octave
  };
  }

      earlierAccidental(pitch);
  note.pitches.push(pitch);
  });
  return true;
  }

  // ## addPitch
  // add a pitch to a note chord, avoiding duplicates.
  static addPitch(selection, pitches) {
  var toAdd = [];
  selection.note.makeNote();
  pitches.forEach((pitch) => {
  var found = false;
  toAdd.forEach((np) => {
  if (np.accidental === pitch.accidental && np.letter === pitch.letter && np.octave === pitch.octave) {
  found = true;
  }
  });
  if (!found) {
  toAdd.push(pitch);
  }
  });
  toAdd.sort(function (a, b) {
  return smoMusic.smoPitchToInt(a) -
  smoMusic.smoPitchToInt(b);
  });
  selection.note.pitches = JSON.parse(JSON.stringify(toAdd));
  selection.measure.setChanged();
  }

  static toggleCourtesyAccidental(selection) {
  var toBe = false;
  var i = 0;
  if (!selection.selector['pitches'] || selection.selector.pitches.length === 0) {
  var ps = [];
  selection.note.pitches.forEach((pitch) => {
  var p = JSON.parse(JSON.stringify(pitch));
  ps.push(p);
  p.cautionary = !(pitch.cautionary);
  });
  selection.note.pitches = ps;
  } else {
  toBe = !(selection.note.pitches[selection.selector.pitches[0]].cautionary);
  }

  SmoOperation.courtesyAccidental(selection, toBe);
  selection.measure.setChanged();
  }

  static courtesyAccidental(pitchSelection, toBe) {
  pitchSelection.selector.pitches.forEach((pitchIx) => {
  pitchSelection.note.pitches[pitchIx].cautionary = toBe;
  });
  pitchSelection.measure.setChanged();
  }

  static toggleEnharmonic(pitchSelection) {
    if (pitchSelection.selector.pitches.length === 0) {
      pitchSelection.selector.pitches.push(0);
    }
    var pitch = pitchSelection.note.pitches[pitchSelection.selector.pitches[0]];
    var lastLetter = pitch.letter;
    var vexPitch = smoMusic.stripVexOctave(smoMusic.pitchToVexKey(pitch));
    vexPitch = smoMusic.getEnharmonic(vexPitch);

    pitch.letter = vexPitch[0];
    pitch.accidental = vexPitch.length > 1 ?
    vexPitch.substring(1, vexPitch.length) : 'n';
    pitch.octave += smoMusic.letterChangedOctave(lastLetter, pitch.letter);
    pitchSelection.measure.setChanged();
  }

  static addDynamic(selection, dynamic) {
    selection.note.addModifier(dynamic);
    selection.measure.setChanged();
  }

  static beamSelections(selections) {
    var start = selections[0].selector;
    var cur = selections[0].selector;
    var beamGroup = [];
    var ticks = 0;
    selections.forEach((selection) => {
      if (SmoSelector.sameNote(start,selection.selector) ||
        (SmoSelector.sameMeasure(selection.selector,cur) &&
         cur.tick == selection.selector.tick-1)) {
        ticks += selection.note.tickCount;
        cur = selection.selector;
        beamGroup.push(selection.note);
      }
    });
    if (beamGroup.length) {
      beamGroup.forEach((note) => {
        note.beamBeats=ticks;
        note.endBeam=false;
      });
      beamGroup[beamGroup.length - 1].endBeam=true;
    }
  }

    static toggleBeamDirection(selections) {
        selections[0].note.toggleFlagState();
        selections.forEach((selection) => {
            selection.note.flagState = selections[0].note.flagState;
            selection.measure.setChanged()
        });
    }

    static toggleOrnament(selection,ornament) {
  selection.note.toggleOrnament(ornament);
  selection.measure.setChanged();
    }

  static toggleArticulation(selection, articulation) {
  selection.note.toggleArticulation(articulation);
  selection.measure.setChanged();
  }

  static addEnding(score, parameters) {
    var startMeasure = parameters.startBar;
    var endMeasure = parameters.endBar;
    var s = 0;

    // Ending ID ties all the instances of an ending across staves
    parameters.endingId=VF.Element.newID();
    score.staves.forEach((staff) => {
      var m = 0;
      staff.measures.forEach((measure) => {
        if (m === startMeasure) {
          var pp = JSON.parse(JSON.stringify(parameters));
          pp.startSelector = {
          staff: s,
          measure: startMeasure
          };
          pp.endSelector = {
          staff: s,
          measure: endMeasure
          };
          var ending = new SmoVolta(pp);
          measure.addNthEnding(ending);
        }
        measure.setChanged();
        m += 1;
      });
      s += 1;
    });
  }

  static addScoreText(score,scoreText) {
    score.addScoreText(scoreText);
  }
  static removeScoreText(score,scoreText) {
    score.removeScoreText(scoreText);
  }

  static addTextGroup(score,textGroup) {
    score.addTextGroup(textGroup);
  }

  static removeTextGroup(score,textGroup) {
    score.removeTextGroup(textGroup);
  }

  static addMeasureText(score,selection,measureText) {
        var current = selection.measure.getMeasureText();
        // TODO: should we allow multiples per position
        current.forEach((mod) => {
            selection.measure.removeMeasureText(mod.attrs.id);
        });
  selection.measure.addMeasureText(measureText);
  }

  static removeMeasureText(score,selection,mt) {
  selection.measure.removeMeasureText(mt.attrs.id);
  }

  static addSystemText(score,selection,measureText) {
  var mm = selection.selector.measure;
  score.staves.forEach((staff) => {
  var mt = new SmoMeasureText(measureText.serialize());
  staff.measures[mm].addMeasureText(mt);
  });
  }

  static addRehearsalMark(score,selection,rehearsalMark) {
  var mm = selection.selector.measure;
  score.staves.forEach((staff) => {
  var mt = new SmoRehearsalMark(rehearsalMark.serialize());
            staff.addRehearsalMark(selection.selector.measure,mt);
  });
  }

    static addLyric(score,selection,lyric) {
        selection.note.addLyric(lyric);
    }

    static removeLyric(score,selection,lyric) {
        selection.note.removeLyric(lyric);
    }

    static addTempo(score,selection,tempo) {
  score.staves.forEach((staff) => {
            staff.addTempo(tempo,selection.selector.measure);
  });
    }

    static removeTempo(score,selection) {
  score.staves.forEach((staff) => {
            staff.removeTempo();
  });
    }


    static removeRehearsalMark(score,selection,rehearsalMark) {
  score.staves.forEach((staff) => {
            staff.removeRehearsalMark(selection.selector.measure);
  });
  }

  static setMeasureBarline(score, selection, barline) {
  var mm = selection.selector.measure;
  var ix = 0;
  score.staves.forEach((staff) => {
  var s2 = SmoSelection.measureSelection(score, ix, mm);
  s2.measure.setBarline(barline);
  s2.measure.setChanged();
  ix += 1;
  });
  }

  static setRepeatSymbol(score, selection, sym) {
  var mm = selection.selector.measure;
  var ix = 0;
  score.staves.forEach((staff) => {
  var s2 = SmoSelection.measureSelection(score, ix, mm);
  s2.measure.setRepeatSymbol(sym);
  s2.measure.setChanged();
  ix += 1;
  });
  }

  // ## interval
  // Add a pitch at the specified interval to the chord in the selection.
  static interval(selection, interval) {
  var measure = selection.measure;
  var note = selection.note;
  selection.measure.setChanged();

  // TODO: figure out which pitch is selected
  var pitch = note.pitches[0];
  if (interval > 0) {
  pitch = note.pitches[note.pitches.length - 1];
  }
  var pitch = smoMusic.getIntervalInKey(pitch, measure.keySignature, interval);
  if (pitch) {
  note.pitches.push(pitch);
  note.pitches.sort((x, y) => {
  return smoMusic.smoPitchToInt(x) - smoMusic.smoPitchToInt(y);
  });
  return true;
  }
  return false;
  }

  static crescendo(fromSelection, toSelection) {
  var fromSelector = JSON.parse(JSON.stringify(fromSelection.selector));
  var toSelector = JSON.parse(JSON.stringify(toSelection.selector));
  var modifier = new SmoStaffHairpin({
  startSelector: fromSelector,
  endSelector: toSelector,
  hairpinType: SmoStaffHairpin.types.CRESCENDO,
  position: SmoStaffHairpin.positions.BELOW
  });
  fromSelection.staff.addStaffModifier(modifier);
  }

  static decrescendo(fromSelection, toSelection) {
  var fromSelector = JSON.parse(JSON.stringify(fromSelection.selector));
  var toSelector = JSON.parse(JSON.stringify(toSelection.selector));
  var modifier = new SmoStaffHairpin({
  startSelector: fromSelector,
  endSelector: toSelector,
  hairpinType: SmoStaffHairpin.types.DECRESCENDO,
  position: SmoStaffHairpin.positions.BELOW
  });
  fromSelection.staff.addStaffModifier(modifier);
  }

  static slur(fromSelection, toSelection) {
  var fromSelector = JSON.parse(JSON.stringify(fromSelection.selector));
  var toSelector = JSON.parse(JSON.stringify(toSelection.selector));
  var modifier = new SmoSlur({
  startSelector: fromSelector,
  endSelector: toSelector,
  position: SmoStaffHairpin.positions.BELOW
  });
  fromSelection.staff.addStaffModifier(modifier);
  fromSelection.measure.setChanged();
  toSelection.measure.setChanged();
  }

  static addStaff(score, parameters) {
    score.addStaff(parameters);
  }
  static removeStaff(score, index) {
    score.removeStaff(index);
  }

  static transposeChords(smoNote,offset,key) {
    var chords = smoNote.getModifiers('SmoLyric');
    chords.forEach((ll) => {
      if (ll.parser === SmoLyric.parsers.chord) {
        var tx = ll.getText();
        // Look for something that looks like a key name
        if (tx.length >= 1 && (tx[0].toUpperCase() >= 'A'
          && tx[0].toUpperCase() <= 'G')) {
          // toffset is 2 if the key has b or # in it
          var toffset = 1;
          var newText = tx[0];
          if (tx.length > 0 && tx[1] === 'b' || tx[1] === '#') {
            newText += tx[1];
            toffset = 2;
          }
          // Transpose the key, as if it were a key signature (octave has no meaning)
          var nkey = smoMusic.smoIntToPitch(smoMusic.smoPitchToInt(
            smoMusic.vexToSmoPitch(newText)) + offset);
          nkey = JSON.parse(JSON.stringify(smoMusic.getEnharmonicInKey(nkey,key)));
          newText = nkey.letter.toUpperCase();

          // new key may have different length, e.g. Bb to B natural
          if (nkey.accidental !== 'n') {
            newText += nkey.accidental;
          };
          newText += tx.substr(toffset,tx.length - toffset);
          ll.setText(newText);
        }
      }
    });
  }
  static changeInstrument(score, instrument, selections) {
    var measureHash = {};
    selections.forEach((selection) => {
      if (!measureHash[selection.selector.measure]) {
        measureHash[selection.selector.measure] = 1;
        var netOffset = instrument.keyOffset - selection.measure.transposeIndex;
        var newKey = smoMusic.pitchToVexKey(smoMusic.smoIntToPitch(
          smoMusic.smoPitchToInt(
            smoMusic.vexToSmoPitch(selection.measure.keySignature)) + netOffset));
        newKey = smoMusic.toValidKeySignature(newKey);
        if (newKey.length > 1 && newKey[1] === 'n') {
          newKey = newKey[0];
        }
        newKey = newKey[0].toUpperCase() + newKey.substr(1,newKey.length)
        selection.measure.keySignature = newKey;
        selection.measure.clef = instrument.clef;
        selection.measure.transposeIndex = instrument.keyOffset;
        selection.measure.voices.forEach((voice) => {
          voice.notes.forEach((note) => {
            if (note.noteType === 'n') {
              var pitches = [];
              note.pitches.forEach((pitch) => {
                var pint = smoMusic.smoIntToPitch(smoMusic.smoPitchToInt(pitch) + netOffset);
                pitches.push(JSON.parse(JSON.stringify(smoMusic.getEnharmonicInKey(pint,newKey))));
              });
              note.pitches = pitches;
              SmoOperation.transposeChords(note,netOffset,newKey);
            }
            note.clef = instrument.clef;
          });
        });
      }
    });
  }

  static addMeasure(score, systemIndex, nmeasure) {
  score.addMeasure(systemIndex, nmeasure);
  }
}
;
// ## UndoBuffer
// ## Description:
// manage a set of undo or redo operations on a score.  The objects passed into
// undo must implement serialize()/deserialize()
// ## Buffer format:
// A buffer is one of 3 things:
// * A single measure,
// * A single staff
// * the whole score.
class UndoBuffer {
    constructor() {
        this.buffer = [];
		this.opCount = 0;
    }
    static get bufferMax() {
        return 100;
    }

    static get bufferTypes() {
        return ['measure', 'staff', 'score'];
    }

  // ### addBuffer
  // Description:
  // Add the current state of the score required to undo the next operation we
  // are about to perform.  For instance, if we are adding a crescendo, we back up the
  // staff the crescendo will go on.
  addBuffer(title, type, selector, obj) {
    if (UndoBuffer.bufferTypes.indexOf(type) < 0) {
      throw ('Undo failure: illegal buffer type ' + type);
    }
    var json = obj.serialize();

    // If this is a measure, preserve the column-mapped attributes
    if (obj.attrs && obj.attrs.type === 'SmoMeasure') {
      var attrColumnHash = {};
      var attrCurrentValue  = {};
      obj.serializeColumnMapped(attrColumnHash,attrCurrentValue);
      Object.keys(attrCurrentValue).forEach((key) => {
        json[key] = attrCurrentValue[key];
      });
    }
    var undoObj = {
      title: title,
      type: type,
      selector: selector,
      json: json
    };
    if (this.buffer.length >= UndoBuffer.bufferMax) {
      this.buffer.splice(0,1);
    }
		this.opCount += 1;
    this.buffer.push(undoObj);
  }

  // ### _pop
  // ### Description:
  // Internal method to pop the top buffer off the stack.
  _pop() {

      if (this.buffer.length < 1)
          return null;
      var buf = this.buffer.pop();
      return buf;
  }

  // ## Before undoing, peek at the top action in the q
  // so it can be re-rendered
  peek() {
    if (this.buffer.length < 1)
      return null;
    return this.buffer[this.buffer.length - 1];
  }

  // ## undo
  // ## Description:
  // Undo the operation at the top of the undo stack.  This is done by replacing
  // the music as it existed before the change was made.
  undo(score) {
    var buf = this._pop();
    if (!buf)
      return score;
    if (buf.type === 'measure') {
      var measure = SmoMeasure.deserialize(buf.json);
      measure.setChanged();
      score.replaceMeasure(buf.selector, measure);
    } else if (buf.type === 'score') {
      // Score expects string, as deserialized score is how saving is done.
      score = SmoScore.deserialize(JSON.stringify(buf.json));
    } else {
      // TODO: test me
      var staff = SmoSystemStaff.deserialize(buf.json);
      score.replaceStaff(buf.selector.staff, staff);
    }
    return score;
  }
}


// ## SmoUndoable
// ## Description:
// Convenience functions to save the score state before operations so we can undo the operation.
// Each undo-able knows which set of parameters the undo operation requires (measure, staff, score).
class SmoUndoable {
	static undoForSelections(score,selections,undoBuffer,operation) {
	    var staffUndo = false;
		var scoreUndo = false;
		if (!selections.length)
			return;
		var measure=selections[0].selector.measure;
		var staff = selections[0].selector.staff;
		for (var i=0;i<selections.length;++i) {
			var sel = selections[i];
			if (sel.selector.measure != measure) {
				staffUndo = true;
			} else if (sel.selector.staff != staff) {
				scoreUndo = true;
				break;
			}
		}
		if (scoreUndo) {
			undoBuffer.addBuffer('score backup for '+operation, 'score', null, score);
		} else if (staffUndo) {
			undoBuffer.addBuffer('staff backup for '+operation, 'staff', selections[0].selector, score);
		} else {
			undoBuffer.addBuffer('measure backup for '+operation, 'measure', selections[0].selector, selections[0].measure);
		}
	}
	// Add the measure/staff/score that will cover this list of selections
	static batchDurationOperation(score,selections,operation,undoBuffer) {
	    SmoUndoable.undoForSelections(score,selections,undoBuffer,operation);
		SmoOperation.batchSelectionOperation(score,selections,operation);
	}
  static multiSelectionOperation(score,selections,operation,parameter,undoBuffer) {
    SmoUndoable.undoForSelections(score,selections,undoBuffer,operation);
    SmoOperation[operation](score,selections,parameter);
  }
  static addConnectorDown(score,selections,parameters,undoBuffer) {
    SmoUndoable.undoForSelections(score,selections,undoBuffer,'Add Connector Below');
    SmoOperation.addConnectorDown(score,selections,parameters);
  }
  static addGraceNote(selection,undoBuffer) {
    undoBuffer.addBuffer('grace note ' + JSON.stringify(selection.note.pitches, null, ' '),
      'measure', selection.selector, selection.measure);
    var pitches = JSON.parse(JSON.stringify(selection.note.pitches));
    SmoOperation.addGraceNote(selection,new SmoGraceNote({pitches:pitches,ticks:{numerator:2048,denominator:1,remainder:0}}))
  }
  static removeGraceNote(selection,params,undoBuffer) {
      undoBuffer.addBuffer('remove grace note',
        'measure', selection.selector, selection.measure);
      SmoOperation.removeGraceNote(selection,params.index);
  }

  static slashGraceNotes(selections,undoBuffer) {
    undoBuffer.addBuffer('transpose grace note',
      'measure', selections[0].selection.selector, selections[0].selection.measure);
    SmoOperation.slashGraceNotes(selections);
  }

  static transposeGraceNotes(selection,params,undoBuffer) {
    undoBuffer.addBuffer('transpose grace note',
      'measure', selection.selector, selection.measure);
    SmoOperation.transposeGraceNotes(selection,params.modifiers,params.offset);
  }
  static setNoteHead(score,selections,noteHead,undoBuffer) {
    SmoUndoable.undoForSelections(score,selections,undoBuffer,'note head');
    SmoOperation.setNoteHead(selections,noteHead);
  }

  static padMeasuresLeft(selections,padding,undoBuffer) {
    if (!Array.isArray(selections)) {
      selections=[selections];
    }
    selections.forEach((selection) => {
      undoBuffer.addBuffer('pad measure','measure',selection.selector,selection.measure);
      SmoOperation.padMeasureLeft(selection,padding);
    });
  }
  static doubleGraceNoteDuration(selection,modifier,undoBuffer) {
    undoBuffer.addBuffer('double grace note duration',
      'measure', selection.selector, selection.measure);
    SmoOperation.doubleGraceNoteDuration(selection,modifier);
  }

  static halveGraceNoteDuration(selection,modifier,undoBuffer) {
    undoBuffer.addBuffer('halve grace note duration',
      'measure', selection.selector, selection.measure);
    SmoOperation.halveGraceNoteDuration(selection,modifier);
  }
  static setPitch(selection, pitches, undoBuffer)  {
    undoBuffer.addBuffer('pitch change ' + JSON.stringify(pitches, null, ' '),
      'measure', selection.selector, selection.measure);
    SmoOperation.setPitch(selection, pitches);
  }
  static addPitch(selection, pitches, undoBuffer)  {
    undoBuffer.addBuffer('pitch change ' + JSON.stringify(pitches, null, ' '),
        'measure', selection.selector, selection.measure);
    SmoOperation.addPitch(selection, pitches);
  }
  static doubleDuration(selection, undoBuffer) {
    undoBuffer.addBuffer('double duration', 'measure', selection.selector, selection.measure);
    SmoOperation.doubleDuration(selection);
  }
  static halveDuration(selection, undoBuffer) {
    undoBuffer.addBuffer('halve note duration', 'measure', selection.selector, selection.measure);
    SmoOperation.halveDuration(selection);
  }
  static makeTuplet(selection, numNotes, undoBuffer) {
    undoBuffer.addBuffer(numNotes + '-let', 'measure', selection.selector, selection.measure);
    SmoOperation.makeTuplet(selection, numNotes);
  }
  static makeRest(selection, undoBuffer) {
    undoBuffer.addBuffer('make rest', 'measure', selection.selector, selection.measure);
    SmoOperation.makeRest(selection);
  }
  static makeNote(selection, undoBuffer) {
    undoBuffer.addBuffer('make note', 'measure', selection.selector, selection.measure);
    SmoOperation.makeNote(selection);
  }
  static unmakeTuplet(selection, undoBuffer) {
    undoBuffer.addBuffer('unmake tuplet', 'measure', selection.selector, selection.measure);
    SmoOperation.unmakeTuplet(selection);
  }
    static dotDuration(selection, undoBuffer) {
        undoBuffer.addBuffer('dot duration', 'measure', selection.selector, selection.measure);
        SmoOperation.dotDuration(selection);
    }
    static populateVoice(selections,voiceIx,undoBuffer) {
        var measures = SmoSelection.getMeasureList(selections);
        measures.forEach((selection) => {
            undoBuffer.addBuffer('populate voice', 'measure',
               selection.selector, selection.measure);
            SmoOperation.populateVoice(selection,voiceIx);
        });
    }

    static depopulateVoice(selections,voiceIx,undoBuffer) {
        var measures = SmoSelection.getMeasureList(selections);
        measures.forEach((selection) => {
            undoBuffer.addBuffer('populate voice', 'measure',
               selection.selector, selection.measure);
            SmoOperation.depopulateVoice(selection,voiceIx);
        });
    }
    static toggleBeamGroups(selections, undoBuffer) {
        var measureUndoHash = {};
        selections.forEach((selection) => {
            if (!measureUndoHash[selection.selector.measure]) {
                measureUndoHash[selection.selector.measure] = true;
                undoBuffer.addBuffer('toggleBeamGroups', 'measure', selection.selector, selection.measure);
            }
            SmoOperation.toggleBeamGroup(selection);
        });
    }
    static toggleBeamDirection(selections,undoBuffer) {
        undoBuffer.addBuffer('beam notes', 'measure', selections[0].selector, selections[0].measure);
        SmoOperation.toggleBeamDirection(selections);
    }
    static beamSelections(selections,undoBuffer) {
        undoBuffer.addBuffer('beam notes', 'measure', selections[0].selector, selections[0].measure);
        SmoOperation.beamSelections(selections);
    }
    static undotDuration(selection, undoBuffer) {
        undoBuffer.addBuffer('undot duration', 'measure', selection.selector, selection.measure);
        SmoOperation.undotDuration(selection);
    }
    static transpose(selection, offset, undoBuffer) {
        undoBuffer.addBuffer('transpose pitches ' + offset, 'measure', selection.selector, selection.measure);
        SmoOperation.transpose(selection, offset);
    }
    static courtesyAccidental(pitchSelection, toBe, undoBuffer) {
        undoBuffer.addBuffer('courtesy accidental ', 'measure', pitchSelection.selector, pitchSelection.measure);
        SmoOperation.courtesyAccidental(pitchSelection, toBe);
    }
    static addDynamic(selection, dynamic, undoBuffer) {
        undoBuffer.addBuffer('add dynamic', 'measure', selection.selector, selection.measure);
        SmoOperation.addDynamic(selection, dynamic);
    }
	static toggleEnharmonic(pitchSelection,undoBuffer) {
	     undoBuffer.addBuffer('toggle enharmonic', 'measure', pitchSelection.selector, pitchSelection.measure);
		 SmoOperation.toggleEnharmonic(pitchSelection)
	}
    static interval(selection, interval, undoBuffer) {
        undoBuffer.addBuffer('add interval ' + interval, 'measure', selection.selector, selection.measure);
        SmoOperation.interval(selection, interval);
    }
    static crescendo(fromSelection, toSelection, undoBuffer) {
        undoBuffer.addBuffer('crescendo', 'staff', fromSelection.selector, fromSelection.staff);
        SmoOperation.crescendo(fromSelection, toSelection);
    }
    static decrescendo(fromSelection, toSelection, undoBuffer) {
        undoBuffer.addBuffer('decrescendo', 'staff', fromSelection.selector, fromSelection.staff);
        SmoOperation.decrescendo(fromSelection, toSelection);
    }
    static slur(fromSelection, toSelection, undoBuffer) {
        undoBuffer.addBuffer('slur', 'staff', fromSelection.selector, fromSelection.staff);
        SmoOperation.slur(fromSelection, toSelection);
    }
    // easy way to back up the score for a score-wide operation
	static noop(score,undoBuffer,label) {
        label = label ? label : 'Backup';
        undoBuffer.addBuffer(label, 'score', null, score);
	}

	static measureSelectionOp(score,selection,op,params,undoBuffer,description) {
		undoBuffer.addBuffer(description, 'measure', selection.selector, selection.measure);
		SmoOperation[op](score,selection,params);
	}

    static staffSelectionOp(score,selection,op,params,undoBuffer,description) {
		undoBuffer.addBuffer(description, 'staff', selection.selector, selection.staff);
		SmoOperation[op](selection,params);
	}

	static scoreSelectionOp(score,selection,op,params,undoBuffer,description) {
        undoBuffer.addBuffer(description, 'score', null, score);
		SmoOperation[op](score,selection,params);
	}
	static scoreOp(score,op,params,undoBuffer,description) {
		undoBuffer.addBuffer(description, 'score', null, score);
		SmoOperation[op](score,params);
	}

    static addKeySignature(score, selection, keySignature, undoBuffer) {
        undoBuffer.addBuffer('addKeySignature ' + keySignature, 'score', null, score);
        SmoOperation.addKeySignature(score, selection, keySignature);
    }
    static addMeasure(score, systemIndex, nmeasure, undoBuffer) {
        undoBuffer.addBuffer('add measure', 'score', null, score);
        SmoOperation.addMeasure(score, systemIndex, nmeasure);
    }
    static deleteMeasure(score, selection, undoBuffer) {
        undoBuffer.addBuffer('delete measure', 'score', null, score);
        var measureIndex = selection.selector.measure;
        score.deleteMeasure(measureIndex);
    }
    static addStaff(score, parameters, undoBuffer) {
        undoBuffer.addBuffer('add instrument', 'score', null, score);
        SmoOperation.addStaff(score, parameters);
    }
    static toggleGraceNoteCourtesyAccidental(selection,modifier,undoBuffer) {
        undoBuffer.addBuffer('toggle grace courtesy ','measure', selection.selector, selection.measure);
		SmoOperation.toggleGraceNoteCourtesy(selection,modifier);
    }
	static toggleCourtesyAccidental(selection,undoBuffer) {
        undoBuffer.addBuffer('toggle courtesy ','measure', selection.selector, selection.measure);
		SmoOperation.toggleCourtesyAccidental(selection);
	}
    static removeStaff(score, index, undoBuffer) {
        undoBuffer.addBuffer('remove instrument', 'score', null, score);
        SmoOperation.removeStaff(score, index);
    }
    static changeInstrument(score, instrument, selections, undoBuffer) {
        undoBuffer.addBuffer('changeInstrument', 'staff', selections[0].selector, selections[0].staff);
        SmoOperation.changeInstrument(score, instrument, selections);
    }
	static pasteBuffer(score,pasteBuffer,selections,undoBuffer,operation) {
		SmoUndoable.undoForSelections(score,selections,undoBuffer,operation);
		var pasteTarget = selections[0].selector;
        pasteBuffer.pasteSelections(this.score, pasteTarget);
	}
}
;


// ## PasteBuffer
// ### Description:
// Hold some music that can be pasted back to the score
class PasteBuffer {
	constructor() {
		this.notes = [];
		this.noteIndex = 0;
		this.measures = [];
		this.measureIndex = -1;
		this.remainder = 0;
	}

	setSelections(score, selections) {
		this.notes = [];
		this.noteIndex = 0;
		var measureIndex = -1;
		this.score = score;

		if (selections.length < 1) {
			return;
		}

		this.tupletNoteMap = {};
		var first = selections[0];
		var last = selections[selections.length - 1];

		var startTuplet = first.measure.getTupletForNote(first.note);
		if (startTuplet) {
			if (startTuplet.getIndexOfNote(first.note) != 0) {
				return; // can't paste from the middle of a tuplet
			}
		}
		var endTuplet = last.measure.getTupletForNote(last.note);
		if (endTuplet) {
			if (endTuplet.getIndexOfNote(last.note) != endTuplet.notes.length - 1) {
				return; // can't paste part of a tuplet.
			}
		}

		this._populateSelectArray(selections);

	}
	// ### _populateSelectArray
	// ### Description:
	// copy the selected notes into the paste buffer with their original locations.
	_populateSelectArray(selections) {
		var currentTupletParameters = null;
		var currentTupletNotes = [];
        this.modifiers=[];
		selections.forEach((selection) => {
			var selector = JSON.parse(JSON.stringify(selection.selector));
            var mod = selection.staff.getModifiersAt(selector);
            if (mod.length) {
                mod.forEach((modifier) => {
                    var cp = StaffModifierBase.deserialize(modifier.serialize());
                    cp.attrs.id = VF.Element.newID();
                    this.modifiers.push(cp);
                });
            }
			if (selection.note.isTuplet) {
				var tuplet = selection.measure.getTupletForNote(selection.note);
				var index = tuplet.getIndexOfNote(selection.note);
				if (index == 0) {
					var ntuplet = SmoTuplet.cloneTuplet(tuplet);
					this.tupletNoteMap[ntuplet.attrs.id] = ntuplet;
					ntuplet.notes.forEach((nnote) => {

						this.notes.push({
						selector:selector,note:nnote});
						selector = JSON.parse(JSON.stringify(selector));
						selector.tick += 1;
					});
				}
			} else {

				var note = SmoNote.clone(selection.note);
				this.notes.push({
					selector: selector,
					note: note
				});
			}
		});
		this.notes.sort((a, b) => {
			return SmoSelector.gt(a.selector, b.selector) ? 1 : -1;
		});
	}

	clearSelections() {
		this.notes = [];
	}

    _findModifier(selector) {
        var rv = this.modifiers.filter((mod) => SmoSelector.eq(selector,mod.startSelector));
        return (rv && rv.length) ? rv[0] : null;
    }
    _findPlacedModifier(selector) {
        var rv = this.modifiers.filter((mod) => SmoSelector.eq(selector,mod.endSelector));
        return (rv && rv.length) ? rv[0] : null;
    }

	// ### _populateMeasureArray
	// ### Description:
	// Before pasting, populate an array of existing measures from the paste destination
	// so we know how to place the notes.
	_populateMeasureArray() {
		this.measures = [];
        this.staffSelectors = [];
		var measureSelection = SmoSelection.measureSelection(this.score, this.destination.staff, this.destination.measure);
		var measure = measureSelection.measure;
		this.measures.push(measure);
		var tickmap = measure.tickmapForVoice(this.destination.voice);
		var startSel = this.notes[0].selector;
		var currentDuration = tickmap.durationMap[this.destination.tick];
		var rv = [];
		this.notes.forEach((selection) => {
			if (currentDuration + selection.note.tickCount > tickmap.totalDuration && measureSelection != null) {
				// If this note will overlap the measure boundary, the note will be split in 2 with the
				// remainder going to the next measure.  If they line up exactly, the remainder is 0.
				var remainder = (currentDuration + selection.note.tickCount) - tickmap.totalDuration;
				currentDuration = remainder;

				measureSelection = SmoSelection.measureSelection(this.score,
						measureSelection.selector.staff,
						measureSelection.selector.measure + 1);

				// If the paste buffer overlaps the end of the score, we can't paste (TODO:  add a measure in this case)
				if (measureSelection != null) {
					this.measures.push(measureSelection.measure);
				}
			} else if (measureSelection != null) {
				currentDuration += selection.note.tickCount;
			}
		});
	}

	// ### _populatePre
	// When we paste, we replace entire measures.  Populate the first measure up until the start of pasting.
	_populatePre(voiceIndex, measure, startTick, tickmap) {
		var voice = {
			notes: []
		};
		var ticksToFill = tickmap.durationMap[startTick];
		var filled = 0;
		// TODO: bug here, need to handle tuplets in pre-part, create new tuplet
		for (var i = 0; i < measure.voices[voiceIndex].notes.length; ++i) {

			var note = measure.voices[voiceIndex].notes[i];
			// IF this is a tuplet, clone all the notes at once.
			if (note.isTuplet) {
				var tuplet = measure.getTupletForNote(note);
                if (!tuplet) {
                    continue;  // we remove the tuplet after first iteration
                }
                var ntuplet = SmoTuplet.cloneTuplet(tuplet);
                voice.notes = voice.notes.concat(ntuplet.notes);
                measure.removeTupletForNote(note);
                measure.tuplets.push(ntuplet);
                ticksToFill -= tuplet.tickCount;
			} else if (ticksToFill >= note.tickCount) {
				ticksToFill -= note.tickCount;
				voice.notes.push(SmoNote.clone(note));
			} else {
				var duration = note.tickCount - ticksToFill;
                var durMap = smoMusic.gcdMap(duration);
                durMap.forEach((dd) => {
                    SmoNote.cloneWithDuration(note, {
    					numerator: dd,
    					denominator: 1,
    					remainder: 0
    				});
                });
				ticksToFill = 0;
			}
			if (ticksToFill < 1) {
				break;
			}
		}
		return voice;
	}

	// ### _populateVoice
	// ### Description:
	// Create a new voice for a new measure in the paste destination
	_populateVoice(voiceIndex) {
		this._populateMeasureArray();
		var measures = this.measures;
		this.measureIndex = 0;
		var measureVoices = [];

		var measure = measures[0];
		var tickmap = measure.tickmapForVoice(this.destination.voice);
		var startSelector = JSON.parse(JSON.stringify(this.destination));
		var measureTuplets = [];
		var voice = this._populatePre(voiceIndex, measure, this.destination.tick, tickmap);
		measureVoices.push(voice);
		while (this.measureIndex < measures.length) {
			measure = measures[this.measureIndex];
			tickmap = measure.tickmapForVoice(this.destination.voice);
			this._populateNew(voice, voiceIndex, measure, tickmap, startSelector);
			if (this.noteIndex < this.notes.length && this.measureIndex < measures.length) {
				voice = {
					notes: []
				};
				measureVoices.push(voice);
				startSelector = {
					staff: startSelector.staff,
					measure: startSelector.measure,
					voice: voiceIndex,
					tick: 0
				};
				this.measureIndex += 1;
                startSelector.measure += 1;
			} else {
				break;
			}
		}
		this._populatePost(voice, voiceIndex, measure, tickmap, startSelector.tick);

		return measureVoices;
	}

	static _countTicks(voice) {
		var voiceTicks = 0;
		voice.notes.forEach((note) => {
			voiceTicks += note.tickCount;
		});
		return voiceTicks;
	}

    // ### _populateModifier
    // If the destination contains a modifier start and end, copy and paste it.
    _populateModifier(srcSelector,destSelector,staff) {
        var mod = this._findModifier(srcSelector);
        // If this is the starting point of a staff modifier, update the selector
        if (mod) {
            mod.startSelector = JSON.parse(JSON.stringify(destSelector));
        }
        // If this is the ending point of a staff modifier, paste the modifier
        mod = this._findPlacedModifier(srcSelector);
        if (mod) {
            mod.endSelector = JSON.parse(JSON.stringify(destSelector));
            mod.attrs.id = VF.Element.newID();
            staff.addStaffModifier(mod);
        }
    }

	// ### _populateNew
	// Start copying the paste buffer into the destination by copying the notes and working out
	// the measure overlap
	_populateNew(voice, voiceIndex, measure, tickmap, startSelector) {
		var currentDuration = tickmap.durationMap[startSelector.tick];
		var totalDuration = tickmap.totalDuration;
		while (currentDuration < totalDuration && this.noteIndex < this.notes.length) {
            var selection = this.notes[this.noteIndex];
			var note = selection.note;
            this._populateModifier(selection.selector,startSelector,this.score.staves[selection.selector.staff]);
			if (note.isTuplet) {
				var tuplet = this.tupletNoteMap[note.tuplet.id];
                var ntuplet = SmoTuplet.cloneTuplet(tuplet);
                this.noteIndex += ntuplet.notes.length;
                startSelector.tick += ntuplet.notes.length;
                currentDuration += tuplet.tickCount;
                for (var i =  0;i < ntuplet.notes.length;++i) {
                    var tn = ntuplet.notes[i];
                    tn.clef = measure.clef;
                    voice.notes.push(tn);
                }
                measure.tuplets.push(ntuplet);
			} else if (currentDuration + note.tickCount <= totalDuration && this.remainder === 0) {
				// The whole note fits in the measure, paste it.
                var nnote = SmoNote.clone(note);
                nnote.clef = measure.clef;
				voice.notes.push(nnote);
				currentDuration += note.tickCount;
				this.noteIndex += 1;
				startSelector.tick += 1;
			} else if (this.remainder > 0) {
				// This is a note that spilled over the last measure
                var nnote = SmoNote.cloneWithDuration(note, {
						numerator: this.remainder,
						denominator: 1,
						remainder: 0
					});
                nnote.clef = measure.clef;
				voice.notes.push(nnote);

				currentDuration += this.remainder;
				this.remainder = 0;
			} else {
				// The note won't fit, so we split it in 2 and paste the remainder in the next measure.
				// TODO:  tie the last note to this one.
				var partial = totalDuration - currentDuration;
                var dar = smoMusic.gcdMap(partial);
                dar.forEach((ddd) => {
                    voice.notes.push(SmoNote.cloneWithDuration(note, {
    						numerator: ddd,
    						denominator: 1,
    						remainder: 0
    					}));
                });
				currentDuration += partial;

				// Set the remaining length of the current note, this will be added to the
				// next measure with the previous note's pitches
				this.remainder = note.tickCount - partial;
			}
		}
	}

	// ### _populatePost
	// When we paste, we replace entire measures.  Populate the last measure from the end of paste to the
	// end of the measure with notes in the existing measure.
	_populatePost(voice, voiceIndex, measure, tickmap, endTick) {
		var startTicks = PasteBuffer._countTicks(voice);
		var notes = measure.voices[voiceIndex].notes;
		var totalDuration = tickmap.totalDuration;
		while (startTicks < totalDuration) {
			// Find the point in the music where the paste area runs out, or as close as we can get.
			var existingIndex = tickmap.durationMap.indexOf(startTicks);
			existingIndex = (existingIndex < 0) ? measure.voices[voiceIndex].notes.length - 1 : existingIndex;
			var note = measure.voices[voiceIndex].notes[existingIndex];
            if (note.isTuplet) {
                var tuplet = measure.getTupletForNote(note);
                var ntuplet = null;
                var ntuplet = SmoTuplet.cloneTuplet(tuplet);
                startTicks += tuplet.tickCount;
                voice.notes = voice.notes.concat(ntuplet.notes);
                measure.tuplets.push(ntuplet);
                measure.removeTupletForNote(note);
            } else {
    			var ticksLeft = totalDuration - startTicks;
    			if (ticksLeft >= note.tickCount) {
    				startTicks += note.tickCount;
    				voice.notes.push(SmoNote.clone(note));
    			} else {
    				var remainder = totalDuration - startTicks;
    				voice.notes.push(SmoNote.cloneWithDuration(note, {
    						numerator: remainder,
    						denominator: 1,
    						remainder: 0
    					}));
    				startTicks = totalDuration;
    			}
            }
		}
	}

    _pasteVoiceSer(ser,vobj,voiceIx) {
        var voices = [];
        var ix = 0;
        ser.voices.forEach((vc) => {
            if(ix != voiceIx) {
                voices.push(vc);
            } else {
                voices.push(vobj);
            }
            ix += 1;
        });
        ser.voices = voices;
    }

	pasteSelections(score, selector) {
		this.destination = selector;
		if (this.notes.length < 1) {
			return;
		}

		var voices = this._populateVoice(this.destination.voice);
		var measureSel = JSON.parse(JSON.stringify(this.destination));
		for (var i = 0; i < this.measures.length; ++i) {
			var measure = this.measures[i];
			var nvoice = voices[i];
			var ser = measure.serialize();

      // deserialize column-mapped attributes, these are not normally serialized
      // since they are mapped to measures on a delta basis.
      SmoMeasure.columnMappedAttributes.forEach((attr) => {
        if (typeof(measure[attr]) === 'string') {
          ser[attr] = measure[attr];
        } else if (typeof(measure[attr]) === 'object') {
          if (measure[attr].ctor) {
            ser[attr] = measure[attr].serialize();
          }
        }
      });
			var vobj = {
				notes: []
			};
			nvoice.notes.forEach((note) => {
				vobj.notes.push(note.serialize());
			});

			// TODO: figure out how to do this with multiple voices
      this._pasteVoiceSer(ser,vobj,this.destination.voice);
			var nmeasure = SmoMeasure.deserialize(ser);
      nmeasure.renderedBox = svgHelpers.smoBox(measure.renderedBox);
      nmeasure.setBox(svgHelpers.smoBox(measure.logicalBox),'copypaste');
      nmeasure.setX(measure.logicalBox.x,'copyPaste');
      nmeasure.setWidth( measure.logicalBox.width,'copypaste');
      nmeasure.setY(measure.logicalBox.y,'copypaste');
      ['forceClef','forceKeySignature','forceTimeSignature','forceTempo'].forEach((flag) => {
          nmeasure[flag] = measure[flag];
      });
			this.score.replaceMeasure(measureSel, nmeasure);
			measureSel.measure += 1;
		}
	}
}
;VF = Vex.Flow;
Vex.Xform = (typeof(Vex.Xform) == 'undefined' ? {}
     : Vex.Xform);
VX = Vex.Xform;

VX.groupCounter = 1;

// ## Description:
//   Create a staff and draw music on it usinbg VexFLow rendering engine
//
// ###  Options:
//  `{measure:measure}` - The SMO measure to render
// ### VxMeasure methods
// ---
class VxMeasure {
  constructor(context, options) {
    this.context = context;
    Vex.Merge(this, VxMeasure.defaults);
    Vex.Merge(this, options);
    this.rendered = false;
    this.selection = options.selection;
    this.smoMeasure = this.selection.measure;
    this.noteToVexMap = {};
    this.beamToVexMap = {};
    this.tupletToVexMap = {};
    this.modifierOptions = {};

    this.vexNotes = [];
    this.vexBeamGroups = [];
    this.vexTuplets = [];
    this.vexBeamGroups = [];
    this.beamToVexMap = {};
  }

	static get adjLeftPixels() {
		return 5;
	}

	static get adjRightPixels() {
		return 5;
	}

  static get defaults() {
      // var defaultLayout = new smrfSimpleLayout();

      return {
          smoMeasure: null
      };
  }
  addCustomModifier(ctor, parameters) {
    this.smoMeasure.addCustomModifier(ctor, parameters);
  }

  applyTransform(actor) {
    SmoTickTransformer.applyTransform(this.smoMeasure, [actor]);
    smoModifierFactory.applyModifiers(this.smoMeasure);
  }
  applyModifiers() {
    smoModifierFactory.applyModifiers(this.smoMeasure);
  }

    // ## Description:
    // decide whether to force stem direction for multi-voice, or use the default.
    // ## TODO:
    // use x position of ticks in other voices, pitch of note, and consider
    // stem direction modifier.
    applyStemDirection(vxParams,voiceIx,flagState) {
      if (this.smoMeasure.voices.length === 1 && flagState === SmoNote.flagStates.auto) {
        vxParams.auto_stem = true;
      } else if (flagState !== SmoNote.flagStates.auto) {
        vxParams.stem_direction = SmoNote.flagState ===  SmoNote.flagStates.up ? 1 : -1;
      } else if (voiceIx % 2) {
        vxParams.stem_direction = -1;
      } else {
        vxParams.stem_direction = 1;
      }
    }

    // We add microtones to the notes, without regard really to how they interact
    _createMicrotones(smoNote,vexNote) {
        var tones = smoNote.getMicrotones();
        tones.forEach((tone) => {
            var acc = new VF.Accidental(tone.toVex);
            vexNote.addAccidental(tone.pitch,acc);
        });
    }

	_createAccidentals(smoNote,vexNote,tickIndex,voiceIx) {
        var tickmap = this.smoMeasure.tickmapForVoice(voiceIx);
        for (var i = 0; i < smoNote.pitches.length; ++i) {
            var pitch = smoNote.pitches[i];
            var duration = this.tickmapObject.tickmaps[voiceIx].durationMap[tickIndex];
            var keyAccidental = smoMusic.getAccidentalForKeySignature(pitch,this.smoMeasure.keySignature);
            var accidentals = this.tickmapObject.accidentalArray.filter((ar) =>
                ar.duration < duration && ar.pitches[pitch.letter]);
            var acLen = accidentals.length;
            var declared = acLen > 0 ?
                accidentals[acLen - 1].pitches[pitch.letter].pitch.accidental: keyAccidental;

            if ((declared != pitch.accidental
                || pitch.cautionary) && smoNote.noteType == 'n') {
                var acc = new VF.Accidental(pitch.accidental);

                if (pitch.cautionary) {
                    acc.setAsCautionary();
                }
                vexNote.addAccidental(i, acc);
            }
        }
        for (var i = 0; i < smoNote.dots; ++i) {
            vexNote.addDotToAll();
        }
        this._createMicrotones(smoNote,vexNote);
	}

  _createJazzOrnaments(smoNote,vexNote) {
    var o = smoNote.getJazzOrnaments();
    var ix = 0;
    o.forEach((ll) => {
      var mod = new VF.JazzTechnique(ll.toVex());
      vexNote.addModifier(0,mod);
    });
  }

  _createOrnaments(smoNote,vexNote) {
    var o  = smoNote.getOrnaments();
    var ix=0;
    o.forEach((ll) => {
      var mod = new VF.Ornament(ll.ornament);
      if (ll.offset === SmoOrnament.offsets.after) {
        mod.setDelayed(true);
      }
      vexNote.addModifier(0, mod);
    });

    }
    _addLyricAnnotationToNote(vexNote,lyric) {
      var y = lyric.verse*10;
      var vexL = new VF.Annotation(lyric.getText()).setReportWidth(false);
      vexL.setAttribute(lyric.attrs.id); //

      // If we adjusted this note for the lyric, adjust the lyric as well.
      vexL.setFont(lyric.fontInfo.family, lyric.fontInfo.size,lyric.fontInfo.weight);
      vexL.setYShift(y); // need this?
      vexL.setVerticalJustification(VF.Annotation.VerticalJustify.BOTTOM);
      vexNote.addAnnotation(0,vexL);
      const classString = 'lyric lyric-'+lyric.verse;
      vexL.addClass(classString);
    }

    _addChordChangeToNote(vexNote,lyric) {
      var y = lyric.verse*10;
      var cs = new VF.ChordSymbol();
      var blocks = lyric.getVexChordBlocks();
      blocks.forEach((block) => {
        if (block.glyph) {
          cs.addGlyph(block.glyph,block);
        } else {
          cs.addGlyphOrText(block.text,block);
        }
      });
      cs.setFontSize(14).setReportWidth(false);
      vexNote.addModifier(0,cs);
      const classString = 'chord chord-'+lyric.verse;
      cs.addClass(classString);
    }

  _createLyric(smoNote,vexNote,x_shift) {
    var lyrics = smoNote.getModifiers('SmoLyric');
    var ix = 0;
    lyrics.forEach((ll) => {
      if (ll.parser === SmoLyric.parsers.lyric) {
        this._addLyricAnnotationToNote(vexNote,ll);
      } else {
        this._addChordChangeToNote(vexNote,ll);
      }
    });
  }

  _createGraceNotes(smoNote,vexNote) {
    var gar = smoNote.getGraceNotes();
    var toBeam = true;
    if (gar && gar.length) {
      var group = [];
      gar.forEach((g) => {
        var gr = new VF.GraceNote(g.toVexGraceNote());
        for (var i=0;i<g.pitches.length;++i) {
            var pitch = g.pitches[i];
            if (pitch.accidental != 'n' || pitch.cautionary)  {
                var accidental = new VF.Accidental(pitch.accidental);
                if (pitch.cautionary) {
                    accidental.setAsCautionary();
                }
                gr.addAccidental(i,accidental);
            }
        }
        if (g.tickCount() > 4096) {
            toBeam = false;
        }
        gr.addClass('grace-note'); // note: this doesn't work :(

        g.renderedId = gr.attrs.id;
        group.push(gr);
      });
      var grace = new VF.GraceNoteGroup(group);
      if (toBeam) {
        grace.beamNotes();
      }

      vexNote.addModifier(0,grace);
    }
  }

  // ## Description:
  // convert a smoNote into a vxNote so it can be rasterized
  _createVexNote(smoNote, tickIndex,voiceIx,x_shift) {
  	// If this is a tuplet, we only get the duration so the appropriate stem
  	// can be rendered.  Vex calculates the actual ticks later when the tuplet is made
  	var duration =
  	   smoNote.isTuplet ?
  	     smoMusic.closestVexDuration(smoNote.tickCount) :
  		 smoMusic.ticksToDuration[smoNote.tickCount];

  	// transpose for instrument-specific keys
  	var keys=smoMusic.smoPitchesToVexKeys(smoNote.pitches,0,smoNote.noteHead);
    var noteParams = {
        clef: smoNote.clef,
        keys: keys,
        duration: duration + smoNote.noteType
    };

    this.applyStemDirection(noteParams,voiceIx,smoNote.flagState);
    var vexNote = new VF.StaveNote(noteParams);
    vexNote.attrs.classes = 'voice-'+voiceIx;
    if (smoNote.tickCount >= 4096) {
      var stemDirection = smoNote.flagState == SmoNote.flagStates.auto ?
        vexNote.getStemDirection() : smoNote.toVexStemDirection();
        vexNote.setStemDirection(stemDirection);
    }
    smoNote.renderId = 'vf-' + vexNote.attrs.id; // where does 'vf' come from?

  	this._createAccidentals(smoNote,vexNote,tickIndex,voiceIx);
    this._createLyric(smoNote,vexNote,x_shift);
    this._createOrnaments(smoNote,vexNote);
    this._createJazzOrnaments(smoNote,vexNote);
    this._createGraceNotes(smoNote,vexNote);

    return vexNote;
  }

	_renderArticulations(vix) {
		var i=0;
		this.smoMeasure.voices[vix].notes.forEach((smoNote) => {
			smoNote.articulations.forEach((art) => {
				var vx = this.noteToVexMap[smoNote.attrs.id];
				var position = SmoArticulation.positionToVex[art.position];
				var vexArt = SmoArticulation.articulationToVex[art.articulation];
				var vxArt=new VF.Articulation(vexArt).setPosition(position);
				vx.addArticulation(i,vxArt);
			});
		});
	}

	_renderNoteGlyph(smoNote,textObj) {
		var x = this.noteToVexMap[smoNote.attrs.id].getAbsoluteX();
		// the -3 is copied from vexflow textDynamics
		var y=this.stave.getYForLine(textObj.yOffsetLine-3) + textObj.yOffsetPixels;
		var group = this.context.openGroup();
    group.classList.add(textObj.attrs.id+'-'+smoNote.attrs.id);
		group.classList.add(textObj.attrs.id);
		textObj.text.split('').forEach((ch)=> {
			const glyphCode = VF.TextDynamics.GLYPHS[ch];
			const glyph=new Vex.Flow.Glyph(glyphCode.code, textObj.fontSize);
			glyph.render(this.context, x, y);
			x += VF.TextDynamics.GLYPHS[ch].width;
		});
		textObj.renderedBox = svgHelpers.smoBox(group.getBoundingClientRect());
		this.context.closeGroup();
	}

	renderDynamics(vix) {
		this.smoMeasure.voices.forEach((voice) => {

            voice.notes.forEach((smoNote) => {
    			var mods = smoNote.textModifiers.filter((mod) => {
    				return mod.attrs.type === 'SmoDynamicText';
    			});
    			mods.forEach((tm) => {
    				this._renderNoteGlyph(smoNote,tm);
    			});
            });
		});
	}


    // ## Description:
    // create an a array of VF.StaveNote objects to render the active voice.
    createVexNotes(voiceIx,active) {
        this.vexNotes = [];
        this.noteToVexMap = {};
        var voice =  this.smoMeasure.voices[voiceIx];
        var shiftIndex = 0;
        for (var i = 0;
            i < voice.notes.length; ++i) {
            var smoNote = voice.notes[i];
            var vexNote = this._createVexNote(smoNote, i,voiceIx,shiftIndex);
            this.noteToVexMap[smoNote.attrs.id] = vexNote;
            this.vexNotes.push(vexNote);
            if (isNaN(smoNote.ticks.numerator) || isNaN(smoNote.ticks.denominator)
                || isNaN(smoNote.ticks.remainder)) {
                    throw ("vxMeasure: NaN in ticks");
                }
        }
		this._renderArticulations(voiceIx);
    }

  // ### createVexBeamGroups
  // create the VX beam groups. VexFlow has auto-beaming logic, but we use
  // our own because the user can specify stem directions, breaks etc.
  createVexBeamGroups(vix) {
    for (var i = 0; i < this.smoMeasure.beamGroups.length; ++i) {
      var bg = this.smoMeasure.beamGroups[i];
      if (bg.voice != vix) {
        continue;
      }
      var vexNotes = [];
      var stemDirection = VF.Stem.DOWN;
      var keyNoteIx = bg.notes.findIndex((nn) => nn.noteType === 'n');

      // Fix stem bug: key off first non-rest note.
      keyNoteIx = (keyNoteIx >= 0) ? keyNoteIx : 0;
      for (var j = 0;j < bg.notes.length; ++j) {
        var note = bg.notes[j];
        var vexNote = this.noteToVexMap[note.attrs.id]
        if (keyNoteIx === j) {
          stemDirection = note.flagState == SmoNote.flagStates.auto ?
            vexNote.getStemDirection() : note.toVexStemDirection();
        }
        vexNote.setStemDirection(stemDirection);
        vexNotes.push(this.noteToVexMap[note.attrs.id]);
      }
      var vexBeam = new VF.Beam(vexNotes);
      this.beamToVexMap[bg.attrs.id] = vexBeam;
      this.vexBeamGroups.push(vexBeam);
    }
  }

  // ### createVexTuplets
  // Create the VF tuplet objects based on the smo tuplet objects
  // that have been defined.
  createVexTuplets(vix) {
    this.vexTuplets = [];
    this.tupletToVexMap = {};
    for (var i = 0; i < this.smoMeasure.tuplets.length; ++i) {
      var tp = this.smoMeasure.tuplets[i];
      if (tp.voice != vix) {
        continue;
      }
      var vexNotes = [];
      for (var j = 0; j < tp.notes.length; ++j) {
        var smoNote = tp.notes[j];
        vexNotes.push(this.noteToVexMap[smoNote.attrs.id]);
      }
      const direction = tp.getStemDirection(this.smoMeasure.clef) === SmoNote.flagStates.up ?
        VF.Tuplet.LOCATION_TOP : VF.Tuplet.LOCATION_BOTTOM;
      var vexTuplet = new VF.Tuplet(vexNotes, {
        num_notes: tp.num_notes,
        notes_occupied: tp.notes_occupied,
        ratioed: false,
        bracketed: true,
        location: direction
      });
      this.tupletToVexMap[tp.attrs.id] = vexTuplet;
      this.vexTuplets.push(vexTuplet);
    }
  }
  unrender() {
      $(this.context.svg).find('g.' + this.smoMeasure.attrs.id).remove();
  }

  handleMeasureModifiers() {
		var sb = this.smoMeasure.getStartBarline();
		var eb = this.smoMeasure.getEndBarline();
		var sym = this.smoMeasure.getRepeatSymbol();

        // don't create a begin bar for any but the 1st measure.
		if (this.smoMeasure.measureNumber.systemIndex != 0 && sb.barline === SmoBarline.barlines.singleBar
             && this.smoMeasure.padLeft === 0) {
		    this.stave.setBegBarType(VF.Barline.type.NONE);
		} else {
			this.stave.setBegBarType(sb.toVexBarline());
		}
		if (eb.barline != SmoBarline.barlines.singleBar) {
			this.stave.setEndBarType(eb.toVexBarline());
		}
		if (sym && sym.symbol != SmoRepeatSymbol.symbols.None) {
			var rep = new VF.Repetition(sym.toVexSymbol(),sym.xOffset+this.smoMeasure.staffX,sym.yOffset);
			this.stave.modifiers.push(rep);
		}
		var tms = this.smoMeasure.getMeasureText();
		// TODO: set font
		tms.forEach((tm) => {
			/* var vm = new VF.StaveText(tm.text,tm.toVexPosition(),{
				shift_x:tm.adjustX,shift_y:tm.adjustY,justification:tm.toVexJustification()
			});
			vm.setFont(tm.fontInfo);   */
            var offset = tm.position === SmoMeasureText.positions.left ? this.smoMeasure.padLeft : 0;
			this.stave.setText(
			    tm.text,tm.toVexPosition(),{
				shift_x:tm.adjustX + offset,shift_y:tm.adjustY,justification:tm.toVexJustification()
			});
			// hack - we can't create staveText directly so this is the only way I could set the font
			var ar = this.stave.getModifiers();
			var vm=ar[ar.length - 1];
			vm.setFont(tm.fontInfo);

		});

        var rm = this.smoMeasure.getRehearsalMark();
        if (rm) {
            this.stave.setSection(rm.symbol,0);
        }

        var tempo = this.smoMeasure.getTempo();
        if (tempo && this.smoMeasure.forceTempo) {
            this.stave.setTempo(tempo.toVexTempo(),-1*tempo.yOffset);
        }

	}

  _setModifierBoxes() {
    this.smoMeasure.voices.forEach((voice) => {
  		voice.notes.forEach((smoNote) =>  {
        var el = this.context.svg.getElementById(smoNote.renderId);
  			svgHelpers.updateArtifactBox(this.context.svg,el,smoNote);

        // TODO: fix this, only works on the first line.
        smoNote.getModifiers('SmoLyric').forEach((lyric) => {
          if (lyric.selector) {
            svgHelpers.updateArtifactBox(this.context.svg,$(lyric.selector)[0],lyric);
            // lyric.logicalBox = svgHelpers.smoBox($(lyric.selector)[0].getBBox());
          }
        });
        smoNote.graceNotes.forEach((g) => {
          var gel = this.context.svg.getElementById('vf-'+g.renderedId);
          $(gel).addClass('grace-note');
          svgHelpers.updateArtifactBox(this.context.svg,gel,g);
        });
      });
    });
  }

  // ### _updateLyricXOffsets
  // Create the DOM modifiers for the rendered lyrics.
   _updateLyricDomSelectors() {
     this.smoMeasure.voices.forEach((vv) => {
       vv.notes.forEach((nn) => {
         nn.getModifiers('SmoLyric').forEach((lyric) => {
           var parser = (lyric.parser === SmoLyric.parsers.lyric ? 'lyric' : 'chord');
           lyric.selector='#'+nn.renderId+' '+lyric.getClassSelector();
         });
       });
     });
   }

  // ## Description:
  // Create all Vex notes and modifiers.  We defer the format and rendering so
  // we can align across multiple staves
  preFormat() {
    $(this.context.svg).find('g.' + this.smoMeasure.getClassId()).remove();


		var key = smoMusic.vexKeySignatureTranspose(this.smoMeasure.keySignature,0);
		var canceledKey = this.smoMeasure.canceledKeySignature ? smoMusic.vexKeySignatureTranspose(this.smoMeasure.canceledKeySignature,0)
      : this.smoMeasure.canceledKeySignature;

    var staffX = this.smoMeasure.staffX + this.smoMeasure.padLeft;

    this.stave = new VF.Stave(staffX, this.smoMeasure.staffY , this.smoMeasure.staffWidth - (1+this.smoMeasure.padLeft));
    if (this.smoMeasure.prevFrame < VxMeasure.fps) {
      this.smoMeasure.prevFrame += 1;
    }

    // If there is padLeft, draw an invisible box so the padding is included in the measure box
    if (this.smoMeasure.padLeft) {
      this.context.rect(this.smoMeasure.staffX,this.smoMeasure.staffY,this.smoMeasure.padLeft,50, {
        fill:'none','stroke-width':1,stroke:'white'
      });
    }

  	this.stave.options.space_above_staff_ln=0; // don't let vex place the staff, we want to.
    //console.log('adjX is '+this.smoMeasure.adjX);

    // Add a clef and time signature.
    if (this.smoMeasure.forceClef) {
      this.stave.addClef(this.smoMeasure.clef);
    }
    if (this.smoMeasure.forceKeySignature) {
  	var sig = new VF.KeySignature(key);
  	if (this.smoMeasure.canceledKeySignature) {
  		sig.cancelKey(canceledKey);
  	}
      sig.addToStave(this.stave);
    }
    if (this.smoMeasure.forceTimeSignature) {
      this.stave.addTimeSignature(this.smoMeasure.timeSignature);
    }
    // Connect it to the rendering context and draw!
    this.stave.setContext(this.context);

  	this.handleMeasureModifiers();

    this.tickmapObject = this.smoMeasure.createMeasureTickmaps();

    this.voiceAr = [];

    // If there are multiple voices, add them all to the formatter at the same time so they don't collide
    for (var j = 0; j < this.smoMeasure.voices.length; ++j) {

      this.createVexNotes(j,this.smoMeasure.getActiveVoice());
      this.createVexTuplets(j);
      this.createVexBeamGroups(j);

        // Create a voice in 4/4 and add above notes
        var voice = new VF.Voice({
            num_beats: this.smoMeasure.numBeats,
            beat_value: this.smoMeasure.beatValue
        }).setMode(Vex.Flow.Voice.Mode.SOFT);
        voice.addTickables(this.vexNotes);
        this.voiceAr.push(voice);
      }

    	// Need to format for x position, then set y position before drawing dynamics.
      this.formatter = new VF.Formatter({softmaxFactor:this.smoMeasure.customProportion}).joinVoices(this.voiceAr);
      // this.formatter = new VF.Formatter().joinVoices(this.voiceAr);

  }
    format(voices) {
        this.formatter.format(voices,
              this.smoMeasure.staffWidth-
             (this.smoMeasure.adjX + this.smoMeasure.adjRight + this.smoMeasure.padLeft));
        // this.formatter.format(voices);
    }
    render() {
         var group = this.context.openGroup();
         var mmClass = this.smoMeasure.getClassId();
         group.classList.add(this.smoMeasure.attrs.id);
         group.classList.add(mmClass);
         group.id=this.smoMeasure.attrs.id;

        this.stave.draw();

        for (var j = 0; j < this.voiceAr.length; ++j) {
            this.voiceAr[j].draw(this.context, this.stave);
        }

        var self = this;
        this.vexBeamGroups.forEach(function (b) {
            b.setContext(self.context).draw();
        });

        this.vexTuplets.forEach(function (tuplet) {
            tuplet.setContext(self.context).draw();
        });
        this.renderDynamics();
        this._updateLyricDomSelectors();
        this._setModifierBoxes();
        // this.smoMeasure.adjX = this.stave.start_x - (this.smoMeasure.staffX);

        this.context.closeGroup();
        var box = svgHelpers.smoBox(group.getBoundingClientRect());
        var lbox = svgHelpers.smoBox(group.getBBox());
        this.smoMeasure.renderedBox = box;
        this.smoMeasure.setBox(lbox,'vxMeasure bounding box');
        this.smoMeasure.changed = false;
        this.rendered = true;
    }
}
;// ## Description:
//   Create a system of staves and draw music on it.
//
// ##  Options:
//  clef:'treble',
//  num_beats:num_beats,
//  timeSignature: '4/4',
//  smoMeasures: []
class VxSystem {
	constructor(context, topY, lineIndex,score) {
		this.context = context;
		this.leftConnector = [null, null];
		this.lineIndex = lineIndex;
    this.score = score;
		this.maxStaffIndex = -1;
		this.maxSystemIndex = -1;
		this.width = -1;
		this.smoMeasures = [];
		this.vxMeasures = [];
    this.staves = [];
		this.endcaps = [];
		this.endings = [];
		this.box = {
			x: -1,
			y: -1,
			width: 0,
			height: 0
		};
		this.currentY = 0;
		this.topY = topY;
		this.clefWidth = 70;
		this.ys = [];
		this.measures = [];
		this.modifiers = [];
	}

	getVxMeasure(smoMeasure) {
		for (var i = 0; i < this.vxMeasures.length; ++i) {
			var vm = this.vxMeasures[i];
			if (vm.smoMeasure.attrs.id === smoMeasure.attrs.id) {
				return vm;
			}
		}

		return null;
	}

	getVxNote(smoNote) {
		var note;
		if (!smoNote) {
			return null;
		}
		for (var i = 0; i < this.measures.length; ++i) {
			var mm = this.measures[i];
			if (mm.noteToVexMap[smoNote.attrs.id]) {
				return mm.noteToVexMap[smoNote.attrs.id];
			}
		}
		return null;
	}

  _updateChordOffsets(note) {
    for (var i =0;i<3;++i) {
      var chords = note.getLyricForVerse(i,SmoLyric.parsers.chord);
      chords.forEach((chord) => {
        var dom = $(this.context.svg).find(chord.selector)[0];
        dom.setAttributeNS('','transform','translate('+chord.translateX+' '+(-1*chord.translateY)+')');
      });
    }
  }

    // ### updateLyricOffsets
    // Adjust the y position for all lyrics in the line so they are even.
    // Also replace '-' with a longer dash do indicate 'until the next measure'
	updateLyricOffsets() {
    for (var i = 0;i < this.score.staves.length;++i) {
      // is this necessary? They should all be from the current line
      var vxMeasures = this.vxMeasures.filter((vx) => {
        return vx.smoMeasure.measureNumber.staffId == i;
      });
      // All the lyrics on this line
      var lyrics=[];
      var lyricsDash = [];

      // The vertical bounds on each line
      var verseLimits={};

      // The
      var lyricVerseMap = {};
      vxMeasures.forEach((mm) => {
        var smoMeasure = mm.smoMeasure;

        // Get lyrics from any voice.
        smoMeasure.voices.forEach((voice) => {
          voice.notes.forEach((note) => {
            this._updateChordOffsets(note);
            note.getTrueLyrics().forEach((ll) => {
              if (!lyricVerseMap[ll.verse]) {
                lyricVerseMap[ll.verse] = [];
              }
              if (ll.logicalBox) {
                lyricVerseMap[ll.verse].push(ll);
                lyrics.push(ll);
              }
            });
          });
        });
      });
      var vkey = Object.keys(lyricVerseMap).sort((a,b) => a-b);
      vkey.forEach((verse) => {
          verseLimits[verse] = {highest:-1,bottom:-1};
          lyricVerseMap[verse].forEach((ll) => {
            verseLimits[verse].highest = Math.round(Math.max(ll.logicalBox.height,verseLimits[verse].highest));
            verseLimits[verse].bottom = Math.round(Math.max(ll.logicalBox.y + ll.logicalBox.height,verseLimits[verse].bottom));
          });
      });
      for (var j = 1; j < vkey.length;++j) {
        verseLimits[j].bottom = verseLimits[j-1].bottom + verseLimits[j-1].highest;
      }
      lyrics.forEach((lyric) => {
  			lyric.adjY = Math.round(verseLimits[lyric.verse].bottom -  lyric.logicalBox.y);
  			var dom = $(this.context.svg).find(lyric.selector)[0];
  			dom.setAttributeNS('','transform','translate('+lyric.adjX+' '+lyric.adjY+')');
        // Keep track of lyrics that are 'dash'
        if (lyric.getText().trim() == '-') {
          lyricsDash.push(lyric);
        }
		  });

      lyricsDash.forEach((lyric) => {
        var parent = $(this.context.svg).find(lyric.selector)[0];
        var line = document.createElementNS(svgHelpers.namespace,'line');
        var ymax = Math.round(lyric.logicalBox.y + lyric.logicalBox.height/2);
        var offset = Math.round(lyric.logicalBox.width/2);
        line.setAttributeNS('', 'x1', lyric.logicalBox.x - offset);
        line.setAttributeNS('', 'y1', ymax);
        line.setAttributeNS('', 'x2', lyric.logicalBox.x + lyric.logicalBox.width + offset);
        line.setAttributeNS('', 'y2', ymax);
        line.setAttributeNS('','stroke-width',1);
        line.setAttributeNS('','fill','none');
        line.setAttributeNS('','stroke','#999999');
        parent.appendChild(line);
        var text = $(this.context.svg).find(lyric.selector).find('text')[0];
        text.setAttributeNS('','fill','#fff');
      });
    }
	}

   // ### renderModifier
   // render a line-type modifier that is associated with a staff (e.g. slur)
	renderModifier(modifier, vxStart, vxEnd,smoStart,smoEnd) {
		// if it is split between lines, render one artifact for each line, with a common class for
		// both if it is removed.
		if (vxStart) {
		    $(this.context.svg).find('g.' +  modifier.attrs.id).remove();
        }
        var artifactId = modifier.attrs.id + '-' + this.lineIndex;
		var group = this.context.openGroup();
        var xtranslate = 0;
        var ytranslate = 0;
		group.classList.add(modifier.attrs.id);
		group.classList.add(artifactId);
		if ((modifier.ctor == 'SmoStaffHairpin' && modifier.hairpinType == SmoStaffHairpin.types.CRESCENDO) ||
			(modifier.ctor == 'SmoStaffHairpin' && modifier.hairpinType == SmoStaffHairpin.types.DECRESCENDO)) {
			var hairpin = new VF.StaveHairpin({
					first_note: vxStart,
					last_note: vxEnd
				}, modifier.hairpinType);
			hairpin.setRenderOptions({
				height: modifier.height,
				y_shift: modifier.yOffset,
				left_shift_px: modifier.xOffsetLeft,
				right_shift_px: modifier.xOffsetRight
			});
			hairpin.setContext(this.context).setPosition(modifier.position).draw();
		} else if (modifier.ctor == 'SmoSlur') {
            var lyric = smoStart.note.longestLyric();
            var xoffset = 0;
            if (lyric && lyric.getText()) {
                // If there is a lyric, the bounding box of the start note is stretched to the right.
                // slide the slur left, and also make it a bit wider.
                xtranslate = (-1*lyric.getText().length * 6);
                xoffset += (xtranslate/2) - SmoSlur.defaults.xOffset;
            }
			var curve = new VF.Curve(
					vxStart, vxEnd, //first_indices:[0],last_indices:[0]});
				{
					thickness: modifier.thickness,
					x_shift: modifier.xOffset,
					y_shift: modifier.yOffset,
                    spacing:modifier.spacing,
					cps: modifier.controlPoints,
					invert: modifier.invert,
					position: modifier.position
				});
            curve.setContext(this.context).draw();


/*
            var curve = new VF.StaveTie({
                first_note:vxStart,
                last_note:vxEnd,
                first_indices:[0],
                last_indices:[0],
                tie_spacing:modifier.spacing
            });
curve.setContext(this.context).draw();
*/
		}

		this.context.closeGroup();
        if (xoffset) {
            var slurBox = $('.'+artifactId)[0];
            svgHelpers.translateElement(slurBox,xoffset,0);
        }
		return svgHelpers.smoBox(group.getBoundingClientRect());
	}

	renderEndings() {
		this.smoMeasures.forEach((smoMeasure) => {
			var staffId = smoMeasure.measureNumber.staffId;
			var endings = smoMeasure.getNthEndings();
			endings.forEach((ending) => {
				$(this.context.svg).find('g.' + ending.attrs.id).remove();
				var group = this.context.openGroup(null,ending.attrs.id);
				var voAr=[];
				group.classList.add(ending.attrs.id);
				group.classList.add(ending.endingId);

				for (var i = ending.startBar; i <= ending.endBar; ++i) {
					var endMeasure = this.getMeasureByIndex(i,staffId);
					if (!endMeasure) {
						continue;
					}
					voAr.push(endMeasure);
					var vxMeasure = this.getVxMeasure(endMeasure);
					var vtype = ending.toVexVolta(endMeasure.measureNumber.measureNumber);
					var vxVolta = new VF.Volta(vtype, ending.number,ending.xOffsetStart, ending.yOffset);
					vxMeasure.stave.modifiers.push(vxVolta);
					vxVolta.setContext(this.context).draw(vxMeasure.stave, endMeasure.staffX);
				}
				this.context.closeGroup();
				ending.renderedBox = svgHelpers.smoBox(group.getBoundingClientRect());
				ending.logicalBox = svgHelpers.clientToLogical(this.context.svg, ending.renderedBox);

				// Adjust real height of measure to match volta height
				voAr.forEach((mm) => {
					var delta =  mm.logicalBox.y - ending.logicalBox.y;
					if (delta > 0) {
						mm.setBox(svgHelpers.boxPoints(
                            mm.logicalBox.x,mm.logicalBox.y - delta,mm.logicalBox.width,mm.logicalBox.height+delta),
                            'vxSystem adjust for volta');
					}
				});
			});
		});
	}

	getMeasureByIndex(measureIndex,staffId) {
		for (var i = 0; i < this.smoMeasures.length; ++i) {
			var mm = this.smoMeasures[i];
			if (measureIndex === mm.measureNumber.measureNumber && staffId === mm.measureNumber.staffId) {
				return mm;
			}
		}
		return null;
	}

	// ## renderMeasure
	// ## Description:
	// Create the graphical (VX) notes and render them on svg.  Also render the tuplets and beam
	// groups
	renderMeasure(smoMeasure,measureMapper,noJustify) {
    var staff = this.score.staves[smoMeasure.measureNumber.staffId];
    var staffId = staff.staffId;
		var systemIndex = smoMeasure.measureNumber.systemIndex;
    var selection = SmoSelection.measureSelection(this.score,staff.staffId,smoMeasure.measureNumber.measureIndex);
		this.smoMeasures.push(smoMeasure);
    if (this.staves.length <= staffId) {
      this.staves.push(staff);
    }

		var vxMeasure = new VxMeasure(this.context, {
				selection: selection
			});

    // create the vex notes, beam groups etc. for the measure
		vxMeasure.preFormat();
    this.vxMeasures.push(vxMeasure);

    var lastStaff = (staffId == this.score.staves.length-1) || noJustify;
    var smoGroupMap = {};

    // If this is the last staff in the column, render the column with justification
    if (lastStaff) {
    var ar = vxMeasure.voiceAr;
    this.vxMeasures.forEach((vv) => {
      if (!vv.rendered) {
        var systemGroup = this.score.getSystemGroupForStaff(vv.selection);
        var justifyGroup = systemGroup ? systemGroup.attrs.id : vv.selection.staff.attrs.id;
        if (!smoGroupMap[justifyGroup]) {
          smoGroupMap[justifyGroup] = {firstMeasure:vv,voices:[]};
        }
        smoGroupMap[justifyGroup].voices =
          smoGroupMap[justifyGroup].voices.concat(vv.voiceAr);
        }
      });
    }
    var keys = Object.keys(smoGroupMap);
    keys.forEach((key) => {
        smoGroupMap[key].firstMeasure.format(smoGroupMap[key].voices);
    });
    if (lastStaff) {
      this.vxMeasures.forEach((vv) => {
        if (!vv.rendered) {
          vv.render();
          // unit test codes don't have tracker.
          if (measureMapper) {
              var tmpStaff = this.staves.find((ss) => ss.staffId == vv.smoMeasure.measureNumber.staffId);
              measureMapper.mapMeasure(tmpStaff,vv.smoMeasure);
          }
        }
      });
    }

		// Keep track of the y coordinate for the nth staff
    var renderedConnection = {};
    var brackets = false;

    if (systemIndex == 0 && lastStaff) {
      $(this.context.svg).find('g.lineBracket-' + this.lineIndex).remove();
      var group = this.context.openGroup();
      group.classList.add('lineBracket-' + this.lineIndex);
      group.classList.add('lineBracket');
      this.vxMeasures.forEach((vv) => {
        var systemGroup = this.score.getSystemGroupForStaff(vv.selection);
        if (systemGroup && !renderedConnection[systemGroup.attrs.id]) {
          renderedConnection[systemGroup.attrs.id] = 1;
          var startSel = this.vxMeasures[systemGroup.startSelector.staff];
          var endSel = this.vxMeasures[systemGroup.endSelector.staff];
          if (startSel && endSel) {
            var c1 = new VF.StaveConnector(startSel.stave, endSel.stave)
  				    .setType(systemGroup.leftConnectorVx());
              c1.setContext(this.context).draw();
              brackets = true;
          }
        }
      });

      if (!brackets && this.vxMeasures.length > 1)  {
        var c2 = new VF.StaveConnector(this.vxMeasures[0].stave,this.vxMeasures[this.vxMeasures.length - 1].stave,
          VF.StaveConnector.type.SINGLE_LEFT);
        c2.setContext(this.context).draw();
      }
      this.context.closeGroup();
      } else if (lastStaff && smoMeasure.measureNumber.measureIndex + 1 < staff.measures.length) {
        if (staff.measures[smoMeasure.measureNumber.measureIndex + 1].measureNumber.systemIndex == 0) {
          var endMeasure = vxMeasure;
          var startMeasure = this.vxMeasures.find((vv) => vv.selection.selector.staff == 0 &&
            vv.selection.selector.measure == vxMeasure.selection.selector.measure);
          if (endMeasure && startMeasure) {
            $(this.context.svg).find('g.endBracket-' + this.lineIndex).remove();
            var group = this.context.openGroup();
            group.classList.add('endBracket-' + this.lineIndex);
            group.classList.add('endBracket');
            var c2 = new VF.StaveConnector(startMeasure.stave,endMeasure.stave)
               .setType(VF.StaveConnector.type.SINGLE_RIGHT);
            c2.setContext(this.context).draw();
            this.context.closeGroup();
          }
       }
     }

		// keep track of left-hand side for system connectors
		if (systemIndex === 0) {
			if (staffId === 0) {
				this.leftConnector[0] = vxMeasure.stave;
			} else if (staffId > this.maxStaffIndex) {
				this.maxStaffIndex = staffId;
				this.leftConnector[1] = vxMeasure.stave;
			}
		} else if (smoMeasure.measureNumber.systemIndex > this.maxSystemIndex) {
			this.endcaps = [];
			this.endcaps.push(vxMeasure.stave);
			this.maxSystemIndex = smoMeasure.measureNumber.systemIndex;
		} else if (smoMeasure.measureNumber.systemIndex === this.maxSystemIndex) {
			this.endcaps.push(vxMeasure.stave);
		}
		this.measures.push(vxMeasure);
		// this._adjustBox(vxMeasure.renderedSize);
	}

	// ## cap
	// ## Description:
	// draw the system brackets.  I don't know why I call them a cap.
	cap() {

	}
}
;
var AudioContext = window.AudioContext || window.webkitAudioContext;

// ## suiAudioPitch
// helper class to compute the frequencies of the notes.
class suiAudioPitch {
    // ### _frequencies
    // Compute the equal-temperment frequencies of the notes.
    static get _frequencies() {
        var map={};
        var letter='a';
        const octaves=[1,2,3,4,5,6,7];
        const letters = ["cn","c#", "dn", "d#","en", "fn", "f#","gn","g#","an", "a#","bn"];
        const lindex = [0,1,2,3,4,5,6];

        const just = Math.pow(2,(1.0/12));
        const baseFrequency=(440/16) * Math.pow(just,3);

        var aaccum = baseFrequency;

        octaves.forEach((octave) => {
            var oint = parseInt(octave);
            var base = baseFrequency*Math.pow(2,oint);
            var lix = 0;
            letters.forEach((letter) => {
                var freq = base*Math.pow(just,lix);
                var enharmonics = smoMusic.getEnharmonics(letter);
                enharmonics.forEach((en) => {
                  // Adjust for B4 higher than C4
                  const adjOctave = (letter[0] === 'b' && en[0] === 'c') ?
                     octave + 1: octave;
                  map[en+adjOctave.toString()] = freq;
                });
                lix += 1;
            });
        });

        return map;
    }

    static get pitchFrequencyMap() {
        suiAudioPitch._pmMap = typeof(suiAudioPitch['_pmMap']) == 'undefined' ? suiAudioPitch._frequencies : suiAudioPitch._pmMap;
        return suiAudioPitch._pmMap;
    }

  static _rawPitchToFrequency(smoPitch,offset) {
    var npitch = smoMusic.smoIntToPitch(smoMusic.smoPitchToInt(smoPitch) + offset);
    var vx = npitch.letter.toLowerCase() + npitch.accidental + npitch.octave.toString();
    return suiAudioPitch.pitchFrequencyMap[vx];
  }

  static smoPitchToFrequency(smoNote,smoPitch,ix,offset) {

    var rv = suiAudioPitch._rawPitchToFrequency(smoPitch,-1 * offset);
    var mt = smoNote.tones.filter((tt) => tt.pitch == ix);
    if (mt.length) {
      var tone = mt[0];
      var coeff = tone.toPitchCoeff;
      var pitchInt = smoMusic.smoPitchToInt(smoPitch);
      pitchInt += (coeff > 0) ? 1 : -1;
      var otherSmo = smoMusic.smoIntToPitch(pitchInt);
      var otherPitch = suiAudioPitch._rawPitchToFrequency(otherSmo,-1 * offset);
      rv += Math.abs(rv - otherPitch)*coeff;
    }
    return rv;
  }
}


class suiReverb {
    static get defaults() {
        return {length:0.5,
        decay:2.0 };
    }

    connect(destination) {
        this.output.connect(destination);
    }

    disconnect() {
        this.output.disconnect();
    }


    // credit: https://github.com/nick-thompson
    _buildImpulse() {
        if (suiReverb['impulse']) {
            this.input.buffer = suiReverb['impulse'];
            return;
        }

         var rate = this._context.sampleRate
           , length = rate * this.length
           , decay = this.decay
           , impulse = this._context.createBuffer(2, length, rate)
           , impulseL = impulse.getChannelData(0)
           , impulseR = impulse.getChannelData(1)
           , n, i;

         for (i = 0; i < length; i++) {
           n = this.reverse ? length - i : i;
           impulseL[i] = (Math.random() * 2 - 1) * Math.pow(1 - n / length, decay);
           impulseR[i] = (Math.random() * 2 - 1) * Math.pow(1 - n / length, decay);
         }
         suiReverb['impulse'] = impulse;

         this.input.buffer = impulse;
    }

    constructor(context) {
        this.input = this.output = context.createConvolver();
        this.length = suiReverb.defaults.length;
        this.decay = suiReverb.defaults.decay;
        this._context = context;
        this._buildImpulse();
    }
}
class suiOscillator {
    static get defaults() {

        var obj = {
            duration:1000,
            frequency:440,
            attackEnv:0.05,
            decayEnv:0.4,
            sustainEnv:0.45,
            releaseEnv:0.1,
            sustainLevel:0.4,
            releaseLevel:0.1,
            waveform:'custom',
            gain:0.1
        };

        var wavetable = {
            real:[0,
                0.3,0.3,0,0,0,
                0.1,0,0,0,0,
                0.05,0,0,0,0,
                0.01,0,0,0,0,
                0.01,0,0,0,0,
                0,0,0,0,0,
                0,0],
            imaginary:[0,
                0,0.05,0,0,0,
                0,0.01,0,0,0,
                0,0,0,0,0,
                0,0,0,0,0,
                0,0,0,0,0,
                0,0,0,0,0,
                0,0]
        }
        obj.wavetable = wavetable;
        return obj;
    }

    static playSelectionNow(selection,gain) {
        // In the midst of re-rendering...
        if (!selection.note) {
            return;
        }
        setTimeout(function() {
        var ar = suiOscillator.fromNote(selection.measure,selection.note,true,gain);
        ar.forEach((osc) => {
            osc.play();
        });
        },1);
    }

    // AR contains an array of arrays of oscillators.
    // The outer array contains an array for each tick/note in a measure.
    // the inner array contains an oscillator for each note in the chord.
    static playOscillatorArray(ar) {
        function playIx(ix,oscAr) {
            var par = [];
            oscAr.forEach((osc) => {
                par.push(osc.play());
            });
            ix += 1;
            Promise.all(par).then(() => {
                if (ix < ar.length) {
                    playIx(ix,ar[ix]);
                }
            });
        }
        playIx(0,ar[0]);
    }

    static fromNote(measure,note,isSample,gain) {
        var tempo = measure.getTempo();
        var offset = -1 * measure.transposeIndex;
        tempo = tempo ? tempo : new SmoTempoText();
        var bpm = tempo.bpm;
        var beats = note.tickCount/4096;
        var duration = (beats / bpm) * 60000;

        // adjust if bpm is over something other than 1/4 note
        duration = duration * (4096/tempo.beatDuration);
        if (isSample)
            duration = 250;


        var ar = [];
        gain = gain ? gain : 0.2;
        gain = gain/note.pitches.length
        if (note.noteType == 'r') {
            gain = 0.001;
        }
        var i = 0;
        note.pitches.forEach((pitch) => {
            var frequency = suiAudioPitch.smoPitchToFrequency(note,pitch,i, measure.transposeIndex);
            var osc = new suiOscillator({frequency:frequency,duration:duration,gain:gain});
            ar.push(osc);
            i += 1;
        });

        return ar;
    }

    static get attributes() {
        return ['duration','frequency','pitch','attackEnv','sustainEnv','decayEnv','releaseEnv','sustainLevel','releaseLevel','waveform','wavetable','gain'];
    }

    static get audio() {
        if (typeof (suiOscillator['_audio']) == 'undefined') {
            suiOscillator._audio = new AudioContext();
        }
        return suiOscillator._audio;
    }

    _playPromise(osc,duration,gain) {
        var audio = suiOscillator.audio;
        var promise = new Promise((resolve) => {
            osc.start(0);

            setTimeout(function() {
               // gain.gain.setTargetAtTime(0, audio.currentTime, 0.015);
                resolve();
            }, duration);


            setTimeout(function() {
               // gain.gain.setTargetAtTime(0, audio.currentTime, 0.015);
                osc.stop(0);
                osc.disconnect(gain);
                gain.disconnect(audio.destination);
            }, duration+500);
        });

        return promise;
    }

    static toFloatArray(ar) {
        var rv = new Float32Array(ar.length);
        for (var i=0;i<ar.length;++i) {
            rv[i] = ar[i];
        }

        return rv;
    }

    play() {

        var audio = suiOscillator.audio;
        var gain = audio.createGain();
        var osc = audio.createOscillator();

        gain.connect(this.reverb.input);
        this.reverb.connect(audio.destination);
        gain.gain.setValueAtTime(0.01, audio.currentTime);
        var attack = this.attack / 1000;
        var decay = this.decay/1000;
        var sustain = this.sustain/1000;
        var release = this.release/1000;
        gain.gain.exponentialRampToValueAtTime(this.gain, audio.currentTime + attack);
        gain.gain.exponentialRampToValueAtTime(this.sustainLevel*this.gain, audio.currentTime + attack + decay);
        gain.gain.exponentialRampToValueAtTime(this.releaseLevel*this.gain,audio.currentTime + attack + decay + sustain );
        gain.gain.exponentialRampToValueAtTime(0.001,audio.currentTime + attack + decay + sustain + release);
        if (this.waveform != 'custom') {
            osc.type = this.waveform;
        } else {
            var wave = audio.createPeriodicWave(suiOscillator.toFloatArray(this.wavetable.real), suiOscillator.toFloatArray(this.wavetable.imaginary),
               {disableNormalization: false});
            osc.setPeriodicWave(wave);
        }
        osc.frequency.value = this.frequency;
        osc.connect(gain);
        gain.connect(audio.destination);
        return this._playPromise(osc,this.duration,gain);
    }


    constructor(parameters) {
        parameters = parameters ? parameters : {};
		smoSerialize.serializedMerge(suiOscillator.attributes, suiOscillator.defaults, this);
		smoSerialize.serializedMerge(suiOscillator.attributes, parameters, this);
        this.reverb = new suiReverb(suiOscillator.audio);
        this.attack = this.attackEnv*this.duration;
        this.decay = this.decayEnv*this.duration;
        this.sustain = this.sustainEnv*this.duration;
        this.release = this.releaseEnv*this.duration;
        this.frequency = this.frequency/2;  // Overtones below partial

        // Note: having some trouble with FloatArray and wavetable on some browsers, so I'm not using it
        // use built-in instead
        if (parameters.waveform && parameters.waveform != 'custom') {
            this.waveform = parameters.waveform;
        } else {
            this.waveform='custom';
        }
    }
}
;

// ## suiAudioPlayer
// Play the music, ja!
class suiAudioPlayer {

    static set playing(val) {
        suiAudioPlayer._playing = val;
    }

    static get maxGain() {
        return 0.2;
    }

    static get instanceId() {
        if (typeof(suiAudioPlayer._instanceId) == 'undefined') {
            suiAudioPlayer._instanceId = 0;
        }
        return suiAudioPlayer._instanceId;
    }
    static incrementInstanceId() {
        var id = suiAudioPlayer.instanceId + 1;
        suiAudioPlayer._instanceId = id;
        return id;
    }
    static get playing() {
        if (typeof(suiAudioPlayer._playing) == 'undefined') {
            suiAudioPlayer._playing = false;
        }
        return suiAudioPlayer._playing;
    }

    static pausePlayer() {
        if (suiAudioPlayer._playingInstance) {
            var a = suiAudioPlayer._playingInstance;
            a.paused = true;
        }
        suiAudioPlayer.playing = false;
    }
    static stopPlayer() {
        if (suiAudioPlayer._playingInstance) {
            var a = suiAudioPlayer._playingInstance;
            a.paused = false;
        }
        suiAudioPlayer.playing = false;
    }

    static get playingInstance() {
        if (!suiAudioPlayer._playingInstance) {
            return null;
        }
        return suiAudioPlayer._playingInstance;
    }

    // the oscAr contains an oscillator for each pitch in the chord.
    // each inner oscillator is a promise, the combined promise is resolved when all
    // the beats have completed.
    static _playChord(oscAr) {
        var par = [];
        oscAr.forEach((osc) => {
            par.push(osc.play());
        });

        return Promise.all(par);
    }

    _createOscillatorsFromMusicData(ar) {
        var rv = [];
        ar.forEach((soundData) => {
            var osc = new suiOscillator({frequency:soundData.frequency,duration:soundData.duration,gain:soundData.gain});
            rv.push(osc);
        });
        return rv;
    }
    _playArrayRecurse(ix,keys,notesToPlay) {
        if (!suiAudioPlayer.playing ||
          suiAudioPlayer.instanceId != this.instanceId) {
               this.tracker.clearMusicCursor();
              return;
          }
        var self = this;
        var key = keys[ix];
        var curTime = parseInt(key);
        var proto = notesToPlay[key];
        var oscs = this._createOscillatorsFromMusicData(proto);

        // Follow the top-staff note in this tick for the cursor
        if (proto[0].selector.staff == 0) {
            this.tracker.musicCursor(proto[0].selector);
        }
        if (ix < keys.length - 1) {
            var diff = parseInt(keys[ix+1]);
            var delay = (diff - curTime);
            setTimeout(function() {
                self._playArrayRecurse(ix+1,keys,notesToPlay);
            },delay);
        } else {
            self.tracker.clearMusicCursor();
        }
        suiAudioPlayer._playChord(oscs);
    }
    _playPlayArray() {
        var startTimes = Object.keys(this.sounds).sort((a,b) => {return parseInt(a) > parseInt(b);});
        if (startTimes.length < 1) {
          return;
        }
        this._playArrayRecurse(0,startTimes,this.sounds);
    }
    _populatePlayArray() {
        var maxGain = suiAudioPlayer.maxGain/this.score.staves.length;
        this.sounds = {};
        this.score.staves.forEach((staff)  => {
            var accumulator = 0;
            var slurs = [];
            for (var i = this.startIndex;i<staff.measures.length;++i) {
                var measure=staff.measures[i];
                var oldAccumulator = accumulator;
                var voiceIx = 0;
                measure.voices.forEach((voice) => {
                    var prevObj = null;
                    if (voiceIx != 0) {
                        accumulator = oldAccumulator;
                    }
                    var tick = 0;
                    voice.notes.forEach((note) => {
                        var tempo = measure.getTempo();
                        tempo = tempo ? tempo : new SmoTempoText();
                        var bpm = tempo.bpm;
                        var beats = note.tickCount/4096;
                        var duration = (beats / bpm) * 60000;

                        // adjust if bpm is over something other than 1/4 note
                        duration = duration * (4096/tempo.beatDuration);
                        var selector = {staff:measure.measureNumber.staffId,measure:measure.measureNumber.measureIndex,voice:voiceIx,tick:tick}

                        var gain = maxGain/note.pitches.length;
                        if (note.noteType == 'n') {
                            var pitchIx = 0;
                            note.pitches.forEach((pitch) => {
                                var frequency = suiAudioPitch.smoPitchToFrequency(note,pitch,pitchIx,-1 * measure.transposeIndex);
                                var obj = {
                                    duration:duration,
                                    frequency: frequency,
                                    gain:gain,
                                    selector:selector,
                                    note:note,
                                    measure:measure,
                                    staff:staff
                                };
                                // Keep track of slurs, don't restart the note it is
                                // really a tie.  TODO:  deal with 1:1, 1:many etc.
                                staff.getSlursStartingAt(selector).forEach((slur) => {
                                    slurs.push({
                                        obj:obj,
                                        slur:slur
                                    });
                                });

                                var pitchTie = slurs.filter((slur) => {
                                    return (SmoSelector.sameNote(slur.slur.endSelector,selector) && slur.obj.frequency == frequency);
                                });
                                if (pitchTie.length) {
                                    pitchTie[0].obj.duration += obj.duration;
                                } else {
                                    if (this.sounds[accumulator]) {
                                        this.sounds[accumulator].push(obj);
                                    } else {
                                        this.sounds[accumulator]=[obj];
                                    }
                                }
                                pitchIx += 1;
                            });
                        }
                        accumulator += Math.round(duration);
                        tick += 1;
                    });
                    voiceIx += 1;
                });
            }
        });
    }

    play() {
        if (suiAudioPlayer.playing) {
            return;
        }
        suiAudioPlayer._playingInstance = this;
        this._populatePlayArray();
        suiAudioPlayer.playing = true;
        this._playPlayArray();
    }

    constructor(parameters) {
        this.instanceId = suiAudioPlayer.incrementInstanceId();
        suiAudioPlayer.playing=false;
        this.paused = false;
        this.startIndex = parameters.startIndex;
        this.playIndex = 0;
        this.tracker = parameters.tracker;
        this.score = parameters.score;
        this._populatePlayArray();
    }
}
;

// ## suiScroller
// Respond to scroll events, and handle the scroll of the viewport
//
// ### class methods:
// ---
class suiScroller  {
	constructor(layout) {

        this._scroll = {x:0,y:0};
        this._scrollInitial = {x:0,y:0};
	    var scroller = $('.musicRelief');
	    this._offsetInitial = {x:$(scroller).offset().left,y:$(scroller).offset().top};

        this.viewport = svgHelpers.boxPoints(
          $('.musicRelief').offset().left,
          $('.musicRelief').offset().top,
          $('.musicRelief').width(),
          $('.musicRelief').height());
	}

    // ### setScrollInitial
    // tracker is going to remap the music, make sure we take the current scroll into account.
    setScrollInitial() {
        var scroller = $('.musicRelief');
        this._scrollInitial = {x:$(scroller)[0].scrollLeft,y:$(scroller)[0].scrollTop};
        this._offsetInitial = {x:$(scroller).offset().left,y:$(scroller).offset().top};
    }

    // ### handleScroll
    // handle scroll events.
    handleScroll(x,y) {
        this._scroll = {x:x,y:y};
        this.viewport = svgHelpers.boxPoints(
          $('.musicRelief').offset().left,
          $('.musicRelief').offset().top,
          $('.musicRelief').width(),
          $('.musicRelief').height());
    }

    scrollAbsolute(x,y) {
        $('.musicRelief')[0].scrollLeft = x;
        $('.musicRelief')[0].scrollTop = y;
        this.netScroll.x = x;
        this.netScroll.y = y;
    }

    // ### scrollVisible
    // Scroll such that the box is fully visible, if possible (if it is
    // not larger than the screen)
    scrollVisibleBox(box) {

        var xoff = 0;
        var yoff = 0;
        var curBox = this.scrollBox;
        if (box.width > curBox.width || box.height > curBox.height) {
            return;
        }
        if (box.height < curBox.height) {
            if (box.y < curBox.y) {
                yoff = box.y - (curBox.y + 25);
            }
            else if (box.y + box.height > curBox.y + curBox.height) {
                yoff = box.y + box.height - (curBox.y + curBox.height) + 25;
            }
        }

        if (box.x < curBox.width) {
            if (box.x < curBox.x) {
                xoff = box.x - curBox.x;
            } else if (box.x + box.width > curBox.x + curBox.width) {
                xoff = box.x + box.width - (curBox.x + curBox.width);
            }
        }

        if (xoff != 0 || yoff != 0) {
            this.scrollOffset(xoff,yoff);
        }
    }

    // ### scrollBox
    // get the current viewport, in scrolled coordinates.  When tracker maps the
    // music element to client coordinates, these are the coordinates used in the
    // map
    get scrollBox() {
        return svgHelpers.boxPoints(this.viewport.x + this.netScroll.x,
         this.viewport.y + this.netScroll.y,
         this.viewport.width,
          this.viewport.height
      );
    }

    get absScroll() {
        var x = $('.musicRelief').offset().left + $('.musicRelief')[0].scrollLeft;
        var y = $('.musicRelief').offset().top + $('.musicRelief')[0].scrollTop;
        return svgHelpers.boxPoints(x,
         y,
         this.viewport.width,
          this.viewport.height
      );

    }

    // ### scrollOffset
    // scroll the offset from the starting scroll point
    scrollOffset(x,y) {
        var self = this;
        var cur = {x:this._scroll.x,y:this._scroll.y};
        setTimeout(function() {
            if (x) {
                $('.musicRelief')[0].scrollLeft = cur.x + x;
            }
            if (y) {
                $('.musicRelief')[0].scrollTop = cur.y + y;
            }

            self.handleScroll( $('.musicRelief')[0].scrollLeft,$('.musicRelief')[0].scrollTop);
        },1);
    }

    // ### netScroll
    // return the net amount we've scrolled, based on when the maps were make (initial)
    // , the offset of the container, and the absolute coordinates of the scrollbar.
    get netScroll() {
		var xoffset = $('.musicRelief').offset().left - this._offsetInitial.x;
		var yoffset = $('.musicRelief').offset().top - this._offsetInitial.y;
        return {x:this._scroll.x - (this._scrollInitial.x + xoffset),y:this._scroll.y - (this._scrollInitial.y + yoffset)};
    }

    // ### invScroll
    // invert the scroll parameters.
    get invScroll() {
        var vect = this.netScroll;
        return {x:vect.x*(-1),y:vect.y*(-1)};
    }

}
;

// ## suiMapper
// Map the notes in the svg so the can respond to events and interact
// with the mouse/keyboard
class suiMapper {
    constructor(layout,scroller) {
        // layout renders the music when it changes
  this.layout = layout;

        // measure to selector map
        this.measureMap = {};
        this.measureNoteMap = {}; // Map for tracker
        this.scroller = scroller;

        // notes currently selected.  Something is always selected
  this.selections = [];
        // modifiers (text etc.) that have been selected
        this.modifierSelections = [];
        // all the modifiers
  this.modifierTabs = [];
        // the index of the currently selected modifier
  this.modifierIndex = -1;
        // The list of modifiers near the current selection
        this.localModifiers = [];
        // mouse-over that might be selected soon
  this.modifierSuggestion=-1;
  this.suggestion = {};
        // index if a single pitch of a chord is selected
  this.pitchIndex = -1;
        // the current selection, which is also the copy/paste destination
  this.pasteBuffer = new PasteBuffer();
  }

    // ### loadScore
    // We are loading a new score.  clear the maps so we can rebuild them after
    // rendering
    loadScore() {
        this.measureMap = {};
        this.measureNoteMap = {};
        this.clearModifierSelections();
        this.selections=[];
    }


  // ### _clearMeasureArtifacts
  // clear the measure from the measure and note maps so we can rebuild it.
  clearMeasureMap(staff,measure) {
    var selector = {staff:measure.measureNumber.staffId,measure:measure.measureNumber.measureIndex};
    var measureKey = SmoSelector.getMeasureKey(selector);
    if (this.measureMap[measureKey]) {
      var nkeys = Object.keys(this.measureMap[measureKey].keys);
      nkeys.forEach((key) => {
        delete this.measureNoteMap[key];
      });

      delete this.measureMap[measureKey];
    }
    // Unselect selections in this measure so we can reselect them when re-tracked
    var ar = [];
    this.selections.forEach((selection) => {
      if (selection.selector.staff != selector.staff || selection.selector.measure != selector.measure) {
        ar.push(selection);
      }
    });
    this.selections = ar;
  }

  deleteMeasure(selection) {
    console.log('removing '+selection.selector.staff+'/'+selection.selector.measure);
    var selCopy = this._copySelectionsByMeasure(selection.selector.staff,selection.selector.measure)
      .selectors;

    this.clearMeasureMap(selection.staff,selection.measure);
    if (selCopy.length) {
        selCopy.forEach((selector) => {
          var nsel = JSON.parse(JSON.stringify(selector));
          if (selector.measure == 0) {
              nsel.measure += 1;
          } else {
              nsel.measure -= 1;
          }
          this.selections.push(this._getClosestTick(nsel));
      });
    }
  }

  updateMap() {
    this._updateMap();
  }

    // ### _getClosestTick
    // given a musical selector, find the note artifact that is closest to it,
    // if an exact match is not available
  _getClosestTick(selector) {
    var measureKey = Object.keys(this.measureNoteMap).find((k) => {
      return SmoSelector.sameMeasure(this.measureNoteMap[k].selector, selector)
   && this.measureNoteMap[k].selector.tick === 0;
    });
    var tickKey = Object.keys(this.measureNoteMap).find((k) => {
        return SmoSelector.sameNote(this.measureNoteMap[k].selector,selector);
    });
  var firstObj = this.measureNoteMap[Object.keys(this.measureNoteMap)[0]];
  return tickKey ? this.measureNoteMap[tickKey]:
      (measureKey ? this.measureNoteMap[measureKey] : firstObj);
  }

    // ### updateMeasure
    // A measure has changed.  Update the music geometry for it
  mapMeasure(staff,measure) {
    if (!measure.renderedBox) {
        return;
    }
    // Keep track of any current selections in this measure, we will try to restore them.
    var sels = this._copySelectionsByMeasure(staff.staffId,measure.measureNumber.measureIndex);
    this.clearMeasureMap(staff,measure);
    var vix = measure.getActiveVoice();
    sels.selectors.forEach((sel) => {
        sel.voice = vix;
    });

    // keep track of the scroll position when we render the music.
    this.scroller.setScrollInitial();

    var voiceIx = 0;
    var selectionChanged = false;
    var selectedTicks = 0;
    measure.voices.forEach((voice) => {
      var tick = 0;
      voice.notes.forEach((note) => {
        var selector = {
          staff: staff.staffId,
          measure: measure.measureNumber.measureIndex,
          voice: voiceIx,
          tick: tick,
          pitches: []
          };

        var voice = measure.getActiveVoice();

        // create a selection for the newly rendered note
        var selection = new SmoSelection({
          selector: selector,
          _staff: staff,
          _measure: measure,
          _note: note,
          _pitches: [],
          box: svgHelpers.adjustScroll(note.renderedBox,this.scroller.netScroll),
          type: 'rendered'
        });
        // and add it to the map
        this._updateMeasureNoteMap(selection);

        // If this note is the same location as something that was selected, reselect it
        if (sels.selectors.length && selection.selector.tick == sels.selectors[0].tick &&
          selection.selector.voice == vix) {
          this.selections.push(selection);
          // Reselect any pitches.
          if (sels.selectors[0].pitches.length > 0) {
            sels.selectors[0].pitches.forEach((pitchIx) => {
              if (selection.pitches.length > pitchIx) {
                selection.selector.pitches.push(pitchIx);
              }
            });
          }
          selectedTicks += selection.note.tickCount;
          selectionChanged = true;
        } else if (selectedTicks > 0 && selectedTicks < sels.ticks && selection.selector.voice == vix) {
          // try to select the same length of music as was previously selected.  So a 1/4 to 2 1/8, both
          // are selected
          this.selections.push(selection);
          selectedTicks += selection.note.tickCount;
        } else if (this.selections.length == 0 && (sels.selectors.length == 0)) {
          this.selections=[selection];
          selectionChanged=true;
        }
        tick += 1;
      });
      voiceIx += 1;
    });
    // If there were selections on this measure, highlight them.
    if (selectionChanged) {
        this.highlightSelection();
    }
  }

  // ### updateMap
  // This should be called after rendering the score.  It updates the score to
  // graphics map and selects the first object.
  _updateMap() {
    console.log('update map');
    this.mapping = true;
    var notes = [].slice.call(this.renderElement.getElementsByClassName('vf-stavenote'));

    var selCopy = this._copySelections();
    var ticksSelectedCopy = this._getTicksFromSelections();
    var firstSelection = this.getExtremeSelection(-1);
    this._updateModifiers();
    this.selections = [];

    // Try to restore selection.  If there were none, just select the fist
    // thing in the score
    var keys = Object.keys(this.measureNoteMap);
    if (keys.length && !selCopy.length) {
    // If there is nothing rendered, don't update tracker
      this.selections = [this.measureNoteMap[keys[0]]];
    }  else {
      if (!firstSelection) {
        return;
      }
      this._findClosestSelection(firstSelection.selector);
      var first = this.selections[0];
      var tickSelected = first.note.tickCount;
      while (tickSelected < ticksSelectedCopy && first) {
        var delta = this.growSelectionRight();
        if (!delta)  {
          break;
        }
        tickSelected += delta;
      }
      // selCopy.forEach((sel) => this._findClosestSelection(sel));
    }
    this.highlightSelection();
    this._createLocalModifiersList();
    // Is this right?  Don't update the past buffer with data until the display is redrawn
    // because some of the selections may not exist in the score.
    if (this.layout.isDirty === false) {
      this.pasteBuffer.clearSelections();
  		this.pasteBuffer.setSelections(this.score, this.selections);
    }
    this.mapping = false;
  }

    // ### intersectingArtifact
    // given a bounding box, find any rendered elements that intersect with it
    intersectingArtifact(bb) {
        bb = svgHelpers.boxPoints(bb.x,bb.y,bb.width ? bb.width : 1 ,bb.height ? bb.height : 1);
        var artifacts = svgHelpers.findIntersectingArtifactFromMap(bb,this.measureNoteMap,this.scroller.netScroll);
        // TODO: handle overlapping suggestions
        if (!artifacts.length) {
            var sel = svgHelpers.findIntersectingArtifact(bb,this.modifierTabs,this.scroller.netScroll);
            if (sel.length) {
                sel = sel[0];
                this._setModifierAsSuggestion(bb, sel);
            }
            return;
        }
        var artifact = artifacts[0];
        this._setArtifactAsSuggestion(bb, artifact);
        return;
    }

}
;
class TrackerBase {
}

// ## suiTracker
// A tracker maps the UI elements to the logical elements ,and allows the user to
// move through the score and make selections, for navigation and editing.
//
// ### See also:
// `suiBaseLayout`, `controller`, `menu`
// ### class methods:
// ---
class suiTracker extends suiMapper {
  constructor(layout,scroller) {
        super(layout,scroller)
  }

  _fullRenderPromise() {
    var self = this;
    return new Promise((resolve) => {
      var f = function() {
        setTimeout(function() {
          if (self.layout.passState === suiLayoutBase.passStates.clean) {
              resolve();
          } else {
              f();
          }
        },50);
      }
      f();
    });
  }

    // ### _checkBoxOffset
  // If the mapped note and actual note don't match, re-render the notes so they do.
  // Otherwise the selections are off.
  _checkBoxOffset() {
  var note = this.selections[0].note;
  var r = note.renderedBox;
  var b = this.selections[0].box;
    var preventScroll = $('body').hasClass('modal');

  if (r.y != b.y || r.x != b.x) {
      if (this.layout.passState == suiLayoutBase.passStates.replace ||
        this.layout.passState == suiLayoutBase.passStates.clean) {
        console.log('tracker: rerender conflicting map');
        this.layout.remapAll();
      }
      if (!preventScroll) {
        console.log('prevent scroll conflicting map');
        $('body').addClass('modal');
        this._fullRenderPromise().then(() => {
          $('body').removeClass('modal');
        });
      }
    }
  }

  replaceSelectedMeasures() {
      var mm = SmoSelection.getMeasureList(this.selections);
      this.layout.addToReplaceQueue(mm);
  }

  setDialogModifier(notifier) {
    this.modifierDialogFactory = notifier;
  }

  // ### renderElement
  // the element the score is rendered on
  get renderElement() {
  return this.layout.renderer.elementId;
  }

  get score() {
  return this.layout.score;
  }

  get context() {
  return this.layout.renderer.getContext();
  }

  _copySelections() {
  var rv = [];
  this.selections.forEach((sel) => {
  rv.push(sel.selector)
  });
  return rv;
  }

    _copySelectionsByMeasure(staffIndex,measureIndex) {
  var rv = this.selections.filter((sel) => sel.selector.staff == staffIndex && sel.selector.measure == measureIndex);
        var ticks = rv.length < 1 ? 0 : rv.map((sel) => sel.note.tickCount).reduce((a,b) => a + b);
        var sels = [];
        rv.forEach((sel) => {
            sels.push(JSON.parse(JSON.stringify(sel.selector)));
        });
        return {ticks:ticks,selectors:sels};
  }

  _getTicksFromSelections() {
  var rv = 0;
  this.selections.forEach((sel) => {
  if (sel.note) {
  rv += sel.note.tickCount;
  }
  });
  return rv;
  }
  // Hack - lyric should be handled consistently
  _reboxTextModifier(modifier) {
    var el;
    if (modifier.attrs.type === 'SmoLyric') {
        // el = $(modifier.selector)[0];
    } else if (modifier.attrs.type === 'SmoGraceNote') {
      el = this.context.svg.getElementById('vf-'+modifier.renderedId);
    } else {
      el = this.context.svg.getElementsByClassName(modifier.attrs.id)[0];
    }
    if (!el) {
      console.warn('cannot rebox element '+modifier.attrs.id);
      return;
    }
    svgHelpers.updateArtifactBox(this.context.svg,el,modifier);
  }

  _updateNoteModifier(selection,modMap,modifier,ix) {
      if (!modMap[modifier.attrs.id]) {
        this.modifierTabs.push({
          modifier: modifier,
          selection: selection,
          box:svgHelpers.adjustScroll(modifier.renderedBox,this.scroller.netScroll),
          index:ix
        });
        ix += 1;
        modMap[modifier.attrs.id] = {
          exists: true
        };
      }
      return ix;
    }

  _updateModifiers() {
    this.modifierTabs = [];
    this.modifierBoxes = [];
    var modMap = {};
    var ix=0;
    this.layout.score.scoreText.forEach((modifier) => {
      if (!modMap[modifier.attrs.id]) {
        this.modifierTabs.push({
          modifier: modifier,
          selection: null,
          box:svgHelpers.adjustScroll(modifier.renderedBox,this.scroller.netScroll),
          index:ix
        });
        ix += 1;
      }
    });
    this.layout.score.textGroups.forEach((modifier) => {
      if (!modMap[modifier.attrs.id]) {
        this.modifierTabs.push({
          modifier: modifier,
          selection: null,
          box:svgHelpers.adjustScroll(modifier.renderedBox,this.scroller.netScroll),
          index:ix
        });
        ix += 1;
      }
    });
    var keys = Object.keys(this.measureNoteMap);
    keys.forEach((selKey) => {
      var selection = this.measureNoteMap[selKey];
      selection.staff.modifiers.forEach((modifier) => {
        if (SmoSelector.contains(selection.selector, modifier.startSelector, modifier.endSelector)) {
          if (!modMap[modifier.attrs.id]) {
            if (modifier.renderedBox) {
              this.modifierTabs.push({
                modifier: modifier,
                selection: selection,
                box:svgHelpers.adjustScroll(modifier.renderedBox,this.scroller.netScroll),
                index:ix
              });
              ix += 1;
              modMap[modifier.attrs.id] = {exists: true };
              }
            }
          }
        });
        selection.measure.modifiers.forEach((modifier) => {
        if (modifier.attrs.id
          && !modMap[modifier.attrs.id]
          && modifier.renderedBox) {
          this.modifierTabs.push({
            modifier: modifier,
            selection: selection,
            box:svgHelpers.adjustScroll(modifier.renderedBox,this.scroller.netScroll),
            index:ix
          });
          ix += 1;
          modMap[modifier.attrs.id] = {
            exists: true
          };
        }
      });
      selection.note.textModifiers.forEach((modifier) => {
        ix = this._updateNoteModifier(selection,modMap,modifier,ix);
      });

      selection.note.graceNotes.forEach((modifier) => {
        ix = this._updateNoteModifier(selection,modMap,modifier,ix);
      });
    });
  }

  clearMusicCursor() {
    $('.workspace #birdy').remove();
  }


  // ### musicCursor
  // the little birdie that follows the music as it plays
  musicCursor(selector) {
    var key = SmoSelector.getNoteKey(selector);
    if (this.measureNoteMap[key]) {
      var measureSel = SmoSelection.measureSelection(this.layout.score,
        this.layout.score.staves.length-1,selector.measure);
      var measure = measureSel.measure;
      var mbox = measure.renderedBox;

      var pos = this.measureNoteMap[key].scrollBox;
      // pos.y = measureSel.measure.renderedBox.y;
      var b = htmlHelpers.buildDom;
      var r = b('span').classes('birdy icon icon-arrow-down').attr('id','birdy');
      $('.workspace #birdy').remove();
      var rd = r.dom();
      var y = pos.y - this.scroller.netScroll.y;
      var x = pos.x - this.scroller.netScroll.x;
      $(rd).css('top',y).css('left',x);
      $('.workspace').append(rd);
      // todo, need lower right for x
      var measureRight = mbox.x + mbox.width;
      var measureBottom = mbox.y +
        mbox.height;
      this.scroller.scrollVisibleBox(svgHelpers.boxPoints(
        mbox.x,mbox.y,mbox.width,mbox.height));
    }
  }

    // ### selectModifierById
    // programatically select a modifier by ID.  Used by text editor.
    selectId(id) {
        this.modifierIndex = this.modifierTabs.findIndex((mm) =>  mm.modifier.attrs.id==id);
    }


    // used by remove dialogs to clear removed thing
    clearModifierSelections() {
        this.modifierSelections=[];
        this._createLocalModifiersList();
        this.modifierIndex = -1;
        this.eraseRect('staffModifier');
    }

  getSelectedModifier() {
        if (this.modifierSelections.length) {
            return this.modifierSelections[0];
        }
  }

    getSelectedModifiers() {
        return this.modifierSelections;
    }
    _addModifierToArray(ar) {
        ar.forEach((mod) => {
            if (mod.renderedBox) {
                this.localModifiers.push({selection:sel,modifier:mod,box:mod.renderedBox});
            }
        });
    }

  _createLocalModifiersList() {
    this.localModifiers = [];
    var staffSelMap = {};
    this.selections.forEach((sel) => {
      sel.note.getGraceNotes().forEach((gg) => {
        this.localModifiers.push({selection:sel,modifier:gg,box:gg.renderedBox});
      });
      sel.note.getModifiers('SmoDynamicText').forEach((dyn) => {
        this.localModifiers.push({selection:sel,modifier:dyn,box:dyn.renderedBox});
      });
      sel.measure.getModifiersByType('SmoVolta').forEach((volta) => {
        this.localModifiers.push({selection:sel,modifier:volta,box:volta.renderedBox});
      });
      sel.measure.getModifiersByType('SmoTempoText').forEach((tempo) => {
        this.localModifiers.push({selection:sel,modifier:tempo,box:tempo.renderedBox});
      });
      sel.staff.getModifiers().forEach((mod) => {
        if (SmoSelector.gteq(sel.selector,mod.startSelector) &&
          SmoSelector.lteq(sel.selector,mod.endSelector) &&
          !staffSelMap[mod.startSelector] && mod.renderedBox)  {
          this.localModifiers.push({selection:sel,modifier:mod,box:mod.renderedBox});
          // avoid duplicates
          staffSelMap[mod.startSelector] = true;
        }
      });
    });
  }

  advanceModifierSelection(keyEv) {
    this.eraseRect('staffModifier');

    var offset = keyEv.key === 'ArrowLeft' ? -1 : 1;

    if (!this.modifierTabs.length) {
      return;
    }
    this.modifierIndex = this.modifierIndex + offset;
    this.modifierIndex = (this.modifierIndex == -2 && this.localModifiers.length) ?
    this.localModifiers.length - 1 : this.modifierIndex;
    if (this.modifierIndex >= this.localModifiers.length || this.modifierIndex < 0) {
      this.modifierIndex = -1;
      this.modifierSelections=[];
      return;
    }
    this.modifierSelections = [this.localModifiers[this.modifierIndex]];
    this._highlightModifier();
  }

  _findClosestSelection(selector) {
    var artifact = this._getClosestTick(selector);
    if (!artifact) {
      return;
    }
    if (this.selections.find((sel) => JSON.stringify(sel.selector)
      === JSON.stringify(artifact.selector))) {
      return;
    }
    if (selector.pitches && selector.pitches.length && selector.pitches.length <= artifact.note.pitches.length) {
      // If the old selection had only a single pitch, try to recreate that.
      artifact.selector.pitches = JSON.parse(JSON.stringify(selector.pitches));
    }
    this.selections.push(artifact);
  }

    // ### _updateNoteBox
    // Update the svg to screen coordinates based on a change in viewport.
    _updateNoteBox(svg,smoNote,selector) {
        var el = svg.getElementById(smoNote.renderId);
        if (!el) {
            console.warn('no element to box');
            return;
        }
        svgHelpers.updateArtifactBox(svg,el,smoNote);

        // removed lyrics - we don't select those directly
        // so no need to track them.
    }

    _updateMeasureNoteMap(artifact) {
        var noteKey = SmoSelector.getNoteKey(artifact.selector);
        var measureKey = SmoSelector.getMeasureKey(artifact.selector);
        var activeVoice = artifact.measure.getActiveVoice();
        if (artifact.selector.voice != activeVoice) {
            $('#'+artifact.note.renderId).find('.vf-notehead path').each(function(ix,el) {
                el.setAttributeNS('', 'fill', 'rgb(128,128,128)');
            });
        }

        // not has not been drawn yet.
        if (!artifact.box) {
            return;
        }

        if (!this.measureNoteMap[noteKey]) {
            this.measureNoteMap[noteKey] = artifact;
            artifact.scrollBox = {x:artifact.box.x - this.scroller.netScroll.x,y:artifact.measure.renderedBox.y - this.scroller.netScroll.y};
        } else {
            var mm = this.measureNoteMap[noteKey];
            mm.scrollBox = {x:Math.min(artifact.box.x - this.scroller.netScroll.x,mm.x),y:Math.min(artifact.measure.renderedBox.y - this.scroller.netScroll.y,mm.y)};
        }

        if (!this.measureMap[measureKey]) {
            this.measureMap[measureKey] = {keys:{}};
            this.measureMap[measureKey].keys[noteKey] = true;
        } else {
            var measureHash = this.measureMap[measureKey].keys;
            if (!measureHash[noteKey]) {
                measureHash[noteKey] = true;
            }

        }
    }



  static stringifyBox(box) {
  return '{x:' + box.x + ',y:' + box.y + ',width:' + box.width + ',height:' + box.height + '}';
  }


  // ### getExtremeSelection
  // Get the rightmost (1) or leftmost (-1) selection
  getExtremeSelection(sign) {
  var rv = this.selections[0];
  for (var i = 1; i < this.selections.length; ++i) {
  var sa = this.selections[i].selector;
  if (sa.measure * sign > rv.selector.measure * sign) {
  rv = this.selections[i];
  } else if (sa.measure === rv.selector.measure && sa.tick * sign > rv.selector.tick * sign) {
  rv = this.selections[i];
  }
  }
  return rv;
  }

  // ### _getOffsetSelection
  // Get the selector that is the offset of the first existing selection
  _getOffsetSelection(offset) {
  var increment = offset;
  var testSelection = this.getExtremeSelection(Math.sign(offset));
  var scopyTick = JSON.parse(JSON.stringify(testSelection.selector));
  var scopyMeasure = JSON.parse(JSON.stringify(testSelection.selector));
  scopyTick.tick += increment;
  scopyMeasure.measure += increment;
  var targetMeasure = SmoSelection.measureSelection(this.score, testSelection.selector.staff,
  scopyMeasure.measure);
        if (targetMeasure && targetMeasure.measure && targetMeasure.measure.voices.length <= scopyMeasure.voice) {
            scopyMeasure.voice = 0;
        }
  if (targetMeasure && targetMeasure.measure) {
  scopyMeasure.tick = (offset < 0) ? targetMeasure.measure.voices[scopyMeasure.voice].notes.length - 1 : 0;
  }

  if (testSelection.measure.voices.length > scopyTick.voice &&
            testSelection.measure.voices[scopyTick.voice].notes.length > scopyTick.tick && scopyTick.tick >= 0) {
            if (testSelection.selector.voice != testSelection.measure.getActiveVoice()) {
                scopyTick.voice = testSelection.measure.getActiveVoice();
                testSelection = this._getClosestTick(scopyTick);
                return testSelection.selector;
            }
  return scopyTick;
  } else if (targetMeasure &&
  scopyMeasure.measure < testSelection.staff.measures.length && scopyMeasure.measure >= 0) {
  return scopyMeasure;
  }
  return testSelection.selector;
  }

    getSelectedGraceNotes() {
        if (!this.modifierSelections.length) {
            return [];
        }
        var ff = this.modifierSelections.filter((mm) => {
            return mm.modifier.attrs.type == 'SmoGraceNote';
        });
        return ff;
    }

    isGraceNoteSelected() {
        if (this.modifierSelections.length) {
            var ff = this.modifierSelections.findIndex((mm)=> mm.modifier.attrs.type == 'SmoGraceNote');
            return ff >= 0;
        }
    }

    _growGraceNoteSelections(offset) {
        var far = this.modifierSelections.filter((mm)=> mm.modifier.attrs.type == 'SmoGraceNote');
        if (!far.length) {
            return;
        }
        var ix = (offset < 0) ? 0 : far.length-1;
        var sel = far[ix];
        var left = this.modifierTabs.filter((mt) => {
            return mt.modifier.attrs.type == 'SmoGraceNote' && SmoSelector.sameNote(mt.selection.selector,sel.selection.selector);
        });
        if (ix+offset < 0 || ix+offset >= left.length) {
            return;
        }
        this.modifierSelections.push(left[ix+offset]);
        this._highlightModifier();
    }

  growSelectionRight() {
        if (this.isGraceNoteSelected()) {
            this._growGraceNoteSelections(1);
            return 0;
        }
  var nselect = this._getOffsetSelection(1);
  // already selected
  var artifact = this._getClosestTick(nselect);
  if (!artifact) {
  return 0;
  }
  if (this.selections.find((sel) => SmoSelector.sameNote(sel.selector, artifact.selector))) {
  return 0;
  }
  // console.log('adding selection ' + artifact.note.id);

        if (!this.mapping) {
            suiOscillator.playSelectionNow(artifact);
        }

  this.selections.push(artifact);
  this.highlightSelection();
        this._createLocalModifiersList();
        return artifact.note.tickCount;
  }

  growSelectionLeft() {
        if (this.isGraceNoteSelected()) {
            this._growGraceNoteSelections(-1);
            return 0;
        }
  var nselect = this._getOffsetSelection(-1);
  // already selected
  var artifact = this._getClosestTick(nselect);
  if (!artifact) {
  return;
  }
  if (this.selections.find((sel) => SmoSelector.sameNote(sel.selector, artifact.selector))) {
  return;
  }

  // console.log('adding selection ' + artifact.note.id);
  this.selections.push(artifact);
        suiOscillator.playSelectionNow(artifact);
  this.highlightSelection();
        this._createLocalModifiersList();
        return artifact.note.tickCount;
  }

    // if we are being moved right programmatically, avoid playing the selected note.
  moveSelectionRight(evKey,skipPLay) {
  if (this.selections.length == 0) {
  return;
  }
  var nselect = this._getOffsetSelection(1);
  this._replaceSelection(nselect,skipPLay);
  }

  moveSelectionLeft() {
  if (this.selections.length == 0) {
  return;
  }
  var nselect = this._getOffsetSelection(-1);
  this._replaceSelection(nselect);
  }
  moveSelectionLeftMeasure() {
  this._moveSelectionMeasure(-1);
  }
  moveSelectionRightMeasure() {
  this._moveSelectionMeasure(1);
  }
  moveSelectionOffset(offset) {
  var fcn = (offset >= 0 ? 'moveSelectionRight' : 'moveSelectionLeft');
  offset = (offset < 0) ? -1 * offset : offset;
  for (var i = 0; i < offset; ++i) {
  this[fcn]();
  }
  }

  _moveSelectionMeasure(offset) {
  var selection = this.getExtremeSelection(Math.sign(offset));
  selection = JSON.parse(JSON.stringify(selection.selector));
  selection.measure += offset;
  selection.tick = 0;
  var selObj = this._getClosestTick(selection);
  if (selObj) {
  this.selections = [selObj];
  }
  this.highlightSelection();
    this._createLocalModifiersList();
  }

    setSelection(selection) {
        var selObj = this._getClosestTick(selection);
        if (selObj) {
  this.selections = [selObj];
  }
  this.highlightSelection();
    }

  _moveStaffOffset(offset) {
  if (this.selections.length == 0) {
  return;
  }

  var nselector = JSON.parse(JSON.stringify(this.selections[0].selector));
  nselector.staff = this.score.incrementActiveStaff(offset);
  this.selections = [this._getClosestTick(nselector)];
  this.highlightSelection();
    this._createLocalModifiersList();
  }

  // ### _moveSelectionPitch
  // Suggest a specific pitch in a chord, so we can transpose just the one note vs. the whole chord.
  _moveSelectionPitch(index) {
  if (!this.selections.length) {
  return;
  }
  var sel = this.selections[0];
  var note = sel.note;
  if (note.pitches.length < 2) {
  this.pitchIndex = -1;
  return;
  }
  this.pitchIndex = (this.pitchIndex + index) % note.pitches.length;
  sel.selector.pitches = [];
  sel.selector.pitches.push(this.pitchIndex);
  this._highlightPitchSelection(note, this.pitchIndex);
  }
  moveSelectionPitchUp() {
  this._moveSelectionPitch(1);
  }
  moveSelectionPitchDown() {
  if (!this.selections.length) {
  return;
  }
  this._moveSelectionPitch(this.selections[0].note.pitches.length - 1);
  }

  moveSelectionUp() {
  this._moveStaffOffset(-1);
  }
  moveSelectionDown() {
  this._moveStaffOffset(1);
  }

  containsArtifact() {
  return this.selections.length > 0;
  }

  _replaceSelection(nselector,skipPlay) {
  var artifact = SmoSelection.noteSelection(this.score, nselector.staff, nselector.measure, nselector.voice, nselector.tick);
        if (!artifact) {
            artifact = SmoSelection.noteSelection(this.score, nselector.staff, nselector.measure, 0, nselector.tick);
        }
        if (!artifact) {
            artifact = SmoSelection.noteSelection(this.score, nselector.staff, nselector.measure, 0,0);
        }
        if (!artifact) {
            console.log('warn: selection disappeared, default to start');
            artifact = SmoSelection.noteSelection(this.score,0,0,0,0);
        }
        if (!skipPlay) {
            suiOscillator.playSelectionNow(artifact);
        }

        // clear modifier selections
        this.clearModifierSelections();
  this.score.setActiveStaff(nselector.staff);
        var mapKey = Object.keys(this.measureNoteMap).find((k) => {
            return SmoSelector.sameNote(this.measureNoteMap[k].selector, artifact.selector);
        });
        if (!mapKey) {
            return;
        }
  var mapped = this.measureNoteMap[mapKey];

  // If this is a new selection, remove pitch-specific and replace with note-specific
  if (!nselector['pitches'] || nselector.pitches.length==0) {
  this.pitchIndex = -1;
  }
  // console.log('adding selection ' + mapped.note.id);

  this.selections = [mapped];
  this.highlightSelection();
        this._createLocalModifiersList();
  }

  getFirstMeasureOfSelection() {
  if (this.selections.length) {
  return this.selections[0].measure;
  }
  return null;
  }
  // ## measureIterator
  // Description: iterate over the any measures that are part of the selection
  getSelectedMeasures() {
  var set = [];
        var rv = [];
  this.selections.forEach((sel) => {
  var measure = SmoSelection.measureSelection(this.score, sel.selector.staff, sel.selector.measure).measure;
  var ix = measure.measureNumber.measureIndex;
  if (set.indexOf(ix) === -1) {
  set.push(ix);
  rv.push(measure);
  }
  });
        return rv;

  }

  _selectFromToInStaff(sel1,sel2) {
  this.selections=[];
        var order = [sel1,sel2].sort((a,b) => {return SmoSelector.lteq(a.selector,b.selector) ? -1 : 1});

        // TODO: we could iterate directly over the selectors, that would be faster
        Object.keys(this.measureNoteMap).forEach((k) => {
            var obj = this.measureNoteMap[k];
            if (SmoSelector.gteq(obj.selector,order[0].selector) && SmoSelector.lteq(obj.selector,order[1].selector)) {
                this.selections.push(obj);
            }
        });
  }
  _addSelection(selection) {
  var ar=this.selections.filter((sel) => {
  return SmoSelector.neq(sel.selector,selection.selector);
  });
        suiOscillator.playSelectionNow(selection);

  ar.push(selection);
  this.selections=ar;
  }

  selectSuggestion(ev) {
  if (!this.suggestion['measure']) {
  return;
  }
  // console.log('adding selection ' + this.suggestion.note.id);

  if (this.modifierSuggestion >= 0) {
  if (this['suggestFadeTimer']) {
     clearTimeout(this.suggestFadeTimer);
      }
  this.modifierIndex = -1;
      this.modifierSelections = [this.modifierTabs[this.modifierSuggestion]];
  this.modifierSuggestion = -1;
  this._highlightModifier();
  return;
  } else if (ev.type === 'click') {
      this.clearModifierSelections(); // if we click on a non-modifier, clear the
      // modifier selections
    }

  if (ev.shiftKey) {
  var sel1 = this.getExtremeSelection(-1);
  if (sel1.selector.staff === this.suggestion.selector.staff) {
  var min = SmoSelector.gt(sel1.selector,this.suggestion.selector)  ? this.suggestion : sel1;
  var max = SmoSelector.lt(min.selector,this.suggestion.selector) ? this.suggestion : sel1;
  this._selectFromToInStaff(min,max);
                this._createLocalModifiersList();
  this.highlightSelection();
  return;
  }
  }

  if (ev.ctrlKey) {
  this._addSelection(this.suggestion);
            this._createLocalModifiersList();
  this.highlightSelection();
  return;
  }

    suiOscillator.playSelectionNow(this.suggestion);

    var preselected = this.selections[0] ? SmoSelector.sameNote(this.suggestion.selector,this.selections[0].selector) && this.selections.length == 1 : false;

    if (preselected && this.selections[0].note.pitches.length > 1) {
        this.pitchIndex =  (this.pitchIndex + 1) % this.selections[0].note.pitches.length;
        this.selections[0].selector.pitches = [this.pitchIndex];
    } else {
        this.selections = [this.suggestion];
    }
    if (preselected && this.modifierTabs.length) {
        var mods  = this.modifierTabs.filter((mm) => mm.selection && SmoSelector.sameNote(mm.selection.selector,this.selections[0].selector));
      if (mods.length) {
        this.modifierSelections[0] = mods[0];
        this.modifierIndex = mods[0].index;
        this._highlightModifier();
        return;
      }
    }
  this.score.setActiveStaff(this.selections[0].selector.staff);
  if (this.selections.length == 0)
  return;
  var first = this.selections[0];
  for (var i = 0; i < this.selections.length; ++i) {
  var selection = this.selections[i];
  this.highlightSelection();
  }
    this._createLocalModifiersList();
  }

  static get strokes() {
  return {
  'suggestion': {
  'stroke': '#fc9',
  'stroke-width': 2,
  'stroke-dasharray': '4,1',
  'fill': 'none'
  },
  'selection': {
  'stroke': '#99d',
  'stroke-width': 2,
  'fill': 'none'
  },
  'staffModifier': {
  'stroke': '#933',
  'stroke-width': 2,
  'fill': 'none'
  }
  }
  }

  _setFadeTimer() {
  if (this['suggestFadeTimer']) {
  clearTimeout(this.suggestFadeTimer);
  }
  var tracker=this;
  this.suggestFadeTimer = setTimeout(function () {
  if (tracker.containsArtifact()) {
  tracker.eraseRect('suggestion');
  tracker.modifierSuggestion=-1;
  }
  }, 1000);
  }


    _setModifierAsSuggestion(bb,artifact) {

  this.modifierSuggestion = artifact.index;

  this._drawRect(artifact.box, 'suggestion');
  this._setFadeTimer();
  }
  _setArtifactAsSuggestion(bb, artifact) {
  var self = this;

  var sameSel =
  this.selections.find((ss) => SmoSelector.sameNote(ss.selector, artifact.selector));

  if (sameSel) {
  return ;
  }

  this.modifierSuggestion = -1;

  this.suggestion = artifact;
  this._drawRect(artifact.box, 'suggestion');
  this._setFadeTimer();
  }


  eraseAllSelections() {
  var strokeKeys = Object.keys(suiTracker.strokes);
  strokeKeys.forEach((key) => {
  this.eraseRect(key);
  });
  }

  eraseRect(stroke) {
  $(this.renderElement).find('g.vf-' + stroke).remove();
  }

  _highlightModifier() {
    if (!this.modifierSelections.length) {
      return;
    }
    var box=null;
    this.modifierSelections.forEach((artifact) => {
      if (!box) {
        box = artifact.modifier.renderedBox;
      }
      else {
        box = svgHelpers.unionRect(box,artifact.modifier.renderedBox);
      }
    });
    this._drawRect(box, 'staffModifier');
  }

  _highlightPitchSelection(note, index) {
  this.eraseAllSelections();
  var noteDiv = $(this.renderElement).find('#' + note.renderId);
  var heads = noteDiv.find('.vf-notehead');
  if (!heads.length) {
  return;
  }
  var headEl = heads[index];
  var box = svgHelpers.adjustScroll(svgHelpers.smoBox(headEl.getBoundingClientRect()),
          this.scroller.invScroll);
  this._drawRect(box, 'staffModifier');
  }

  _highlightActiveVoice(selection) {
    var selector = selection.selector;
    for (var i =1;i<=4;++i) {
        var cl = 'v'+i.toString()+'-active';
        $('body').removeClass(cl);
    }
    var cl = 'v'+(selector.voice + 1).toString()+'-active';
    $('body').addClass(cl);
  }

  highlightSelection() {
        var grace = this.getSelectedGraceNotes();
        // If this is not a note with grace notes, logically unselect the grace notes
        if (grace.length) {
            if (!SmoSelector.sameNote(grace[0].selection.selector,this.selections[0].selector)) {
                this.clearModifierSelections();
            } else {
                this._highlightModifier();
                return;
            }
        }
  if (this.pitchIndex >= 0 && this.selections.length == 1 &&
  this.pitchIndex < this.selections[0].note.pitches.length) {
  this._highlightPitchSelection(this.selections[0].note, this.pitchIndex);
            this._highlightActiveVoice(this.selections[0]);
  return;
  }
  this.pitchIndex = -1;
  this.eraseAllSelections();
  if (this.selections.length === 1 && this.selections[0].box) {
  this._checkBoxOffset();
  this._drawRect(this.selections[0].box, 'selection');
            this._highlightActiveVoice(this.selections[0]);
  return;
  }
  var sorted = this.selections.sort((a, b) => SmoSelector.gt(a.selector,b.selector) ? 1 : -1);
  var prevSel = sorted[0];
        // rendered yet?
        if (!prevSel.box)
            return;
  var curBox = svgHelpers.smoBox(prevSel.box);
  var boxes = [];
  for (var i = 1; i < sorted.length; ++i) {
  var sel = sorted[i];
  var ydiff = Math.abs(prevSel.box.y - sel.box.y);
  if (sel.selector.staff === prevSel.selector.staff && ydiff < 1.0) {
  curBox = svgHelpers.unionRect(curBox, sel.box);
  } else {
  boxes.push(curBox);
  curBox = sel.box;
  }
            this._highlightActiveVoice(sel);
  prevSel = sel;
  }
  boxes.push(curBox);
  this._drawRect(boxes, 'selection');
  }
  _suggestionParameters(box,strokeName) {
    const outlineStroke = suiTracker.strokes[strokeName];
    return {
      context: this.context, box: box,classes: strokeName,
         outlineStroke, scroller: this.scroller
    }
  }

  _drawRect(bb, stroke) {
    svgHelpers.outlineRect(this._suggestionParameters(bb,stroke));
  }
}
;
class layoutDebug {
    static get values() {
        return {
            pre:1,
            post:2,
            adjust:4,
            system:8,
            note:16,
            adjustHeight:32,
            measureHistory:64,
            textEditorHistory:128,
            dialogEvents:256
        }
    }

    static get classes() {
        return {
            pre:'measure-place-dbg',
            post:'measure-render-dbg',
            adjust:'measure-adjust-dbg',
            system:'system-place-dbg',
            note:'measure-note-dbg',
            adjustHeight:'measure-adjustHeight-dbg',
            measureHistory:'',
            textEditorHistory:'',
            dialogEvents:''
        }
    }

	static get mask() {
        if (typeof(layoutDebug._flags) == 'undefined') {
            layoutDebug._flags = 0;
        }
        return layoutDebug._flags;
	}

    static set mask(value) {
        layoutDebug._flags = value;
    }

    static flagSet(value) {
        return layoutDebug.mask & layoutDebug.values[value];
    }

    static clearAll(svg) {
        layoutDebug._flags = 0;
    }
    static setAll() {
        layoutDebug._flags = 1+2+4+8+16+32+64+128+256;
    }
    static setRenderFlags() {
      layoutDebug._flags = 1+2+4+8+16+32;
    }
    static clearDebugBoxes(value) {
        if (layoutDebug.flagSet(value)) {
            var selector = 'g.'+layoutDebug.classes[value];
            $(selector).remove();
        }
    }
    static debugBox(svg,box,flag) {
        if (!box) {
            return;
        }
        if (!box.height) {
            box.height=1;
        }
        if (layoutDebug.flagSet(flag)) {
            svgHelpers.debugBox(svg, box, layoutDebug.classes[flag]);
        }
    }
    static clearFlag(value) {
        clearFlagSvg(value);

        var flag = layoutDebug.values[value];
        if (typeof(layoutDebug._flags) == 'undefined') {
            layoutDebug._flags = 0;
        }
        layoutDebug._flags = layoutDebug._flags & (~flag);
    }

	static setFlag(value) {
        var flag = layoutDebug.values[value];
        if (typeof(layoutDebug._flags) == 'undefined') {
            layoutDebug._flags = flag;
            return;
        }
        layoutDebug._flags |= flag;
	}

    static get textDebug() {
        if (!layoutDebug['_textDebug']) {
            layoutDebug['_textDebug'] = [];
        }
        return layoutDebug['_textDebug']
    }

    static addTextDebug(value) {
        if (!layoutDebug.mask & layoutDebug.textEditorHistory) {
            return;
        }
        if (!layoutDebug['_textDebug']) {
            layoutDebug['_textDebug'] = [];
        }
        layoutDebug['_textDebug'].push(value);
        console.log(value);
    }

    static addDialogDebug(value) {
      if (!layoutDebug.mask & layoutDebug.dialogEvents) {
          return;
      }
      if (!layoutDebug['_dialogEvents']) {
          layoutDebug['_dialogEvents'] = [];
      }
      layoutDebug['_dialogEvents'].push(value);
      console.log(value);
    }

    static measureHistory(measure,oldVal,newVal,description) {
        if (layoutDebug.flagSet('measureHistory')) {
            var oldExp = (typeof(measure.svg[oldVal]) == 'object') ? JSON.stringify(measure.svg[oldVal]).replace(/"/g,'') : measure.svg[oldVal];
            var newExp = (typeof(newVal) == 'object') ? JSON.stringify(newVal).replace(/"/g,'') : newVal;
            measure.svg.history.push(oldVal + ': '+oldExp +'=> '+newExp + ' ' + description);
        }
    }
}
;
// ## suiLayoutBase
// ## Description:
// A layout maps the measures and notes to a spot on the page.  It
// manages the flow of music as an ordinary score.  We call it simple layout, because
// there may be other layouts for parts view, or output to other media.
class suiLayoutBase {
	constructor(ctor) {
		this.attrs = {
			id: VF.Element.newID(),
			type: ctor
		};
		this.dirty=true;
    this.replaceQ=[];
    this.renderTime=250;  // ms to render before time slicing
    this.partialRender = false;
    this.stateRepCount=0;
    this.viewportPages = 1;
		this.setPassState(suiLayoutBase.initial,'ctor');
		console.log('layout ctor: pstate initial');
		this.viewportChanged = false;
    this._resetViewport = false;
    this.measureMapper = null;
	}

  setMeasureMapper(mapper) {
    this.measureMapper = mapper;
  }

  static get Fonts() {
    return {
      Bravura: [VF.Fonts.Bravura, VF.Fonts.Gonville, VF.Fonts.Custom],
      Gonville: [VF.Fonts.Gonville, VF.Fonts.Bravura, VF.Fonts.Custom],
      Petaluma: [VF.Fonts.Petaluma, VF.Fonts.Gonville, VF.Fonts.Custom]
    };
  }

  static setFont(font) {
    VF.DEFAULT_FONT_STACK=suiLayoutBase.Fonts[font];
  }

	static get passStates() {
		return {initial:0,clean:2,replace:3};
	}

  addToReplaceQueue(selection) {
    if (this.passState == suiLayoutBase.passStates.clean ||
      this.passState == suiLayoutBase.passStates.replace) {
      if (Array.isArray(selection)) {
        this.replaceQ = this.replaceQ.concat(selection);
      } else {
        this.replaceQ.push(selection)
      }
      this.setDirty();
   }
  }

  _partialRenderCondition() {

  }


	setDirty() {
		if (!this.dirty) {
			this.dirty = true;
			if (this.passState == suiLayoutBase.passStates.clean) {
        this.setPassState(suiLayoutBase.passStates.replace);
			}
		}
	}
	setRefresh() {
		this.dirty=true;
		this.setPassState(suiLayoutBase.passStates.initial,'setRefresh');
	}
  rerenderAll() {
    this.dirty=true;
  	this.setPassState(suiLayoutBase.passStates.initial,'rerenderAll');
    this._resetViewport = true;
  }

  remapAll() {
    this.partialRender = false;
    this.setRefresh();
  }

  numberMeasures() {
    var staff = this.score.staves[0];
    var measures = staff.measures.filter((measure) => measure.measureNumber.systemIndex == 0);
    $('.measure-number').remove();
    var printing = $('body').hasClass('print-render');

    measures.forEach((measure) => {
      var at = [];
      if (measure.measureNumber.measureNumber > 0 && measure.measureNumber.systemIndex == 0) {
        at.push({y:measure.logicalBox.y - 10});
        at.push({x:measure.logicalBox.x});
        at.push({fontFamily:'Helvitica'});
        at.push({fontSize:'8pt'});
        svgHelpers.placeSvgText(this.context.svg,at,'measure-number',(measure.measureNumber.measureNumber + 1).toString());

        var formatIndex = SmoMeasure.systemOptions.findIndex((option) => measure[option] != SmoMeasure.defaults[option]);
        if (formatIndex >= 0 && !printing) {
          var at=[];
          at.push({y:measure.logicalBox.y - 5});
          at.push({x:measure.logicalBox.x + 25});
          at.push({fontFamily:'Helvitica'});
          at.push({fontSize:'8pt'});
          svgHelpers.placeSvgText(this.context.svg,at,'measure-format','&#x21b0;');
        }
      }
    });
  }

	_setViewport(reset,elementId) {
		// this.screenWidth = window.innerWidth;
		var layout = this._score.layout;
		this.zoomScale = layout.zoomMode === SmoScore.zoomModes.zoomScale ?
			layout.zoomScale : (window.innerWidth - 200) / layout.pageWidth;

		if (layout.zoomMode != SmoScore.zoomModes.zoomScale) {
			layout.zoomScale = this.zoomScale;
		}

		this.svgScale = layout.svgScale * this.zoomScale;
		this.orientation = this._score.layout.orientation;
		var w = Math.round(layout.pageWidth * this.zoomScale) ;
		var h = Math.round(layout.pageHeight * this.zoomScale);
		this.pageWidth =  (this.orientation  === SmoScore.orientations.portrait) ? w: h;
		this.pageHeight = (this.orientation  === SmoScore.orientations.portrait) ? h : w;
        this.totalHeight = this.pageHeight * this.score.layout.pages;
        this.viewportPages = this.score.layout.pages;

		this.leftMargin=this._score.layout.leftMargin;
        this.rightMargin = this._score.layout.rightMargin;
		$(elementId).css('width', '' + Math.round(this.pageWidth) + 'px');
		$(elementId).css('height', '' + Math.round(this.totalHeight) + 'px');
		if (reset) {
		    $(elementId).html('');
    		this.renderer = new VF.Renderer(elementId, VF.Renderer.Backends.SVG);
            this.viewportChanged = true;
            if (this.measureMapper) {
                this.measureMapper.scroller.scrollAbsolute(0,0);
            }
		}
		// this.renderer.resize(this.pageWidth, this.pageHeight);

		svgHelpers.svgViewport(this.context.svg, 0, 0, this.pageWidth, this.totalHeight, this.svgScale);

		this.context.setFont(this.font.typeface, this.font.pointSize, "").setBackgroundFillStyle(this.font.fillStyle);
		this.resizing = false;
		console.log('layout setViewport: pstate initial');
		this.dirty=true;
    suiLayoutBase._renderer = this.renderer;
	}

  setViewport(reset) {
    this._setViewport(reset,this.elementId);
    this.score.staves.forEach((staff) => {
      staff.measures.forEach((measure) => {
        if (measure.logicalBox && reset) {
          measure.svg.history=['reset'];
          // measure.deleteLogicalBox('reset viewport');
        }
      });
    });
    this.partialRender = false;
  }
  renderForPrintPromise() {
    $('body').addClass('print-render');
    var self = this;
    // layout.setViewport(true);
    this._backupLayout = JSON.parse(JSON.stringify(this.score.layout));
    this.score.layout.zoomMode = SmoScore.zoomModes.zoomScale;
    this.score.layout.zoomScale = 1.0;
    this.setViewport(true);
    this.setRefresh();
    var self = this;

    var promise = new Promise((resolve) => {
      var poll = () => {
        setTimeout(() => {
          if (!self.dirty) {
             // tracker.highlightSelection();
             $('body').removeClass('print-render');
             $('.vf-selection').remove();
             $('body').addClass('printing');
             $('.musicRelief').css('height','');
             resolve();
          } else {
            poll();
          }
        },500);
      }
      poll();
    });
    return promise;
  }

  restoreLayoutAfterPrint() {
    if (this._backupLayout) {
      this.score.layout  = this._backupLayout;
      this.setViewport(true);
      this.setRefresh();
      this._backupLayout = null;
    }
  }

  clearLine(measure) {
    var lineIndex = measure.lineIndex;
    var startIndex = (lineIndex > 1 ? lineIndex - 1: 0);
    for (var i = startIndex;i<lineIndex+1;++i) {
      this.score.staves.forEach((staff) => {
        var mms = staff.measures.filter((mm) => mm.lineIndex === i);
        mms.forEach((mm) => {
          delete mm.logicalBox;
        });
      });
    }
  }

	setPassState(st,location) {
    var oldState = this.passState;
    if (oldState != st) {
      this.stateRepCount = 0;
    } else {
      this.stateRepCount += 1;
    }

    var msg = location + ': passState '+this.passState+'=>'+st;
    if (this.stateRepCount > 0) {
      msg += ' ('+this.stateRepCount+')';
    }
		console.log(msg);
		this.passState = st;
	}
	static get defaults() {
		return {
			clefWidth: 70,
			staffWidth: 250,
			totalWidth: 250,
			leftMargin: 15,
			topMargin: 15,
			pageWidth: 8 * 96 + 48,
			pageHeight: 11 * 96,
			svgScale: 0.7,
			font: {
				typeface: "Arial",
				pointSize: 10,
				fillStyle: '#eed'
			}
		};
	}

	static get debugLayout() {
		suiLayoutBase['_debugLayout'] = suiLayoutBase['_debugLayout'] ? suiLayoutBase._debugLayout : false
		return suiLayoutBase._debugLayout;
	}

	static set debugLayout(value) {
		suiLayoutBase._debugLayout = value;
      if (value) {
        $('body').addClass('layout-debug');
      } else {
        $('body').removeClass('layout-debug');
      }
	}

	// ### get context
	// ### Description:
	// return the VEX renderer context.
	get context() {
		return this.renderer.getContext();
	}
	get renderElement() {
		return this.renderer.elementId;
	}

	get svg() {
		return this.context.svg;
	}

  get score() {
    return this._score;
  }

  set score(score) {
    var shouldReset = false;
    if (this._score) {
      shouldReset = true;
    }
    this.setPassState(suiLayoutBase.passStates.initial,'load score');
    suiLayoutBase.setFont(score.engravingFont);
    this.dirty=true;
    this._score = score;
    if (shouldReset) {
      if (this.measureMapper) {
        this.measureMapper.loadScore();
      }
      this.setViewport(true);
    }
  }


	// ### render
	// ### Description:
	// Render the current score in the div using VEX.  Rendering is actually done twice:
	// 1. Rendering is done just to the changed parts of the score.  THe first time, the whole score is rendered.
	// 2. Widths and heights are adjusted for elements that may have overlapped or exceeded their expected boundary.
	// 3. The whole score is rendered a second time with the new values.


	// ### undo
	// ### Description:
	// Undo is handled by the layout, because the layout has to first delete areas of the div that may have changed
	// , then create the modified score, then render the 'new' score.
	undo(undoBuffer) {
		var buffer = undoBuffer.peek();
		var op = 'setDirty';
		// Unrender the modified music because the IDs may change and normal unrender won't work
		if (buffer) {
			var sel = buffer.selector;
			if (buffer.type == 'measure') {
				this.unrenderMeasure(SmoSelection.measureSelection(this._score, sel.staff, sel.measure).measure);
			} else if (buffer.type === 'staff') {
				this.unrenderStaff(SmoSelection.measureSelection(this._score, sel.staff, 0).staff);
				op = 'setRefresh';
			} else {
				this.unrenderAll();
				op = 'setRefresh';
			}
			this._score = undoBuffer.undo(this._score);
			this[op]();
		}
	}

	// ### renderNoteModifierPreview
	// ### Description:
	// For dialogs that allow you to manually modify elements that are automatically rendered, we allow a preview so the
	// changes can be undone before the buffer closes.
	renderNoteModifierPreview(modifier,selection) {
		var selection = SmoSelection.noteSelection(this._score, selection.selector.staff, selection.selector.measure, selection.selector.voice, selection.selector.tick);
		if (!selection.measure.renderedBox) {
			return;
		}
		var system = new VxSystem(this.context, selection.measure.staffY, selection.measure.lineIndex,this.score);
		system.renderMeasure(selection.measure,this.mapper);
	}

    // ### renderNoteModifierPreview
	// ### Description:
	// For dialogs that allow you to manually modify elements that are automatically rendered, we allow a preview so the
	// changes can be undone before the buffer closes.
	renderMeasureModifierPreview(modifier,measure) {
        var ix = measure.measureNumber.measureIndex;
        this._score.staves.forEach((staff) => {
            var cm = staff.measures[ix];
    		var system = new VxSystem(this.context, cm.staffY, cm.lineIndex,this.score);
            system.renderMeasure(staff.staffId, cm);
        });
	}

	// ### renderStaffModifierPreview
	// ### Description:
	// Similar to renderNoteModifierPreview, but lets you preveiw a change to a staff element.
	// re-render a modifier for preview during modifier dialog
	renderStaffModifierPreview(modifier) {
		// get the first measure the modifier touches
		var startSelection = SmoSelection.measureSelection(this._score, modifier.startSelector.staff, modifier.startSelector.measure);

		// We can only render if we already have, or we don't know where things go.
		if (!startSelection.measure.renderedBox) {
			return;
		}
		var system = new VxSystem(this.context, startSelection.measure.staffY, startSelection.measure.lineIndex,this.score);
		while (startSelection && startSelection.selector.measure <= modifier.endSelector.measure) {
			smoBeamerFactory.applyBeams(startSelection.measure);
      system.renderMeasure(startSelection.measure,null,true);
      this._renderModifiers(startSelection.staff, system);

			var nextSelection = SmoSelection.measureSelection(this._score, startSelection.selector.staff, startSelection.selector.measure + 1);

			// If we go to new line, render this line part, then advance because the modifier is split
			if (nextSelection && nextSelection.measure && nextSelection.measure.lineIndex != startSelection.measure.lineIndex) {
				this._renderModifiers(startSelection.staff, system);
				var system = new VxSystem(this.context, startSelection.measure.staffY, startSelection.measure.lineIndex,this.score);
			}
			startSelection = nextSelection;
		}
		// this._renderModifiers(startSelection.staff, system);
	}

	// ### unrenderMeasure
	// ### Description:
	// All SVG elements are associated with a logical SMO element.  We need to erase any SVG element before we change a SMO
	// element in such a way that some of the logical elements go away (e.g. when deleting a measure).
	unrenderMeasure(measure) {
		if (!measure)
			return;

		$(this.renderer.getContext().svg).find('g.' + measure.getClassId()).remove();
		measure.setYTop(0,'unrender');
		measure.setChanged();
	}

    unrenderColumn(measure) {
        this.score.staves.forEach((staff) => {
            this.unrenderMeasure(staff.measures[measure.measureNumber.measureIndex]);
        });
    }

	// ### unrenderStaff
	// ### Description:
	// See unrenderMeasure.  Like that, but with a staff.
	unrenderStaff(staff) {
		staff.measures.forEach((measure) => {
			this.unrenderMeasure(measure);
		});
		staff.modifiers.forEach((modifier) => {
			$(this.renderer.getContext().svg).find('g.' + modifier.attrs.id).remove();
		});
	}


	// ### _renderModifiers
	// ### Description:
	// Render staff modifiers (modifiers straddle more than one measure, like a slur).  Handle cases where the destination
	// is on a different system due to wrapping.
	_renderModifiers(staff, system) {
		var svg = this.svg;
		staff.modifiers.forEach((modifier) => {
			var startNote = SmoSelection.noteSelection(this._score,
					modifier.startSelector.staff, modifier.startSelector.measure, modifier.startSelector.voice, modifier.startSelector.tick);
			var endNote = SmoSelection.noteSelection(this._score,
					modifier.endSelector.staff, modifier.endSelector.measure, modifier.endSelector.voice, modifier.endSelector.tick);
            if (!startNote || !endNote) {
                console.log('missing modifier...');
                return;
            }

			var vxStart = system.getVxNote(startNote.note);
			var vxEnd = system.getVxNote(endNote.note);

			// If the modifier goes to the next staff, draw what part of it we can on this staff.
			if (vxStart && !vxEnd) {
				var nextNote = SmoSelection.nextNoteSelection(this._score,
						modifier.startSelector.staff, modifier.startSelector.measure, modifier.startSelector.voice, modifier.startSelector.tick);
				var testNote = system.getVxNote(nextNote.note);
				while (testNote) {
					vxEnd = testNote;
					nextNote = SmoSelection.nextNoteSelection(this._score,
							nextNote.selector.staff, nextNote.selector.measure, nextNote.selector.voice, nextNote.selector.tick);
                    // last beat of the measure
                    if (!nextNote) {
                        break;
                    }
					testNote = system.getVxNote(nextNote.note);

				}
			}
			if (vxEnd && !vxStart) {
				var lastNote = SmoSelection.lastNoteSelection(this._score,
						modifier.endSelector.staff, modifier.endSelector.measure, modifier.endSelector.voice, modifier.endSelector.tick);
				var testNote = system.getVxNote(lastNote.note);
				while (testNote) {
					vxStart = testNote;
					lastNote = SmoSelection.lastNoteSelection(this._score,
							lastNote.selector.staff, lastNote.selector.measure, lastNote.selector.voice, lastNote.selector.tick);
                    if (!lastNote) {
                        break;
                    }
					testNote = system.getVxNote(lastNote.note);
				}
			}

			if (!vxStart && !vxEnd)
				return;

			// TODO: notes may have changed, get closest if these exact endpoints don't exist
			modifier.renderedBox = system.renderModifier(modifier, vxStart, vxEnd,startNote,endNote);
			modifier.logicalBox = svgHelpers.clientToLogical(svg,modifier.renderedBox);

			// TODO: consider staff height with these.
			// TODO: handle dynamics split across systems.
		});

        // Note: this is done elsewhere, after system is rendered.
		// system.updateLyricOffsets();
	}

  _drawPageLines() {
    $(this.context.svg).find('.pageLine').remove();
    var printing = $('body').hasClass('print-render');
    if (printing) {
      return;
    }
    for (var i=1;i<this._score.layout.pages;++i) {
      var y = (this.pageHeight/this.svgScale)*i;
      svgHelpers.line(this.svg,0,y,this.score.layout.pageWidth/this.score.layout.svgScale,y,
        [
          {'stroke': '#321'},
          {'stroke-width': '2'},
          {'stroke-dasharray': '4,1'},
          {'fill': 'none'}],'pageLine');
    }
  }

  _replaceMeasures() {
    var rendered = {};
    this.replaceQ.forEach((change) => {
      smoBeamerFactory.applyBeams(change.measure);
      var system = new VxSystem(this.context, change.measure.staffY, change.measure.lineIndex,this.score);
      var selections = SmoSelection.measuresInColumn(this.score,change.measure.measureNumber.measureIndex);
      selections.forEach((selection) => {
        system.renderMeasure(selection.measure,this.measureMapper);
      });
      system.renderEndings();
      this._renderModifiers(change.staff, system);
      system.updateLyricOffsets();

      // Fix a bug: measure change needs to stay true so we recaltulate the width
      change.measure.changed = true;
    });
    this.replaceQ = [];
  }

  // ### forceRender
  // For unit test applictions that want to render right-away
  forceRender() {
    this.setRefresh();
    this.render();
  }

	render() {
        if (this._resetViewport) {
            this.setViewport(true);
            this._resetViewport = false;
        }

		// layout iteratively until we get it right, adjusting X each time.
        if (suiLayoutBase.passStates.replace == this.passState) {
            this._replaceMeasures();
        } else if (suiLayoutBase.passStates.initial == this.passState) {
           this.layout();
           this._drawPageLines();
           this.setPassState(suiLayoutBase.passStates.clean);
        }
        this.dirty = false;

	}
}
;
class suiPiano {
	constructor(parameters) {
    Vex.Merge(this, parameters);
		this.renderElement = document.getElementById('piano-svg');
		this.selections = [];
		this.render();
    this.octaveOffset = 0;
    this.chordPedal = false;
	}

	static get dimensions() {
		return {
			wwidth: 23,
			bwidth: 13,
			wheight: 120,
			bheight: 80,
			octaves:1
		};
	}
		// 7 white keys per octave
	static get wkeysPerOctave() {
		return 7;
	}
	static get owidth() {
		return suiPiano.dimensions.wwidth * suiPiano.wkeysPerOctave;
	}

	static createAndDisplay(parms) {
		// Called by ribbon button.
		// $('body').toggleClass('show-piano');
        $('body').trigger('show-piano-event');
		$('body').trigger('forceScrollEvent');
		// handle resize work area.
	}
	_mapKeys() {
		this.objects = [];
		var keys = [].slice.call(this.renderElement.getElementsByClassName('piano-key'));
		keys.forEach((key) => {
			var rect = svgHelpers.smoBox(key.getBoundingClientRect());
			var id = key.getAttributeNS('', 'id');
			var artifact = {
				keyElement: key,
				box: rect,
				id: id
			};
			this.objects.push(artifact);
		});
	}
	_removeClass(classes) {
		Array.from(this.renderElement.getElementsByClassName('piano-key')).forEach((el) => {
			$(el).removeClass(classes);
		});
	}
	_removeGlow() {
		this._removeClass('glow-key');
	}
	_fadeGlow(el) {
		if (this['suggestFadeTimer']) {
			clearTimeout(this.suggestFadeTimer);
		}
		// Make selection fade if there is a selection.
		this.suggestFadeTimer = setTimeout(function () {
				$(el).removeClass('glow-key');
			}, 1000);
	}
	bind() {
		var self = this;
    $('body').off('show-piano-event').on('show-piano-event',function() {
        $('body').toggleClass('show-piano');
        self._mapKeys();
    });
    $('#piano-8va-button').off('click').on('click',function() {
      $('#piano-8vb-button').removeClass('activated');
      if (self.octaveOffset === 0) {
        $(this).addClass('activated');
        self.octaveOffset = 1;
      } else {
        $(this).removeClass('activated');
        self.octaveOffset = 0;
      }
    });
    $('#piano-8vb-button').off('click').on('click',function() {
      $('#piano-8va-button').removeClass('activated');
      if (self.octaveOffset === 0) {
        $(this).addClass('activated');
        self.octaveOffset = -1;
      } else {
        $(this).removeClass('activated');
        self.octaveOffset = 0;
      }
    });
    $('#piano-xpose-up').off('click').on('click',function() {
      self.editor.transposeUp();
    });
    $('#piano-xpose-down').off('click').on('click',function() {
      self.editor.transposeDown();
    });
    $('#piano-enharmonic').off('click').on('click',function() {
      self.editor.toggleEnharmonic();
    });
    $('button.jsLeft').off('click').on('click',function() {
      self.tracker.moveSelectionLeft();
    });
    $('button.jsRight').off('click').on('click',function() {
      self.tracker.moveSelectionRight();
    });
    $('button.jsGrowDuration').off('click').on('click',function() {
      self.editor.doubleDuration();
    });
    $('button.jsGrowDot').off('click').on('click',function() {
      self.editor.dotDuration();
    });
    $('button.jsShrinkDuration').off('click').on('click',function() {
      self.editor.halveDuration();
    });
    $('button.jsShrinkDot').off('click').on('click',function() {
      self.editor.undotDuration();
    });
    $('button.jsChord').off('click').on('click',function() {
      $(this).toggleClass('activated');
      self.chordPedal = !self.chordPedal;
    });


  	$(this.renderElement).off('mousemove').on('mousemove', function (ev) {
      if (Math.abs(self.objects[0].box.x - self.objects[0].keyElement.getBoundingClientRect().x)
        > self.objects[0].box.width/2) {
          console.log('remap piano');
          self._mapKeys();
        }
  		var keyPressed = svgHelpers.findSmallestIntersection({
				x: ev.clientX,
				y: ev.clientY
			}, self.objects,{x:0,y:0});
  		if (!keyPressed) {
  			return;
  		}
  		var el = self.renderElement.getElementById(keyPressed.id);
  		if ($(el).hasClass('glow-key')) {
  			return;
  		}
  		self._removeGlow();
  		$(el).addClass('glow-key');
  		self._fadeGlow(el);
  	});
  	$(this.renderElement).off('blur').on('blur',function(ev) {
  		self._removeGlow();
  	});
  	$(this.renderElement).off('click').on('click', function (ev) {
  		self._updateSelections(ev);
  	});

		$('.close-piano').off('click').on('click', function () {
			$('body').removeClass('show-piano');
			// resize the work area.
			$('body').trigger('forceScrollEvent');
		});
	}
	_updateSelections(ev) {
		var keyPressed = svgHelpers.findSmallestIntersection({
				x: ev.clientX,
				y: ev.clientY
			}, this.objects,{x:0,y:0});
		if (!keyPressed) {
			return;
		}
		if (!ev.shiftKey && !this.chordPedal) {
			this.selections = [];
			this._removeClass('glow-key pressed-key');
		} else {
			var el = this.renderElement.getElementById(keyPressed.id);
			$(el).addClass('pressed-key');
		}
		var key = keyPressed.id.substr(6, keyPressed.id.length - 6);
		var pitch = {
			letter: key[0].toLowerCase(),
			octave: parseInt(key[key.length - 1]),
			accidental: key.length == 3 ? key[1] : 'n'
		};
		this.selections.push(pitch);
    this.playNote();
	}
	_renderControls() {
		var b = htmlHelpers.buildDom;
		var r =b('button').classes('icon icon-cross close close-piano');
		$('.piano-container .key-right-ctrl').append(r.dom());
    r = b('button').classes('piano-ctrl jsGrowDuration').append(b('span').classes('icon icon-duration_grow'));
    $('.piano-container .key-right-ctrl').append(r.dom());
    r = b('button').classes('piano-ctrl jsShrinkDuration').append(b('span').classes('icon icon-duration_less'));
    $('.piano-container .key-right-ctrl').append(r.dom());
    r = b('button').classes('piano-ctrl jsGrowDot').append(b('span').classes('icon icon-duration_grow_dot'));
    $('.piano-container .key-right-ctrl').append(r.dom());
    r = b('button').classes('piano-ctrl jsShrinkDot').append(b('span').classes('icon icon-duration_less_dot'));
    $('.piano-container .key-right-ctrl').append(r.dom());

    r = b('button').classes('key-ctrl jsLeft').append(b('span').classes('icon icon-arrow-left'));
    $('.piano-container .piano-keys').prepend(r.dom());
    r = b('button').classes('key-ctrl jsRight').append(b('span').classes('icon icon-arrow-right'));
    $('.piano-container .piano-keys').append(r.dom());

    r = b('button').classes('piano-ctrl').attr('id','piano-8va-button').append(
      b('span').classes('bold-italic').text('8')).append(
        b('sup').classes('italic').text('va'));
    $('.piano-container .key-left-ctrl').append(r.dom());
    r = b('button').classes('piano-ctrl ').attr('id','piano-8vb-button').append(
      b('span').classes('bold-italic').text('8')).append(
        b('sup').classes('italic').text('vb'));
    $('.piano-container .key-left-ctrl').append(r.dom());
    r = b('button').classes('piano-ctrl jsXposeUp').attr('id','piano-xpose-up').append(
      b('span').classes('bold').text('+'));
    $('.piano-container .key-left-ctrl').append(r.dom());
    r = b('button').classes('piano-ctrl jsXposeDown').attr('id','piano-xpose-down').append(
      b('span').classes('bold').text('-'));
    $('.piano-container .key-left-ctrl').append(r.dom());
    r = b('button').classes('piano-ctrl jsEnharmonic').attr('id','piano-enharmonic').append(
      b('span').classes('bold icon icon-accident'));

    $('.piano-container .key-left-ctrl').append(r.dom());
    r = b('button').classes('piano-ctrl jsChord')
      .append(b('span').classes('icon icon-chords'));
    $('.piano-container .key-left-ctrl').append(r.dom());
	}
	handleResize() {
		this._mapKeys();
	}
  playNote() {
    var pitchSel = JSON.parse(JSON.stringify(this.selections));
    this.tracker.selections.forEach((sel) => {
      var ova = SmoMeasure.defaultPitchForClef[sel.measure.clef];
      pitchSel.forEach((pitch) => {
        pitch.octave = ova.octave + this.octaveOffset;
      });
      SmoUndoable.addPitch(sel, pitchSel, this.undoBuffer);
      suiOscillator.playSelectionNow(sel);
    });
    this.tracker.replaceSelectedMeasures();
  }
	render() {
		$('body').addClass('show-piano');
		var b = svgHelpers.buildSvg;
		var d = suiPiano.dimensions;
		// https://www.mathpages.com/home/kmath043.htm

		// Width of white key at back for C,D,E
		var b1off = d.wwidth - (d.bwidth * 2 / 3);

		// Width of other white keys at the back.
		var b2off=d.wwidth-(d.bwidth*3)/4;

		var keyAr = [];
		var xwhite = [{
				note: 'C',
				x: 0
			}, {
				note: 'D',
				x: d.wwidth
			}, {
				note: 'E',
				x: 2 * d.wwidth
			}, {
				note: 'F',
				x: 3 * d.wwidth
			}, {
				note: 'G',
				x: 4 * d.wwidth
			}, {
				note: 'A',
				x: 5 * d.wwidth
			}, {
				note: 'B',
				x: 6 * d.wwidth
			}
		];
		var xblack = [{
				note: 'Db',
				x: b1off
			}, {
				note: 'Eb',
				x: 2*b1off+d.bwidth
			}, {
				note: 'Gb',
				x: 3*d.wwidth+b2off
			}, {
				note: 'Ab',
				x: (3*d.wwidth+b2off)+b2off+d.bwidth
			}, {
				note: 'Bb',
				x: suiPiano.owidth-(b2off+d.bwidth)
			}
		];
		var wwidth = d.wwidth;
		var bwidth = d.bwidth;
		var wheight = d.wheight;
		var bheight = d.bheight;
		var owidth = suiPiano.wkeysPerOctave * wwidth;

		// Start on C2 to C6 to reduce space
		var octaveOff = 7-d.octaves;

		var x = 0;
		var y = 0;
		var r = b('g');
		for (var i = 0; i < d.octaves; ++i) {
			x = i * owidth;
			xwhite.forEach((key) => {
				var nt = key.note; // + (octaveOff + i + 1).toString();
				var classes = 'piano-key white-key';
				if (nt == 'C4') {
					classes += ' middle-c';
				}
				var rect = b('rect').attr('id', 'keyId-' + nt).rect(x + key.x, y, wwidth, wheight, classes);
				r.append(rect);

				var tt = b('text').text(x + key.x + (wwidth / 5), bheight + 16, 'note-text', nt);
				r.append(tt);
			});
			xblack.forEach((key) => {
				var nt = key.note + (octaveOff + i + 1).toString();
				var classes = 'piano-key black-key';
				var rect = b('rect').attr('id', 'keyId-' + nt).attr('fill','url(#piano-grad)').rect(x + key.x, 0, bwidth, bheight, classes);
				r.append(rect);
			});
		}
		var el = document.getElementById(this.elementId);
    svgHelpers.gradient(el,'piano-grad','vertical',[{color:'#000',offset:'0%'},{color:'#777',offset:'50%'},{color:'#ddd',offset:'100%'}]);
		el.appendChild(r.dom());
		this._renderControls();
		this._mapKeys();
		this.bind();
	}
}
;
class SuiLayoutDemon {
  constructor(parameters) {
    this.pollTime = 100;

    this.idleRedrawTime = 2500;
    this.idleLayoutTimer = 0;
    this.undoStatus=0;

    Vex.Merge(this, parameters);
  }

  get isLayoutQuiet() {
		return ((this.layout.passState == suiLayoutBase.passStates.clean && this.layout.dirty == false)
		   || this.layout.passState == suiLayoutBase.passStates.replace);
	}

  handleRedrawTimer() {
    // If there has been a change, redraw the score
  	if (this.undoStatus != this.undoBuffer.opCount || this.layout.dirty) {
  		this.layout.dirty=true;
  		this.undoStatus = this.undoBuffer.opCount;
  		this.idleLayoutTimer = Date.now();
      var state = this.layout.passState;
      // this.tracker.updateMap(); why do this before rendering?

      // indicate the display is 'dirty' and we will be refreshing it.
      $('body').addClass('refresh-1');
      try {
  		  this.render();
      } catch (ex) {
        SuiExceptionHandler.instance.exceptionHandler(ex);
      }
  	} else if (this.layout.passState === suiLayoutBase.passStates.replace) {
  		// Do we need to refresh the score?
  		if (Date.now() - this.idleLayoutTimer > this.idleRedrawTime) {
  			this.layout.setRefresh();
  		}
  	}
}

    // ### pollRedraw
	// if anything has changed over some period, prepare to redraw everything.
	pollRedraw() {
		var self=this;
		setTimeout(function() {
			self.handleRedrawTimer();
			self.pollRedraw();
		},self.pollTime);
	}

  startDemon() {
      this.pollRedraw();
  }

  render() {
		this.layout.render();
    if (this.layout.passState == suiLayoutBase.passStates.clean && this.layout.dirty == false) {
       this.tracker.updateMap();

       // indicate the display is 'clean' and up-to-date with the score
       $('body').removeClass('refresh-1');
    }
	}
}
;
// ## suiAdjuster
// Perform adjustments on the score based on the rendered components so we can re-render it more legibly.
class suiLayoutAdjuster {

	static estimateMusicWidth(smoMeasure) {
		var widths = [];
    var voiceIx = 0;
    var tmObj = smoMeasure.createMeasureTickmaps();
		smoMeasure.voices.forEach((voice) => {
			var tickIndex = 0;
      var width = 0;
      var duration = 0;
      var tm = tmObj.tickmaps[voiceIx];

			voice.notes.forEach((note) => {
        var tuplet = smoMeasure.getTupletForNote(note);
        if (tuplet && tuplet.notes[0].attrs.id === note.attrs.id) {
          // width += vexGlyph.tupletBeam.width + vexGlyph.tupletBeam.spacingRight;
        }
        var noteWidth = 0;
        var dots = (note.dots ? note.dots : 0);
				noteWidth += vexGlyph.dimensions.noteHead.width + vexGlyph.dimensions.noteHead.spacingRight;
				noteWidth += vexGlyph.dimensions.dot.width * dots + vexGlyph.dimensions.dot.spacingRight * dots;
				note.pitches.forEach((pitch) => {
          var keyAccidental = smoMusic.getAccidentalForKeySignature(pitch,smoMeasure.keySignature);
          var accidentals = tmObj.accidentalArray.filter((ar) =>
              ar.duration < duration && ar.pitches[pitch.letter]);
          var acLen = accidentals.length;
          var declared = acLen > 0 ?
              accidentals[acLen - 1].pitches[pitch.letter].pitch.accidental: keyAccidental;

          if (declared != pitch.accidental
              || pitch.cautionary) {
					noteWidth += vexGlyph.accidental(pitch.accidental).width;
				}
			});

      var verse = 0;
      var lyric;
      while (lyric = note.getLyricForVerse(verse,SmoLyric.parsers.lyric)) {
          // TODO: kerning and all that...
          if (!lyric.length) {
              break;
          }
          // why did I make this return an array?
          // oh...because of voices
          var lyricWidth = 7*lyric[0].getText().length + 10;
          noteWidth = Math.max(lyricWidth,noteWidth);
          verse += 1;
        }

  			tickIndex += 1;
        duration += note.tickCount;
        width += noteWidth;
		  });
      voiceIx += 1;
      widths.push(width);
		});
    widths.sort((a,b) => a > b ? -1 : 1);
		return widths[0];
	}

	static estimateStartSymbolWidth(smoMeasure) {
		var width = 0;
		if (smoMeasure.forceKeySignature) {
			if ( smoMeasure.canceledKeySignature) {
			    width += vexGlyph.keySignatureLength(smoMeasure.canceledKeySignature);
			}
            width += vexGlyph.keySignatureLength(smoMeasure.keySignature);
		}
		if (smoMeasure.forceClef) {
			width += vexGlyph.clef(smoMeasure.clef).width + vexGlyph.clef(smoMeasure.clef).spacingRight;
		}
		if (smoMeasure.forceTimeSignature) {
            var digits = smoMeasure.timeSignature.split('/')[0].length;
			width += vexGlyph.dimensions.timeSignature.width*digits + vexGlyph.dimensions.timeSignature.spacingRight;
		}
		var starts = smoMeasure.getStartBarline();
		if (starts) {
			width += vexGlyph.barWidth(starts);
		}
		return width;
	}

	static estimateEndSymbolWidth(smoMeasure) {
		var width = 0;
		var ends  = smoMeasure.getEndBarline();
		if (ends) {
			width += vexGlyph.barWidth(ends);
		}
		return width;
	}


	static estimateTextOffset(renderer,smoMeasure) {
		var leftText = smoMeasure.modifiers.filter((mm) => mm.ctor==='SmoMeasureText' && mm.position === SmoMeasureText.positions.left);
		var rightText = smoMeasure.modifiers.filter((mm) => mm.ctor==='SmoMeasureText' && mm.position === SmoMeasureText.positions.right);
		var svg = renderer.getContext().svg;
		var xoff=0;
		var width=0;
		leftText.forEach((tt) => {
    		var testText = new SmoScoreText({text:tt.text});
    		var box = svgHelpers.getTextBox(svg,testText.toSvgAttributes(),testText.classes,testText.text);
			xoff += box.width;
		});
		rightText.forEach((tt) => {
    		var testText = new SmoScoreText({text:tt.text});
			var box = svgHelpers.getTextBox(svg,testText.toSvgAttributes(),testText.classes,testText.text);
			width += box.width;
		});
		return svgHelpers.boxPoints(xoff,0,width,0);
	}

	static estimateMeasureWidth(measure) {

		// Calculate the existing staff width, based on the notes and what we expect to be rendered.
  var gravity = false;
  var prevWidth = measure.staffWidth;
	var measureWidth = suiLayoutAdjuster.estimateMusicWidth(measure);
	measure.adjX = suiLayoutAdjuster.estimateStartSymbolWidth(measure);
	measure.adjRight = suiLayoutAdjuster.estimateEndSymbolWidth(measure);
	measureWidth += measure.adjX + measure.adjRight + measure.customStretch;
  if (measure.changed == false && measure.logicalBox && measure.staffWidth < prevWidth) {
    measureWidth = Math.round((measure.staffWidth + prevWidth)/2);
    gravity = true;
  }
  var y = measure.logicalBox ? measure.logicalBox.y : measure.staffY;
  measure.setWidth(measureWidth,'estimateMeasureWidth adjX adjRight gravity: '+gravity);

		// Calculate the space for left/right text which displaces the measure.
		// var textOffsetBox=suiLayoutAdjuster.estimateTextOffset(renderer,measure);
		// measure.setX(measure.staffX  + textOffsetBox.x,'estimateMeasureWidth');
    measure.setBox(svgHelpers.boxPoints(measure.staffX,y,measure.staffWidth,measure.logicalBox.height),
       'estimate measure width');
	}
  static _beamGroupForNote(measure,note) {
    var rv = null;
    if (!note.beam_group) {
      return null;
    }
    measure.beamGroups.forEach((bg) => {
      if (!rv) {
        if (bg.notes.findIndex((nn) => note.beam_group && note.beam_group.id == bg.attrs.id) >= 0) {
          rv = bg;
        }
      }
    });
    return rv;
  }

    // ### _highestLowestHead
    // highest value is actually the one lowest on the page
    static _highestLowestHead(measure,note) {
        var hilo = {hi:0,lo:9999999};
        note.pitches.forEach((pitch) => {
            // 10 pixels per line
            var px = 10*smoMusic.pitchToLedgerLine(measure.clef,pitch);
            hilo.lo = Math.min(hilo.lo,px);
            hilo.hi = Math.max(hilo.hi,px);
        });
        return hilo;
    }

  // ### estimateMeasureHeight
  // The baseline is the top line of the staff.  aboveBaseline is a negative number
  // that indicates how high above the baseline the measure goes.  belowBaseline
  // is a positive number that indicates how far below the baseline the measure goes.
  // the height of the measure is below-above.  Vex always renders a staff such that
  // the y coordinate passed in for the stave is on the baseline.
  static estimateMeasureHeight(measure,layout) {
    var heightOffset = 50;  // assume 5 lines, todo is non-5-line staffs
    var yOffset = 0;
    if (measure.forceClef) {
      heightOffset += vexGlyph.clef(measure.clef).yTop + vexGlyph.clef(measure.clef).yBottom;
      yOffset = yOffset - vexGlyph.clef(measure.clef).yTop;
    }

    if (measure.forceTempo) {
      yOffset = Math.min(-1*vexGlyph.tempo.yTop,yOffset);
    }
    var hasDynamic = false;

    measure.voices.forEach((voice) => {
      voice.notes.forEach((note) => {
        var bg = suiLayoutAdjuster._beamGroupForNote(measure,note);
        var flag = SmoNote.flagStates.auto;
        if (bg && note.noteType == 'n') {
          flag = bg.notes[0].flagState;
          // an  auto-flag note is up if the 1st note is middle line
          if (flag == SmoNote.flagStates.auto) {
            var pitch = bg.notes[0].pitches[0];
            flag = smoMusic.pitchToLedgerLine(measure.clef,pitch)
               >= 2 ? SmoNote.flagStates.up : SmoNote.flagStates.down;
          }
        }  else {
          var flag = note.flagState;
          // an  auto-flag note is up if the 1st note is middle line
          if (flag == SmoNote.flagStates.auto) {
            var pitch = note.pitches[0];
            flag = smoMusic.pitchToLedgerLine(measure.clef,pitch)
             >= 2 ? SmoNote.flagStates.up : SmoNote.flagStates.down;
          }
        }
        var hiloHead = suiLayoutAdjuster._highestLowestHead(measure,note);
        if (flag == SmoNote.flagStates.down) {
          yOffset = Math.min(hiloHead.lo,yOffset);
          heightOffset = Math.max(hiloHead.hi + vexGlyph.stem.height,heightOffset);
        } else {
          yOffset = Math.min(hiloHead.lo - vexGlyph.stem.height,yOffset);
          heightOffset = Math.max(hiloHead.hi,heightOffset);
        }
        var dynamics = note.getModifiers('SmoDynamicText');
        dynamics.forEach((dyn) => {
          heightOffset = Math.max((10*dyn.yOffsetLine - 50) + 11,heightOffset);
          yOffset = Math.min(10*dyn.yOffsetLine - 50,yOffset)
        });
      });
    });
    return {belowBaseline:heightOffset,aboveBaseline:yOffset};
  }
}
;
// ## suiLayoutBase
// ## Description:
// A layout maps the measures and notes to a spot on the page.  It
// manages the flow of music as an ordinary score.  We call it simple layout, because
// there may be other layouts for parts view, or output to other media.
class suiScoreLayout extends suiLayoutBase {
  constructor(params) {
  super('suiScoreLayout');
  Vex.Merge(this, suiLayoutBase.defaults);
  Vex.Merge(this, params);

  this.setViewport(true);

  this.attrs = {
  id: VF.Element.newID(),
  type: 'testLayout'
  };
  }

  // ### createScoreLayout
  // ### Description;
  // to get the score to appear, a div and a score object are required.  The layout takes care of creating the
  // svg element in the dom and interacting with the vex library.
  static createScoreLayout(renderElement,score, layoutParams) {
    var ctorObj = {
      elementId: renderElement,
      score: score
    };
    if (layoutParams) {
      Vex.Merge(ctorObj, layoutParams);
    }
    var layout = new suiScoreLayout(ctorObj);
      return layout;
  }
  static get defaults() {
    return {
      clefWidth: 70,
      staffWidth: 250,
      totalWidth: 250,
      pageWidth: 8 * 96 + 48,
      pageHeight: 11 * 96,
      svgScale: 0.7,
      font: {
        typeface: "Arial",
        pointSize: 10,
        fillStyle: '#eed'
      }
    };
  }

  // ### unrenderAll
  // ### Description:
  // Delete all the svg elements associated with the score.
  unrenderAll() {
    this._score.staves.forEach((staff) => {
      this.unrenderStaff(staff);
    });
    $(this.renderer.getContext().svg).find('g.lineBracket').remove();
  }

  get logicalPageWidth() {
    return this.pageMarginWidth;
  }
  get logicalPageHeight() {
    return this.pageMarginHeigh;
  }

  // ### _measureToLeft
  // measure to 'left' is on previous row if this is the first column in a system
  // but we still use it to compute beginning symbols (key sig etc.)
  _measureToLeft(measure) {
    var j = measure.measureNumber.staffId;
    var i = measure.measureNumber.measureIndex;
    return (i > 0 ? this._score.staves[j].measures[i - 1] :null);
  }

  renderTextGroup(gg) {
    const textBlock = SuiTextBlock.fromTextGroup(gg,this.context);
    textBlock.render();
    gg.renderedBox = textBlock.renderedBox;
    gg.logicalBox = textBlock.logicalBox;
    gg.textBlocks.forEach((block) => {
      const it = textBlock.inlineBlocks.find((ib) => ib.text.attrs.id === block.text.attrs.id).text;
      block.text.renderedBox = svgHelpers.smoBox(it.renderedBox);
      block.text.logicalBox = svgHelpers.smoBox(it.logicalBox);
    });
  }

  renderScoreText(tt) {
    var svg = this.context.svg;
    var scoreLayout = this.scaledScoreLayout;
    var classes = tt.attrs.id+' '+'score-text'+' '+tt.classes;
    var text = tt.text.replace('###',1); /// page number
    text = text.replace('@@@',scoreLayout.pages); /// page number
    var args = {svg:this.svg,width:tt.width,height:tt.height,layout:this._score.layout,text:text};
    const block = SuiInlineText.fromScoreText(tt,this.context);
    const blocks = [{ text: block, position: SmoTextGroup.relativePosition.RIGHT }];

    const svgText = new SuiTextBlock({blocks: blocks, context: this.context} );
    svgText.render();
    tt.renderedBox = svgText.getRenderedBox();

    // Update paginated score text
    if (tt.pagination != SmoScoreText.paginations.once) {
      for (var i = 1;i<scoreLayout.pages;++i) {
        if (tt.pagination == SmoScoreText.paginations.even &&
          i % 2 > 0)  {
            continue;
        }
        else if (tt.pagination == SmoScoreText.paginations.odd &&
           i % 2 == 0) {
          continue;
        }
        else if (tt.pagination == SmoScoreText.paginations.subsequent
           && i == 1) {
            continue;
        }

        var xx = new SmoScoreText(tt);
        xx.classes = 'score-text '+xx.attrs.id;
        xx.text = xx.text.replace('###',i + 1); /// page number
        xx.text = xx.text.replace('@@@',scoreLayout.pages); /// page number
        xx.y += scoreLayout.pageHeight*i;
        args.text = xx.text;
        suiTextLayout.placeText(xx,args);
      }
    }
  }
  _renderScoreModifiers() {
    var svg = this.context.svg;
    $(this.renderer.getContext().svg).find('text.score-text').remove();
    this._score.scoreText.forEach((tt) => {
      this.renderScoreText(tt);
    });
    this._score.textGroups.forEach((tg) => {
      this.renderTextGroup(tg);
    });
  }


    // ### calculateBeginningSymbols
    // calculate which symbols like clef, key signature that we have to render in this measure.
  calculateBeginningSymbols(systemIndex, measure, clefLast, keySigLast, timeSigLast,tempoLast) {
    var measureKeySig = smoMusic.vexKeySignatureTranspose(measure.keySignature, measure.transposeIndex);
    measure.forceClef = (systemIndex === 0 || measure.clef !== clefLast);
    measure.forceTimeSignature = (measure.measureNumber.measureIndex == 0 || measure.timeSignature !== timeSigLast);
      measure.forceTempo = false;
    var tempo = measure.getTempo();
    if (tempo && measure.measureNumber.measureIndex == 0) {
        measure.forceTempo = tempo.display;
    }
    else if (tempo && tempoLast) {
      if (!SmoTempoText.eq(tempo,tempoLast)) {
      	measure.forceTempo = tempo.display;
      }
    } else if (tempo) {
      measure.forceTempo = tempo.display;
    }
    if (measureKeySig !== keySigLast) {
      measure.canceledKeySignature = keySigLast;
      measure.setChanged();
      measure.forceKeySignature = true;
    } else if (systemIndex == 0 && measureKeySig != 'C') {
      measure.forceKeySignature = true;
    } else {
      measure.forceKeySignature = false;
    }
  }

  _getMeasuresInColumn(ix) {
    var rv = [];
    this.score.staves.forEach((staff) => {
      var inst = staff.measures.find((ss) => ss.measureNumber.measureIndex == ix);
      if (inst) {
        rv.push(inst);
      }
    });
    return rv;
  }
  get scaledScoreLayout() {
    var svgScale = this.score.layout.svgScale;
    var rv = JSON.parse(JSON.stringify(this.score.layout));
    var attrs = ['topMargin','bottomMargin','interGap','intraGap','pageHeight','pageWidth','leftMargin','rightMargin'];
    attrs.forEach((attr) => {
      rv[attr] = rv[attr] / svgScale;
    });

    return rv;
  }

    renderAllMeasures() {
        var mscore = {};
        $('.measure-format').remove();
        var printing = $('body').hasClass('print-render');
        this.score.staves.forEach((staff) => {
            staff.measures.forEach((measure) => {
                if (!mscore[measure.lineIndex]) {
                    mscore[measure.lineIndex] = [];
                }
                mscore[measure.lineIndex].push(measure);
            });
        });

        var keys = Object.keys(mscore);
        keys.forEach((key) => {
            var columns = {};
            var vxSystem = new VxSystem(this.context,0,parseInt(key),this.score);
            mscore[key].forEach((measure) => {
                if (!columns[measure.measureNumber.systemIndex]) {
                    columns[measure.measureNumber.systemIndex] = [];
                }
                columns[measure.measureNumber.systemIndex].push(measure);
            });

            var colKeys = Object.keys(columns);
            colKeys.forEach((colKey) => {
                columns[colKey].forEach((measure) => {
                    vxSystem.renderMeasure(measure,this.measureMapper);
                    var formatIndex = SmoMeasure.formattingOptions.findIndex((option) => measure[option] != SmoMeasure.defaults[option]);
                    if (formatIndex >= 0 && !printing) {
                        var at=[];
                        at.push({y:measure.logicalBox.y - 5});
                        at.push({x:measure.logicalBox.x + 25});
                        at.push({fontFamily:'Helvitica'});
                        at.push({fontSize:'8pt'});
                        svgHelpers.placeSvgText(this.context.svg,at,'measure-format','*');
                    }

                });
            });

            vxSystem.renderEndings();
            vxSystem.updateLyricOffsets();
            this._score.staves.forEach((stf) => {
    			this._renderModifiers(stf, vxSystem);
    		});

        });
        this._renderScoreModifiers();
        this.numberMeasures();
    }

    // ### _justifyY
    // when we have finished a line of music, adjust the measures in the system so the
    // top of the staff lines up.
    _justifyY(svg,scoreLayout,measureEstimate,currentLine) {
        // We estimate the staves at the same absolute y value.  Now, move them down so the top of the staves align for all measures in a  row.
        for (var i =0;i< measureEstimate.measures.length;++i) {
            var rowAdj = currentLine.filter((mm) => mm.svg.rowInSystem == i);
            // lowest staff has greatest staffY value.
            var lowestStaff = rowAdj.reduce((a,b) => {
                return a.staffY > b.staffY ? a : b;
            });
            rowAdj.forEach((measure) => {
                var adj = lowestStaff.staffY - measure.staffY;
                measure.setY(measure.staffY + adj);
                measure.setBox(svgHelpers.boxPoints(measure.logicalBox.x,measure.logicalBox.y + adj,measure.logicalBox.width,measure.logicalBox.height));
            });
            var rightStaff = rowAdj.reduce((a,b) => {
               return a.staffX + a.staffWidth > b.staffX + b.staffWidth ?  a : b});

            var justifyX = Math.round((scoreLayout.pageWidth - (scoreLayout.leftMargin + scoreLayout.rightMargin + rightStaff.staffX + rightStaff.staffWidth))
                 / rowAdj.length);
            rowAdj.forEach((measure) => {
                measure.setWidth(measure.staffWidth + justifyX,'_estimateMeasureDimensions justify');
                var offset = measure.measureNumber.systemIndex * justifyX;
                measure.setX(measure.staffX + offset);
                measure.setBox(svgHelpers.boxPoints(measure.logicalBox.x + offset,measure.logicalBox.y,measure.staffWidth,measure.logicalBox.height,));
                layoutDebug.debugBox(svg,measure.logicalBox,'adjust');
            });
         }

    }

    // ### _checkPageBreak
    // See if this line breaks the page boundary
    _checkPageBreak(scoreLayout,currentLine,bottomMeasure) {
        // See if this measure breaks a page.
        var maxY = bottomMeasure.logicalBox.y +  bottomMeasure.logicalBox.height;
        if (maxY > (scoreLayout.pages * scoreLayout.pageHeight) - scoreLayout.bottomMargin) {
            // When adjusting the page, make it so the top staff of the system
            // clears the bottom of the page.
            var topMeasure = currentLine.reduce((a,b) => {
                return a.logicalBox.y < b.logicalBox.y ? a : b;
            });
            var minMaxY = topMeasure.logicalBox.y;
            var pageAdj = (scoreLayout.pages * scoreLayout.pageHeight) - minMaxY;
            pageAdj = pageAdj + scoreLayout.topMargin;
            scoreLayout.pages += 1;
            currentLine.forEach((measure) => {
                measure.setBox(svgHelpers.boxPoints(
                    measure.logicalBox.x,measure.logicalBox.y + pageAdj,measure.logicalBox.width,measure.logicalBox.height));
                measure.setY(measure.staffY + pageAdj);
            });
        }
    }

    layout() {
        var measureIx = 0;
        var systemIndex = 0;

        layoutDebug.clearDebugBoxes('pre');
        layoutDebug.clearDebugBoxes('post');
        layoutDebug.clearDebugBoxes('adjust');
        layoutDebug.clearDebugBoxes('system');
        layoutDebug.clearDebugBoxes('note');

        var svg = this.context.svg;
        var scoreLayout = this.scaledScoreLayout;
        scoreLayout.pages = 1;

        var y = scoreLayout.topMargin;
        var x = scoreLayout.leftMargin;
        var currentLine = []; // the system we are esimating

        var lineIndex = 0;
        while (measureIx < this.score.staves[0].measures.length) {

            var measureEstimate = this._estimateColumn(scoreLayout,measureIx,systemIndex,lineIndex,x,y);
            x = measureEstimate.x;

            if (systemIndex > 0 &&
                  (measureEstimate.measures[0].getForceSystemBreak() || measureEstimate.x > (scoreLayout.pageWidth - scoreLayout.leftMargin))) {

                  this._justifyY(svg,scoreLayout,measureEstimate,currentLine);
                  // find the measure with the lowest y extend (greatest y value), not necessarily one with lowest
                  // start of staff.
                  var bottomMeasure = currentLine.reduce((a,b) => {
                      return a.logicalBox.y + a.logicalBox.height > b.logicalBox.y + b.logicalBox.height ? a : b;
                  });

                  this._checkPageBreak(scoreLayout,currentLine,bottomMeasure);

                  if (layoutDebug.mask & layoutDebug.values.system) {
                      currentLine.forEach((measure) => {
                         layoutDebug.debugBox(svg,measure.logicalBox,'system');
                         layoutDebug.debugBox(svg,svgHelpers.boxPoints(measure.staffX,measure.logicalBox.y,measure.adjX,measure.logicalBox.height),'post');
                      });
                  }

                // Now start rendering on the next system.
                y = bottomMeasure.logicalBox.height + bottomMeasure.logicalBox.y + this.score.layout.interGap;
                currentLine = [];
                systemIndex = 0;
                x = scoreLayout.leftMargin;
                lineIndex += 1;
                measureEstimate = this._estimateColumn(scoreLayout,measureIx,systemIndex,lineIndex,x,y);
                x = measureEstimate.x;
            }

            measureEstimate.measures.forEach((measure) => {
               layoutDebug.debugBox(svg,measure.logicalBox,'pre');
            });

            currentLine = currentLine.concat(measureEstimate.measures);
            measureIx += 1;
            systemIndex += 1;
            // If this is the last measure but we have not filled the x extent,
            // still justify the vertical staves and check for page break.
            if (measureIx >= this.score.staves[0].measures.length) {
                this._justifyY(svg,scoreLayout,measureEstimate,currentLine);

                var bottomMeasure = currentLine.reduce((a,b) => {
                    return a.logicalBox.y + a.logicalBox.height > b.logicalBox.y + b.logicalBox.height ? a : b;
                });

                this._checkPageBreak(scoreLayout,currentLine,bottomMeasure);
            }
        }
        if (scoreLayout.pages != this.score.layout.pages) {
            this.score.layout.pages = scoreLayout.pages;
            this.setViewport(true);
        }
        this.renderAllMeasures();
    }

    // ### _estimateColumns
    // the new logic to estimate the dimensions of a column of music, corresponding to
    // a certain measure index.
    // returns:
    // {measures,y,x}  the x and y at the left/bottom of the render
    _estimateColumn(scoreLayout,measureIx,systemIndex,lineIndex,x,y) {
        var s = {};
        var measures = this._getMeasuresInColumn(measureIx);
        var rowInSystem = 0;
        measures.forEach((measure) => {
            smoBeamerFactory.applyBeams(measure);
            var staff = this.score.staves[measure.measureNumber.staffId];
            measure.measureNumber.systemIndex = systemIndex;
            measure.svg.rowInSystem = rowInSystem;
            measure.lineIndex = lineIndex;

            // use measure to left to figure out whether I need to render key signature, etc.
            // If I am the first measure, just use self and we always render them on the first measure.
            var measureToLeft = this._measureToLeft(measure);
            if (!measureToLeft) {
                measureToLeft = measure;
            }
            s.measureKeySig = smoMusic.vexKeySignatureTranspose(measure.keySignature, measure.transposeIndex);
            s.keySigLast = smoMusic.vexKeySignatureTranspose(measureToLeft.keySignature,measure.transposeIndex);
            s.tempoLast = measureToLeft.getTempo();
            s.timeSigLast = measureToLeft.timeSignature;
            s.clefLast = measureToLeft.clef;
            this.calculateBeginningSymbols(systemIndex, measure, s.clefLast, s.keySigLast, s.timeSigLast,s.tempoLast);

            // calculate vertical offsets from the baseline
            var offsets = suiLayoutAdjuster.estimateMeasureHeight(measure,this.score.layout);
            measure.setYTop(offsets.aboveBaseline);
            measure.setY(y - measure.yTop,'_estimateColumns height');
            measure.setX(x);

            // Add custom width to measure:
            measure.setBox(svgHelpers.boxPoints(measure.staffX,y,measure.staffWidth,offsets.belowBaseline-offsets.aboveBaseline));
            suiLayoutAdjuster.estimateMeasureWidth(measure);
            y = y + measure.logicalBox.height + scoreLayout.intraGap;
            rowInSystem += 1;
        });

        // justify this column to the maximum width
        var maxMeasure = measures.reduce((a,b) => a.staffX+a.staffWidth > b.staffX+b.staffWidth ? a : b);
        var maxX = maxMeasure.staffX + maxMeasure.staffWidth;
        var maxAdjMeasure =measures.reduce((a,b) => a.adjX > b.adjX  ? a  : b);
        var maxAdj = maxAdjMeasure.adjX;
        measures.forEach((measure) => {
            measure.setWidth(measure.staffWidth + (maxX - (measure.staffX + measure.staffWidth)));
            measure.adjX = maxAdj;
        });
        var rv = {measures:measures,y:y,x:maxX};
        return rv;
    }

}
;// ## SuiInlineText
// Inline text is a block of SVG text with the same font.  Each block can
// contain eithr text or an svg (vex) glyph.  Each block in the text has its own
// metrics so we can support inline svg text editors (cursor).
class SuiInlineText {
  static get textTypes() {
    return {normal:0,superScript:1,subScript:2};
  }
  static get symbolTypes() {
    return {
      GLYPH: 1,
      TEXT: 2,
      LINE: 3
    };
  }
  static get superscriptOffset() {
    return VF.ChordSymbol.chordSymbolMetrics.global.superscriptOffset / VF.ChordSymbol.engravingFontResolution;
  }

  static get subscriptOffset() {
    return VF.ChordSymbol.chordSymbolMetrics.global.subscriptOffset / VF.ChordSymbol.engravingFontResolution;
  }

  get spacing() {
    return this.fontMetrics.spacing / this.fontMetrics.resolution;
  }


  static get defaults() {
    return {
      blocks: [],
      fontFamily: 'robotoSlab',
      fontSize: 14,
      startX: 100,
      startY: 100,
      fontWeight:500,
      scale: 1,
      activeBlock:-1,
      artifacts: [],
      updatedMetrics: false
    };
  }
  // ### constructor just creates an empty svg
  constructor(params) {
    Vex.Merge(this, SuiInlineText.defaults);
    Vex.Merge(this, params);
    this.attrs = {
      id: VF.Element.newID(),
      type: 'SuiInlineText'
    };

    if (!this.context) {
      throw('context for SVG must be set');
    }
  }

  static fromScoreText(scoreText,context) {
    var pointSize = scoreText.fontInfo.pointSize ? scoreText.fontInfo.pointSize
      : SmoScoreText.fontPointSize(scoreText.fontInfo.size);
    const params = { fontFamily:scoreText.fontInfo.family,
      startX: scoreText.x, startY: scoreText.y,
      fontSize: pointSize, context: context};
    let rv = new SuiInlineText(params);
    rv.attrs.id = scoreText.attrs.id;
    rv.addTextBlockAt(0, { text: scoreText.text});
    return rv;
  }

  get fontMetrics() {
    return VF.DEFAULT_FONT_STACK[0].name === 'Petaluma' ?
      VF.PetalumaScriptMetrics : VF.RobotoSlabMetrics;
  }

  static get blockDefaults() {
    return {
      symbolType: SuiInlineText.symbolTypes.TEXT,
      textType: SuiInlineText.textTypes.normal,
      highlighted: false
    };
  }

  // ### pointsToPixels
  // The font size is specified in points, convert to 'pixels' in the svg space
  get pointsToPixels() {
    return (this.fontSize / 72) / (1 / 96);
  }

  offsetStartX(offset) {
    this.startX += offset;
    this.blocks.forEach((block) => {
      block.x += offset;
    });
  }

  offsetStartY(offset) {
    this.startY += offset;
    this.blocks.forEach((block) => {
      block.y += offset;
    });
  }
  maxFontHeight(scale) {
    const glyph = this.fontMetrics.glyphs['H'];
    return  (glyph.ha / this.fontMetrics.resolution) *  this.pointsToPixels * scale;
  }

  _glyphOffset(block) {
    return block.metrics.yOffset / VF.ChordSymbol.engravingFontResolution * this.pointsToPixels * block.scale;
  }

  // ### _calculateBlockIndex
  // Based on the font metrics, compute the width of the strings and glyph that make up
  // this block.
  _calculateBlockIndex() {
    var curX = this.startX;
    var maxH = 0;
    let superXAlign = 0;
    let superXWidth = 0;
    let prevBlock = null;
    this.blocks.forEach((block) => {
      // super/subscript
      const sp = this.isSuperscript(block);
      const sub = this.isSubcript(block);

      block.width = 0;
      block.height = 0;

      // coeff for sub/super script
      const subAdj = (sp || sub) ? VF.ChordSymbol.superSubRatio : 1.0;
      // offset for super/sub
      const subOffset =  sp ? SuiInlineText.superscriptOffset * this.pointsToPixels : (sub ? SuiInlineText.subscriptOffset * this.pointsToPixels : 0);
      const glyphAdj = block.symbolType === SuiInlineText.symbolTypes.GLYPH ? 2.0 : 1.0;
      block.x = curX;
      if (block.symbolType === SuiInlineText.symbolTypes.TEXT) {
        for (var i = 0;i < block.text.length;++i) {
          const metrics = this.fontMetrics;
          const ch = block.text[i];

          const glyph = metrics.glyphs[ch] ? metrics.glyphs[ch] : metrics.glyphs['H'];
          block.width += ((glyph.advanceWidth) / metrics.resolution) * this.pointsToPixels * block.scale * subAdj;
          const blockHeight = (glyph.ha / metrics.resolution) *  this.pointsToPixels * block.scale;
          block.height = block.height < blockHeight ? blockHeight : block.height;
          block.y = this.startY +  (subOffset * block.scale);
        }
      } else if (block.symbolType === SuiInlineText.symbolTypes.GLYPH) {
        block.width = (block.metrics.advanceWidth / VF.ChordSymbol.engravingFontResolution) * this.pointsToPixels * block.scale;
        block.height = (block.glyph.metrics.ha / VF.ChordSymbol.engravingFontResolution) * this.pointsToPixels * block.scale;
        block.x += block.metrics.leftSideBearing / VF.ChordSymbol.engravingFontResolution * this.pointsToPixels * block.scale;
        block.y = this.startY + this._glyphOffset(block) + subOffset;
      }
      // Line subscript up with super if the follow each other
      if (sp) {
        if (superXAlign === 0) {
          superXAlign = block.x;
        }
      } else if (sub) {
        if (superXAlign > 0) {
          block.x = superXAlign;
          superXWidth = prevBlock.x + prevBlock.width;
          curX = superXAlign;
          superXAlign = 0;
        } else {
          if (superXWidth > 0 && superXWidth < block.width + block.x) {
            superXWidth = block.width + block.x;
          }
        }
      } else if (superXWidth > 0) {
        block.x = superXWidth + VF.ChordSymbol.spacingBetweenBlocks;
        superXWidth = 0;
      }  else {
        superXAlign = 0;
      }
      curX += block.width;
      maxH = block.height > maxH ? maxH : block.height;
      prevBlock = block;
    });
    this.width = curX - this.startX;
    this.height = maxH;
    this.updatedMetrics = true;
  }

  // ### getLogicalBox
  // return the calculated svg metrics.  In SMO parlance the
  // logical box is in SVG space, 'renderedBox' is in client space.
  getLogicalBox() {
    var rv = {};
    if (!this.updatedMetrics) {
      this._calculateBlockIndex();
    }
    var adjBox = (box) => {
      const nbox = svgHelpers.smoBox(box);
      nbox.y = nbox.y - nbox.height;
      return nbox;
    }
    this.blocks.forEach((block) => {
      if (!rv.x) {
        rv = svgHelpers.smoBox(adjBox(block));
      } else {
        rv = svgHelpers.unionRect(rv,adjBox(block));
      }
    });
    return rv;
  }

  _getTextBlock(params) {
    const block = JSON.parse(JSON.stringify(SuiInlineText.blockDefaults));
    Vex.Merge(block, params);
    block.text = params.text;
    block.scale = params.scale ? params.scale : 1;
    return block;
  }
  // ### renderCursorAt
  // When we are using textLayout to render editor, create a cursor that adjusts it's size
  renderCursorAt(position) {
    if (!this.updatedMetrics) {
      this._calculateBlockIndex();
    }
    var group = this.context.openGroup();
    group.id = 'inlineCursor';
    let h = this.fontSize;
    if (this.blocks.length <= position || position < 0) {
      svgHelpers.renderCursor(group, this.startX,this.startY - h,h);
      this.context.closeGroup();
      return;
    }
    var block = this.blocks[position];
    const adjH = block.symbolType === SuiInlineText.symbolTypes.GLYPH ? h/2 : h;
    // For glyph, add y adj back to the cursor since it's not a glyph
    const adjY = block.symbolType === SuiInlineText.symbolTypes.GLYPH ? block.y - this._glyphOffset(block) :
      block.y;
    svgHelpers.renderCursor(group, block.x + block.width,adjY - (adjH * block.scale), adjH * block.scale);
    this.context.closeGroup();
  }
  removeCursor() {
    $('svg #inlineCursor').remove();
  }
  unrender() {
    $('svg #'+this.attrs.id).remove();
  }
  getIntersectingBlocks(box, scroller) {
    if (!this.artifacts) {
      return [];
    }
    return svgHelpers.findIntersectingArtifact(box,this.artifacts,scroller);
  }
  _addBlockAt(position,block) {
    if (position >= this.blocks.length) {
      this.blocks.push(block);
    } else {
      this.blocks.splice(position,0,block);
    }
  }
  removeBlockAt(position) {
    this.blocks.splice(position,1);
    this.updatedMetrics = false;
  }

  // ### addTextBlockAt
  // Add a text block to the line of text.
  // params must contain at least:
  // {text:'xxx'}
  addTextBlockAt(position,params) {
    const block = this._getTextBlock(params);
    this._addBlockAt(position,block);
    this.updatedMetrics = false;
  }
  _getGlyphBlock(params) {
    const block = JSON.parse(JSON.stringify(SuiInlineText.blockDefaults));
    block.symbolType = SuiInlineText.symbolTypes.GLYPH;
    block.glyphCode = params.glyphCode;
    block.glyph = new VF.Glyph(block.glyphCode, this.fontSize);
    block.metrics = VF.ChordSymbol.getMetricForGlyph(block.glyphCode);
    block.scale  = (params.textType && params.textType !== SuiInlineText.textTypes.normal) ?
       2 * VF.ChordSymbol.superSubRatio * block.metrics.scale : 2 * block.metrics.scale;

    block.textType = params.textType ? params.textType : SuiInlineText.textTypes.normal;

    block.glyph.scale = block.glyph.scale * block.scale;
    return block;
  }
  // ### addGlyphBlockAt
  // Add a glyph block to the line of text.  Params must include:
  // {glyphCode:'csymDiminished'}
  addGlyphBlockAt(position,params) {
    const block = this._getGlyphBlock(params);
    this._addBlockAt(position,block);
    this.updatedMetrics = false;
  }
  isSuperscript(block) {
    return block.textType === SuiInlineText.textTypes.superScript;
  }
  isSubcript(block) {
    return block.textType === SuiInlineText.textTypes.subScript;
  }
  getHighlight(block) {
    return block.highlighted;
  }
  setHighlight(block,value) {
    block.highlighted = value;
  }

  rescale(scale) {
    scale = (scale * this.fontSize < 6) ? 6 / this.fontSize : scale;
    scale = (scale * this.fontSize > 72) ? 72/this.fontSize : scale;
    this.blocks.forEach((block) => {
      block.scale = scale;
    });
    this.updatedMetrics = false;
  }

  render() {
    $('svg #'+this.attrs.id).remove();

    if (!this.updatedMetrics) {
      this._calculateBlockIndex();
    }

    this.context.setFont(this.fontFamily, this.fontSize, this.fontWeight);
    var group = this.context.openGroup();
    var mmClass = "suiInlineText";
    group.classList.add('vf-'+this.attrs.id);
    group.classList.add(this.attrs.id);
    group.classList.add(mmClass);
    group.id=this.attrs.id;
    this.artifacts = [];
    var ix = 0;

    this.blocks.forEach((block) => {
      var bg = this.context.openGroup();
      bg.classList.add('textblock-'+this.attrs.id+ix);
      this._drawBlock(block);
      this.context.closeGroup();
      var artifact = {block: block};
      artifact.box = svgHelpers.smoBox(bg.getBoundingClientRect());
      artifact.index = ix;
      this.artifacts.push(artifact);
      ix += 1;
    });
    this.context.closeGroup();
    this.renderedBox = svgHelpers.smoBox(group.getBoundingClientRect());
    this.logicalBox = svgHelpers.smoBox(group.getBBox());
  }

  _drawBlock(block) {
    const sp = this.isSuperscript(block);
    const sub = this.isSubcript(block);
    const highlight = this.getHighlight(block);
    let y = block.y;

    if (highlight) {
      this.context.save();
      this.context.setFillStyle('#999');
    }

    if (sp || sub) {
      // y = y + (sp ? SuiInlineText.superscriptOffset : SuiInlineText.subscriptOffset) * this.pointsToPixels * block.scale;
      this.context.save();
      this.context.setFont(this.fontFamily, this.fontSize * VF.ChordSymbol.superSubRatio * block.scale, this.fontWeight);
    } else {
      this.context.setFont(this.fontFamily, this.fontSize * block.scale, this.fontWeight);
    }
    if (block.symbolType === SuiInlineText.symbolTypes.TEXT) {
      this.context.fillText(block.text,block.x,y);
    } else if (block.symbolType === SuiInlineText.symbolTypes.GLYPH) {
      block.glyph.render(this.context, block.x, y);
    }
    if (sp || sub) {
      this.context.restore();
    }
    if (highlight) {
      this.context.restore();
    }
  }

  getText() {
    var rv ='';
    this.blocks.forEach((block) => {
      rv += block.text;
    });
    return rv;
  }
}

// ## SuiTextBlock
// A text block is a set of inline blocks that can be aligned/arranged in different ways.
class SuiTextBlock {
  static get relativePosition() {
    return { ABOVE:SmoTextGroup.relativePosition.ABOVE,
      BELOW: SmoTextGroup.relativePosition.BELOW,
      LEFT: SmoTextGroup.relativePosition.LEFT,
      RIGHT: SmoTextGroup.relativePosition.RIGHT
    };
  }
  constructor(params) {
    this.inlineBlocks = [];
    this.context = params.context;
    if (!params.blocks) {
      const inst = new SuiInlineText(params);
      params.blocks = [{ text: inst, position: SmoTextGroup.relativePosition.RIGHT }];
    }
    params.blocks.forEach((block) => {
      // const position = block.position ? block.position : SmoTextGroup.relativePosition.RIGHT;
      // const ib = {text:block, position: position};
      if (!this.currentBlock) {
        this.currentBlock = block;
        this.currentBlockIndex = 0;
      }
      this.inlineBlocks.push(block);
    });
    this.justification = params.justification ? params.justification :
      SmoTextGroup.justifications.LEFT;
  }
  addTextAt(position,params) {
    this.currentBlock.text.addTextBlockAt(position,params);
  }
  addGlyphAt(position,params) {
    this.currentBlock.text.addGlyphBlockAt(position,params);
  }
  render() {
    this.unrender();
    this.renderedBox = null;
    this.logicalBox = null;
    this.inlineBlocks.forEach((block) => {
      block.text.render();
      if (!this.renderedBox) {
        this.renderedBox = svgHelpers.smoBox(block.text.renderedBox);
        this.logicalBox = svgHelpers.smoBox(block.text.logicalBox);
      } else {
        this.renderedBox = svgHelpers.unionRect(this.renderedBox,block.text.renderedBox);
        this.logicalBox = svgHelpers.unionRect(this.logicalBox,block.text.logicalBox);
      }
    });
  }

  offsetStartX(offset) {
    this.inlineBlocks.forEach((block) => {
      block.text.offsetStartX(offset);
    });
  }

  offsetStartY(offset) {
    this.inlineBlocks.forEach((block) => {
      block.text.offsetStartY(offset);
    });
  }

  rescale(scale) {
    this.inlineBlocks.forEach((block) => {
      block.text.rescale(scale);
    });
  }

  get x() {
    return this.getLogicalBox().x;
  }
  get y() {
    return this.getLogicalBox().y;
  }

  maxFontHeight(scale) {
    var rv = 0;
    this.inlineBlocks.forEach((block) => {
      const blockHeight = block.text.maxFontHeight(scale);
      rv = blockHeight > rv ? blockHeight : rv;
    });
    return rv;
  }

  static inlineParamsFromScoreText(scoreText,context) {
    var pointSize = scoreText.fontInfo.pointSize ? scoreText.fontInfo.pointSize
      : SmoScoreText.fontPointSize(scoreText.fontInfo.size);
    const rv = { fontFamily:scoreText.fontInfo.family,
      startX: scoreText.x, startY: scoreText.y,
      fontSize: pointSize, context: context };
    return rv;
  }
  static blockFromScoreText(scoreText,context, position) {
    var inlineText = SuiInlineText.fromScoreText(scoreText, context);
    return  {text: inlineText, position: position};
  }

  getLogicalBox() {
    return this._calculateBoundingClientRect();
  }
  getRenderedBox() {
    return svgHelpers.logicalToClient(this.context.svg,this._calculateBoundingClientRect());
  }
  _calculateBoundingClientRect() {
    var rv = {};
    this.inlineBlocks.forEach((block) => {
      if (!rv.x) {
        rv = block.text.getLogicalBox();
      } else {
        rv = svgHelpers.unionRect(rv,block.text.getLogicalBox());
      }
    });
    rv.y = rv.y - rv.height;
    return rv;
  }
  static fromTextGroup(tg,context) {
    var rv = null;
    let blocks = [];

    // Create an inline block for each ScoreText
    tg.textBlocks.forEach((stBlock) => {
      const st = stBlock.text;
      blocks.push(SuiTextBlock.blockFromScoreText(st,context, stBlock.position));
    });
    return new SuiTextBlock({blocks: blocks, justification: tg.justification, context: context});
  }
  unrender() {
    this.inlineBlocks.forEach((block) => {
      var selector = '#'+block.text.attrs.id;
      $(selector).remove();
    });
  }
  _justify() {
    if (!this.inlineBlocks.length) {
      return;
    }
    var minx = this.inlineBlocks[0].text.startX;
    var maxx = 0;
    var maxwidth = 0;
    var vert = {};
    var lvl = 0;
    this.inlineBlocks.forEach((inlineBlock) => {
      const block = inlineBlock.text;
      minx = block.startX < minx ? block.startX : minx;
      maxx = (block.startX + block.width) > maxx ? block.startX + block.width : maxx;
      lvl = inlineBlock.position === SmoTextGroup.relativePosition.ABOVE ? lvl + 1 : lvl;
      lvl = inlineBlock.position === SmoTextGroup.relativePosition.BELOW ? lvl - 1 : lvl;
      if (!vert[lvl] ) {
        vert[lvl] = {};
        vert[lvl].blocks = [ block ];
        vert[lvl].minx = block.startX;
        vert[lvl].maxx = block.startX + block.width;
        maxwidth = vert[lvl].width = block.width;
      }  else {
        vert[lvl].blocks.push(block);
        vert[lvl].minx = vert[lvl].minx < block.startX ? vert[lvl].minx : block.startX;
        vert[lvl].maxx = vert[lvl].maxx > (block.startX + block.width) ?
          vert[lvl].maxx : (block.startX + block.width);
        vert[lvl].width += block.width;
        maxwidth = maxwidth > vert[lvl].width ? maxwidth : vert[lvl].width;
      }
    });
    var levels = Object.keys(vert);
    levels.forEach((level) => {
      var vobj = vert[level];
      var left = 0;
      if (this.justification === SmoTextGroup.justifications.LEFT) {
        left = minx - vobj.minx;
      } else if (this.justification === SmoTextGroup.justifications.RIGHT) {
        left = maxx - vobj.maxx;
      } else {
        left = ( maxwidth / 2 ) - (vobj.width / 2);
        left +=  minx - vobj.minx;
      }
      vobj.blocks.forEach((block) => {
        block.offsetStartX(left);
      });
    });
  }
  addBlockPosition(scoreText,position) {
    var blockBox = this.currentBlock.text.getRenderedBox();
    position = position ? position : SuiTextBlock.relativePosition.BELOW;
    var ycoff = position === SuiTextBlock.relativePosition.ABOVE ? -1 : 1;
    var xcoff = position === SuiTextBlock.relativePosition.LEFT ? -1 : 1;
    var yoffset = position === SuiTextBlock.relativePosition.ABOVE
      || position === SuiTextBlock.relativePosition.BELOW ?
       blockBox.height + this.currentBlock.text.spacing : 0;
    var xoffset = position === SuiTextBlock.relativePosition.LEFT
     || position === SuiTextBlock.relativePosition.RIGHT ?
      blockBox.width + this.currentBlock.text.spacing : 0;
    const params = SuiTextBlock.inlineParamsFromScoreText(scoreText,this.context);
    params.startX = this.currentBlock.text.startX + (xoffset * xcoff);
    params.startY = this.currentBlock.text.startY + (yoffset * ycoff);
    const textBlock = new SuiInlineText(params);
    textBlock.attrs.id = scoreText.attrs.id;
    this.currentBlock = { text: textBlock,position: position };
    this.currentBlock.text.addTextBlockAt(0,{text: scoreText.text});
    this.inlineBlocks.push(this.currentBlock);
    this.currentBlockIndex += 1;
    this._justify();
  }
}

class suiTextLayout {

	static _getTextBox(scoreText,parameters) {
		var svg = parameters.svg;
		if (scoreText.width && scoreText.height && scoreText.boxModel == SmoScoreText.boxModels.wrap) {
			return svgHelpers.boxPoints(scoreText.x,scoreText.y,scoreText.width,scoreText.height);
		}
		return svgHelpers.getTextBox(svg,scoreText.toSvgAttributes(),scoreText.classes,scoreText.text);
	}
	static _saveBox(scoreText,parameters,el) {
		var svg = parameters.svg;
		 var box = svgHelpers.smoBox(el.getBoundingClientRect());
		 var lbox = svgHelpers.clientToLogical(svg,box);
		 scoreText.renderedBox = {
			x: box.x,
			y: box.y,
			height: box.height,
			width: box.width
		};
		scoreText.logicalBox = lbox;
	}
	static titleTextPlacement(scoreText,parameters) {
		var svg = parameters.svg;
		var bbox = suiTextLayout._getTextBox(scoreText,parameters);
		scoreText.x=parameters.width/2-(bbox.width/2);
		scoreText.y=parameters.layout.topMargin;
		parameters.layout.topMargin += bbox.height;
		scoreText.autoLayout=false; // use custom placement or calculated placement next time
		suiTextLayout.placeText(scoreText,parameters);
	}

	static headerTextPlacement(scoreText,parameters) {
		var svg = parameters.svg;
		var bbox = suiTextLayout._getTextBox(scoreText,parameters);
		scoreText.x=parameters.width/2-(bbox.width/2);
		scoreText.y=10;
		scoreText.autoLayout=false;
		suiTextLayout.placeText(scoreText,parameters);
	}

	static footerTextPlacement(scoreText,parameters) {
		var svg = parameters.svg;
		var bbox = suiTextLayout._getTextBox(scoreText,parameters);
		scoreText.x=parameters.width/2-(bbox.width/2);
		scoreText.y=parameters.height-(bbox.height+10);
		scoreText.autoLayout=false;
		suiTextLayout.placeText(scoreText,parameters);
	}

	static copyrightTextPlacement(scoreText,parameters) {
		var svg = parameters.svg;
		var bbox = suiTextLayout._getTextBox(scoreText,parameters);
		scoreText.x=parameters.width-(bbox.width+10);
		scoreText.y=10;
		suiTextLayout.placeText(scoreText,parameters);
		scoreText.autoLayout=false;
	}

	static placeText(scoreText,parameters) {
		var svg = parameters.svg;
		if (scoreText.width && scoreText.height && scoreText.boxModel == SmoScoreText.boxModels.wrap) {
    		suiTextLayout.placeWithWrap(scoreText,parameters);
		} else {
			var el = svgHelpers.placeSvgText(svg,scoreText.toSvgAttributes(),scoreText.classes,parameters.text,scoreText.attrs.id);
            suiTextLayout._saveBox(scoreText,parameters,el);
		}
	}


	static _placeWithWrap(scoreText,parameters,justification) {
		var justifyOnly=false;
		if (!justification.length) {
			justifyOnly=true;
		}
		var svg = parameters.svg;
		var words = scoreText.text.split(' ');
		var curx = scoreText.x;
		var left = curx;
		var right = scoreText.x+scoreText.width;
		var top = scoreText.y;
		var params = scoreText.backupParams();
		var cury = scoreText.y;
		var width=	scoreText.width;
		var height = scoreText.height;
		var delta = 0;
		params.boxModel = SmoScoreText.boxModels.none;
		params.width=0;
		params.height = 0;
		scoreText.logicalBox=svgHelpers.boxPoints(scoreText.x,scoreText.y,scoreText.width,scoreText.height);
		scoreText.renderedBox = svgHelpers.logicalToClient(svg,scoreText.logicalBox);
		var justifyAmount = justifyOnly ? 0 : justification[0];
		if(!justifyOnly) {
		    justification.splice(0,1);
		}

		words.forEach((word) => {
			var bbox = svgHelpers.getTextBox(svg,SmoScoreText.toSvgAttributes(params),scoreText.classes,word);
			delta = right - (bbox.width + bbox.x);
			if (delta > 0) {
				params.x=bbox.x;
				params.y=cury;
				if (!justifyOnly) {
                   params.x += justifyAmount;
				   svgHelpers.placeSvgText(svg,SmoScoreText.toSvgAttributes(params),scoreText.classes,word);
				}
			} else {
				if (!justifyOnly) {
					justifyAmount = justification[0];
				    justification.splice(0,1);
				} else {
					// If we are computing for justification, do that.
					delta = right - bbox.x;
					delta = scoreText.justification === SmoScoreText.justifications.right ? delta :
					    (scoreText.justification === SmoScoreText.justifications.center ? delta/2 : 0);
					justification.push(delta);
				}
				cury += bbox.height;
				curx = left;
				params.x=curx + justifyAmount;
				params.y=cury;
				if (!justifyOnly) {
				    svgHelpers.placeSvgText(svg,SmoScoreText.toSvgAttributes(params),scoreText.classes,word);
				}
			}
			curx += bbox.width + 5;
			params.x = curx;
			// calculate delta in case this is last time
			delta = right - curx;
		});
		delta = scoreText.justification === SmoScoreText.justifications.right ? delta :
					    (scoreText.justification === SmoScoreText.justifications.center ? delta/2 : 0);
        justification.push(delta-5);
	}
	static placeWithWrap(scoreText,parameters) {
		var justification=[];

		// One pass is to compute justification for the box model.
		suiTextLayout._placeWithWrap(scoreText,parameters,justification);
		suiTextLayout._placeWithWrap(scoreText,parameters,justification);
	}

}
;

// ## SuiTextEditor
// Next-gen text editor.  The base text editor handles the positioning and inserting
// of text blocks into the text area.  The derived class shoud interpret key events.
// A container class will manage the session for starting/stopping the editor
// and retrieving the results into the target object.
class SuiTextEditor {
  static get attributes() {
    return ['svgText','context','x','y','text','textPos','selectionStart','selectionLength','empty','suggestionIndex'];
  }
  static get defaults() {
    return {
      svgText: null,
      context: null,
      x: 0,
      y: 0,
      text: '',
      textPos: 0,
      selectionStart: -1,
      selectionLength: 0,
      empty: true,
      suggestionIndex:-1,
      textType: SuiInlineText.textTypes.normal
    }
  }
  constructor(params) {
    Vex.Merge(this,SuiTextEditor.defaults);
    Vex.Merge(this,params);
    this.context = params.context;
  }

  static get strokes() {
    return {
      'text-suggestion': {
        'stroke': '#cce',
        'stroke-width': 1,
        'stroke-dasharray': '4,1',
        'fill': 'none'
      },
      'text-selection': {
        'stroke': '#99d',
        'stroke-width': 1,
        'fill': 'none'
      },'text-highlight': {
        'stroke': '#dd9',
        'stroke-width': 1,
        'stroke-dasharray': '4,1',
        'fill': 'none'
      },'text-drag' : {
        'stroke': '#d99',
        'stroke-width': 1,
        'stroke-dasharray': '2,1',
        'fill': '#eee',
        'opacity' : '0.3'
      }
    }
  }

  // ### _suggestionParameters
  // Create the svg text outline parameters
  _suggestionParameters(box,strokeName) {
    const outlineStroke = SuiTextEditor.strokes[strokeName];
    return {
      context: this.context, box: box,classes: strokeName,
         outlineStroke, scroller: this.scroller
    }
  }

  // ### _expandSelectionToSuggestion
  // Expand the selection to include the character the user clicked on.
  _expandSelectionToSuggestion() {
    if (this.suggestionIndex < 0) {
      return;
    }
    if (this.selectionStart < 0) {
      this._setSelectionToSugggestion();
      return;
    }  else if (this.selectionStart > this.suggestionIndex) {
      const oldStart = this.selectionStart;
      this.selectionStart = this.suggestionIndex;
      this.selectionLength = (oldStart - this.selectionStart) + this.selectionLength;
    }  else if (this.selectionStart < this.suggestionIndex
        && this.selectionStart > this.selectionStart + this.selectionLength) {
      const oldStart = this.selectionStart;
      this.selectionLength = (this.suggestionIndex - this.selectionStart) + 1;
    }
    this._updateSelections();
  }

  // ### _setSelectionToSugggestion
  // Set the selection to the character the user clicked on.
  _setSelectionToSugggestion() {
    this.selectionStart = this.suggestionIndex;
    this.selectionLength = 1;
    this.suggestionIndex = -1;
    this._updateSelections();
  }

  // ### handleMouseEvent
  // Handle hover/click behavior for the text under edit.
  // Returns: true if the event was handled here
  handleMouseEvent(ev) {
    let handled = false;
    var blocks = this.svgText.getIntersectingBlocks({
      x: ev.clientX,
      y: ev.clientY
    }, this.scroller.netScroll );

    // The mouse is not over the text
    if (!blocks.length) {
      svgHelpers.eraseOutline(this.context,'text-suggestion');

      // If the user clicks and there was a previous selection, treat it as selected
      if (ev.type === 'click' && this.suggestionIndex >= 0) {
        if (ev.shiftKey) {
          this._expandSelectionToSuggestion();
        } else {
          this._setSelectionToSugggestion();
        }
        handled = true;
      }
      this.svgText.render();
      return handled;
    }
    handled = true;
    // outline the text that is hovered.  Since mouse is a point
    // there should only be 1
    blocks.forEach((block) => {
      svgHelpers.outlineRect(this._suggestionParameters(block.box,'text-suggestion'));
      this.suggestionIndex = block.index;
    });
    // if the user clicked on it, add it to the selection.
    if (ev.type === 'click') {
      svgHelpers.eraseOutline(this.context,'text-suggestion');
      if (ev.shiftKey) {
        this._expandSelectionToSuggestion();
      } else {
        this._setSelectionToSugggestion();
      }
      this.svgText.render();
    }
    return handled;
  }

  // ### _serviceCursor
  // Flash the cursor as a background task
  _serviceCursor() {
    if (this.cursorState) {
      this.svgText.renderCursorAt(this.textPos - 1);
    } else {
      this.svgText.removeCursor();
    }
    this.cursorState = !this.cursorState;
  }
  // ### _refreshCursor
  // If the text position changes, update the cursor position right away
  // don't wait for blink.
  _refreshCursor() {
    this.svgText.removeCursor();
    this.cursorState = true;
    this._serviceCursor();
  }

  get _endCursorCondition() {
    return this.cursorRunning === false;
  }

  _cursorPreResolve() {
    this.svgText.removeCursor();
  }

  _cursorPoll() {
    this._serviceCursor();
  }

  // ### startCursorPromise
  // Used by the calling logic to start the cursor.
  // returns a promise that can be pended when the editing ends.
  startCursorPromise() {
    var self = this;
    this.cursorRunning = true;
    this.cursorState = true;
    self.svgText.renderCursorAt(this.textPos);
    return PromiseHelpers.makePromise(this,'_endCursorCondition','_cursorPreResolve','_cursorPoll',333);
  }
  stopCursor() {
    this.cursorRunning = false;
  }

  // ### setTextPos
  // Set the text position within the editor space and update the cursor
  setTextPos(val) {
    this.textPos = val;
    this._refreshCursor();
  }
  // ### moveCursorRight
  // move cursor right within the block of text.
  moveCursorRight() {
    if (this.textPos <= this.svgText.blocks.length) {
      this.setTextPos(this.textPos + 1);
    }
  }
  // ### moveCursorRight
  // move cursor left within the block of text.
  moveCursorLeft() {
    if (this.textPos > 0) {
      this.setTextPos(this.textPos - 1);
    }
  }

  // ### moveCursorRight
  // highlight the text selections
  _updateSelections() {
    let i = 0;
    const end = this.selectionStart + this.selectionLength;
    const start =  this.selectionStart;
    this.svgText.blocks.forEach((block) => {
      const val = start >= 0 && i >= start && i < end;
      this.svgText.setHighlight(block,val);
      ++i;
    });
  }

  // ### _checkGrowSelectionLeft
  // grow selection within the bounds
  _checkGrowSelectionLeft() {
    if (this.selectionStart > 0) {
      this.selectionStart -= 1;
      this.selectionLength += 1;
    }
  }
  // ### _checkGrowSelectionRight
  // grow selection within the bounds
  _checkGrowSelectionRight() {
    const end = this.selectionStart + this.selectionLength;
    if (end < this.svgText.blocks.length) {
      this.selectionLength += 1;
    }
  }

  // ### growSelectionLeft
  // handle the selection keys
  growSelectionLeft() {
    if (this.selectionStart === -1) {
      this.moveCursorLeft();
      this.selectionStart = this.textPos;
      this.selectionLength = 1;
    } else if (this.textPos === this.selectionStart) {
      this.moveCursorLeft();
      this._checkGrowSelectionLeft();
    }
    this._updateSelections();
  }

  // ### growSelectionRight
  // handle the selection keys
  growSelectionRight() {
    if (this.selectionStart === -1) {
      this.selectionStart = this.textPos;
      this.selectionLength = 1;
      this.moveCursorRight();
    } else if (this.selectionStart + this.selectionLength === this.textPos) {
      this._checkGrowSelectionRight();
      this.moveCursorRight();
    }
    this._updateSelections();
  }

  // ### _clearSelections
  // Clear selected text
  _clearSelections() {
    this.selectionStart = -1;
    this.selectionLength = 0;
  }

  // ### deleteSelections
  // delete the selected blocks of text/glyphs
  deleteSelections() {
    const blockPos = this.selectionStart;
    for (var i = 0;i < this.selectionLength; ++i) {
      this.svgText.removeBlockAt(blockPos); // delete shifts blocks so keep index the same.
    }
    this.setTextPos(blockPos);
    this.selectionStart = -1;
    this.selectionLength = 0;
  }

  // ### parseBlocks
  // THis can be overridden by the base class to create the correct combination
  // of text and glyph blocks based on the underlying text
  parseBlocks() {
    this.svgText = new SuiInlineText({ context: this.context,startX: this.x, startY: this.y });
    for (var i =0;i < this.text.length; ++i) {
      this.svgText.addTextBlockAt(i,{text:this.text[i]});
      this.empty = false;
    }
    this.textPos = this.text.length;
    this.state = SuiLyricEditor.States.RUNNING;
    this.svgText.render();
  }
  // ### evKey
  // Handle key events that filter down to the editor
  evKey(evdata) {
    if (evdata.code === 'ArrowRight') {
      if (evdata.shiftKey) {
        this.growSelectionRight();
      } else {
        this.moveCursorRight();
      }
      this.svgText.render();
      return true;
    }
    if (evdata.code === 'ArrowLeft') {
      if (evdata.shiftKey) {
        this.growSelectionLeft();
      } else {
        this.moveCursorLeft();
      }
      this.svgText.render();
      return true;
    }
    if (evdata.code === 'Backspace') {
      if (this.selectionStart >= 0) {
        this.deleteSelections();
      } else {
        if (this.textPos > 0) {
          this.selectionStart = this.textPos - 1;
          this.selectionLength = 1;
          this.deleteSelections();
        }
      }
      this.svgText.render();
      return true;
    }
    if (evdata.code === 'Delete') {
      if (this.selectionStart >= 0) {
        this.deleteSelections();
      } else {
        if (this.textPos > 0 && this.textPos < this.svgText.blocks.length) {
          this.selectionStart = this.textPos;
          this.selectionLength = 1;
          this.deleteSelections();
        }
      }
      this.svgText.render();
      return true;
    }
    if (evdata.key.charCodeAt(0) >= 33 && evdata.key.charCodeAt(0) <= 126  && evdata.key.length === 1) {
      if (this.empty) {
        this.svgText.removeBlockAt(0);
        this.empty = false;
        this.svgText.addTextBlockAt(0,{text: evdata.key});
        this.setTextPos(1);
      } else {
        if (this.selectionStart >= 0) {
          this.deleteSelections();
        }
        this.svgText.addTextBlockAt(this.textPos,{ text: evdata.key, textType:this.textType});
        this.setTextPos(this.textPos + 1);
      }
      this.svgText.render();
      return true;
    }
    return false;
  }
}
class SuiTextBlockEditor extends SuiTextEditor {
  // ### ctor
  // ### args
  // params: {lyric: SmoLyric,...}
  constructor(params) {
    super(params);
    this.parseBlocks();
  }

  _highlightEditor() {
    if (this.svgText.blocks.length === 0) {
      return;
    }
    var bbox = this.svgText.getLogicalBox();
    const outlineStroke = SuiTextEditor.strokes['text-highlight'];
    const obj = {
      context: this.context, box: bbox,classes: 'text-highlight',
         outlineStroke, scroller: this.scroller
    };
    svgHelpers.outlineLogicalRect(obj);
  }

  getText() {
    return this.svgText.getText();
  }

  evKey(evdata) {
    if (evdata.key.charCodeAt(0) == 32) {
      if (this.empty) {
        this.svgText.removeBlockAt(0);
        this.empty = false;
        this.svgText.addTextBlockAt(0,{text: ' '});
        this.setTextPos(1);
      } else {
        if (this.selectionStart >= 0) {
          this.deleteSelections();
        }
        this.svgText.addTextBlockAt(this.textPos,{ text: ' ', textType:this.textType});
        this.setTextPos(this.textPos + 1);
      }
      this.svgText.render();
      return true;
    }
    const rv = super.evKey(evdata);
    this._highlightEditor();
    return rv;
  }

  stopEditor() {
    this.state = SuiLyricEditor.States.STOPPING;
    $(this.context.svg).find('g.vf-' + 'text-highlight').remove();
    this.stopCursor();
    this.svgText.unrender();
  }
}

class SuiLyricEditor extends SuiTextEditor {
  static get States() {
    return { RUNNING: 1, STOPPING: 2, STOPPED: 4 };
  }
  parseBlocks() {
    this.svgText = new SuiInlineText({ context: this.context,startX: this.x, startY: this.y });
    for (var i =0;i < this.text.length; ++i) {
      this.svgText.addTextBlockAt(i,{text:this.text[i]});
      this.empty = false;
    }
    this.textPos = this.text.length;
    this.state = SuiLyricEditor.States.RUNNING;
    this.svgText.render();
  }

  getText() {
    return this.svgText.getText();
  }

  // ### ctor
  // ### args
  // params: {lyric: SmoLyric,...}
  constructor(params) {
    super(params);
    this.text = params.lyric._text;
    this.lyric = params.lyric;
    this.sessionNotifier = params.sessionNotifier;
    this.parseBlocks();
  }

  stopEditor() {
    this.state = SuiLyricEditor.States.STOPPING;
    this.stopCursor();
    this.svgText.unrender();
  }
}

class SuiChordEditor extends SuiTextEditor {
  static get States() {
    return { RUNNING: 1, STOPPING: 2, STOPPED: 4 };
  }
  static get SymbolModifiers() {
    return {
      NONE: 1,
      SUBSCRIPT: 2,
      SUPERSCRIPT: 3
    };
  }


  _setSymbolModifier(char) {
    if (char === '^') {
      this.textType =
        this.textType ===  SuiInlineText.textTypes.superScript
          ? SuiInlineText.textTypes.none
          : SuiInlineText.textTypes.superScript;
      return true;
    } else if (char === '%') {
      this.textType =
        this.textType ===  SuiInlineText.textTypes.subScript
          ? SuiInlineText.textTypes.none
          : SuiInlineText.textTypes.subScript;
      return true;
    }
    return false;
  }

  parseBlocks() {
    let readGlyph = false;
    let curGlyph = '';
    let blockIx = 0;
    this.svgText = new SuiInlineText({ context: this.context,startX: this.x, startY: this.y });

    for (var i =0;i < this.text.length; ++i) {
      let char = this.text[i];
      if (!this._setSymbolModifier(char)) {
      } else if (char === '@') {
        if (!readGlyph) {
          readGlyph = true;
          curGlyph = '';
        } else {
          this._addGlyphAt(blockIx,curGlyph);
          blockIx += 1;
        }
    } else {
      if (readGlyph) {
        curGlyph = curGlyph + char;
      } else {
        this.svgText.addTextBlockAt(i,{text:char, textType: this.textType});
      }
    }
      this.empty = false;
    }
    this.textPos = this.text.length;
    this.state = SuiLyricEditor.States.RUNNING;
    this.svgText.render();
  }

  _toTextTypeChar(oldTextType, newTextType) {
    if (newTextType === SuiInlineText.textTypes.subScript) {
      return '%';
    }

    if (newTextType === SuiInlineText.textTypes.superScript) {
      return '^';
    }

    if (oldTextType === SuiInlineText.textTypes.superScript &&
         newTextType === SuiInlineText.textTypes.normal)  {
      return '^';
    }
    if (oldTextType === SuiInlineText.textTypes.subScript &&
         newTextType === SuiInlineText.textTypes.normal)  {
      return '%';
    }
    return '';
  }

  // ### getText
  // Get the text value that we persist
  getText() {
    if (this.svgText.blocks < 1) {
      return '';
    }
    let text = '';
    let textType = this.svgText.blocks[0].textType;
    this.svgText.blocks.forEach((block) => {
      if (block.textType != textType) {
        text += this._toTextTypeChar(textType,block.textType);
        textType = block.textType;
      }
      if (block.symbolType === SuiInlineText.symbolTypes.GLYPH) {
        text += '@' + block.glyphCode + '@';
      } else {
        text += block.text;
      }
    });
    return text;
  }

  _addGlyphAt(ix,code) {
    if (this.selectionStart >= 0) {
      this.deleteSelections();
    }
    this.svgText.addGlyphBlockAt(ix,{glyphCode:code,textType:this.textType});
    this.textPos += 1;
  }

  evKey(evdata) {
    if (this._setSymbolModifier(evdata.key)) {
      return true;
    }
    // Dialog gives us a specific glyph code
    if (evdata.key[0] === '@' && evdata.key.length > 2) {
      const glyph = evdata.key.substr(1,evdata.key.length - 2);
      this._addGlyphAt(this.textPos,glyph);
      this.svgText.render();
    } else if (VF.ChordSymbol.glyphs[evdata.key[0]]) { // glyph shortcut like 'b'
      this._addGlyphAt(this.textPos,VF.ChordSymbol.glyphs[evdata.key[0]].code);
      this.svgText.render();
    } else {
      // some ordinary key
      super.evKey(evdata);
    }
    if (this.svgText.blocks.length > this.textPos && this.textPos >= 0) {
      this.textType = this.svgText.blocks[this.textPos].textType;
    }
    // if (evdata.substr)

  }

  // ### ctor
  // ### args
  // params: {lyric: SmoLyric,...}
  constructor(params) {
    super(params);
    this.text = params.lyric._text;
    this.lyric = params.lyric;
    this.sessionNotifier = params.sessionNotifier;
    this.textTypes = SuiInlineText.textTypes.none;
    this.glyphCur = '';
    this.parseBlocks();
  }

  stopEditor() {
    this.state = SuiLyricEditor.States.STOPPING;
    this.stopCursor();
    this.svgText.unrender();
  }

  // ### _markStopped
  // Indicate this editor session is done running
  _markStopped() {
    this.state = SuiLyricSession.States.STOPPED;
  }
}

class SuiResizeTextSession {

  static get defaultSpring() {
    return 0.1;
  }
  static get resizeModes() {
    return {BOX: 1, FONT: 2}
  }
  static get defaults () {
    return {
      spring : 0.1,
      resizeMode : SuiResizeTextSession.resizeModes.FONT,
      dragging: false,
      startDragPoint: { x: -1, y: -1}
    }
  }
  constructor(params) {
    Vex.Merge(this,SuiResizeTextSession.defaults);
    Vex.Merge(this,params);
    this.textObject = SuiTextBlock.fromTextGroup(this.textGroup,this.context); // SuiTextBlock
    this.startBox = this.textObject.getLogicalBox();
    this.clientBox = this.textObject.getRenderedBox();
    this.startBox.y += this.textObject.maxFontHeight(1);
    this.currentBox = svgHelpers.smoBox(this.startBox);

    this.currentClientBox = svgHelpers.adjustScroll(svgHelpers.logicalToClient(this.context.svg, this.currentBox),this.scroller.netScroll);
  }
  _outlineBox() {
    const outlineStroke = SuiTextEditor.strokes['text-drag'];
    const obj = {
      context: this.context, box: this.currentBox,classes: 'text-drag',
         outlineStroke, scroller: this.scroller
    };
    svgHelpers.outlineLogicalRect(obj);
  }

  startDrag(e) {
    if (!svgHelpers.containsPoint(this.clientBox,{x: e.clientX,y: e.clientY}, this.scroller.netScroll)) {
      return;
    }

    this.dragging = true;
    this.startDragPoint = {x: e.clientX, y: e.clientY };
    this.deltaDrag = null;
    // calculate offset of mouse start vs. box UL
    this._outlineBox();
  }

  mouseMove(e) {
    if (!this.dragging) {
      return;
    }
    const clientX = this.startDragPoint.x;
    const clientY = this.startDragPoint.y;
    const xdelta = e.clientX - clientX;
    const ydelta = e.clientY - clientY;
    if (!this.deltaDrag) {
      this.deltaDrag = {x: xdelta, y: ydelta};
      return;
    }
    const dragDiff = Math.abs(xdelta) - Math.abs(this.deltaDrag.x);
    const coeff = dragDiff > 0 ? 2 : 0.5;
    const  absRate = 1 + (this.spring * coeff);
    const rate = xdelta > 0 ? absRate : 1/absRate;
    this.textGroup.scaleInPlace(rate);
    this.textObject.rescale(rate);
    this.textObject.render();
    this._outlineBox();
    this.deltaDrag = {x: xdelta, y: ydelta};
  }
  endDrag(e) {
    this.dragging = false;
    svgHelpers.eraseOutline(this.context,'text-drag');
    this.textObject.render();
  }
}
class SuiDragSession {
  constructor(params) {
    this.textGroup = params.textGroup;
    this.context = params.context;
    this.scroller = params.scroller;
    this.xOffset = 0;
    this.yOffset = 0;
    this.textObject = SuiTextBlock.fromTextGroup(this.textGroup,this.context); // SuiTextBlock
    this.dragging = false;
    this.startBox = this.textObject.getLogicalBox();
    this.startBox.y += this.textObject.maxFontHeight(1);
    this.currentBox = svgHelpers.smoBox(this.startBox);
    this.currentClientBox = svgHelpers.adjustScroll(svgHelpers.logicalToClient(this.context.svg, this.currentBox),this.scroller.netScroll);
  }

  _outlineBox() {
    const outlineStroke = SuiTextEditor.strokes['text-drag'];
    const obj = {
      context: this.context, box: this.currentBox,classes: 'text-drag',
         outlineStroke, scroller: this.scroller
    };
    svgHelpers.outlineLogicalRect(obj);
  }

  startDrag(e) {
    if (!svgHelpers.containsPoint(this.currentClientBox,{x: e.clientX,y: e.clientY}, this.scroller.netScroll)) {
      return;
    }
    this.dragging = true;
    // calculate offset of mouse start vs. box UL
    this.yOffset = this.currentClientBox.y - e.clientY;
    this.xOffset = this.currentClientBox.x - e.clientX;
    this._outlineBox();
  }

  mouseMove(e) {
    if (!this.dragging) {
      return;
    }
    const svgX = this.currentBox.x;
    const svgY = this.currentBox.y;
    const clientX = this.currentClientBox.x;
    const clientY = this.currentClientBox.y;

    this.currentClientBox.x = e.clientX - this.xOffset;
    this.currentClientBox.y = e.clientY - this.yOffset;
    const coor = svgHelpers.clientToLogical(this.context.svg, {x: this.currentClientBox.x, y: this.currentClientBox.y });
    this.currentBox.x = coor.x;
    this.currentBox.y = coor.y;
    this.textObject.offsetStartX(this.currentBox.x - svgX);
    this.textObject.offsetStartY(this.currentBox.y - svgY);
    this.textObject.render();
    this._outlineBox();
  }
  get deltaX() {
    return this.currentBox.x - this.startBox.x;
  }
  get deltaY() {
    return this.currentBox.y - this.startBox.y;
  }

  endDrag(ev) {
    svgHelpers.eraseOutline(this.context,'text-drag');
    this.textObject.render();
    this.textGroup.offsetX(this.deltaX);
    this.textGroup.offsetY(this.deltaY);
    this.dragging = false;
  }
}

// ## SuiTextSession
// session for editing plain text
class SuiTextSession {
  static get States() {
    return { RUNNING: 1, STOPPING: 2, STOPPED: 4, PENDING_EDITOR: 8 };
  }
  constructor(params) {
    this.score = params.score;
    this.layout = params.layout;
    this.scroller = params.scroller;
    this.scoreText = params.scoreText;
    this.text = params.text ? params.text : '';
    this.x = params.x;
    this.y = params.y;
    this.textGroup = params.textGroup;
    this.scoreText = params.scoreText;
    this.fontFamily = params.fontFamily ? params.fontFamily :
      SuiInlineText.defaults.fontFamily;
    this.fontSize = params.fontSize ? params.fontSize :
      SuiInlineText.defaults.fontSize;
    this.fontWeight = params.fontSize ? params.fontSize :
        SuiInlineText.defaults.fontSize;

    // Create a text group if one was not a startup parameter
    if (!this.textGroup) {
      this.textGroup = new SmoTextGroup();
    }
    // Create a scoreText if one was not a startup parameter, or
    // get it from the text group
    if (!this.scoreText) {
      if (this.textGroup && this.textGroup.textBlocks.length) {
        this.scoreText = this.textGroup.textBlocks[0].text;
      } else {
        this.scoreText = new SmoScoreText({x: this.x,y: this.y});
        this.textGroup.addScoreText(this.scoreText,null,SmoTextGroup.relativePosition.RIGHT);
      }
    }
    this.text = this.scoreText.text;
  }

  // ### _isRefreshed
  // renderer has partially rendered text(promise condition)
  get _isRefreshed() {
    return this.layout.dirty === false;
  }

  get isStopped() {
    return this.state === SuiTextSession.States.STOPPED;
  }

  get isRunning() {
    return this.state === SuiTextSession.States.RUNNING;
  }

  _markStopped() {
    this.state = SuiTextSession.States.STOPPED;
  }

  // ### _isRendered
  // renderer has rendered text(promise condition)
  get _isRendered() {
    return this.layout.passState ===  suiLayoutBase.passStates.clean;
  }

  _removeScoreText() {
    const selector = '#' + this.scoreText.attrs.id;
    $(selector).remove();
  }

  // ### _startSessionForNote
  // Start the lyric session
  startSession() {
    console.log('startSession');
    this.editor = new SuiTextBlockEditor({context : this.layout.context,
       x: this.x, y: this.y, scroller: this.scroller,
     fontFamily: this.fontFamily, fontSize: this.fontSize, fontWeight: this.fontWeight
     ,text: this.scoreText.text});
    this.cursorPromise = this.editor.startCursorPromise();
    this.state = SuiTextSession.States.RUNNING;
    this._removeScoreText();
  }

  // ### _startSessionForNote
  // Stop the lyric session, return promise for done
  stopSession() {
    console.log('stopSession');
    if (this.editor) {
      this.scoreText.text = this.editor.getText();
      this.editor.stopEditor();
    }
    return PromiseHelpers.makePromise(this,'_isRendered','_markStopped',null,100);
  }

  // ### evKey
  // Key handler (pass to editor)
  evKey(evdata) {
    if (this.state !== SuiTextSession.States.RUNNING) {
      return false;
    }
    const rv = this.editor.evKey(evdata);
    if (rv) {
      this._removeScoreText();
    }
  }

  handleMouseEvent(ev) {
    if (this.isRunning) {
      this.editor.handleMouseEvent(ev);
    }
  }
}
// ## SuiLyricSession
// Manage editor for lyrics, jupmping from note to note if asked
class SuiLyricSession {

  static get States() {
    return { RUNNING: 1, STOPPING: 2, STOPPED: 4, PENDING_EDITOR: 8 };
  }
  constructor(params) {
    this.score = params.score;
    this.layout = params.layout;
    this.scroller = params.scroller;
    this.parser = params.parser ? params.parser : SmoLyric.parsers.lyric;
    this.verse = params.verse;
    this.selector = params.selector;
    this.selection = SmoSelection.noteFromSelector(this.score, this.selector);
    this.note = this.selection.note;
  }

  // ### _setLyricForNote
  // Get the text from the editor and update the lyric with it.
  _setLyricForNote() {
    this.lyric = null;
    console.log('_setLyricForNote');
    const lar = this.note.getLyricForVerse(this.verse,SmoLyric.parsers.lyric);
    if (lar.length) {
      this.lyric = lar[0];
    }
    if (!this.lyric) {
      this.lyric =  new SmoLyric({_text:'',verse: this.verse });
      this.note.addLyric(this.lyric);
    }
    this.text = this.lyric._text;
  }

  // ### _endLyricCondition
  // Lyric editor has stopped running (promise condition)
  get _endLyricCondition()  {
    return this.editor.state !== SuiLyricEditor.States.RUNNING;
  }

  // ### _endLyricCondition
  // renderer has partially rendered text(promise condition)
  get _isRefreshed() {
    return this.layout.dirty === false;
  }

  // ### _isRendered
  // renderer has rendered text(promise condition)
  get _isRendered() {
    return this.layout.passState ===  suiLayoutBase.passStates.clean;
  }

  get _pendingEditor() {
    return this.state !== SuiLyricSession.States.PENDING_EDITOR;
  }

  // ### _hideLyric
  // Hide the lyric so you only see the editor.
  _hideLyric() {
    if (this.lyric.selector) {
      $(this.lyric.selector).remove();
    }
  }

  get isStopped() {
    return this.state === SuiLyricSession.States.STOPPED;
  }

  get isRunning() {
    return this.state === SuiLyricSession.States.RUNNING;
  }

  // ### _markStopped
  // Indicate this editor session is done running
  _markStopped() {
    this.state = SuiLyricSession.States.STOPPED;
  }

  // ### _startSessionForNote
  // Start the lyric editor for a note (current selected note)
  _startSessionForNote() {
    console.log('_startSessionForNote');
    const lyricRendered = this.lyric._text.length && this.lyric.logicalBox;
    const startX = lyricRendered ? this.lyric.logicalBox.x : this.note.logicalBox.x;
    const startY = lyricRendered ? this.lyric.logicalBox.y + this.lyric.adjY + this.lyric.logicalBox.height :
          this.note.logicalBox.y + this.note.logicalBox.height;
    this.editor = new SuiLyricEditor({context : this.layout.context,
      lyric: this.lyric, x: startX, y: startY, scroller: this.scroller});
    this.state = SuiLyricSession.States.RUNNING;
    if (!lyricRendered) {
      const delta = 2 * this.editor.svgText.maxFontHeight(1.0) * (this.lyric.verse + 1)
      this.editor.svgText.offsetStartY(delta);
    }
    this.cursorPromise = this.editor.startCursorPromise();
    this._hideLyric();
  }

  // ### _startSessionForNote
  // Start the lyric session
  startSession() {
    this._setLyricForNote();
    this._startSessionForNote();
    console.log('startSession');

    this.state = SuiLyricSession.States.RUNNING;
  }

  // ### _startSessionForNote
  // Stop the lyric session, return promise for done
  stopSession() {
    console.log('stopSession');
    if (this.editor && !this._endLyricCondition) {
      this._updateLyricFromEditor();
    }
    return PromiseHelpers.makePromise(this,'_isRendered','_markStopped',null,100);
  }

  // ### _advanceSelection
  // Based on a skip character, move the editor forward/back one note.
  _advanceSelection(isShift) {
    const nextSelection = isShift ? SmoSelection.lastNoteSelectionFromSelector(this.score,this.selector)
     : SmoSelection.nextNoteSelectionFromSelector(this.score,this.selector);
    if (nextSelection) {
      console.log('_advanceSelection');
      this.selector = nextSelection.selector;
      this.selection = nextSelection;
      this.note = nextSelection.note;
      this._setLyricForNote();
      const conditionArray = [];
      this.state = SuiLyricSession.States.PENDING_EDITOR;
      conditionArray.push(PromiseHelpers.makePromiseObj(this,'_endLyricCondition',null,null,100));
      conditionArray.push(PromiseHelpers.makePromiseObj(this,'_isRefreshed','_startSessionForNote',null,100));
      PromiseHelpers.promiseChainThen(conditionArray);
    }
  }

  // ### advanceSelection
  // external interfoace to move to next/last note
  advanceSelection(isShift) {
    if (this.isRunning) {
      this._updateLyricFromEditor();
      this._advanceSelection(isShift);
    }
  }

  removeLyric() {
    if (this.selection && this.lyric) {
      this.selection.note.removeLyric(this.lyric);
    }
  }


  // ### _updateLyricFromEditor
  // The editor is done running, so update the lyric now.
  _updateLyricFromEditor() {
    const txt = this.editor.getText();
    this.lyric.setText(txt);
    this.editor.stopEditor();
    this.layout.addToReplaceQueue(this.selection);
  }
  // ### evKey
  // Key handler (pass to editor)
  evKey(evdata) {
    if (this.state !== SuiLyricSession.States.RUNNING) {
      return;
    }
    var str = evdata.key;
    if (evdata.key === '-' || evdata.key === ' ') {
      // skip
      const back = evdata.shiftKey && evdata.key === ' ';
      if (evdata.key === '-') {
        this.editor.evKey(evdata);
      }
      this._updateLyricFromEditor();
      this._advanceSelection(back);
    } else {
      this.editor.evKey(evdata);
      this._hideLyric();
    }
  }

  // ### handleMouseEvent
  // Mouse event (send to editor)
  handleMouseEvent(ev) {
    if (this.state !== SuiLyricSession.States.RUNNING) {
      return;
    }
    return this.editor.handleMouseEvent(ev);
  }
}

class SuiChordSession extends SuiLyricSession {
  constructor(params) {
    super(params);
    this.parser = SmoLyric.parsers.chord;
  }

  // ### evKey
  // Key handler (pass to editor)
  evKey(evdata) {
    if (this.state !== SuiLyricSession.States.RUNNING) {
      return;
    }
    if (evdata.code === 'Enter') {
      this._updateLyricFromEditor();
      this._advanceSelection(evdata.shiftKey);
    }
    this.editor.evKey(evdata);
    this._hideLyric();
  }

  // ### _setLyricForNote
  // Get the text from the editor and update the lyric with it.
  _setLyricForNote() {
    this.lyric = null;
    const lar = this.note.getLyricForVerse(this.verse, this.parser);
    if (lar.length) {
      this.lyric = lar[0];
    }
    if (!this.lyric) {
      this.lyric =  new SmoLyric({_text:'',verse: this.verse, parser: this.parser});
      this.note.addLyric(this.lyric);
    }
    this.text = this.lyric._text;
  }
  // ### _startSessionForNote
  // Start the lyric editor for a note (current selected note)
  _startSessionForNote() {
    const lyricRendered = this.lyric._text.length && this.lyric.logicalBox;
    const startX = lyricRendered ? this.lyric.logicalBox.x : this.note.logicalBox.x;
    const startY = lyricRendered ? this.lyric.logicalBox.y + this.lyric.adjY + this.lyric.logicalBox.height :
          this.selection.measure.logicalBox.y + this.selection.measure.logicalBox.height - 70;
    this.editor = new SuiChordEditor({context : this.layout.context,
      lyric: this.lyric, x: startX, y: startY, scroller: this.scroller});
    this.state = SuiLyricSession.States.RUNNING;
    if (!lyricRendered) {
      const delta = (-1) * this.editor.svgText.maxFontHeight(1.0) * (this.lyric.verse + 1)
      this.editor.svgText.offsetStartY(delta);
    }
    this.cursorPromise = this.editor.startCursorPromise();
    this._hideLyric();
  }


}

// ## editSvgText
// A class that implements very basic text editing behavior in an svg text node
// params must supply the following:
// 1. target: an svg text element
// 2. textObject: a text object described below.
// 3. layout: the page layout information, used to create the shadow editor in the DOM
// The textObject must have the following attributes:
// 1. getText returns the text (the text to render initially)
// 2. translateX, translateY, scaleX, scaleY for svg text element
// 3. fontInfo from smoScoreText and other text objects
class editSvgText {
  constructor(params) {
    this.target = params.target;
    var ns = svgHelpers.namespace;
    this.layout = params.layout;
    this.fontInfo = params.textObject.fontInfo;
		this.svg = document.createElementNS(ns, 'svg');
    this.editText = document.createElementNS(ns, 'text');
    this.textObject = params.textObject;
    this.attrAr = [];
    this.id = VF.Element.newID();

    // create a mirror of the node under edit by copying attributes
    // and setting up a similarly-dimensioned viewbox
    editSvgText.textAttrs.forEach((attr) => {
  		if (this.target.attributes[attr]) {
         		var val = this.target.attributes[attr].value;
  			this.editText.setAttributeNS('',attr,val);
  			this.attrAr.push(JSON.parse('{"'+attr+'":"'+val+'"}'));
  		}
    });
    this.editing = this.running=false;

    // Hide the original - TODO, handle non-white background.
    this.oldFill = this.target.getAttributeNS(null,'fill');
    this.target.setAttributeNS(null,'fill','#fff');

    this.editText.textContent=this.textObject.getText();
    this._value = this.textObject.getText();
    var svgBox = svgHelpers.smoBox(this.target.getBBox());
    this.clientBox = svgHelpers.smoBox(svgHelpers.smoBox(this.target.getBoundingClientRect()));
    if (this.textObject.boxModel != 'none') {
      svgBox = svgHelpers.boxPoints(this.textObject.x,this.textObject.y,this.textObject.width,this.textObject.height);
      var boxDims = svgHelpers.logicalToClient(this.svg,svgBox);
      this.clientBox.width = boxDims.width;
      this.clientBox.height = boxDims.height;
    }
    this.editText.setAttributeNS('','y',svgBox.height);

    $('.textEdit').html('');
    this.svg.appendChild(this.editText);
    var b = htmlHelpers.buildDom;
    var r = b('span').classes('hide icon-move');
    $('.textEdit').append(r.dom());
    $('.textEdit').append(this.svg);
    $('.textEdit').removeClass('hide').attr('contentEditable','true');
    this.setEditorPosition(this.clientBox,svgBox,params);
    layoutDebug.addTextDebug('editSvgText: ctor '+this.id);
  }

  setEditorPosition(clientBox,svgBox) {
    var box = svgHelpers.pointBox(this.layout.pageWidth, this.layout.pageHeight);
    svgHelpers.svgViewport(this.svg, this.textObject.translateX,this.textObject.translateY, box.x,box.y,this.layout.svgScale);

    $('.textEdit').css('top',this.clientBox.y-5)
      .css('left',this.clientBox.x-5)
      .width(this.clientBox.width+10)
      .height(this.clientBox.height+10);
  }

  endSession() {
    this.editing = false;
    layoutDebug.addTextDebug('editSvgText: endSession for '+this.id);
    this.target.setAttributeNS(null,'fill',this.oldFill);
  }

  get value() {
    return this._value;
  }

  _updateText() {
    $('.textEdit').focus();

    if (this.editText.textContent &&
      this.editText.textContent.length &&
      this._value != this.editText.textContent) {
      this.target.textContent = this._value = this.editText.textContent;
      this._value = this.target.textContent;
      var fontAttr = svgHelpers.fontIntoToSvgAttributes(this.fontInfo);
      var svgBox = svgHelpers.getTextBox(this.svg,this.attrAr,null,this._value);
      var nbox = svgHelpers.logicalToClient(this.svg,svgBox);
      if (nbox.width > this.clientBox.width) {
         this.clientBox.width = nbox.width + nbox.width*.3;
         this.clientBox.height = nbox.height;
         this.setEditorPosition(this.clientBox,svgBox,{xOffset:0,yOffset:0});
       }
    }
    if (!this.editText.textContent) {
       this.editText.textContent='\xa0';
    }
  }

  // ### endTextEditSessionPromise
  // return a promise that is resolved when the current text edit session ends.
  endTextEditSessionPromise() {
      var self=this;
      $('body').addClass('text-edit');

      this.editing=true;
      this.running = true;
      layoutDebug.addTextDebug('editSvgText: create endTextEditSessionPromise '+this.id);
      const promise = new Promise((resolve, reject) => {
        function editTimer() {
          setTimeout(function() {
            self._updateText();
            if (self.editing) {
              editTimer();
            } else {
              self._updateText();
              layoutDebug.addTextDebug('editSvgText: resolve endTextEditSessionPromise promise '+self.id);
              resolve();
            }
          },25);
        }
        editTimer();
	  });

    return promise;
  }

    static get textAttrs() {
      return ['font-size','font-family','font-weight','fill','transform'];
    }
}

// ## editLyricSession
// Another interface between UI and renderer, let the user enter lyrics while
// navigating through the notes.  This class handles the session of editing
// a single note, and also the logic of skipping from note to note.
class editLyricSession {
	static get states() {
    return {stopped:0,started:1,minus:2,space:3,backSpace:4,stopping:5};
  }
	// tracker, selection, controller
  constructor(parameters) {
    this.tracker = parameters.tracker;
    this.selection = parameters.selection;
    this.completeNotifier = parameters.completeNotifier;
    this.eventSource = parameters.eventSource;
    this.verse=parameters.verse;
    this.notifier = parameters.notifier;
	  this.bound = false;
    this.state=editLyricSession.states.stopped;
    this.parser = parameters.parser;
    layoutDebug.addTextDebug('editLyricSession: create note '+this.selection.note.attrs.id);
  }

  detach() {
    layoutDebug.addTextDebug('editLyricSession: detach() from '+this.selection.note.attrs.id);
    this.state = editLyricSession.states.stopping;
    this.editor.endSession();
    this.lyric.setText(this.editor.value);
		this.eventSource.unbindKeydownHandler( this.keydownHandler, true);
    if (this.selection) {
      this.selection.measure.changed=true;
    }
  }

  // ### detachEditorCompletePromise
  // A promise that is resolved when SVG editor is fully detached.
  detachEditorCompletePromise() {
    var self=this;
    layoutDebug.addTextDebug('editLyricSession:create detachEditorCompletePromise from '+this.selection.note.attrs.id);
    return new Promise((resolve) => {
      var waiter = () => {
      setTimeout(() => {
        if (self.state == editLyricSession.states.stopping ||
          self.state == editLyricSession.states.stopped) {
          layoutDebug.addTextDebug('editLyricSession:resolve detachEditorCompletePromise promise from '+self.selection.note.attrs.id);
          resolve();
         } else {
           waiter();
         }
        },50);
      };
      waiter();
    });
  }

    // ### _lyricAddedPromise
    // Don't edit the lyric until the DOM part has been added by the editor, so pend on a promise that has happened.
  _lyricAddedPromise() {
    var self=this;
    layoutDebug.addTextDebug('editLyricSession:create _lyricAddedPromise promise from '+self.selection.note.attrs.id);
    return new Promise((resolve) => {
      var checkAdd = function() {
        setTimeout(function() {
          self.textElement = $(self.tracker.layout.svg).find('#'+self.selection.note.renderId).find(self.lyric.getClassSelector())[0];
          if (self.textElement) {
              layoutDebug.addTextDebug('editLyricSession:resolve _lyricAddedPromise promise for  '+self.selection.note.attrs.id);
              resolve();
          } else {
              checkAdd();
          }
        },50);
      }
      checkAdd();
    });
  }

    // ### _editCurrentLyric
    // The DOM is ready.  Create the editor and wait for it to finish.
  _editCurrentLyric() {
    this.textElement = $(this.tracker.layout.svg).find('#'+this.selection.note.renderId).find(this.lyric.getClassSelector())[0];
    if (this.editor) {
      layoutDebug.addTextDebug('editLyricSession: _editCurrentLyric dispense with editor ' + this.editor.id);
    }
    this.editor = new editSvgText({target:this.textElement,
      textObject:this.lyric,
      layout:this.tracker.layout});
    this.state = editLyricSession.states.started;
    var self = this;
    function handleSkip() {
      layoutDebug.addTextDebug('editLyricSession:_editCurrentLyric endTextEditSessionPromise rcvd, editor is done, handleSkip for  '+self.selection.note.attrs.id);
      // Only skip to the next lyric if the session is still going on.
      if (self.state != editLyricSession.states.stopped && self.state != editLyricSession.states.stopping) {
          self._handleSkip();
      } else {  // session is stopping due to esc.
          self.notifier.detachCompleteEvent();
      }
    }

    this.editor.endTextEditSessionPromise().then(handleSkip);
  }

    // Start the editing session by creating editor, and wait for the editor to create the DOM element.
	_editingSession() {
    var self = this;
		if (!this.bound) {
			this.bindEvents();
		}
    function editCurrent() {
      layoutDebug.addTextDebug('editLyricSession:_lyricAddedPromise rcvd, _editCurrentLyric for  '+self.selection.note.attrs.id);
      self._editCurrentLyric();
    }
    this._lyricAddedPromise().then(editCurrent);
	}

  _getOrCreateLyric(note) {
    var lyrics =  note.getLyricForVerse(this.verse,this.parser);
    layoutDebug.addTextDebug('editLyricSession:new lyric created  ');
    if (!lyrics.length) {
			this.lyric = new SmoLyric({verse:this.verse,parser:this.parser});
    } else {
	   this.lyric = lyrics[0];
    }
  }
  removeLyric() {
    if (this.selection && this.lyric) {
      this.selection.note.removeLyric(this.lyric);
      this.tracker.replaceSelectedMeasures();
      this._deferSkip();
    }
  }

  _handleSkip() {
    // var tag = this.state == editLyricSession.states.minus ? '-' :'';
    this.lyric.setText(this.editor.value);
    this.selection.measure.changed = true;
    if (this.state != editLyricSession.states.stopping) {
      var func = (this.state == editLyricSession.states.backSpace) ? 'lastNoteSelection' : 'nextNoteSelection';
      var sel = SmoSelection[func](
      this.tracker.layout.score, this.selection.selector.staff,
      this.selection.selector.measure, this.selection.selector.voice, this.selection.selector.tick);
      if (sel) {
        layoutDebug.addTextDebug('editLyricSession:_handleSkip,  moving on to '+sel.note.attrs.id);
        this.selection=sel;
        this.notifier.notifySelectionChanged(this.selection);
        this.editNote();
      }
    } else {
      layoutDebug.addTextDebug('editLyricSession:_handleSkip, no more lyrics');
      this.detach();
    }
  }

  editNote() {
  	var self=this;
  	function _startEditing() {
  		self._editingSession();
  	}
    this._getOrCreateLyric(this.selection.note)
  	this.fontInfo = JSON.parse(JSON.stringify(this.lyric.fontInfo));
    this.selection.note.addLyric(this.lyric);
    this.selection.measure.changed = true;
    this.tracker.replaceSelectedMeasures();
    _startEditing();
    return this.detachEditorCompletePromise();
  }

    // ### _deferSkip
    // skip to the next word, but not in the current call stack.  Used to handl
    // interactions with the dialog, where the dialog must reset changed flags
    // before  selection is changed
  _deferSkip() {
    var self=this;
    setTimeout(function() {
      self._handleSkip();
    },1);
  }

    // ### moveSelectionRight
    // Selection can move automatically based on key events, but there are Also
    // UI ways to force it.
  moveSelectionRight() {
    this.state = editLyricSession.states.space;
    this._deferSkip();
  }

  moveSelectionLeft() {
    this.state = editLyricSession.states.backSpace;
    this._deferSkip();
  }

	evKey(event) {
		console.log("Lyric KeyboardEvent: key='" + event.key + "' | code='" +
			event.code + "'"
			 + " shift='" + event.shiftKey + "' control='" + event.ctrlKey + "'" + " alt='" + event.altKey + "'");

    if (suiController.keyboardWidget) {
     Qwerty.handleKeyEvent(event);
    }

    var isSkip = this.parser === SmoLyric.parsers.lyric ?
        ['Space', 'Minus'].indexOf(event.code) >= 0 : ['Space'].indexOf(event.code) >= 0;

		if (isSkip) {
      if (editLyricSession.states.minus && event.shiftKey) {
          // allow underscore
      } else {
        this.state =  (event.code == 'Minus') ? editLyricSession.states.minus :  editLyricSession.states.space;
        this.state = (this.state === editLyricSession.states.space && event.shiftKey)
		     ? editLyricSession.states.backSpace :  this.state;
        layoutDebug.addTextDebug('editLyricSession:  handleKeydown skip key for  '+this.selection.note.attrs.id);
        this.editor.endSession();
        return;
      }
		}

		if (event.code == 'Escape') {
      this.state = editLyricSession.states.stopping;
      this.editor.endSession();
      return;
		}
    layoutDebug.addTextDebug('editLyricSession:  handleKeydown pass on event for  '+this.selection.note.attrs.id);
    this.selection.measure.changed=true;
	}

  bindEvents() {
		var self = this;

		if (!this.bound) {
      this.keydownHandler = this.eventSource.bindKeydownHandler(this,'evKey');
			this.bound = true;
		}
	}
}

// ## editNoteText
// Manage editing text for a note, and navigating, adding and removing.
class noteTextEditSession {
  constructor(changeNotifier,tracker,verse,selection,eventSource,parser) {
    this.notifier = changeNotifier;
    this.tracker = tracker;
    this.verse = verse;
    this.selection = selection;
    this.eventSource = eventSource;
    this.parser = parser;
  }

  get isRunning() {
    return !(this.editor === null || (
      this.editor.state === editLyricSession.states.stopped ||
      this.editor.state === editLyricSession.states.stopping ));
  }

  notifySelectionChanged(selection) {
    if (selection) {
        layoutDebug.addTextDebug('SuiLyricEditComponent: lyric notification for ' + selection.note.attrs.id);
    } else {
        layoutDebug.addTextDebug('SuiLyricEditComponent: no selection');
    }
    if (this.selection == null || SmoSelector.neq(selection.selector,this.selection.selector)) {
        this.selection = selection;
        this.notifier.notifySelectionChanged();
    }
  }

  removeText() {
      this.editor.removeLyric();
  }

  moveSelectionRight() {
    this.editor.moveSelectionRight();
  }

  moveSelectionLeft() {
    this.editor.moveSelectionLeft();
  }

  setYOffset(y) {
    if (this.editor && this.editor.lyric) {
      this.editor.lyric.translateY = y;
    }
  }

  getYOffset() {
    if (this.editor && this.editor.lyric) {
      return this.editor.lyric.translateY;
    }
    return 0;
  }

  toggleSessionStateEvent() {
    if (this.editor.state == editLyricSession.states.stopped ||
        this.editor.state == editLyricSession.states.stopping)  {
        layoutDebug.addTextDebug('SuiLyricEditComponent: restarting button');
        this.startEditingSession();
    } else {
        layoutDebug.addTextDebug('SuiLyricEditComponent: stopping editor button');
        this.forceEndSessionEvent();
    }
  }

  // Inform client that the edit session is complete
  detachCompleteEvent() {
    this.notifier.notifySelectionChanged();
  }

  startEditingSession() {
    layoutDebug.addTextDebug('SuiLyricEditComponent: initial create editor request');
    this.editor = new editLyricSession(
      {
        tracker:this.tracker,
        verse:this.verse,
        selection:this.tracker.selections[0],
        completeNotifier:this.completeNotifier,
        notifier:this,
        eventSource:this.eventSource,
        parser:this.parser
      }
    );
    this.editor.editNote();
  }
  forceEndSessionEvent() {
    this.editor.detach();
  }
}
;

// ##browserEventSource
// Handle registration for events.  Can be used for automated testing, so all
// the events are consolidated in one place so they can be simulated or recorded
class browserEventSource {
  constructor(evMask) {
    this.keydownHandlers = [];
    this.mouseMoveHandlers = [];
    this.mouseClickHandlers = [];
    this.mouseUpHandlers = [];
    this.mouseDownHandlers = [];
    this.domTriggers = [];
    this.scrollers = [];
    this.handleKeydown = this.evKey.bind(this);
    this.vexContext = null;
    window.addEventListener("keydown", this.handleKeydown, true);
  }

  evKey(event) {
    this.keydownHandlers.forEach((handler) => {
      handler.sink[handler.method](event);
    });
  }

  mouseMove(event) {
    this.mouseMoveHandlers.forEach((handler) => {
      handler.sink[handler.method](event);
    });
  }

  mouseClick(event) {
    this.mouseClickHandlers.forEach((handler) => {
      handler.sink[handler.method](event);
    });
  }

  mouseDown(event) {
    this.mouseDownHandlers.forEach((handler) => {
      handler.sink[handler.method](event);
    });
  }

  mouseUp(event) {
    this.mouseUpHandlers.forEach((handler) => {
      handler.sink[handler.method](event);
    });
  }

  setRenderElement(renderElement) {
    this.renderElement = renderElement;
    var self = this;
    this.handleMouseMove = this.mouseMove.bind(this);
    this.handleMouseClick = this.mouseClick.bind(this);
    this.handleMouseUp = this.mouseUp.bind(this);
    this.handleMouseDown = this.mouseDown.bind(this);
    $(document)[0].addEventListener("mousemove",this.handleMouseMove);
    $(this.renderElement)[0].addEventListener("click",this.handleMouseClick);
    $(document)[0].addEventListener("mouseup",this.handleMouseUp);
    $(document)[0].addEventListener("mousedown",this.handleMouseDown);
  }

  _unbindHandlerArray(arSrc,arDest,handler) {
    arSrc.forEach((htest) => {
      if (handler.symbol !== htest.symbol) {
        arDest.push(htest);
      }
    });
  }

  unbindMouseMoveHandler(handler) {
    var handlers = [];
    this._unbindHandlerArray(this.mouseMoveHandlers,handlers,handler);
    this.mouseMoveHandlers = handlers;
  }
  unbindMouseDownHandler(handler) {
    var handlers = [];
    this._unbindHandlerArray(this.mouseDownHandlers,handlers,handler);
    this.mouseDownHandlers = handlers;
  }
  unbindMouseUpHandler(handler) {
    var handlers = [];
    this._unbindHandlerArray(this.mouseUpHandlers,handlers,handler);
    this.mouseUpHandlers = handlers;
  }
  unbindMouseClickHandler(handler) {
    var handlers = [];
    this._unbindHandlerArray(this.mouseClickHandlers,handlers,handler);
    this.mouseClickHandlers = handlers;
  }

  unbindKeydownHandler(handler) {
    var handlers = [];
    this._unbindHandlerArray(this.keydownHandlers,handlers,handler);
    this.keydownHandlers = handlers;
  }

  bindScroller(sink,method) {}

  // ### bindKeydownHandler
  // add a handler for the evKey event, for keyboard data.
  bindKeydownHandler(sink,method) {
    var handler = {};
    handler.symbol = Symbol();
    handler.sink = sink;
    handler.method = method;
    this.keydownHandlers.push(handler);
    return handler;
  }

  bindMouseMoveHandler(sink, method) {
    var handler = {symbol: Symbol(), sink, method};
    this.mouseMoveHandlers.push(handler);
    return handler;
  }

  bindMouseUpHandler(sink, method) {
    var handler = {symbol: Symbol(), sink, method};
    this.mouseUpHandlers.push(handler);
    return handler;
  }

  bindMouseDownHandler(sink, method) {
    var handler = {symbol: Symbol(), sink, method};
    this.mouseDownHandlers.push(handler);
    return handler;
  }

  bindMouseClickHandler(sink, method) {
    var handler = {symbol: Symbol(), sink, method};
    this.mouseClickHandlers.push(handler);
    return handler;
  }

  domClick(selector,sink,method,args) {
    $(selector).off('click').on('click',function(ev) {
      sink[method](ev,args);
    });
  }
}
;

// ## suiEditor
// Editor handles key events and converts them into commands, updating the score and
// display
class suiEditor {
  constructor(params) {
    Vex.Merge(this, params);
    this.slashMode = false;
  }

	tempoDialog() {
		SuiTempoDialog.createAndDisplay(
      {
        buttonElement:this.buttonElement,
        buttonData:this.buttonData,
        completeNotifier:this.controller,
        tracker: this.tracker,
        layout:this.layout,
        undoBuffer:this.undoBuffer,
        eventSource:this.eventSource,
        editor:this
      }
    );
	}

    // ## _render
    // utility function to render the music and update the tracker map.
    _render() {
		this.tracker.replaceSelectedMeasures();
    }

	_refresh() {
		this.layout.setRefresh();
	}

  get score() {
      return this.layout.score;
  }

  _renderAndAdvance() {
    this.tracker.replaceSelectedMeasures();
	  this.tracker.moveSelectionRight(null,true);
  }
  _rebeam() {
      this.tracker.getSelectedMeasures().forEach((measure) => {
        smoBeamerFactory.applyBeams(measure);
      });
  }
  _batchDurationOperation(operation) {
    SmoUndoable.batchDurationOperation(this.layout.score, this.tracker.selections, operation, this.undoBuffer);
    this._rebeam();
    this._render();
  }

	scoreSelectionOperation(selection,name,parameters,description) {
		SmoUndoable.scoreSelectionOp(this.layout.score,selection,name,parameters,
	    this.undoBuffer,description);
		this._render();
	}


	scoreOperation(name,parameters,description) {
		SmoUndoable.scoreOp(this.layout.score,name,parameters,this.undoBuffer,description);
		this._render();
	}

  _selectionOperation(selection, name, parameters) {
    if (parameters) {
      SmoUndoable[name](selection, parameters, this.undoBuffer);
    } else {
      SmoUndoable[name](selection, this.undoBuffer);
    }
	  this._render();
  }

  undo() {
    this.layout.undo(this.undoBuffer);
  }

  _singleSelectionOperation(name, parameters) {
    var selection = this.tracker.selections[0];
    if (parameters) {
      SmoUndoable[name](selection, parameters, this.undoBuffer);
    } else {
      SmoUndoable[name](selection, this.undoBuffer);
    }
    suiOscillator.playSelectionNow(selection);
    this._rebeam();
    this._render();
  }

  _transpose(selection, offset, playSelection) {
      this._selectionOperation(selection, 'transpose', offset);
      if (playSelection) {
          suiOscillator.playSelectionNow(selection);
      }
  }

  copy() {
      if (this.tracker.selections.length < 1) {
          return;
      }
      this.pasteBuffer.setSelections(this.layout.score, this.tracker.selections);
  }
  paste() {
      if (this.tracker.selections.length < 1) {
          return;
      }

      SmoUndoable.pasteBuffer(this.layout.score, this.pasteBuffer, this.tracker.selections, this.undoBuffer, 'paste')
      this._rebeam();
      this._refresh();
  }
  toggleBeamGroup() {
      if (this.tracker.selections.length < 1) {
          return;
      }
      SmoUndoable.toggleBeamGroups(this.tracker.selections, this.undoBuffer);
      this._rebeam();
      this._render();
  }

  beamSelections() {
      if (this.tracker.selections.length < 1) {
          return;
      }
      SmoUndoable.beamSelections(this.tracker.selections, this.undoBuffer);
      this._rebeam();
      this._render();
  }
  toggleBeamDirection() {
      if (this.tracker.selections.length < 1) {
          return;
      }
      SmoUndoable.toggleBeamDirection(this.tracker.selections, this.undoBuffer);
      this._render();
  }

  collapseChord() {
      SmoUndoable.noop(this.layout.score, this.undoBuffer);
      this.tracker.selections.forEach((selection) => {
          var p = selection.note.pitches[0];
          p = JSON.parse(JSON.stringify(p));
          selection.note.pitches = [p];
      });
      this._render();
  }

  playScore() {
    var mm = this.tracker.getExtremeSelection(-1);
    if (suiAudioPlayer.playingInstance && suiAudioPlayer.playingInstance.paused) {
      suiAudioPlayer.playingInstance.play();
      return;
    }
    new suiAudioPlayer({score:this.layout.score,startIndex:mm.selector.measure,tracker:this.tracker}).play();
  }

  stopPlayer() {
    suiAudioPlayer.stopPlayer();
  }
  pausePlayer() {
    suiAudioPlayer.pausePlayer();
  }

  intervalAdd(interval, direction) {
    this._singleSelectionOperation('interval', direction * interval);
  }

  interval(keyEvent) {
    if (this.tracker.selections.length != 1)
      return;
    // code='Digit3'
    var interval = parseInt(keyEvent.keyCode) - 49;  // 48 === '0', 0 indexed
    if (isNaN(interval) || interval < 1 || interval > 7) {
      return;
    }
    this.intervalAdd(interval, keyEvent.shiftKey ? -1 : 1);
  }

  transpose(offset) {
      var grace = this.tracker.getSelectedGraceNotes();
      if (grace.length) {
          grace.forEach((artifact) => {
              SmoUndoable.transposeGraceNotes(artifact.selection,{modifiers:artifact.modifier,offset:offset},this.undoBuffer);
          });
          this._render();

          return;
      }
      // If there are lots of selections, just play the first note
      var playSelection = true;
      this.tracker.selections.forEach((selected) => {
          this._transpose(selected, offset, playSelection);
          playSelection = false;
      });
      this._render();
  }
  transposeDown() {
    this.transpose(-1);
  }
  transposeUp() {
    this.transpose(1);
  }
  upOctave() {
    this.transpose(12);
  }
  downOctave() {
    this.transpose(-12);
  }
  makeRest() {
      this.tracker.selections.forEach((selection) => {
          this._selectionOperation(selection,'makeRest');
      });
      this.tracker.replaceSelectedMeasures();
  }

  _setPitch(selected, letter) {
    var selector = selected.selector;
    var hintSel = SmoSelection.lastNoteSelection(this.layout.score,
      selector.staff, selector.measure, selector.voice, selector.tick);
    if (!hintSel) {
      hintSel = SmoSelection.nextNoteSelection(this.layout.score,
        selector.staff, selector.measure, selector.voice, selector.tick);
    }
    // The selection no longer exists, possibly deleted
    if (!hintSel) {
      return;
    }

    var hintNote = hintSel.note;
    var hpitch = hintNote.pitches[0];
    var pitch = JSON.parse(JSON.stringify(hpitch));
    pitch.letter = letter;

    // Make the key 'a' make 'Ab' in the key of Eb, for instance
    var vexKsKey = smoMusic.getKeySignatureKey(letter, selected.measure.keySignature);
    if (vexKsKey.length > 1) {
        pitch.accidental = vexKsKey[1];
    } else {
        pitch.accidental = 'n';
    }

    // make the octave of the new note as close to previous (or next) note as possible.
    var upv = ['bc', 'ac', 'bd', 'da', 'be', 'gc'];
    var downv = ['cb', 'ca', 'db', 'da', 'eb', 'cg'];
    var delta = hpitch.letter + pitch.letter;
    if (upv.indexOf(delta) >= 0) {
        pitch.octave += 1;
    }
    if (downv.indexOf(delta) >= 0) {
      pitch.octave -= 1;
    }
    SmoUndoable['setPitch'](selected, pitch, this.undoBuffer);
    suiOscillator.playSelectionNow(selected);
  }

    setPitchCommand(letter) {
        this.tracker.selections.forEach((selected) => this._setPitch(selected, letter));
        this._renderAndAdvance();
    }

    setPitch(keyEvent) {
        this.setPitchCommand(keyEvent.key.toLowerCase());
    }

    dotDuration(keyEvent) {
        this._batchDurationOperation('dotDuration');
    }

    undotDuration(keyEvent) {
        this._batchDurationOperation('undotDuration');
    }

    doubleDuration(keyEvent) {
        var grace = this.tracker.getSelectedGraceNotes();
        if (grace.length) {
            grace.forEach((artifact) => {
                SmoUndoable.doubleGraceNoteDuration(artifact.selection,artifact.modifier,this.undoBuffer);
            });
            this._render();

            return;
        }
        this._batchDurationOperation('doubleDuration');
    }

    halveDuration(keyEvent) {
        var grace = this.tracker.getSelectedGraceNotes();
        if (grace.length) {
            grace.forEach((artifact) => {
                SmoUndoable.halveGraceNoteDuration(artifact.selection,artifact.modifier,this.undoBuffer);
            });
            this._render();
            return;
        }
        this._batchDurationOperation('halveDuration');
    }

    addMeasure(keyEvent) {
        if (this.tracker.selections.length < 1) {
            return;
        }
        var measure = this.tracker.getFirstMeasureOfSelection();
        if (measure) {
            var nmeasure = SmoMeasure.getDefaultMeasureWithNotes(measure);
			var pos = measure.measureNumber.measureIndex;
			if (keyEvent.shiftKey) {
				pos += 1;
			}
            nmeasure.measureNumber.measureIndex = pos;
            nmeasure.setActiveVoice(0);
            SmoUndoable.addMeasure(this.layout.score, pos, nmeasure, this.undoBuffer);
            this.layout.clearLine(measure);
            this._refresh();
        }
    }
	deleteMeasure() {
    if (this.tracker.selections.length < 1) {
      return;
    }
    // don't delete the last measure
    if (this.layout.score.staves[0].measures.length < 2) {
      return;
    }
    var selection = this.tracker.selections[0];
    var ix = selection.selector.measure;
    this.layout.score.staves.forEach((staff) => {
      this.layout.unrenderMeasure(staff.measures[ix]);
      this.layout.unrenderMeasure(staff.measures[staff.measures.length-1]);

      // A little hacky - delete the modifiers if they start or end on
      // the measure
      staff.modifiers.forEach((modifier) => {
        if (modifier.startSelector.measure == ix || modifier.endSelector.measure == ix) {
  	        $(this.layout.renderer.getContext().svg).find('g.' + modifier.attrs.id).remove();
        }
        });
    });
    this.tracker.deleteMeasure(selection);
    // this.layout.unrenderAll();

    SmoUndoable.deleteMeasure(this.layout.score, selection, this.undoBuffer);
    this.tracker.loadScore();
    this._refresh();
  }

  toggleCourtesyAccidental() {
    var grace = this.tracker.getSelectedGraceNotes();
    if (grace.length) {
      grace.forEach((artifact) => {
        SmoUndoable.toggleGraceNoteCourtesyAccidental(artifact.selection,{modifiers:artifact.modifier},this.undoBuffer);
      });
      this._render();

      return;
    }
    if (this.tracker.selections.length < 1) {
      return;
    }
    this.tracker.selections.forEach((selection) => {
      SmoUndoable.toggleCourtesyAccidental(selection, this.undoBuffer);
    });
    this._render();
  }
  toggleEnharmonic() {
    this.tracker.selections.forEach((selected) => this._selectionOperation(selected, 'toggleEnharmonic'));
    this._render();
  }

  rerender(keyEvent) {
    this.layout.unrenderAll();
    SmoUndoable.noop(this.layout.score, this.undoBuffer);
    this.undo();
    this._render();
  }
  makeTupletCommand(numNotes) {
    this._singleSelectionOperation('makeTuplet', numNotes);
  }
  makeTuplet(keyEvent) {
    var numNotes = parseInt(keyEvent.key);
    this.makeTupletCommand(numNotes);
  }

  unmakeTuplet(keyEvent) {
    this._singleSelectionOperation('unmakeTuplet');
  }
  setNoteHead(keyEvent) {
     SmoUndoable.setNoteHead(this.layout.score, this.tracker.selections, 'x2', this.undoBuffer);
     this._render();
  }
  removeGraceNote(keyEvent) {
    this._singleSelectionOperation('removeGraceNote',{index:0});
  }
  addGraceNote(keyEvent) {
    this._singleSelectionOperation('addGraceNote');
  }
  slashGraceNotes(keyEvent) {
    if (!this.tracker.modifierSelections.length) {
      return;
    }
    this._selectionOperation(this.tracker.modifierSelections,'slashGraceNotes');
  }

  toggleArticulationCommand(articulation, ctor) {
    this.undoBuffer.addBuffer('change articulation ' + articulation,
      'staff', this.tracker.selections[0].selector, this.tracker.selections[0].staff);

    this.tracker.selections.forEach((sel) => {

      if (ctor === 'SmoArticulation') {
        var aa = new SmoArticulation({
            articulation: articulation
        });
       SmoOperation.toggleArticulation(sel, aa);
      } else {
        var aa = new SmoOrnament({
            ornament: articulation
        });
        SmoOperation.toggleOrnament(sel, aa);
      }
    });
    this._render();
  }

    addRemoveArticulation(keyEvent) {
        if (this.tracker.selections.length < 1)
            return;

        var atyp = SmoArticulation.articulations.accent;

        if (keyEvent.key.toLowerCase() === 'h') {
            atyp = SmoArticulation.articulations.accent;
        }
        if (keyEvent.key.toLowerCase() === 'i') {
            atyp = SmoArticulation.articulations.tenuto;
        }
        if (keyEvent.key.toLowerCase() === 'j') {
            atyp = SmoArticulation.articulations.staccato;
        }
        if (keyEvent.key.toLowerCase() === 'k') {
            atyp = SmoArticulation.articulations.marcato;
        }
        if (keyEvent.key.toLowerCase() === 'l') {
            atyp = SmoArticulation.articulations.pizzicato;
        }
        this.toggleArticulationCommand(atyp, 'SmoArticulation');

    }
}
;
class suiMenuBase {
  constructor(params) {
    Vex.Merge(this, params);
    this.focusIndex = -1;
    SmoTranslator.registerMenu(this.ctor);
  }
  get closeModalPromise() {
    return this.closePromise();
  }
  static printTranslate(_class) {
    var xx = eval(_class);
    var items = [];
    xx['defaults'].menuItems.forEach((item) => {
      items.push({value:item.value,text:item.text});
    });

    return {ctor:xx['ctor'],label:xx['label'],menuItems:items};
  }

  complete() {
    $('body').trigger('menuDismiss');
  }
  // Most menus don't process their own events
  keydown(ev) {}
}

class suiMenuManager {
  constructor(params) {
    Vex.Merge(this, suiMenuManager.defaults);
    Vex.Merge(this, params);
    this.eventSource = params.eventSource;
    this.bound = false;
    this.hotkeyBindings={};
  }

  static get defaults() {
    return {
      menuBind: suiMenuManager.menuKeyBindingDefaults,
      menuContainer: '.menuContainer'
    };
  }

  get closeModalPromise() {
    return this.closeMenuPromise;
  }

  setController(c) {
    this.controller=c;
  }

  get score() {
    return this.layout.score;
  }

  // ### Description:
  // slash ('/') menu key bindings.  The slash key followed by another key brings up
  // a menu.
  static get menuKeyBindingDefaults() {
    return [
      {
        event: "keydown",
        key: "n",
        ctrlKey: false,
        altKey: false,
        shiftKey: false,
        action: "SuiLanguageMenu"
      }, {
        event: "keydown",
        key: "k",
        ctrlKey: false,
        altKey: false,
        shiftKey: false,
        action: "SuiKeySignatureMenu"
      }, {
        event: "keydown",
        key: "l",
        ctrlKey: false,
        altKey: false,
        shiftKey: false,
        action: "SuiStaffModifierMenu"
      }, {
        event: "keydown",
        key: "d",
        ctrlKey: false,
        altKey: false,
        shiftKey: false,
        action: "SuiDynamicsMenu"
      }, {
        event: "keydown",
        key: "s",
        ctrlKey: false,
        altKey: false,
        shiftKey: false,
        action: "SuiAddStaffMenu"
        }, {
        event: "keydown",
        key: "f",
        ctrlKey: false,
        altKey: false,
        shiftKey: false,
        action: "SuiFileMenu"
      }, {
        event: "keydown",
        key: "m",
        ctrlKey: false,
        altKey: false,
        shiftKey: false,
        action: "SuiTimeSignatureMenu"
      }, {
        event: "keydown",
        key: "a",
        ctrlKey: false,
        altKey: false,
        shiftKey: false,
        action: "SuiMeasureMenu"
      }
    ];
  }
  _advanceSelection(inc) {
    var options = $('.menuContainer ul.menuElement li.menuOption');
    inc = inc < 0 ? options.length - 1: 1;
    this.menu.focusIndex = (this.menu.focusIndex+inc) % options.length;
    $(options[this.menu.focusIndex]).find('button').focus();
  }

  get menuBindings() {
    return this.menuBind;
  }

  unattach() {
    this.eventSource.unbindKeydownHandler(this.keydownHandler);
    $('body').removeClass('modal');
    $(this.menuContainer).html('');
    $('body').off('dismissMenu');
    this.bound = false;
    this.menu = null;
  }

  attach(el) {
    var b = htmlHelpers.buildDom();

    $(this.menuContainer).html('');
    $(this.menuContainer).attr('z-index', '12');
    var b = htmlHelpers.buildDom;
    var r = b('ul').classes('menuElement').attr('size', this.menu.menuItems.length)
    .css('left', '' + this.menuPosition.x + 'px')
    .css('top', '' + this.menuPosition.y + 'px');
      var hotkey=0;
    this.menu.menuItems.forEach((item) => {
      var vkey = (hotkey < 10) ? String.fromCharCode(48+hotkey) :
        String.fromCharCode(87 + hotkey);

      r.append(
        b('li').classes('menuOption').append(
          b('button').attr('data-value',item.value).append(
            b('span').classes('menuText').text(item.text))
          .append(b('span').classes('icon icon-' + item.icon))
        .append(b('span').classes('menu-key').text(''+vkey))));
      item.hotkey=vkey;
      hotkey += 1;
    });
    $(this.menuContainer).append(r.dom());
    $('body').addClass('modal');
    this.bindEvents();
  }

  slashMenuMode(completeNotifier) {
    var self = this;
    this.bindEvents();
    layoutDebug.addDialogDebug('slash menu creating closeMenuPromise');
    // A menu asserts this event when it is done.
    this.closeMenuPromise = new Promise((resolve, reject) => {
      $('body').off('menuDismiss').on('menuDismiss', function () {
        layoutDebug.addDialogDebug('menuDismiss received, resolve closeMenuPromise');
        self.unattach();
        $('body').removeClass('slash-menu');
        resolve();
      });
    });
    // take over the keyboard
    completeNotifier.unbindKeyboardForModal(this);
  }

  dismiss() {
    $('body').trigger('menuDismiss');
  }

  createMenu(action,completeNotifier) {
    this.menuPosition = {x:250,y:40,width:1,height:1};
      // If we were called from the ribbon, we notify the controller that we are
      // taking over the keyboard.  If this was a key-based command we already did.

    layoutDebug.addDialogDebug('createMenu creating ' + action);
    var ctor = eval(action);
    this.menu = new ctor({
      position: this.menuPosition,
      tracker: this.tracker,
      editor: this.editor,
      score: this.score,
      completeNotifier:this.controller,
      closePromise:this.closeMenuPromise,
      layout: this.layout,
      eventSource:this.eventSource,
      undoBuffer: this.undoBuffer
    });
    this.attach(this.menuContainer);
    this.menu.menuItems.forEach((item) => {
      if (typeof(item.hotkey) != 'undefined') {
        this.hotkeyBindings[item.hotkey] = item.value;
      }
    });
  }

  // ### evKey
  // We have taken over menu commands from controller.  If there is a menu active, send the key
  // to it.  If there is not, see if the keystroke creates one.  If neither, dismissi the menu.
  evKey(event) {
    console.log("KeyboardEvent: key='" + event.key + "' | code='" +
    event.code + "'"
     + " shift='" + event.shiftKey + "' control='" + event.ctrlKey + "'" + " alt='" + event.altKey + "'");

    if (['Tab', 'Enter'].indexOf(event.code) >= 0) {
      return;
    }

    event.preventDefault();

    if (event.code === 'Escape') {
      this.dismiss();
    }
    if (this.menu) {
      if (event.code == 'ArrowUp') {
        this._advanceSelection(-1);
      }
      else if (event.code == 'ArrowDown') {
        this._advanceSelection(1);
      } else  if (this.hotkeyBindings[event.key]) {
        $('button[data-value="'+this.hotkeyBindings[event.key]+'"]').click();
      } else {
        this.menu.keydown(event);
      }
      return;
    }
    var binding = this.menuBind.find((ev) => {
      return ev.key === event.key
    });
    if (!binding) {
      this.dismiss();
      return;
    }
    this.createMenu(binding.action);
  }

  bindEvents() {
  var self = this;
    this.hotkeyBindings={};
    $('body').addClass('slash-menu');

    // We need to keep track of is bound, b/c the menu can be created from
    // different sources.
    if (!this.bound) {
      this.keydownHandler = this.eventSource.bindKeydownHandler(this,'evKey');
      this.bound = true;
    }

  $(this.menuContainer).find('button').off('click').on('click', function (ev) {
  if ($(ev.currentTarget).attr('data-value') == 'cancel') {
  self.menu.complete();
  return;
  }
  self.menu.selection(ev);
  });
  }
}



class SuiFileMenu extends suiMenuBase {
    constructor(params) {
  params = (params ? params : {});
  Vex.Merge(params, SuiFileMenu.defaults);
    super(params);
  }
  static get ctor() {
    return 'SuiFileMenu';
  }
  get ctor() {
    return SuiFileMenu.ctor;
  }
  static get defaults() {

    SuiFileMenu._defaults = SuiFileMenu._defaults ? SuiFileMenu._defaults : {
      label:'File',
      menuItems: [
        {
          icon: 'folder-new',
          text: 'New Score',
          value: 'newFile'
        },{
          icon: 'folder-open',
          text: 'Open',
          value: 'openFile'
        },{
          icon: 'folder-save',
          text: 'Save',
          value: 'saveFile'
        },{
          icon: 'folder-save',
          text: 'Quick Save',
          value: 'quickSave'
        },{
          icon: '',
          text: 'Print',
          value: 'printScore'
        },{
          icon: '',
          text: 'Bach Invention',
          value: 'bach'
        },{
          icon: '',
          text: 'Jesu Bambino',
          value: 'bambino'
        },{
          icon: '',
          text: 'Microtone Sample',
          value: 'microtone'
        },{
          icon: '',
          text: 'Precious Lord',
          value: 'preciousLord'
        },{
          icon: '',
          text: 'Yama',
          value: 'yamaJson'
        },	{
          icon: '',
          text: 'Cancel',
          value: 'cancel'
        }
      ]
    };
    return SuiFileMenu._defaults;
  }

  systemPrint() {
   var self = this;
   window.print();
   SuiPrintFileDialog.createAndDisplay({
       layout: self.layout,
       completeNotifier:self.completeNotifier,
       closeMenuPromise:self.closePromise,
       tracker:self.tracker,
       undoBuffer:self.undoBuffer,
       });
  }
  selection(ev) {
    var text = $(ev.currentTarget).attr('data-value');
    var self=this;
    if (text == 'saveFile') {
      SuiSaveFileDialog.createAndDisplay({
        completeNotifier:this.completeNotifier,
        tracker:this.tracker,
        undoBuffer:this.editor.undoBuffer,
        eventSource:this.eventSource,
        editor:this.editor,
        layout:this.layout,
        closeMenuPromise:this.closePromise
    });
    } else if (text == 'openFile') {
      SuiLoadFileDialog.createAndDisplay({
        completeNotifier:this.completeNotifier,
        tracker:this.tracker,
        undoBuffer:this.undoBuffer,
        eventSource:this.eventSource,
        editor:this.editor,
        layout:this.layout,
        closeMenuPromise:this.closePromise
     });
     } else if (text == 'newFile') {
        this.undoBuffer.addBuffer('New Score', 'score', null, this.layout.score);
        var score = SmoScore.getDefaultScore();
        this.layout.score = score;
        setTimeout(function() {
        $('body').trigger('forceResizeEvent');
        },1);

      } else if (text == 'quickSave') {
        var scoreStr = JSON.stringify(this.layout.score.serialize());
        localStorage.setItem(smoSerialize.localScore,scoreStr);
      } else if (text == 'printScore') {
        var systemPrint = () => {
        self.systemPrint();
      }
        this.layout.renderForPrintPromise().then(systemPrint);
      } else if (text == 'bach') {
  			this.undoBuffer.addBuffer('New Score', 'score', null, this.layout.score);
  			var score = SmoScore.deserialize(inventionJson);
  			this.layout.score = score;
  			this.layout.setViewport(true);
    } else if (text == 'yamaJson') {
      this.undoBuffer.addBuffer('New Score', 'score', null, this.layout.score);
      var score = SmoScore.deserialize(yamaJson);
      this.layout.score = score;
      this.layout.setViewport(true);
    }
      else if (text == 'bambino') {
        this.undoBuffer.addBuffer('New Score', 'score', null, this.layout.score);
        var score = SmoScore.deserialize(jesuBambino);
        this.layout.score = score;
        this.layout.setViewport(true);
      } else if (text == 'microtone') {
        this.undoBuffer.addBuffer('New Score', 'score', null, this.layout.score);
        var score = SmoScore.deserialize(microJson);
        this.layout.score = score;
        this.layout.setViewport(true);
      }     else if (text == 'preciousLord') {
        this.undoBuffer.addBuffer('New Score', 'score', null, this.layout.score);
        var score = SmoScore.deserialize(preciousLord);
        this.layout.score = score;
        this.layout.setViewport(true);
    }
  this.complete();
  }

  keydown(ev) {}
}

class SuiDynamicsMenu extends suiMenuBase {
  constructor(params) {
  params = (params ? params : {});
  Vex.Merge(params, SuiDynamicsMenu.defaults);
  super(params);
  }
  static get ctor() {
    return 'SuiDynamicsMenu';
  }
  get ctor() {
    return SuiDynamicsMenu.ctor;
  }
  static get defaults() {
    SuiDynamicsMenu._defaults = SuiDynamicsMenu._defaults ? SuiDynamicsMenu._defaults :
    {
      label:'Dynamics',
      menuItems: [{
        icon: 'pianissimo',
        text: 'Pianissimo',
        value: 'pp'
      }, {
        icon: 'piano',
        text: 'Piano',
        value: 'p'
      }, {
        icon: 'mezzopiano',
        text: 'Mezzo-piano',
        value: 'mp'
      }, {
        icon: 'mezzoforte',
        text: 'Mezzo-forte',
        value: 'mf'
      }, {
        icon: 'forte',
        text: 'Forte',
        value: 'f'
      }, {
        icon: 'fortissimo',
        text: 'Fortissimo',
        value: 'ff'
      }, {
        icon: 'sfz',
        text: 'sfortzando',
        value: 'sfz'
      },
       {
        icon: '',
        text: 'Cancel',
        value: 'cancel'
      }
    ]
    };

    return SuiDynamicsMenu._defaults;

  }

  selection(ev) {
  var text = $(ev.currentTarget).attr('data-value');

  var ft = this.tracker.getExtremeSelection(-1);
  if (!ft || !ft.note) {
  return;
  }

  SmoUndoable.addDynamic(ft, new SmoDynamicText({
  selector: ft.selector,
  text: text,
  yOffsetLine: 11,
  fontSize: 38
  }), this.editor.undoBuffer);
    this.tracker.replaceSelectedMeasures();
  this.complete();
  }
  keydown(ev) {}
}

class SuiTimeSignatureMenu extends suiMenuBase {
    constructor(params) {
  params = (params ? params : {});
  Vex.Merge(params, SuiTimeSignatureMenu.defaults);
  super(params);
  }
  static get ctor() {
    return 'SuiTimeSignatureMenu';
  }

  get ctor() {
    return SuiTimeSignatureMenu.ctor;
  }
  static get defaults() {
    SuiTimeSignatureMenu._defaults = SuiTimeSignatureMenu._defaults ? SuiTimeSignatureMenu._defaults :
    {
      label:'Time Sig',
      menuItems: [
        {
          icon: 'sixeight',
          text: '6/8',
          value: '6/8',
        },{
          icon: 'threefour',
          text: '3/4',
          value: '3/4',
        },{
          icon: 'twofour',
          text: '2/4',
          value: '2/4',
        },{
          icon: 'twelveeight',
          text: '12/8',
          value: '12/8',
        },{
          icon: 'seveneight',
          text: '7/8',
          value: '7/8',
        },{
          icon: 'fiveeight',
          text: '5/8',
          value: '5/8',
        },{
          icon: '',
          text: 'Other',
          value: 'TimeSigOther',
        },{
          icon: '',
          text: 'Cancel',
          value: 'cancel'
        }
      ]
    };
    return SuiTimeSignatureMenu._defaults;
  }

  selection(ev) {
    var text = $(ev.currentTarget).attr('data-value');

    if (text == 'TimeSigOther') {
      SuiTimeSignatureDialog.createAndDisplay({
  			layout: this.layout,
        tracker: this.tracker,
        completeNotifier:this.completeNotifier,
        closeMenuPromise:this.closePromise,
        undoBuffer:this.undoBuffer,
        eventSource:this.eventSource
	    });
      this.complete();
      return;
    }
    var timeSig = $(ev.currentTarget).attr('data-value');
    this.layout.unrenderAll();
    SmoUndoable.scoreSelectionOp(this.layout.score,this.tracker.selections,
      'setTimeSignature',timeSig,this.undoBuffer,'change time signature');
    this.layout.setRefresh();
    this.complete();
  }

  keydown(ev) {}
  }

class SuiKeySignatureMenu extends suiMenuBase {

  constructor(params) {
  params = (params ? params : {});
  Vex.Merge(params, SuiKeySignatureMenu.defaults);
    super(params);
  }
  static get ctor() {
    return 'SuiKeySignatureMenu';
  }
  get ctor() {
    return SuiKeySignatureMenu.ctor;
  }
  static get defaults() {
    SuiKeySignatureMenu._defaults = SuiKeySignatureMenu._defaults ? SuiKeySignatureMenu._defaults :
   {
     label:'Key',

  menuItems: [{
    icon: 'key-sig-c',
    text: 'C Major',
    value: 'KeyOfC',
    }, {
    icon: 'key-sig-f',
    text: 'F Major',
    value: 'KeyOfF',
    }, {
    icon: 'key-sig-g',
    text: 'G Major',
    value: 'KeyOfG',
    }, {
    icon: 'key-sig-bb',
    text: 'Bb Major',
    value: 'KeyOfBb'
    }, {
    icon: 'key-sig-d',
    text: 'D Major',
    value: 'KeyOfD'
    }, {
    icon: 'key-sig-eb',
    text: 'Eb Major',
    value: 'KeyOfEb'
    }, {
    icon: 'key-sig-a',
    text: 'A Major',
    value: 'KeyOfA'
    }, {
    icon: 'key-sig-ab',
    text: 'Ab Major',
    value: 'KeyOfAb'
    }, {
    icon: 'key-sig-e',
    text: 'E Major',
    value: 'KeyOfE'
    }, {
    icon: 'key-sig-bd',
    text: 'Db Major',
    value: 'KeyOfDb'
    }, {
    icon: 'key-sig-b',
    text: 'B Major',
    value: 'KeyOfB'
    }, {
    icon: 'key-sig-fs',
    text: 'F# Major',
    value: 'KeyOfF#'
    }, {
    icon: 'key-sig-cs',
    text: 'C# Major',
    value: 'KeyOfC#'
    },
     {
    icon: '',
    text: 'Cancel',
    value: 'cancel'
    }
    ],
    menuContainer: '.menuContainer'
    };
    return SuiKeySignatureMenu._defaults;
  }

  selection(ev) {
    var keySig = $(ev.currentTarget).attr('data-value');
    keySig = (keySig === 'cancel' ? keySig : keySig.substring(5,keySig.length));
    var changed = [];
    this.tracker.selections.forEach((sel) => {
      if (changed.indexOf(sel.selector.measure) === -1) {
        changed.push(sel.selector.measure);
        SmoUndoable.addKeySignature(this.score, sel, keySig, this.editor.undoBuffer);
        }
    });

    this.layout.setRefresh();
    this.complete();
  }
  keydown(ev) {}
}

class SuiStaffModifierMenu extends suiMenuBase {

  constructor(params) {
    params = (params ? params : {});
    Vex.Merge(params, SuiStaffModifierMenu.defaults);
    super(params);
  }
  static get ctor() {
    return 'SuiStaffModifierMenu';
  }
  get ctor() {
    return SuiStaffModifierMenu.ctor;
  }

  static get defaults() {
    SuiStaffModifierMenu._defaults = SuiStaffModifierMenu._defaults ? SuiStaffModifierMenu._defaults :
    {
      label:'Lines',
      menuItems: [{
        icon: 'cresc',
        text: 'Crescendo',
        value: 'crescendo'
        }, {
        icon: 'decresc',
        text: 'Decrescendo',
        value: 'decrescendo'
        }, {
        icon: 'slur',
        text: 'Slur/Tie',
        value: 'slur'
        }, {
        icon: 'ending',
        text: 'nth ending',
        value: 'ending'
        },
         {
        icon: '',
        text: 'Cancel',
        value: 'cancel'
        }
      ],
      menuContainer: '.menuContainer'
    };
    return SuiStaffModifierMenu._defaults;
  }
  selection(ev) {
    var op = $(ev.currentTarget).attr('data-value');

    var ft = this.tracker.getExtremeSelection(-1);
    var tt = this.tracker.getExtremeSelection(1);

    if (op === 'ending') {
      SmoUndoable.scoreOp(this.score,'addEnding',
        new SmoVolta({startBar:ft.selector.measure,endBar:tt.selector.measure,number:1}),this.editor.undoBuffer,'add ending');
      this.complete();
    return;
    }
    if (SmoSelector.sameNote(ft.selector, tt.selector)) {
      this.complete();
      return;
    }

    SmoUndoable[op](ft, tt, this.editor.undoBuffer);
    this.tracker.replaceSelectedMeasures();
    this.complete();
  }

  keydown(ev) {

  }
}

class SuiLanguageMenu extends suiMenuBase {

  constructor(params) {
    params = (params ? params : {});
    Vex.Merge(params, SuiLanguageMenu.defaults);
    super(params);
  }
  static get ctor() {
    return 'SuiLanguageMenu';
  }
  get ctor() {
    return SuiLanguageMenu.ctor;
  }

  static get defaults() {
    SuiLanguageMenu._defaults = SuiLanguageMenu._defaults ? SuiLanguageMenu._defaults :
    {
      label:'Language',
      menuItems: [{
        icon: '',
        text: 'English',
        value: 'en'
        }, {
          icon: '',
          text: 'Deutsch',
          value: 'de'
        }, {
        icon: '',
        text: 'اَلْعَرَبِيَّةُ',
        value: 'ar'
      }, {
        icon: '',
        text: 'Cancel',
        value: 'cancel'
        }
      ],
      menuContainer: '.menuContainer'
    };
    return SuiLanguageMenu._defaults;
  }
  selection(ev) {
    var op = $(ev.currentTarget).attr('data-value');

    SmoTranslator.setLanguage(op);
    this.complete();
  }

  keydown(ev) {

  }
}
class SuiMeasureMenu extends suiMenuBase {
  static get defaults() {
    SuiMeasureMenu._defaults = SuiMeasureMenu._defaults ? SuiMeasureMenu._defaults : {
      label:'Measure',
      menuItems: [

        {
          icon: '',
          text: 'Add Measure Before',
          value: 'addMenuBeforeCmd'
        },
        {
          icon: '',
          text: 'Add Measure After',
          value: 'addMenuAfterCmd'
        }, {
          icon: 'icon-cross',
          text: 'Delete Selected Measures',
          value: 'deleteSelected'
        }, {
          icon: '',
          text: 'Format Measure',
          value: 'formatMeasureDialog'
        }, {
          icon: '',
          text: 'Cancel',
          value: 'cancel'
        }
      ]
    }
    return SuiMeasureMenu._defaults;
  }
  static get ctor() {
    return 'SuiMeasureMenu';
  }
  get ctor() {
    return SuiMeasureMenu.ctor;
  }

  constructor(params) {
    params = (params ? params : {});
    Vex.Merge(params, SuiMeasureMenu.defaults);
    super(params);
  }
  selection(ev) {
    var text = $(ev.currentTarget).attr('data-value');

    if (text == 'formatMeasureDialog') {
      SuiMeasureDialog.createAndDisplay({
        layout: this.layout,
        tracker: this.tracker,
        completeNotifier:this.completeNotifier,
        closeMenuPromise:this.closePromise,
        undoBuffer:this.undoBuffer,
        eventSource:this.eventSource
      });
      this.complete();
      return;
    }
    if (text === 'addMenuBeforeCmd') {
      this.editor.addMeasure({shiftKey:false});
      this.complete();
    }
    if (text === 'addMenuAfterCmd') {
      this.editor.addMeasure({shiftKey:true});
      this.complete();
    }
    if (text === 'deleteSelected') {
      this.editor.deleteMeasure();
    }
    this.complete();
  }


}

class SuiAddStaffMenu extends suiMenuBase {
  constructor(params) {
    params = (params ? params : {});
    Vex.Merge(params, SuiAddStaffMenu.defaults);
    super(params);
  }
  static get ctor() {
    return 'SuiAddStaffMenu';
  }
  get ctor() {
    return SuiAddStaffMenu.ctor;
  }

  static get defaults() {
    SuiAddStaffMenu._defaults = SuiAddStaffMenu._defaults ? SuiAddStaffMenu._defaults : {
      label: "Add Staff",
      menuItems: [
        {
          icon: 'treble',
          text: 'Treble Clef Staff',
          value: 'trebleInstrument'
        }, {
          icon: 'bass',
          text: 'Bass Clef Staff',
          value: 'bassInstrument'
        }, {
          icon: 'alto',
          text: 'Alto Clef Staff',
          value: 'altoInstrument'
        }, {
          icon: 'tenor',
          text: 'Tenor Clef Staff',
          value: 'tenorInstrument'
        }, {
          icon: 'cancel-circle',
          text: 'Remove Staff',
          value: 'remove'
        }, {
          icon: '',
          text: 'Cancel',
          value: 'cancel'
        }
      ],
      menuContainer: '.menuContainer'
    };
    return SuiAddStaffMenu._defaults;
  }
  static get instrumentMap() {
    return {
      'trebleInstrument': {
        instrumentInfo: {
        instrumentName: 'Treble Clef Staff',
        keyOffset: 0,
        clef: 'treble'
      }
      },
      'bassInstrument': {
        instrumentInfo: {
        instrumentName: 'Bass Clef Staff',
        keyOffset: 0,
        clef: 'bass'
      }
      },
      'altoInstrument': {
        instrumentInfo: {
        instrumentName: 'Alto Clef Staff',
        keyOffset: 0,
        clef: 'alto'
      }
      },
      'tenorInstrument': {
        instrumentInfo: {
        instrumentName: 'Tenor Clef Staff',
        keyOffset: 0,
        clef: 'tenor'
      }
      },
      'remove': {
        instrumentInfo: {
        instrumentName: 'Remove clef',
        keyOffset: 0,
        clef: 'tenor'
      }
    }
  }

  }
  selection(ev) {
    var op = $(ev.currentTarget).attr('data-value');
    if (op == 'remove') {
      if (this.score.staves.length > 1 && this.tracker.selections.length > 0) {
        this.tracker.layout.unrenderAll();
        SmoUndoable.removeStaff(this.score, this.tracker.selections[0].selector.staff, this.editor.undoBuffer);
        this.tracker.layout.setRefresh();
      }
    } else if (op === 'cancel') {
      this.complete();
    } else {
      var instrument = SuiAddStaffMenu.instrumentMap[op];
      SmoUndoable.addStaff(this.score, instrument, this.editor.undoBuffer);
      this.tracker.layout.setRefresh();
    }
    this.layout.setRefresh();
    this.complete();
  }
  keydown(ev) {}

}
;
// ## utController
// a simple controller object to render the unit test cases.
class utController {

	constructor(params) {

		Vex.Merge(this, utController.defaults);
		Vex.Merge(this, params);
		this.bindEvents();
    this.score = params.layout.score;
		this.undoBuffer = new UndoBuffer();
    this.layoutDemon.undoBuffer = this.undoBuffer;
    this.exhandler = new SuiExceptionHandler(this);
    SmoMeasure.emptyMeasureNoteType='n';

    this.layoutDemon.startDemon();
	}

	get renderElement() {
		return this.layout.renderElement;
	}

	static get defaults() {
		return {};
	}

	detach() {
		this.layout = null;
	}

	render() {
        var ix = 0;
        this.layout.layout();
	}

	bindEvents() {}

}
;
class SuiExceptionHandler {
    constructor(params) {
        this.tracker = params.tracker;
        this.layout = params.layout;
        this.score = params.score;
        this.undoBuffer = params.undoBuffer;
        this.thrown = false;
		SuiExceptionHandler._instance = this;
    }
	static get instance() {
		return SuiExceptionHandler._instance;
	}
    exceptionHandler(e) {
        var self = this;
        if (this.thrown) {
          return;
        }
        this.thrown = true;
        if (window['suiController'] && window['suiController'].reentry) {
            return;
        }

        if (window['suiController']) {
            suiController.reentry = true;
        }
        var scoreString = 'Could not serialize score.';
        try {
            scoreString = this.layout.score.serialize();
        } catch (e) {
            scoreString += ' ' + e.message;
        }
        var message = e.message;
        var stack = 'No stack trace available';

        try {
            if (e.error && e.error.stack) {
                stack = e.error.stack;
            } else if (e['stack']) {
				stack = e.stack;
			}
        } catch (e2) {
            stack = 'Error with stack: ' + e2.message;
        }
        var doing = 'Last operation not available.';

        var lastOp = this.undoBuffer.peek();
        if (lastOp) {
            doing = lastOp.title;
        }
        var url = 'https://github.com/AaronDavidNewman/Smoosic/issues';
        var bodyObject = JSON.stringify({
                message: message,
                stack: stack,
                lastOperation: doing,
                scoreString: scoreString
            }, null, ' ');

        var b = htmlHelpers.buildDom;
        var r = b('div').classes('bug-modal').append(
                b('img').attr('src', '../styles/images/logo.png').classes('bug-logo'))
            .append(b('button').classes('icon icon-cross bug-dismiss-button'))
            .append(b('span').classes('bug-title').text('oh nooooo!  You\'ve found a bug'))
            .append(b('p').text('It would be helpful if you would submit a bug report, and copy the data below into an issue'))
            .append(b('div')
                .append(b('textarea').attr('id', 'bug-text-area').text(bodyObject))
                .append(
                    b('div').classes('button-container').append(b('button').classes('bug-submit-button').text('Submit Report'))));

        $('.bugDialog').html('');
        $('.bugDialog').append(r.dom());

        $('.bug-dismiss-button').off('click').on('click', function () {
            $('body').removeClass('bugReport');
            if (lastOp) {
                self.undoBuffer.undo(self.score);
                self.layout.render();
                suiController.reentry = false;
            }
        });
        $('.bug-submit-button').off('click').on('click', function () {
            var data = {
                title: "automated bug report",
                body: encodeURIComponent(bodyObject)
            };
            $('#bug-text-area').select();
            document.execCommand('copy');
            window.open(url, 'Report Smoosic issues');
        });
        $('body').addClass('bugReport');
        if (!this.thrown) {
            this.thrown = true;
            throw(e);
        }

    }
}
;class defaultEditorKeys {

	static get keys() {
		return [{
				event: "keydown",
				key: "=",
				ctrlKey: false,
				altKey: false,
				shiftKey: false,
				action: "transposeUp"
			}, {
				event: "keydown",
				key: "-",
				ctrlKey: false,
				altKey: false,
				shiftKey: false,
				action: "transposeDown"
			}, {
				event: "keydown",
				key: "+",
				ctrlKey: false,
				altKey: false,
				shiftKey: true,
				action: "upOctave"
			}, {
				event: "keydown",
				key: "_",
				ctrlKey:false,
				altKey: false,
				shiftKey: true,
				action: "downOctave"
			}, {
				event: "keydown",
				key: "F",
				ctrlKey: false,
				altKey: false,
				shiftKey: true,
				action: "toggleCourtesyAccidental"
			}, {
				event: "keydown",
				key: ".",
				ctrlKey: false,
				altKey: false,
				shiftKey: false,
				action: "doubleDuration"
			}, {
				event: "keydown",
				key: ",",
				ctrlKey: false,
				altKey: false,
				shiftKey: false,
				action: "halveDuration"
			}, {
				event: "keydown",
				key: ">",
				ctrlKey: false,
				altKey: false,
				shiftKey: true,
				action: "dotDuration"
			}, {
				event: "keydown",
				key: "<",
				ctrlKey: false,
				altKey: false,
				shiftKey: true,
				action: "undotDuration"
			}, {
				event: "keydown",
				key: "a",
				ctrlKey: false,
				altKey: false,
				shiftKey: false,
				action: "setPitch"
			}, {
				event: "keydown",
				key: "A",
				ctrlKey: false,
				altKey: false,
				shiftKey: true,
				action: "slashGraceNotes"
			}, {
				event: "keydown",
				key: "b",
				ctrlKey: false,
				altKey: false,
				shiftKey: false,
				action: "setPitch"
			}, {
				event: "keydown",
				key: "G",
				ctrlKey: false,
				altKey: false,
				shiftKey: true,
				action: "addGraceNote"
			}, {
				event: "keydown",
				key: "g",
				ctrlKey: false,
				altKey: true,
				shiftKey: false,
				action: "removeGraceNote"
			}, {
				event: "keydown",
				key: "c",
				ctrlKey: false,
				altKey: false,
				shiftKey: false,
				action: "setPitch"
			}, {
				event: "keydown",
				key: "d",
				ctrlKey: false,
				altKey: false,
				shiftKey: false,
				action: "setPitch"
			}, {
				event: "keydown",
				key: "e",
				ctrlKey: false,
				altKey: false,
				shiftKey: false,
				action: "setPitch"
			}, {
				event: "keydown",
				key: "f",
				ctrlKey: false,
				altKey: false,
				shiftKey: false,
				action: "setPitch"
			}, {
				event: "keydown",
				key: "g",
				ctrlKey: false,
				altKey: false,
				shiftKey: false,
				action: "setPitch"
			}, {
				event: "keydown",
				key: "r",
				ctrlKey: false,
				altKey: false,
				shiftKey: false,
				action: "makeRest"
			}, {
				event: "keydown",
				key: "r",
				ctrlKey: false,
				altKey: true,
				shiftKey: false,
				action: "rerender"
			}, {
				event: "keydown",
				key: "p",
				ctrlKey: false,
				altKey: false,
				shiftKey: false,
				action: "playScore"
			}, {
				event: "keydown",
				key: "P",
				ctrlKey: false,
				altKey: false,
				shiftKey: true,
				action: "pausePlayer"
			},
            {
				event: "keydown",
				key: "s",
				ctrlKey: false,
				altKey: false,
				shiftKey: false,
				action: "stopPlayer"
			},             {
				event: "keydown",
				key: "t",
				ctrlKey: false,
				altKey: false,
				shiftKey: false,
				action: "tempoDialog"
			},
			{
				event: "keydown",
				key: "3",
				ctrlKey: true,
				altKey: false,
				shiftKey: false,
				action: "makeTuplet"
			}, {
				event: "keydown",
				key: "5",
				ctrlKey: true,
				altKey: false,
				shiftKey: false,
				action: "makeTuplet"
			}, {
				event: "keydown",
				key: "7",
				ctrlKey: true,
				altKey: false,
				shiftKey: false,
				action: "makeTuplet"
			},
			// interval commands
			{
				event: "keydown",
				key: "2",
				ctrlKey: false,
				altKey: false,
				shiftKey: false,
				action: "interval"
			}, {
				event: "keydown",
				key: "3",
				ctrlKey: false,
				altKey: false,
				shiftKey: false,
				action: "interval"
			}, {
				event: "keydown",
				key: "4",
				ctrlKey: false,
				altKey: false,
				shiftKey: false,
				action: "interval"
			}, {
				event: "keydown",
				key: "5",
				ctrlKey: false,
				altKey: false,
				shiftKey: false,
				action: "interval"
			}, {
				event: "keydown",
				key: "6",
				ctrlKey: false,
				altKey: false,
				shiftKey: false,
				action: "interval"
			}, {
				event: "keydown",
				key: "7",
				ctrlKey: false,
				altKey: false,
				shiftKey: false,
				action: "interval"
			}, {
				event: "keydown",
				key: "8",
				ctrlKey: false,
				altKey: false,
				shiftKey: false,
				action: "interval"
			}, {
				event: "keydown",
				key: "@",
				ctrlKey: false,
				altKey: false,
				shiftKey: true,
				action: "interval"
			}, {
				event: "keydown",
				key: "$",
				ctrlKey: false,
				altKey: false,
				shiftKey: true,
				action: "interval"
			}, {
				event: "keydown",
				key: "#",
				ctrlKey: false,
				altKey: false,
				shiftKey: true,
				action: "interval"
			}, {
				event: "keydown",
				key: "%",
				ctrlKey: false,
				altKey: false,
				shiftKey: true,
				action: "interval"
			}, {
				event: "keydown",
				key: "^",
				ctrlKey: false,
				altKey: false,
				shiftKey: true,
				action: "interval"
			}, {
				event: "keydown",
				key: "&",
				ctrlKey: false,
				altKey: false,
				shiftKey: true,
				action: "interval"
			}, {
				event: "keydown",
				key: "*",
				ctrlKey: false,
				altKey: false,
				shiftKey: true,
				action: "interval"
			}, {
				event: "keydown",
				key: "8",
				ctrlKey: false,
				altKey: false,
				shiftKey: true,
				action: "interval"
			}, {
				event: "keydown",
				key: "0",
				ctrlKey: true,
				altKey: false,
				shiftKey: false,
				action: "unmakeTuplet"
			}, {
				event: "keydown",
				key: "Insert",
				ctrlKey: false,
				altKey: false,
				shiftKey: false,
				action: "addMeasure"
			},{
				event: "keydown",
				key: "Insert",
				ctrlKey: false,
				altKey: false,
				shiftKey: true,
				action: "addMeasure"
			}, {
				event: "keydown",
				key: "i",
				ctrlKey: true,
				altKey: false,
				shiftKey: false,
				action: "addMeasure"
			}, {
				event: "keydown",
				key: "I",
				ctrlKey: true,
				altKey: false,
				shiftKey: true,
				action: "addMeasure"
			}, {
				event: "keydown",
				key: "B",
				ctrlKey: false,
				altKey: false,
				shiftKey: true,
				action: "toggleBeamDirection"
			}, {
				event: "keydown",
				key: "Delete",
				ctrlKey: false,
				altKey: false,
				shiftKey: false,
				action: "deleteMeasure"
			}, {
				event: "keydown",
				key: "d",
				ctrlKey: true,
				altKey: false,
				shiftKey: false,
				action: "deleteMeasure"
			}, {
				event: "keydown",
				key: "z",
				ctrlKey: true,
				altKey: false,
				shiftKey: false,
				action: "undo"
			}, {
				event: "keydown",
				key: "c",
				ctrlKey: true,
				altKey: false,
				shiftKey: false,
				action: "copy"
			}, {
				event: "keydown",
				key: "x",
				ctrlKey: false,
				altKey: false,
				shiftKey: false,
				action: "toggleBeamGroup"
			}, {
				event: "keydown",
				key: "X",
				ctrlKey: false,
				altKey: false,
				shiftKey: true,
				action: "beamSelections"
			},{
				event: "keydown",
				key: "v",
				ctrlKey: true,
				altKey: false,
				shiftKey: false,
				action: "paste"
			}, {
				event: "keydown",
				key: "h",
				ctrlKey: false,
				altKey: false,
				shiftKey: false,
				action: "addRemoveArticulation"
			}, {
				event: "keydown",
				key: "i",
				ctrlKey: false,
				altKey: false,
				shiftKey: false,
				action: "addRemoveArticulation"
			}, {
				event: "keydown",
				key: "j",
				ctrlKey: false,
				altKey: false,
				shiftKey: false,
				action: "addRemoveArticulation"
			}, {
				event: "keydown",
				key: "k",
				ctrlKey: false,
				altKey: false,
				shiftKey: false,
				action: "addRemoveArticulation"
			}, {
				event: "keydown",
				key: "l",
				ctrlKey: false,
				altKey: false,
				shiftKey: false,
				action: "addRemoveArticulation"
			}, {
				event: "keydown",
				key: "H",
				ctrlKey: false,
				altKey: false,
				shiftKey: true,
				action: "addRemoveArticulation"
			}, {
				event: "keydown",
				key: "I",
				ctrlKey: false,
				altKey: false,
				shiftKey: true,
				action: "addRemoveArticulation"
			}, {
				event: "keydown",
				key: "J",
				ctrlKey: false,
				altKey: false,
				shiftKey: true,
				action: "addRemoveArticulation"
			}, {
				event: "keydown",
				key: "K",
				ctrlKey: false,
				altKey: false,
				shiftKey: true,
				action: "addRemoveArticulation"
			}, {
				event: "keydown",
				key: "L",
				ctrlKey: false,
				altKey: false,
				shiftKey: true,
				action: "addRemoveArticulation"
			},{
				event: "keydown",
				key: "E",
				ctrlKey: false,
				altKey: false,
				shiftKey: true,
				action: "toggleEnharmonic"
			}
		];
	}

}
;
class defaultTrackerKeys {
	
	static get keys() {
		return [{
				event: "keydown",
				key: "ArrowRight",
				ctrlKey: false,
				altKey: false,
				shiftKey: false,
				action: "moveSelectionRight"
			}, {
				event: "keydown",
				key: "ArrowRight",
				ctrlKey: false,
				altKey: true,
				shiftKey: false,
				action: "advanceModifierSelection"
			}, {
				event: "keydown",
				key: "ArrowLeft",
				ctrlKey: false,
				altKey: true,
				shiftKey: false,
				action: "advanceModifierSelection"
			},{
				event: "keydown",
				key: "ArrowLeft",
				ctrlKey: false,
				altKey: false,
				shiftKey: false,
				action: "moveSelectionLeft"
			}, {
				event: "keydown",
				key: "ArrowRight",
				ctrlKey: false,
				altKey: false,
				shiftKey: true,
				action: "growSelectionRight"
			}, {
				event: "keydown",
				key: "ArrowLeft",
				ctrlKey: false,
				altKey: false,
				shiftKey: true,
				action: "growSelectionLeft"
			}, {
				event: "keydown",
				key: "ArrowUp",
				ctrlKey: false,
				altKey: false,
				shiftKey: false,
				action: "moveSelectionUp"
			}, {
				event: "keydown",
				key: "ArrowDown",
				ctrlKey: false,
				altKey: false,
				shiftKey: false,
				action: "moveSelectionDown"
			}, {
				event: "keydown",
				key: "ArrowRight",
				ctrlKey: true,
				altKey: false,
				shiftKey: false,
				action: "moveSelectionRightMeasure"
			}, {
				event: "keydown",
				key: "ArrowLeft",
				ctrlKey: true,
				altKey: false,
				shiftKey: false,
				action: "moveSelectionLeftMeasure"
			},{
				event: "keydown",
				key: "ArrowUp",
				ctrlKey: false,
				altKey: false,
				shiftKey: true,
				action: "moveSelectionPitchUp"
			},{
				event: "keydown",
				key: "ArrowDown",
				ctrlKey: false,
				altKey: false,
				shiftKey: true,
				action: "moveSelectionPitchDown"
			}
			];
	}
};// # Dialog base classes

// ## SuiModifierDialogFactory
// Automatic dialog constructors for dialogs without too many parameters
// that operated on a selection.
class SuiModifierDialogFactory {

  static createDialog(modifier, parameters) {
    var dbType = SuiModifierDialogFactory.modifierDialogMap[modifier.attrs.type];
      if (dbType === 'SuiLyricDialog' && modifier.parser === SmoLyric.parsers.chord) {
        dbType = 'SuiChordChangeDialog';
      }
      var ctor = eval(dbType);
      if (!ctor) {
      console.warn('no dialog for modifier ' + modifier.type);
      return;
    }
    return ctor.createAndDisplay({
    modifier: modifier,
        ...parameters
    });
  }
  static get modifierDialogMap() {
    return {
      SmoStaffHairpin: 'SuiHairpinAttributesDialog',
      SmoSlur: 'SuiSlurAttributesDialog',
      SmoDynamicText: 'SuiDynamicModifierDialog',
      SmoVolta: 'SuiVoltaAttributeDialog',
      SmoScoreText: 'SuiTextTransformDialog',
      SmoTextGroup: 'SuiTextTransformDialog',
      SmoLoadScore: 'SuiLoadFileDialog',
      SmoLyric:'SuiLyricDialog'
    };
  }
}

// ## SuiDialogBase
// Base class for dialogs.
class SuiDialogBase {
    // ### SuiDialogBase ctor
    // Creates the DOM element for the dialog and gets some initial elements
  constructor(dialogElements, parameters) {
    this.id = parameters.id;
    this.boundKeyboard = false;
    this.components = [];

    console.log('creating close dialog promise in SuiDialogBase');
    this.closeDialogPromise = new Promise((resolve, reject) => {
      $('body').off('dialogDismiss').on('dialogDismiss', function () {
          console.log('dialog dismiss DOM event received, resolve closeDialogPromise');
          resolve();
      });
    });

    const staticText = dialogElements.find((xx) => xx.staticText);
    if (!staticText) {
      throw('dialog ' + this.ctor+ ' needs a static text section');
    }
    this.staticText = {};
    staticText.staticText.forEach((st) => {
      const key = Object.keys(st)[0];
      this.staticText[key] = st[key];

    });

    this.initialLeft = parameters.left
    this.initialTop = parameters.top;

    // If this dialog was spawned by a menu, wait for the menu to dismiss
    // before continuing.
    this.startPromise = parameters.closeMenuPromise;
    this.eventSource = parameters.eventSource;
    this.layout = parameters.layout;
    this.context = this.layout.context;
    this.dialogElements = dialogElements;
    this.tracker = parameters.tracker;
    this.completeNotifier = parameters.completeNotifier;
    this.undoBuffer = parameters.undoBuffer;
    this.editor = parameters.editor;
    this.label = this.staticText.label;
    this.modifier = parameters.modifier;
    this.activeScoreText = parameters.activeScoreText;

    var top = parameters.top - this.tracker.scroller.netScroll.y;
    var left = parameters.left - this.tracker.scroller.netScroll.x;

    this.dgDom = this._constructDialog(dialogElements, {
      id: 'dialog-' + this.id,
      top: top,
      left: left,
      label: this.label
    });

    SmoTranslator.registerDialog(this.ctor);
  }

  // ### printXlate
  // print json with string labels to use as a translation file seed.
  static printTranslate(_class) {
    var output = [];
    var xx = eval(_class);
    xx['dialogElements'].forEach((element) => {
      var component = {};
      if (element.label) {
        component.label = element.label;
        component.id = element.smoName;
        if (element.options) {
          component.options = [];

          element.options.forEach((option) => {
            component.options.push({value:option.value,label:option.label})
          });
        }
      }
      if (element.staticText) {
        component.staticText = {};
        element.staticText.forEach((st) => {
          var key = Object.keys(st)[0];
          component.staticText[key] = st[key];
        });
      }
      output.push(component);
    });
    return {ctor:xx['ctor'],dialogElements:output};
  }

  get closeModalPromise() {
    return this.closeDialogPromise;
  }

  // ### position
  // For dialogs based on selections, tries to place the dialog near the selection and also
  // to scroll so the dialog is in view
  static position(box,dgDom,scroller) {
    var y = (box.y + box.height) - scroller.netScroll.y;

  	// TODO: adjust if db is clipped by the browser.
    var dge = $(dgDom.element).find('.attributeModal');
    var dgeHeight = $(dge).height();
    var maxY =  $('.musicRelief').height();
    var maxX = $('.musicRelief').width();
    var offset = $('.dom-container').offset();
    y = y - offset.top;

    var offsetY = dgeHeight + y > window.innerHeight ? (dgeHeight + y) -  window.innerHeight : 0;
    y = (y < 0) ? -y : y - offsetY;

    y = (y > maxY || y < 0) ? maxY / 2 : y;

  	$(dge).css('top', '' + y + 'px');

    var x = box.x - scroller.netScroll.x;
    x = x - offset.left;
    var w = $(dge).width();
    x = (x > window.innerWidth /2)  ? x - (w+25) : x + (w+25);

    x = (x < 0 || x > maxX) ? maxX/2 : x;
    $(dge).css('left', '' + x + 'px');
  }

    // ### position
    // Position the dialog near a selection.  If the dialog is not visible due
    // to scrolling, make sure it is visible.
  position(box) {
    SuiDialogBase.position(box,this.dgDom,this.tracker.scroller);
  }
    // ### build the html for the dialog, based on the instance-specific components.
  _constructDialog(dialogElements, parameters) {
    var id = parameters.id;
    var b = htmlHelpers.buildDom;
    var r = b('div').classes('attributeModal').attr('id','attr-modal-'+id)
      .css('top', parameters.top + 'px').css('left', parameters.left + 'px')
    .append(b('spanb').classes('draggable button').append(b('span').classes('icon icon-move jsDbMove')))
    .append(b('h2').classes('dialog-label').text(this.staticText.label));

    var ctrl = b('div').classes('smoControlContainer');
    dialogElements.filter((de) => de.control).forEach((de) => {
      var ctor = eval(de.control);
      var control = new ctor(this, de);
      this.components.push(control);
      ctrl.append(control.html);
    });
    r.append(ctrl);
    r.append(
    b('div').classes('buttonContainer').append(
    b('button').classes('ok-button button-left').text('OK')).append(
    b('button').classes('cancel-button button-center').text('Cancel')).append(
    b('button').classes('remove-button button-right').text('Remove').append(
    b('span').classes('icon icon-cancel-circle'))));
    $('.attributeDialog').html('');

    $('.attributeDialog').append(r.dom());

    var trapper = htmlHelpers.inputTrapper('.attributeDialog');
    $('.attributeDialog').find('.cancel-button').focus();
    return {
      element: $('.attributeDialog'),
      trapper: trapper
    };
  }

  // ### _commit
  // generic logic to commit changes to a momdifier.
  _commit() {
    this.modifier.restoreOriginal();
    this.components.forEach((component) => {
      this.modifier[component.smoName] = component.getValue();
    });
  }

     // ### Complete
     // Dialogs take over the keyboard, so release that and trigger an event
     // that the dialog is closing that can resolve any outstanding promises.
  complete() {
    if (this.boundKeyboard) {
      this.eventSource.unbindKeydownHandler(this.keydownHandler);
    }
    $('body').removeClass('showAttributeDialog');
    console.log('dialog complete method called, triggering dialog close');
    $('body').trigger('dialogDismiss');
    this.dgDom.trapper.close();
  }

    // ### _bindComponentNames
    // helper method to give components class names based on their static configuration
  _bindComponentNames() {
    this.components.forEach((component) => {
      var nm = component.smoName + 'Ctrl';
      this[nm] = component;
    });
  }

   // ### display
   // make3 the modal visible.  bind events and elements.
  display() {
    $('body').addClass('showAttributeDialog');
    this.components.forEach((component) => {
      component.bind();
    });
    this._bindElements();
    if (this.modifier && this.modifier.renderedBox) {
      this.position(this.modifier.renderedBox);
    }
    this.tracker.scroller.scrollVisibleBox(
      svgHelpers.smoBox($(this.dgDom.element)[0].getBoundingClientRect())
    );

    var cb = function (x, y) {}
    htmlHelpers.draggable({
      parent: $(this.dgDom.element).find('.attributeModal'),
      handle: $(this.dgDom.element).find('.jsDbMove'),
      animateDiv:'.draganime',
      cb: cb,
      moveParent: true
    });
  }

  // ### handleKeydown
  // allow a dialog to be dismissed by esc.
  evKey(evdata) {
    if (evdata.key == 'Escape') {
      $(this.dgDom.element).find('.cancel-button').click();
      evdata.preventDefault();
      return;
    }
    return;
  }

  // ### bindKeyboard
  // generic logic to grab keyboard elements for modal
  bindKeyboard() {
      this.boundKeyboard = true;
      this.keydownHandler = this.eventSource.bindKeydownHandler(this,'evKey');
  }

   // ### _bindElements
   // bing the generic controls in most dialogs.
  _bindElements() {
  var self = this;
  var dgDom = this.dgDom;
        this.bindKeyboard();

  $(dgDom.element).find('.ok-button').off('click').on('click', function (ev) {
  self._commit();
  self.complete();
  });

  $(dgDom.element).find('.cancel-button').off('click').on('click', function (ev) {
  self.modifier.restoreOriginal();
  self.complete();
  });
  $(dgDom.element).find('.remove-button').off('click').on('click', function (ev) {
  self.handleRemove();
  self.complete();
  });
  }
}
;
// ## SuiLayoutDialog
// The layout dialog has page layout and zoom logic.  It is not based on a selection but score-wide
class SuiLayoutDialog extends SuiDialogBase {

  static get ctor() {
    return 'SuiLayoutDialog';
  }
  get ctor() {
    return SuiLayoutDialog.ctor;
  }

   // ### dialogElements
   // all dialogs have elements define the controls of the dialog.
  static get dialogElements() {
    SuiLayoutDialog._dialogElements = SuiLayoutDialog._dialogElements ? SuiLayoutDialog._dialogElements :
     [
       {
        smoName: 'pageSize',
        parameterName: 'pageSize',
        defaultValue: SmoScore.pageSizes.letter,
        control: 'SuiDropdownComponent',
        label:'Page Size',
        options: [{
            value: 'letter',
            label: 'Letter'
            }, {
            value: 'tabloid',
            label: 'Tabloid (11x17)'
            }, {
            value: 'A4',
            label: 'A4'
            }, {
            value: 'custom',
            label: 'Custom'
            }
          ]
        }, {
          smoName: 'pageWidth',
          parameterName: 'pageWidth',
          defaultValue: SmoScore.defaults.layout.pageWidth,
          control: 'SuiRockerComponent',
          label: 'Page Width (px)'
        }, {
          smoName: 'pageHeight',
          parameterName: 'pageHeight',
          defaultValue: SmoScore.defaults.layout.pageHeight,
          control: 'SuiRockerComponent',
          label: 'Page Height (px)'
        }, {
          smoName: 'orientation',
          parameterName: 'orientation',
          defaultValue: SmoScore.orientations.portrait,
          control: 'SuiDropdownComponent',
          label: 'Orientation',
          dataType:'int',
          options:[{
              value:SmoScore.orientations.portrait,
              label:'Portrait'
            }, {
              value:SmoScore.orientations.landscape,
              label:'Landscape'
          }]
        }, {
          smoName: 'engravingFont',
          parameterName: 'engravingFont',
          defaultValue: SmoScore.engravingFonts.Bravura,
          control: 'SuiDropdownComponent',
          label:'Engraving Font',
          options: [{
              value: 'Bravura',
              label: 'Bravura'
            }, {
              value: 'Gonville',
              label: 'Gonville'
            }, {
              value: 'Petaluma',
              label: 'Petaluma'
            }
          ]
        },{
          smoName: 'leftMargin',
          parameterName: 'leftMargin',
          defaultValue: SmoScore.defaults.layout.leftMargin,
          control: 'SuiRockerComponent',
          label: 'Left Margin (px)'
        }, {
          smoName: 'rightMargin',
          parameterName: 'rightMargin',
          defaultValue: SmoScore.defaults.layout.rightMargin,
          control: 'SuiRockerComponent',
          label: 'Right Margin (px)'
        }, {
          smoName: 'topMargin',
          parameterName: 'topMargin',
          defaultValue: SmoScore.defaults.layout.topMargin,
          control: 'SuiRockerComponent',
          label: 'Top Margin (px)'
        }, {
          smoName: 'interGap',
          parameterName: 'interGap',
          defaultValue: SmoScore.defaults.layout.interGap,
          control: 'SuiRockerComponent',
          label: 'Inter-System Margin'
        }, {
          smoName: 'intraGap',
          parameterName: 'intraGap',
          defaultValue: SmoScore.defaults.layout.intraGap,
          control: 'SuiRockerComponent',
          label: 'Intra-System Margin'
        }, {
          smoName: 'zoomScale',
          parameterName: 'zoomScale',
          defaultValue: SmoScore.defaults.layout.zoomScale,
          control: 'SuiRockerComponent',
          label: '% Zoom',
          type: 'percent'
        }, {
          smoName: 'svgScale',
          parameterName: 'svgScale',
          defaultValue: SmoScore.defaults.layout.svgScale,
          control: 'SuiRockerComponent',
          label: '% Note size',
          type: 'percent'
        },
        {staticText:[
          {label : 'Score Layout'}
        ]}
      ];

    return SuiLayoutDialog._dialogElements;
  }
    // ### backupOriginal
    // backup the original layout parameters for trial period
  backupOriginal() {
    this.backup = JSON.parse(JSON.stringify(this.modifier));
  }
  display() {
    $('body').addClass('showAttributeDialog');
    this.components.forEach((component) => {
    component.bind();
  });
  this.components.forEach((component) => {
    var val = this.modifier[component.parameterName];
    component.setValue(val);
  });
  this._setPageSizeDefault();
  this._bindElements();

  var cb = function (x, y) {}
  htmlHelpers.draggable({
  parent: $(this.dgDom.element).find('.attributeModal'),
  handle: $(this.dgDom.element).find('.icon-move'),
            animateDiv:'.draganime',
  cb: cb,
  moveParent: true
  });
  this.completeNotifier.unbindKeyboardForModal(this);

    var box = svgHelpers.boxPoints(250,250,1,1);
    SuiDialogBase.position(box,this.dgDom,this.tracker.scroller);
  }
  // ### _updateLayout
  // even if the layout is not changed, we re-render the entire score by resetting
  // the svg context.
  _updateLayout() {
    this.layout.rerenderAll();
  }
  _handleCancel() {
  this.layout.score.layout = this.backup;
  this._updateLayout();
  this.complete();
  }
  _bindElements() {
  var self = this;
  var dgDom = this.dgDom;
        this.bindKeyboard();
        this._bindComponentNames();

  $(dgDom.element).find('.ok-button').off('click').on('click', function (ev) {

  // TODO:  allow user to select a zoom mode.
  self.layout.score.layout.zoomMode = SmoScore.zoomModes.zoomScale;
  self._updateLayout();
  self.complete();
  });

  $(dgDom.element).find('.cancel-button').off('click').on('click', function (ev) {
  self._handleCancel();
  });

  $(dgDom.element).find('.remove-button').remove();
  }
  _setPageSizeDefault() {
  var value = 'custom';
  var scoreDims = this.layout.score.layout;
  SmoScore.pageSizes.forEach((sz) => {
  var dim = SmoScore.pageDimensions[sz];
  if (scoreDims.pageWidth === dim.width && scoreDims.pageHeight === dim.height) {
  value = sz;
  } else if (scoreDims.pageHeight === dim.width && scoreDims.pageWidth === dim.height) {
  value = sz;
  }
  });
  this.components.find((x)=>{return x.parameterName==='pageSize'}).setValue(value);
  }
    // ### _handlePageSizeChange
    // see if the dimensions have changed.
  _handlePageSizeChange() {
  var pageSizeComp = this.components.find((x)=>{return x.parameterName==='pageSize'});
  var sel = pageSizeComp.getValue();
  if (sel === 'custom') {
  $('.attributeModal').addClass('customPage');
  } else {
  $('.attributeModal').removeClass('customPage');
  var dim = SmoScore.pageDimensions[sel];
  var hComp = this.components.find((x)=>{return x.parameterName==='pageHeight'});
  var wComp = this.components.find((x)=>{return x.parameterName==='pageWidth'});
  hComp.setValue(dim.height);
  wComp.setValue(dim.width);
  }
  }
    // ### changed
    // One of the components has had a changed value.
  changed() {
  // this.modifier.backupOriginal();
  this._handlePageSizeChange();
  this.components.forEach((component) => {
      if (typeof(this.layout.score.layout[component.smoName]) != 'undefined') {
      this.layout.score.layout[component.smoName] = component.getValue();
      }
  });
    if (this.engravingFontCtrl.changeFlag)  {
      this.layout.score.engravingFont = this.engravingFontCtrl.getValue();
      suiLayoutBase.setFont(this.layout.score.engravingFont);
    }
  this.layout.setViewport();
  }

  // ### createAndDisplay
  // static method to create the object and then display it.
  static createAndDisplay(parameters) {
  var dg = new SuiLayoutDialog(parameters);
  dg.display();
  }
  constructor(parameters) {
  var p = parameters;

  super(SuiLayoutDialog.dialogElements, {
  id: 'dialog-layout',
  top: (p.layout.score.layout.pageWidth / 2) - 200,
  left: (p.layout.score.layout.pageHeight / 2) - 200,
      ...parameters
  });
  this.layout = p.layout;
  this.modifier = this.layout.score.layout;
  this.backupOriginal();
  }
}
;
class SuiFileDialog extends SuiDialogBase {
  constructor(parameters) {
		var p = parameters;
    var ctor = eval(parameters.ctor);
    p.label = parameters.label ? parameters.label : 'Dialog Box';
    p.id = 'dialog-file';
    p.top = (p.layout.score.layout.pageWidth / 2) - 200;
    p.left = (p.layout.score.layout.pageHeight / 2) - 200;

		super(ctor.dialogElements, p);

    // File dialogs can be created from menu, get menu promise
		this.layout = p.layout;
    this.value='';
	}
  display() {
    $('body').addClass('showAttributeDialog');
		this.components.forEach((component) => {
			component.bind();
		});
		this._bindElements();

    // make sure keyboard is unbound or we get dupicate key events.
    var self=this;
    function getKeys() {
        self.completeNotifier.unbindKeyboardForModal(self);
    }
    this.startPromise.then(getKeys);
    this.position($(this.dgDom.element)[0].getBoundingClientRect());
	}

  _bindElements() {
  	var self = this;
  	var dgDom = this.dgDom;

  	$(dgDom.element).find('.ok-button').off('click').on('click', function (ev) {
            self.commit();
  	});

  	$(dgDom.element).find('.cancel-button').off('click').on('click', function (ev) {
  		self.complete();
  	});

  	$(dgDom.element).find('.remove-button').remove();
        this.bindKeyboard();
  	}
    position(box) {
  	var y = (window.innerHeight/3  + box.height);

  	// TODO: adjust if db is clipped by the browser.
    var dge = $(this.dgDom.element).find('.attributeModal');

  	$(dge).css('top', '' + y + 'px');
        var x = window.innerWidth - box.width/2;
        $(dge).css('left', '' + x + 'px');
  }
}
class SuiLoadFileDialog extends SuiFileDialog {
  static get ctor() {
    return 'SuiLoadFileDialog';
  }
  get ctor() {
    return SuiLoadFileDialog.ctor;
  }

    static get dialogElements() {
      SuiLoadFileDialog._dialogElements = SuiLoadFileDialog._dialogElements ? SuiLoadFileDialog._dialogElements :
		    [{
  				smoName: 'loadFile',
  				parameterName: 'jsonFile',
  				defaultValue: '',
  				control: 'SuiFileDownloadComponent',
  				label:''
			  },{staticText: [
          {label: 'Load File'}
        ]}
      ];
      return SuiLoadFileDialog._dialogElements;
    }

    changed() {
        this.value = this.components[0].getValue();
        $(this.dgDom.element).find('.ok-button').prop('disabled',false);
    }
    commit() {
        var scoreWorks = false;
        if (this.value) {
            try {
                var score = SmoScore.deserialize(this.value);
                scoreWorks=true;
                this.layout.score = score;
                this.layout.setViewport(true);
                setTimeout(function() {
                    $('body').trigger('forceResizeEvent');
                },1);
                this.complete();
            } catch (e) {
                console.log('unable to score '+e);
            }
            if (!scoreWorks) {
                this.complete();
            }
        }
    }
    static createAndDisplay(params) {
		var dg = new SuiLoadFileDialog(params);
		dg.display();
     // disable until file is selected
    $(dg.dgDom.element).find('.ok-button').prop('disabled',true);
	}
    constructor(parameters) {
        parameters.ctor='SuiLoadFileDialog';
        super(parameters);
	}
}


class SuiPrintFileDialog extends SuiFileDialog {
  static get ctor() {
    return 'SuiPrintFileDialog';
  }
  get ctor() {
    return SuiPrintFileDialog.ctor;
  }
  static get label() {
    SuiPrintFileDialog._label = SuiPrintFileDialog._label ? SuiPrintFileDialog._label :
       'Print Complete';
    return SuiPrintFileDialog._label;
  }
  static set label(value) {
    SuiPrintFileDialog._label = value;
  }

  static get dialogElements() {
	  return [
      {staticText: [
      {label: 'Print Complete'}
    ]}];
  }
  static createAndDisplay(params) {
		var dg = new SuiPrintFileDialog(params);
		dg.display();
	}
  constructor(parameters) {
    parameters.ctor='SuiPrintFileDialog';
    super(parameters);
	}
  changed() {}
  _bindElements() {
    var self = this;
    var dgDom = this.dgDom;
		$(dgDom.element).find('.ok-button').off('click').on('click', function (ev) {
      $('body').removeClass('printing');
      self.layout.restoreLayoutAfterPrint();
      window.dispatchEvent(new Event('resize'));
      self.complete();
	  });

		$(dgDom.element).find('.cancel-button').remove();
		$(dgDom.element).find('.remove-button').remove();
	}
}
class SuiSaveFileDialog extends SuiFileDialog {
  static get ctor() {
    return 'SuiSaveFileDialog';
  }
  get ctor() {
    return SuiSaveFileDialog.ctor;
  }

  static get dialogElements() {
    SuiSaveFileDialog._dialogElements = SuiSaveFileDialog._dialogElements ? SuiSaveFileDialog._dialogElements :
	  [{
        smoName: 'saveFileName',
        parameterName: 'saveFileName',
        defaultValue: '',
        control: 'SuiTextInputComponent',
        label:'File Name'
		},
    {
      staticText: [
        {label : 'Save Score'}
      ]
    }];

    return SuiSaveFileDialog._dialogElements;
  }

  changed() {
    this.value = this.components[0].getValue();
  }
  commit() {
    var filename = this.value;
    if (!filename) {
        filename='myScore.json';
    }
    if (filename.indexOf('.json') < 0) {
        filename = filename + '.json';
    }
    var txt = this.layout.score.serialize();
    txt = JSON.stringify(txt);
    htmlHelpers.addFileLink(filename,txt,$('.saveLink'));
    $('.saveLink a')[0].click();
    this.complete();
  }
  static createAndDisplay(params) {
		var dg = new SuiSaveFileDialog(params);
		dg.display();
	}
  constructor(parameters) {
    parameters.ctor='SuiSaveFileDialog';
    super(parameters);
	}
}
;class SuiLyricDialog extends SuiDialogBase {
  static get ctor() {
    return 'SuiLyricDialog';
  }
  get ctor() {
    return SuiLyricDialog.ctor;
  }
  static createAndDisplay(parameters) {
  var dg = new SuiLyricDialog(parameters);
  dg.display();
      return dg;
  }
  static get dialogElements() {
    SuiLyricDialog._dialogElements = SuiLyricDialog._dialogElements ? SuiLyricDialog._dialogElements :
     [{
      smoName: 'verse',
      parameterName: 'verse',
      defaultValue: 0,
      control: 'SuiDropdownComponent',
      label:'Verse',
      startRow:true,
      options: [{
          value: 0,
          label: '1'
        }, {
          value: 1,
          label: '2'
        }, {
          value: 2,
          label: '3'
        }
      ]
    },{
      smoName: 'translateY',
      parameterName: 'translateY',
      defaultValue: 0,
      control: 'SuiRockerComponent',
      label: 'Y Adjustment (Px)',
      type: 'int'
    }, {
      smoName: 'lyricEditor',
      parameterName: 'text',
      defaultValue: 0,
      control: 'SuiLyricComponent',
      label:'Edit Lyrics',
      options: []
    }, {
    staticText: [
      {doneEditing: 'Done Editing Lyrics'},
      {undo: 'Undo Lyrics'},
      {label: 'Lyric Editor'}
    ]}
  ];

    return SuiLyricDialog._dialogElements;
  }


  // ### getStaticText
  // given 'foo' return dialogElements.staticText value that has key of 'foo'
  static getStaticText(label) {
    return SuiLyricDialog.dialogElements.find((x) => x.staticText).staticText.find((x) => x[label])[label];
  }

  constructor(parameters) {
    parameters.ctor= parameters.ctor ? parameters.ctor : 'SuiLyricDialog';
    var p = parameters;
    const _class = eval(p.ctor);
    const dialogElements = _class['dialogElements'];

    super(dialogElements, {
      id: 'dialog-lyrics',
      top: (p.layout.score.layout.pageWidth / 2) - 200,
      left: (p.layout.score.layout.pageHeight / 2) - 200,
      ...p
    });

    // If we are editing existing lyrics, make sure it is the same type of session.
    // Note: the actual lyric (modifier) is picked later from the selection. We just
    // need to keep track of which type of thing we are editing.
    if (parameters.modifier) {
      this.parser = parameters.modifier.parser;
    } else {
      this.parser = parameters.parser; // lyrics or chord changes
    }
    SmoUndoable.noop(this.layout.score,this.undoBuffer,'Undo lyrics');
  }
  display() {
    $('body').addClass('showAttributeDialog');
    $('body').addClass('textEditor');
    this.components.forEach((component) => {
      component.bind();
    });

    this._bindComponentNames();

    // this.editor = this.components.find((c) => c.smoName === 'textEditor');
    this.verse = this.components.find((c) => c.smoName === 'verse');
    this._bindElements();

    // make sure keyboard is unbound or we get dupicate key events.
    var self=this;
    this.completeNotifier.unbindKeyboardForModal(this);

    $(this.dgDom.element).find('.smoControl').each((ix,ctrl) => {
        if (!$(ctrl).hasClass('cbLyricEdit')) {
          $(ctrl).addClass('fold-textedit');
        }
    });

    this.position(this.tracker.selections[0].note.renderedBox);

    var cb = function (x, y) {}
    htmlHelpers.draggable({
      parent: $(this.dgDom.element).find('.attributeModal'),
      handle: $(this.dgDom.element).find('.jsDbMove'),
            animateDiv:'.draganime',
            cb: cb,
      moveParent: true
    });
    this.mouseMoveHandler = this.eventSource.bindMouseMoveHandler(this,'mouseMove');
    this.mouseClickHandler = this.eventSource.bindMouseClickHandler(this,'mouseClick');
    this.bindKeyboard();
  }
  _focusSelection() {
    if (this.lyricEditorCtrl.editor.selection &&
      this.lyricEditorCtrl.editor.selection.note &&
      this.lyricEditorCtrl.editor.selection.note.renderedBox) {
      this.tracker.scroller.scrollVisibleBox(this.lyricEditorCtrl.editor.selection.note.renderedBox);
    }
  }
  changed() {
    this.lyricEditorCtrl.verse = this.verse.getValue();
  }
  _bindElements() {
    var self = this;
    var dgDom = this.dgDom;

    $(dgDom.element).find('.ok-button').off('click').on('click', function (ev) {
      self.tracker.replaceSelectedMeasures();
      self.tracker.layout.setDirty();
      self._complete();
    });
    $(dgDom.element).find('.cancel-button').off('click').on('click', function (ev) {
      self.editor.undo();
      self.tracker.layout.setDirty();
      self._complete();
    });
    $(dgDom.element).find('.remove-button').remove();
    this.lyricEditorCtrl.eventSource = this.eventSource;
    this.lyricEditorCtrl.startEditSession();
  }
  // ### handleKeydown
  // allow a dialog to be dismissed by esc.
  evKey(evdata) {
    if (evdata.key == 'Escape') {
      $(this.dgDom.element).find('.cancel-button').click();
      evdata.preventDefault();
      return;
    } else {
      this.lyricEditorCtrl.evKey(evdata);
    }
  }

  _complete() {
    this.layout.setDirty();
    if (this.lyricEditorCtrl.running) {
      this.lyricEditorCtrl.endSession();
    }
    this.eventSource.unbindMouseMoveHandler(this.mouseMoveHandler);
    this.eventSource.unbindMouseClickHandler(this.mouseClickHandler);
    $('body').removeClass('showAttributeDialog');
    $('body').removeClass('textEditor');
    this.complete();
  }


  mouseMove(ev) {
    if (this.lyricEditorCtrl && this.lyricEditorCtrl.running) {
      this.lyricEditorCtrl.mouseMove(ev);
    }
  }

  mouseClick(ev) {
    if (this.lyricEditorCtrl && this.lyricEditorCtrl.running) {
      this.lyricEditorCtrl.mouseClick(ev);
      ev.stopPropagation();
    }
  }

}

class SuiChordChangeDialog  extends SuiDialogBase {
  static get ctor() {
    return 'SuiChordChangeDialog';
  }
  get ctor() {
    return SuiChordChangeDialog.ctor;
  }

  static createAndDisplay(parameters) {
    var dg = new SuiChordChangeDialog(parameters);
    dg.display();
    return dg;
  }
  constructor(parameters) {
    parameters.ctor = 'SuiChordChangeDialog';
    const p = parameters;
    const _class = eval(p.ctor);
    const dialogElements = _class['dialogElements'];

    super(dialogElements, {
      id: 'dialog-lyrics',
      top: (p.layout.score.layout.pageWidth / 2) - 200,
      left: (p.layout.score.layout.pageHeight / 2) - 200,
      ...p
    });
  }
  static get dialogElements() {
    SuiChordChangeDialog._dialogElements = SuiChordChangeDialog._dialogElements ? SuiChordChangeDialog._dialogElements :
      [{
        smoName: 'verse',
        parameterName: 'verse',
        defaultValue: 0,
        control: 'SuiDropdownComponent',
        label:'Ordinality',
        startRow:true,
        options: [{
            value: 0,
            label: '1'
          }, {
            value: 1,
            label: '2'
          }, {
            value: 2,
            label: '3'
          }
        ]
      },{
        smoName: 'translateY',
        parameterName: 'translateY',
        defaultValue: 0,
        control: 'SuiRockerComponent',
        label: 'Y Adjustment (Px)',
        type: 'int'
      }, {
        smoName: 'chordEditor',
        parameterName: 'text',
        defaultValue: 0,
        control: 'SuiChordComponent',
        label:'Edit Text',
        options: []
      }, {
        staticText: [
          {label : 'Edit Chord Symbol'},
          {undo: 'Undo Chord Symbols'},
          {doneEditing : 'Done Editing Chord Symbols' }
        ]
      }
    ];

    return SuiChordChangeDialog._dialogElements;
  }
  changed() {
    this.chordEditorCtrl.verse = this.verse.getValue();

    if (this.translateYCtrl.changeFlag) {
      this.chordEditorCtrl.setYOffset(this.translateYCtrl.getValue());
      this.tracker.replaceSelectedMeasures();
    } else {
      this.translateYCtrl.setValue(this.textEditorCtrl.getYOffset());
    }
  }

  display() {
    $('body').addClass('showAttributeDialog');
    $('body').addClass('textEditor');
    this.components.forEach((component) => {
      component.bind();
    });

    this._bindComponentNames();

    // this.editor = this.components.find((c) => c.smoName === 'textEditor');
    this.verse = this.components.find((c) => c.smoName === 'verse');
    this._bindElements();

    // make sure keyboard is unbound or we get dupicate key events.
    var self=this;
    this.completeNotifier.unbindKeyboardForModal(this);

    $(this.dgDom.element).find('.smoControl').each((ix,ctrl) => {
        if (!$(ctrl).hasClass('cbLyricEdit')) {
          $(ctrl).addClass('fold-textedit');
        }
    });

    this.position(this.tracker.selections[0].note.renderedBox);

    var cb = function (x, y) {}
    htmlHelpers.draggable({
      parent: $(this.dgDom.element).find('.attributeModal'),
      handle: $(this.dgDom.element).find('.jsDbMove'),
            animateDiv:'.draganime',
            cb: cb,
      moveParent: true
    });
    this.mouseMoveHandler = this.eventSource.bindMouseMoveHandler(this,'mouseMove');
    this.mouseClickHandler = this.eventSource.bindMouseClickHandler(this,'mouseClick');
    this.bindKeyboard();
  }

  _bindElements() {
    var self = this;
    var dgDom = this.dgDom;

    $(dgDom.element).find('.ok-button').off('click').on('click', function (ev) {
      self.tracker.replaceSelectedMeasures();
      self.tracker.layout.setDirty();
      self._complete();
    });
    $(dgDom.element).find('.cancel-button').off('click').on('click', function (ev) {
      self.editor.undo();
      self.tracker.layout.setDirty();
      self._complete();
    });
    $(dgDom.element).find('.remove-button').remove();
    this.chordEditorCtrl.eventSource = this.eventSource;
    this.chordEditorCtrl.startEditSession();
  }

  // ### handleKeydown
  // allow a dialog to be dismissed by esc.
  evKey(evdata) {
    if (evdata.key == 'Escape') {
      $(this.dgDom.element).find('.cancel-button').click();
      evdata.preventDefault();
      return;
    } else {
      this.chordEditorCtrl.evKey(evdata);
    }
  }

  _complete() {
    if (this.chordEditorCtrl.running) {
      this.chordEditorCtrl.endSession();
    }
    this.layout.setDirty();
    this.eventSource.unbindMouseMoveHandler(this.mouseMoveHandler);
    this.eventSource.unbindMouseClickHandler(this.mouseClickHandler);
    $('body').removeClass('showAttributeDialog');
    $('body').removeClass('textEditor');
    this.complete();
  }


  mouseMove(ev) {
    if (this.chordEditorCtrl && this.chordEditorCtrl.running) {
      this.chordEditorCtrl.mouseMove(ev);
    }
  }

  mouseClick(ev) {
    if (this.chordEditorCtrl && this.chordEditorCtrl.running) {
      this.chordEditorCtrl.mouseClick(ev);
      ev.stopPropagation();
    }
  }
}

class SuiTextTransformDialog  extends SuiDialogBase {
  static createAndDisplay(parameters) {
  var dg = new SuiTextTransformDialog(parameters);
  dg.display();
    return dg;
  }

  static get ctor() {
    return 'SuiTextTransformDialog';
  }
  get ctor() {
    return SuiTextTransformDialog.ctor;
  }
  static get dialogElements() {
    SuiTextTransformDialog._dialogElements = SuiTextTransformDialog._dialogElements ? SuiTextTransformDialog._dialogElements :
      [
      {
        smoName: 'textEditor',
        parameterName: 'text',
        defaultValue: 0,
        control: 'SuiTextInPlace',
        label:'Edit Text',
        options: []
      },{
        smoName: 'textDragger',
        parameterName: 'textLocation',
        defaultValue: 0,
        control: 'SuiDragText',
        label:'Move Text',
        options: []
      },
      {
        smoName: 'x',
        parameterName: 'x',
        defaultValue: 0,
        control: 'SuiRockerComponent',
        label: 'X Position (Px)',
                startRow:true,
        type: 'int'
      },{
        smoName: 'y',
        parameterName: 'y',
        defaultValue: 0,
        control: 'SuiRockerComponent',
        label: 'Y Position (Px)',
                startRow:true,
        type: 'int'
      }, {
        smoName: 'justification',
        parameterName: 'justification',
        defaultValue: SmoScoreText.justifications.left,
        control: 'SuiDropdownComponent',
        label:'Justification',
                startRow:true,
        options: [{
            value: 'left',
            label: 'Left'
          }, {
            value: 'right',
            label: 'Right'
          }, {
            value: 'center',
            label: 'Center'
          }
        ]
      },
      {
        smoName: 'fontFamily',
        parameterName: 'fontFamily',
        defaultValue: SmoScoreText.fontFamilies.times,
        control: 'SuiDropdownComponent',
        label:'Font Family',
        startRow:true,
        options: [{value:SmoScoreText.fontFamilies.serif,label:'Serif'},
          {value:SmoScoreText.fontFamilies.sansSerif,label:'Sans-Serif'},
          {label:'Monospace',value:SmoScoreText.fontFamilies.monospace},
          {label:'Cursive',value:SmoScoreText.fontFamilies.cursive},
          {label:'times',value:SmoScoreText.fontFamilies.times},
          {label:'arial',value:SmoScoreText.fontFamilies.arial},
          {label:'Helvetica',value:'Helvetica'}
        ]
      },
      {
        smoName: 'fontSize',
        parameterName: 'fontSize',
        defaultValue: 1,
        control: 'SuiRockerComponent',
        label: 'Font Size',
        type: 'float',
        increment:0.1
      },
      {
        smoName: 'fontUnit',
        parameterName: 'fontUnit',
        defaultValue: 'em',
        control: 'SuiDropdownComponent',
        label: 'Units',
        options: [{value:'em',label:'em'},{value:'px',label:'px'},{value:'pt',label:'pt'}]
      },
      {
        smoName: 'wrap',
        parameterName: 'wrap',
        defaultValue: false,
        control:'SuiToggleComponent',
        label: 'Wrap Text'
      },
      { // {every:'every',even:'even',odd:'odd',once:'once'}
        smoName: 'pagination',
        parameterName: 'pagination',
        defaultValue: SmoScoreText.paginations.every,
        control: 'SuiDropdownComponent',
        label:'Page Behavior',
        startRow:true,
        options: [{value:'once',label:'Once'},
          {value:'every',label:'Every'},
          {label:'Even',value:'even'},
          {label:'Odd',value:'odd'},
          {label:'Subsequent',value:'subsequent'}
        ]
      }, {
        staticText: [
          {label : 'Text Properties' },
          {editorLabel: 'Done Editing Text Block' },
          {draggerLabel: 'Done Dragging Text'}
        ]
      }
    ];

    return SuiTextTransformDialog._dialogElements;
  }
  static getStaticText(label) {
    return SuiTextTransformDialog.dialogElements.find((x) => x.staticText).staticText.find((x) => x[label])[label];
  }


  display() {
    console.log('text box creationg complete')
    this.textElement=$(this.layout.context.svg).find('.' + this.modifier.attrs.id)[0];

    $('body').addClass('showAttributeDialog');
    $('body').addClass('textEditor');
    this._bindComponentNames();

    this.components.forEach((component) => {
      component.bind();
    });

    var dbFontSize = this.components.find((c) => c.smoName === 'fontSize');
    var dbFontUnit  = this.components.find((c) => c.smoName === 'fontUnit');
    var fontSize = this.activeScoreText.fontInfo.size;
    fontSize=svgHelpers.getFontSize(fontSize);
    dbFontSize.setValue(fontSize.size);
    dbFontUnit.setValue(fontSize.unit);

    this.wrapCtrl.setValue(this.activeScoreText.boxModel != SmoScoreText.boxModels.none);

    this.paginationsComponent = this.components.find((c) => c.smoName == 'pagination');
    this.paginationsComponent.setValue(this.activeScoreText.pagination);

    this._bindElements();
    if (!this.activeScoreText.renderedBox) {
      this.layout.renderTextGroup(this.modifier);
    }
    this.position(this.activeScoreText.renderedBox);
    const ul = this.modifier.ul();
    this.xCtrl.setValue(ul.x);
    this.yCtrl.setValue(ul.y);

    var cb = function (x, y) {}
    htmlHelpers.draggable({
      parent: $(this.dgDom.element).find('.attributeModal'),
      handle: $(this.dgDom.element).find('span.jsDbMove'),
      animateDiv:'.draganime',
      cb: cb,
      moveParent: true
    });
    $(this.dgDom.element).find('.smoControl').each((ix,ctrl) => {
      if ($(ctrl).hasClass('cbTextInPlace')) {
       $(ctrl).addClass('fold-textmove');
       $(ctrl).addClass('fold-textresize');
      } else if ($(ctrl).hasClass('cbDragTextDialog')) {
        $(ctrl).addClass('fold-textedit');
        $(ctrl).addClass('fold-textresize');
      } else if ($(ctrl).hasClass('cbResizeTextBox')) {
        $(ctrl).addClass('fold-textedit');
        $(ctrl).addClass('fold-textmove');
      } else {
        $(ctrl).addClass('fold-textedit');
        $(ctrl).addClass('fold-textmove');
        $(ctrl).addClass('fold-textresize');
      }
    });

    // If this control has not been edited this session, assume they want to
    // edit the text and just right into that.
    if (!this.modifier.edited) {
      this.modifier.edited = true;
      layoutDebug.addDialogDebug('text transform db: startEditSession');
      this.textEditorCtrl.startEditSession();
    }
    this.mouseMoveHandler = this.eventSource.bindMouseMoveHandler(this,'mouseMove');
    this.mouseUpHandler = this.eventSource.bindMouseUpHandler(this,'mouseUp');
    this.mouseDownHandler = this.eventSource.bindMouseDownHandler(this,'mouseDown');
    this.mouseClickHandler = this.eventSource.bindMouseClickHandler(this,'mouseClick');
  }
  // ### handleKeydown
  // allow a dialog to be dismissed by esc.
  evKey(evdata) {
    if (evdata.key == 'Escape') {
      $(this.dgDom.element).find('.cancel-button').click();
      evdata.preventDefault();
      return;
    } else {
      this.textEditorCtrl.evKey(evdata);
    }
    return;
  }

  // ### Event handlers, passed from dialog
  mouseUp(ev) {
    if (this.textResizerCtrl && this.textResizerCtrl.running) {
      this.textResizerCtrl.mouseUp();
    }
    else if (this.textDraggerCtrl && this.textDraggerCtrl.running) {
      this.textDraggerCtrl.mouseUp();
    }
  }

  mouseMove(ev) {
    if (this.textResizerCtrl && this.textResizerCtrl.running) {
      this.textResizerCtrl.mouseMove(ev);
    }
    else if (this.textDraggerCtrl && this.textDraggerCtrl.running) {
      this.textDraggerCtrl.mouseMove(ev);
    } else if (this.textEditorCtrl && this.textEditorCtrl.isRunning) {
      this.textEditorCtrl.mouseMove(ev);
    }
  }

  mouseClick(ev) {
    if (this.textEditorCtrl && this.textEditorCtrl.isRunning) {
      this.textEditorCtrl.mouseClick(ev);
      ev.stopPropagation();
    }
  }

  mouseDown(ev) {
    if (this.textResizerCtrl && this.textResizerCtrl.running) {
      this.textResizerCtrl.mouseDown(ev);
    }
    else if (this.textDraggerCtrl && this.textDraggerCtrl.running) {
      this.textDraggerCtrl.mouseDown(ev);
    }
  }
  changed() {
    var textEditor = this.components.find((c) => c.smoName === 'textEditor');
    if (textEditor.editor) {
      this.modifier = textEditor.editor.textGroup;
    } else {
      this.modifier = textEditor.value;
    }

    if (this.wrapCtrl.changeFlag) {
      var boxModel = this.wrapCtrl.getValue() ? SmoScoreText.boxModels.wrap :
        SmoScoreText.boxModels.none;
      this.modifier.boxModel = boxModel;
      if (boxModel ==  SmoScoreText.boxModels.wrap) {
        this.modifier.scaleX = this.modifier.scaleY = 1.0;
        this.modifier.translateX = this.modifier.translateY = 1.0;
        this.modifier.width = this.modifier.logicalBox.width;
        this.modifier.height = this.modifier.logicalBox.height;
      }
    }

    var xcomp = this.components.find((x) => x.smoName === 'x');
    var ycomp = this.components.find((x) => x.smoName === 'y');
    const pos = this.modifier.ul();

    // position can change from drag or by dialog - only update from
    // dialog entries if that changed.
    if (this.xCtrl.changeFlag) {
      this.modifier.offsetX(this.xCtrl.getValue() - pos.x);
    }
    if (this.yCtrl.changeFlag) {
      this.modifier.offsetY(this.yCtrl.getValue() - pos.y);
    }
    if (this.textDraggerCtrl.changeFlag) {
      this.xCtrl.setValue(pos.x);
      this.yCtrl.setValue(pos.y);
    }

    if (this.fontFamilyCtrl.changeFlag) {
      const family = this.fontFamilyCtrl.getValue();
      this.activeScoreText.fontInfo.family = family;
      if (this.textEditorCtrl.editor) {
        this.textEditorCtrl.editor.scoreText.fontInfo.family = family;
      }
    }

    if (this.paginationsComponent.changeFlag && this.textEditorCtrl.editor) {
      this.textEditorCtrl.editor.scoreText.pagination = this.paginationsComponent.getValue();
    }

    if (this.fontSizeCtrl.changeFlag) {
      const fontSize = '' + this.fontSizeCtrl.getValue() + this.fontUnitCtrl.getValue();
      this.activeScoreText.fontInfo.size = fontSize;
      if (this.textEditorCtrl.editor) {
        this.textEditorCtrl.editor.scoreText.fontInfo.size = fontSize;
      }
    }

    // Use layout context because render may have reset svg.
    $(this.layout.context.svg).find('.' + this.modifier.attrs.id).remove();
    this.layout.renderTextGroup(this.modifier);
  }

  constructor(parameters) {
    var tracker = parameters.tracker;
    var layout = tracker.layout.score.layout;

    // If this is a SmoScoreText, promote it to SmoTextGroup.  That is what the other
    // layers expect.  A text group could contain multiple score text objects, and
    // one of them is the active block we are editing.  We need to know what that
    // one is so we can apply the correct fonts etc. to it
    if (!parameters.modifier) {
      var newText =  new SmoScoreText({position:SmoScoreText.positions.custom});
      var newGroup = new SmoTextGroup({blocks:[newText]});
      parameters.modifier = newGroup;
      parameters.activeScoreText = newText;
      SmoUndoable.scoreOp(parameters.layout.score,'addTextGroup',
        parameters.modifier,  parameters.undoBuffer,'Text Menu Command');
      parameters.layout.setRefresh();
    } else if (parameters.modifier.ctor === 'SmoScoreText') {
      var newGroup = new SmoTextGroup({blocks:[parameters.modifier]});
      parameters.activeScoreText = newGroup.textBlocks[0].text;
      parameters.modifier = newGroup;
      tracker.layout.score.removeScoreText(parameters.activeScoreText);
      tracker.layout.score.addTextGroup(newGroup);
    } else if (!parameters.activeScoreText) {
      parameters.activeScoreText = parameters.modifier.textBlocks[0].text;
    }

    var scrollPosition = tracker.scroller.absScroll;
    console.log('text ribbon: scroll y is '+scrollPosition.y);

    scrollPosition.y = scrollPosition.y / (layout.svgScale * layout.zoomScale);
    scrollPosition.x = scrollPosition.x / (layout.svgScale * layout.zoomScale);
    console.log('text ribbon: converted scroll y is '+scrollPosition.y);

    super(SuiTextTransformDialog.dialogElements, {
      id: 'dialog-' + parameters.modifier.attrs.id,
      top: scrollPosition.y + 100,
      left: scrollPosition.x + 100,
      ...parameters
    });

    Vex.Merge(this, parameters);
    // Do we jump right into editing?
    this.undo = parameters.undoBuffer;
    this.modifier.backupParams();
    this.completeNotifier.unbindKeyboardForModal(this);
  }

  _complete() {
    this.tracker.updateMap(); // update the text map
    this.layout.setDirty();
    this.eventSource.unbindMouseDownHandler(this.mouseDownHandler);
    this.eventSource.unbindMouseUpHandler(this.mouseUpHandler);
    this.eventSource.unbindMouseMoveHandler(this.mouseMoveHandler);
    this.eventSource.unbindMouseClickHandler(this.mouseClickHandler);
    $('body').removeClass('showAttributeDialog');
    $('body').removeClass('textEditor');
    this.complete();
  }

  _bindElements() {
    var self = this;
    this.bindKeyboard();
    var dgDom = this.dgDom;
    var fontComp = this.components.find((c) => c.smoName === 'fontFamily');

    fontComp.setValue(this.activeScoreText.fontInfo.family);

    $(dgDom.element).find('.ok-button').off('click').on('click', function (ev) {
      self._complete();
    });

    $(dgDom.element).find('.cancel-button').off('click').on('click', function (ev) {
      self.modifier.restoreParams();
      self._complete();
    });
    $(dgDom.element).find('.remove-button').off('click').on('click', function (ev) {
      SmoUndoable.scoreOp(self.layout.score,'removeTextGroup',self.modifier,self.undo,'remove text from dialog');
      self._complete();
    });
  }
}


// ## SuiTextModifierDialog
// This is a poorly named class, it just allows you to placeText
// dynamic text so it doesn't collide with something.
class SuiDynamicModifierDialog extends SuiDialogBase {
  static get ctor() {
    return 'SuiDynamicModifierDialog';
  }
  get ctor() {
    return SuiDynamicModifierDialog.ctor;
  }
  static get label() {
    SuiDynamicModifierDialog._label = SuiDynamicModifierDialog._label ? SuiDynamicModifierDialog._label :
       'Dynamics Properties';
    return SuiDynamicModifierDialog._label;
  }
  static set label(value) {
    SuiDynamicModifierDialog._label = value;
  }

  static get dialogElements() {
    SuiDynamicModifierDialog._dialogElements = SuiDynamicModifierDialog._dialogElements ? SuiDynamicModifierDialog._dialogElements :
    [{
  smoName: 'yOffsetLine',
  parameterName: 'yOffsetLine',
  defaultValue: 11,
  control: 'SuiRockerComponent',
  label: 'Y Line'
  }, {
  smoName: 'yOffsetPixels',
  parameterName: 'yOffsetPixels',
  defaultValue: 0,
  control: 'SuiRockerComponent',
  label: 'Y Offset Px'
  }, {
  smoName: 'xOffset',
  parameterName: 'yOffset',
  defaultValue: 0,
  control: 'SuiRockerComponent',
  label: 'X Offset'
  }, {
  smoName: 'text',
  parameterName: 'text',
  defaultValue: SmoDynamicText.dynamics.P,
  options: [{
  value: SmoDynamicText.dynamics.P,
  label: 'Piano'
  }, {
  value: SmoDynamicText.dynamics.PP,
  label: 'Pianissimo'
  }, {
  value: SmoDynamicText.dynamics.MP,
  label: 'Mezzo-Piano'
  }, {
  value: SmoDynamicText.dynamics.MF,
  label: 'Mezzo-Forte'
  }, {
  value: SmoDynamicText.dynamics.F,
  label: 'Forte'
  }, {
  value: SmoDynamicText.dynamics.FF,
  label: 'Fortissimo'
  }, {
  value: SmoDynamicText.dynamics.SFZ,
  label: 'Sforzando'
  }
  ],
  control: 'SuiDropdownComponent',
  label: 'Text'
  },
      {staticText: [
        {label: 'Dynamics Properties'}
      ]}
  ];
    return SuiDynamicModifierDialog._dialogElements;
  }
  static createAndDisplay(parameters) {
  var dg = new SuiDynamicModifierDialog(parameters);
  dg.display();
  return dg;
  }

  constructor(parameters) {
  super(SuiDynamicModifierDialog.dialogElements, {
  id: 'dialog-' + parameters.modifier.id,
  top: parameters.modifier.renderedBox.y,
  left: parameters.modifier.renderedBox.x,
      ...parameters
  });
  Vex.Merge(this, parameters);
    this.selection = this.tracker.selections[0];
  this.components.find((x) => {
  return x.parameterName == 'text'
  }).defaultValue = parameters.modifier.text;
  }
  handleRemove() {
  $(this.context.svg).find('g.' + this.modifier.id).remove();
    this.undoBuffer.addBuffer('remove dynamic', 'measure', this.selection.selector, this.selection.measure);
  this.selection.note.removeModifier(this.modifier);
  this.tracker.clearModifierSelections();
  }
  changed() {
  this.modifier.backupOriginal();
  this.components.forEach((component) => {
  this.modifier[component.smoName] = component.getValue();
  });
  this.layout.renderNoteModifierPreview(this.modifier,this.selection);
  }
}

class helpModal {
  constructor() {}
  static createAndDisplay() {
  SmoHelp.displayHelp();
  return htmlHelpers.closeDialogPromise();
  }
}
;// ## measureDialogs.js
// This file contains dialogs that affect all measures at a certain position,
// such as tempo or time signature.

class SuiMeasureDialog extends SuiDialogBase {
    static get attributes() {
      return ['pickupMeasure', 'makePickup', 'padLeft', 'padAllInSystem',
        'measureText','measureTextPosition'];
    }
    static get ctor() {
      return 'SuiMeasureDialog';
    }
    get ctor() {
      return SuiMeasureDialog.ctor;
    }
    static get dialogElements() {
      SuiMeasureDialog._dialogElements = SuiMeasureDialog._dialogElements ? SuiMeasureDialog._dialogElements :
        [
          {
            staticText: [
              { label: 'Measure Properties' }]
          },
          {
          smoName: 'pickupMeasure',
          parameterName: 'pickupMeasure',
          defaultValue: 2048,
          control: 'SuiDropdownComponent',
          label:'Pickup Measure',
          options: [{
            value: 2048,
            label: 'Eighth Note'
          }, {
            value: 4096,
            label: 'Quarter Note'
          }, {
            value: 6144,
            label: 'Dotted Quarter'
          }, {
            value: 8192,
            label: 'Half Note'
          }
        ]
			}, {
  			smoName:'makePickup',
  			parameterName:'makePickup',
  			defaultValue: false,
  			control:'SuiToggleComponent',
  			label:'Convert to Pickup Measure'
  		}, {
        parameterName: 'padLeft',
        smoName: 'padLeft',
        defaultValue: 0,
        control: 'SuiRockerComponent',
        label: 'Pad Left (px)'
      }, {
        parameterName: 'customStretch',
        smoName: 'customStretch',
        defaultValue: 0,
        control: 'SuiRockerComponent',
        label: 'Stretch Contents'
      },{
        parameterName: 'customProportion',
        smoName: 'customProportion',
        defaultValue: SmoMeasure.defaults.customProportion,
        control: 'SuiRockerComponent',
        increment:10,
        label: 'Adjust Proportional Spacing'
      },{
  			smoName:'padAllInSystem',
  			parameterName:'padAllInSystem',
  			defaultValue: false,
  			control:'SuiToggleComponent',
  			label:'Pad all measures in system'
  		},{
				smoName: 'measureText',
				parameterName: 'measureText',
				defaultValue: '',
				control: 'SuiTextInputComponent',
				label:'Measure Text'
  		},{
        smoName: 'measureTextPosition',
        parameterName: 'measureTextPosition',
        defaultValue: SmoMeasureText.positions.above,
        control: 'SuiDropdownComponent',
        label:'Text Position',
        options: [{
                value: SmoMeasureText.positions.left,
                label: 'Left'
            }, {
                value: SmoMeasureText.positions.right,
                label: 'Right'
            }, {
                value:SmoMeasureText.positions.above,
                label: 'Above'
            }, {
                value: SmoMeasureText.positions.below,
                label: 'Below'
            }
            ]
    			}, {
  			smoName:'systemBreak',
  			parameterName:'systemBreak',
  			defaultValue: false,
  			control:'SuiToggleComponent',
  			label: 'System break before this measure'
  		}];

      return SuiMeasureDialog._dialogElements;
    }
    static createAndDisplay(parameters) {
      // SmoUndoable.scoreSelectionOp(score,selection,'addTempo',
      //      new SmoTempoText({bpm:144}),undo,'tempo test 1.3');
      parameters.selection = parameters.tracker.selections[0];
      var dg = new SuiMeasureDialog(parameters);
      dg.display();
      return dg;
    }
  changed() {
    if (this.pickupMeasureCtrl.changeFlag || this.pickupMeasureCtrl.changeFlag) {
      this.layout.unrenderColumn(this.measure);
      SmoUndoable.scoreOp(this.layout.score,'convertToPickupMeasure',this.pickupMeasureCtrl.getValue(),this.undoBuffer,'Create pickup measure');
      this.selection = SmoSelection.measureSelection(this.layout.score,this.selection.selector.staff,this.selection.selector.measure);
      this.tracker.replaceSelectedMeasures();
      this.measure = this.selection.measure;
    }
    if (this.customStretchCtrl.changeFlag) {
      var delta = this.measure.customStretch;
      this.measure.customStretch = this.customStretchCtrl.getValue();
      this.measure.setWidth(this.measure.staffWidth - (delta - this.measure.customStretch));
      this.tracker.replaceSelectedMeasures();
    }
    if (this.customProportionCtrl.changeFlag) {
      this.measure.customProportion = this.customProportionCtrl.getValue();
      this.tracker.replaceSelectedMeasures();
    }
    if (this.systemBreakCtrl.changeFlag) {
      SmoUndoable.scoreSelectionOp(this.layout.score,
          this.tracker.selections[0],'setForceSystemBreak',this.systemBreakCtrl.getValue(),
            this.undoBuffer,'change system break flag');
      this.layout.setRefresh();
    }
    if (this.padLeftCtrl.changeFlag || this.padAllInSystemCtrl.changeFlag) {
      this.layout.unrenderColumn(this.measure);
      var selections = this.padAllInSystemCtrl.getValue() ?
         SmoSelection.measuresInColumn(this.layout.score,this.selection.measure.measureNumber.measureIndex) :
         SmoSelection.measureSelection(this.layout.score,this.selection.selector.staff,this.selection.selector.measure);
      SmoUndoable.padMeasuresLeft(selections,this.padLeftCtrl.getValue(),this.undoBuffer);
      this.tracker.replaceSelectedMeasures();
    }
    if (this.measureTextCtrl.changeFlag || this.measureTextPositionCtrl.changeFlag) {
      var position = this.measureTextPositionCtrl.getValue();
      var text = this.measureTextCtrl.getValue();
      if (text.length == 0) {
        var tms = this.selection.measure.getMeasureText();
        tms.forEach((tm) => {
          SmoUndoable.measureSelectionOp(this.layout.score,
            this.selection,'removeMeasureText',tm,this.undoBuffer,'Remove measure text');
        });
      } else {
        var mt = new SmoMeasureText({position:parseInt(position),text:this.measureTextCtrl.getValue()});
        SmoUndoable.measureSelectionOp(this.layout.score,this.selection,'addMeasureText',mt,this.undoBuffer,'Add measure text');
      }
      this.tracker.replaceSelectedMeasures();
    }
    //
    this._updateConditionals();
  }
  constructor(parameters) {
    if (!parameters.selection) {
        throw new Error('measure dialogmust have measure and selection');
    }

    super(SuiMeasureDialog.dialogElements, {
      id: 'dialog-measure',
      top: parameters.selection.measure.renderedBox.y,
      left: parameters.selection.measure.renderedBox.x,
      label: 'Measure Properties',
  		tracker:parameters.tracker,
      undoBuffer: parameters.undoBuffer,
      eventSource: parameters.eventSource,
      completeNotifier : parameters.completeNotifier,
      layout: parameters.layout
    });
    this.startPromise=parameters.closeMenuPromise;
    if (!this.startPromise) {
      this.startPromise = new Promise((resolve,reject) => {
        resolve();
      });
    }

    this.refresh = false;
    Vex.Merge(this, parameters);

    // The 'modifier' that this dialog acts on is a measure.
    this.measure = this.selection.measure;
    this.modifier = this.measure;
  }
  display() {
    super.display();
    var self=this;
    function getKeys() {
        self.completeNotifier.unbindKeyboardForModal(self);
    }
    this.startPromise.then(getKeys);
  }
  _updateConditionals() {
    if (this.padLeftCtrl.getValue() != 0 || this.padLeftCtrl.changeFlag) {
      $('.attributeDialog .attributeModal').addClass('pad-left-select');
    } else {
      $('.attributeDialog .attributeModal').removeClass('pad-left-select');
    }

    if (this.pickupMeasureCtrl.getValue()) {
      $('.attributeDialog .attributeModal').addClass('pickup-select');
    } else {
      $('.attributeDialog .attributeModal').removeClass('pickup-select');
    }
    var str = this.measureTextCtrl.getValue();
    if (str && str.length) {
      $('.attributeDialog .attributeModal').addClass('measure-text-set');
    } else {
      $('.attributeDialog .attributeModal').removeClass('measure-text-set');
    }
  }
  populateInitial() {
    this.padLeftCtrl.setValue(this.measure.padLeft);
    this.originalStretch = this.measure.customStretch;
    this.originalProportion = this.measure.customProportion;
    var isPickup = this.measure.isPickup();
    this.customStretchCtrl.setValue(this.measure.customStretch);
    this.customProportionCtrl.setValue(this.measure.customProportion);
    this.pickupMeasureCtrl.setValue(isPickup);
    if (isPickup) {
      this.pickupMeasureCtrl.setValue(this.measure.getTicksFromVoice())
    }

    var isSystemBreak = this.measure.getForceSystemBreak();
    this.systemBreakCtrl.setValue(isSystemBreak);
    this._updateConditionals();

    // TODO: handle multiples (above/below)
    var texts = this.measure.getMeasureText();
    if (texts.length) {
      this.measureTextCtrl.setValue(texts[0].text);
      this.measureTextPositionCtrl.setValue(texts[0].position);
    }
  }
  _cancelEdits() {
    this.measure.customStretch = this.originalStretch;
    this.measure.customProportion = this.originalProportion;
    this.layout.setRefresh();
  }
  _bindElements() {
    this._bindComponentNames();
		var self = this;
		var dgDom = this.dgDom;
    this.bindKeyboard();
    this._bindComponentNames();
    this.populateInitial();

  	$(dgDom.element).find('.ok-button').off('click').on('click', function (ev) {
      self.tracker.replaceSelectedMeasures();
  		self.complete();
  	});

		$(dgDom.element).find('.cancel-button').off('click').on('click', function (ev) {
      self._cancelEdits();
			self.complete();
		});
		$(dgDom.element).find('.remove-button').off('click').on('click', function (ev) {
			self.complete();
		});
	}
}

class SuiInstrumentDialog extends SuiDialogBase {
  static get ctor() {
    return 'SuiInstrumentDialog';
  }
  get ctor() {
    return SuiTimeSignatureDialog.ctor;
  }
  static get applyTo() {
    return {
      score: 0,selected:1, remaining: 3
    };
  }
  static get dialogElements() {
    SuiInstrumentDialog._dialogElements = SuiInstrumentDialog._dialogElements ? SuiInstrumentDialog._dialogElements :
    [
      {
        staticText: [
          {label: 'Instrument Properties'}
        ]
      },
      {
        smoName: 'transposeIndex',
        parameterName: 'transposeIndex',
        defaultValue: 0,
        control: 'SuiRockerComponent',
        label:'Transpose Index (1/2 steps)',
      },{
        smoName: 'applyTo',
        parameterName: 'applyTo',
        defaultValue: SuiInstrumentDialog.applyTo.score,
        control: 'SuiDropdownComponent',
        label:'Apply To',
        options: [{
            value: SuiInstrumentDialog.applyTo.score,
            label: 'Score'
          }, {
            value: SuiInstrumentDialog.applyTo.selected,
            label: 'Selected Measures'
          }, {
            value: SuiInstrumentDialog.applyTo.remaining,
            label: 'Remaining Measures'
          }
        ]
			}
    ];
    return SuiInstrumentDialog._dialogElements;
  }
  static createAndDisplay(parameters) {
    /* SuiLyricDialog.createAndDisplay(
      {
        buttonElement:this.buttonElement,
        buttonData:this.buttonData,
        completeNotifier:this.controller,
        tracker: this.tracker,
        layout:this.layout,
        undoBuffer:this.editor.undoBuffer,
        eventSource:this.eventSource,
        editor:this.editor,
        parser:SmoLyric.parsers.lyric
      }
    );  */
    var db = new SuiInstrumentDialog(parameters);
    db.display();
    return db;
  }
  display() {
    $('body').addClass('showAttributeDialog');
    this.components.forEach((component) => {
        component.bind();
    });
    this._bindComponentNames();
    this._bindElements();
    this.position(this.measure.renderedBox);
    this.tracker.scroller.scrollVisibleBox(
      svgHelpers.smoBox($(this.dgDom.element)[0].getBoundingClientRect())
    );


    var cb = function (x, y) {}
    htmlHelpers.draggable({
      parent: $(this.dgDom.element).find('.attributeModal'),
      handle: $(this.dgDom.element).find('.jsDbMove'),
      animateDiv:'.draganime',
      cb: cb,
      moveParent: true
    });
  }
  populateInitial() {
    var ix = this.measure.transposeIndex;
    this.transposeIndexCtrl.setValue(ix);
  }

  changed() {
    var staffIx = this.measure.measureNumber.staffId;

    var xpose = this.transposeIndexCtrl.getValue();
    var selections = [];
    for (var i = 0;i < this.score.staves[staffIx].measures.length;++i) {
      selections.push(SmoSelection.measureSelection(this.score, staffIx, i));
    }
    SmoUndoable.changeInstrument(this.score,
      {
        instrumentName: 'Treble Instrument',
        keyOffset: xpose,
        clef: this.measure.clef
      },
      selections,
      this.undoBuffer);

    this.layout.setRefresh();
  }

  constructor(parameters) {
    var selection = parameters.tracker.selections[0];
    var measure = selection.measure;

    parameters = {selection:selection,measure:measure,...parameters};

    super(SuiInstrumentDialog.dialogElements, {
      id: 'time-signature-measure',
      top: measure.renderedBox.y,
      left: measure.renderedBox.x,
      ...parameters
    });
    this.measure = measure;
    this.score = this.editor.score;
    this.refresh = false;
    this.startPromise=parameters.closeMenuPromise;
    Vex.Merge(this, parameters);
  }
  _bindElements() {
    var self = this;
    var dgDom = this.dgDom;
    this.populateInitial();

   $(dgDom.element).find('.ok-button').off('click').on('click', function (ev) {
     self.complete();
   });

   $(dgDom.element).find('.cancel-button').off('click').on('click', function (ev) {
     self.complete();
   });
   $(dgDom.element).find('.remove-button').off('click').on('click', function (ev) {
     self.complete();
   });
  }

}


class SuiTimeSignatureDialog extends SuiDialogBase {
  static get ctor() {
    return 'SuiTimeSignatureDialog';
  }
  get ctor() {
    return SuiTimeSignatureDialog.ctor;
  }

  static get dialogElements() {
    SuiTimeSignatureDialog._dialogElements = SuiTimeSignatureDialog._dialogElements ? SuiTimeSignatureDialog._dialogElements :
      [
        { staticText: [
            { label: 'Custom Time Signature' }
          ]
        },
        {
          smoName: 'numerator',
          parameterName: 'numerator',
          defaultValue: 3,
          control: 'SuiRockerComponent',
          label:'Beats/Measure',
        },
		    {
          parameterName: 'denominator',
          smoName: 'denominator',
          defaultValue: 8,
          dataType:'int',
          control: 'SuiDropdownComponent',
          label: 'Beat Value',
          options: [{
            value: 8,
            label: '8',
          }, {
            value: 4,
            label: '4'
          }, {
            value: 2,
            label: '2'
          }
        ]
      }
    ];

    return SuiTimeSignatureDialog._dialogElements;
  }
  populateInitial() {
     var num,den;
     var nd = this.measure.timeSignature.split('/');
     var num = parseInt(nd[0]);
     var den = parseInt(nd[1]);

     this.numeratorCtrl.setValue(num);
     this.denominatorCtrl.setValue(den);
  }

  changed() {
    // no dynamic change for time  signatures
  }
 static createAndDisplay(params) {
     // SmoUndoable.scoreSelectionOp(score,selection,'addTempo',
     //      new SmoTempoText({bpm:144}),undo,'tempo test 1.3');

     var dg = new SuiTimeSignatureDialog({
        selections: params.tracker.selections,
        undoBuffer: params.undoBuffer,
        layout: params.tracker.layout,
        completeNotifier :params.completeNotifier,
        closeMenuPromise:params.closeMenuPromise,
        tracker: params.tracker
      });
      dg.display();
      return dg;
   }
   changeTimeSignature() {
    var ts = '' + this.numeratorCtrl.getValue() + '/'+this.denominatorCtrl.getValue();
    SmoUndoable.multiSelectionOperation(this.tracker.layout.score,
      this.tracker.selections,
      'setTimeSignature',ts,this.undoBuffer);
      this.tracker.replaceSelectedMeasures();
   }
   _bindElements() {
     var self = this;
	   var dgDom = this.dgDom;
     this.numeratorCtrl = this.components.find((comp) => {return comp.smoName == 'numerator';});
     this.denominatorCtrl = this.components.find((comp) => {return comp.smoName == 'denominator';});
     this.populateInitial();

		$(dgDom.element).find('.ok-button').off('click').on('click', function (ev) {
          self.changeTimeSignature();
			self.complete();
		});

 		$(dgDom.element).find('.cancel-button').off('click').on('click', function (ev) {
 			self.complete();
 		});
 		$(dgDom.element).find('.remove-button').off('click').on('click', function (ev) {
 			self.complete();
 		});
   }
   display() {
     $('body').addClass('showAttributeDialog');
     this.components.forEach((component) => {
         component.bind();
     });
     this._bindElements();
     this.position(this.measure.renderedBox);
     this.tracker.scroller.scrollVisibleBox(
         svgHelpers.smoBox($(this.dgDom.element)[0].getBoundingClientRect())
     );


     var cb = function (x, y) {}
     htmlHelpers.draggable({
         parent: $(this.dgDom.element).find('.attributeModal'),
         handle: $(this.dgDom.element).find('.jsDbMove'),
          animateDiv:'.draganime',
         cb: cb,
         moveParent: true
     });

     var self=this;
     function getKeys() {
         self.completeNotifier.unbindKeyboardForModal(self);
     }
     this.startPromise.then(getKeys);
   }
   constructor(parameters) {
       var measure = parameters.selections[0].measure;

       super(SuiTimeSignatureDialog.dialogElements, {
           id: 'time-signature-measure',
           top: measure.renderedBox.y,
           left: measure.renderedBox.x,
           label: 'Custom Time Signature',
			 tracker:parameters.tracker,
     undoBuffer: parameters.undoBuffer,
     eventSource: parameters.eventSource,
     completeNotifier : parameters.completeNotifier,
     layout: parameters.layout

       });
       this.measure = measure;
       this.refresh = false;
       this.startPromise=parameters.closeMenuPromise;
       Vex.Merge(this, parameters);
   }
 }


// ## SuiTempoDialog
// Allow user to choose a tempo or tempo change.
class SuiTempoDialog extends SuiDialogBase {
  static get ctor() {
    return 'SuiTempoDialog';
  }
  get ctor() {
    return SuiTempoDialog.ctor;
  }
  static get attributes() {
    return ['tempoMode', 'bpm', 'beatDuration', 'tempoText','yOffset'];
  }
  static get dialogElements() {
    SuiTempoDialog._dialogElements = SuiTempoDialog._dialogElements ? SuiTempoDialog._dialogElements :
     [
       { staticText: [
         { label: 'Tempo Properties'}
       ]
       },
       {
        smoName: 'tempoMode',
        parameterName: 'tempoMode',
        defaultValue: SmoTempoText.tempoModes.durationMode,
        control: 'SuiDropdownComponent',
        label:'Tempo Mode',
        options: [{
            value: 'duration',
            label: 'Duration (Beats/Minute)'
          }, {
            value: 'text',
            label: 'Tempo Text'
          }, {
            value: 'custom',
            label: 'Specify text and duration'
          }
        ]
      },
      {
        parameterName: 'bpm',
        smoName: 'bpm',
        defaultValue: 120,
        control: 'SuiRockerComponent',
        label: 'Notes/Minute'
      },
      {
        parameterName: 'duration',
        smoName: 'beatDuration',
        defaultValue: 4096,
        dataType:'int',
        control: 'SuiDropdownComponent',
        label: 'Unit for Beat',
        options: [{
        		value: 4096,
        		label: 'Quarter Note',
        	}, {
        		value: 2048,
        		label: '1/8 note'
        	}, {
        		value: 6144,
        		label: 'Dotted 1/4 note'
        	}, {
        		value: 8192,
        		label: '1/2 note'
        	}
        ]
      },
      {
        smoName: 'tempoText',
        parameterName: 'tempoText',
        defaultValue: SmoTempoText.tempoTexts.allegro,
        control: 'SuiDropdownComponent',
        label:'Tempo Text',
        options: [{
            value: SmoTempoText.tempoTexts.larghissimo,
            label: 'Larghissimo'
          }, {
            value: SmoTempoText.tempoTexts.grave,
            label: 'Grave'
          }, {
            value: SmoTempoText.tempoTexts.lento,
            label: 'Lento'
          }, {
            value: SmoTempoText.tempoTexts.largo,
            label: 'Largo'
          }, {
            value: SmoTempoText.tempoTexts.larghetto,
            label: 'Larghetto'
          }, {
            value: SmoTempoText.tempoTexts.adagio,
            label: 'Adagio'
          }, {
            value: SmoTempoText.tempoTexts.adagietto,
            label: 'Adagietto'
          }, {
            value: SmoTempoText.tempoTexts.andante_moderato,
            label: 'Andante moderato'
          }, {
            value: SmoTempoText.tempoTexts.andante,
            label: 'Andante'
          }, {
            value: SmoTempoText.tempoTexts.andantino,
            label: 'Andantino'
          }, {
            value: SmoTempoText.tempoTexts.moderator,
            label: 'Moderato'
          }, {
            value: SmoTempoText.tempoTexts.allegretto,
            label: 'Allegretto',
          } ,{
            value: SmoTempoText.tempoTexts.allegro,
            label: 'Allegro'
          }, {
            value: SmoTempoText.tempoTexts.vivace,
            label: 'Vivace'
          }, {
            value: SmoTempoText.tempoTexts.presto,
            label: 'Presto'
          }, {
            value: SmoTempoText.tempoTexts.prestissimo,
            label: 'Prestissimo'
          }
        ]
      }, {
        smoName:'applyToAll',
        parameterName:'applyToAll',
        defaultValue: false,
        control:'SuiToggleComponent',
        label:'Apply to all future measures?'
      },{
        smoName: 'display',
        parameterName: 'display',
        defaultValue: true,
        control: 'SuiToggleComponent',
        label: 'Display Tempo'
      }, {
        smoName: 'yOffset',
        parameterName: 'yOffset',
        defaultValue: 0,
        control: 'SuiRockerComponent',
        label: 'Y Offset'
      }
    ];
    return SuiTempoDialog._dialogElements;
  }
  static createAndDisplay(parameters) {
    parameters.measures = SmoSelection.getMeasureList(parameters.tracker.selections)
       .map((sel) => sel.measure);
    var measure = parameters.measures[0];

    // All measures have a default tempo, but it is not explicitly set unless it is
    // non-default
    parameters.modifier = measure.getTempo();
    if (!parameters.modifier) {
        parameters.modifier = new SmoTempoText();
        measure.addTempo(parameters.modifier);
    }
    if (!parameters.modifier.renderedBox) {
        parameters.modifier.renderedBox = svgHelpers.copyBox(measure.renderedBox);
    }
    var dg = new SuiTempoDialog(parameters);
    dg.display();
    return dg;
  }
    constructor(parameters) {
        if (!parameters.modifier || !parameters.measures) {
            throw new Error('modifier attribute dialog must have modifier and selection');
        }

        super(SuiTempoDialog.dialogElements, {
            id: 'dialog-tempo',
            top: parameters.modifier.renderedBox.y,
            left: parameters.modifier.renderedBox.x,
            tracker:parameters.tracker,
            undoBuffer: parameters.undoBuffer,
            eventSource: parameters.eventSource,
            completeNotifier : parameters.completeNotifier,
            layout: parameters.layout
        });
        this.refresh = false;
        Vex.Merge(this, parameters);
    }
    populateInitial() {
        SmoTempoText.attributes.forEach((attr) => {
            var comp = this.components.find((cc) => {
                return cc.smoName == attr;
            });
            if (comp) {
                comp.setValue(this.modifier[attr]);
            }
        });
		this._updateModeClass();
    }
	_updateModeClass() {
        if (this.modifier.tempoMode == SmoTempoText.tempoModes.textMode) {
			$('.attributeModal').addClass('tempoTextMode');
			$('.attributeModal').removeClass('tempoDurationMode');
        } else if (this.modifier.tempoMode == SmoTempoText.tempoModes.durationMode) {
			$('.attributeModal').addClass('tempoDurationMode');
			$('.attributeModal').removeClass('tempoTextMode');
		} else {
			$('.attributeModal').removeClass('tempoDurationMode');
			$('.attributeModal').removeClass('tempoTextMode');
		}
	}
    changed() {
        this.components.forEach((component) => {
			if (SmoTempoText.attributes.indexOf(component.smoName) >= 0) {
                this.modifier[component.smoName] = component.getValue();
			}
        });
        if (this.modifier.tempoMode == SmoTempoText.tempoModes.textMode) {
            this.modifier.bpm = SmoTempoText.bpmFromText[this.modifier.tempoText];
        }
		this._updateModeClass();
        this.refresh = true;
    }
    // ### handleFuture
    // Update other measures in selection, or all future measures if the user chose that.
    handleFuture() {
        var fc = this.components.find((comp) => {return comp.smoName == 'applyToAll'});
        var toModify = [];
        if (fc.getValue()) {
            this.layout.score.staves.forEach((staff) => {
                var toAdd = staff.measures.filter((mm) => {
                    return mm.measureNumber.measureIndex >= this.measures[0].measureNumber.measureIndex;
                });
                toModify = toModify.concat(toAdd);
            });
        } else {
            this.measures.forEach((measure) => {
                this.layout.score.staves.forEach((staff) => {
                    toModify.push(staff.measures[measure.measureNumber.measureIndex]);
                });
            });
        }
        toModify.forEach((measure) => {
            measure.changed = true;
            var tempo = SmoMeasureModifierBase.deserialize(this.modifier.serialize());
            tempo.attrs.id = VF.Element.newID();
            measure.addTempo(tempo);
        });
        this.tracker.replaceSelectedMeasures();
    }
    // ### handleRemove
    // Removing a tempo change is like changing the measure to the previous measure's tempo.
    // If this is the first measure, use the default value.
    handleRemove() {
        if (this.measures[0].measureNumber.measureIndex > 0) {
            var target = this.measures[0].measureNumber.measureIndex - 1;
            this.modifier = this.layout.score.staves[0].measures[target].getTempo();
            this.handleFuture();
        } else {
            this.modifier = new SmoTempoText();
        }
        this.handleFuture();
    }
    // ### _backup
    // Backup the score before changing tempo which affects score.
    _backup() {
        if (this.refresh) {
            SmoUndoable.noop(this.layout.score,this.undoBuffer,'Tempo change');
            this.layout.setDirty();
        }
    }
    // ### Populate the initial values and bind to the buttons.
    _bindElements() {
        var self = this;
        this.populateInitial();
		var dgDom = this.dgDom;
        // Create promise to release the keyboard when dialog is closed
        this.closeDialogPromise = new Promise((resolve) => {
            $(dgDom.element).find('.cancel-button').remove();
            $(dgDom.element).find('.ok-button').off('click').on('click', function (ev) {
                self._backup();
                self.handleFuture();
                self.complete();
                resolve();
            });
            $(dgDom.element).find('.remove-button').off('click').on('click', function (ev) {
                self._backup();
                self.handleRemove();
                self.complete();
                resolve();
            });
        });
        this.completeNotifier.unbindKeyboardForModal(this);
    }
}
;// # dbComponents - components of modal dialogs.

class SuiComponentBase {
    constructor() {
        this.changeFlag = false;
    }
    handleChanged() {
        this.changeFlag = true;
        this.dialog.changed();
        this.changeFlag = false;
    }
}
// ## SuiRockerComponent
// A numeric input box with +- buttons.   Adjustable type and scale
class SuiRockerComponent extends SuiComponentBase {
	static get dataTypes() {
		return ['int','float','percent'];
	}
	static get increments() {
		return {'int':1,'float':0.1,'percent':10}
	}
	static get parsers() {
		return {'int':'_getIntValue','float':'_getFloatValue','percent':'_getPercentValue'};
	}
    constructor(dialog, parameter) {
        super();
        smoSerialize.filteredMerge(
            ['parameterName', 'smoName', 'defaultValue', 'control', 'label','increment','type'], parameter, this);
        if (!this.defaultValue) {
            this.defaultValue = 0;
        }
		if (!this.type) {
			this.type='int';
		}
		if (!this.increment) {
		    this.increment = SuiRockerComponent.increments[this.type];
		}
		if (SuiRockerComponent.dataTypes.indexOf(this.type) < 0) {
			throw new Error('dialog element invalid type '+this.type);
		}

        this.id = this.id ? this.id : '';

		if (this.type === 'percent') {
			this.defaultValue = 100*this.defaultValue;
		}
		this.parser=SuiRockerComponent.parsers[this.type];
        this.dialog = dialog;
    }

    get html() {
        var b = htmlHelpers.buildDom;
        var id = this.parameterId;
        var r = b('div').classes('rockerControl smoControl').attr('id', id).attr('data-param', this.parameterName)
            .append(
                b('button').classes('increment').append(
                    b('span').classes('icon icon-circle-up'))).append(
                b('button').classes('decrement').append(
                    b('span').classes('icon icon-circle-down'))).append(
                b('input').attr('type', 'text').classes('rockerInput')
                .attr('id', id + '-input')).append(
                b('label').attr('for', id + '-input').text(this.label));
        return r;
    }

    get parameterId() {
        return this.dialog.id + '-' + this.parameterName;
    }
    handleChange() {
        this.changeFlag = true;
        this.dialog.changed();
        this.changeFlag = false;
    }

    bind() {
        var dialog = this.dialog;
        var pid = this.parameterId;
        var input = this._getInputElement();
        this.setValue(this.defaultValue);
        var self = this;
        $('#' + pid).find('button.increment').off('click').on('click',
            function (ev) {
            var val = self[self.parser]();
			if (self.type === 'percent') {
			    val = 100*val;
     		}
            $(input).val(val + self.increment);
            self.handleChanged();
        });
        $('#' + pid).find('button.decrement').off('click').on('click',
            function (ev) {
            var val = self[self.parser]();
			if (self.type === 'percent') {
			    val = 100*val;
     		}
            $(input).val(val - self.increment);
            self.handleChanged();
        });
        $(input).off('blur').on('blur',
            function (ev) {
            self.handleChanged();
        });
    }

    _getInputElement() {
        var pid = this.parameterId;
        return $(this.dialog.dgDom.element).find('#' + pid).find('input');
    }
    _getIntValue() {
        var pid = this.parameterId;
        var val = parseInt(this._getInputElement().val());
        val = isNaN(val) ? 0 : val;
        return val;
    }
	 _getFloatValue() {
        var pid = this.parameterId;
        var val = parseFloat(this._getInputElement().val());
        val = isNaN(val) ? 1.0 : val;
        return val;
    }
	_getPercentValue() {
        var pid = this.parameterId;
        var val = parseFloat(this._getInputElement().val());
        val = isNaN(val) ? 1 : val;
        return val/100;
	}
    _setIntValue(val) {
        this._getInputElement().val(val);
    }
    setValue(value) {
		if (this.type === 'percent') {
			value = value * 100;
		}
        this._setIntValue(value);
    }
    getValue() {
        return this[this.parser]();
    }
}




class SuiLyricEditComponent extends SuiComponentBase {
  constructor(dialog,parameter) {
    super();
    smoSerialize.filteredMerge(
        ['parameterName', 'smoName', 'defaultValue', 'control', 'label'], parameter, this);
    if (!this.defaultValue) {
        this.defaultValue = 0;
    }
    this._verse = 0;

    this.dialog = dialog;
    this.selection = null;
    this.value='';
  }

  set verse(val) {
    this._verse = val;
  }

  get verse() {
    return this._verse;
  }

  get html() {
    var b = htmlHelpers.buildDom;
    var id = this.parameterId;
    var r = b('div').classes('cbLyricEdit smoControl').attr('id', this.parameterId).attr('data-param', this.parameterName)
      .append(b('div').classes('toggleEdit')
        .append(b('button').classes('toggleTextEdit')
          .attr('id', id + '-toggleInput').append(
          b('span').classes('icon icon-pencil'))).append(
          b('label').attr('for', id + '-toggleInput').text(this.label)))

      .append(b('div').classes('controlDiv')
        .append(b('span')
          .append(
            b('button').attr('id', id + '-left').classes('icon-arrow-left buttonComponent')))
        .append(b('span')
          .append(
            b('button').attr('id', id + '-right').classes('icon-arrow-right buttonComponent')))
        .append(b('span')
          .append(
            b('button').attr('id', id + '-remove').classes('icon-cross buttonComponent')))
      );
    return r;
  }
  get parameterId() {
      return this.dialog.id + '-' + this.parameterName;
  }

  // If the user pressed esc., force the end of the session
  endSessionDom() {
    var elementDom = $('#'+this.parameterId);
    $(elementDom).find('label').text('Edit'); // TODO: i18n this and also specific text
    $(this.editorButton).find('span.icon').removeClass('icon-checkmark').addClass('icon-pencil');
    $('body').removeClass('text-edit');
    $('div.textEdit').addClass('hide');
  }
  getValue() {
    return this.value;
  }
  _getInputElement() {
    var pid = this.parameterId;
    return $(this.dialog.dgDom.element).find('#' + pid).find('button.toggleTextEdit');
  }

  notifySelectionChanged(selection) {
    if (selection) {
      layoutDebug.addTextDebug('SuiLyricEditComponent: lyric notification for ' + selection.note.attrs.id);
    } else {
      layoutDebug.addTextDebug('SuiLyricEditComponent: no selection');
    }
    if (this.selection == null || SmoSelector.neq(selection.selector,this.selection.selector)) {
      this.selection = selection;
      this.handleChanged();
    }
    if (!this.editor.isRunning) {
      this.endSessionDom();
    }
  }

  moveSelectionRight() {
    this.editor.moveSelectionRight();
  }
  moveSelectionLeft() {
    this.editor.moveSelectionLeft();
  }
  removeText() {
    this.editor.removeText();
  }

  _startEditorDom() {
    var elementDom = $('#'+this.parameterId);
    var button = $(elementDom).find('button.toggleTextEdit');
    layoutDebug.addTextDebug('SuiLyricEditComponent: create editor for ' + this.tracker.selections[0].note.attrs.id);
    $(button).find('span.icon').removeClass('icon-pencil').addClass('icon-checkmark');
    $(elementDom).find('label').text('Done Editing Lyrics');
  }
  get editorButton() {
    var elementDom = $('#'+this.parameterId);
    var button = $(elementDom).find('button.toggleTextEdit');
    return button;
  }
  toggleSessionButton() {
    this.handleChanged();
    if (!this.editor.isRunning) {
      this.editor.verse = this.verse;
      this._startEditorDom();
      layoutDebug.addTextDebug('SuiLyricEditComponent: restarting button');
     } else {
       this.endSessionDom();
       layoutDebug.addTextDebug('SuiLyricEditComponent: stopping editor button');
     }
     this.editor.toggleSessionStateEvent();
  }
  getYOffset() {
    if (this.editor) {
      return this.editor.getYOffset();
    }
    return 0;
  }

  setYOffset(val) {
    if (this.editor) {
      this.editor.setYOffset(val);
    }
  }
  startEditSession(selection) {
    var self=this;
    layoutDebug.addTextDebug('SuiLyricEditComponent: create editor request');
    this._startEditorDom();
    this.editor = new noteTextEditSession(this,this.tracker,this.verse,this.selection,this.eventSource,this.dialog.parser);
    this.editor.startEditingSession();
    this._bind();
  }
  bind() {
    this.tracker = this.dialog.tracker;
    this.selection = this.dialog.selection;
    this.controller = this.dialog.controller; // do we need this
  }

  _bind() {
    var self=this;
    $('#'+this.parameterId+'-left').off('click').on('click',function() {
      self.moveSelectionLeft();
    });
    $('#'+this.parameterId+'-right').off('click').on('click',function() {
      self.moveSelectionRight();
    });
    $('#'+this.parameterId+'-remove').off('click').on('click',function() {
      self.removeText();
    });
    $(this.editorButton).off('click').on('click',function() {
      self.toggleSessionButton();
    });
  }
}

// ## SuiTextInputComponent
// Just get text from an input, such as a filename.
class SuiTextInputComponent extends SuiComponentBase {
    constructor(dialog, parameter) {
        super();
        smoSerialize.filteredMerge(
            ['parameterName', 'smoName', 'defaultValue', 'control', 'label'], parameter, this);
        if (!this.defaultValue) {
            this.defaultValue = 0;
        }
        this.dialog = dialog;
        this.value='';
    }
    get parameterId() {
        return this.dialog.id + '-' + this.parameterName;
    }
    get html() {
        var b = htmlHelpers.buildDom;
        var id = this.parameterId;
        var r = b('div').classes('text-input smoControl').attr('id', this.parameterId).attr('data-param', this.parameterName)
            .append(b('input').attr('type', 'text').classes('file-name')
                .attr('id', id + '-input')).append(
                b('label').attr('for', id + '-input').text(this.label));
        return r;
    }

    getValue() {
        return this.value;
    }
    setValue(val) {
        this.value = val;
        $('#'+this.parameterId).find('input').val(val);
    }
    bind() {
        var self=this;
        $('#'+this.parameterId).find('input').off('change').on('change',function(e) {
            self.value = $(this).val();
            self.handleChanged();
        });
    }
}

// ## SuiFileDownloadComponent
// Download a test file using the file input.
class SuiFileDownloadComponent extends SuiComponentBase {
    constructor(dialog, parameter) {
        super();
        smoSerialize.filteredMerge(
            ['parameterName', 'smoName', 'defaultValue', 'control', 'label'], parameter, this);
        if (!this.defaultValue) {
            this.defaultValue = 0;
        }
        this.dialog = dialog;
        this.value='';
    }
    get parameterId() {
        return this.dialog.id + '-' + this.parameterName;
    }
    get html() {
        var b = htmlHelpers.buildDom;
        var id = this.parameterId;
        var r = b('div').classes('select-file').attr('id', this.parameterId).attr('data-param', this.parameterName)
            .append(b('input').attr('type', 'file').classes('file-button')
                .attr('id', id + '-input')).append(
                b('label').attr('for', id + '-input').text(this.label));
        return r;
    }

    _handleUploadedFiles(evt)  {
        var reader = new FileReader();
        var self=this;
        reader.onload = function(file) {
            self.value = file.target.result;
            self.handleChanged();
        }
        reader.readAsText(evt.target.files[0]);
    }
    getValue() {
        return this.value;
    }
    bind() {
        var self=this;
        $('#'+this.parameterId).find('input').off('change').on('change',function(e) {
            self._handleUploadedFiles(e);
        });
    }

}

// ## SuiToggleComponent
// Simple on/off behavior
class SuiToggleComponent extends SuiComponentBase {
    constructor(dialog, parameter) {
        super();
        smoSerialize.filteredMerge(
            ['parameterName', 'smoName', 'defaultValue', 'control', 'label'], parameter, this);
        if (!this.defaultValue) {
            this.defaultValue = 0;
        }
        this.dialog = dialog;
    }
    get html() {
        var b = htmlHelpers.buildDom;
        var id = this.parameterId;
        var r = b('div').classes('toggleControl smoControl').attr('id', this.parameterId).attr('data-param', this.parameterName)
            .append(b('input').attr('type', 'checkbox').classes('toggleInput')
                .attr('id', id + '-input')).append(
                b('label').attr('for', id + '-input').text(this.label));
        return r;
    }
    _getInputElement() {
        var pid = this.parameterId;
        return $(this.dialog.dgDom.element).find('#' + pid).find('input');
    }
    get parameterId() {
        return this.dialog.id + '-' + this.parameterName;
    }

    setValue(value) {
        $(this._getInputElement()).prop('checked', value);
    }
    getValue() {
        return $(this._getInputElement()).prop('checked');
    }

    bind() {
        var dialog = this.dialog;
        var pid = this.parameterId;
        var input = this._getInputElement();
        this.setValue(this.defaultValue);
        var self = this;
        $(input).off('change').on('change',
            function (ev) {
            self.handleChanged();
        });
    }
}

// ## SuiToggleComponent
// Simple on/off behavior
class SuiButtonComponent extends SuiComponentBase {
    constructor(dialog, parameter) {
        super();
        smoSerialize.filteredMerge(
            ['parameterName', 'smoName', 'defaultValue', 'control', 'label','additionalClasses'], parameter, this);
        if (!this.defaultValue) {
            this.defaultValue = 0;
        }
        this.dialog = dialog;
    }
    get html() {
        var b = htmlHelpers.buildDom;
        var id = this.parameterId;
        var classNames = this['additionalClasses'] ? this['additionalClasses'] + ' buttonComponent' : 'buttonComponent';
        var r = b('div').classes('buttonControl smoControl').attr('id', this.parameterId).attr('data-param', this.parameterName)
            .append(b('button').attr('type', 'button').classes(classNames)
                .attr('id', id + '-input')).append(
                b('label').attr('for', id + '-input').text(this.label));
        return r;
    }
    _getInputElement() {
        var pid = this.parameterId;
        return $(this.dialog.dgDom.element).find('#' + pid).find('button');
    }
    get parameterId() {
        return this.dialog.id + '-' + this.parameterName;
    }

    setValue(value) {
        return;
    }
    getValue() {
        return null;
    }

    bind() {
        var dialog = this.dialog;
        var pid = this.parameterId;
        var input = this._getInputElement();
        this.setValue(this.defaultValue);
        var self = this;
        $(input).off('click').on('click',
            function (ev) {
            self.handleChanged();
        });
    }
}

class SuiDropdownComponent  extends SuiComponentBase{
    constructor(dialog, parameter) {
        super();
        smoSerialize.filteredMerge(
            ['parameterName', 'smoName', 'defaultValue', 'options', 'control', 'label','dataType'], parameter, this);
        if (!this.defaultValue) {
            this.defaultValue = 0;
        }
		if (!this.dataType) {
			this.dataType = 'string';
		}

        this.dialog = dialog;
    }

    get parameterId() {
        return this.dialog.id + '-' + this.parameterName;
    }

    get html() {
        var b = htmlHelpers.buildDom;
        var id = this.parameterId;
        var r = b('div').classes('dropdownControl smoControl').attr('id', id).attr('data-param', this.parameterName);
        var s = b('select');
        this.options.forEach((option) => {
            s.append(
                b('option').attr('value', option.value).text(option.label));
        });
        r.append(s).append(
            b('label').attr('for', id + '-input').text(this.label));

        return r;
    }

    _getInputElement() {
        var pid = this.parameterId;
        return $(this.dialog.dgDom.element).find('#' + pid).find('select');
    }
    getValue() {
        var input = this._getInputElement();
        var option = this._getInputElement().find('option:selected');
		var val = $(option).val();
		val = (this.dataType.toLowerCase() === 'int') ?	parseInt(val) : val;
		val = (this.dataType.toLowerCase() === 'float') ?	parseFloat(val) : val;
        return val;
    }
    setValue(value) {
        var input = this._getInputElement();
        $(input).val(value);
    }

    bind() {
        var input = this._getInputElement();
        this.setValue(this.defaultValue);
        var self = this;
        $(input).off('change').on('change',
            function (ev) {
            self.handleChanged();
        });
    }
}
;
// ## This has the text editing dialog components.  Unlike components that are
// actual dialog controls, these actually run a text editing session of some kind.
//
// The heirarchy of text editing objects goes:
// dialog -> component -> session -> editor
//
// ### editor
//  handles low-level events and renders the preview using one
// of the text layout objects.
//
// ### session creates and destroys editors, e.g. for lyrics that have a Different
// editor instance for each note.
//
// ### component
// is defined in the dialog, and creates/destroys the session based on input from
// the dialog
//
// ### dialog
// manages the coponent session, as well as other components of the text like font etc.
//
// ## SuiTextInPlace
// Edit the text in an SVG element, in the same scale etc. as the text in the score SVG DOM.
// This component just manages the text editing component of hte renderer.
class SuiTextInPlace extends SuiComponentBase {
  constructor(dialog,parameter) {
    super();
    smoSerialize.filteredMerge(
        ['parameterName', 'smoName', 'defaultValue', 'control', 'label'], parameter, this);
    if (!this.defaultValue) {
        this.defaultValue = 0;
    }
    this.editMode=false;
    this.dialog = dialog;
    this.value='';
    var modifier = this.dialog.modifier;

    this.activeScoreText = dialog.activeScoreText;
    this.value = modifier;
    this.altLabel = SuiTextTransformDialog.getStaticText('editorLabel');
  }

  get html() {
    var b = htmlHelpers.buildDom;
    var id = this.parameterId;
    var r = b('div').classes('cbTextInPlace smoControl').attr('id', this.parameterId).attr('data-param', this.parameterName)
      .append(b('button').attr('type', 'checkbox').classes('toggleTextEdit')
        .attr('id', id + '-input').append(
        b('span').classes('icon icon-pencil'))
        .append(
        b('label').attr('for', id + '-input').text(this.label)));
    return r;
  }
  get parameterId() {
    return this.dialog.id + '-' + this.parameterName;
  }
  endSession() {
    var self = this;
    $(this._getInputElement()).find('label').text(this.label);
    const button = document.getElementById(this.parameterId);
    $(button).find('span.icon').removeClass('icon-checkmark').addClass('icon-pencil');

    var render = () => {
      this.dialog.layout.setRefresh();
    }
    if (this.editor) {
      this.value=this.editor.textGroup;
      this.editor.stopSession().then(render);
    }
    $('body').removeClass('text-edit');
  }
  get isRunning() {
    return this.editor && this.editor.isRunning;
  }
  getValue() {
    return this.value;
  }
  _getInputElement() {
    var pid = this.parameterId;
    return $(this.dialog.dgDom.element).find('#' + pid).find('button');
  }
  mouseMove(ev) {
    if (this.editor && this.editor.isRunning) {
      this.editor.handleMouseEvent(ev);
    }
  }

  mouseClick(ev) {
    if (this.editor && this.editor.isRunning) {
      this.editor.handleMouseEvent(ev);
    }
  }
  startEditSession() {
    var self=this;
    $(this._getInputElement()).find('label').text(this.altLabel);
    var modifier = this.dialog.modifier;
    const ul = modifier.ul();
    // this.textElement=$(this.dialog.layout.svg).find('.'+modifier.attrs.id)[0];
    this.editor = new SuiTextSession({context : this.dialog.layout.context,
      scroller: this.dialog.tracker.scroller,
      layout: this.dialog.layout,
      score: this.dialog.layout.score,
      x: ul.x,
      y: ul.y,
      textGroup: modifier
    });
    $('body').addClass('text-edit');
    this.value = this.editor.textGroup;
    var button = document.getElementById(this.parameterId);
    $(button).find('span.icon').removeClass('icon-pencil').addClass('icon-checkmark');
    this.editor.startSession();
  }
  evKey(evdata) {
    if (this.editor) {
      this.editor.evKey(evdata);
    }
  }

  bind() {
    var self=this;
    this.fontInfo = JSON.parse(JSON.stringify(this.activeScoreText.fontInfo));
    this.value = this.dialog.modifier;
    $(this._getInputElement()).off('click').on('click',function(ev) {
      if (self.editor && self.editor.state === SuiTextSession.States.RUNNING) {
        self.endSession();
      } else {
        self.startEditSession();
      }
    });
  }
}

// ## SuiLyricComponent
// manage a lyric session that moves from note to note and adds lyrics.
class SuiLyricComponent extends SuiComponentBase {
  constructor(dialog,parameter) {
    super();
    smoSerialize.filteredMerge(
        ['parameterName', 'smoName', 'defaultValue', 'control', 'label'], parameter, this);
    if (!this.defaultValue) {
        this.defaultValue = 0;
    }
    this.editor = null;
    this.dialog = dialog;

    this.selection = dialog.tracker.selections[0];
    this.selector = JSON.parse(JSON.stringify(this.selection.selector));
    this.altLabel = SuiLyricDialog.getStaticText('doneEditing');
  }

  get html() {
    var b = htmlHelpers.buildDom;
    var id = this.parameterId;
    var r = b('div').classes('cbLyricEdit smoControl').attr('id', this.parameterId).attr('data-param', this.parameterName)
      .append(b('div').classes('toggleEdit')
        .append(b('button').classes('toggleTextEdit')
          .attr('id', id + '-toggleInput').append(
          b('span').classes('icon icon-pencil'))).append(
          b('label').attr('for', id + '-toggleInput').text(this.label)))

      .append(b('div').classes('controlDiv')
        .append(b('span')
          .append(
            b('button').attr('id', id + '-left').classes('icon-arrow-left buttonComponent')))
        .append(b('span')
          .append(
            b('button').attr('id', id + '-right').classes('icon-arrow-right buttonComponent')))
        .append(b('span')
          .append(
            b('button').attr('id', id + '-remove').classes('icon-cross buttonComponent')))
      );
    return r;

  }
  get parameterId() {
    return this.dialog.id + '-' + this.parameterName;
  }
  endSession() {
    var self = this;
    $(this._getInputElement()).find('label').text(this.label);
    const button = document.getElementById(this.parameterId);
    $(button).find('span.icon').removeClass('icon-checkmark').addClass('icon-pencil');

    var render = () => {
      this.dialog.layout.setRefresh();
    }
    if (this.editor) {
      this.value=this.editor.textGroup;
      this.editor.stopSession().then(render);
    }
    $('body').removeClass('text-edit');
  }
  get running() {
    return this.editor && this.editor.isRunning;
  }
  getValue() {
    return this.value;
  }
  _getInputElement() {
    var pid = this.parameterId;
    return $(this.dialog.dgDom.element).find('#' + pid).find('button');
  }
  mouseMove(ev) {
    if (this.editor && this.editor.isRunning) {
      this.editor.handleMouseEvent(ev);
    }
  }

  mouseClick(ev) {
    if (this.editor && this.editor.isRunning) {
      this.editor.handleMouseEvent(ev);
    }
  }
  startEditSession() {
    var self=this;
    $(this._getInputElement()).find('label').text(this.altLabel);
    var modifier = this.dialog.modifier;
    // this.textElement=$(this.dialog.layout.svg).find('.'+modifier.attrs.id)[0];
    this.editor = new SuiLyricSession({
       context : this.dialog.layout.context,
       selector: this.selector,
       scroller: this.dialog.tracker.scroller,
       layout: this.dialog.layout,
       verse: 0,
       score: this.dialog.layout.score
       }
     );
    $('body').addClass('text-edit');
    var button = document.getElementById(this.parameterId);
    $(button).find('span.icon').removeClass('icon-pencil').addClass('icon-checkmark');
    this.editor.startSession();
  }
  evKey(evdata) {
    if (this.editor) {
      this.editor.evKey(evdata);
    }
  }

  moveSelectionRight() {
      this.editor.advanceSelection(false);
  }
  moveSelectionLeft() {
    this.editor.advanceSelection(true);
  }
  removeText() {
    this.editor.removeLyric();
  }

  bind() {
    var self=this;
    $(this._getInputElement()).off('click').on('click',function(ev) {
      if (self.editor && self.editor.state === SuiLyricEditor.States.RUNNING) {
        self.endSession();
      } else {
        self.startEditSession();
      }
    });
    var self=this;
    $('#'+this.parameterId+'-left').off('click').on('click',function() {
      self.moveSelectionLeft();
    });
    $('#'+this.parameterId+'-right').off('click').on('click',function() {
      self.moveSelectionRight();
    });
    $('#'+this.parameterId+'-remove').off('click').on('click',function() {
      self.removeText();
    });
  }
}

// ## SuiChordComponent
// manage a chord editing session that moves from note to note and adds chord symbols.
class SuiChordComponent extends SuiComponentBase {
  constructor(dialog,parameter) {
    super();
    smoSerialize.filteredMerge(
        ['parameterName', 'smoName', 'defaultValue', 'control', 'label'], parameter, this);
    if (!this.defaultValue) {
        this.defaultValue = 0;
    }
    this.editor = null;
    this.dialog = dialog;

    this.selection = dialog.tracker.selections[0];
    this.selector = JSON.parse(JSON.stringify(this.selection.selector));
    this.altLabel = SuiLyricDialog.getStaticText('doneEditing');
  }

  get html() {
    var b = htmlHelpers.buildDom;
    var id = this.parameterId;
    var r = b('div').classes('cbTextInPlace smoControl').attr('id', this.parameterId).attr('data-param', this.parameterName)
      .append(b('button').attr('type', 'checkbox').classes('toggleTextEdit')
        .attr('id', id + '-input').append(
        b('span').classes('icon icon-pencil'))
        .append(
        b('label').attr('for', id + '-input').text(this.label)));
    return r;
  }
  get parameterId() {
    return this.dialog.id + '-' + this.parameterName;
  }
  endSession() {
    var self = this;
    $(this._getInputElement()).find('label').text(this.label);
    const button = document.getElementById(this.parameterId);
    $(button).find('span.icon').removeClass('icon-checkmark').addClass('icon-pencil');

    var render = () => {
      this.dialog.layout.setRefresh();
    }
    if (this.editor) {
      this.value=this.editor.textGroup;
      this.editor.stopSession().then(render);
    }
    $('body').removeClass('text-edit');
  }
  get running() {
    return this.editor && this.editor.isRunning;
  }
  getValue() {
    return this.value;
  }
  _getInputElement() {
    var pid = this.parameterId;
    return $(this.dialog.dgDom.element).find('#' + pid).find('button');
  }
  mouseMove(ev) {
    if (this.editor && this.editor.isRunning) {
      this.editor.handleMouseEvent(ev);
    }
  }

  mouseClick(ev) {
    if (this.editor && this.editor.isRunning) {
      this.editor.handleMouseEvent(ev);
    }
  }
  startEditSession() {
    var self=this;
    $(this._getInputElement()).find('label').text(this.altLabel);
    var modifier = this.dialog.modifier;
    // this.textElement=$(this.dialog.layout.svg).find('.'+modifier.attrs.id)[0];
    this.editor = new SuiChordSession({
       context : this.dialog.layout.context,
       selector: this.selector,
       scroller: this.dialog.tracker.scroller,
       layout: this.dialog.layout,
       verse: 0,
       score: this.dialog.layout.score
       }
     );
    $('body').addClass('text-edit');
    var button = document.getElementById(this.parameterId);
    $(button).find('span.icon').removeClass('icon-pencil').addClass('icon-checkmark');
    this.editor.startSession();
  }
  evKey(evdata) {
    if (this.editor) {
      this.editor.evKey(evdata);
    }
  }

  bind() {
    var self=this;
    $(this._getInputElement()).off('click').on('click',function(ev) {
      if (self.editor && self.editor.state === SuiLyricEditor.States.RUNNING) {
        self.endSession();
      } else {
        self.startEditSession();
      }
    });
  }
}

// ## SuiDragText
// A component that lets you drag the text you are editing to anywhere on the score.
// The text is not really part of the dialog but the location of the text appears
// in other dialog fields.
class SuiDragText extends SuiComponentBase {
  constructor(dialog,parameter) {
    super();
    smoSerialize.filteredMerge(
        ['parameterName', 'smoName', 'defaultValue', 'control', 'label'], parameter, this);
    if (!this.defaultValue) {
        this.defaultValue = 0;
    }
    this.dragging=false;
    this.running = false;

    this.dialog = dialog;
    this.altLabel = SuiTextTransformDialog.getStaticText('draggerLabel');
    this.value='';
  }

  get html() {
    var b = htmlHelpers.buildDom;
    var id = this.parameterId;
    var r = b('div').classes('cbDragTextDialog smoControl').attr('id', this.parameterId).attr('data-param', this.parameterName)
      .append(b('button').attr('type', 'checkbox').classes('toggleTextEdit')
        .attr('id', id + '-input').append(
        b('span').classes('icon icon-move'))
        .append(
        b('label').attr('for', id + '-input').text(this.label)));
    return r;
  }
  get parameterId() {
    return this.dialog.id + '-' + this.parameterName;
  }

  getValue() {
    return this.dialog.modifier;
  }
  _getInputElement() {
    var pid = this.parameterId;
    return $(this.dialog.dgDom.element).find('#' + pid).find('button');
  }
  stopEditSession() {
    $('body').removeClass('text-move');
    $(this._getInputElement()).find('span.icon').removeClass('icon-checkmark').addClass('icon-move');
    if (this.editor && this.editor.dragging) {
      this.editor.dragging = false;
    }
    this.running = false;
  }
  startEditSession() {
    $('body').addClass('text-move');
    this.editor = new SuiDragSession({
      textGroup: this.dialog.modifier,
      context: this.dialog.layout.context,
      scroller: this.dialog.tracker.scroller
    });
    $(this._getInputElement()).find('label').text(this.altLabel);
    $(this._getInputElement()).find('span.icon').removeClass('icon-enlarge').addClass('icon-checkmark');
    this.running = true;
  }
  mouseMove(e) {
    if (this.editor && this.editor.dragging) {
      this.editor.mouseMove(e);
    }
  }
  mouseDown(e) {
    if (this.editor && !this.editor.dragging) {
      this.editor.startDrag(e);
      this.dragging = true;
    }
  }
  mouseUp(e) {
    if (this.editor && this.editor.dragging) {
      this.editor.endDrag(e);
      this.dragging = false;
      this.handleChanged();
    }
  }

  bind() {
    var self=this;
    $(this._getInputElement()).off('click').on('click',function(ev) {
      if (self.running) {
        self.stopEditSession();
      } else {
        self.startEditSession();
      }
    });
  }
}

// ## Removing this for now...
class SuiResizeTextBox extends SuiComponentBase {
  constructor(dialog,parameter) {
    super();
    smoSerialize.filteredMerge(
      ['parameterName', 'smoName', 'defaultValue', 'control', 'label'], parameter, this);
    if (!this.defaultValue) {
      this.defaultValue = 0;
    }
    this.resizing = false;
    this.running = false;

    this.dialog = dialog;
    this.value='';
  }

  get html() {
    var b = htmlHelpers.buildDom;
    var id = this.parameterId;
    var r = b('div').classes('cbResizeTextBox smoControl').attr('id', this.parameterId).attr('data-param', this.parameterName)
      .append(b('button').attr('type', 'checkbox').classes('toggleTextEdit')
          .attr('id', id + '-input').append(
          b('span').classes('icon icon-enlarge'))
          .append(
          b('label').attr('for', id + '-input').text(this.label)));
    return r;
  }
  get parameterId() {
    return this.dialog.id + '-' + this.parameterName;
  }

  stopEditSession() {
    $('body').removeClass('text-resize');
    if (this.editor && this.editor.dragging) {
      this.editor.dragging = false;
      this.dragging = false;
    }
    this.running = false;
  }
  getValue() {
    return this.value;
  }
  _getInputElement() {
    var pid = this.parameterId;
    return $(this.dialog.dgDom.element).find('#' + pid).find('button');
  }
  mouseUp(e) {
    if (this.editor && this.editor.dragging) {
      this.editor.endDrag(e);
      this.dragging = false;
      this.dialog.changed();
    }
  }
  mouseMove(e) {
    if (this.editor && this.editor.dragging) {
      this.editor.mouseMove(e);
    }
  }

  startEditSession() {
    $('body').addClass('text-resize');
    this.editor = new SuiResizeTextSession({
      textGroup: this.dialog.modifier,
      context: this.dialog.layout.context,
      scroller: this.dialog.tracker.scroller
    });
    this.running = true;
    $(this._getInputElement()).find('label').text('Done Resizing Text Block');
    $(this._getInputElement()).find('span.icon').removeClass('icon-enlarge').addClass('icon-checkmark');
  }
  mouseDown(e) {
    if (this.editor && !this.editor.dragging) {
      this.editor.startDrag(e);
      this.dragging = true;
    }
  }

  bind() {
      var self=this;
      $(this._getInputElement()).off('click').on('click',function(ev) {
        if (self.running) {
          self.stopEditSession();
        } else {
          self.startEditSession();
        }
      });
    }
}
;

class defaultRibbonLayout {

	static get ribbons() {
		var left = defaultRibbonLayout.leftRibbonIds;
		var top = defaultRibbonLayout.displayIds.concat(defaultRibbonLayout.noteButtonIds).concat(defaultRibbonLayout.navigateButtonIds)
        .concat(defaultRibbonLayout.articulateButtonIds).concat(defaultRibbonLayout.microtoneIds)
		    .concat(defaultRibbonLayout.durationIds)
            .concat(defaultRibbonLayout.beamIds).concat(defaultRibbonLayout.measureIds).concat(defaultRibbonLayout.staveIds)
              .concat(defaultRibbonLayout.textIds).concat(defaultRibbonLayout.playerIds)
              .concat(defaultRibbonLayout.voiceButtonIds).concat(defaultRibbonLayout.debugIds);

		return {
			left: left,
			top:top
		};
	}

	static get ribbonButtons() {
		return defaultRibbonLayout.leftRibbonButtons.concat(
			defaultRibbonLayout.navigationButtons).concat(
			defaultRibbonLayout.noteRibbonButtons).concat(
			defaultRibbonLayout.articulationButtons).concat(
            defaultRibbonLayout.microtoneButtons).concat(
			defaultRibbonLayout.chordButtons).concat(
			defaultRibbonLayout.durationRibbonButtons).concat(defaultRibbonLayout.beamRibbonButtons).concat(defaultRibbonLayout.measureRibbonButtons)
			.concat(defaultRibbonLayout.staveRibbonButtons)
            .concat(defaultRibbonLayout.textRibbonButtons).concat(defaultRibbonLayout.playerButtons)
            .concat(defaultRibbonLayout.voiceRibbonButtons).concat(defaultRibbonLayout.displayButtons).concat(defaultRibbonLayout.debugRibbonButtons);
	}

	static get leftRibbonIds() {
		return ['helpDialog','languageMenu', 'fileMenu','addStaffMenu','measureModal','tempoModal','timeSignatureMenu','keyMenu', 'staffModifierMenu', 'staffModifierMenu2',
    'instrumentModal','pianoModal','layoutModal'];
	}
	static get noteButtonIds() {
		return ['NoteButtons',
            'UpNoteButton', 'DownNoteButton','AddGraceNote','RemoveGraceNote','SlashGraceNote','XNoteHead',
				'UpOctaveButton', 'DownOctaveButton', 'ToggleRest','ToggleAccidental', 'ToggleCourtesy'];
	}
  static get voiceButtonIds() {
      return ['VoiceButtons','V1Button','V2Button','V3Button','V4Button','VXButton'];
  }
	static get navigateButtonIds()  {
		return ['NavigationButtons', 'navLeftButton', 'navRightButton', 'navUpButton', 'navDownButton', 'moreNavButtons','navFastForward', 'navRewind',
				'navGrowLeft', 'navGrowRight'];
	}
	static get articulateButtonIds()  {
		return ['articulationButtons', 'accentButton', 'tenutoButton', 'staccatoButton', 'marcatoButton', 'fermataButton', 'pizzicatoButton','mordentButton','mordentInvertedButton','trillButton'
      ,'scoopButton','dropButton','dropLongButton','doitButton','doitLongButton','flipButton','smearButton'];
	}

	static get intervalIds()  {
		return ['CreateChordButtons', 'SecondUpButton', 'SecondDownButton', 'ThirdUpButton', 'ThirdDownButton', 'FourthUpButton', 'FourthDownButton',
				'FifthUpButton', 'FifthDownButton','SixthUpButton', 'SixthDownButton'
				,'SeventhUpButton', 'SeventhDownButton','OctaveUpButton','OctaveDownButton','CollapseChordButton'];
	}

	static get debugIds() {
		return ['DebugGroup','DebugButton2'];
	}
	static get durationIds() {
		return ['DurationButtons','GrowDuration','LessDuration','GrowDurationDot','LessDurationDot','TripletButton','QuintupletButton','SeptupletButton','NoTupletButton'];
	}
	static get measureIds() {
		return ['MeasureButtons','endRepeat','startRepeat','endBar','doubleBar','singleBarEnd','singleBarStart','nthEnding','dcAlCoda','dsAlCoda','dcAlFine','dsAlFine','coda','toCoda','segno','toSegno','fine'];
	}

    static get textIds() {
		return ['TextButtons','addTextMenu','rehearsalMark','lyrics','chordChanges','addDynamicsMenu'];
	}

    static get beamIds() {
		return ['BeamButtons','breakBeam','beamSelections','toggleBeamDirection'];
	}
    static get staveIds() {
		return ['StaveButtons','clefTreble','clefBass','clefAddRemove','clefMoveUp','clefMoveDown','moreStaffButtons',
        'clefTenor','clefAlto',
           'staffBracketLower','staffBraceLower','staffDoubleConnectorLower','staffSingleConnectorLower'];
	}

  static get playerIds() {
      return ['playerButtons','playButton','pauseButton','stopButton'];
  }

  static get microtoneIds() {
      return ['MicrotoneButtons','flat75sz','flat25sz','flat25ar','flat125ar','sharp75','sharp125','sharp25','sori','koron'];
  }

  static get displayIds() {
      return ['displaySettings','refresh','zoomout','zoomin','playButton2','stopButton2'];
  }


  static get textRibbonButtons() {
    return [
      {
        leftText: '',
        rightText: '',
        classes: 'icon  collapseParent measure',
        icon: 'icon-text',
        action: 'collapseParent',
        ctor: 'CollapseRibbonControl',
        group: 'textEdit',
        id: 'TextButtons'
      }, {
        leftText: '',
        rightText: '/t',
        classes: 'icon collapsed textButton',
        icon: 'icon-textBasic',
        action: 'collapseChild',
        ctor: 'TextButtons',
        group: 'textEdit',
        id: 'addTextMenu'
      },{
        leftText: '',
        rightText: '',
        classes: 'icon collapsed textButton',
        icon: 'icon-rehearsemark',
        action: 'collapseChild',
        ctor: 'TextButtons',
        group: 'textEdit',
        id: 'rehearsalMark'
      },{
        leftText: '',
        rightText: '',
        classes: 'icon collapsed textButton',
        icon: 'icon-lyric',
        action: 'collapseChild',
        ctor: 'TextButtons',
        group: 'textEdit',
        id: 'lyrics'
      },  {
        leftText: '',
        rightText: '',
        classes: 'icon collapsed textButton',
        icon: 'icon-chordSymbol',
        action: 'collapseChild',
        ctor: 'TextButtons',
        group: 'textEdit',
        id: 'chordChanges'
      }, {
        leftText: '',
        rightText: '/d',
        classes: 'icon collapsed textButton',
        icon: 'icon-mezzopiano',
        action: 'collapseChild',
        ctor: 'TextButtons',
        group: 'textEdit',
        id: 'addDynamicsMenu'
	    }
    ];
  }
  static get displayButtons() {
    return [{
    	leftText: '',
  		rightText: '',
  		classes: 'icon  hide',
  		icon: 'icon-zoomplus',
  		action: 'collapseParent',
  		ctor: 'CollapseRibbonControl',
  		group: 'displaySettings',
  		id: 'displaySettings'
    },{
      leftText: '',
      rightText: '',
      classes: 'icon   refresh',
      icon: 'icon-refresh',
      action: 'collapseChild',
      ctor: 'DisplaySettings',
      group: 'displaySettings',
      id: 'refresh'
    },{
      leftText: '',
      rightText: '',
      classes: 'icon   refresh',
      icon: 'icon-zoomplus',
      action: 'collapseChild',
      ctor: 'DisplaySettings',
      group: 'displaySettings',
      id: 'zoomout'
    },{
      leftText: '',
  		rightText: '',
  		classes: 'icon   refresh',
  		icon: 'icon-zoomminus',
  		action: 'collapseChild',
  		ctor: 'DisplaySettings',
  		group: 'displaySettings',
  		id: 'zoomin'
    },{
      leftText: '',
  		rightText: '',
  		classes: 'icon   play',
  		icon: 'icon-play3',
  		action: 'collapseChild',
  		ctor: 'DisplaySettings',
  		group: 'displaySettings',
  		id: 'playButton2'
    },{
      leftText: '',
  		rightText: '',
  		classes: 'icon   stop2',
  		icon: 'icon-stop2',
  		action: 'collapseChild',
  		ctor: 'DisplaySettings',
  		group: 'displaySettings',
  		id: 'stopButton2'
    }
  ];
  }

    static get microtoneButtons() {
        return [{
			leftText: '',
				rightText: '',
				classes: 'icon  collapseParent microtones',
				icon: 'icon-microtone',
				action: 'collapseParent',
				ctor: 'CollapseRibbonControl',
				group: 'microtone',
				id: 'MicrotoneButtons'
		}, {
            leftText: '',
				rightText: '',
				classes: 'icon  collapsed microtones',
				icon: 'icon-flat25sz',
				action: 'collapseChild',
				ctor: 'MicrotoneButtons',
				group: 'microtone',
				id: 'flat25sz'
        }, {
            leftText: '',
				rightText: '',
				classes: 'icon  collapsed microtones',
				icon: 'icon-flat75sz',
				action: 'collapseChild',
				ctor: 'MicrotoneButtons',
				group: 'microtone',
				id: 'flat75sz'
        },{
            leftText: '',
				rightText: '',
				classes: 'icon  collapsed microtones',
				icon: 'icon-flat25ar',
				action: 'collapseChild',
				ctor: 'MicrotoneButtons',
				group: 'microtone',
				id: 'flat25ar'
        },{
            leftText: '',
				rightText: '',
				classes: 'icon  collapsed microtones',
				icon: 'icon-sharp75',
				action: 'collapseChild',
				ctor: 'MicrotoneButtons',
				group: 'microtone',
				id: 'sharp75'
        },{
            leftText: '',
				rightText: '',
				classes: 'icon  collapsed microtones',
				icon: 'icon-sharp125',
				action: 'collapseChild',
				ctor: 'MicrotoneButtons',
				group: 'microtone',
				id: 'sharp125'
        },{
            leftText: '',
				rightText: '',
				classes: 'icon  collapsed microtones',
				icon: 'icon-sharp25',
				action: 'collapseChild',
				ctor: 'MicrotoneButtons',
				group: 'microtone',
				id: 'sharp25'
        },{
            leftText: '',
				rightText: '',
				classes: 'icon  collapsed microtones',
				icon: 'icon-sori',
				action: 'collapseChild',
				ctor: 'MicrotoneButtons',
				group: 'microtone',
				id: 'sori'
        },{
            leftText: '',
				rightText: '',
				classes: 'icon  collapsed microtones',
				icon: 'icon-koron',
				action: 'collapseChild',
				ctor: 'MicrotoneButtons',
				group: 'microtone',
				id: 'koron'
        }];
    }

	static get staveRibbonButtons() {
		return [{
			leftText: '',
				rightText: '',
				classes: 'icon  collapseParent staves',
				icon: 'icon-treble',
				action: 'collapseParent',
				ctor: 'CollapseRibbonControl',
				group: 'staves',
				id: 'StaveButtons'
		},{
			leftText: '',
				rightText: '',
				classes: 'icon  collapsed staves',
				icon: 'icon-treble',
				action: 'collapseChild',
				ctor: 'StaveButtons',
				group: 'staves',
				id: 'clefTreble'
		},{
			leftText: '',
				rightText: '',
				classes: 'icon  collapsed staves',
				icon: 'icon-bass',
				action: 'collapseChild',
				ctor: 'StaveButtons',
				group: 'staves',
				id: 'clefBass'
		}
        ,{
			leftText: '',
				rightText: '',
				classes: 'icon  collapsed staves',
				icon: 'icon-plus',
				action: 'collapseChildMenu',
				ctor: 'SuiAddStaffMenu',
				group: 'staves',
				id: 'clefAddRemove'
		},
        {
			leftText: '',
				rightText: '',
				classes: 'icon  collapsed staves',
				icon: 'icon-arrow-up',
				action: 'collapseChild',
				ctor: 'StaveButtons',
				group: 'staves',
				id: 'clefMoveUp'
		},{
			leftText: '',
				rightText: '',
				classes: 'icon  collapsed staves',
				icon: 'icon-arrow-down',
				action: 'collapseChild',
				ctor: 'StaveButtons',
				group: 'staves',
				id: 'clefMoveDown'
		},
        {
            leftText: '...',
            rightText: '',
            icon: 'icon-circle-left',
            classes: 'collapsed expander',
            action: 'collapseMore',
            ctor: 'ExtendedCollapseParent',
            group: 'staves',
            id: 'moreStaffButtons'
        },{
			leftText: '',
				rightText: '',
				classes: 'icon  collapsed staves',
				icon: 'icon-tenor',
				action: 'collapseGrandchild',
				ctor: 'StaveButtons',
				group: 'staves',
				id: 'clefTenor'
		},{
			leftText: '',
				rightText: '',
				classes: 'icon  collapsed staves',
				icon: 'icon-alto',
				action: 'collapseGrandchild',
				ctor: 'StaveButtons',
				group: 'staves',
				id: 'clefAlto'
		},{
			leftText: '',
				rightText: '',
				classes: 'icon  collapsed staves',
				icon: 'icon-brace',
				action: 'collapseGrandchild',
				ctor: 'StaveButtons',
				group: 'staves',
				id: 'staffBraceLower'
		},{
			leftText: '',
				rightText: '',
				classes: 'icon  collapsed staves',
				icon: 'icon-bracket',
				action: 'collapseGrandchild',
				ctor: 'StaveButtons',
				group: 'staves',
				id: 'staffBracketLower'
		}

		];
	}

    static get beamRibbonButtons() {
        return [{
			leftText: '',
				rightText: '',
				classes: 'icon  collapseParent beams',
				icon: 'icon-flag',
				action: 'collapseParent',
				ctor: 'CollapseRibbonControl',
				group: 'beams',
				id: 'BeamButtons'
		},{
				leftText: '',
				rightText: 'x',
				icon: 'icon-beamBreak',
				classes: 'collapsed beams',
				action: 'collapseChild',
				ctor: 'BeamButtons',
				group: 'beams',
				id: 'breakBeam'
			},
            {
				leftText: '',
				rightText: 'Shift-X',
				icon: 'icon-beam',
				classes: 'collapsed beams',
				action: 'collapseChild',
				ctor: 'BeamButtons',
				group: 'beams',
				id: 'beamSelections'
			},
            {
				leftText: '',
				rightText: 'Shift-B',
				icon: 'icon-flagFlip',
				classes: 'collapsed beams',
				action: 'collapseChild',
				ctor: 'BeamButtons',
				group: 'beams',
				id: 'toggleBeamDirection'
			}
        ];
    }

	static get measureRibbonButtons() {
		return [{
			leftText: '',
				rightText: '',
				classes: 'icon  collapseParent measure',
				icon: 'icon-end_rpt',
				action: 'collapseParent',
				ctor: 'CollapseRibbonControl',
				group: 'measure',
				id: 'MeasureButtons'
		},{
				leftText: '',
				rightText: '',
				icon: 'icon-end_rpt',
				classes: 'collapsed duration',
				action: 'collapseChild',
				ctor: 'MeasureButtons',
				group: 'measure',
				id: 'endRepeat'
			},
			{
				leftText: '',
				rightText: '',
				icon: 'icon-start_rpt',
				classes: 'collapsed duration',
				action: 'collapseChild',
				ctor: 'MeasureButtons',
				group: 'measure',
				id: 'startRepeat'
			}
			,
			{
				leftText: '',
				rightText: '',
				icon: 'icon-end_bar',
				classes: 'collapsed duration',
				action: 'collapseChild',
				ctor: 'MeasureButtons',
				group: 'measure',
				id: 'endBar'
			},
			{
				leftText: '',
				rightText: '',
				icon: 'icon-double_bar',
				classes: 'collapsed duration',
				action: 'collapseChild',
				ctor: 'MeasureButtons',
				group: 'measure',
				id: 'doubleBar'
			},
			{
				leftText: '',
				rightText: '',
				icon: 'icon-single_bar',
				classes: 'collapsed duration',
				action: 'collapseChild',
				ctor: 'MeasureButtons',
				group: 'measure',
				id: 'singleBarEnd'
			},
			{
				leftText: '',
				rightText: '',
				icon: 'icon-single_bar_start',
				classes: 'collapsed duration',
				action: 'collapseChild',
				ctor: 'MeasureButtons',
				group: 'measure',
				id: 'singleBarStart'
			},
			{
				leftText: '',
				rightText: '',
				icon: 'icon-ending',
				classes: 'collapsed duration',
				action: 'collapseChild',
				ctor: 'MeasureButtons',
				group: 'measure',
				id: 'nthEnding'
			},
			{
				leftText: 'DC Al Coda',
				rightText: '',
				icon: '',
				classes: 'collapsed repetext',
				action: 'collapseChild',
				ctor: 'MeasureButtons',
				group: 'measure',
				id: 'dcAlCoda'
			},
			{
				leftText: 'DS Al Coda',
				rightText: '',
				icon: '',
				classes: 'collapsed repetext',
				action: 'collapseChild',
				ctor: 'MeasureButtons',
				group: 'measure',
				id: 'dsAlCoda'
			},
			{
				leftText: 'DC Al Fine',
				rightText: '',
				icon: '',
				classes: 'collapsed repetext',
				action: 'collapseChild',
				ctor: 'MeasureButtons',
				group: 'measure',
				id: 'dcAlFine'
			},
			{
				leftText: 'DS Al Fine',
				rightText: '',
				icon: '',
				classes: 'collapsed repetext',
				action: 'collapseChild',
				ctor: 'MeasureButtons',
				group: 'measure',
				id: 'dsAlFine'
			},
			{
				leftText: '',
				rightText: '',
				icon: 'icon-coda',
				classes: 'collapsed duration',
				action: 'collapseChild',
				ctor: 'MeasureButtons',
				group: 'measure',
				id: 'coda'
			},
			{
				leftText: 'to ',
				rightText: '',
				icon: 'icon-coda',
				classes: 'collapsed duration',
				action: 'collapseChild',
				ctor: 'MeasureButtons',
				group: 'measure',
				id: 'toCoda'
			},
			{
				leftText: '',
				rightText: '',
				icon: 'icon-segno',
				classes: 'collapsed duration',
				action: 'collapseChild',
				ctor: 'MeasureButtons',
				group: 'measure',
				id: 'segno'
			},
			{
				leftText: 'Fine',
				rightText: '',
				icon: '',
				classes: 'collapsed repetext',
				action: 'collapseChild',
				ctor: 'MeasureButtons',
				group: 'measure',
				id: 'fine'
			}
		];
	}
	static get debugRibbonButtons() {
		return [{
				leftText: '',
				rightText: '',
				classes: 'icon  collapseParent',
				icon: 'icon-new-tab',
				action: 'collapseParent',
				ctor: 'CollapseRibbonControl',
				group: 'debug',
				id: 'DebugGroup'
			},{
				leftText: '',
				rightText: '',
				classes: 'icon  collapsed',
				icon: 'icon-new-tab',
				action: 'collapseChild',
				ctor: 'DebugButtons',
				group: 'debug',
				id: 'DebugButton2'
			}];
	}

	static get durationRibbonButtons() {
		return [{
				leftText: '',
				rightText: '',
				classes: 'icon  collapseParent duration',
				icon: 'icon-duration',
				action: 'collapseParent',
				ctor: 'CollapseRibbonControl',
				group: 'duration',
				id: 'DurationButtons'
			},{
				leftText: '',
				rightText: '.',
				icon: 'icon-duration_grow',
				classes: 'collapsed duration',
				action: 'collapseChild',
				ctor: 'DurationButtons',
				group: 'duration',
				id: 'GrowDuration'
			},{
				leftText: '',
				rightText: ',',
				icon: 'icon-duration_less',
				classes: 'collapsed duration',
				action: 'collapseChild',
				ctor: 'DurationButtons',
				group: 'duration',
				id: 'LessDuration'
			},{
				leftText: '',
				rightText: '>',
				icon: 'icon-duration_grow_dot',
				classes: 'collapsed duration',
				action: 'collapseChild',
				ctor: 'DurationButtons',
				group: 'duration',
				id: 'GrowDurationDot'
			},{
				leftText: '',
				rightText: '<',
				icon: 'icon-duration_less_dot',
				classes: 'collapsed duration',
				action: 'collapseChild',
				ctor: 'DurationButtons',
				group: 'duration',
				id: 'LessDurationDot'
			},{
				leftText: '',
				rightText: 'Ctrl-3',
				icon: 'icon-triplet',
				classes: 'collapsed duration tuplet',
				action: 'collapseChild',
				ctor: 'DurationButtons',
				group: 'duration',
				id: 'TripletButton'
			},{
				leftText: '',
				rightText: 'Ctrl-5',
				icon: 'icon-quint',
				classes: 'collapsed duration tuplet',
				action: 'collapseChild',
				ctor: 'DurationButtons',
				group: 'duration',
				id: 'QuintupletButton'
			},{
				leftText: '',
				rightText: 'Ctrl-7',
				icon: 'icon-septuplet',
				classes: 'collapsed duration tuplet',
				action: 'collapseChild',
				ctor: 'DurationButtons',
				group: 'duration',
				id: 'SeptupletButton'
			},
			{
				leftText: '',
				rightText: 'Ctrl-0',
				icon: 'icon-no_tuplet',
				classes: 'collapsed duration tuplet',
				action: 'collapseChild',
				ctor: 'DurationButtons',
				group: 'duration',
				id: 'NoTupletButton'
			}
			];
	}

    static get voiceRibbonButtons() {
        return [{
                leftText: '',
                rightText: '',
                classes: 'icon  collapseParent',
                icon: 'icon-Vo',
                action: 'collapseParent',
                ctor: 'CollapseRibbonControl',
                group: 'voices',
                id: 'VoiceButtons'
            }, {
                leftText: '',
                rightText: '',
                icon: 'icon-V1',
                classes: 'collapsed',
                action: 'collapseChild',
                ctor: 'VoiceButtons',
                group: 'voices',
                id: 'V1Button'
            }, {
                leftText: '',
                rightText: '',
                icon: 'icon-V2',
                classes: 'collapsed',
                action: 'collapseChild',
                ctor: 'VoiceButtons',
                group: 'voices',
                id: 'V2Button'
            }, {
                leftText: '',
                rightText: '',
                icon: 'icon-V3',
                classes: 'collapsed',
                action: 'collapseChild',
                ctor: 'VoiceButtons',
                group: 'voices',
                id: 'V3Button'
            }, {
                leftText: '',
                rightText: '',
                icon: 'icon-V4',
                classes: 'collapsed',
                action: 'collapseChild',
                ctor: 'VoiceButtons',
                group: 'voices',
                id: 'V4Button'
            }, {
                leftText: '',
                rightText: '',
                icon: 'icon-Vx',
                classes: 'collapsed',
                action: 'collapseChild',
                ctor: 'VoiceButtons',
                group: 'voices',
                id: 'VXButton'
            }
        ];
    }
	static get noteRibbonButtons() {
		return [{
				leftText: '',
				rightText: '',
				classes: 'icon  collapseParent',
				icon: 'icon-note',
				action: 'collapseParent',
				ctor: 'CollapseRibbonControl',
				group: 'notes',
				id: 'NoteButtons'
			}, {
				leftText: 'A',
				rightText: 'a',
				icon: '',
				classes: 'collapsed',
				action: 'collapseChild',
				ctor: 'NoteButtons',
				group: 'notes',
				id: 'ANoteButton'
			}, {
				leftText: 'B',
				rightText: 'b',
				icon: '',
				classes: 'collapsed',
				action: 'collapseChild',
				ctor: 'NoteButtons',
				group: 'notes',
				id: 'BNoteButton'
			}, {
				leftText: 'C',
				rightText: 'c',
				icon: '',
				classes: 'collapsed',
				action: 'collapseChild',
				ctor: 'NoteButtons',
				group: 'notes',
				id: 'CNoteButton'
			}, {
				leftText: 'D',
				rightText: 'd',
				icon: '',
				classes: 'collapsed',
				action: 'collapseChild',
				ctor: 'NoteButtons',
				group: 'notes',
				id: 'DNoteButton'
			}, {
				leftText: 'E',
				rightText: 'e',
				icon: '',
				classes: 'collapsed',
				action: 'collapseChild',
				ctor: 'NoteButtons',
				group: 'notes',
				id: 'ENoteButton'
			}, {
				leftText: 'F',
				rightText: 'f',
				icon: '',
				classes: 'collapsed',
				action: 'collapseChild',
				ctor: 'NoteButtons',
				group: 'notes',
				id: 'FNoteButton'
			}, {
				leftText: 'G',
				rightText: 'g',
				icon: '',
				classes: 'collapsed',
				action: 'collapseChild',
				ctor: 'NoteButtons',
				group: 'notes',
				id: 'GNoteButton'
			}, {
				leftText: '',
				rightText: '-',
				icon: 'icon-sharp',
				classes: 'collapsed',
				action: 'collapseChild',
				ctor: 'NoteButtons',
				group: 'notes',
				id: 'UpNoteButton'
			}, {
				leftText: '',
				rightText: '=',
				icon: 'icon-flat',
				classes: 'collapsed',
				action: 'collapseChild',
				ctor: 'NoteButtons',
				group: 'notes',
				id: 'DownNoteButton'
			}, {
				leftText: '',
				rightText: 'r',
				icon: 'icon-rest',
				classes: 'collapsed',
				action: 'collapseChild',
				ctor: 'NoteButtons',
				group: 'notes',
				id: 'ToggleRestButton'
			},{
				leftText: '...',
				rightText: '',
				icon: 'icon-circle-left',
				classes: 'collapsed expander',
				action: 'collapseMore',
				ctor: 'ExtendedCollapseParent',
				group: 'notes',
				id: 'moreNoteButtons'
			}, {
				leftText: '',
				rightText: 'G',
				icon: 'icon-grace_note',
				classes: 'collapsed graceIcon',
				action: 'collapseChild',
				ctor: 'NoteButtons',
				group: 'notes',
				id: 'AddGraceNote'
			}, {
				leftText: '',
				rightText: '',
				icon: 'icon-grace_slash',
				classes: 'collapsed graceIcon',
				action: 'collapseChild',
				ctor: 'NoteButtons',
				group: 'notes',
				id: 'SlashGraceNote'
			},{
				leftText: '',
				rightText: 'alt-g',
				icon: 'icon-grace_remove',
				classes: 'collapsed graceIcon',
				action: 'collapseChild',
				ctor: 'NoteButtons',
				group: 'notes',
				id: 'RemoveGraceNote'
			},{
				leftText: '',
				rightText: '',
				icon: 'icon-notex',
				classes: 'collapsed graceIcon',
				action: 'collapseChild',
				ctor: 'NoteButtons',
				group: 'notes',
				id: 'XNoteHead'
			},{
				leftText: '8va',
				rightText: 'Shift=',
				icon: '',
				classes: 'collapsed',
				action: 'collapseChild',
				ctor: 'NoteButtons',
				group: 'notes',
				id: 'UpOctaveButton'
			}, {
				leftText: '8vb',
				rightText: 'Shift-',
				icon: '',
				classes: 'collapsed',
				action: 'collapseChild',
				ctor: 'NoteButtons',
				group: 'notes',
				id: 'DownOctaveButton'
			}, {
				leftText: '',
				rightText: 'ShiftE',
				icon: 'icon-accident',
				classes: 'collapsed',
				action: 'collapseChild',
				ctor: 'NoteButtons',
				group: 'notes',
				id: 'ToggleAccidental'
			}, {
				leftText: '',
				rightText: 'ShiftF',
				icon: 'icon-courtesy',
				classes: 'collapsed',
				action: 'collapseChild',
				ctor: 'NoteButtons',
				group: 'notes',
				id: 'ToggleCourtesy'
			}

		];
	}
	static get playerButtons() {
        // .icon-play3
        return [{
				leftText: '',
				rightText: '',
				icon: 'icon-equalizer2',
				classes: 'icon collapseParent player',
				action: 'collapseParent',
				ctor: 'CollapseRibbonControl',
				group: 'playerButtons',
				id: 'playerButtons'
			}, {
				leftText: '',
				rightText: 'p',
				icon: 'icon-play3',
				classes: 'icon collapsed player',
				action: 'collapseChild',
				ctor: 'PlayerButtons',
				group: 'playerButtons',
				id: 'playButton'
			},
            {
				leftText: '',
				rightText: 's',
				icon: 'icon-stop2',
				classes: 'icon collapsed player',
				action: 'collapseChild',
				ctor: 'PlayerButtons',
				group: 'playerButtons',
				id: 'stopButton'
			},
            {
				leftText: '',
				rightText: 'P',
				icon: 'icon-pause2',
				classes: 'icon collapsed player',
				action: 'collapseChild',
				ctor: 'PlayerButtons',
				group: 'playerButtons',
				id: 'pauseButton'
			}];
    }
    static get articulationButtons() {
		return [{
				leftText: '',
				rightText: '',
				icon: 'icon-articulation',
				classes: 'icon collapseParent articulation',
				action: 'collapseParent',
				ctor: 'CollapseRibbonControl',
				group: 'articulations',
				id: 'articulationButtons'
			}, {
				leftText: '',
				rightText: 'h',
				icon: 'icon-accent_above',
				classes: 'icon collapsed articulation',
				action: 'collapseChild',
				ctor: 'ArticulationButtons',
				group: 'articulations',
				id: 'accentButton'
			},{
				leftText: '',
				rightText: 'i',
				icon: 'icon-tenuto_above',
				classes: 'icon collapsed articulation',
				action: 'collapseChild',
				ctor: 'ArticulationButtons',
				group: 'articulations',
				id: 'tenutoButton'
			}, {
				leftText: '',
				rightText: 'j',
				icon: 'icon-staccato_above',
				classes: 'icon collapsed articulation',
				action: 'collapseChild',
				ctor: 'ArticulationButtons',
				group: 'articulations',
				id: 'staccatoButton'
			}, {
				leftText: '',
				rightText: 'k',
				icon: 'icon-marcato_above',
				classes: 'icon collapsed articulation',
				action: 'collapseChild',
				ctor: 'ArticulationButtons',
				group: 'articulations',
				id: 'marcatoButton'
			}, {
				leftText: '',
				rightText: '',
				icon: 'icon-fermata',
				classes: 'icon collapsed articulation',
				action: 'collapseChild',
				ctor: 'ArticulationButtons',
				group: 'articulations',
				id: 'fermataButton'
			},  {
				leftText: '',
				rightText: 'l',
				icon: 'icon-pitz_above',
				classes: 'icon collapsed articulation',
				action: 'collapseChild',
				ctor: 'ArticulationButtons',
				group: 'articulations',
				id: 'pizzicatoButton'
			}, {
				leftText: '',
				rightText: '',
				icon: 'icon-mordent-inv',
				classes: 'icon collapsed articulation',
				action: 'collapseChild',
				ctor: 'ArticulationButtons',
				group: 'articulations',
				id: 'mordentInvertedButton'
      }, {
				leftText: '',
				rightText: '',
				icon: 'icon-mordent',
				classes: 'icon collapsed articulation',
				action: 'collapseChild',
				ctor: 'ArticulationButtons',
				group: 'articulations',
				id: 'mordentButton'
      }, {
				leftText: '',
				rightText: '',
				icon: 'icon-trill',
				classes: 'icon collapsed articulation',
				action: 'collapseChild',
				ctor: 'ArticulationButtons',
				group: 'articulations',
				id: 'trillButton'
      }, {
				leftText: '',
				rightText: '',
				icon: 'icon-scoop',
				classes: 'icon collapsed articulation',
				action: 'collapseChild',
				ctor: 'ArticulationButtons',
				group: 'articulations',
				id: 'scoopButton'
      },
      {
        leftText: '',
        rightText: '',
        icon: 'icon-drop',
        classes: 'icon collapsed articulation',
        action: 'collapseChild',
        ctor: 'ArticulationButtons',
        group: 'articulations',
        id: 'dropButton'
      },
      {
        leftText: '',
        rightText: '',
        icon: 'icon-drop-long',
        classes: 'icon collapsed articulation',
        action: 'collapseChild',
        ctor: 'ArticulationButtons',
        group: 'articulations',
        id: 'dropLongButton'
      },
      {
        leftText: '',
        rightText: '',
        icon: 'icon-doit',
        classes: 'icon collapsed articulation',
        action: 'collapseChild',
        ctor: 'ArticulationButtons',
        group: 'articulations',
        id: 'doitButton'
      },
      {
        leftText: '',
        rightText: '',
        icon: 'icon-doit-long',
        classes: 'icon collapsed articulation',
        action: 'collapseChild',
        ctor: 'ArticulationButtons',
        group: 'articulations',
        id: 'doitLongButton'
      },
      {
        leftText: '',
        rightText: '',
        icon: 'icon-flip',
        classes: 'icon collapsed articulation',
        action: 'collapseChild',
        ctor: 'ArticulationButtons',
        group: 'articulations',
        id: 'flipButton'
      },
      {
        leftText: '',
        rightText: '',
        icon: 'icon-smear',
        classes: 'icon collapsed articulation',
        action: 'collapseChild',
        ctor: 'ArticulationButtons',
        group: 'articulations',
        id: 'smearButton'
      }
		];
	}
	static get navigationButtons() {
		return [{
				leftText: '',
				rightText: '',
				classes: 'icon  collapseParent',
				icon: 'icon-navigate',
				action: 'collapseParent',
				ctor: 'CollapseRibbonControl',
				group: 'navigation',
				id: 'NavigationButtons'
			}, {
				leftText: '',
				rightText: '',
				icon: 'icon-arrow-left',
				classes: 'collapsed',
				action: 'collapseChild',
				ctor: 'NavigationButtons',
				group: 'navigation',
				id: 'navLeftButton'
			}, {
				leftText: '',
				rightText: '',
				icon: 'icon-arrow-right',
				classes: 'collapsed',
				action: 'collapseChild',
				ctor: 'NavigationButtons',
				group: 'navigation',
				id: 'navRightButton'
			}, {
				leftText: '',
				rightText: '',
				icon: 'icon-arrow-up',
				classes: 'collapsed',
				action: 'collapseChild',
				ctor: 'NavigationButtons',
				group: 'navigation',
				id: 'navUpButton'
			}, {
				leftText: '',
				rightText: '',
				icon: 'icon-arrow-down',
				classes: 'collapsed',
				action: 'collapseChild',
				ctor: 'NavigationButtons',
				group: 'navigation',
				id: 'navDownButton'
			}, {
				leftText: '...',
				rightText: '',
				icon: '',
				classes: 'collapsed expander',
				action: 'collapseMore',
				ctor: 'ExtendedCollapseParent',
				group: 'navigation',
				id: 'moreNavButtons'
			},{
				leftText: '',
				rightText: '',
				icon: 'icon-fforward',
				classes: 'collapsed',
				action: 'collapseGrandchild',
				ctor: 'NavigationButtons',
				group: 'navigation',
				id: 'navFastForward'
			}, {
				leftText: '',
				rightText: '',
				icon: 'icon-rewind',
				classes: 'collapsed',
				action: 'collapseGrandchild',
				ctor: 'NavigationButtons',
				group: 'navigation',
				id: 'navRewind'
			}, {
				leftText: '',
				rightText: '',
				icon: 'icon-note_select_left',
				classes: 'collapsed selection-icon',
				action: 'collapseGrandchild',
				ctor: 'NavigationButtons',
				group: 'navigation',
				id: 'navGrowLeft'
			}, {
				leftText: '',
				rightText: '',
				icon: 'icon-note_select_right',
				classes: 'collapsed selection-icon',
				action: 'collapseGrandchild',
				ctor: 'NavigationButtons',
				group: 'navigation',
				id: 'navGrowRight'
			}
		];
	}
	static get chordButtons() {
		return [{
				icon: 'icon-chords',
				leftText: '',
				rightText: '',
				classes: 'icon collapseParent',
				action: 'collapseParent',
				ctor: 'CollapseRibbonControl',
				group: 'chords',
				id: 'CreateChordButtons'
			}, {
				icon: 'icon-arrow-up',
				leftText: '2nd',
				rightText: '2',
				classes: 'collapsed addChord',
				action: 'collapseChild',
				dataElements: {
					interval: '1',
					direction: '1'
				},
				ctor: 'ChordButtons',
				group: 'chords',
				id: 'SecondUpButton'
			}, {
				icon: 'icon-arrow-down',
				leftText: '2nd',
				rightText: 'Shift 2',
				classes: 'collapsed addChord dirdown',
				action: 'collapseChild',
				dataElements: {
					interval: '1',
					direction: '1'
				},
				ctor: 'ChordButtons',
				group: 'chords',
				id: 'SecondDownButton'
			}, {
				icon: 'icon-arrow-up',
				leftText: '3rd',
				rightText: '3',
				classes: 'collapsed addChord',
				action: 'collapseChild',
				dataElements: {
					interval: '2',
					direction: '1'
				},
				ctor: 'ChordButtons',
				group: 'chords',
				id: 'ThirdUpButton'
			}, {
				icon: 'icon-arrow-down',
				leftText: '3rd',
				rightText: 'Shift 3',
				classes: 'collapsed addChord dirdown',
				action: 'collapseChild',
				dataElements: {
					interval: '2',
					direction: '-1'
				},
				ctor: 'ChordButtons',
				group: 'chords',
				id: 'ThirdDownButton'
			}, {
				icon: 'icon-arrow-up',
				leftText: '4th',
				rightText: '4',
				classes: 'collapsed addChord',
				action: 'collapseChild',
				dataElements: {
					interval: '3',
					direction: '1'
				},
				ctor: 'ChordButtons',
				group: 'chords',
				id: 'FourthUpButton'
			}, {
				icon: 'icon-arrow-down',
				leftText: '4th',
				rightText: 'Shift 4',
				classes: 'collapsed addChord dirdown',
				action: 'collapseChild',
				dataElements: {
					interval: '3',
					direction: '-1'
				},
				ctor: 'ChordButtons',
				group: 'chords',
				id: 'FourthDownButton'
			}, {
				icon: 'icon-arrow-up',
				leftText: '5th',
				rightText: '5',
				classes: 'collapsed addChord dirdown',
				action: 'collapseChild',
				dataElements: {
					interval: '4',
					direction: '1'
				},
				ctor: 'ChordButtons',
				group: 'chords',
				id: 'FifthUpButton'
			}, {
				icon: 'icon-arrow-down',
				leftText: '5th',
				rightText: 'Shift 5',
				classes: 'collapsed addChord dirdown',
				action: 'collapseChild',
				dataElements: {
					interval: '4',
					direction: '-1'
				},
				ctor: 'ChordButtons',
				group: 'chords',
				id: 'FifthDownButton'
			}, {
				icon: 'icon-arrow-up',
				leftText: '6th',
				rightText: '6',
				classes: 'collapsed addChord dirdown',
				action: 'collapseChild',
				dataElements: {
					interval: '5',
					direction: '1'
				},
				ctor: 'ChordButtons',
				group: 'chords',
				id: 'SixthUpButton'
			}, {
				icon: 'icon-arrow-down',
				leftText: '6th',
				rightText: 'Shift 6',
				classes: 'collapsed addChord dirdown',
				action: 'collapseChild',
				dataElements: {
					interval: '5',
					direction: '-1'
				},
				ctor: 'ChordButtons',
				group: 'chords',
				id: 'SixthDownButton'
			}, {
				icon: 'icon-arrow-up',
				leftText: '7th',
				rightText: '7',
				classes: 'collapsed addChord dirdown',
				action: 'collapseChild',
				dataElements: {
					interval: '6',
					direction: '1'
				},
				ctor: 'ChordButtons',
				group: 'chords',
				id: 'SeventhUpButton'
			}, {
				icon: 'icon-arrow-down',
				leftText: '7th',
				rightText: 'Shift 7',
				classes: 'collapsed addChord dirdown',
				action: 'collapseChild',
				dataElements: {
					interval: '6',
					direction: '-1'
				},
				ctor: 'ChordButtons',
				group: 'chords',
				id: 'SeventhDownButton'
			}, {
				icon: 'icon-arrow-up',
				leftText: '8va',
				rightText: '8',
				classes: 'collapsed addChord dirdown',
				action: 'collapseChild',
				dataElements: {
					interval: '7',
					direction: '1'
				},
				ctor: 'ChordButtons',
				group: 'chords',
				id: 'OctaveUpButton'
			}, {
				icon: 'icon-arrow-down',
				leftText: '7th',
				rightText: 'Shift 7',
				classes: 'collapsed addChord dirdown',
				action: 'collapseChild',
				dataElements: {
					interval: '7',
					direction: '-1'
				},
				ctor: 'ChordButtons',
				group: 'chords',
				id: 'OctaveDownButton'
			}, {
				icon: '',
				leftText: 'Collapse',
				rightText: '',
				classes: 'collapsed addChord dirdown',
				action: 'collapseChild',
				ctor: 'ChordButtons',
				group: 'chords',
				id: 'CollapseChordButton'
			}
		];
	}

	static get leftRibbonButtons() {
		return [{
				icon: '',
				leftText: 'Help',
				rightText: '?',
				classes: 'help-button',
				action: 'modal',
				ctor: 'helpModal',
				group: 'scoreEdit',
				id: 'helpDialog'
			}, {
				leftText: 'Language',
				rightText: '/n',
				icon: '',
				classes: 'language-select menu-select',
				action: 'menu',
				ctor: 'SuiLanguageMenu',
				group: 'scoreEdit',
				id: 'languageMenu'
			}, {
				leftText: 'File',
				rightText: '/f',
				icon: '',
				classes: 'file-modify menu-select',
				action: 'menu',
				ctor: 'SuiFileMenu',
				group: 'scoreEdit',
				id: 'fileMenu'
			},
			 {
				leftText: 'Tempo',
				rightText: 't',
				icon: '',
				classes: 'icon ',
				action: 'modal',
				ctor: 'SuiTempoDialog',
				group: 'scoreEdit',
				id: 'tempoModal'
			},{
				leftText: 'Time Signature',
				rightText: '/m',
				icon: '',
				classes: 'staff-modify menu-select',
				action: 'menu',
				ctor: 'SuiTimeSignatureMenu',
				group: 'scoreEdit',
				id: 'timeSignatureMenu'
			}, {
				leftText: 'Staves',
				rightText: '/s',
				icon: '',
				classes: 'staff-modify',
				action: 'menu',
				ctor: 'SuiAddStaffMenu',
				group: 'scoreEdit',
				id: 'addStaffMenu'
			},
      {
         leftText: 'Measure',
         rightText: '/a',
         icon: '',
         classes: 'icon menu-select',
         action: 'menu',
         ctor: 'SuiMeasureMenu',
         group: 'scoreEdit',
         id: 'measureModal'
      },
      {
				leftText: 'Key',
				rightText: '/k',
				icon: '',
				classes: 'note-modify menu-select',
				action: 'menu',
				ctor: 'SuiKeySignatureMenu',
				group: 'scoreEdit',
				id: 'keyMenu'
			},
      {
       leftText: 'Instrument',
       rightText: '',
       icon: '',
       classes: 'icon',
       action: 'modal',
       ctor: 'SuiInstrumentDialog',
       group: 'scoreEdit',
       id: 'instrumentModal'
     },
      {
				leftText: 'Lines',
				rightText: '/l',
				icon: '',
				classes: 'icon note-modify menu-select',
				action: 'menu',
				ctor: 'SuiStaffModifierMenu',
				group: 'scoreEdit',
				id: 'staffModifierMenu'
			},
			 {
				leftText: 'Piano',
				rightText: '',
				icon: '',
				classes: 'icon keyboard',
				action: 'modal',
				ctor: 'suiPiano',
				group: 'scoreEdit',
				id: 'pianoModal'
			},
			 {
				leftText: 'Layout',
				rightText: '',
				icon: '',
				classes: 'icon ',
				action: 'modal',
				ctor: 'SuiLayoutDialog',
				group: 'scoreEdit',
				id: 'layoutModal'
			}
		];
	}
}
;

class vexGlyph {
	static accidental(a) {
       return vexGlyph.accidentals[a];
	}
	static barWidth(b) {
		var str = SmoBarline.barlineString(b);
		var cc = vexGlyph.dimensions[str];
		return cc.width+cc.spacingRight;
	}
	static get accidentals() {
		return {
		'b':vexGlyph.dimensions.flat,
		'#':vexGlyph.dimensions.sharp,
		'bb':vexGlyph.dimensions.doubleFlat,
		'##':vexGlyph.dimensions.doubleSharp,
		'n':vexGlyph.dimensions.natural
		};
	}

    static get tempo() {
        return vexGlyph.dimensions['tempo'];
    }
	static keySignatureLength(key) {
		return smoMusic.getSharpsInKeySignature(key)*vexGlyph.dimensions['sharp'].width +
		    smoMusic.getFlatsInKeySignature(key)*vexGlyph.dimensions['flat'].width +
			vexGlyph.dimensions['keySignature'].spacingRight;
	}
	static get timeSignature() {
		return vexGlyph.dimensions['timeSignature'];
	}
	static get dot() {
		return vexGlyph.dimensions['dot'];
	}

  static get tupletBeam() {
    return vexGlyph.dimensions['tupletBeam'];
  }

  static get stem() {
      return vexGlyph.dimensions['stem'];
  }
  static get flag() {
      return vexGlyph.dimensions['flag'];
  }

	static clef(c) {
		var key = c.toLowerCase()+'Clef';
		if (!vexGlyph.dimensions[key]) {
			return vexGlyph.dimensions['tenorClef'];
		}
		return vexGlyph.dimensions[key];
	}
	static get dimensions() {
		return {
      tupletBeam: {
        width:5,
  			height:6,
        yTop:0,
        yBottom:0,
  			spacingRight:5
      },
  		singleBar: {
  			width:1,
  			height:41,
        yTop:0,
        yBottom:0,
  			spacingRight:5
  		},
  		endBar: {
  			width:5.22,
  			height:40.99,
        yTop:0,
        yBottom:0,
  			spacingRight:10
  		},
  		doubleBar: {
  			width:3.22,
  			height:40.99,
        yTop:0,
        yBottom:0,
  			spacingRight:0
  		},
  		endRepeat: {
  			width:6,
  			height:40.99,
        yTop:0,
        yBottom:0,
  			spacingRight:0,
  		},
  		startRepeat: {
  			width:6,
  			height:40.99,
        yTop:0,
        yBottom:0,
  			spacingRight:5,
  		},
  		noteHead: {
  			width:12.02,
  			height:10.48,
        yTop:0,
        yBottom:0,
  			spacingRight:10,
  		},
  		dot: {
  			width:5,
  			height:5,
  			spacingRight:2
  		},
  		trebleClef: {
  			width: 25.5,
  			height: 68.32,
        yTop:14,
        yBottom:14,
  			spacingRight: 10,
  		},
  		bassClef: {
  			width: 25,
  			height: 31.88,
        yTop:0,
        yBottom:0,
  			spacingRight: 5,
  		},
  		altoClef: {
  			width: 31.5,
        yTop:0,
        yBottom:0,
  			height: 85.5,
  			spacingRight: 10
  		},
  		tenorClef: {
  			width: 31.5,
        yTop:10,
        yBottom:0,
  			height: 41,
  			spacingRight: 10
  		},
  		timeSignature: {
  			width: 13.48,
  			height: 85,
        yTop:0,
        yBottom:0,
  			spacingRight: 5
  		},
      tempo : {
        width:10,
        height:37,
        yTop:37,
        yBottom:0,
        spacingRight:0
      },
  		flat: {
  			width: 7.44,
  			height: 23.55,
        yTop:0,
        yBottom:0,
  			spacingRight: 2
  		},
  		keySignature: {
  			width: 0,
  			height: 85.5,
        yTop:0,
        yBottom:0,
  			spacingRight: 10
  		},
  		sharp: {
  			width: 8.84,
  			height: 62,
        yTop:0,
        yBottom:0,
  			spacingRight: 2
  		},
  		natural: {
  			width: 6.54,
  			height: 53.35,
        yTop:0,
        yBottom:0,
  			spacingRight: 2
  		},
  		doubleSharp: {
  			height: 10.04,
  			width: 21.63,
        yTop:0,
        yBottom:0,
  			spacingRight: 2
  		},
  		doubleFlat: {
  			width: 13.79,
  			height: 49.65,
        yTop:0,
        yBottom:0,
  			spacingRight:2
  		},stem: {
        width:1,
        height:35,
        yTop:0,
        yBottom:0,
  			spacingRight:0
      },flag: {
        width:10,
        height:35,
        yTop:0,
        yBottom:0,
  			spacingRight:0
      }
		};
	}
}
;var yamaJson = `{"a":{"b":{"c":30,"d":30,"e":50,"f":40,"g":816,"h":1056,"i":0,"j":30,"k":10,"l":0.7,"m":1.9162210338680927,"n":2,"o":2},"q":0,"r":{},"ce":"Petaluma"},"s":[{"t":0,"u":10,"v":40,"w":0,"x":1600,"y":90,"q":0,"r":{},"z":{},"aa":{"ba":"Treble Instrument","ca":"0","da":"treble"},"ea":[{"fa":{"ga":0,"ha":0,"ia":0,"ja":2,"ka":[]},"la":{"ga":0,"ha":0,"ia":0,"ja":3,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":2,"ia":0,"ja":2,"ka":[]},"la":{"ga":0,"ha":2,"ia":0,"ja":3,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":2,"ia":0,"ja":2,"ka":[]},"la":{"ga":0,"ha":2,"ia":0,"ja":3,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":5,"ia":0,"ja":3,"ka":[]},"la":{"ga":0,"ha":5,"ia":0,"ja":4,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":6,"ia":0,"ja":3,"ka":[]},"la":{"ga":0,"ha":6,"ia":0,"ja":4,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":1,"ia":0,"ja":2,"ka":[]},"la":{"ga":0,"ha":1,"ia":0,"ja":3,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":3,"ia":0,"ja":2,"ka":[]},"la":{"ga":0,"ha":3,"ia":0,"ja":3,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":7,"ia":0,"ja":3,"ka":[]},"la":{"ga":0,"ha":7,"ia":0,"ja":4,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":10,"ia":0,"ja":1,"ka":[]},"la":{"ga":0,"ha":10,"ia":0,"ja":2,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":10,"ia":0,"ja":4,"ka":[]},"la":{"ga":0,"ha":10,"ia":0,"ja":5,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":11,"ia":0,"ja":4,"ka":[]},"la":{"ga":0,"ha":11,"ia":0,"ja":5,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":15,"ia":0,"ja":1,"ka":[]},"la":{"ga":0,"ha":15,"ia":0,"ja":2,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":16,"ia":0,"ja":1,"ka":[]},"la":{"ga":0,"ha":16,"ia":0,"ja":2,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":17,"ia":0,"ja":12,"ka":[]},"la":{"ga":0,"ha":17,"ia":0,"ja":13,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":17,"ia":0,"ja":14,"ka":[]},"la":{"ga":0,"ha":18,"ia":0,"ja":0,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":18,"ia":0,"ja":9,"ka":[]},"la":{"ga":0,"ha":18,"ia":0,"ja":10,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":20,"ia":0,"ja":15,"ka":[]},"la":{"ga":0,"ha":20,"ia":0,"ja":16,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":25,"ia":0,"ja":12,"ka":[]},"la":{"ga":0,"ha":25,"ia":0,"ja":13,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":25,"ia":0,"ja":16,"ka":[]},"la":{"ga":0,"ha":26,"ia":0,"ja":0,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":24,"ia":0,"ja":8,"ka":[]},"la":{"ga":0,"ha":24,"ia":0,"ja":9,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":25,"ia":0,"ja":8,"ka":[]},"la":{"ga":0,"ha":25,"ia":0,"ja":9,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":26,"ia":0,"ja":1,"ka":[]},"la":{"ga":0,"ha":26,"ia":0,"ja":2,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":26,"ia":0,"ja":11,"ka":[]},"la":{"ga":0,"ha":26,"ia":0,"ja":12,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":29,"ia":0,"ja":1,"ka":[]},"la":{"ga":0,"ha":29,"ia":0,"ja":2,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":36,"ia":0,"ja":1,"ka":[]},"la":{"ga":0,"ha":36,"ia":0,"ja":2,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":36,"ia":0,"ja":9,"ka":[]},"la":{"ga":0,"ha":36,"ia":0,"ja":10,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":36,"ia":0,"ja":11,"ka":[]},"la":{"ga":0,"ha":36,"ia":0,"ja":12,"ka":[]},"ua":4,"sa":"SmoSlur"}],"va":[{"ya":{"ya":0,"za":0,"ab":0,"t":0},"transposeIndex":2,"bb":77.42,"cb":[{"pa":{"qa":"auto196875","ra":"SmoTuplet"},"q":3},{"pa":{"qa":"auto203439","ra":"SmoTuplet"},"q":6},{"ud":[2,1],"pa":{"qa":"auto210860","ra":"SmoTuplet"},"q":1}],"db":[{"eb":[{"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble","sb":[{"parser":2,"gc":8,"sa":"SmoLyric","_text":"G^-7 "}]},{"fb":{"gb":2730,"hb":1,"ib":1},"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","od":{"qa":"auto210860","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":1365,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"od":{"qa":"auto210860","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":1365,"hb":1,"ib":1},"ka":[{"jb":"a","lb":"n","kb":4}],"od":{"qa":"auto196875","ra":"SmoTuplet"},"da":"treble","sb":[{"parser":2,"gc":12,"sa":"SmoLyric","_text":"C^7 "}]},{"fb":{"gb":1365,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"od":{"qa":"auto196875","ra":"SmoTuplet"},"da":"treble","noteHead":""},{"fb":{"gb":1365,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"od":{"qa":"auto196875","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":1365,"hb":1,"ib":1},"ka":[{"jb":"a","lb":"n","kb":4}],"od":{"qa":"auto203439","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":1365,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"od":{"qa":"auto203439","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":1365,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":4}],"od":{"qa":"auto203439","ra":"SmoTuplet"},"da":"treble"}]}],"ea":[]},{"ya":{"ya":1,"za":1,"ab":1,"t":0},"transposeIndex":2,"bb":6,"cb":[{"ud":[2,1],"pa":{"qa":"auto11224","ra":"SmoTuplet"},"q":1},{"pa":{"qa":"auto11233","ra":"SmoTuplet"},"q":3},{"pa":{"qa":"auto11240","ra":"SmoTuplet"},"q":6}],"db":[{"eb":[{"ka":[{"jb":"d","lb":"n","kb":4}],"da":"treble","sb":[{"parser":2,"gc":13,"sa":"SmoLyric","_text":"G^-7 "}]},{"fb":{"gb":2730,"hb":1,"ib":1},"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","od":{"qa":"auto11224","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":1365,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"od":{"qa":"auto11224","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":1365,"hb":1,"ib":1},"ka":[{"jb":"a","lb":"n","kb":4}],"od":{"qa":"auto11233","ra":"SmoTuplet"},"da":"treble","sb":[{"parser":2,"gc":9,"sa":"SmoLyric","_text":"C7 "}]},{"fb":{"gb":1365,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"od":{"qa":"auto11233","ra":"SmoTuplet"},"da":"treble","sb":[{"parser":2,"sa":"SmoLyric"}]},{"fb":{"gb":1365,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"od":{"qa":"auto11233","ra":"SmoTuplet"},"da":"treble","sb":[{"parser":2,"sa":"SmoLyric"}]},{"fb":{"gb":1365,"hb":1,"ib":1},"ka":[{"jb":"a","lb":"n","kb":4}],"od":{"qa":"auto11240","ra":"SmoTuplet"},"da":"treble","sb":[{"parser":2,"sa":"SmoLyric"}]},{"fb":{"gb":1365,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"od":{"qa":"auto11240","ra":"SmoTuplet"},"da":"treble","sb":[{"parser":2,"sa":"SmoLyric"}]},{"fb":{"gb":1365,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":4}],"od":{"qa":"auto11240","ra":"SmoTuplet"},"da":"treble","sb":[{"parser":2,"sa":"SmoLyric"}]}]}],"ea":[]},{"ya":{"ya":2,"za":2,"ab":2,"t":0},"transposeIndex":2,"bb":6,"be":83,"cb":[{"ud":[2,1],"pa":{"qa":"auto8246","ra":"SmoTuplet"},"q":1},{"pa":{"qa":"auto8256","ra":"SmoTuplet"},"q":3},{"pa":{"qa":"auto8263","ra":"SmoTuplet"},"q":6}],"db":[{"eb":[{"ka":[{"jb":"d","lb":"n","kb":4}],"da":"treble","sb":[{"parser":2,"sa":"SmoLyric","_text":"G^-7 "}]},{"fb":{"gb":2730,"hb":1,"ib":1},"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","od":{"qa":"auto8246","ra":"SmoTuplet"},"da":"treble","sb":[{"parser":2,"sa":"SmoLyric"}]},{"fb":{"gb":1365,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"od":{"qa":"auto8246","ra":"SmoTuplet"},"da":"treble","sb":[{"parser":2,"sa":"SmoLyric"}]},{"fb":{"gb":1365,"hb":1,"ib":1},"ka":[{"jb":"a","lb":"n","kb":4}],"od":{"qa":"auto8256","ra":"SmoTuplet"},"da":"treble","sb":[{"parser":2,"gc":9,"sa":"SmoLyric","_text":"C^7 "}]},{"fb":{"gb":1365,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"od":{"qa":"auto8256","ra":"SmoTuplet"},"da":"treble","sb":[{"parser":2,"sa":"SmoLyric"}]},{"fb":{"gb":1365,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"od":{"qa":"auto8256","ra":"SmoTuplet"},"da":"treble","sb":[{"parser":2,"sa":"SmoLyric"}]},{"fb":{"gb":1365,"hb":1,"ib":1},"ka":[{"jb":"a","lb":"n","kb":4}],"od":{"qa":"auto8263","ra":"SmoTuplet"},"da":"treble","sb":[{"parser":2,"sa":"SmoLyric"}]},{"fb":{"gb":1365,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"od":{"qa":"auto8263","ra":"SmoTuplet"},"da":"treble","sb":[{"parser":2,"sa":"SmoLyric"}]},{"fb":{"gb":1365,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":4}],"od":{"qa":"auto8263","ra":"SmoTuplet"},"da":"treble","sb":[{"parser":2,"sa":"SmoLyric"}]}]}],"ea":[]},{"ya":{"ya":3,"za":3,"ab":3,"t":0},"transposeIndex":2,"bb":6,"cb":[{"ud":[2,1],"pa":{"qa":"auto31809","ra":"SmoTuplet"},"q":1},{"pa":{"qa":"auto31819","ra":"SmoTuplet"},"q":3},{"pa":{"qa":"auto31826","ra":"SmoTuplet"},"q":6}],"db":[{"eb":[{"ka":[{"jb":"d","lb":"n","kb":4}],"da":"treble","sb":[{"parser":2,"sa":"SmoLyric","_text":"G^-7 "}]},{"fb":{"gb":2730,"hb":1,"ib":1},"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","od":{"qa":"auto31809","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":1365,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"od":{"qa":"auto31809","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":1365,"hb":1,"ib":1},"ka":[{"jb":"a","lb":"n","kb":4}],"od":{"qa":"auto31819","ra":"SmoTuplet"},"da":"treble","sb":[{"parser":2,"gc":10,"sa":"SmoLyric","_text":"C^7 "}]},{"fb":{"gb":1365,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"od":{"qa":"auto31819","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":1365,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"od":{"qa":"auto31819","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":1365,"hb":1,"ib":1},"ka":[{"jb":"g","lb":"n","kb":4}],"od":{"qa":"auto31826","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":1365,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":4}],"od":{"qa":"auto31826","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":1365,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":4}],"oc":"r","od":{"qa":"auto31826","ra":"SmoTuplet"},"da":"treble"}]}],"ea":[{"kd":1,"sa":"SmoBarline"}]},{"ld":true,"ya":{"ya":4,"za":4,"ab":0,"t":0},"transposeIndex":2,"bb":58.94,"cb":[],"db":[{"eb":[{"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","sb":[{"parser":2,"sa":"SmoLyric","_text":"G^-7 "}]},{"ka":[{"jb":"b","lb":"b","kb":4}],"da":"treble","sb":[{"parser":2,"sa":"SmoLyric"}]},{"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","sb":[{"parser":2,"sa":"SmoLyric","_text":"F^Maj7 "}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"da":"treble","sb":[{"parser":2,"sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","sb":[{"parser":2,"sa":"SmoLyric"}]}]}],"ea":[{"sa":"SmoRehearsalMark"}]},{"ya":{"ya":5,"za":5,"ab":1,"t":0},"transposeIndex":2,"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":4}],"da":"treble","sb":[{"parser":2,"sa":"SmoLyric","_text":"Eb^7 "}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"b","kb":4}],"da":"treble","noteHead":"x2","sb":[{"parser":2,"sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":4}],"da":"treble","sb":[{"parser":2,"sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","sb":[{"parser":2,"sa":"SmoLyric"}]},{"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","sb":[{"parser":2,"sa":"SmoLyric","_text":"C^7 "}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"da":"treble"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","sb":[{"parser":2,"sa":"SmoLyric"}]}]}],"ea":[]},{"ya":{"ya":6,"za":6,"ab":2,"t":0},"transposeIndex":2,"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":4}],"da":"treble","sb":[{"parser":2,"sa":"SmoLyric","_text":"Db^7 "}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":4,"pc":true}],"da":"treble","noteHead":"x2","sb":[{"parser":2,"sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":4}],"da":"treble","sb":[{"parser":2,"sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","sb":[{"parser":2,"sa":"SmoLyric"}]},{"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","sb":[{"parser":2,"sa":"SmoLyric","_text":"Ab^-7 "}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":4}],"da":"treble","sb":[{"parser":2,"sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","sb":[{"parser":2,"sa":"SmoLyric"}]}]}],"ea":[]},{"ya":{"ya":7,"za":7,"ab":3,"t":0},"transposeIndex":2,"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble","sb":[{"parser":2,"sa":"SmoLyric","_text":"Eb^7 "}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":4}],"da":"treble","sb":[{"parser":2,"sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble","sb":[{"parser":2,"sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","sb":[{"parser":2,"sa":"SmoLyric"}]},{"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","sb":[{"parser":2,"sa":"SmoLyric","_text":"D^7 "}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"da":"treble"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble"}]}],"ea":[]},{"ld":true,"ya":{"ya":8,"za":8,"ab":0,"t":0},"transposeIndex":2,"bb":58.94,"cb":[],"db":[{"eb":[{"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","sb":[{"parser":2,"sa":"SmoLyric","_text":"G^-7 "}],"fd":[{"hd":"SCOOP","sa":"SmoOrnament"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","sb":[{"parser":2,"sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"da":"treble","sb":[{"parser":2,"sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"#","kb":4}],"da":"treble","sb":[{"parser":2,"sa":"SmoLyric","_text":"D^7+5 "}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":4}],"da":"treble","sb":[{"parser":2,"sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":4}],"da":"treble","sb":[{"parser":2,"sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"#","kb":4}],"da":"treble","sb":[{"parser":2,"sa":"SmoLyric"}]}]}],"ea":[]},{"ya":{"ya":9,"za":9,"ab":1,"t":0},"transposeIndex":2,"bb":6,"cb":[{"pa":{"qa":"auto100919","ra":"SmoTuplet"},"q":1}],"db":[{"eb":[{"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","sb":[{"parser":2,"sa":"SmoLyric","_text":"Eb^7 "}]},{"fb":{"gb":1365,"hb":1,"ib":1},"ka":[{"jb":"e","lb":"b","kb":4}],"od":{"qa":"auto100919","ra":"SmoTuplet"},"da":"treble","sb":[{"parser":2,"sa":"SmoLyric"}]},{"fb":{"gb":1365,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":4}],"od":{"qa":"auto100919","ra":"SmoTuplet"},"da":"treble","sb":[{"parser":2,"sa":"SmoLyric"}]},{"fb":{"gb":1365,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"od":{"qa":"auto100919","ra":"SmoTuplet"},"da":"treble","sb":[{"parser":2,"sa":"SmoLyric"}]},{"ka":[{"jb":"f","lb":"n","kb":4}],"da":"treble","sb":[{"parser":2,"sa":"SmoLyric","_text":"Ab^-7 "}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble","rb":true,"qb":2048,"sb":[{"parser":2,"sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":4}],"da":"treble","sb":[{"parser":2,"sa":"SmoLyric"}]}]}],"ea":[]},{"ya":{"ya":10,"za":10,"ab":2,"t":0},"transposeIndex":2,"bb":6,"be":10,"cb":[],"db":[{"eb":[{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":3}],"da":"treble","sb":[{"parser":2,"sa":"SmoLyric","_text":"G^-7 "}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"#","kb":4}],"da":"treble","sb":[{"parser":2,"sa":"SmoLyric"}]},{"ka":[{"jb":"f","lb":"#","kb":4}],"da":"treble","sb":[{"parser":2,"sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":3}],"da":"treble","sb":[{"parser":2,"sa":"SmoLyric","_text":"F^Maj7 "}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":4}],"da":"treble","sb":[{"parser":2,"sa":"SmoLyric"}]},{"ka":[{"jb":"e","lb":"n","kb":4}],"da":"treble","sb":[{"parser":2,"sa":"SmoLyric"}]}]}],"ea":[]},{"ya":{"ya":11,"za":11,"ab":3,"t":0},"transposeIndex":2,"bb":6,"cb":[{"ud":[2,1],"pa":{"qa":"auto303621","ra":"SmoTuplet"},"q":0},{"pa":{"qa":"auto320948","ra":"SmoTuplet"},"q":6},{"pa":{"qa":"auto10785","ra":"SmoTuplet"},"q":2}],"db":[{"eb":[{"fb":{"gb":2730,"hb":1,"ib":1},"ka":[{"jb":"g","lb":"n","kb":4}],"od":{"qa":"auto303621","ra":"SmoTuplet"},"da":"treble","sb":[{"parser":2,"gc":14,"sa":"SmoLyric","_text":"Eb^7 "}],"qc":[{"ua":"below","rc":"staccato","sa":"SmoArticulation"}]},{"fb":{"gb":1365,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"od":{"qa":"auto303621","ra":"SmoTuplet"},"da":"treble","sb":[{"parser":2,"sa":"SmoLyric"}]},{"fb":{"gb":1365,"hb":1,"ib":1},"ka":[{"jb":"c","lb":"n","kb":5}],"od":{"qa":"auto10785","ra":"SmoTuplet"},"da":"treble","sb":[{"parser":2,"sa":"SmoLyric"}]},{"fb":{"gb":1365,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"b","kb":5}],"od":{"qa":"auto10785","ra":"SmoTuplet"},"da":"treble","sb":[{"parser":2,"sa":"SmoLyric"}]},{"fb":{"gb":1365,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"od":{"qa":"auto10785","ra":"SmoTuplet"},"da":"treble"},{"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","sb":[{"parser":2,"sa":"SmoLyric","_text":"D^7 "}]},{"fb":{"gb":1365,"hb":1,"ib":1},"ka":[{"jb":"a","lb":"b","kb":4}],"oc":"r","od":{"qa":"auto320948","ra":"SmoTuplet"},"da":"treble","rb":true,"qb":1366,"sb":[{"parser":2,"gc":7,"sa":"SmoLyric"}]},{"fb":{"gb":1365,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"od":{"qa":"auto320948","ra":"SmoTuplet"},"da":"treble","rb":true,"qb":1365,"sb":[{"parser":2,"sa":"SmoLyric"}]},{"fb":{"gb":1365,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":4}],"od":{"qa":"auto320948","ra":"SmoTuplet"},"da":"treble","rb":true,"qb":1365}]}],"ea":[]},{"ld":true,"ya":{"ya":12,"za":12,"ab":0,"t":0},"transposeIndex":2,"bb":58.94,"cb":[{"ud":[1,2],"pa":{"qa":"auto46986","ra":"SmoTuplet"},"q":3}],"db":[{"eb":[{"fb":{"gb":8192,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","sb":[{"parser":2,"sa":"SmoLyric","_text":"G^-7 "}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble","rb":true,"qb":2048,"sb":[{"parser":2,"sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","rb":true,"qb":2048,"tc":1,"sb":[{"parser":2,"sa":"SmoLyric","_text":"C^7 "}]},{"fb":{"gb":1365,"hb":1,"ib":1},"ka":[{"jb":"c","lb":"n","kb":5}],"od":{"qa":"auto46986","ra":"SmoTuplet"},"da":"treble","sb":[{"parser":2,"sa":"SmoLyric"}]},{"fb":{"gb":2730,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"od":{"qa":"auto46986","ra":"SmoTuplet"},"da":"treble","sb":[{"parser":2,"sa":"SmoLyric"}]}]}],"ea":[]},{"ya":{"ya":13,"za":13,"ab":1,"t":0},"transposeIndex":2,"bb":6,"cb":[{"td":1024,"ud":[1,1,1,1,1],"pa":{"qa":"auto147967","ra":"SmoTuplet"},"q":1}],"db":[{"eb":[{"fb":{"gb":12288,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","sb":[{"parser":2,"sa":"SmoLyric","_text":"F^7 "}]},{"fb":{"gb":819,"hb":1,"ib":1},"ka":[{"jb":"d","lb":"b","kb":5}],"od":{"qa":"auto147967","ra":"SmoTuplet"},"da":"treble","sb":[{"parser":2,"sa":"SmoLyric","_text":"Bb^7 "}]},{"fb":{"gb":819,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"od":{"qa":"auto147967","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":819,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"od":{"qa":"auto147967","ra":"SmoTuplet"},"da":"treble","sb":[{"parser":2,"sa":"SmoLyric"}]},{"fb":{"gb":819,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"od":{"qa":"auto147967","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":819,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","od":{"qa":"auto147967","ra":"SmoTuplet"},"da":"treble"}]}],"ea":[]},{"ya":{"ya":14,"za":14,"ab":2,"t":0},"transposeIndex":2,"bb":6,"cb":[{"ud":[2,1],"pa":{"qa":"auto127112","ra":"SmoTuplet"},"q":1},{"pa":{"qa":"auto127379","ra":"SmoTuplet"},"q":4}],"db":[{"eb":[{"fb":{"gb":8192,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","sb":[{"parser":2,"sa":"SmoLyric","_text":"Eb^7 "}]},{"fb":{"gb":2730,"hb":1,"ib":1},"ka":[{"jb":"c","lb":"n","kb":4}],"oc":"r","od":{"qa":"auto127112","ra":"SmoTuplet"},"da":"treble","sb":[{"parser":2,"gc":14,"sa":"SmoLyric","_text":"D^7 "}]},{"fb":{"gb":1365,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":4}],"od":{"qa":"auto127112","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":1365,"hb":1,"ib":1},"ka":[{"jb":"f","lb":"n","kb":4}],"od":{"qa":"auto127379","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":1365,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":4}],"od":{"qa":"auto127379","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":1365,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":4}],"od":{"qa":"auto127379","ra":"SmoTuplet"},"da":"treble"}]}],"ea":[]},{"ya":{"ya":15,"za":15,"ab":3,"t":0},"transposeIndex":2,"bb":6,"cb":[{"pa":{"qa":"auto239480","ra":"SmoTuplet"},"q":3}],"db":[{"eb":[{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","sb":[{"parser":2,"sa":"SmoLyric","_text":"G^-7 "}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","rb":true,"qb":2048},{"ka":[{"jb":"g","lb":"n","kb":4}],"od":{},"da":"treble","sb":[{"parser":2,"gc":10,"sa":"SmoLyric","_text":"C^7 "}]},{"fb":{"gb":1365,"hb":1,"ib":1},"ka":[{"jb":"f","lb":"n","kb":4}],"od":{"qa":"auto239480","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":1365,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":4}],"od":{"qa":"auto239480","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":1365,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":4}],"od":{"qa":"auto239480","ra":"SmoTuplet"},"da":"treble"}]}],"ea":[]},{"ya":{"ya":16,"za":16,"ab":4,"t":0},"transposeIndex":2,"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","sb":[{"parser":2,"gc":1,"sa":"SmoLyric","_text":"G^-7 "}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","rb":true,"qb":2048,"sb":[{"parser":2,"sa":"SmoLyric","_text":"C^7 "}]},{"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble"},{"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble"}]}],"ea":[{"kd":1,"sa":"SmoBarline"}]},{"ld":true,"ya":{"ya":17,"za":17,"ab":0,"t":0},"transposeIndex":2,"bb":58.94,"be":-25,"cb":[{"ud":[1,1,0.5,0.5],"pa":{"qa":"auto32682","ra":"SmoTuplet"},"q":8}],"db":[{"eb":[{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble","sb":[{"parser":2,"sa":"SmoLyric","_text":"G^-7 "}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","sb":[{"parser":2,"sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":5}],"da":"treble","sb":[{"parser":2,"sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":5}],"oc":"r","da":"treble","sb":[{"parser":2,"sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":5}],"da":"treble","sb":[{"parser":2,"sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":6}],"da":"treble","sb":[{"parser":2,"sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":5}],"oc":"r","da":"treble","sb":[{"parser":2,"sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":5}],"da":"treble","sb":[{"parser":2,"sa":"SmoLyric"}]},{"fb":{"gb":1365,"hb":1,"ib":2},"ka":[{"jb":"g","lb":"n","kb":5}],"od":{"qa":"auto32682","ra":"SmoTuplet"},"da":"treble","sb":[{"parser":2,"gc":9,"sa":"SmoLyric","_text":"F^Maj7 "}]},{"fb":{"gb":1365,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"od":{"qa":"auto32682","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":682,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"od":{"qa":"auto32682","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":682,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"od":{"qa":"auto32682","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"b","kb":4}],"da":"treble"}]}],"ea":[]},{"ya":{"ya":18,"za":18,"ab":1,"t":0},"transposeIndex":2,"bb":6,"be":55,"de":12,"cb":[{"td":1024,"sd":2048,"pa":{"qa":"auto439759","ra":"SmoTuplet"},"q":1},{"ud":[1,2],"pa":{"qa":"auto152250","ra":"SmoTuplet"},"q":6},{"td":1024,"sd":2048,"pa":{"qa":"auto193687","ra":"SmoTuplet"},"q":5}],"db":[{"eb":[{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"b","kb":4}],"da":"treble","sb":[{"parser":2,"gc":10,"sa":"SmoLyric","_text":"Eb^7 "}]},{"fb":{"gb":682,"hb":1,"ib":2},"ka":[{"jb":"f","lb":"n","kb":4}],"od":{"qa":"auto439759","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":682,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"od":{"qa":"auto439759","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":682,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"od":{"qa":"auto439759","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":682,"hb":1,"ib":2},"ka":[{"jb":"g","lb":"n","kb":4}],"od":{"qa":"auto193687","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":682,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"od":{"qa":"auto193687","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":682,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"od":{"qa":"auto193687","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":1365,"hb":1,"ib":1},"ka":[{"jb":"e","lb":"n","kb":4}],"od":{"qa":"auto152250","ra":"SmoTuplet"},"da":"treble","sb":[{"parser":2,"gc":16,"sa":"SmoLyric","_text":"C^7 "}],"fd":[{"hd":"SCOOP","sa":"SmoOrnament"}]},{"fb":{"gb":2730,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":4}],"od":{"qa":"auto152250","ra":"SmoTuplet"},"da":"treble"},{"ka":[{"jb":"c","lb":"n","kb":4}],"da":"treble"}]}],"ea":[]},{"ya":{"ya":19,"za":19,"ab":0,"t":0},"transposeIndex":2,"bb":58.94,"be":41,"de":12,"cb":[],"db":[{"eb":[{"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble","sb":[{"parser":2,"sa":"SmoLyric","_text":"Db^7 "}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"b","kb":4}],"da":"treble","sb":[{"parser":2,"sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":4}],"da":"treble","sb":[{"parser":2,"sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","sb":[{"parser":2,"sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"da":"treble","sb":[{"parser":2,"sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"b","kb":4}],"da":"treble","sb":[{"parser":2,"sa":"SmoLyric","_text":"Ab^-7 "}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"b","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"b","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"b","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"b","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"b","kb":4}],"da":"treble"}]}],"ea":[]},{"ya":{"ya":20,"za":20,"ab":1,"t":0},"transposeIndex":2,"bb":6,"cb":[{"td":1024,"sd":2048,"pa":{"qa":"auto52582","ra":"SmoTuplet"},"q":5},{"td":1024,"sd":2048,"pa":{"qa":"auto273903","ra":"SmoTuplet"},"q":10}],"db":[{"eb":[{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble","rb":true,"qb":2048,"sb":[{"parser":2,"sa":"SmoLyric","_text":"Eb^7 "}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"b","kb":4}],"da":"treble","sb":[{"parser":2,"sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":4}],"da":"treble","rb":true,"qb":1024,"sb":[{"parser":2,"sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"da":"treble","sb":[{"parser":2,"sa":"SmoLyric"}]},{"fb":{"gb":682,"hb":1,"ib":2},"ka":[{"jb":"a","lb":"n","kb":4}],"od":{"qa":"auto52582","ra":"SmoTuplet"},"da":"treble","sb":[{"parser":2,"sa":"SmoLyric"}]},{"fb":{"gb":682,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"od":{"qa":"auto52582","ra":"SmoTuplet"},"da":"treble","sb":[{"parser":2,"sa":"SmoLyric"}]},{"fb":{"gb":682,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"od":{"qa":"auto52582","ra":"SmoTuplet"},"da":"treble","sb":[{"parser":2,"sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","sb":[{"parser":2,"sa":"SmoLyric","_text":"D^7 "}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":682,"hb":1,"ib":2},"ka":[{"jb":"f","lb":"#","kb":4}],"od":{"qa":"auto273903","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":682,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"od":{"qa":"auto273903","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":682,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"od":{"qa":"auto273903","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":512,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"b","kb":5}],"da":"treble","qb":2048},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":5}],"da":"treble","qb":2048},{"fb":{"gb":512,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","rb":true,"qb":2048},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":2048},{"fb":{"gb":512,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","qb":2048},{"fb":{"gb":512,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","rb":true,"qb":2048}]}],"ea":[]},{"ya":{"ya":21,"za":21,"ab":0,"t":0},"transposeIndex":2,"bb":58.94,"cb":[],"db":[{"eb":[{"ka":[{"jb":"b","lb":"b","kb":4}],"da":"treble","sb":[{"parser":2,"sa":"SmoLyric","_text":"G^-7 "}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble","sb":[{"parser":2,"sa":"SmoLyric"}]},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","sb":[{"parser":2,"sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"b","kb":5}],"da":"treble","sb":[{"parser":2,"gc":6,"sa":"SmoLyric","_text":"D^7+5 "}]},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"b","kb":5}],"da":"treble","sb":[{"parser":2,"sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"b","kb":4}],"da":"treble","sb":[{"parser":2,"sa":"SmoLyric"}]},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"b","kb":4}],"da":"treble","sb":[{"parser":2,"sa":"SmoLyric"}]}]}],"ea":[]},{"ya":{"ya":22,"za":22,"ab":1,"t":0},"transposeIndex":2,"bb":6,"de":-8,"cb":[],"db":[{"eb":[{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble","rb":true,"qb":2048,"sb":[{"parser":2,"sa":"SmoLyric","_text":"Db^7 "}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"b","kb":4}],"da":"treble","qb":2048,"sb":[{"parser":2,"sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":4}],"da":"treble","rb":true,"qb":2048,"sb":[{"parser":2,"sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","sb":[{"parser":2,"sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"da":"treble","sb":[{"parser":2,"sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"b","kb":4}],"da":"treble","sb":[{"parser":2,"sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"da":"treble","sb":[{"parser":2,"sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","sb":[{"parser":2,"sa":"SmoLyric","_text":"Ab-7 "}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"b","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"b","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"b","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"b","kb":5}],"da":"treble","rb":true,"qb":1024},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"oc":"r","da":"treble"}]}],"ea":[]},{"ya":{"ya":23,"za":23,"ab":2,"t":0},"transposeIndex":2,"bb":6,"cb":[],"db":[{"eb":[{"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble","sb":[{"parser":2,"gc":13,"sa":"SmoLyric","_text":"G^-7 "}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"b","kb":5}],"da":"treble","sb":[{"parser":2,"sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":5}],"da":"treble","sb":[{"parser":2,"sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":6}],"da":"treble","sb":[{"parser":2,"sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":5}],"da":"treble","sb":[{"parser":2,"sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":5}],"da":"treble","sb":[{"parser":2,"sa":"SmoLyric","_text":"F^Maj7 "}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"#","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"#","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"#","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"da":"treble"}]}],"ea":[]},{"ya":{"ya":24,"za":24,"ab":0,"t":0},"transposeIndex":2,"bb":58.94,"cb":[{"td":1024,"sd":2048,"pa":{"qa":"auto639348","ra":"SmoTuplet"},"q":0},{"td":1024,"sd":2048,"pa":{"qa":"auto1649531","ra":"SmoTuplet"},"q":4},{"td":1024,"sd":2048,"pa":{"qa":"auto1805448","ra":"SmoTuplet"},"q":10}],"db":[{"eb":[{"fb":{"gb":682,"hb":1,"ib":2},"ka":[{"jb":"a","lb":"n","kb":4}],"od":{"qa":"auto639348","ra":"SmoTuplet"},"da":"treble","sb":[{"parser":2,"gc":17,"sa":"SmoLyric","_text":"Eb^7 "}]},{"fb":{"gb":682,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"od":{"qa":"auto639348","ra":"SmoTuplet"},"da":"treble","sb":[{"parser":2,"sa":"SmoLyric"}]},{"fb":{"gb":682,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"od":{"qa":"auto639348","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","rb":true},{"fb":{"gb":682,"hb":1,"ib":2},"ka":[{"jb":"g","lb":"n","kb":4}],"od":{"qa":"auto1649531","ra":"SmoTuplet"},"da":"treble","qb":684},{"fb":{"gb":682,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"od":{"qa":"auto1649531","ra":"SmoTuplet"},"da":"treble","rb":true,"qb":682},{"fb":{"gb":682,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"od":{"qa":"auto1649531","ra":"SmoTuplet"},"da":"treble","rb":true,"qb":682},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":5}],"da":"treble","qb":2048},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"b","kb":5}],"da":"treble","rb":true,"qb":2048},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"b","kb":5}],"da":"treble","sb":[{"parser":2,"sa":"SmoLyric","_text":"D^7 "}]},{"fb":{"gb":682,"hb":1,"ib":2},"ka":[{"jb":"b","lb":"b","kb":4}],"od":{"qa":"auto1805448","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":682,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"od":{"qa":"auto1805448","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":682,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"od":{"qa":"auto1805448","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"b","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":4}],"da":"treble"}]}],"ea":[]},{"ya":{"ya":25,"za":25,"ab":1,"t":0},"transposeIndex":2,"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":3}],"da":"treble","sb":[{"parser":2,"gc":9,"sa":"SmoLyric","_text":"G^-7 "}]},{"fb":{"gb":512,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":512,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"da":"treble"},{"fb":{"gb":512,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":512,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"b","kb":4}],"oc":"r","da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"da":"treble","sb":[{"parser":2,"sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","sb":[{"parser":2,"sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":5}],"da":"treble","sb":[{"parser":2,"gc":5,"sa":"SmoLyric","_text":"C^7 "}],"fd":[{"hd":"SCOOP","sa":"SmoOrnament"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"oc":"r","da":"treble","sb":[{"parser":2,"sa":"SmoLyric"}]}]}],"ea":[]},{"ya":{"ya":26,"za":26,"ab":0,"t":0},"transposeIndex":2,"bb":58.94,"cb":[{"td":1024,"sd":2048,"pa":{"qa":"auto2041825","ra":"SmoTuplet"},"q":11}],"db":[{"eb":[{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble","qb":2048,"sb":[{"parser":2,"sa":"SmoLyric","_text":"F^7 "}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":2048},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":2048},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":5}],"da":"treble","qb":2048},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"b","kb":5}],"da":"treble","sb":[{"parser":2,"sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","sb":[{"parser":2,"sa":"SmoLyric","_text":"Bb^7 "}],"md":[{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"slash":true,"sa":"SmoGraceNote"}]},{"fb":{"gb":682,"hb":1,"ib":2},"ka":[{"jb":"b","lb":"b","kb":4}],"od":{"qa":"auto2041825","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":682,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"od":{"qa":"auto2041825","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":682,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"od":{"qa":"auto2041825","ra":"SmoTuplet"},"da":"treble","rb":true},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"da":"treble"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"b","kb":4}],"oc":"r","od":{},"da":"treble"}]}],"ea":[]},{"ya":{"ya":27,"za":27,"ab":1,"t":0},"transposeIndex":2,"bb":6,"cb":[{"td":1024,"sd":2048,"pa":{"qa":"auto2138794","ra":"SmoTuplet"},"q":7},{"td":1024,"sd":2048,"pa":{"qa":"auto2410639","ra":"SmoTuplet"},"q":10}],"db":[{"eb":[{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"#","kb":5}],"oc":"r","da":"treble","rb":true,"qb":1024,"sb":[{"parser":2,"sa":"SmoLyric","_text":"Eb^7 "}]},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"b","kb":5}],"da":"treble","qb":2048},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"da":"treble"},{"fb":{"gb":682,"hb":1,"ib":2},"ka":[{"jb":"a","lb":"n","kb":4}],"od":{"qa":"auto2138794","ra":"SmoTuplet"},"da":"treble","sb":[{"parser":2,"gc":20,"sa":"SmoLyric","_text":"D^7 "}]},{"fb":{"gb":682,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"od":{"qa":"auto2138794","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":682,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"od":{"qa":"auto2138794","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":4}],"da":"treble","rb":true},{"fb":{"gb":682,"hb":1,"ib":2},"ka":[{"jb":"f","lb":"#","kb":4}],"od":{"qa":"auto2410639","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":682,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"od":{"qa":"auto2410639","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":682,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"od":{"qa":"auto2410639","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"b","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":5}],"da":"treble","rb":true}]}],"ea":[]},{"ld":true,"ya":{"ya":28,"za":28,"ab":0,"t":0},"transposeIndex":2,"bb":58.94,"cb":[{"pa":{"qa":"auto310764","ra":"SmoTuplet"},"q":1},{"td":1024,"sd":2048,"pa":{"qa":"auto1286701","ra":"SmoTuplet"},"q":8},{"td":1024,"sd":2048,"pa":{"qa":"auto1323888","ra":"SmoTuplet"},"q":11}],"db":[{"eb":[{"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","sb":[{"parser":2,"sa":"SmoLyric","_text":"G^-7 "}]},{"fb":{"gb":1365,"hb":1,"ib":1},"ka":[{"jb":"d","lb":"n","kb":5}],"oc":"r","od":{"qa":"auto310764","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":1365,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":5}],"od":{"qa":"auto310764","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":1365,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":5}],"od":{"qa":"auto310764","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":5}],"da":"treble","sb":[{"parser":2,"sa":"SmoLyric","_text":"C^7 "}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":682,"hb":1,"ib":2},"ka":[{"jb":"e","lb":"n","kb":5}],"od":{"qa":"auto1286701","ra":"SmoTuplet"},"da":"treble","md":[{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"#","kb":5}],"slash":true,"sa":"SmoGraceNote"}]},{"fb":{"gb":682,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"oc":"r","od":{"qa":"auto1286701","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":682,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"od":{"qa":"auto1286701","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":682,"hb":1,"ib":2},"ka":[{"jb":"b","lb":"b","kb":4}],"od":{"qa":"auto1323888","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":682,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"od":{"qa":"auto1323888","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":682,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"od":{"qa":"auto1323888","ra":"SmoTuplet"},"da":"treble"}]}],"ea":[]},{"ya":{"ya":29,"za":29,"ab":1,"t":0},"transposeIndex":2,"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","sb":[{"parser":2,"sa":"SmoLyric","_text":"G^-7 "}],"md":[{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"slash":true,"sa":"SmoGraceNote"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble"},{"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble"},{"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble","sb":[{"parser":2,"sa":"SmoLyric","_text":"C^7 "}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":6}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":5}],"da":"treble"}]}],"ea":[{"kd":1,"sa":"SmoBarline"}]},{"ld":true,"ya":{"ya":30,"za":30,"ab":0,"t":0},"transposeIndex":2,"bb":58.94,"cb":[],"db":[{"eb":[{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":6}],"da":"treble","sb":[{"parser":2,"sa":"SmoLyric","_text":"G^-7 "}]},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","sb":[{"parser":2,"sa":"SmoLyric","_text":"F^Maj "}]},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":4}],"da":"treble"}]}],"ea":[]},{"ya":{"ya":31,"za":31,"ab":1,"t":0},"transposeIndex":2,"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"b","kb":4}],"da":"treble","sb":[{"parser":2,"sa":"SmoLyric","_text":"Eb^7 "}]},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","sb":[{"parser":2,"sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"da":"treble","sb":[{"parser":2,"sa":"SmoLyric"}]},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","sb":[{"parser":2,"sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":4}],"da":"treble","sb":[{"parser":2,"sa":"SmoLyric","_text":"C^7 "}]},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":4}],"da":"treble","sb":[{"parser":2,"sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":3}],"da":"treble","sb":[{"parser":2,"sa":"SmoLyric"}]},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":4}],"da":"treble","sb":[{"parser":2,"sa":"SmoLyric"}]}]}],"ea":[]},{"ya":{"ya":32,"za":32,"ab":2,"t":0},"transposeIndex":2,"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"b","kb":4}],"da":"treble","sb":[{"parser":2,"sa":"SmoLyric","_text":"Db^7 "}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"b","kb":4}],"da":"treble","sb":[{"parser":2,"sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":4}],"da":"treble","sb":[{"parser":2,"sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"da":"treble","sb":[{"parser":2,"sa":"SmoLyric"}],"fd":[{"hd":"FALL_SHORT","sa":"SmoOrnament"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble","rb":true,"qb":1024,"sb":[{"parser":2,"sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"b","kb":4}],"da":"treble","qb":3072},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"b","kb":4}],"da":"treble","qb":3072},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"da":"treble","rb":true,"qb":3072},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"b","kb":5}],"da":"treble","sb":[{"parser":2,"sa":"SmoLyric","_text":"Ab^-7 "}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"b","kb":5,"pc":true}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"b","kb":5,"pc":true}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"b","kb":5}],"da":"treble","rb":true},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"b","kb":4}],"da":"treble","rb":true,"qb":1024},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble","rb":true,"qb":2048}]}],"ea":[]},{"ya":{"ya":33,"za":33,"ab":0,"t":0},"transposeIndex":2,"bb":58.94,"cb":[],"db":[{"eb":[{"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble","sb":[{"parser":2,"sa":"SmoLyric","_text":"Eb^7 "}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble","rb":true,"qb":2048},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":5}],"da":"treble","rb":true,"qb":1024},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":5}],"da":"treble","sb":[{"parser":2,"sa":"SmoLyric","_text":"D^7 "}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":6}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":5}],"da":"treble","rb":true},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":5}],"da":"treble","sb":[{"parser":2,"sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"#","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"b","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"#","kb":5}],"da":"treble"}]}],"ea":[]},{"ya":{"ya":34,"za":34,"ab":1,"t":0},"transposeIndex":2,"bb":6,"be":9,"cb":[{"td":1024,"sd":2048,"pa":{"qa":"auto2828176","ra":"SmoTuplet"},"q":1}],"db":[{"eb":[{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":5}],"da":"treble","sb":[{"parser":2,"sa":"SmoLyric","_text":"G^-7 "}]},{"fb":{"gb":682,"hb":1,"ib":2},"ka":[{"jb":"e","lb":"n","kb":5}],"od":{"qa":"auto2828176","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":682,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"od":{"qa":"auto2828176","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":682,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"od":{"qa":"auto2828176","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","sb":[{"parser":2,"sa":"SmoLyric","_text":"D^7+5 "}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"b","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"b","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"#","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"#","kb":4}],"da":"treble","rb":true,"qb":1024},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"#","kb":4}],"oc":"r","da":"treble"}]}],"ea":[]},{"ya":{"ya":35,"za":35,"ab":2,"t":0},"transposeIndex":2,"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":4}],"oc":"r","da":"treble","rb":true,"qb":2048,"sb":[{"parser":2,"sa":"SmoLyric","_text":"Eb^7 "}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"b","kb":4}],"da":"treble","rb":true,"qb":1024},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"b","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble","rb":true},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"b","kb":5,"pc":true}],"da":"treble","sb":[{"parser":2,"sa":"SmoLyric","_text":"Ab^-7 "}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"b","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4,"pc":false}],"da":"treble"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"b","kb":4}],"da":"treble"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"b","kb":5}],"da":"treble"}]}],"ea":[]},{"ld":true,"ya":{"ya":36,"za":36,"ab":0,"t":0},"transposeIndex":2,"bb":58.94,"cb":[{"td":1024,"sd":2048,"pa":{"qa":"auto1152853","ra":"SmoTuplet"},"q":4}],"db":[{"eb":[{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble","qb":2048,"sb":[{"parser":2,"sa":"SmoLyric","_text":"G^-7 "}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":2048,"fd":[{"hd":"SCOOP","sa":"SmoOrnament"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":2048},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"da":"treble","qb":2048},{"fb":{"gb":682,"hb":1,"ib":2},"ka":[{"jb":"a","lb":"n","kb":4}],"od":{"qa":"auto1152853","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":682,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"od":{"qa":"auto1152853","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":682,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"od":{"qa":"auto1152853","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"b","kb":4}],"oc":"r","da":"treble","rb":true},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":5}],"da":"treble","qb":3072,"sb":[{"parser":2,"gc":6,"sa":"SmoLyric","_text":"F^Maj7 "}],"fd":[{"hd":"SCOOP","sa":"SmoOrnament"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":5}],"da":"treble","qb":3072},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","rb":true,"qb":3072},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":4}],"da":"treble"}]}],"ea":[]},{"ya":{"ya":37,"za":37,"ab":1,"t":0},"transposeIndex":2,"bb":6,"cb":[{"td":1024,"sd":2048,"pa":{"qa":"auto2273973","ra":"SmoTuplet"},"q":0},{"td":1024,"sd":2048,"pa":{"qa":"auto2275359","ra":"SmoTuplet"},"q":3},{"td":1024,"sd":2048,"pa":{"qa":"auto2447172","ra":"SmoTuplet"},"q":6},{"td":1024,"sd":2048,"pa":{"qa":"auto2571791","ra":"SmoTuplet"},"q":9},{"td":1024,"sd":2048,"pa":{"qa":"auto2694259","ra":"SmoTuplet"},"q":15},{"td":1024,"sd":2048,"ud":[1,2],"pa":{"qa":"auto2816339","ra":"SmoTuplet"},"q":16},{"td":1024,"sd":2048,"ud":[2,1],"pa":{"qa":"auto2924730","ra":"SmoTuplet"},"q":18}],"db":[{"eb":[{"fb":{"gb":682,"hb":1,"ib":2},"ka":[{"jb":"b","lb":"b","kb":4}],"oc":"r","od":{"qa":"auto2273973","ra":"SmoTuplet"},"da":"treble","rb":true,"qb":2048,"sb":[{"parser":2,"gc":9,"sa":"SmoLyric","_text":"Eb^7 "}]},{"fb":{"gb":682,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"oc":"r","od":{"qa":"auto2273973","ra":"SmoTuplet"},"da":"treble","rb":true,"qb":2048},{"fb":{"gb":682,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":3}],"od":{"qa":"auto2273973","ra":"SmoTuplet"},"da":"treble","qb":2048},{"fb":{"gb":682,"hb":1,"ib":2},"ka":[{"jb":"d","lb":"b","kb":4}],"od":{"qa":"auto2275359","ra":"SmoTuplet"},"da":"treble","qb":2048},{"fb":{"gb":682,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"b","kb":4}],"od":{"qa":"auto2275359","ra":"SmoTuplet"},"da":"treble","qb":2048},{"fb":{"gb":682,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":4}],"od":{"qa":"auto2275359","ra":"SmoTuplet"},"da":"treble","rb":true,"qb":2048},{"fb":{"gb":682,"hb":1,"ib":2},"ka":[{"jb":"b","lb":"b","kb":4}],"od":{"qa":"auto2447172","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":682,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"od":{"qa":"auto2447172","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":682,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"oc":"r","od":{"qa":"auto2447172","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":682,"hb":1,"ib":2},"ka":[{"jb":"a","lb":"n","kb":4}],"od":{"qa":"auto2571791","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":682,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"oc":"r","od":{"qa":"auto2571791","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":682,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"od":{"qa":"auto2571791","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"#","kb":4}],"od":{},"da":"treble","sb":[{"parser":2,"sa":"SmoLyric","_text":"D^7 "}]},{"fb":{"gb":682,"hb":1,"ib":2},"ka":[{"jb":"f","lb":"#","kb":4}],"od":{"qa":"auto2694259","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":682,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"od":{"qa":"auto2694259","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":682,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"od":{"qa":"auto2694259","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":682,"hb":1,"ib":1},"ka":[{"jb":"e","lb":"b","kb":5,"pc":true}],"od":{"qa":"auto2816339","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":1365,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":5}],"od":{"qa":"auto2816339","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":1365,"hb":1,"ib":1},"ka":[{"jb":"d","lb":"n","kb":5}],"od":{"qa":"auto2924730","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":682,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"od":{"qa":"auto2924730","ra":"SmoTuplet"},"da":"treble"}]}],"ea":[]},{"ya":{"ya":38,"za":38,"ab":0,"t":0},"transposeIndex":2,"bb":58.94,"cb":[],"db":[{"eb":[{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":5}],"da":"treble","sb":[{"parser":2,"sa":"SmoLyric","_text":"G^-7 "}],"md":[{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"#","kb":5}],"sa":"SmoGraceNote"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":5}],"da":"treble","md":[{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"#","kb":5}],"sa":"SmoGraceNote"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":5}],"da":"treble","sb":[{"parser":2,"sa":"SmoLyric","_text":"C^7 "}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"b","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"#","kb":5}],"da":"treble"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble"}]}],"ea":[]},{"ya":{"ya":39,"za":39,"ab":1,"t":0},"transposeIndex":2,"bb":6,"cb":[],"db":[{"eb":[{"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble","sb":[{"parser":2,"sa":"SmoLyric","_text":"F^7 "}]},{"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":5}],"da":"treble","sb":[{"parser":2,"sa":"SmoLyric","_text":"Bb^7 "}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"#","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"da":"treble"}]}],"ea":[]},{"ya":{"ya":40,"za":40,"ab":2,"t":0},"transposeIndex":2,"bb":6,"cb":[],"db":[{"eb":[{"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble","sb":[{"parser":2,"sa":"SmoLyric","_text":"Eb^7 "}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"b","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"b","kb":5}],"da":"treble","sb":[{"parser":2,"gc":10,"sa":"SmoLyric","_text":"D^7 "}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"b","kb":5}],"da":"treble"},{"fb":{"gb":512,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":512,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"#","kb":5,"pc":false}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":5}],"da":"treble"}]}],"ea":[]},{"ya":{"ya":41,"za":41,"ab":0,"t":0},"transposeIndex":2,"bb":58.94,"cb":[{"td":1024,"sd":2048,"pa":{"qa":"auto1143660","ra":"SmoTuplet"},"q":4}],"db":[{"eb":[{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":5}],"da":"treble","sb":[{"parser":2,"sa":"SmoLyric","_text":"G^-7 "}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"da":"treble"},{"fb":{"gb":682,"hb":1,"ib":2},"ka":[{"jb":"a","lb":"n","kb":4}],"od":{"qa":"auto1143660","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":682,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"od":{"qa":"auto1143660","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":682,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"od":{"qa":"auto1143660","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","sb":[{"parser":2,"sa":"SmoLyric","_text":"C^7 "}],"fd":[{"hd":"SCOOP","sa":"SmoOrnament"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble"},{"ka":[{"jb":"e","lb":"n","kb":4}],"da":"treble"}]}],"ea":[]},{"ya":{"ya":42,"za":42,"ab":1,"t":0},"transposeIndex":2,"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble","rb":true,"qb":1024},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":4}],"da":"treble","rb":true,"qb":1024,"sb":[{"parser":2,"sa":"SmoLyric","_text":"G^-7 "}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble","rb":true,"qb":1024},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":3}],"da":"treble","rb":true,"qb":1024},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":3}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":3}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3}],"da":"treble"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":4}],"da":"treble","sb":[{"parser":2,"sa":"SmoLyric","_text":"C^7 "}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":4}],"oc":"r","da":"treble","rb":true,"qb":1024},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":4}],"da":"treble"}]}],"ea":[{"kd":1,"sa":"SmoBarline"}]},{"ya":{"ya":43,"za":43,"ab":2,"t":0},"transposeIndex":2,"bb":6,"cb":[],"db":[{"eb":[{"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble"},{"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble"},{"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble"},{"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble"}]}],"ea":[]}]}],"yc":[{"jc":616,"kc":54,"tb":"Yama","vb":{"wb":"1.8000000000000007em","xb":"Times New Roman","yb":"normal","zb":"normal"},"ac":"score-text auto2033","sa":"SmoScoreText"},{"jc":692,"kc":48,"tb":"(as played by Lee Morgan)","ac":"score-text auto2034","sa":"SmoScoreText"},{"jc":1006,"kc":44,"tb":"Bb Trumpet","ac":"score-text auto2035","sa":"SmoScoreText"}],"yd":[],"ee":{"wa":{"0":"4/4"},"xa":{"0":"F"},"fe":{"0":{"sa":"SmoTempoText","pa":{"qa":"auto1018","ra":"SmoTempoText"},"id":"duration","nb":96,"ob":true,"pb":4096,"jd":"Allegro","ta":24},"1":{"sa":"SmoTempoText","pa":{"qa":"auto1042","ra":"SmoTempoText"},"id":"duration","nb":96,"ob":true,"pb":4096,"jd":"Allegro","ta":0}}},"dictionary":{"a":"score","b":"layout","c":"leftMargin","d":"rightMargin","e":"topMargin","f":"bottomMargin","g":"pageWidth","h":"pageHeight","i":"orientation","j":"interGap","k":"intraGap","l":"svgScale","m":"zoomScale","n":"zoomMode","o":"pages","p":"pageSize","q":"startIndex","r":"renumberingMap","s":"staves","t":"staffId","u":"staffX","v":"staffY","w":"adjY","x":"staffWidth","y":"staffHeight","z":"keySignatureMap","aa":"instrumentInfo","ba":"instrumentName","ca":"keyOffset","da":"clef","ea":"modifiers","fa":"startSelector","ga":"staff","ha":"measure","ia":"voice","ja":"tick","ka":"pitches","la":"endSelector","ma":"xOffset","na":"cp1y","oa":"cp2y","pa":"attrs","qa":"id","ra":"type","sa":"ctor","ta":"yOffset","ua":"position","va":"measures","wa":"timeSignature","xa":"keySignature","ya":"measureNumber","za":"measureIndex","ab":"systemIndex","bb":"adjX","cb":"tuplets","db":"voices","eb":"notes","fb":"ticks","gb":"numerator","hb":"denominator","ib":"remainder","jb":"letter","kb":"octave","lb":"accidental","mb":"symbol","nb":"bpm","ob":"display","pb":"beatDuration","qb":"beamBeats","rb":"endBeam","sb":"textModifiers","tb":"text","ub":"endChar","vb":"fontInfo","wb":"size","xb":"family","yb":"style","zb":"weight","ac":"classes","bc":"verse","cc":"fill","dc":"scaleX","ec":"scaleY","fc":"translateX","gc":"translateY","hc":"selector","ic":"renderedBox","jc":"x","kc":"y","lc":"width","mc":"height","nc":"logicalBox","oc":"noteType","pc":"cautionary","qc":"articulations","rc":"articulation","sc":"activeVoice","tc":"flagState","uc":"invert","vc":"fontSize","wc":"yOffsetLine","xc":"yOffsetPixels","yc":"scoreText","zc":"backup","ad":"edited","bd":"pagination","cd":"boxModel","dd":"justification","ed":"autoLayout","fd":"ornaments","gd":"offset","hd":"ornament","id":"tempoMode","jd":"tempoText","kd":"barline","ld":"systemBreak","md":"graceNotes","nd":"tones","od":"tuplet","pd":"beam_group","qd":"renderId","rd":"numNotes","sd":"totalTicks","td":"stemTicks","ud":"durationMap","vd":"bracketed","wd":"ratioed","xd":"location","yd":"systemGroups","zd":"leftConnector","ae":"padLeft","be":"customStretch","ce":"engravingFont","de":"customProportion","ee":"columnAttributeMap","fe":"tempo"}}`;
;var inventionJson = `{"a":{"b":{"c":30,"d":30,"e":150,"f":40,"g":816,"h":1056,"i":0,"j":30,"k":15,"l":0.7,"m":1.4641000000000006,"n":2,"o":2,"p":"letter"},"q":0,"r":{},"ce":"Bravura"},"s":[{"t":0,"u":10,"v":40,"w":0,"x":1600,"y":90,"q":0,"r":{},"z":{},"aa":{"ba":"Treble Instrument","ca":"0","da":"treble"},"ea":[{"fa":{"ga":0,"ha":4,"ia":0,"ja":0,"ka":[]},"la":{"ga":0,"ha":4,"ia":0,"ja":1,"ka":[]},"ma":-3,"na":34,"oa":17,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":5,"ia":0,"ja":9,"ka":[]},"la":{"ga":0,"ha":5,"ia":0,"ja":12,"ka":[]},"ma":0,"ua":4,"na":40,"oa":40,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":10,"ia":0,"ja":1,"ka":[]},"la":{"ga":0,"ha":10,"ia":0,"ja":4,"ka":[]},"ma":0,"uc":true,"na":40,"oa":40,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":10,"ia":0,"ja":5,"ka":[]},"la":{"ga":0,"ha":11,"ia":0,"ja":0,"ka":[]},"ma":0,"ua":4,"na":40,"oa":40,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":11,"ia":0,"ja":1,"ka":[]},"la":{"ga":0,"ha":11,"ia":0,"ja":6,"ka":[]},"ma":0,"ua":4,"na":40,"oa":40,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":15,"ia":0,"ja":8,"ka":[]},"la":{"ga":0,"ha":16,"ia":0,"ja":0,"ka":[]},"ma":0,"ua":4,"na":40,"oa":40,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":17,"ia":0,"ja":8,"ka":[]},"la":{"ga":0,"ha":18,"ia":0,"ja":0,"ka":[]},"ma":0,"ua":4,"na":40,"oa":40,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":0,"ia":0,"ja":9,"ka":[]},"la":{"ga":0,"ha":0,"ia":0,"ja":11,"ka":[]},"sa":"SmoStaffHairpin"},{"fa":{"ga":0,"ha":1,"ia":0,"ja":9,"ka":[]},"la":{"ga":0,"ha":1,"ia":0,"ja":11,"ka":[]},"sa":"SmoStaffHairpin"},{"fa":{"ga":0,"ha":6,"ia":0,"ja":4,"ka":[]},"la":{"ga":0,"ha":6,"ia":0,"ja":10,"ka":[]},"ta":-40,"sa":"SmoStaffHairpin"},{"fa":{"ga":0,"ha":7,"ia":0,"ja":4,"ka":[]},"la":{"ga":0,"ha":7,"ia":0,"ja":10,"ka":[]},"sa":"SmoStaffHairpin"},{"fa":{"ga":0,"ha":16,"ia":0,"ja":8,"ka":[]},"la":{"ga":0,"ha":17,"ia":0,"ja":0,"ka":[]},"ma":0,"ua":4,"na":40,"oa":40,"sa":"SmoSlur"}],"va":[{"ya":{"ya":0,"za":0,"ab":0,"t":0},"bb":59.980000000000004,"cb":[],"db":[{"eb":[{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":4}],"oc":"r","da":"treble","rb":true},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":4}],"da":"treble","qb":3072},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":4}],"da":"treble","qb":3072},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":4}],"da":"treble","rb":true,"qb":3072},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","qb":8192},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","qb":8192},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":8192,"fd":[{"hd":"mordent_inverted","sa":"SmoOrnament"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","rb":true,"qb":8192}]}],"ea":[]},{"ya":{"ya":1,"za":1,"ab":1,"t":0},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qc":[{"rc":"staccato","sa":"SmoArticulation"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":8192},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":5}],"da":"treble","qb":8192},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":5}],"da":"treble","qb":8192,"fd":[{"hd":"mordent_inverted","sa":"SmoOrnament"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":5}],"da":"treble","rb":true,"qb":8192}]}],"ea":[]},{"ya":{"ya":2,"za":2,"ab":2,"t":0},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":5}],"da":"treble","qc":[{"rc":"staccato","sa":"SmoArticulation"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":5}],"da":"treble"}]}],"ea":[]},{"ya":{"ya":3,"za":3,"ab":0,"t":0},"bb":41.5,"cb":[],"db":[{"eb":[{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"#","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble"}]}],"ea":[]},{"ya":{"ya":4,"za":4,"ab":1,"t":0},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","fd":[{"hd":"mordent_inverted","sa":"SmoOrnament"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"#","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"#","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble"}]}],"ea":[]},{"ya":{"ya":5,"za":5,"ab":2,"t":0},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":512,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":512,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","fd":[{"sa":"SmoOrnament"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble"}]}],"ea":[]},{"ya":{"ya":6,"za":6,"ab":0,"t":0},"bb":41.5,"cb":[],"db":[{"eb":[{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","rb":true},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"oc":"r","da":"treble"},{"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"oc":"r","da":"treble","rb":true},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","rb":true},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble"}]}],"ea":[]},{"ya":{"ya":7,"za":7,"ab":1,"t":0},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"#","kb":4}],"da":"treble","rb":true},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble"},{"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"oc":"r","da":"treble","rb":true},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","rb":true},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble"}]}],"ea":[]},{"ya":{"ya":8,"za":8,"ab":2,"t":0},"bb":41.5,"cb":[],"db":[{"eb":[{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","rb":true},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble"},{"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble","rb":true},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","rb":true},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble"}]}],"ea":[]},{"ya":{"ya":9,"za":9,"ab":0,"t":0},"bb":41.5,"cb":[],"db":[{"eb":[{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","rb":true},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble"},{"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":5}],"oc":"r","da":"treble","rb":true},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","rb":true},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"#","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":5}],"da":"treble"}]}],"ea":[]},{"ya":{"ya":10,"za":10,"ab":1,"t":0},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":8192},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"#","kb":5}],"da":"treble","qb":8192},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":8192},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":5}],"da":"treble","rb":true,"qb":8192},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":5}],"da":"treble","qb":8192,"tc":1},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble","qb":8192,"tc":1},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":8192,"tc":1},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"#","kb":5}],"da":"treble","rb":true,"qb":8192,"tc":1}]}],"ea":[]},{"ya":{"ya":11,"za":11,"ab":2,"t":0},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":8192,"tc":1},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"#","kb":4}],"da":"treble","qb":8192,"tc":1},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"#","kb":4}],"da":"treble","qb":8192,"tc":1},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble","rb":true,"qb":8192,"tc":1},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","tc":1},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","tc":1},{"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","tc":1}]}],"ea":[]},{"ya":{"ya":12,"za":12,"ab":0,"t":0},"bb":41.5,"cb":[],"db":[{"eb":[{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble"}]}],"ea":[]},{"ya":{"ya":13,"za":13,"ab":1,"t":0},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"#","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","fd":[{"sa":"SmoOrnament"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble"}]}],"ea":[]},{"ya":{"ya":14,"za":14,"ab":2,"t":0},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble","qc":[{"ua":"below","rc":"staccato","sa":"SmoArticulation"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":8192,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":5}],"da":"treble"}]}],"ea":[]},{"ya":{"ya":15,"za":15,"ab":0,"t":0},"bb":41.5,"de":12,"cb":[],"db":[{"eb":[{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":5}],"da":"treble","tc":2},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":5}],"da":"treble","tc":2},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":5}],"da":"treble","tc":2},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":5}],"da":"treble","tc":2},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":5}],"da":"treble","tc":2},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":5}],"da":"treble","tc":2},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":5}],"da":"treble","tc":2},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":5}],"da":"treble","tc":2},{"fb":{"gb":8192,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":5}],"da":"treble"}]}],"ea":[]},{"ya":{"ya":16,"za":16,"ab":1,"t":0},"bb":6,"de":12,"cb":[],"db":[{"eb":[{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":5}],"da":"treble","qc":[{"rc":"staccato","sa":"SmoArticulation"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":8192,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":5}],"da":"treble"}]}],"ea":[]},{"ya":{"ya":17,"za":17,"ab":2,"t":0},"bb":6,"de":62,"cb":[],"db":[{"eb":[{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":8192,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":5}],"da":"treble"}]}],"ea":[]},{"ya":{"ya":18,"za":18,"ab":3,"t":0},"bb":6,"be":-31,"cb":[],"db":[{"eb":[{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":5}],"da":"treble","qc":[{"rc":"staccato","sa":"SmoArticulation"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":5}],"da":"treble"}]}],"ea":[]},{"ya":{"ya":19,"za":19,"ab":0,"t":0},"bb":41.5,"cb":[],"db":[{"eb":[{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":6}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":6}],"da":"treble"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble"}]}],"ea":[]},{"ya":{"ya":20,"za":20,"ab":1,"t":0},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":5}],"da":"treble"}]}],"ea":[]},{"ya":{"ya":21,"za":21,"ab":2,"t":0},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":16384,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":4},{"jb":"g","lb":"n","kb":4},{"jb":"c","lb":"n","kb":5}],"da":"treble"}]}],"ea":[{"kd":2,"sa":"SmoBarline"}]}]},{"t":1,"u":10,"v":40,"w":0,"x":1600,"y":90,"q":0,"r":{},"z":{},"aa":{"ba":"Bass Clef Staff","ca":0,"da":"bass"},"ea":[{"fa":{"ga":1,"ha":1,"ia":0,"ja":0,"ka":[0]},"la":{"ga":1,"ha":1,"ia":0,"ja":1,"ka":[]},"ma":0,"ua":4,"na":40,"oa":40,"sa":"SmoSlur"},{"fa":{"ga":1,"ha":2,"ia":0,"ja":1,"ka":[]},"la":{"ga":1,"ha":2,"ia":0,"ja":4,"ka":[]},"ma":0,"ua":4,"na":40,"oa":40,"sa":"SmoSlur"},{"fa":{"ga":1,"ha":2,"ia":0,"ja":5,"ka":[]},"la":{"ga":1,"ha":3,"ia":0,"ja":0,"ka":[]},"ma":0,"ua":4,"na":40,"oa":40,"sa":"SmoSlur"},{"fa":{"ga":1,"ha":3,"ia":0,"ja":1,"ka":[]},"la":{"ga":1,"ha":3,"ia":0,"ja":6,"ka":[]},"ma":0,"ua":4,"na":40,"oa":40,"sa":"SmoSlur"},{"fa":{"ga":1,"ha":15,"ia":0,"ja":0,"ka":[]},"la":{"ga":1,"ha":15,"ia":0,"ja":1,"ka":[]},"ma":0,"ua":4,"na":40,"oa":40,"sa":"SmoSlur"},{"fa":{"ga":1,"ha":16,"ia":0,"ja":0,"ka":[0]},"la":{"ga":1,"ha":16,"ia":0,"ja":1,"ka":[]},"ma":0,"ua":4,"na":40,"oa":40,"sa":"SmoSlur"},{"fa":{"ga":1,"ha":3,"ia":0,"ja":4,"ka":[]},"la":{"ga":1,"ha":3,"ia":0,"ja":6,"ka":[]},"sa":"SmoStaffHairpin"},{"fa":{"ga":1,"ha":17,"ia":0,"ja":0,"ka":[]},"la":{"ga":1,"ha":17,"ia":0,"ja":1,"ka":[]},"ua":4,"sa":"SmoSlur"}],"va":[{"ya":{"ya":0,"za":0,"ab":0,"t":1},"da":"bass","bb":59.980000000000004,"cb":[],"db":[{"eb":[{"fb":{"gb":8192,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":3}],"oc":"r","da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":3}],"oc":"r","da":"bass","rb":true,"qb":1024},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":3}],"da":"bass","rb":true},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":3}],"da":"bass","rb":true}]}],"ea":[]},{"ya":{"ya":1,"za":1,"ab":1,"t":1},"da":"bass","bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":2}],"da":"bass","qc":[{"rc":"staccato","sa":"SmoArticulation"}]},{"ka":[{"jb":"d","lb":"n","kb":3}],"oc":"r","da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":3}],"oc":"r","da":"bass","rb":true},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":3}],"da":"bass","rb":true},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":4}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3}],"da":"bass","rb":true}]}],"ea":[]},{"ya":{"ya":2,"za":2,"ab":2,"t":1},"da":"bass","bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":4}],"da":"bass","qb":8192},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":3}],"da":"bass","qb":8192},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":4}],"da":"bass","qb":8192},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":4}],"da":"bass","rb":true,"qb":8192},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":4}],"da":"bass","qb":8192},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3}],"da":"bass","qb":8192},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":3}],"da":"bass","qb":8192},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":3}],"da":"bass","rb":true,"qb":8192}]}],"ea":[]},{"ya":{"ya":3,"za":3,"ab":0,"t":1},"da":"bass","bb":41.5,"cb":[],"db":[{"eb":[{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":4}],"da":"bass","qb":8192},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":3}],"da":"bass","qb":8192},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"#","kb":3}],"da":"bass","qb":8192},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3}],"da":"bass","rb":true,"qb":8192},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":3}],"da":"bass"},{"ka":[{"jb":"c","lb":"n","kb":4}],"da":"bass"}]}],"ea":[]},{"ya":{"ya":4,"za":4,"ab":1,"t":1},"da":"bass","bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":4}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"#","kb":3}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"#","kb":3}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3}],"da":"bass","qb":8192},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":2}],"da":"bass","qb":8192},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":3}],"da":"bass","qb":8192},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":3}],"da":"bass","rb":true,"qb":8192}]}],"ea":[]},{"ya":{"ya":5,"za":5,"ab":2,"t":1},"da":"bass","bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":3}],"da":"bass","qb":8192},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"#","kb":3}],"da":"bass","qb":8192},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3}],"da":"bass","qb":8192},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":3}],"da":"bass","rb":true,"qb":8192},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":2}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":3}],"da":"bass","tc":1},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":2}],"da":"bass","tc":1,"qc":[{"ua":"below","rc":"staccato","sa":"SmoArticulation"}]}]}],"ea":[]},{"ya":{"ya":6,"za":6,"ab":0,"t":1},"da":"bass","bb":41.5,"cb":[],"db":[{"eb":[{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":2}],"oc":"r","da":"bass","rb":true},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":2}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":2}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":2}],"da":"bass","rb":true},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":2}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":2}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":2}],"da":"bass"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":3}],"da":"bass","qb":8192},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3}],"da":"bass","qb":8192},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"#","kb":3}],"da":"bass","qb":8192},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3}],"da":"bass","rb":true,"qb":8192}]}],"ea":[]},{"ya":{"ya":7,"za":7,"ab":1,"t":1},"da":"bass","bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":3}],"da":"bass","qc":[{"rc":"staccato","sa":"SmoArticulation"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"#","kb":3}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"#","kb":3}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":3}],"da":"bass","qb":8192},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":4}],"da":"bass","qb":8192},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":4}],"da":"bass","qb":8192},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":4}],"da":"bass","rb":true,"qb":8192}]}],"ea":[]},{"ya":{"ya":8,"za":8,"ab":2,"t":1},"bb":41.5,"cb":[],"db":[{"eb":[{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3}],"da":"treble","qc":[{"ua":"below","rc":"staccato","sa":"SmoArticulation"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":4,"pc":true}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":4}],"da":"treble","rb":true},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","qb":8192},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":4}],"da":"treble","qb":8192},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","qb":8192},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":4}],"da":"treble","rb":true,"qb":8192}]}],"ea":[]},{"ya":{"ya":9,"za":9,"ab":0,"t":1},"bb":41.5,"cb":[],"db":[{"eb":[{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":4}],"da":"treble"}]}],"ea":[]},{"ya":{"ya":10,"za":10,"ab":1,"t":1},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble"}]}],"ea":[]},{"ya":{"ya":11,"za":11,"ab":2,"t":1},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":3}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":3}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":3}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"#","kb":3}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":3}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":3}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":4}],"da":"treble"}]}],"ea":[]},{"ya":{"ya":12,"za":12,"ab":0,"t":1},"da":"bass","bb":41.5,"cb":[],"db":[{"eb":[{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":4}],"da":"bass"},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":4}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":4}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":4}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3,"pc":true}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"#","kb":3}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"#","kb":3}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":3}],"da":"bass"}]}],"ea":[]},{"ya":{"ya":13,"za":13,"ab":1,"t":1},"da":"bass","bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":4}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":4}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":4}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":4}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":4}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":4}],"da":"bass"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":4}],"da":"bass"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":4}],"da":"bass"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":3}],"da":"bass"}]}],"ea":[]},{"ya":{"ya":14,"za":14,"ab":2,"t":1},"da":"bass","bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":3}],"da":"bass"},{"ka":[{"jb":"c","lb":"n","kb":4}],"oc":"r","da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":4}],"oc":"r","da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":4}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":4}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":4}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":4}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"#","kb":4}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":4}],"da":"bass"}]}],"ea":[]},{"ya":{"ya":15,"za":15,"ab":0,"t":1},"da":"bass","bb":41.5,"cb":[],"db":[{"eb":[{"fb":{"gb":8192,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":4}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":4}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":4}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":4}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":4}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":3}],"da":"bass"}]}],"ea":[]},{"ya":{"ya":16,"za":16,"ab":1,"t":1},"da":"bass","bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":8192,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":4}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":4}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":4}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":4}],"da":"bass"}]}],"ea":[]},{"ya":{"ya":17,"za":17,"ab":2,"t":1},"da":"bass","bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":8192,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":4}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":4}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":3}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":4}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":3}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3}],"da":"bass"}]}],"ea":[]},{"ya":{"ya":18,"za":18,"ab":3,"t":1},"da":"bass","bb":6,"be":-15,"cb":[],"db":[{"eb":[{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":3}],"da":"bass","qb":8192},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":3}],"da":"bass","qb":8192},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":3}],"da":"bass","qb":8192},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3}],"da":"bass","rb":true,"qb":8192},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":3}],"da":"bass","qb":8192},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":4}],"da":"bass","qb":8192},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":4}],"da":"bass","qb":8192},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":3}],"da":"bass","rb":true,"qb":8192}]}],"ea":[]},{"ya":{"ya":19,"za":19,"ab":0,"t":1},"da":"bass","bb":41.5,"cb":[],"db":[{"eb":[{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":4}],"da":"bass"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":4}],"da":"bass"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":4}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":4}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":3}],"da":"bass"}]}],"ea":[]},{"ya":{"ya":20,"za":20,"ab":1,"t":1},"da":"bass","bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":2}],"da":"bass","qc":[{"rc":"staccato","sa":"SmoArticulation"}]}]}],"ea":[]},{"ya":{"ya":21,"za":21,"ab":2,"t":1},"da":"bass","bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":16384,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":2},{"jb":"c","lb":"n","kb":3}],"da":"bass"}]}],"ea":[{"kd":2,"sa":"SmoBarline"}]}]}],"yc":[{"jc":450,"kc":142,"tb":"15 Inventions à 2 voix.","vb":{"wb":"1.8em","xb":"Times New Roman","yb":"normal","zb":"normal"},"ac":"score-text auto89138","sa":"SmoScoreText"},{"jc":1010,"kc":45,"tb":"JS Bach","bd":"every","ac":"score-text auto89139","sa":"SmoScoreText"},{"jc":1013,"kc":76,"tb":"Page 1 of 2","bd":"every","ac":"score-text auto89140","sa":"SmoScoreText"},{"jc":441,"kc":1605,"tb":"15 Inventions &#xE0; 2 voix.","bd":"every","ac":"score-text auto89141","sa":"SmoScoreText"}],"yd":[{"zd":0,"la":{"ga":1,"ha":0},"sa":"SmoSystemGroup"}],"ee":{"wa":{"0":"4/4"},"xa":{"0":"C"},"fe":{"0":{"sa":"SmoTempoText","pa":{"qa":"auto88285","ra":"SmoTempoText"},"id":"text","nb":96,"ob":true,"pb":4096,"jd":"Moderato","ta":0}}},"dictionary":{"a":"score","b":"layout","c":"leftMargin","d":"rightMargin","e":"topMargin","f":"bottomMargin","g":"pageWidth","h":"pageHeight","i":"orientation","j":"interGap","k":"intraGap","l":"svgScale","m":"zoomScale","n":"zoomMode","o":"pages","p":"pageSize","q":"startIndex","r":"renumberingMap","s":"staves","t":"staffId","u":"staffX","v":"staffY","w":"adjY","x":"staffWidth","y":"staffHeight","z":"keySignatureMap","aa":"instrumentInfo","ba":"instrumentName","ca":"keyOffset","da":"clef","ea":"modifiers","fa":"startSelector","ga":"staff","ha":"measure","ia":"voice","ja":"tick","ka":"pitches","la":"endSelector","ma":"xOffset","na":"cp1y","oa":"cp2y","pa":"attrs","qa":"id","ra":"type","sa":"ctor","ta":"yOffset","ua":"position","va":"measures","wa":"timeSignature","xa":"keySignature","ya":"measureNumber","za":"measureIndex","ab":"systemIndex","bb":"adjX","cb":"tuplets","db":"voices","eb":"notes","fb":"ticks","gb":"numerator","hb":"denominator","ib":"remainder","jb":"letter","kb":"octave","lb":"accidental","mb":"symbol","nb":"bpm","ob":"display","pb":"beatDuration","qb":"beamBeats","rb":"endBeam","sb":"textModifiers","tb":"text","ub":"endChar","vb":"fontInfo","wb":"size","xb":"family","yb":"style","zb":"weight","ac":"classes","bc":"verse","cc":"fill","dc":"scaleX","ec":"scaleY","fc":"translateX","gc":"translateY","hc":"selector","ic":"renderedBox","jc":"x","kc":"y","lc":"width","mc":"height","nc":"logicalBox","oc":"noteType","pc":"cautionary","qc":"articulations","rc":"articulation","sc":"activeVoice","tc":"flagState","uc":"invert","vc":"fontSize","wc":"yOffsetLine","xc":"yOffsetPixels","yc":"scoreText","zc":"backup","ad":"edited","bd":"pagination","cd":"boxModel","dd":"justification","ed":"autoLayout","fd":"ornaments","gd":"offset","hd":"ornament","id":"tempoMode","jd":"tempoText","kd":"barline","ld":"systemBreak","md":"graceNotes","nd":"tones","od":"tuplet","pd":"beam_group","qd":"renderId","rd":"numNotes","sd":"totalTicks","td":"stemTicks","ud":"durationMap","vd":"bracketed","wd":"ratioed","xd":"location","yd":"systemGroups","zd":"leftConnector","ae":"padLeft","be":"customStretch","ce":"engravingFont","de":"customProportion","ee":"columnAttributeMap","fe":"tempo"}}`;
;var basicJson = `{"score":{"layout":{"leftMargin":30,"rightMargin":30,"topMargin":40,"bottomMargin":40,"pageWidth":816,"pageHeight":1056,"orientation":0,"interGap":30,"intraGap":10,"svgScale":1,"zoomScale":2.107843137254902,"zoomMode":0,"pages":1},"startIndex":0,"renumberingMap":{}},"staves":[{"staffId":0,"staffX":10,"staffY":40,"adjY":0,"staffWidth":1600,"staffHeight":90,"startIndex":0,"renumberingMap":{},"keySignatureMap":{},"instrumentInfo":{"instrumentName":"Treble Instrument","keyOffset":"0","clef":"treble"},"modifiers":[],"measures":[{"timeSignature":"4/4","keySignature":"C","staffY":41,"measureNumber":{"measureNumber":0,"measureIndex":0,"systemIndex":0,"staffId":0},"activeVoice":0,"clef":"treble","transposeIndex":0,"adjX":64.98,"padLeft":0,"adjRight":11,"padRight":10,"rightMargin":2,"tuplets":[],"beamGroups":[],"voices":[{"notes":[{"ticks":{"numerator":2048,"denominator":1,"remainder":0},"pitches":[{"letter":"c","accidental":"n","octave":4}],"noteType":"n","attrs":{"id":"auto318077","type":"SmoNote"},"clef":"treble","endBeam":false,"beamBeats":4096,"flagState":0,"noteModifiers":[],"graceNotes":[],"articulations":[],"ornaments":[]},{"ticks":{"numerator":1024,"denominator":1,"remainder":0},"pitches":[{"letter":"d","accidental":"n","octave":4}],"noteType":"n","attrs":{"id":"auto318078","type":"SmoNote"},"clef":"treble","endBeam":false,"beamBeats":4096,"flagState":0,"noteModifiers":[],"graceNotes":[],"articulations":[],"ornaments":[]},{"ticks":{"numerator":1024,"denominator":1,"remainder":0},"pitches":[{"letter":"e","accidental":"n","octave":4}],"noteType":"n","attrs":{"id":"auto318079","type":"SmoNote"},"clef":"treble","endBeam":false,"beamBeats":4096,"flagState":0,"noteModifiers":[],"graceNotes":[],"articulations":[],"ornaments":[]},{"ticks":{"numerator":1024,"denominator":1,"remainder":0},"pitches":[{"letter":"f","accidental":"n","octave":4}],"noteType":"n","attrs":{"id":"auto318080","type":"SmoNote"},"clef":"treble","endBeam":false,"beamBeats":4096,"flagState":0,"noteModifiers":[],"graceNotes":[],"articulations":[],"ornaments":[]},{"ticks":{"numerator":1024,"denominator":1,"remainder":0},"pitches":[{"letter":"g","accidental":"n","octave":4}],"noteType":"n","attrs":{"id":"auto318081","type":"SmoNote"},"clef":"treble","endBeam":false,"beamBeats":4096,"flagState":0,"noteModifiers":[],"graceNotes":[],"articulations":[],"ornaments":[]},{"ticks":{"numerator":1024,"denominator":1,"remainder":0},"pitches":[{"letter":"a","accidental":"n","octave":4}],"noteType":"n","attrs":{"id":"auto318082","type":"SmoNote"},"clef":"treble","endBeam":false,"beamBeats":4096,"flagState":0,"noteModifiers":[],"graceNotes":[],"articulations":[],"ornaments":[]},{"ticks":{"numerator":1024,"denominator":1,"remainder":0},"pitches":[{"letter":"b","accidental":"n","octave":4}],"noteType":"n","attrs":{"id":"auto318083","type":"SmoNote"},"clef":"treble","endBeam":false,"beamBeats":4096,"flagState":0,"noteModifiers":[],"graceNotes":[],"articulations":[],"ornaments":[]},{"ticks":{"numerator":2048,"denominator":1,"remainder":0},"pitches":[{"letter":"c","accidental":"n","octave":5}],"noteType":"n","attrs":{"id":"auto318084","type":"SmoNote"},"clef":"treble","endBeam":false,"beamBeats":4096,"flagState":0,"noteModifiers":[],"graceNotes":[],"articulations":[],"ornaments":[]},{"ticks":{"numerator":1024,"denominator":1,"remainder":0},"pitches":[{"letter":"b","accidental":"n","octave":4}],"noteType":"n","attrs":{"id":"auto318085","type":"SmoNote"},"clef":"treble","endBeam":false,"beamBeats":4096,"flagState":0,"noteModifiers":[],"graceNotes":[],"articulations":[],"ornaments":[]},{"ticks":{"numerator":1024,"denominator":1,"remainder":0},"pitches":[{"letter":"a","accidental":"n","octave":4}],"noteType":"n","attrs":{"id":"auto318086","type":"SmoNote"},"clef":"treble","endBeam":false,"beamBeats":4096,"flagState":0,"noteModifiers":[],"graceNotes":[],"articulations":[],"ornaments":[]},{"ticks":{"numerator":1024,"denominator":1,"remainder":0},"pitches":[{"letter":"g","accidental":"n","octave":4}],"noteType":"n","attrs":{"id":"auto318087","type":"SmoNote"},"clef":"treble","endBeam":false,"beamBeats":4096,"flagState":0,"noteModifiers":[],"graceNotes":[],"articulations":[],"ornaments":[]},{"ticks":{"numerator":1024,"denominator":1,"remainder":0},"pitches":[{"letter":"f","accidental":"n","octave":4}],"noteType":"n","attrs":{"id":"auto318088","type":"SmoNote"},"clef":"treble","endBeam":false,"beamBeats":4096,"flagState":0,"noteModifiers":[],"graceNotes":[],"articulations":[],"ornaments":[]},{"ticks":{"numerator":1024,"denominator":1,"remainder":0},"pitches":[{"letter":"e","accidental":"n","octave":4}],"noteType":"n","attrs":{"id":"auto318089","type":"SmoNote"},"clef":"treble","endBeam":false,"beamBeats":4096,"flagState":0,"noteModifiers":[],"graceNotes":[],"articulations":[],"ornaments":[]},{"ticks":{"numerator":1024,"denominator":1,"remainder":0},"pitches":[{"letter":"d","accidental":"n","octave":4}],"noteType":"n","attrs":{"id":"auto318090","type":"SmoNote"},"clef":"treble","endBeam":false,"beamBeats":4096,"flagState":0,"noteModifiers":[],"graceNotes":[],"articulations":[],"ornaments":[]}]}],"modifiers":[{"position":0,"barline":0,"ctor":"SmoBarline"},{"position":1,"barline":0,"ctor":"SmoBarline"},{"symbol":0,"xOffset":0,"yOffset":30,"position":0,"ctor":"SmoRepeatSymbol"}]},{"timeSignature":"4/4","keySignature":"C","staffY":41,"measureNumber":{"measureNumber":1,"measureIndex":1,"systemIndex":1,"staffId":0},"activeVoice":0,"clef":"treble","transposeIndex":0,"adjX":11,"padLeft":0,"adjRight":11,"padRight":10,"rightMargin":2,"tuplets":[],"beamGroups":[],"voices":[{"notes":[{"ticks":{"numerator":2048,"denominator":1,"remainder":0},"pitches":[{"letter":"c","accidental":"n","octave":4}],"noteType":"n","attrs":{"id":"auto358929","type":"SmoNote"},"clef":"treble","endBeam":false,"beamBeats":4096,"flagState":0,"noteModifiers":[],"graceNotes":[],"articulations":[],"ornaments":[]},{"ticks":{"numerator":1024,"denominator":1,"remainder":0},"pitches":[{"letter":"e","accidental":"n","octave":4}],"noteType":"n","attrs":{"id":"auto360328","type":"SmoNote"},"clef":"treble","endBeam":false,"beamBeats":4096,"flagState":0,"noteModifiers":[],"graceNotes":[],"articulations":[],"ornaments":[]},{"ticks":{"numerator":1024,"denominator":1,"remainder":0},"pitches":[{"letter":"g","accidental":"n","octave":4}],"noteType":"n","attrs":{"id":"auto360329","type":"SmoNote"},"clef":"treble","endBeam":false,"beamBeats":4096,"flagState":0,"noteModifiers":[],"graceNotes":[],"articulations":[],"ornaments":[]},{"ticks":{"numerator":2048,"denominator":1,"remainder":0},"pitches":[{"letter":"c","accidental":"n","octave":5}],"noteType":"n","attrs":{"id":"auto372785","type":"SmoNote"},"clef":"treble","endBeam":false,"beamBeats":4096,"flagState":0,"noteModifiers":[],"graceNotes":[],"articulations":[],"ornaments":[]},{"ticks":{"numerator":1024,"denominator":1,"remainder":0},"pitches":[{"letter":"g","accidental":"n","octave":4}],"noteType":"n","attrs":{"id":"auto374186","type":"SmoNote"},"clef":"treble","endBeam":false,"beamBeats":4096,"flagState":0,"noteModifiers":[],"graceNotes":[],"articulations":[],"ornaments":[]},{"ticks":{"numerator":1024,"denominator":1,"remainder":0},"pitches":[{"letter":"e","accidental":"n","octave":4}],"noteType":"n","attrs":{"id":"auto374187","type":"SmoNote"},"clef":"treble","endBeam":false,"beamBeats":4096,"flagState":0,"noteModifiers":[],"graceNotes":[],"articulations":[],"ornaments":[]},{"ticks":{"numerator":2048,"denominator":1,"remainder":0},"pitches":[{"letter":"c","accidental":"n","octave":4}],"noteType":"n","attrs":{"id":"auto381535","type":"SmoNote"},"clef":"treble","endBeam":false,"beamBeats":4096,"flagState":0,"noteModifiers":[],"graceNotes":[],"articulations":[],"ornaments":[]},{"ticks":{"numerator":2048,"denominator":1,"remainder":0},"pitches":[{"letter":"b","accidental":"n","octave":3}],"noteType":"n","attrs":{"id":"auto354946","type":"SmoNote"},"clef":"treble","endBeam":false,"beamBeats":4096,"flagState":0,"noteModifiers":[],"graceNotes":[],"articulations":[],"ornaments":[]},{"ticks":{"numerator":4096,"denominator":1,"remainder":0},"pitches":[{"letter":"c","accidental":"n","octave":4}],"noteType":"n","attrs":{"id":"auto389896","type":"SmoNote"},"clef":"treble","endBeam":false,"beamBeats":4096,"flagState":0,"noteModifiers":[],"graceNotes":[],"articulations":[],"ornaments":[]}]}],"modifiers":[{"position":0,"barline":0,"ctor":"SmoBarline"},{"position":1,"barline":0,"ctor":"SmoBarline"},{"symbol":0,"xOffset":0,"yOffset":30,"position":0,"ctor":"SmoRepeatSymbol"}]}]}],"scoreText":[]}`;

var emptyScoreJson = `{"a":{"b":{"c":30,"d":30,"e":40,"f":40,"g":816,"h":1056,"i":0,"j":30,"k":10,"l":1,"m":2.107843137254902,"n":0,"o":1},"q":0,"r":{},"ce":"Bravura"},"s":[{"t":0,"u":10,"v":40,"w":0,"x":1600,"y":90,"q":0,"r":{},"z":{},"aa":{"ba":"Treble Instrument","ca":"0","da":"treble"},"ea":[],"va":[{"ya":{"ya":0,"za":0,"ab":0,"t":0},"bb":59.980000000000004,"cb":[],"db":[{"eb":[{"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble"},{"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble"},{"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble"},{"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble"}]}],"ea":[]}]}],"yc":[],"yd":[],"ee":{"wa":{"0":"4/4"},"xa":{"0":"C"}},"dictionary":{"a":"score","b":"layout","c":"leftMargin","d":"rightMargin","e":"topMargin","f":"bottomMargin","g":"pageWidth","h":"pageHeight","i":"orientation","j":"interGap","k":"intraGap","l":"svgScale","m":"zoomScale","n":"zoomMode","o":"pages","p":"pageSize","q":"startIndex","r":"renumberingMap","s":"staves","t":"staffId","u":"staffX","v":"staffY","w":"adjY","x":"staffWidth","y":"staffHeight","z":"keySignatureMap","aa":"instrumentInfo","ba":"instrumentName","ca":"keyOffset","da":"clef","ea":"modifiers","fa":"startSelector","ga":"staff","ha":"measure","ia":"voice","ja":"tick","ka":"pitches","la":"endSelector","ma":"xOffset","na":"cp1y","oa":"cp2y","pa":"attrs","qa":"id","ra":"type","sa":"ctor","ta":"yOffset","ua":"position","va":"measures","wa":"timeSignature","xa":"keySignature","ya":"measureNumber","za":"measureIndex","ab":"systemIndex","bb":"adjX","cb":"tuplets","db":"voices","eb":"notes","fb":"ticks","gb":"numerator","hb":"denominator","ib":"remainder","jb":"letter","kb":"octave","lb":"accidental","mb":"symbol","nb":"bpm","ob":"display","pb":"beatDuration","qb":"beamBeats","rb":"endBeam","sb":"textModifiers","tb":"text","ub":"endChar","vb":"fontInfo","wb":"size","xb":"family","yb":"style","zb":"weight","ac":"classes","bc":"verse","cc":"fill","dc":"scaleX","ec":"scaleY","fc":"translateX","gc":"translateY","hc":"selector","ic":"renderedBox","jc":"x","kc":"y","lc":"width","mc":"height","nc":"logicalBox","oc":"noteType","pc":"cautionary","qc":"articulations","rc":"articulation","sc":"activeVoice","tc":"flagState","uc":"invert","vc":"fontSize","wc":"yOffsetLine","xc":"yOffsetPixels","yc":"scoreText","zc":"backup","ad":"edited","bd":"pagination","cd":"boxModel","dd":"justification","ed":"autoLayout","fd":"ornaments","gd":"offset","hd":"ornament","id":"tempoMode","jd":"tempoText","kd":"barline","ld":"systemBreak","md":"graceNotes","nd":"tones","od":"tuplet","pd":"beam_group","qd":"renderId","rd":"numNotes","sd":"totalTicks","td":"stemTicks","ud":"durationMap","vd":"bracketed","wd":"ratioed","xd":"location","yd":"systemGroups","zd":"leftConnector","ae":"padLeft","be":"customStretch","ce":"engravingFont","de":"customProportion","ee":"columnAttributeMap","fe":"tempo"}}`;

var sixTestJson = `{"a":{"b":{"c":30,"d":30,"e":40,"f":40,"g":816,"h":1056,"i":0,"j":30,"k":10,"l":1,"m":2.107843137254902,"n":0,"o":1},"q":0,"r":{},"ce":"Bravura"},"s":[{"t":0,"u":10,"v":40,"w":0,"x":1600,"y":90,"q":0,"r":{},"z":{},"aa":{"ba":"Treble Instrument","ca":"0","da":"treble"},"ea":[],"va":[{"ya":{"ya":0,"za":0,"ab":0,"t":0},"bb":59.980000000000004,"cb":[],"db":[{"eb":[{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","rb":true,"qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","rb":true,"qb":6144}]}],"ea":[]}]}],"yc":[],"yd":[],"ee":{"wa":{"0":"6/8"},"xa":{"0":"C"}},"dictionary":{"a":"score","b":"layout","c":"leftMargin","d":"rightMargin","e":"topMargin","f":"bottomMargin","g":"pageWidth","h":"pageHeight","i":"orientation","j":"interGap","k":"intraGap","l":"svgScale","m":"zoomScale","n":"zoomMode","o":"pages","p":"pageSize","q":"startIndex","r":"renumberingMap","s":"staves","t":"staffId","u":"staffX","v":"staffY","w":"adjY","x":"staffWidth","y":"staffHeight","z":"keySignatureMap","aa":"instrumentInfo","ba":"instrumentName","ca":"keyOffset","da":"clef","ea":"modifiers","fa":"startSelector","ga":"staff","ha":"measure","ia":"voice","ja":"tick","ka":"pitches","la":"endSelector","ma":"xOffset","na":"cp1y","oa":"cp2y","pa":"attrs","qa":"id","ra":"type","sa":"ctor","ta":"yOffset","ua":"position","va":"measures","wa":"timeSignature","xa":"keySignature","ya":"measureNumber","za":"measureIndex","ab":"systemIndex","bb":"adjX","cb":"tuplets","db":"voices","eb":"notes","fb":"ticks","gb":"numerator","hb":"denominator","ib":"remainder","jb":"letter","kb":"octave","lb":"accidental","mb":"symbol","nb":"bpm","ob":"display","pb":"beatDuration","qb":"beamBeats","rb":"endBeam","sb":"textModifiers","tb":"text","ub":"endChar","vb":"fontInfo","wb":"size","xb":"family","yb":"style","zb":"weight","ac":"classes","bc":"verse","cc":"fill","dc":"scaleX","ec":"scaleY","fc":"translateX","gc":"translateY","hc":"selector","ic":"renderedBox","jc":"x","kc":"y","lc":"width","mc":"height","nc":"logicalBox","oc":"noteType","pc":"cautionary","qc":"articulations","rc":"articulation","sc":"activeVoice","tc":"flagState","uc":"invert","vc":"fontSize","wc":"yOffsetLine","xc":"yOffsetPixels","yc":"scoreText","zc":"backup","ad":"edited","bd":"pagination","cd":"boxModel","dd":"justification","ed":"autoLayout","fd":"ornaments","gd":"offset","hd":"ornament","id":"tempoMode","jd":"tempoText","kd":"barline","ld":"systemBreak","md":"graceNotes","nd":"tones","od":"tuplet","pd":"beam_group","qd":"renderId","rd":"numNotes","sd":"totalTicks","td":"stemTicks","ud":"durationMap","vd":"bracketed","wd":"ratioed","xd":"location","yd":"systemGroups","zd":"leftConnector","ae":"padLeft","be":"customStretch","ce":"engravingFont","de":"customProportion","ee":"columnAttributeMap","fe":"tempo"}}`;
;var jesuBambino = `{"a":{"b":{"c":50,"d":50,"e":72,"f":40,"g":816,"h":1056,"i":0,"j":40,"k":30,"l":0.65,"m":1.5,"n":2,"o":7,"p":"letter"},"q":0,"r":{},"ce":"Bravura"},"s":[{"t":0,"u":10,"v":40,"w":0,"x":1600,"y":90,"q":0,"r":{},"z":{},"aa":{"ba":"Treble Instrument","ca":"0","da":"treble"},"ea":[{"fa":{"ga":0,"ha":1,"ia":0,"ja":0,"ka":[]},"la":{"ga":0,"ha":1,"ia":0,"ja":1,"ka":[]},"ma":0,"na":10,"oa":10,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":1,"ia":0,"ja":2,"ka":[]},"la":{"ga":0,"ha":1,"ia":0,"ja":3,"ka":[]},"ma":0,"ta":14,"na":10,"oa":30,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":3,"ia":0,"ja":0,"ka":[]},"la":{"ga":0,"ha":3,"ia":0,"ja":1,"ka":[]},"ma":0,"ua":4,"na":40,"oa":40,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":3,"ia":0,"ja":2,"ka":[]},"la":{"ga":0,"ha":3,"ia":0,"ja":3,"ka":[]},"ma":0,"ua":4,"na":40,"oa":40,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":3,"ia":0,"ja":4,"ka":[]},"la":{"ga":0,"ha":3,"ia":0,"ja":5,"ka":[]},"ma":0,"ua":4,"na":40,"oa":40,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":3,"ia":0,"ja":6,"ka":[]},"la":{"ga":0,"ha":3,"ia":0,"ja":7,"ka":[]},"ma":0,"ua":4,"na":40,"oa":40,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":4,"ia":0,"ja":0,"ka":[]},"la":{"ga":0,"ha":4,"ia":0,"ja":1,"ka":[]},"ma":0,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":4,"ia":0,"ja":2,"ka":[]},"la":{"ga":0,"ha":4,"ia":0,"ja":3,"ka":[]},"ma":0,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":4,"ia":0,"ja":4,"ka":[]},"la":{"ga":0,"ha":4,"ia":0,"ja":5,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":4,"ia":0,"ja":6,"ka":[]},"la":{"ga":0,"ha":4,"ia":0,"ja":7,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":1,"ia":0,"ja":4,"ka":[]},"la":{"ga":0,"ha":1,"ia":0,"ja":5,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":1,"ia":0,"ja":6,"ka":[]},"la":{"ga":0,"ha":1,"ia":0,"ja":7,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":16,"ia":0,"ja":0,"ka":[]},"la":{"ga":0,"ha":17,"ia":0,"ja":0,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":18,"ia":0,"ja":0,"ka":[]},"la":{"ga":0,"ha":18,"ia":0,"ja":1,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":18,"ia":0,"ja":2,"ka":[]},"la":{"ga":0,"ha":18,"ia":0,"ja":3,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":18,"ia":0,"ja":4,"ka":[]},"la":{"ga":0,"ha":18,"ia":0,"ja":5,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":18,"ia":0,"ja":6,"ka":[]},"la":{"ga":0,"ha":18,"ia":0,"ja":7,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":20,"ia":0,"ja":0,"ka":[]},"la":{"ga":0,"ha":20,"ia":0,"ja":1,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":20,"ia":0,"ja":2,"ka":[]},"la":{"ga":0,"ha":20,"ia":0,"ja":3,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":20,"ia":0,"ja":4,"ka":[]},"la":{"ga":0,"ha":20,"ia":0,"ja":5,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":20,"ia":0,"ja":6,"ka":[]},"la":{"ga":0,"ha":20,"ia":0,"ja":7,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":21,"ia":0,"ja":0,"ka":[]},"la":{"ga":0,"ha":21,"ia":0,"ja":1,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":21,"ia":0,"ja":2,"ka":[]},"la":{"ga":0,"ha":21,"ia":0,"ja":3,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":21,"ia":0,"ja":4,"ka":[]},"la":{"ga":0,"ha":21,"ia":0,"ja":5,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":21,"ia":0,"ja":6,"ka":[]},"la":{"ga":0,"ha":21,"ia":0,"ja":7,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":22,"ia":0,"ja":0,"ka":[]},"la":{"ga":0,"ha":22,"ia":0,"ja":1,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":22,"ia":0,"ja":2,"ka":[]},"la":{"ga":0,"ha":22,"ia":0,"ja":3,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":22,"ia":0,"ja":4,"ka":[]},"la":{"ga":0,"ha":22,"ia":0,"ja":5,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":22,"ia":0,"ja":6,"ka":[]},"la":{"ga":0,"ha":22,"ia":0,"ja":7,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":27,"ia":0,"ja":0,"ka":[]},"la":{"ga":0,"ha":27,"ia":0,"ja":1,"ka":[]},"ua":4,"sa":"SmoSlur"}],"va":[{"ya":{"ya":-1,"za":0,"ab":0,"t":0},"bb":99.74000000000001,"cb":[],"db":[{"eb":[{"fb":{"gb":"2048","hb":1,"ib":0},"ka":[{"jb":"d","kb":5,"lb":"n"}],"da":"treble"}]}],"ea":[]},{"ya":{"ya":0,"za":1,"ab":1,"t":0},"bb":6,"cb":[],"db":[{"eb":[{"ka":[{"jb":"b","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":6}],"da":"treble","qb":6144},{"ka":[{"jb":"a","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":6}],"da":"treble","rb":true,"qb":2048},{"ka":[{"jb":"b","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":6}],"da":"treble","qb":6144},{"ka":[{"jb":"c","lb":"n","kb":6}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":6}],"da":"treble","rb":true,"qb":2048}]}],"ea":[]},{"ya":{"ya":1,"za":2,"ab":2,"t":0},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":6}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":6}],"da":"treble","qb":6144},{"ka":[{"jb":"c","lb":"n","kb":6}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":12288,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"#","kb":5},{"jb":"a","lb":"n","kb":5}],"da":"treble","qb":6144}]}],"ea":[]},{"ya":{"ya":2,"za":3,"ab":3,"t":0},"bb":6,"cb":[],"db":[{"eb":[{"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144},{"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","rb":true,"qb":2048},{"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144},{"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","rb":true,"qb":2048}]}],"ea":[]},{"ya":{"ya":3,"za":4,"ab":0,"t":0},"bb":99.74000000000001,"cb":[],"db":[{"eb":[{"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144},{"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","rb":true,"qb":2048},{"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144},{"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","rb":true,"qb":2048}]}],"ea":[]},{"ya":{"ya":4,"za":5,"ab":1,"t":0},"bb":6,"cb":[],"db":[{"eb":[{"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144},{"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","rb":true,"qb":2048},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"tb":" ","sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","qb":6144},{"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144}]}],"ea":[]},{"ld":true,"ya":{"ya":5,"za":6,"ab":0,"t":0},"bb":99.74000000000001,"cb":[],"db":[{"eb":[{"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144},{"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","rb":true,"qb":6144},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144},{"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","qb":6144}]}],"ea":[]},{"ya":{"ya":6,"za":7,"ab":1,"t":0},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","qb":6144},{"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble","qb":6144},{"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble","qb":6144}]}],"ea":[]},{"ld":true,"ya":{"ya":7,"za":8,"ab":0,"t":0},"bb":99.74000000000001,"cb":[],"db":[{"eb":[{"fb":{"gb":24576,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"oc":"r","da":"treble","qb":6144}]}],"ea":[]},{"ya":{"ya":8,"za":9,"ab":1,"t":0},"bb":6,"de":102,"cb":[],"db":[{"eb":[{"ka":[{"jb":"g","lb":"n","kb":4},{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"#","kb":4},{"jb":"a","lb":"n","kb":4}],"da":"treble","qb":6144},{"ka":[{"jb":"g","lb":"n","kb":4},{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"b","kb":4},{"jb":"d","lb":"n","kb":5}],"da":"treble","rb":true,"qb":2048},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4},{"jb":"e","lb":"b","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4},{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"b","kb":4,"pc":false}],"da":"treble","rb":true,"qb":6144},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":4},{"jb":"b","lb":"b","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":4},{"jb":"a","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":4},{"jb":"g","lb":"n","kb":4}],"da":"treble","rb":true,"qb":6144}]}],"ea":[]},{"ya":{"ya":9,"za":10,"ab":0,"t":0},"bb":99.74000000000001,"de":22,"cb":[],"db":[{"eb":[{"ka":[{"jb":"f","lb":"#","kb":4},{"jb":"a","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"#","kb":4},{"jb":"b","lb":"b","kb":4}],"da":"treble","qb":6144},{"ka":[{"jb":"e","lb":"b","kb":4},{"jb":"g","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"b","kb":4},{"jb":"g","lb":"n","kb":4}],"da":"treble","rb":true,"qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"#","kb":4},{"jb":"a","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"#","kb":4},{"jb":"b","lb":"b","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4},{"jb":"c","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4},{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4},{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144}]}],"ea":[]},{"ya":{"ya":10,"za":11,"ab":1,"t":0},"bb":6,"cb":[],"db":[{"eb":[{"ka":[{"jb":"c","lb":"n","kb":5},{"jb":"f","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"tb":" ","sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5},{"jb":"f","lb":"n","kb":5}],"da":"treble","rb":true,"qb":6144},{"ka":[{"jb":"c","lb":"n","kb":5},{"jb":"f","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5},{"jb":"f","lb":"n","kb":5}],"da":"treble","qb":6144},{"ka":[{"jb":"c","lb":"n","kb":5},{"jb":"f","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5},{"jb":"f","lb":"n","kb":5}],"da":"treble","qb":6144},{"ka":[{"jb":"c","lb":"n","kb":5},{"jb":"f","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"da":"treble","qb":6144}]}],"ea":[]},{"ld":true,"ya":{"ya":11,"za":12,"ab":0,"t":0},"bb":142.3,"cb":[],"db":[{"eb":[{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"b","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"b","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"da":"treble","qb":6144},{"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":4}],"da":"treble","qb":6144}]}],"ea":[]},{"ya":{"ya":12,"za":13,"ab":1,"t":0},"bb":6,"de":12,"cb":[],"db":[{"eb":[{"ka":[{"jb":"b","lb":"b","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"b","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":12288,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":5}],"da":"treble","qb":6144}]}],"ea":[]},{"ya":{"ya":13,"za":14,"ab":2,"t":0},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"b","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"b","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"da":"treble","qb":6144},{"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":4}],"da":"treble","qb":6144}]}],"ea":[]},{"ya":{"ya":14,"za":15,"ab":3,"t":0},"bb":6,"cb":[],"db":[{"eb":[{"ka":[{"jb":"b","lb":"b","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"da":"treble","rb":true,"qb":2048},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"b","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":12288,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":5}],"da":"treble","qb":6144}]}],"ea":[]},{"ya":{"ya":15,"za":16,"ab":0,"t":0},"bb":116.02000000000001,"cb":[],"db":[{"eb":[{"fb":{"gb":24576,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"da":"treble","qb":6144}]}],"ea":[]},{"ya":{"ya":16,"za":17,"ab":1,"t":0},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"oc":"r","da":"treble","qb":6144},{"fb":{"gb":12288,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"oc":"r","da":"treble","qb":6144}]}],"ea":[]},{"ld":true,"ya":{"ya":17,"za":18,"ab":0,"t":0},"bb":142.3,"cb":[],"db":[{"eb":[{"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144},{"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144},{"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144},{"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144}]}],"ea":[]},{"ya":{"ya":18,"za":19,"ab":1,"t":0},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144},{"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":12288,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"#","kb":4},{"jb":"a","lb":"n","kb":4}],"da":"treble","qb":6144}]}],"ea":[]},{"ld":true,"ya":{"ya":19,"za":20,"ab":0,"t":0},"bb":99.74000000000001,"cb":[],"db":[{"eb":[{"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144},{"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144},{"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144},{"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144}]}],"ea":[]},{"ya":{"ya":20,"za":21,"ab":1,"t":0},"bb":6,"cb":[],"db":[{"eb":[{"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144},{"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144},{"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144},{"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144}]}],"ea":[]},{"ld":true,"ya":{"ya":21,"za":22,"ab":0,"t":0},"bb":99.74000000000001,"cb":[],"db":[{"eb":[{"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144},{"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144},{"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144},{"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144}]}],"ea":[]},{"ya":{"ya":22,"za":23,"ab":1,"t":0},"bb":6,"cb":[],"db":[{"eb":[{"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144},{"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","rb":true,"qb":6144},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144},{"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"tb":"f","sa":"SmoDynamicText"}]}]}],"ea":[]},{"ld":true,"ya":{"ya":23,"za":24,"ab":0,"t":0},"bb":99.74000000000001,"cb":[],"db":[{"eb":[{"ka":[{"jb":"g","lb":"n","kb":4},{"jb":"e","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4},{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144},{"ka":[{"jb":"g","lb":"n","kb":4},{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":4},{"jb":"a","lb":"b","kb":4}],"da":"treble","qb":6144},{"ka":[{"jb":"e","lb":"b","kb":4},{"jb":"g","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"b","kb":4},{"jb":"g","lb":"n","kb":4}],"da":"treble","rb":true,"qb":2048},{"ka":[{"jb":"d","lb":"n","kb":4},{"jb":"f","lb":"#","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":4},{"jb":"g","lb":"n","kb":4}],"da":"treble","rb":true,"qb":6144}]}],"ea":[]},{"ya":{"ya":24,"za":25,"ab":1,"t":0},"bb":6,"cb":[],"db":[{"eb":[{"ka":[{"jb":"c","lb":"n","kb":4},{"jb":"f","lb":"#","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":4},{"jb":"f","lb":"#","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"b","kb":4},{"jb":"g","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"b","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"#","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"b","kb":5}],"da":"treble","qb":6144},{"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","qb":6144}]}],"ea":[]},{"ld":true,"ya":{"ya":25,"za":26,"ab":0,"t":0},"bb":99.74000000000001,"cb":[],"db":[{"eb":[{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble","qb":6144},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"b","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":5}],"da":"treble","qb":6144}]}],"ea":[]},{"ya":{"ya":26,"za":27,"ab":1,"t":0},"bb":24.48,"cb":[],"db":[{"eb":[{"fb":{"gb":12288,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4},{"jb":"b","lb":"b","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4},{"jb":"b","lb":"b","kb":4}],"da":"treble","qb":6144}]}],"ea":[]},{"ya":{"ya":27,"za":28,"ab":2,"t":0},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3},{"jb":"b","lb":"b","kb":3}],"da":"treble","qb":6144,"qc":[{"rc":"fermata","sa":"SmoArticulation"}]},{"fb":{"gb":12288,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"oc":"r","da":"treble","qb":6144}]}],"ea":[]},{"ld":true,"ya":{"ya":28,"za":29,"ab":0,"t":0},"bb":99.74000000000001,"cb":[],"db":[{"eb":[{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":6}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":6}],"da":"treble","qb":6144},{"ka":[{"jb":"c","lb":"n","kb":6}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":12288,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"#","kb":5},{"jb":"a","lb":"n","kb":5}],"da":"treble","qb":6144}]}],"ea":[]},{"ya":{"ya":29,"za":30,"ab":1,"t":0},"bb":6,"cb":[],"db":[{"eb":[{"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144},{"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","rb":true,"qb":6144},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144}]}],"ea":[{"ua":1,"tb":"a tempo","sa":"SmoMeasureText"}]},{"ya":{"ya":30,"za":31,"ab":2,"t":0},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":12288,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":5}],"da":"treble","qb":6144,"qc":[{"rc":"fermata","sa":"SmoArticulation"}]}]}],"ea":[]}]},{"t":1,"u":10,"v":40,"w":0,"x":1600,"y":90,"q":0,"r":{},"z":{},"aa":{"ba":"Bass Clef Staff","ca":0,"da":"bass"},"ea":[{"fa":{"ga":1,"ha":3,"ia":0,"ja":0,"ka":[]},"la":{"ga":1,"ha":3,"ia":0,"ja":3,"ka":[]},"ma":0,"ua":4,"na":40,"oa":40,"sa":"SmoSlur"},{"fa":{"ga":1,"ha":4,"ia":0,"ja":0,"ka":[]},"la":{"ga":1,"ha":4,"ia":0,"ja":3,"ka":[]},"ma":0,"ua":4,"na":40,"oa":40,"sa":"SmoSlur"},{"fa":{"ga":1,"ha":5,"ia":0,"ja":0,"ka":[]},"la":{"ga":1,"ha":5,"ia":0,"ja":3,"ka":[]},"ma":0,"ua":4,"na":40,"oa":40,"sa":"SmoSlur"},{"fa":{"ga":1,"ha":20,"ia":0,"ja":0,"ka":[]},"la":{"ga":1,"ha":20,"ia":0,"ja":3,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":1,"ha":21,"ia":0,"ja":0,"ka":[]},"la":{"ga":1,"ha":21,"ia":0,"ja":3,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":1,"ha":22,"ia":0,"ja":0,"ka":[]},"la":{"ga":1,"ha":22,"ia":0,"ja":3,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":1,"ha":22,"ia":0,"ja":0,"ka":[]},"la":{"ga":1,"ha":22,"ia":0,"ja":3,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":1,"ha":22,"ia":0,"ja":0,"ka":[]},"la":{"ga":1,"ha":22,"ia":0,"ja":3,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":1,"ha":23,"ia":0,"ja":0,"ka":[]},"la":{"ga":1,"ha":23,"ia":0,"ja":3,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":1,"ha":27,"ia":0,"ja":0,"ka":[]},"la":{"ga":1,"ha":27,"ia":0,"ja":1,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":1,"ha":30,"ia":0,"ja":2,"ka":[]},"la":{"ga":1,"ha":31,"ia":0,"ja":0,"ka":[]},"ua":4,"sa":"SmoSlur"}],"va":[{"ya":{"ya":-1,"za":0,"ab":0,"t":1},"da":"bass","bb":99.74000000000001,"cb":[],"db":[{"eb":[{"fb":{"gb":"2048","hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble"}]}],"ea":[]},{"ya":{"ya":0,"za":1,"ab":1,"t":1},"da":"bass","bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3},{"jb":"b","lb":"n","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"#","kb":3},{"jb":"c","lb":"n","kb":4}],"da":"bass","qb":6144},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3},{"jb":"b","lb":"n","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":3},{"jb":"c","lb":"n","kb":4}],"da":"bass","qb":6144}]}],"ea":[]},{"ya":{"ya":1,"za":2,"ab":2,"t":1},"da":"bass","bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":12288,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3},{"jb":"b","lb":"n","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":12288,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":3}],"da":"bass","qb":6144}]}],"ea":[]},{"ya":{"ya":2,"za":3,"ab":3,"t":1},"da":"bass","bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"#","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":3}],"da":"bass","qb":6144}]}],"ea":[]},{"ya":{"ya":3,"za":4,"ab":0,"t":1},"da":"bass","bb":99.74000000000001,"cb":[],"db":[{"eb":[{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"#","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":3}],"da":"bass","qb":6144}]}],"ea":[]},{"ya":{"ya":4,"za":5,"ab":1,"t":1},"da":"bass","bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"#","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":3}],"da":"bass","qb":6144}]}],"ea":[]},{"ld":true,"ya":{"ya":5,"za":6,"ab":0,"t":1},"da":"bass","bb":99.74000000000001,"cb":[],"db":[{"eb":[{"ka":[{"jb":"g","lb":"n","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3}],"da":"bass","qb":6144},{"ka":[{"jb":"g","lb":"n","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":3}],"oc":"r","da":"bass","qb":6144},{"ka":[{"jb":"d","lb":"n","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":3}],"da":"bass","qb":6144},{"ka":[{"jb":"d","lb":"n","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":3}],"oc":"r","da":"bass","qb":6144}]}],"ea":[]},{"ya":{"ya":6,"za":7,"ab":1,"t":1},"da":"bass","bb":6,"cb":[],"db":[{"eb":[{"ka":[{"jb":"g","lb":"n","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3}],"oc":"r","da":"bass","qb":6144},{"ka":[{"jb":"g","lb":"n","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3}],"oc":"r","da":"bass","qb":6144},{"ka":[{"jb":"g","lb":"n","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"#","kb":3}],"da":"bass","qb":6144},{"ka":[{"jb":"g","lb":"n","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3}],"da":"bass","qb":6144}]}],"ea":[]},{"ld":true,"ya":{"ya":7,"za":8,"ab":0,"t":1},"da":"bass","bb":99.74000000000001,"cb":[],"db":[{"eb":[{"ka":[{"jb":"g","lb":"n","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3}],"oc":"r","da":"bass","qb":6144},{"ka":[{"jb":"g","lb":"n","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":3}],"oc":"r","da":"bass","qb":6144},{"ka":[{"jb":"g","lb":"n","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"#","kb":3}],"da":"bass","qb":6144},{"ka":[{"jb":"g","lb":"n","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3}],"da":"bass","qb":6144}]}],"ea":[]},{"ya":{"ya":8,"za":9,"ab":1,"t":1},"da":"bass","bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":4}],"da":"bass","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":3}],"da":"bass","qb":6144}]}],"ea":[]},{"ya":{"ya":9,"za":10,"ab":0,"t":1},"da":"bass","bb":99.74000000000001,"cb":[],"db":[{"eb":[{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":4},{"jb":"d","lb":"n","kb":4}],"da":"bass","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":3}],"oc":"r","da":"bass","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":4}],"da":"bass","qb":6144},{"ka":[{"jb":"b","lb":"b","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":3}],"da":"bass","qb":6144},{"ka":[{"jb":"d","lb":"n","kb":4}],"da":"bass","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"b","kb":4}],"da":"bass","qb":6144},{"ka":[{"jb":"d","lb":"n","kb":4}],"da":"bass","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":4}],"da":"bass","qb":6144}]}],"ea":[]},{"ya":{"ya":10,"za":11,"ab":1,"t":1},"da":"bass","bb":6,"cb":[],"db":[{"eb":[{"ka":[{"jb":"a","lb":"n","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":3}],"da":"bass","qb":6144},{"ka":[{"jb":"a","lb":"n","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":3}],"da":"bass","qb":6144},{"ka":[{"jb":"a","lb":"n","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":3}],"da":"bass","qb":6144},{"ka":[{"jb":"a","lb":"n","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":3}],"oc":"r","da":"bass","qb":6144}]}],"ea":[]},{"ld":true,"ya":{"ya":11,"za":12,"ab":0,"t":1},"da":"bass","bb":142.3,"cb":[],"db":[{"eb":[{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":3},{"jb":"d","lb":"n","kb":4}],"da":"bass","qb":6144},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":3},{"jb":"e","lb":"b","kb":4}],"da":"bass","qb":6144},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":3},{"jb":"e","lb":"b","kb":4}],"da":"bass","qb":6144}]}],"ea":[]},{"ya":{"ya":12,"za":13,"ab":1,"t":1},"da":"bass","bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":3},{"jb":"d","lb":"n","kb":4}],"da":"bass","qb":6144},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":3},{"jb":"e","lb":"b","kb":4}],"da":"bass","qb":6144},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":3},{"jb":"e","lb":"b","kb":4}],"da":"bass","qb":6144}]}],"ea":[]},{"ya":{"ya":13,"za":14,"ab":2,"t":1},"da":"bass","bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":3},{"jb":"d","lb":"n","kb":4}],"da":"bass","qb":6144},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":3},{"jb":"e","lb":"b","kb":4}],"da":"bass","qb":6144},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":3},{"jb":"d","lb":"n","kb":4}],"da":"bass","qb":6144},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":3},{"jb":"e","lb":"b","kb":4}],"da":"bass","qb":6144}]}],"ea":[]},{"ya":{"ya":14,"za":15,"ab":3,"t":1},"da":"bass","bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":3},{"jb":"d","lb":"n","kb":4}],"da":"bass","qb":6144},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":3},{"jb":"e","lb":"b","kb":4}],"da":"bass","qb":6144},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":3},{"jb":"d","lb":"n","kb":4}],"da":"bass","qb":6144},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":3},{"jb":"c","lb":"n","kb":4}],"da":"bass","qb":6144}]}],"ea":[]},{"ya":{"ya":15,"za":16,"ab":0,"t":1},"sc":1,"da":"bass","bb":116.02000000000001,"cb":[],"db":[{"eb":[{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":3}],"da":"bass","qb":6144,"tc":2},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":3}],"da":"bass","qb":6144,"tc":2},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":3}],"da":"bass","qb":6144,"tc":2},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":3}],"da":"bass","qb":6144,"tc":2}]},{"eb":[{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":4}],"da":"bass","qb":6144,"tc":1},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"b","kb":4}],"da":"bass","qb":6144,"tc":1},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":4}],"da":"bass","qb":6144,"tc":1},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":4}],"da":"bass","qb":6144,"tc":1},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"b","kb":4}],"da":"bass","qb":6144,"tc":1},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":4}],"da":"bass","qb":6144,"tc":1},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":4}],"da":"bass","qb":6144,"tc":1},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"b","kb":4}],"da":"bass","qb":6144,"tc":1},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":4}],"da":"bass","qb":6144,"tc":1},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":4}],"da":"bass","qb":6144,"tc":1},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"b","kb":4}],"da":"bass","qb":6144,"tc":1},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":4}],"da":"bass","qb":6144,"tc":1}]}],"ea":[]},{"ya":{"ya":16,"za":17,"ab":1,"t":1},"sc":1,"da":"bass","bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":3}],"da":"bass","qb":6144,"tc":2},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":3}],"da":"bass","qb":6144,"tc":2},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":3}],"da":"bass","qb":6144,"tc":2},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":3}],"da":"bass","qb":6144,"tc":2}]},{"eb":[{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":4}],"da":"bass","qb":6144,"tc":1},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":4}],"da":"bass","qb":6144,"tc":1},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":3}],"da":"bass","qb":6144,"tc":1},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":4}],"da":"bass","qb":6144,"tc":1},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":3}],"da":"bass","qb":6144,"tc":1},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":3}],"da":"bass","qb":6144,"tc":1},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":3}],"da":"bass","qb":6144,"tc":1},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":3}],"da":"bass","qb":6144,"tc":1},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3}],"da":"bass","qb":6144,"tc":1},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":3}],"da":"bass","qb":6144,"tc":1},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":3}],"da":"bass","qb":6144,"tc":1},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":4}],"da":"bass","qb":6144,"tc":1}]}],"ea":[]},{"ld":true,"ya":{"ya":17,"za":18,"ab":0,"t":1},"da":"bass","bb":142.3,"cb":[],"db":[{"eb":[{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3},{"jb":"b","lb":"n","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"#","kb":3},{"jb":"c","lb":"n","kb":4}],"da":"bass","qb":6144},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3},{"jb":"b","lb":"n","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":3},{"jb":"c","lb":"n","kb":4}],"da":"bass","qb":6144}]}],"ea":[]},{"ya":{"ya":18,"za":19,"ab":1,"t":1},"da":"bass","bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":12288,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3},{"jb":"b","lb":"n","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":12288,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":3}],"da":"bass","qb":6144}]}],"ea":[]},{"ld":true,"ya":{"ya":19,"za":20,"ab":0,"t":1},"da":"bass","bb":99.74000000000001,"cb":[],"db":[{"eb":[{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"#","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":3}],"da":"bass","qb":6144}]}],"ea":[]},{"ya":{"ya":20,"za":21,"ab":1,"t":1},"da":"bass","bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"#","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":3}],"da":"bass","qb":6144}]}],"ea":[]},{"ld":true,"ya":{"ya":21,"za":22,"ab":0,"t":1},"da":"bass","bb":99.74000000000001,"cb":[],"db":[{"eb":[{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"#","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":3}],"da":"bass","qb":6144}]}],"ea":[]},{"ya":{"ya":22,"za":23,"ab":1,"t":1},"da":"bass","bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"#","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3}],"da":"bass","qb":6144},{"ka":[{"jb":"g","lb":"n","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3}],"da":"bass","qb":6144,"sb":[{"tb":" ","sa":"SmoLyric"},{"tb":"f","sa":"SmoDynamicText"}]}]}],"ea":[]},{"ld":true,"ya":{"ya":23,"za":24,"ab":0,"t":1},"da":"bass","bb":99.74000000000001,"cb":[],"db":[{"eb":[{"ka":[{"jb":"g","lb":"n","kb":2}],"da":"bass","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":3}],"da":"bass","rb":true,"qb":6144},{"ka":[{"jb":"g","lb":"n","kb":2}],"da":"bass","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":2}],"da":"bass","qb":6144},{"ka":[{"jb":"c","lb":"n","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":2}],"da":"bass","qb":6144},{"ka":[{"jb":"b","lb":"b","kb":2}],"da":"bass","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":3}],"da":"bass","qb":6144}]}],"ea":[]},{"ya":{"ya":24,"za":25,"ab":1,"t":1},"da":"bass","bb":6,"cb":[],"db":[{"eb":[{"ka":[{"jb":"a","lb":"n","kb":2}],"da":"bass","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":3}],"da":"bass","rb":true,"qb":6144},{"ka":[{"jb":"g","lb":"n","kb":2}],"da":"bass","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":2}],"da":"bass","rb":true,"qb":6144},{"ka":[{"jb":"c","lb":"n","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":2}],"da":"bass","qb":6144},{"ka":[{"jb":"b","lb":"b","kb":2}],"da":"bass","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":2}],"da":"bass","qb":6144}]}],"ea":[]},{"ld":true,"ya":{"ya":25,"za":26,"ab":0,"t":1},"da":"bass","bb":99.74000000000001,"cb":[],"db":[{"eb":[{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":3}],"oc":"r","da":"bass","qb":6144},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":2}],"da":"bass","qb":6144},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":2}],"da":"bass","qb":6144},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":3}],"da":"bass","qb":6144}]}],"ea":[]},{"ya":{"ya":26,"za":27,"ab":1,"t":1},"da":"bass","bb":24.48,"cb":[],"db":[{"eb":[{"fb":{"gb":12288,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"b","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"b","kb":3}],"da":"bass","qb":6144}]}],"ea":[]},{"ya":{"ya":27,"za":28,"ab":2,"t":1},"da":"bass","bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"b","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":12288,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":3}],"oc":"r","da":"bass","qb":6144}]}],"ea":[]},{"ld":true,"ya":{"ya":28,"za":29,"ab":0,"t":1},"da":"bass","bb":99.74000000000001,"cb":[],"db":[{"eb":[{"fb":{"gb":12288,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3},{"jb":"b","lb":"n","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":12288,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":3}],"da":"bass","qb":6144,"qc":[{"rc":"fermata","sa":"SmoArticulation"}]}]}],"ea":[]},{"ya":{"ya":29,"za":30,"ab":1,"t":1},"da":"bass","bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"#","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":12288,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3}],"da":"bass","qb":6144}]}],"ea":[]},{"ya":{"ya":30,"za":31,"ab":2,"t":1},"da":"bass","bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":12288,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3}],"da":"bass","qb":6144}]}],"ea":[]}]},{"t":2,"u":10,"v":40,"w":0,"x":1600,"y":90,"q":0,"r":{},"z":{},"aa":{"ba":"Treble Clef Staff","ca":0,"da":"treble"},"ea":[{"fa":{"ga":2,"ha":3,"ia":0,"ja":0,"ka":[]},"la":{"ga":2,"ha":3,"ia":0,"ja":1,"ka":[]},"ma":-10,"na":10,"oa":10,"sa":"SmoSlur"},{"fa":{"ga":2,"ha":3,"ia":0,"ja":3,"ka":[]},"la":{"ga":2,"ha":3,"ia":0,"ja":4,"ka":[]},"ma":-10,"ua":"2","na":10,"oa":10,"sa":"SmoSlur"},{"fa":{"ga":2,"ha":3,"ia":0,"ja":6,"ka":[]},"la":{"ga":2,"ha":3,"ia":0,"ja":7,"ka":[]},"ma":-10,"na":10,"oa":10,"sa":"SmoSlur"},{"fa":{"ga":2,"ha":4,"ia":0,"ja":5,"ka":[]},"la":{"ga":2,"ha":4,"ia":0,"ja":6,"ka":[]},"sa":"SmoSlur"},{"fa":{"ga":2,"ha":9,"ia":0,"ja":0,"ka":[]},"la":{"ga":2,"ha":9,"ia":0,"ja":1,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":2,"ha":8,"ia":0,"ja":6,"ka":[]},"la":{"ga":2,"ha":9,"ia":0,"ja":0,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":2,"ha":11,"ia":0,"ja":0,"ka":[]},"la":{"ga":2,"ha":11,"ia":0,"ja":1,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":2,"ha":11,"ia":0,"ja":1,"ka":[]},"la":{"ga":2,"ha":11,"ia":0,"ja":2,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":2,"ha":7,"ia":0,"ja":0,"ka":[]},"la":{"ga":2,"ha":7,"ia":0,"ja":1,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":2,"ha":7,"ia":0,"ja":3,"ka":[]},"la":{"ga":2,"ha":7,"ia":0,"ja":4,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":2,"ha":8,"ia":0,"ja":0,"ka":[]},"la":{"ga":2,"ha":8,"ia":0,"ja":1,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":2,"ha":8,"ia":0,"ja":3,"ka":[]},"la":{"ga":2,"ha":8,"ia":0,"ja":4,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":2,"ha":19,"ia":0,"ja":5,"ka":[]},"la":{"ga":2,"ha":19,"ia":0,"ja":6,"ka":[]},"ma":-14,"sa":"SmoSlur"},{"fa":{"ga":2,"ha":21,"ia":0,"ja":0,"ka":[]},"la":{"ga":2,"ha":21,"ia":0,"ja":1,"ka":[]},"ma":-14,"sa":"SmoSlur"},{"fa":{"ga":2,"ha":20,"ia":0,"ja":0,"ka":[]},"la":{"ga":2,"ha":20,"ia":0,"ja":9,"ka":[]},"uc":true,"sa":"SmoSlur"},{"fa":{"ga":2,"ha":21,"ia":0,"ja":3,"ka":[]},"la":{"ga":2,"ha":21,"ia":0,"ja":4,"ka":[]},"ma":-10,"sa":"SmoSlur"},{"fa":{"ga":2,"ha":21,"ia":0,"ja":6,"ka":[]},"la":{"ga":2,"ha":21,"ia":0,"ja":7,"ka":[]},"ma":-12,"sa":"SmoSlur"},{"fa":{"ga":2,"ha":24,"ia":0,"ja":0,"ka":[]},"la":{"ga":2,"ha":24,"ia":0,"ja":1,"ka":[]},"ma":-10,"sa":"SmoSlur"},{"fa":{"ga":2,"ha":28,"ia":0,"ja":0,"ka":[]},"la":{"ga":2,"ha":28,"ia":0,"ja":1,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":2,"ha":29,"ia":0,"ja":0,"ka":[]},"la":{"ga":2,"ha":29,"ia":0,"ja":4,"ka":[]},"ua":4,"sa":"SmoSlur"}],"va":[{"ya":{"ya":-1,"za":0,"ab":0,"t":2},"bb":99.74000000000001,"cb":[],"db":[{"eb":[{"fb":{"gb":"2048","hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble","qb":6144}]}],"ea":[]},{"ya":{"ya":0,"za":1,"ab":1,"t":2},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":24576,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble","qb":6144}]}],"ea":[]},{"ya":{"ya":1,"za":2,"ab":2,"t":2},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":12288,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble","qb":6144},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble","qb":6144},{"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"tb":"Ne-","sa":"SmoLyric"}]}]}],"ea":[]},{"ya":{"ya":2,"za":3,"ab":3,"t":2},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"tb":" ll'u-","sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"tb":"u   ","sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"tb":"ni   ","sa":"SmoLyric"}]},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"tb":"mile-","sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"tb":"i   ","sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"tb":"cap-","sa":"SmoLyric"}]},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"tb":"a   ","sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"tb":"- ","sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"tb":"- ","sa":"SmoLyric"}]},{"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"tb":"nna","sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"tb":"nel ","sa":"SmoLyric"}]}]}],"ea":[]},{"ya":{"ya":3,"za":4,"ab":0,"t":2},"bb":99.74000000000001,"cb":[],"db":[{"eb":[{"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"tb":"fre- ","sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","rb":true,"qb":6144,"sb":[{"tb":"ddo  ","sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"tb":"e  ","sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"tb":"po- ","sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","rb":true,"qb":6144,"sb":[{"tb":"ver- ","sa":"SmoLyric"}]},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"tb":"ta  ","sa":"SmoLyric"}]},{"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble","qb":6144}]}],"ea":[]},{"ya":{"ya":4,"za":5,"ab":1,"t":2},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":24576,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble","qb":6144}]}],"ea":[]},{"ld":true,"ya":{"ya":5,"za":6,"ab":0,"t":2},"bb":99.74000000000001,"cb":[],"db":[{"eb":[{"fb":{"gb":12288,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble","qb":6144},{"fb":{"gb":8192,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"tb":"O- ","sa":"SmoLyric"}]}]}],"ea":[]},{"ya":{"ya":6,"za":7,"ab":1,"t":2},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"tb":"sa- ","sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"#","kb":5}],"da":"treble","qb":6144,"sb":[{"tb":"nna  ","sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"tb":"O  ","sa":"SmoLyric"}]},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"tb":"sa- ","sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"#","kb":5}],"da":"treble","qb":6144,"sb":[{"tb":"- ","sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"tb":"nna  ","sa":"SmoLyric"}]},{"ka":[{"jb":"e","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"tb":"can  ","sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","rb":true,"qb":6144,"sb":[{"tb":"ta- ","sa":"SmoLyric"}]},{"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"tb":"no  ","sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"tb":"con  ","sa":"SmoLyric"}]}]}],"ea":[]},{"ld":true,"ya":{"ya":7,"za":8,"ab":0,"t":2},"bb":99.74000000000001,"cb":[],"db":[{"eb":[{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"tb":"gui- ","sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"#","kb":5}],"da":"treble","qb":6144,"sb":[{"tb":"- ","sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":5}],"da":"treble","rb":true,"qb":6144,"sb":[{"tb":"bi  ","sa":"SmoLyric"}]},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"tb":" lan-","sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"#","kb":5}],"da":"treble","qb":6144,"sb":[{"tb":"- ","sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":5}],"da":"treble","rb":true,"qb":6144,"sb":[{"tb":"te  ","sa":"SmoLyric"}]},{"fb":{"gb":12288,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"tb":"cor ","sa":"SmoLyric"}]}]}],"ea":[]},{"ya":{"ya":8,"za":9,"ab":1,"t":2},"bb":6,"de":92,"cb":[],"db":[{"eb":[{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144},{"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","rb":true,"qb":2048,"sb":[{"tb":"I  ","sa":"SmoLyric"}]},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"b","kb":5}],"da":"treble","qb":6144,"sb":[{"tb":"tuo  ","sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"tb":"- ","sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"tb":"i  ","sa":"SmoLyric"}]},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"da":"treble","qb":6144,"sb":[{"tb":"pa- ","sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"tb":"sto- ","sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"tb":"ri  ","sa":"SmoLyric"}]}]}],"ea":[]},{"ya":{"ya":9,"za":10,"ab":0,"t":2},"bb":99.74000000000001,"cb":[],"db":[{"eb":[{"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"tb":"an- ","sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"da":"treble","qb":6144,"sb":[{"tb":"gel- ","sa":"SmoLyric"}]},{"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"tb":"i  ","sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"tb":"o  ","sa":"SmoLyric"}]},{"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"tb":"re- ","sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"da":"treble","qb":6144,"sb":[{"tb":"di  ","sa":"SmoLyric"}]},{"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"tb":"luce  ","sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"tb":"e'a  ","sa":"SmoLyric"}]}]}],"ea":[]},{"ya":{"ya":10,"za":11,"ab":1,"t":2},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":12288,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"tb":"more ","sa":"SmoLyric"}]},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":5}],"da":"treble","qb":6144},{"ka":[{"jb":"f","lb":"n","kb":5}],"da":"treble","qb":6144,"qc":[{"ua":"below","rc":"fermata","sa":"SmoArticulation"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble","qb":6144}]}],"ea":[]},{"ld":true,"ya":{"ya":11,"za":12,"ab":0,"t":2},"bb":142.3,"cb":[],"db":[{"eb":[{"fb":{"gb":24576,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"oc":"r","da":"treble","qb":6144}]}],"ea":[]},{"ya":{"ya":12,"za":13,"ab":1,"t":2},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":24576,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"oc":"r","da":"treble","qb":6144}]}],"ea":[]},{"ya":{"ya":13,"za":14,"ab":2,"t":2},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":24576,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"oc":"r","da":"treble","qb":6144}]}],"ea":[]},{"ya":{"ya":14,"za":15,"ab":3,"t":2},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":24576,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"oc":"r","da":"treble","qb":6144}]}],"ea":[]},{"ya":{"ya":15,"za":16,"ab":0,"t":2},"bb":116.02000000000001,"cb":[],"db":[{"eb":[{"fb":{"gb":24576,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"oc":"r","da":"treble","qb":6144}]}],"ea":[]},{"ya":{"ya":16,"za":17,"ab":1,"t":2},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":12288,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"oc":"r","da":"treble","qb":6144},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"oc":"r","da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"oc":"r","da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"oc":"r","da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":2048,"sb":[{"tb":"Ah- ","sa":"SmoLyric"}]}]}],"ea":[]},{"ld":true,"ya":{"ya":17,"za":18,"ab":0,"t":2},"bb":142.3,"cb":[],"db":[{"eb":[{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"tb":"- ","sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"tb":" ","sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"tb":"- ","sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"tb":"  ","sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"tb":"  ","sa":"SmoLyric"}]},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"tb":"- ","sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"tb":" ","sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","qb":6144},{"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"tb":"Ve ","sa":"SmoLyric"}]}]}],"ea":[]},{"ya":{"ya":18,"za":19,"ab":1,"t":2},"bb":6,"cb":[],"db":[{"eb":[{"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"tb":"ni- ","sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","rb":true,"qb":6144,"sb":[{"tb":"te  ","sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"tb":"a- ","sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"tb":"do- ","sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"tb":"re- ","sa":"SmoLyric"}]},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"tb":"mus ","sa":"SmoLyric"}]},{"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"tb":"Ah!  ","sa":"SmoLyric"}]}]}],"ea":[]},{"ld":true,"ya":{"ya":19,"za":20,"ab":0,"t":2},"bb":99.74000000000001,"cb":[],"db":[{"eb":[{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"tb":"- ","sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"tb":"  ","sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"tb":"- ","sa":"SmoLyric"}]},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"tb":"  ","sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"tb":"- ","sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"tb":"  ","sa":"SmoLyric"}]},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"tb":"- ","sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"tb":" ","sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","qb":6144},{"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":4}],"da":"treble","qb":2048,"sb":[{"tb":"a- ","sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":4}],"da":"treble","rb":true,"qb":2048,"sb":[{"tb":"do  ","sa":"SmoLyric"}]}]}],"ea":[]},{"ya":{"ya":20,"za":21,"ab":1,"t":2},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"tb":"re- ","sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"tb":"- ","sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"tb":"mus  ","sa":"SmoLyric"}]},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"tb":"Do- ","sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"tb":"- ","sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"tb":"mi- ","sa":"SmoLyric"}]},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"tb":"num ","sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","rb":true,"qb":2048},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"tb":"ve- ","sa":"SmoLyric"}]}]}],"ea":[]},{"ld":true,"ya":{"ya":21,"za":22,"ab":0,"t":2},"bb":99.74000000000001,"cb":[],"db":[{"eb":[{"fb":{"gb":12288,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"tb":"ni- ","sa":"SmoLyric"}]},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"tb":"te ","sa":"SmoLyric"}]},{"ka":[{"jb":"d","lb":"n","kb":5}],"oc":"r","da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"tb":"ve- ","sa":"SmoLyric"},{"wc":2,"tb":"p","sa":"SmoDynamicText"}]}]}],"ea":[]},{"ya":{"ya":22,"za":23,"ab":1,"t":2},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":12288,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"tb":"ni- ","sa":"SmoLyric"}]},{"fb":{"gb":12288,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"tb":"te ","sa":"SmoLyric"}]}]}],"ea":[]},{"ld":true,"ya":{"ya":23,"za":24,"ab":0,"t":2},"bb":99.74000000000001,"cb":[],"db":[{"eb":[{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144},{"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","rb":true,"qb":2048,"sb":[{"tb":"ve- ","sa":"SmoLyric"}]},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"b","kb":5}],"da":"treble","qb":6144,"sb":[{"tb":"ni- ","sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"tb":"- ","sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","rb":true,"qb":6144,"sb":[{"tb":"te  ","sa":"SmoLyric"}]},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"da":"treble","qb":6144,"sb":[{"tb":"a  ","sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"tb":"- ","sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"tb":"dor- ","sa":"SmoLyric"}]}]}],"ea":[]},{"ya":{"ya":24,"za":25,"ab":1,"t":2},"bb":6,"cb":[],"db":[{"eb":[{"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"tb":"re  ","sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"da":"treble","qb":6144,"sb":[{"tb":"- ","sa":"SmoLyric"}]},{"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"tb":"mus ","sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"oc":"r","da":"treble","rb":true,"qb":2048},{"fb":{"gb":12288,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"oc":"r","da":"treble","qb":6144}]}],"ea":[]},{"ld":true,"ya":{"ya":25,"za":26,"ab":0,"t":2},"bb":99.74000000000001,"cb":[],"db":[{"eb":[{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble","qb":6144},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"da":"treble","qb":6144,"sb":[{"tb":"A- ","sa":"SmoLyric"}]},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"b","kb":5}],"da":"treble","qb":6144,"sb":[{"tb":"  ","sa":"SmoLyric"}]},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"tb":"do- ","sa":"SmoLyric"}]}]}],"ea":[]},{"ya":{"ya":26,"za":27,"ab":1,"t":2},"bb":24.48,"cb":[],"db":[{"eb":[{"fb":{"gb":12288,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":5}],"da":"treble","qb":6144,"sb":[{"tb":"- ","sa":"SmoLyric"}]},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"tb":"re- ","sa":"SmoLyric"}]}]}],"ea":[]},{"ya":{"ya":27,"za":28,"ab":2,"t":2},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":12288,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"b","kb":5}],"da":"treble","qb":6144,"sb":[{"tb":"mus ","sa":"SmoLyric"}],"qc":[{"rc":"fermata","sa":"SmoArticulation"}]},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"b","kb":5}],"da":"treble","qb":6144}]}],"ea":[]},{"ld":true,"ya":{"ya":28,"za":29,"ab":0,"t":2},"bb":99.74000000000001,"cb":[],"db":[{"eb":[{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"tb":"Do  ","sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"tb":"  ","sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"tb":"- ","sa":"SmoLyric"}]},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"tb":"  ","sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"tb":"  ","sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"tb":"mi  ","sa":"SmoLyric"}]},{"fb":{"gb":12288,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"tb":"num ","sa":"SmoLyric"}],"qc":[{"rc":"fermata","sa":"SmoArticulation"}]}]}],"ea":[]},{"ya":{"ya":29,"za":30,"ab":1,"t":2},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":24576,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble","qb":6144}]}],"ea":[]},{"ya":{"ya":30,"za":31,"ab":2,"t":2},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":24576,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble","qb":6144}]}],"ea":[]}]},{"t":3,"u":10,"v":40,"w":0,"x":1600,"y":90,"q":0,"r":{},"z":{},"aa":{"ba":"Treble Clef Staff","ca":0,"da":"treble"},"ea":[{"fa":{"ga":3,"ha":6,"ia":0,"ja":6,"ka":[]},"la":{"ga":3,"ha":6,"ia":0,"ja":7,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":3,"ha":6,"ia":0,"ja":6,"ka":[]},"la":{"ga":3,"ha":6,"ia":0,"ja":7,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":3,"ha":11,"ia":0,"ja":0,"ka":[]},"la":{"ga":3,"ha":11,"ia":0,"ja":1,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":3,"ha":11,"ia":0,"ja":1,"ka":[]},"la":{"ga":3,"ha":11,"ia":0,"ja":2,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":3,"ha":7,"ia":0,"ja":0,"ka":[]},"la":{"ga":3,"ha":7,"ia":0,"ja":1,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":3,"ha":7,"ia":0,"ja":3,"ka":[]},"la":{"ga":3,"ha":7,"ia":0,"ja":4,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":3,"ha":8,"ia":0,"ja":0,"ka":[]},"la":{"ga":3,"ha":8,"ia":0,"ja":1,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":3,"ha":8,"ia":0,"ja":3,"ka":[]},"la":{"ga":3,"ha":8,"ia":0,"ja":4,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":3,"ha":20,"ia":0,"ja":0,"ka":[]},"la":{"ga":3,"ha":20,"ia":0,"ja":1,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":3,"ha":22,"ia":0,"ja":6,"ka":[]},"la":{"ga":3,"ha":22,"ia":0,"ja":7,"ka":[]},"ma":-9,"sa":"SmoSlur"},{"fa":{"ga":3,"ha":24,"ia":0,"ja":0,"ka":[]},"la":{"ga":3,"ha":24,"ia":0,"ja":1,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":3,"ha":25,"ia":0,"ja":0,"ka":[]},"la":{"ga":3,"ha":25,"ia":0,"ja":1,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":3,"ha":18,"ia":0,"ja":4,"ka":[]},"la":{"ga":3,"ha":19,"ia":0,"ja":3,"ka":[]},"uc":true,"sa":"SmoSlur"},{"fa":{"ga":3,"ha":28,"ia":0,"ja":0,"ka":[]},"la":{"ga":3,"ha":28,"ia":0,"ja":1,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":3,"ha":20,"ia":0,"ja":3,"ka":[]},"la":{"ga":3,"ha":20,"ia":0,"ja":8,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":3,"ha":29,"ia":0,"ja":0,"ka":[]},"la":{"ga":3,"ha":29,"ia":0,"ja":4,"ka":[]},"sa":"SmoSlur"},{"fa":{"ga":3,"ha":22,"ia":0,"ja":0,"ka":[]},"la":{"ga":3,"ha":22,"ia":0,"ja":1,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":3,"ha":22,"ia":0,"ja":3,"ka":[]},"la":{"ga":3,"ha":22,"ia":0,"ja":4,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":3,"ha":23,"ia":0,"ja":0,"ka":[]},"la":{"ga":3,"ha":23,"ia":0,"ja":1,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":3,"ha":23,"ia":0,"ja":3,"ka":[]},"la":{"ga":3,"ha":23,"ia":0,"ja":4,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":3,"ha":5,"ia":0,"ja":0,"ka":[]},"la":{"ga":3,"ha":5,"ia":0,"ja":1,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":3,"ha":5,"ia":0,"ja":3,"ka":[]},"la":{"ga":3,"ha":5,"ia":0,"ja":4,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":3,"ha":5,"ia":0,"ja":6,"ka":[]},"la":{"ga":3,"ha":5,"ia":0,"ja":7,"ka":[]},"ua":4,"sa":"SmoSlur"}],"va":[{"ya":{"ya":-1,"za":0,"ab":0,"t":3},"bb":99.74000000000001,"cb":[],"db":[{"eb":[{"fb":{"gb":"2048","hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble","qb":6144}]}],"ea":[]},{"ya":{"ya":0,"za":1,"ab":1,"t":3},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":24576,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble","qb":6144}]}],"ea":[]},{"ya":{"ya":1,"za":2,"ab":2,"t":3},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":24576,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144}]}],"ea":[]},{"ya":{"ya":2,"za":3,"ab":3,"t":3},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":24576,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble","qb":6144}]}],"ea":[]},{"ya":{"ya":3,"za":4,"ab":0,"t":3},"bb":99.74000000000001,"cb":[],"db":[{"eb":[{"fb":{"gb":12288,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble","qb":6144},{"fb":{"gb":8192,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"tb":"e  ","sa":"SmoLyric"}]}]}],"ea":[]},{"ya":{"ya":4,"za":5,"ab":1,"t":3},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"tb":"na- ","sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"tb":"to  ","sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"tb":"il  ","sa":"SmoLyric"}]},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"tb":"Sa- ","sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"tb":"  ","sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"tb":"nto  ","sa":"SmoLyric"}]},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"tb":"pa- ","sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"tb":"- ","sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","rb":true,"qb":6144,"sb":[{"tb":"rgo- ","sa":"SmoLyric"}]},{"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"tb":"lo  ","sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":4}],"da":"treble","qb":2048,"sb":[{"tb":"che- ","sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":4}],"da":"treble","rb":true,"qb":2048,"sb":[{"tb":"il ","sa":"SmoLyric"}]}]}],"ea":[]},{"ld":true,"ya":{"ya":5,"za":6,"ab":0,"t":3},"bb":99.74000000000001,"cb":[],"db":[{"eb":[{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"tb":"mo- ","sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"tb":"- ","sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"tb":"ndo  ","sa":"SmoLyric"}]},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"tb":"a- ","sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"tb":"do- ","sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"tb":"re  ","sa":"SmoLyric"}]},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"tb":"ra  ","sa":"SmoLyric"}]},{"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"tb":" ","sa":"SmoLyric"},{"tb":"f","sa":"SmoDynamicText"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"tb":"O- ","sa":"SmoLyric"}]}]}],"ea":[]},{"ya":{"ya":6,"za":7,"ab":1,"t":3},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"tb":"sa- ","sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"tb":"nna  ","sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"tb":"O  ","sa":"SmoLyric"}]},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"tb":"sa- ","sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"tb":"- ","sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"tb":"na  ","sa":"SmoLyric"}]},{"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"tb":"can- ","sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","rb":true,"qb":6144,"sb":[{"tb":"ta- ","sa":"SmoLyric"}]},{"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"tb":"no  ","sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"tb":"con  ","sa":"SmoLyric"}]}]}],"ea":[]},{"ld":true,"ya":{"ya":7,"za":8,"ab":0,"t":3},"bb":99.74000000000001,"cb":[],"db":[{"eb":[{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"tb":"gui- ","sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"tb":"- ","sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":5}],"da":"treble","rb":true,"qb":6144,"sb":[{"tb":"bi  ","sa":"SmoLyric"}]},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"tb":"lan- ","sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"tb":"- ","sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","rb":true,"qb":6144,"sb":[{"tb":"te  ","sa":"SmoLyric"}]},{"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"tb":" cor ","sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"tb":"con  ","sa":"SmoLyric"}]},{"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"tb":"bui- ","sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"tb":"bi- ","sa":"SmoLyric"}]}]}],"ea":[]},{"ya":{"ya":8,"za":9,"ab":1,"t":3},"bb":6,"cb":[],"db":[{"eb":[{"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"tb":"la- ","sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"tb":"nte  ","sa":"SmoLyric"}]},{"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"tb":"core  ","sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","rb":true,"qb":2048,"sb":[{"tb":"I  ","sa":"SmoLyric"}]},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"da":"treble","qb":6144,"sb":[{"tb":"tuo- ","sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"da":"treble","qb":6144,"sb":[{"tb":"   ","sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"da":"treble","qb":6144,"sb":[{"tb":"i  ","sa":"SmoLyric"}]},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"da":"treble","qb":6144,"sb":[{"tb":"pa- ","sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"tb":"sto-  ","sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"tb":"ri  ","sa":"SmoLyric"}]}]}],"ea":[]},{"ya":{"ya":9,"za":10,"ab":0,"t":3},"bb":99.74000000000001,"cb":[],"db":[{"eb":[{"ka":[{"jb":"f","lb":"#","kb":4}],"da":"treble","qb":6144,"sb":[{"tb":"an-  ","sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"#","kb":4}],"da":"treble","qb":6144,"sb":[{"tb":"gel-  ","sa":"SmoLyric"}]},{"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"tb":"i   ","sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"tb":"o  ","sa":"SmoLyric"}]},{"ka":[{"jb":"f","lb":"#","kb":4}],"da":"treble","qb":6144,"sb":[{"tb":"re-  ","sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"tb":"di   ","sa":"SmoLyric"}]},{"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"tb":"luce  ","sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"da":"treble","qb":6144,"sb":[{"tb":"e'a  ","sa":"SmoLyric"}]}]}],"ea":[]},{"ya":{"ya":10,"za":11,"ab":1,"t":3},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":12288,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"tb":"more ","sa":"SmoLyric"}]},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble","qb":6144},{"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble","qb":6144,"qc":[{"rc":"fermata","sa":"SmoArticulation"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble","qb":6144}]}],"ea":[]},{"ld":true,"ya":{"ya":11,"za":12,"ab":0,"t":3},"bb":142.3,"cb":[],"db":[{"eb":[{"fb":{"gb":24576,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"oc":"r","da":"treble","qb":6144}]}],"ea":[]},{"ya":{"ya":12,"za":13,"ab":1,"t":3},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":24576,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"oc":"r","da":"treble","qb":6144}]}],"ea":[]},{"ya":{"ya":13,"za":14,"ab":2,"t":3},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":24576,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"oc":"r","da":"treble","qb":6144}]}],"ea":[]},{"ya":{"ya":14,"za":15,"ab":3,"t":3},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":24576,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"oc":"r","da":"treble","qb":6144}]}],"ea":[]},{"ya":{"ya":15,"za":16,"ab":0,"t":3},"bb":116.02000000000001,"cb":[],"db":[{"eb":[{"fb":{"gb":24576,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"oc":"r","da":"treble","qb":6144}]}],"ea":[]},{"ya":{"ya":16,"za":17,"ab":1,"t":3},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":24576,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"oc":"r","da":"treble","qb":6144}]}],"ea":[]},{"ld":true,"ya":{"ya":17,"za":18,"ab":0,"t":3},"bb":142.3,"cb":[],"db":[{"eb":[{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":4}],"da":"treble","qb":2048,"sb":[{"tb":"Ah- ","sa":"SmoLyric"}]},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"tb":" ","sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble","qb":6144}]}],"ea":[]},{"ya":{"ya":18,"za":19,"ab":1,"t":3},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","qb":6144},{"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"tb":"Ve- ","sa":"SmoLyric"}]},{"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"tb":"ni- ","sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","rb":true,"qb":2048,"sb":[{"tb":"te  ","sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"tb":"a- ","sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"tb":"- ","sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"tb":"do  ","sa":"SmoLyric"}]}]}],"ea":[]},{"ld":true,"ya":{"ya":19,"za":20,"ab":0,"t":3},"bb":99.74000000000001,"cb":[],"db":[{"eb":[{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"tb":"re- ","sa":"SmoLyric"}]},{"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"tb":"mus  ","sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":4}],"da":"treble","rb":true,"qb":6144,"sb":[{"tb":"Ah- ","sa":"SmoLyric"}]},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"tb":"  ","sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"tb":" ","sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble","qb":6144}]}],"ea":[]},{"ya":{"ya":20,"za":21,"ab":1,"t":3},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"tb":"- ","sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"tb":"  ","sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"tb":"  ","sa":"SmoLyric"}]},{"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"tb":"- ","sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":4}],"da":"treble","rb":true,"qb":6144,"sb":[{"tb":" ","sa":"SmoLyric"}]},{"fb":{"gb":8192,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"tb":"ve- ","sa":"SmoLyric"}]}]}],"ea":[]},{"ld":true,"ya":{"ya":21,"za":22,"ab":0,"t":3},"bb":99.74000000000001,"cb":[],"db":[{"eb":[{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"tb":"ni- ","sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"tb":"- ","sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"tb":"- ","sa":"SmoLyric"}]},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"tb":"- ","sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"tb":"- ","sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"tb":"- ","sa":"SmoLyric"}]},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"tb":"te  ","sa":"SmoLyric"}]},{"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"tb":"  ","sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"tb":"ve- ","sa":"SmoLyric"},{"wc":2,"tb":"p","sa":"SmoDynamicText"}]}]}],"ea":[]},{"ya":{"ya":22,"za":23,"ab":1,"t":3},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"tb":"ni- ","sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"tb":"- ","sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"tb":"- ","sa":"SmoLyric"}]},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"tb":"- ","sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"tb":"- ","sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"tb":"- ","sa":"SmoLyric"}]},{"fb":{"gb":12288,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"tb":"te ","sa":"SmoLyric"}]}]}],"ea":[]},{"ld":true,"ya":{"ya":23,"za":24,"ab":0,"t":3},"bb":99.74000000000001,"cb":[],"db":[{"eb":[{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144},{"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","rb":true,"qb":2048,"sb":[{"tb":"ve- ","sa":"SmoLyric"}]},{"ka":[{"jb":"b","lb":"b","kb":4}],"da":"treble","qb":6144,"sb":[{"tb":"ni- ","sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"da":"treble","rb":true,"qb":2048,"sb":[{"tb":"te- ","sa":"SmoLyric"}]},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"da":"treble","qb":6144,"sb":[{"tb":"a  ","sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"tb":"- ","sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"tb":"dor  ","sa":"SmoLyric"}]}]}],"ea":[]},{"ya":{"ya":24,"za":25,"ab":1,"t":3},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"#","kb":4,"pc":true}],"da":"treble","qb":6144,"sb":[{"tb":" re-","sa":"SmoLyric"}]},{"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"tb":"mus ","sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble","qb":2048},{"fb":{"gb":12288,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble","qb":2048}]}],"ea":[]},{"ld":true,"ya":{"ya":25,"za":26,"ab":0,"t":3},"bb":99.74000000000001,"cb":[],"db":[{"eb":[{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble","qb":6144},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"tb":"A  ","sa":"SmoLyric"}]},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"da":"treble","qb":6144,"sb":[{"tb":"- ","sa":"SmoLyric"}]},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"b","kb":5}],"da":"treble","qb":6144,"sb":[{"tb":"do- ","sa":"SmoLyric"}]}]}],"ea":[]},{"ya":{"ya":26,"za":27,"ab":1,"t":3},"bb":24.48,"cb":[],"db":[{"eb":[{"fb":{"gb":12288,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"tb":" ","sa":"SmoLyric"}]},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"b","kb":5}],"da":"treble","qb":6144,"sb":[{"tb":"re- ","sa":"SmoLyric"}]}]}],"ea":[]},{"ya":{"ya":27,"za":28,"ab":2,"t":3},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":12288,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"da":"treble","qb":6144,"sb":[{"tb":"mus  ","sa":"SmoLyric"}],"qc":[{"rc":"fermata","sa":"SmoArticulation"}]},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"da":"treble","qb":6144,"sb":[{"tb":" ","sa":"SmoLyric"}]}]}],"ea":[]},{"ld":true,"ya":{"ya":28,"za":29,"ab":0,"t":3},"bb":99.74000000000001,"cb":[],"db":[{"eb":[{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144,"tc":2,"sb":[{"tb":"Do  ","sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble","qb":6144,"tc":2,"sb":[{"tb":"- ","sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","qb":6144,"tc":2,"sb":[{"tb":"  ","sa":"SmoLyric"}]},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble","qb":6144,"tc":2,"sb":[{"tb":"  ","sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","qb":6144,"tc":2,"sb":[{"tb":"- ","sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"#","kb":4}],"da":"treble","qb":6144,"tc":2,"sb":[{"tb":"mi  ","sa":"SmoLyric"}]},{"fb":{"gb":12288,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"tb":"num ","sa":"SmoLyric"}],"qc":[{"rc":"fermata","sa":"SmoArticulation"}]}]}],"ea":[]},{"ya":{"ya":29,"za":30,"ab":1,"t":3},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":24576,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble","qb":6144}]}],"ea":[]},{"ya":{"ya":30,"za":31,"ab":2,"t":3},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":24576,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble","qb":6144}]}],"ea":[]}]}],"yc":[{"jc":527,"kc":66,"tb":"Gesu Bambino","bd":"every","ua":"title","vb":{"wb":"1.8em","xb":"Times New Roman","yb":"normal","zb":"normal"},"ac":"score-text auto13997","sa":"SmoScoreText"},{"jc":995,"kc":46,"tb":"© Pietro Yon page ### of @@@","bd":"every","ac":"score-text auto13998","sa":"SmoScoreText"}],"yd":[{"zd":0,"fa":{"ga":0,"ha":1},"la":{"ga":1,"ha":1},"sa":"SmoSystemGroup"},{"zd":1,"fa":{"ga":2,"ha":0},"la":{"ga":3,"ha":0},"sa":"SmoSystemGroup"}],"ee":{"wa":{"0":"12/8","27":"9/8","29":"12/8"},"xa":{"0":"G","12":"Bb","18":"G"},"fe":{"0":{"sa":"SmoTempoText","pa":{"qa":"auto11946","ra":"SmoTempoText"},"id":"duration","nb":56,"ob":true,"pb":6144,"jd":"Allegro","ta":0},"9":{"sa":"SmoTempoText","pa":{"qa":"auto12088","ra":"SmoTempoText"},"id":"duration","nb":56,"ob":false,"pb":6144,"jd":"Allegro","ta":0},"30":{"sa":"SmoTempoText","pa":{"qa":"auto12398","ra":"SmoTempoText"},"id":"duration","nb":62,"ob":true,"pb":6144,"jd":"Allegro","ta":0}}},"dictionary":{"a":"score","b":"layout","c":"leftMargin","d":"rightMargin","e":"topMargin","f":"bottomMargin","g":"pageWidth","h":"pageHeight","i":"orientation","j":"interGap","k":"intraGap","l":"svgScale","m":"zoomScale","n":"zoomMode","o":"pages","p":"pageSize","q":"startIndex","r":"renumberingMap","s":"staves","t":"staffId","u":"staffX","v":"staffY","w":"adjY","x":"staffWidth","y":"staffHeight","z":"keySignatureMap","aa":"instrumentInfo","ba":"instrumentName","ca":"keyOffset","da":"clef","ea":"modifiers","fa":"startSelector","ga":"staff","ha":"measure","ia":"voice","ja":"tick","ka":"pitches","la":"endSelector","ma":"xOffset","na":"cp1y","oa":"cp2y","pa":"attrs","qa":"id","ra":"type","sa":"ctor","ta":"yOffset","ua":"position","va":"measures","wa":"timeSignature","xa":"keySignature","ya":"measureNumber","za":"measureIndex","ab":"systemIndex","bb":"adjX","cb":"tuplets","db":"voices","eb":"notes","fb":"ticks","gb":"numerator","hb":"denominator","ib":"remainder","jb":"letter","kb":"octave","lb":"accidental","mb":"symbol","nb":"bpm","ob":"display","pb":"beatDuration","qb":"beamBeats","rb":"endBeam","sb":"textModifiers","tb":"text","ub":"endChar","vb":"fontInfo","wb":"size","xb":"family","yb":"style","zb":"weight","ac":"classes","bc":"verse","cc":"fill","dc":"scaleX","ec":"scaleY","fc":"translateX","gc":"translateY","hc":"selector","ic":"renderedBox","jc":"x","kc":"y","lc":"width","mc":"height","nc":"logicalBox","oc":"noteType","pc":"cautionary","qc":"articulations","rc":"articulation","sc":"activeVoice","tc":"flagState","uc":"invert","vc":"fontSize","wc":"yOffsetLine","xc":"yOffsetPixels","yc":"scoreText","zc":"backup","ad":"edited","bd":"pagination","cd":"boxModel","dd":"justification","ed":"autoLayout","fd":"ornaments","gd":"offset","hd":"ornament","id":"tempoMode","jd":"tempoText","kd":"barline","ld":"systemBreak","md":"graceNotes","nd":"tones","od":"tuplet","pd":"beam_group","qd":"renderId","rd":"numNotes","sd":"totalTicks","td":"stemTicks","ud":"durationMap","vd":"bracketed","wd":"ratioed","xd":"location","yd":"systemGroups","zd":"leftConnector","ae":"padLeft","be":"customStretch","ce":"engravingFont","de":"customProportion","ee":"columnAttributeMap","fe":"tempo"}}`;
;var microJson = `{"score":{"layout":{"leftMargin":30,"rightMargin":30,"topMargin":40,"bottomMargin":40,"pageWidth":816,"pageHeight":1056,"orientation":0,"interGap":30,"intraGap":10,"svgScale":1,"zoomScale":2.107843137254902,"zoomMode":0,"pages":1},"startIndex":0,"renumberingMap":{}},"staves":[{"staffId":0,"staffX":10,"staffY":40,"adjY":0,"staffWidth":1600,"staffHeight":90,"startIndex":0,"renumberingMap":{},"keySignatureMap":{},"instrumentInfo":{"instrumentName":"Treble Instrument","keyOffset":"0","clef":"treble"},"modifiers":[],"measures":[{"measureNumber":{"measureNumber":0,"measureIndex":0,"systemIndex":0,"staffId":0},"adjX":64.98,"adjRight":11,"tuplets":[],"voices":[{"notes":[{"ticks":{"numerator":2048,"denominator":1,"remainder":0},"pitches":[{"letter":"c","accidental":"n","octave":5}],"attrs":{"id":"auto6268","type":"SmoNote"},"clef":"treble"},{"ticks":{"numerator":2048,"denominator":1,"remainder":0},"pitches":[{"letter":"c","accidental":"n","octave":5}],"attrs":{"id":"auto6269","type":"SmoNote"},"clef":"treble","tones":[{"attrs":{"id":"auto6679","type":"SmoMicrotone"},"ctor":"SmoMicrotone","tone":"flat75sz","pitch":0}]},{"ticks":{"numerator":2048,"denominator":1,"remainder":0},"pitches":[{"letter":"c","accidental":"n","octave":5}],"attrs":{"id":"auto6273","type":"SmoNote"},"clef":"treble"},{"ticks":{"numerator":2048,"denominator":1,"remainder":0},"pitches":[{"letter":"c","accidental":"n","octave":5}],"attrs":{"id":"auto6274","type":"SmoNote"},"clef":"treble","tones":[{"attrs":{"id":"auto7062","type":"SmoMicrotone"},"ctor":"SmoMicrotone","tone":"flat25sz","pitch":0}]},{"ticks":{"numerator":2048,"denominator":1,"remainder":0},"pitches":[{"letter":"c","accidental":"n","octave":5}],"attrs":{"id":"auto6279","type":"SmoNote"},"clef":"treble"},{"ticks":{"numerator":2048,"denominator":1,"remainder":0},"pitches":[{"letter":"c","accidental":"n","octave":5}],"attrs":{"id":"auto6280","type":"SmoNote"},"clef":"treble","tones":[{"attrs":{"id":"auto8606","type":"SmoMicrotone"},"ctor":"SmoMicrotone","tone":"flat25ar","pitch":0}]},{"ticks":{"numerator":2048,"denominator":1,"remainder":0},"pitches":[{"letter":"c","accidental":"n","octave":5}],"attrs":{"id":"auto6286","type":"SmoNote"},"clef":"treble"},{"ticks":{"numerator":2048,"denominator":1,"remainder":0},"pitches":[{"letter":"c","accidental":"n","octave":5}],"attrs":{"id":"auto6287","type":"SmoNote"},"clef":"treble","tones":[{"attrs":{"id":"auto9475","type":"SmoMicrotone"},"ctor":"SmoMicrotone","tone":"sharp75","pitch":0}]}]}],"modifiers":[{"position":0,"barline":0,"ctor":"SmoBarline"},{"position":1,"barline":0,"ctor":"SmoBarline"},{"symbol":0,"xOffset":0,"yOffset":30,"position":0,"ctor":"SmoRepeatSymbol"}]},{"measureNumber":{"measureNumber":1,"measureIndex":1,"systemIndex":1,"staffId":0},"adjX":11,"adjRight":11,"tuplets":[],"voices":[{"notes":[{"ticks":{"numerator":2048,"denominator":1,"remainder":0},"pitches":[{"letter":"c","accidental":"n","octave":5}],"attrs":{"id":"auto9944","type":"SmoNote"},"clef":"treble"},{"ticks":{"numerator":2048,"denominator":1,"remainder":0},"pitches":[{"letter":"c","accidental":"n","octave":5}],"attrs":{"id":"auto9945","type":"SmoNote"},"clef":"treble","tones":[{"attrs":{"id":"auto10352","type":"SmoMicrotone"},"ctor":"SmoMicrotone","tone":"sharp125","pitch":0}]},{"ticks":{"numerator":2048,"denominator":1,"remainder":0},"pitches":[{"letter":"c","accidental":"n","octave":5}],"attrs":{"id":"auto9949","type":"SmoNote"},"clef":"treble"},{"ticks":{"numerator":2048,"denominator":1,"remainder":0},"pitches":[{"letter":"c","accidental":"n","octave":5}],"attrs":{"id":"auto9950","type":"SmoNote"},"clef":"treble","tones":[{"attrs":{"id":"auto10728","type":"SmoMicrotone"},"ctor":"SmoMicrotone","tone":"sharp25","pitch":0}]},{"ticks":{"numerator":2048,"denominator":1,"remainder":0},"pitches":[{"letter":"c","accidental":"n","octave":5}],"attrs":{"id":"auto9955","type":"SmoNote"},"clef":"treble"},{"ticks":{"numerator":2048,"denominator":1,"remainder":0},"pitches":[{"letter":"c","accidental":"n","octave":5}],"attrs":{"id":"auto9956","type":"SmoNote"},"clef":"treble","tones":[{"attrs":{"id":"auto11106","type":"SmoMicrotone"},"ctor":"SmoMicrotone","tone":"sori","pitch":0}]},{"ticks":{"numerator":2048,"denominator":1,"remainder":0},"pitches":[{"letter":"c","accidental":"n","octave":5}],"attrs":{"id":"auto9962","type":"SmoNote"},"clef":"treble"},{"ticks":{"numerator":2048,"denominator":1,"remainder":0},"pitches":[{"letter":"c","accidental":"n","octave":5}],"attrs":{"id":"auto9963","type":"SmoNote"},"clef":"treble","tones":[{"attrs":{"id":"auto11486","type":"SmoMicrotone"},"ctor":"SmoMicrotone","tone":"koron","pitch":0}]}]}],"modifiers":[{"position":0,"barline":0,"ctor":"SmoBarline"},{"position":1,"barline":0,"ctor":"SmoBarline"},{"symbol":0,"xOffset":0,"yOffset":30,"position":0,"ctor":"SmoRepeatSymbol"}]}]}],"scoreText":[]}`;
;var preciousLord = `{"a":{"b":{"c":30,"d":30,"e":121,"f":40,"g":816,"h":1056,"i":0,"j":50,"k":40,"l":0.65,"m":2.107843137254902,"n":2,"o":1,"p":"letter"},"q":0,"r":{},"ce":"Bravura"},"s":[{"t":0,"u":10,"v":40,"w":0,"x":1600,"y":90,"q":0,"r":{},"z":{},"aa":{"ba":"Treble Instrument","ca":"0","da":"treble"},"ea":[{"fa":{"ga":0,"ha":15,"ia":0,"ja":0,"ka":[]},"la":{"ga":0,"ha":16,"ia":0,"ja":0,"ka":[]},"ua":4,"sa":"SmoSlur"}],"va":[{"ya":{"ya":-1,"za":0,"ab":0,"t":0},"bb":86.26,"cb":[],"db":[{"eb":[{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":3},{"jb":"a","lb":"n","kb":3}],"da":"treble","sb":[{"tb":"Pre- ","sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3},{"jb":"b","lb":"b","kb":3}],"da":"treble","sb":[{"tb":"cious  ","sa":"SmoLyric"}]}]}],"ea":[]},{"ya":{"ya":0,"za":1,"ab":1,"t":0},"bb":11,"be":19,"cb":[],"db":[{"eb":[{"fb":{"gb":8192,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":3},{"jb":"c","lb":"n","kb":4}],"da":"treble","sb":[{"tb":"Lord,  ","sa":"SmoLyric"},{"tb":"dark- ","bc":"1","sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":3},{"jb":"c","lb":"n","kb":4}],"da":"treble","sb":[{"tb":"take  ","sa":"SmoLyric"},{"tb":"ness ","bc":"1","sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":3},{"jb":"c","lb":"n","kb":4}],"da":"treble","sb":[{"tb":"my ","sa":"SmoLyric"},{"tb":"a-  ","bc":"1","sa":"SmoLyric"}]}]}],"ea":[{"ua":0,"kd":3,"sa":"SmoBarline"}]},{"ya":{"ya":1,"za":2,"ab":2,"t":0},"bb":6,"be":6,"cb":[],"db":[{"eb":[{"fb":{"gb":8192,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":4},{"jb":"f","lb":"n","kb":4}],"da":"treble","sb":[{"tb":"hand, ","sa":"SmoLyric"},{"tb":"pears  ","bc":"1","sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":4},{"jb":"a","lb":"n","kb":4}],"da":"treble","sb":[{"tb":"lead  ","sa":"SmoLyric"},{"tb":"and  ","bc":"1","sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"#","kb":4},{"jb":"a","lb":"n","kb":4}],"da":"treble","sb":[{"tb":"me  ","sa":"SmoLyric"},{"tb":"the  ","bc":"1","sa":"SmoLyric"}]}]}],"ea":[]},{"ya":{"ya":2,"za":3,"ab":3,"t":0},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":8192,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":4},{"jb":"g","lb":"n","kb":4}],"da":"treble","sb":[{"tb":"on,  ","sa":"SmoLyric"},{"tb":"night  ","bc":"1","sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":3},{"jb":"f","lb":"n","kb":4}],"da":"treble","sb":[{"tb":"let  ","sa":"SmoLyric"},{"tb":"dra- ","bc":"1","sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":3},{"jb":"f","lb":"n","kb":4}],"da":"treble","sb":[{"tb":"me  ","sa":"SmoLyric"},{"tb":"ws  ","bc":"1","sa":"SmoLyric"}]}]}],"ea":[]},{"ya":{"ya":3,"za":4,"ab":4,"t":0},"bb":6,"be":24,"cb":[],"db":[{"eb":[{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":3},{"jb":"d","lb":"n","kb":4}],"da":"treble","sb":[{"tb":"sta- ","sa":"SmoLyric"},{"tb":" ne- ","bc":"1","sa":"SmoLyric"}]},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":4},{"jb":"f","lb":"n","kb":4}],"da":"treble","sb":[{"tb":"nd ","sa":"SmoLyric"},{"tb":"ar   ","bc":"1","sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"b","kb":3},{"jb":"d","lb":"n","kb":4}],"da":"treble","sb":[{"tb":"I  ","sa":"SmoLyric"},{"tb":"when   ","bc":"1","sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"b","kb":3},{"jb":"d","lb":"n","kb":4}],"da":"treble","sb":[{"tb":"am  ","sa":"SmoLyric"},{"tb":"my   ","bc":"1","sa":"SmoLyric"}]}]}],"ea":[]},{"ya":{"ya":4,"za":5,"ab":5,"t":0},"bb":6,"be":15,"cb":[],"db":[{"eb":[{"fb":{"gb":8192,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":3},{"jb":"c","lb":"n","kb":4}],"da":"treble","sb":[{"tb":"tired ","sa":"SmoLyric"},{"tb":"life   ","bc":"1","sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":3},{"jb":"c","lb":"n","kb":4}],"da":"treble","sb":[{"tb":"I  ","sa":"SmoLyric"},{"tb":"  ","bc":"1","sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":3},{"jb":"c","lb":"n","kb":4}],"da":"treble","sb":[{"tb":"am  ","sa":"SmoLyric"},{"tb":"is- ","bc":"1","sa":"SmoLyric"}]}]}],"ea":[]},{"ya":{"ya":5,"za":6,"ab":0,"t":0},"bb":86.26,"cb":[],"db":[{"eb":[{"fb":{"gb":8192,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":3},{"jb":"f","lb":"n","kb":4}],"da":"treble","sb":[{"tb":"weak ","sa":"SmoLyric"},{"tb":"al-  ","bc":"1","sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":3},{"jb":"a","lb":"n","kb":4}],"da":"treble","sb":[{"tb":"I   ","sa":"SmoLyric"},{"tb":"most  ","bc":"1","sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":3},{"jb":"a","lb":"n","kb":4}],"da":"treble","sb":[{"tb":"am ","sa":"SmoLyric"},{"tb":"  ","bc":"1","sa":"SmoLyric"}]}]}],"ea":[]},{"ya":{"ya":6,"za":7,"ab":1,"t":0},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":8192,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":4},{"jb":"g","lb":"n","kb":4}],"da":"treble","sb":[{"tb":"worn  ","sa":"SmoLyric"},{"tb":"gone_ ","bc":"1","sa":"SmoLyric"}]},{"ka":[{"jb":"b","lb":"n","kb":3},{"jb":"g","lb":"n","kb":4}],"da":"treble","sb":[{"tb":"- ","sa":"SmoLyric"},{"tb":"- ","bc":"1","sa":"SmoLyric"}]}]}],"ea":[]},{"ya":{"ya":7,"za":8,"ab":2,"t":0},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":8192,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":4},{"jb":"g","lb":"n","kb":4}],"da":"treble","sb":[{"tb":"- ","sa":"SmoLyric"},{"tb":"- ","bc":"1","sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":4},{"jb":"a","lb":"n","kb":4}],"da":"treble","sb":[{"tb":"Through  ","sa":"SmoLyric"},{"tb":"at  ","bc":"1","sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4},{"jb":"b","lb":"b","kb":4}],"da":"treble","sb":[{"tb":"the  ","sa":"SmoLyric"},{"tb":"the  ","bc":"1","sa":"SmoLyric"}]}]}],"ea":[]},{"ya":{"ya":8,"za":9,"ab":3,"t":0},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":8192,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":4},{"jb":"c","lb":"n","kb":5}],"da":"treble","sb":[{"tb":"storm,  ","sa":"SmoLyric"},{"tb":"riv- ","bc":"1","sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":4},{"jb":"c","lb":"n","kb":5}],"da":"treble","sb":[{"tb":"through  ","sa":"SmoLyric"},{"tb":"er  ","bc":"1","sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":4},{"jb":"c","lb":"n","kb":5}],"da":"treble","sb":[{"tb":"the  ","sa":"SmoLyric"},{"tb":"I  ","bc":"1","sa":"SmoLyric"}]}]}],"ea":[]},{"ya":{"ya":9,"za":10,"ab":4,"t":0},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":8192,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":4},{"jb":"a","lb":"n","kb":4}],"da":"treble","sb":[{"tb":"night  ","sa":"SmoLyric"},{"tb":"stand,  ","bc":"1","sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"b","kb":4},{"jb":"a","lb":"n","kb":4}],"da":"treble","sb":[{"tb":"lead  ","sa":"SmoLyric"},{"tb":"guide  ","bc":"1","sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"b","kb":4},{"jb":"a","lb":"n","kb":4}],"da":"treble","sb":[{"tb":"me  ","sa":"SmoLyric"},{"tb":"me  ","bc":"1","sa":"SmoLyric"}]}]}],"ea":[]},{"ya":{"ya":10,"za":11,"ab":5,"t":0},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":8192,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":4},{"jb":"g","lb":"n","kb":4}],"da":"treble","sb":[{"tb":"on  ","sa":"SmoLyric"},{"tb":"feet,  ","bc":"1","sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":4},{"jb":"f","lb":"n","kb":4}],"da":"treble","sb":[{"tb":"to  ","sa":"SmoLyric"},{"tb":"hold  ","bc":"1","sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":4},{"jb":"f","lb":"n","kb":4}],"da":"treble","sb":[{"tb":"the  ","sa":"SmoLyric"},{"tb":"my  ","bc":"1","sa":"SmoLyric"}]}]}],"ea":[]},{"ld":true,"ya":{"ya":11,"za":12,"ab":0,"t":0},"bb":86.26,"cb":[],"db":[{"eb":[{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":3},{"jb":"d","lb":"n","kb":4}],"da":"treble","sb":[{"tb":"li- ","sa":"SmoLyric"},{"tb":"ha- ","bc":"1","sa":"SmoLyric"}]},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":4},{"jb":"f","lb":"n","kb":4}],"da":"treble","sb":[{"tb":"ght  ","sa":"SmoLyric"},{"tb":"nd  ","bc":"1","sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":4}],"da":"treble","sb":[{"tb":"Take  ","sa":"SmoLyric"},{"tb":" ","bc":"1","sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":4}],"da":"treble","sb":[{"tb":"my  ","sa":"SmoLyric"}]}]}],"ea":[]},{"ya":{"ya":12,"za":13,"ab":1,"t":0},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":4}],"da":"treble","sb":[{"tb":"ha- ","sa":"SmoLyric"}]},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":4}],"da":"treble","sb":[{"tb":"nd  ","sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":4}],"da":"treble","sb":[{"tb":"pre- ","sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":4},{"jb":"g","lb":"n","kb":4}],"da":"treble","sb":[{"tb":"cious  ","sa":"SmoLyric"}]}]}],"ea":[]},{"ya":{"ya":13,"za":14,"ab":2,"t":0},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":8192,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":4},{"jb":"a","lb":"n","kb":4}],"da":"treble","sb":[{"tb":"Lord,  ","sa":"SmoLyric"}]},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":4},{"jb":"g","lb":"n","kb":4}],"da":"treble","sb":[{"tb":"lead  ","sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":4},{"jb":"f","lb":"n","kb":4}],"da":"treble","sb":[{"tb":"me  ","sa":"SmoLyric"}]}]}],"ea":[]},{"ya":{"ya":14,"za":15,"ab":3,"t":0},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":12288,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":4},{"jb":"f","lb":"n","kb":4}],"da":"treble","sb":[{"tb":"home- ","sa":"SmoLyric"}]}]}],"ea":[{"kd":1,"sa":"SmoBarline"}]},{"ya":{"ya":15,"za":16,"ab":4,"t":0},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":8192,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":4},{"jb":"f","lb":"n","kb":4}],"da":"treble","sb":[{"tb":" ","sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":3}],"da":"treble","sb":[{"tb":"When  ","sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3}],"da":"treble","sb":[{"tb":"the ","sa":"SmoLyric"}]}]}],"ea":[{"kd":4,"sa":"SmoBarline"},{"mb":9,"ma":-40,"sa":"SmoRepeatSymbol"}]}]},{"t":1,"u":10,"v":40,"w":0,"x":1600,"y":90,"q":0,"r":{},"z":{},"aa":{"ba":"Bass Clef Staff","ca":0,"da":"bass"},"ea":[{"fa":{"ga":1,"ha":15,"ia":0,"ja":0,"ka":[]},"la":{"ga":1,"ha":16,"ia":0,"ja":0,"ka":[]},"ua":4,"sa":"SmoSlur"}],"va":[{"ya":{"ya":-1,"za":0,"ab":0,"t":1},"da":"bass","bb":86.26,"cb":[],"db":[{"eb":[{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":2},{"jb":"f","lb":"n","kb":3}],"da":"bass","tc":2},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":2},{"jb":"f","lb":"n","kb":3}],"da":"bass","tc":2}]}],"ea":[]},{"ya":{"ya":0,"za":1,"ab":1,"t":1},"da":"bass","bb":11,"cb":[],"db":[{"eb":[{"fb":{"gb":8192,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":2},{"jb":"f","lb":"n","kb":3}],"da":"bass","tc":2},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":2},{"jb":"f","lb":"n","kb":3}],"da":"bass","tc":2},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":2},{"jb":"e","lb":"n","kb":3}],"da":"bass","tc":2,"sb":[{"tb":" ","sa":"SmoLyric"}]}]}],"ea":[{"ua":0,"kd":3,"sa":"SmoBarline"}]},{"ya":{"ya":1,"za":2,"ab":2,"t":1},"da":"bass","bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":8192,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":2},{"jb":"f","lb":"n","kb":3}],"da":"bass","tc":2,"sb":[{"tb":" ","sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":2},{"jb":"f","lb":"n","kb":3}],"da":"bass","tc":2},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":2},{"jb":"f","lb":"n","kb":3}],"da":"bass","tc":2}]}],"ea":[]},{"ya":{"ya":2,"za":3,"ab":3,"t":1},"da":"bass","bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":8192,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":2},{"jb":"f","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":3},{"jb":"f","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":3},{"jb":"f","lb":"n","kb":3}],"da":"bass"}]}],"ea":[]},{"ya":{"ya":3,"za":4,"ab":4,"t":1},"da":"bass","bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":2},{"jb":"f","lb":"n","kb":3}],"da":"bass","sb":[{"tb":"  ","sa":"SmoLyric"}]},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":2},{"jb":"d","lb":"n","kb":3}],"da":"bass","sb":[{"tb":" ","sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":3}],"da":"bass"}]}],"ea":[]},{"ya":{"ya":4,"za":5,"ab":5,"t":1},"da":"bass","bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":8192,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":3},{"jb":"f","lb":"n","kb":3}],"da":"bass","sb":[{"tb":"  ","sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":3},{"jb":"e","lb":"n","kb":3}],"da":"bass","sb":[{"tb":" ","sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":3},{"jb":"e","lb":"n","kb":3}],"da":"bass"}]}],"ea":[]},{"ya":{"ya":5,"za":6,"ab":0,"t":1},"da":"bass","bb":86.26,"cb":[],"db":[{"eb":[{"fb":{"gb":8192,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":2},{"jb":"f","lb":"n","kb":3}],"da":"bass","tc":2},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":2},{"jb":"f","lb":"n","kb":3}],"da":"bass","tc":2}]}],"ea":[]},{"ya":{"ya":6,"za":7,"ab":1,"t":1},"da":"bass","bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":8192,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":3},{"jb":"e","lb":"n","kb":3}],"da":"bass"},{"ka":[{"jb":"d","lb":"n","kb":3},{"jb":"f","lb":"n","kb":3}],"da":"bass"}]}],"ea":[]},{"ya":{"ya":7,"za":8,"ab":2,"t":1},"da":"bass","bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":8192,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":3},{"jb":"g","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":3},{"jb":"c","lb":"n","kb":4}],"da":"bass"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":3},{"jb":"c","lb":"n","kb":4}],"da":"bass"}]}],"ea":[]},{"ya":{"ya":8,"za":9,"ab":3,"t":1},"da":"bass","bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":8192,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":3},{"jb":"a","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3},{"jb":"b","lb":"b","kb":3}],"da":"bass"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3},{"jb":"b","lb":"b","kb":3}],"da":"bass"}]}],"ea":[]},{"ya":{"ya":9,"za":10,"ab":4,"t":1},"da":"bass","bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":8192,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":3},{"jb":"c","lb":"n","kb":4}],"da":"bass"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":3},{"jb":"c","lb":"n","kb":4}],"da":"bass"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":3},{"jb":"c","lb":"n","kb":4}],"da":"bass"}]}],"ea":[]},{"ya":{"ya":10,"za":11,"ab":5,"t":1},"da":"bass","bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":8192,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":2},{"jb":"b","lb":"b","kb":3}],"da":"bass"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":2},{"jb":"b","lb":"b","kb":3}],"da":"bass"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":2},{"jb":"b","lb":"b","kb":3}],"da":"bass"}]}],"ea":[]},{"ld":true,"ya":{"ya":11,"za":12,"ab":0,"t":1},"da":"bass","bb":86.26,"cb":[],"db":[{"eb":[{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":2},{"jb":"f","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":2},{"jb":"b","lb":"b","kb":3}],"da":"bass"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":2},{"jb":"a","lb":"b","kb":3}],"da":"bass"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":2},{"jb":"g","lb":"n","kb":3}],"da":"bass"}]}],"ea":[]},{"ya":{"ya":12,"za":13,"ab":1,"t":1},"da":"bass","bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":8192,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":3},{"jb":"a","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":3},{"jb":"a","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"b","kb":3},{"jb":"b","lb":"n","kb":3}],"da":"bass"}]}],"ea":[]},{"ya":{"ya":13,"za":14,"ab":2,"t":1},"da":"bass","bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":8192,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":3},{"jb":"c","lb":"n","kb":4}],"da":"bass"},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":3},{"jb":"b","lb":"b","kb":3}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":3},{"jb":"b","lb":"b","kb":3}],"da":"bass"}]}],"ea":[]},{"ya":{"ya":14,"za":15,"ab":3,"t":1},"da":"bass","bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":12288,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":3},{"jb":"a","lb":"n","kb":3}],"da":"bass"}]}],"ea":[{"kd":1,"sa":"SmoBarline"}]},{"ya":{"ya":15,"za":16,"ab":4,"t":1},"da":"bass","bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":8192,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":3},{"jb":"a","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":2},{"jb":"f","lb":"n","kb":3}],"da":"bass","tc":2},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":2},{"jb":"f","lb":"n","kb":3}],"da":"bass","tc":2}]}],"ea":[{"kd":4,"sa":"SmoBarline"},{"mb":9,"ma":-40,"sa":"SmoRepeatSymbol"}]}]}],"yc":[{"jc":476,"kc":64,"tb":"Precious Lord","ua":"title","vb":{"wb":"1.8em","xb":"Times New Roman","yb":"normal","zb":"normal"},"ac":"score-text auto595274","sa":"SmoScoreText"},{"jc":-52.25,"kc":10,"tb":"Smoosic  c","ua":"copyright","vb":{"wb":".6em","xb":"Times New Roman","yb":"normal","zb":"normal"},"ac":"score-text auto595275","sa":"SmoScoreText"}],"yd":[{"zd":0,"fa":{"ga":0,"ha":2},"la":{"ga":1,"ha":2},"sa":"SmoSystemGroup"}],"ee":{"wa":{"0":"3/4"},"xa":{"0":"F"}},"dictionary":{"a":"score","b":"layout","c":"leftMargin","d":"rightMargin","e":"topMargin","f":"bottomMargin","g":"pageWidth","h":"pageHeight","i":"orientation","j":"interGap","k":"intraGap","l":"svgScale","m":"zoomScale","n":"zoomMode","o":"pages","p":"pageSize","q":"startIndex","r":"renumberingMap","s":"staves","t":"staffId","u":"staffX","v":"staffY","w":"adjY","x":"staffWidth","y":"staffHeight","z":"keySignatureMap","aa":"instrumentInfo","ba":"instrumentName","ca":"keyOffset","da":"clef","ea":"modifiers","fa":"startSelector","ga":"staff","ha":"measure","ia":"voice","ja":"tick","ka":"pitches","la":"endSelector","ma":"xOffset","na":"cp1y","oa":"cp2y","pa":"attrs","qa":"id","ra":"type","sa":"ctor","ta":"yOffset","ua":"position","va":"measures","wa":"timeSignature","xa":"keySignature","ya":"measureNumber","za":"measureIndex","ab":"systemIndex","bb":"adjX","cb":"tuplets","db":"voices","eb":"notes","fb":"ticks","gb":"numerator","hb":"denominator","ib":"remainder","jb":"letter","kb":"octave","lb":"accidental","mb":"symbol","nb":"bpm","ob":"display","pb":"beatDuration","qb":"beamBeats","rb":"endBeam","sb":"textModifiers","tb":"text","ub":"endChar","vb":"fontInfo","wb":"size","xb":"family","yb":"style","zb":"weight","ac":"classes","bc":"verse","cc":"fill","dc":"scaleX","ec":"scaleY","fc":"translateX","gc":"translateY","hc":"selector","ic":"renderedBox","jc":"x","kc":"y","lc":"width","mc":"height","nc":"logicalBox","oc":"noteType","pc":"cautionary","qc":"articulations","rc":"articulation","sc":"activeVoice","tc":"flagState","uc":"invert","vc":"fontSize","wc":"yOffsetLine","xc":"yOffsetPixels","yc":"scoreText","zc":"backup","ad":"edited","bd":"pagination","cd":"boxModel","dd":"justification","ed":"autoLayout","fd":"ornaments","gd":"offset","hd":"ornament","id":"tempoMode","jd":"tempoText","kd":"barline","ld":"systemBreak","md":"graceNotes","nd":"tones","od":"tuplet","pd":"beam_group","qd":"renderId","rd":"numNotes","sd":"totalTicks","td":"stemTicks","ud":"durationMap","vd":"bracketed","wd":"ratioed","xd":"location","yd":"systemGroups","zd":"leftConnector","ae":"padLeft","be":"customStretch","ce":"engravingFont","de":"customProportion","ee":"columnAttributeMap","fe":"tempo"}}`;
;//# sourceMappingURL=../src/ui/ribbon.js

// ## RibbonButtons
// Render the ribbon buttons based on group, function, and underlying UI handler.
// Also handles UI events.
// ### RibbonButton methods
// ---
class RibbonButtons {
	static get paramArray() {
		return ['ribbonButtons', 'ribbons', 'editor', 'controller', 'tracker', 'menus','layout','eventSource'];
	}
	static _buttonHtml(containerClass,buttonId, buttonClass, buttonText, buttonIcon, buttonKey) {
		var b = htmlHelpers.buildDom;
		var r = b('div').classes(containerClass).append(b('button').attr('id', buttonId).classes(buttonClass).append(
					b('span').classes('left-text').append(
					    b('span').classes('text-span').text(buttonText)).append(
					b('span').classes('ribbon-button-text icon ' + buttonIcon))).append(
					b('span').classes('ribbon-button-hotkey').text(buttonKey)));
		return r.dom();
	}
  static get translateButtons() {
    if (!RibbonButtons._translateButtons) {
      RibbonButtons._translateButtons = [];
    }
    return RibbonButtons._translateButtons;
  }
	constructor(parameters) {
		smoSerialize.filteredMerge(RibbonButtons.paramArray, parameters, this);
		this.ribbonButtons = parameters.ribbonButtons;
		this.ribbons = parameters.ribbons;
		this.collapsables = [];
		this.collapseChildren = [];
	}
	_executeButtonModal(buttonElement, buttonData) {
		var ctor = eval(buttonData.ctor);
		ctor.createAndDisplay(
      {
        tracker:this.tracker,
        undoBuffer:this.editor.undoBuffer,
        eventSource:this.eventSource,
        editor:this.editor,
        completeNotifier: this.controller,
        layout: this.layout
      }
    );
	}
	_executeButtonMenu(buttonElement, buttonData) {
		var self = this;
    this.menus.slashMenuMode(this.controller);
		this.menus.createMenu(buttonData.ctor);
	}
	_rebindController() {
		this.controller.render();
		this.controller.bindEvents();
	}
	_executeButton(buttonElement, buttonData) {
		if (buttonData.action === 'modal') {
			this._executeButtonModal(buttonElement, buttonData);
			return;
		}
		if (buttonData.action === 'menu' || buttonData.action === 'collapseChildMenu') {
			this._executeButtonMenu(buttonElement, buttonData);
			return;
		}
	}

	_bindButton(buttonElement, buttonData) {
    this.eventSource.domClick(buttonElement,this,'_executeButton',buttonData);
	}
  _createCollapsibleButtonGroups(selector) {
    // Now all the button elements have been bound.  Join child and parent buttons
    // For all the children of a button group, add it to the parent group
    this.collapseChildren.forEach((b) => {
      var containerClass = 'ribbonButtonContainer';
      if (b.action == 'collapseGrandchild') {
        containerClass = 'ribbonButtonContainerMore'
      }
      var buttonHtml = RibbonButtons._buttonHtml(
        containerClass,b.id, b.classes, b.leftText, b.icon, b.rightText);
      if (b.dataElements) {
        var bkeys = Object.keys(b.dataElements);
        bkeys.forEach((bkey) => {
          var de = b.dataElements[bkey];
          $(buttonHtml).find('button').attr('data-' + bkey, de);
        });
      }
      // Bind the child button actions
      var parent = $(selector).find('.collapseContainer[data-group="' + b.group + '"]');
      $(parent).append(buttonHtml);
      var el = $(selector).find('#' + b.id);
      this._bindButton(el, b);
    });

    this.collapsables.forEach((cb) => {
      // Bind the events of the parent button
      cb.bind();
    });
  }

    static isCollapsible(action) {
        return ['collapseChild','collapseChildMenu','collapseGrandchild','collapseMore'].indexOf(action) >= 0;
    }

    static isBindable(action) {
        return ['collapseChildMenu','menu','modal'].indexOf(action) >= 0;
    }

    // ### _createButtonHtml
    // For each button, create the html and bind the events based on
    // the button's configured action.
	_createRibbonHtml(buttonAr, selector) {
		buttonAr.forEach((buttonId) => {
			var buttonData = this.ribbonButtons.find((e) => {
					return e.id === buttonId;
				});
			if (buttonData) {
        if (buttonData.leftText) {
          RibbonButtons.translateButtons.push({buttonId:buttonData.id,
            buttonText:buttonData.leftText});
        }

        // collapse child is hidden until the parent button is selected, exposing the button group
				if (RibbonButtons.isCollapsible(buttonData.action)) {
					this.collapseChildren.push(buttonData);
        }
				if (buttonData.action != 'collapseChild') {

          // else the button has a specific action, such as a menu or dialog, or a parent button
          // for translation, add the menu name to the button class
          var buttonClass = buttonData.classes;
          if (buttonData.action === 'menu' || buttonData.action === 'modal') {
            buttonClass += ' ' +buttonData.ctor;
          }
					var buttonHtml = RibbonButtons._buttonHtml('ribbonButtonContainer',
              buttonData.id, buttonClass, buttonData.leftText, buttonData.icon, buttonData.rightText);
					$(buttonHtml).attr('data-group', buttonData.group);

					$(selector).append(buttonHtml);
          var buttonElement = $('#' + buttonData.id);

          // If this is a collabsable button, create it, otherwise bind its execute function.
					if (buttonData.action == 'collapseParent') {
						$(buttonHtml).addClass('collapseContainer');
                  // collapseParent
          		this.collapsables.push(new CollapseRibbonControl({
          				ribbonButtons: this.ribbonButtons,
                  layout:this.layout,
                  undoBuffer:this.editor.undoBuffer,
          				menus: this.menus,
                  eventSource:this.eventSource,
          				tracker: this.tracker,
          				controller: this.controller,
          				editor: this.editor,
          				buttonElement: buttonElement,
          				buttonData: buttonData
          			}));
					} else {
            this.eventSource.domClick(buttonElement,this,'_executeButton',buttonData);
          }
				}
			}
		});
	}

  createRibbon(buttonDataArray,parentElement) {
    this._createRibbonHtml(buttonDataArray, parentElement);
    this._createCollapsibleButtonGroups(parentElement);
  }

	display() {
		$('body .controls-left').html('');
		$('body .controls-top').html('');

		var buttonAr = this.ribbons['left'];
		this.createRibbon(buttonAr, 'body .controls-left');

		buttonAr = this.ribbons['top'];
		this.createRibbon(buttonAr, 'body .controls-top');
	}
}

class DebugButtons {
	constructor(parameters) {
		this.buttonElement = parameters.buttonElement;
		this.buttonData = parameters.buttonData;
		this.editor = parameters.editor;
	}
	bind() {
		var self = this;
		$(this.buttonElement).off('click').on('click', function () {
			$('body').trigger('redrawScore');
		});
    }
}

class ExtendedCollapseParent {
    constructor(parameters) {
		this.buttonElement = parameters.buttonElement;
		this.buttonData = parameters.buttonData;
		this.editor = parameters.editor;
	}
    bind() {
		var self = this;
		$(this.buttonElement).off('click').on('click', function () {
			$(this).closest('.collapseContainer').toggleClass('expanded-more');
		});
    }
}
class BeamButtons {
	constructor(parameters) {
		this.buttonElement = parameters.buttonElement;
		this.buttonData = parameters.buttonData;
		this.editor = parameters.editor;
	}
    operation() {
        if (this.buttonData.id === 'breakBeam') {
			this.editor.toggleBeamGroup();
        } else if (this.buttonData.id === 'beamSelections') {
            this.editor.beamSelections();
        } else if (this.buttonData.id === 'toggleBeamDirection') {
            this.editor.toggleBeamDirection();
        }
    }
	bind() {
		var self = this;
		$(this.buttonElement).off('click').on('click', function () {
			self.operation();
		});
    }
}
class MicrotoneButtons {
    constructor(parameters) {
		this.buttonElement = parameters.buttonElement;
		this.buttonData = parameters.buttonData;
		this.editor = parameters.editor;
        this.tracker = parameters.tracker
	}
    applyButton(el) {
        var pitch = 0;
        if (this.tracker.selections.length == 1 &&
            this.tracker.selections[0].selector.pitches &&
            this.tracker.selections[0].selector.pitches.length
        ) {
            pitch = this.tracker.selections[0].selector.pitches[0];
        }
        var tn = new SmoMicrotone({tone:el.id,pitch:pitch});
        SmoUndoable.multiSelectionOperation(this.tracker.layout.score,
             this.tracker.selections,'addRemoveMicrotone',tn,this.editor.undoBuffer);
        suiOscillator.playSelectionNow(this.tracker.selections[0]);
        this.tracker.layout.addToReplaceQueue(this.tracker.selections[0]);
    }
    bind() {
		var self = this;
		$(this.buttonElement).off('click').on('click', function () {
            self.applyButton(self.buttonData);
		});
	}
}
class DurationButtons {
	constructor(parameters) {
		this.buttonElement = parameters.buttonElement;
		this.buttonData = parameters.buttonData;
		this.editor = parameters.editor;
	}
	setDuration() {
		if (this.buttonData.id === 'GrowDuration') {
			this.editor.doubleDuration();
		} else if (this.buttonData.id === 'LessDuration') {
			this.editor.halveDuration();
		} else if (this.buttonData.id === 'GrowDurationDot') {
			this.editor.dotDuration();
		} else if (this.buttonData.id === 'LessDurationDot') {
			this.editor.undotDuration();
		} else if (this.buttonData.id === 'TripletButton') {
			this.editor.makeTupletCommand(3);
		} else if (this.buttonData.id === 'QuintupletButton') {
			this.editor.makeTupletCommand(5);
		} else if (this.buttonData.id === 'SeptupletButton') {
			this.editor.makeTupletCommand(7);
		} else if (this.buttonData.id === 'NoTupletButton') {
			this.editor.unmakeTuplet();
		}
	}
	bind() {
		var self = this;
		$(this.buttonElement).off('click').on('click', function () {
			self.setDuration();
		});
	}
}

class VoiceButtons {
	constructor(parameters) {
		this.buttonElement = parameters.buttonElement;
		this.buttonData = parameters.buttonData;
		this.editor = parameters.editor;
        this.tracker = parameters.tracker;
	}
    _depopulateVoice() {
        var selections = SmoSelection.getMeasureList(this.tracker.selections);
        selections.forEach((selection) => {
            SmoUndoable.depopulateVoice([selection],selection.measure.getActiveVoice(),
               this.editor.undoBuffer);
            selection.measure.setChanged();
        });
        this.tracker.replaceSelectedMeasures();
    }
	setPitch() {
        var voiceIx = 0;
		if (this.buttonData.id === 'V1Button') {
            SmoOperation.setActiveVoice(this.tracker.layout.score,voiceIx);
            var ml = SmoSelection.getMeasureList(this.tracker.selections);
            ml.forEach((sel) => {
                sel.measure.setChanged();
            });
            this.tracker.replaceSelectedMeasures();
            return;
		} else if (this.buttonData.id === 'V2Button') {
			voiceIx = 1;
		} else if (this.buttonData.id === 'V3Button') {
			this.editor.upOctave();
            voiceIx = 2;
		} else if (this.buttonData.id === 'V4Button') {
			this.editor.downOctave();
            voiceIx = 3;
		} else if (this.buttonData.id === 'VXButton') {
        	return this._depopulateVoice();
        }
        SmoUndoable.populateVoice(this.tracker.selections,voiceIx,this.editor.undoBuffer);
        SmoOperation.setActiveVoice(this.tracker.layout.score,voiceIx);
        this.tracker.replaceSelectedMeasures();
    }
	bind() {
		var self = this;
		$(this.buttonElement).off('click').on('click', function () {
			self.setPitch();
		});
	}
}
class NoteButtons {
	constructor(parameters) {
		this.buttonElement = parameters.buttonElement;
		this.buttonData = parameters.buttonData;
		this.editor = parameters.editor;
	}
	setPitch() {
		if (this.buttonData.id === 'UpNoteButton') {
			this.editor.transposeUp();
		} else if (this.buttonData.id === 'DownNoteButton') {
			this.editor.transposeDown();
		} else if (this.buttonData.id === 'UpOctaveButton') {
			this.editor.upOctave();
		} else if (this.buttonData.id === 'DownOctaveButton') {
			this.editor.downOctave();
		} else if (this.buttonData.id === 'ToggleAccidental') {
			this.editor.toggleEnharmonic();
		} else if (this.buttonData.id === 'ToggleCourtesy') {
			this.editor.toggleCourtesyAccidental();
		} else if (this.buttonData.id === 'ToggleRestButton') {
			this.editor.makeRest();
		} else if (this.buttonData.id === 'AddGraceNote') {
			this.editor.addGraceNote();
		} else if (this.buttonData.id === 'SlashGraceNote') {
      this.editor.slashGraceNotes();
    } else if (this.buttonData.id === 'RemoveGraceNote') {
			this.editor.removeGraceNote();
		} else if (this.buttonData.id === 'XNoteHead') {
      this.editor.setNoteHead();
    } else {
			this.editor.setPitchCommand(this.buttonData.rightText);
		}
	}
	bind() {
		var self = this;
		$(this.buttonElement).off('click').on('click', function () {
			self.setPitch();
		});
	}
}

class ChordButtons {
	constructor(parameters) {
		this.buttonElement = parameters.buttonElement;
		this.buttonData = parameters.buttonData;
		this.editor = parameters.editor;
		this.tracker = parameters.tracker;
		this.score = parameters.score;
		this.interval = parseInt($(this.buttonElement).attr('data-interval'));
		this.direction = parseInt($(this.buttonElement).attr('data-direction'));
	}
	static get direction() {
		return {
			up: 1,
			down: -1
		}
	}
	static get intervalButtonMap() {}
	collapseChord() {
		this.editor.collapseChord();
	}
	setInterval() {
		this.editor.intervalAdd(this.interval, this.direction);
	}
	bind() {
		var self = this;
		$(this.buttonElement).off('click').on('click', function () {
			if ($(self.buttonElement).attr('id') === 'CollapseChordButton') {
				self.collapseChord();
				return;
			}
			self.setInterval();
		});
	}
}

class StaveButtons {
	constructor(parameters) {
    Vex.Merge(this,parameters);
    this.score = this.layout.score;
	}
	addClef(clef,clefName) {
		var instrument = {
			instrumentName:clefName,
			keyOffset:0,
			clef:clef
		}
		var staff = this.tracker.selections[0].selector.staff;
		var measures = SmoSelection.getMeasureList(this.tracker.selections)
            .map((sel) => sel.measure);
		var selections=[];
		measures.forEach((measure) => {
			selections.push(SmoSelection.measureSelection(this.tracker.layout.score,staff,measure.measureNumber.measureIndex));
		});
		SmoUndoable.changeInstrument(this.tracker.layout.score,instrument,selections,this.editor.undoBuffer);
		this.tracker.replaceSelectedMeasures();
	}
	clefTreble() {
		this.addClef('treble','Treble Instrument');
	}
	clefBass() {
		this.addClef('bass','Bass Instrument');
	}
	clefAlto() {
		this.addClef('alto','Alto Instrument');
	}
	clefTenor() {
		this.addClef('tenor','Tenor Instrument');
	}
    _clefMove(index,direction) {
        SmoUndoable.scoreSelectionOp(this.tracker.layout.score,this.tracker.selections[0],'moveStaffUpDown',
           index,this.editor.undoBuffer,'Move staff '+direction);
        this.tracker.layout.rerenderAll();
    }
    clefMoveUp() {
        this._clefMove(-1,'up');
    }
    clefMoveDown() {
        this._clefMove(1,'down');
    }
    _addStaffGroup(type) {
        SmoUndoable.addConnectorDown(this.tracker.layout.score,
            this.tracker.selections,
        {mapType:SmoSystemGroup.mapTypes.allMeasures,leftConnector:type,
            rightConnector:SmoSystemGroup.connectorTypes.single},
            this.editor.undoBuffer);
    }
    staffBraceLower() {
        this._addStaffGroup(SmoSystemGroup.connectorTypes.brace);
    }
    staffBracketLower() {
        this._addStaffGroup(SmoSystemGroup.connectorTypes.bracket);
    }
	bind() {
		var self = this;
		$(this.buttonElement).off('click').on('click', function (ev) {
			 console.log('couch');
			 var id = self.buttonData.id;
			if (typeof(self[id]) === 'function') {
				self[id]();
			}
		});
	}
}
class MeasureButtons {
	constructor(parameters) {
    Vex.Merge(this,parameters);
	}
	/*
	 static get barlines() {
        return {
            singleBar: 0,
            doubleBar: 1,
            endBar: 2,
            startRepeat: 3,
            endRepeat: 4,
            none: 5
        }
    }*/
	setEnding(startBar,endBar,number) {
		this.editor.scoreOperation('addEnding',new SmoVolta({startBar:startBar,endBar:endBar,number:number}));

	}
	setBarline(selection,position,barline,description) {
		this.editor.scoreSelectionOperation(selection, 'setMeasureBarline', new SmoBarline({position:position,barline:barline})
		    ,description);
	}
	setSymbol(selection,position,symbol,description) {
		this.editor.scoreSelectionOperation(selection, 'setRepeatSymbol', new SmoRepeatSymbol({position:position,symbol:symbol})
		    ,description);
	}
	endRepeat() {
		var selection = this.tracker.getExtremeSelection(1);
		this.setBarline(selection,SmoBarline.positions.end,SmoBarline.barlines.endRepeat,'add repeat');
	}
	startRepeat() {
		var selection = this.tracker.getExtremeSelection(-1);
		this.setBarline(selection,SmoBarline.positions.start,SmoBarline.barlines.startRepeat,'add start repeat');
	}
	singleBarStart() {
		var selection = this.tracker.getExtremeSelection(-1);
		this.setBarline(selection,SmoBarline.positions.start,SmoBarline.barlines.singleBar,'single start bar');
	}
    singleBarEnd() {
		var selection = this.tracker.getExtremeSelection(1);
		this.setBarline(selection,SmoBarline.positions.end,SmoBarline.barlines.singleBar,'single  bar');
	}

	doubleBar() {
		var selection = this.tracker.getExtremeSelection(1);
		this.setBarline(selection,SmoBarline.positions.end,SmoBarline.barlines.doubleBar,'double  bar');
	}
	endBar() {
		var selection = this.tracker.getExtremeSelection(1);
		this.setBarline(selection,SmoBarline.positions.end,SmoBarline.barlines.endBar,'final  bar');
	}
	coda() {
		var selection = this.tracker.getExtremeSelection(1);
		this.setSymbol(selection,SmoRepeatSymbol.positions.end,SmoRepeatSymbol.symbols.Coda);
	}
	toCoda() {
		var selection = this.tracker.getExtremeSelection(1);
		this.setSymbol(selection,SmoRepeatSymbol.positions.end,SmoRepeatSymbol.symbols.ToCoda);
	}
	segno() {
		var selection = this.tracker.getExtremeSelection(1);
		this.setSymbol(selection,SmoRepeatSymbol.positions.end,SmoRepeatSymbol.symbols.Segno);
	}
	dsAlCoda() {
		var selection = this.tracker.getExtremeSelection(1);
		this.setSymbol(selection,SmoRepeatSymbol.positions.end,SmoRepeatSymbol.symbols.DsAlCoda);
	}
	dcAlCoda() {
		var selection = this.tracker.getExtremeSelection(1);
		this.setSymbol(selection,SmoRepeatSymbol.positions.end,SmoRepeatSymbol.symbols.DcAlCoda);
	}
	dsAlFine() {
		var selection = this.tracker.getExtremeSelection(1);
		this.setSymbol(selection,SmoRepeatSymbol.positions.end,SmoRepeatSymbol.symbols.DsAlFine);
	}
	dcAlFine() {
		var selection = this.tracker.getExtremeSelection(1);
		this.setSymbol(selection,SmoRepeatSymbol.positions.end,SmoRepeatSymbol.symbols.DcAlFine);
	}
	fine() {
		var selection = this.tracker.getExtremeSelection(1);
		this.setSymbol(selection,SmoRepeatSymbol.positions.end,SmoRepeatSymbol.symbols.Fine);
	}
	nthEnding() {
		var startSel = this.tracker.getExtremeSelection(-1);
		var endSel = this.tracker.getExtremeSelection(1);
		this.setEnding(startSel.selector.measure,endSel.selector.measure,1);
	}
  handleEvent(event,method) {
    this[method]();
    this.tracker.replaceSelectedMeasures();
  }

	bind() {
		var self = this;
    this.eventSource.domClick(this.buttonElement,this,'handleEvent',this.buttonData.id);
	}
}

class PlayerButtons {
	constructor(parameters) {
    Vex.Merge(this,parameters);
  }
  playButton() {
    this.editor.playScore();
  }
  stopButton() {
    this.editor.stopPlayer();
  }
  pauseButton() {
    this.editor.pausePlayer();
  }
  bind() {
    this.eventSource.domClick(this.buttonElement,this,this.buttonData.id);
  }
}

class DisplaySettings {
  constructor(parameters) {
    Vex.Merge(this,parameters);
  }

  refresh() {
      this.layout.setViewport(true);
      this.layout.setRefresh();
  }
  zoomout() {
      this.layout.score.layout.zoomMode = SmoScore.zoomModes.zoomScale;
      this.layout.score.layout.zoomScale = this.layout.score.layout.zoomScale * 1.1;
      this.layout.setViewport();
      this.layout.setRefresh();
  }
  zoomin() {
      this.layout.score.layout.zoomMode = SmoScore.zoomModes.zoomScale;
      this.layout.score.layout.zoomScale = this.layout.score.layout.zoomScale / 1.1;
      this.layout.setViewport();
      this.layout.setRefresh();
  }
  playButton2() {
    this.editor.playScore();
  }
  stopButton2() {
    this.editor.stopPlayer();
  }


  bind() {
    this.eventSource.domClick(this.buttonElement,this,this.buttonData.id);
  }
}
class TextButtons {
	constructor(parameters) {
    Vex.Merge(this,parameters);
    this.menus = this.controller.menus;
	}
  lyrics() {
	  SuiLyricDialog.createAndDisplay(
      {
        buttonElement:this.buttonElement,
        buttonData:this.buttonData,
        completeNotifier:this.controller,
        tracker: this.tracker,
        layout:this.layout,
        undoBuffer:this.editor.undoBuffer,
        eventSource:this.eventSource,
        editor:this.editor,
        parser:SmoLyric.parsers.lyric
      }
    );
  	// tracker, selection, controller
  }
  chordChanges() {
    SuiChordChangeDialog.createAndDisplay(
      {
        buttonElement:this.buttonElement,
        buttonData:this.buttonData,
        completeNotifier:this.controller,
        tracker: this.tracker,
        layout:this.layout,
        undoBuffer:this.editor.undoBuffer,
        eventSource:this.eventSource,
        editor:this.editor,
        parser:SmoLyric.parsers.chord
      }
    );
  }
  rehearsalMark() {
    var selection = this.tracker.getExtremeSelection(-1);
    var cmd = selection.measure.getRehearsalMark() ? 'removeRehearsalMark' : 'addRehearsalMark';
    this.editor.scoreSelectionOperation(selection, cmd, new SmoRehearsalMark());
  }
  _invokeMenu(cmd) {
    this.menus.slashMenuMode(this.controller);
    this.menus.createMenu(cmd);
  }

  addTextMenu() {
    var dialog = SuiTextTransformDialog.createAndDisplay(
      {
        buttonElement:this.buttonElement,
        buttonData:this.buttonData,
        completeNotifier:this.controller,
        tracker: this.tracker,
        layout:this.layout,
        undoBuffer:this.editor.undoBuffer,
        eventSource:this.eventSource,
        editor:this.editor
    });
  }
	addDynamicsMenu() {
        this._invokeMenu('SuiDynamicsMenu');
	}
  bind() {
    var self=this;
    this.eventSource.domClick(this.buttonElement,this,self.buttonData.id);
	}
}

class NavigationButtons {
	static get directionsTrackerMap() {
		return {
			navLeftButton: 'moveSelectionLeft',
			navRightButton: 'moveSelectionRight',
			navUpButton: 'moveSelectionUp',
			navDownButton: 'moveSelectionDown',
			navFastForward: 'moveSelectionRightMeasure',
			navRewind: 'moveSelectionLeftMeasure',
			navGrowLeft: 'growSelectionLeft',
			navGrowRight: 'growSelectionRight'
		};
	}
	constructor(parameters) {
    Vex.Merge(this,parameters);
	}

	_moveTracker() {
		this.tracker[NavigationButtons.directionsTrackerMap[this.buttonData.id]]();
	}
	bind() {
		var self = this;
    this.eventSource.domClick(this.buttonElement,this,'_moveTracker');
	}
}
class ArticulationButtons {
	static get articulationIdMap() {
		return {
			accentButton: SmoArticulation.articulations.accent,
			tenutoButton: SmoArticulation.articulations.tenuto,
			staccatoButton: SmoArticulation.articulations.staccato,
			marcatoButton: SmoArticulation.articulations.marcato,
			pizzicatoButton: SmoArticulation.articulations.pizzicato,
			fermataButton: SmoArticulation.articulations.fermata,
      mordentButton: SmoOrnament.ornaments.mordent,
      mordentInvertedButton:SmoOrnament.ornaments.mordentInverted,
      trillButton: SmoOrnament.ornaments.trill,
      scoopButton: SmoOrnament.ornaments.scoop,
      dropButton: SmoOrnament.ornaments.drop,
      dropLongButton: SmoOrnament.ornaments.dropLong,
      doitButton: SmoOrnament.ornaments.doit,
      doitLongButton: SmoOrnament.ornaments.doitLong,
      flipButton: SmoOrnament.ornaments.flip,
      smearButton: SmoOrnament.ornaments.smear
		};
	}
  static get constructors() {
    return {
  		accentButton: 'SmoArticulation',
  		tenutoButton: 'SmoArticulation',
  		staccatoButton: 'SmoArticulation',
  		marcatoButton: 'SmoArticulation',
  		pizzicatoButton: 'SmoArticulation',
  		fermataButton: 'SmoArticulation',
      mordentButton: 'SmoOrnament',
      mordentInvertedButton:'SmoOrnament',
      trillButton:'SmoOrnament',
      scoopButton: 'SmoOrnament',
      dropButton: 'SmoOrnament',
      dropLongButton: 'SmoOrnament',
      doitButton: 'SmoOrnament',
      doitLongButton: 'SmoOrnament',
      flipButton: 'SmoOrnament',
      smearButton:'SmoOrnament'
    }
  }
	constructor(parameters) {
		this.buttonElement = parameters.buttonElement;
		this.buttonData = parameters.buttonData;
		this.editor = parameters.editor;
		this.articulation = ArticulationButtons.articulationIdMap[this.buttonData.id];
    this.eventSource = parameters.eventSource;
    this.ctor = ArticulationButtons.constructors[this.buttonData.id];
	}
	_toggleArticulation() {
		this.showState = !this.showState;
		this.editor.toggleArticulationCommand(this.articulation, this.ctor);
	}
	bind() {
		var self = this;
    this.eventSource.domClick(this.buttonElement,this,'_toggleArticulation');
	}
}


class CollapseRibbonControl {
	static get paramArray() {
		return ['ribbonButtons', 'editor', 'controller', 'tracker', 'menus', 'buttonData', 'buttonElement',
    'layout','eventSource','undoBuffer'];
	}
	constructor(parameters) {
		smoSerialize.filteredMerge(CollapseRibbonControl.paramArray, parameters, this);
		this.childButtons = parameters.ribbonButtons.filter((cb) => {
				return cb.group === this.buttonData.group &&
                    RibbonButtons.isCollapsible(cb.action)
			});
	}
	_toggleExpand() {
		this.childButtons.forEach((cb) => {

			var el = $('#' + cb.id);
			$(el).toggleClass('collapsed');
			$(el).toggleClass('expanded');
		});

		this.buttonElement.closest('div').toggleClass('expanded');
		this.buttonElement.toggleClass('expandedChildren');
		if (this.buttonElement.hasClass('expandedChildren')) {
			var leftSpan = $(this.buttonElement).find('.ribbon-button-text');
			$(leftSpan).text('');
			$(leftSpan).removeClass(this.buttonData.icon);
			$(this.buttonElement).addClass('icon icon-circle-left');
		} else {
			$(this.buttonElement).removeClass('icon-circle-left');
			var leftSpan = $(this.buttonElement).find('.ribbon-button-text');
			$(leftSpan).addClass(this.buttonData.icon);
			$(leftSpan).text(this.buttonData.leftText);
		}
  	// Expand may change music dom, redraw
  	$('body').trigger('forceScrollEvent');
	}
	bind() {
		var self = this;
		$(this.buttonElement).closest('div').addClass('collapseContainer');
    this.eventSource.domClick(this.buttonElement,this,'_toggleExpand');
		this.childButtons.forEach((cb) => {
			var ctor = eval(cb.ctor);
			var el = $('#' + cb.id);
			var btn = new ctor({
					buttonData: cb,
					buttonElement: el,
					editor: this.editor,
					tracker: this.tracker,
					controller: this.controller,
          layout:this.layout,
          eventSource:this.eventSource,
          undoBuffer:this.undoBuffer
				});
        if (typeof(btn.bind) == 'function') {
          btn.bind();
        }
		});
	}
}
;class SuiStaffModifierDialog extends SuiDialogBase {
	 handleRemove() {
      $(this.context.svg).find('g.' + this.modifier.attrs.id).remove();
      var selection = SmoSelection.measureSelection(this.layout.score,this.modifier.startSelector.staff,this.modifier.startSelector.measure);
      SmoUndoable.staffSelectionOp(this.layout.score,selection,'removeStaffModifier',this.modifier,this.undoBuffer,'remove slur');
      this.tracker.clearModifierSelections();
    }

    _preview() {
        this.modifier.backupOriginal();
        this.components.forEach((component) => {
            this.modifier[component.smoName] = component.getValue();
        });
        this.layout.renderStaffModifierPreview(this.modifier)
    }

    changed() {
        this.modifier.backupOriginal();
        this.components.forEach((component) => {
            this.modifier[component.smoName] = component.getValue();
        });
        this.layout.renderStaffModifierPreview(this.modifier);
    }
}


class SuiSlurAttributesDialog extends SuiStaffModifierDialog {
  get ctor() {
    return SuiSlurAttributesDialog.ctor;
  }
  static get ctor() {
    return 'SuiSlurAttributesDialog';
  }

  static get dialogElements() {
    SuiSlurAttributesDialog._dialogElements = SuiSlurAttributesDialog._dialogElements ? SuiSlurAttributesDialog._dialogElements :
    [
      {
        staticText: [
          { label: 'Slur Properties' }
        ]
      }, {
        parameterName: 'spacing',
        smoName: 'spacing',
        defaultValue: 2,
        control: 'SuiRockerComponent',
        label: 'Spacing'
      }, {
        smoName: 'thickness',
        parameterName: 'thickness',
        defaultValue: 2,
        control: 'SuiRockerComponent',
        label: 'Thickness'
      }, {
        smoName: 'xOffset',
        parameterName: 'xOffset',
        defaultValue: 0,
        control: 'SuiRockerComponent',
        label: 'X Offset'
      }, {
        smoName: 'yOffset',
        parameterName: 'yOffset',
        defaultValue: 10,
        control: 'SuiRockerComponent',
        label: 'Y Offset'
      }, {
        smoName: 'position',
        parameterName: 'position',
        defaultValue: SmoSlur.positions.HEAD,
        options: [{
            value: SmoSlur.positions.HEAD,
            label: 'Head'
          }, {
            value: SmoSlur.positions.TOP,
            label: 'Top'
          }
        ],
        control: 'SuiDropdownComponent',
        label: 'Start Position'
      }, {
        smoName: 'position_end',
        parameterName: 'position_end',
        defaultValue: SmoSlur.positions.HEAD,
        options: [{
          value: SmoSlur.positions.HEAD,
          label: 'Head'
        }, {
          value: SmoSlur.positions.TOP,
          label: 'Top'
        }
        ],
        control: 'SuiDropdownComponent',
        label: 'End Position'
      }, {
        smoName: 'invert',
        parameterName: 'invert',
        defaultValue: false,
        control: 'SuiToggleComponent',
        label: 'Invert'
      }, {
        parameterName: 'cp1x',
        smoName: 'cp1x',
        defaultValue: 0,
        control: 'SuiRockerComponent',
        label: 'Control Point 1 X'
      }, {
        parameterName: 'cp1y',
        smoName: 'cp1y',
        defaultValue: 40,
        control: 'SuiRockerComponent',
        label: 'Control Point 1 Y'
      }, {
        parameterName: 'cp2x',
        smoName: 'cp2x',
        defaultValue: 0,
        control: 'SuiRockerComponent',
        label: 'Control Point 2 X'
      }, {
        parameterName: 'cp2y',
        smoName: 'cp2y',
        defaultValue: 40,
        control: 'SuiRockerComponent',
        label: 'Control Point 2 Y'
      }
    ];

    return SuiSlurAttributesDialog._dialogElements;
  }
  static createAndDisplay(parameters) {
    var dg = new SuiSlurAttributesDialog(parameters);
    dg.display();
    return dg;
  }
  constructor(parameters) {
    if (!parameters.modifier) {
        throw new Error('modifier attribute dialog must have modifier');
    }

    super(SuiSlurAttributesDialog.dialogElements, {
      id: 'dialog-' + parameters.modifier.attrs.id,
      top: parameters.modifier.renderedBox.y,
      left: parameters.modifier.renderedBox.x,
      label: 'Slur Properties',
     ...parameters
    });
    Vex.Merge(this, parameters);
    this.completeNotifier.unbindKeyboardForModal(this);
  }
  populateInitial() {
    this.components.forEach((comp) => {
      if (typeof(this.modifier[comp.smoName]) != 'undefined') {
        comp.setValue(this.modifier[comp.smoName]);
      }
    });
  }
  display() {
    super.display();
    this.populateInitial();
  }
}

class SuiVoltaAttributeDialog extends SuiStaffModifierDialog {
  get ctor() {
    return SuiVoltaAttributeDialog.ctor;
  }
  static get ctor() {
    return 'SuiVoltaAttributeDialog';
  }
  static get label() {
    SuiVoltaAttributeDialog._label = SuiVoltaAttributeDialog._label ?
        SuiVoltaAttributeDialog._label : 'Volta Properties';
    return SuiVoltaAttributeDialog._label;
  }
  static set label(value) {
    SuiVoltaAttributeDialog._label = value;
  }

 static get dialogElements() {
    SuiVoltaAttributeDialog._dialogElements = SuiVoltaAttributeDialog._dialogElements ? SuiVoltaAttributeDialog._dialogElements :
      [
        {
          staticText: [
            {label: 'Volta Properties'}
          ]
        },
        {
        parameterName: 'number',
        smoName: 'number',
        defaultValue: 1,
        control: 'SuiRockerComponent',
        label: 'number'
        }, {
        smoName: 'xOffsetStart',
        parameterName: 'xOffsetStart',
        defaultValue: 0,
        control: 'SuiRockerComponent',
        label: 'X1 Offset'
        }, {
        smoName: 'xOffsetEnd',
        parameterName: 'xOffsetEnd',
        defaultValue: 0,
        control: 'SuiRockerComponent',
        label: 'X2 Offset'
        }, {
        smoName: 'yOffset',
        parameterName: 'yOffset',
        defaultValue: 0,
        control: 'SuiRockerComponent',
        label: 'Y Offset'
        }
     ];

     return SuiVoltaAttributeDialog._dialogElements;
 }
 static createAndDisplay(parameters) {
    var dg = new SuiVoltaAttributeDialog(parameters);
    dg.display();
    return dg;
  }
handleRemove() {
  this.undoBuffer.addBuffer('Remove nth ending', 'score', null, this.layout.score);
	this.layout.score.staves.forEach((staff) => {
  	staff.measures.forEach((measure) => {
  		if (measure.measureNumber.measureNumber === this.modifier.startBar) {
  			measure.removeNthEnding(this.modifier.number);
  		}
  	 });
	});
  $(this.context.svg).find('g.' + this.modifier.endingId).remove();
  this.selection.staff.removeStaffModifier(this.modifier);
 }
  _commit() {
    this.modifier.restoreOriginal();
	  this.layout.score.staves.forEach((staff) => {
  		staff.measures.forEach((measure) => {
    		if (measure.measureNumber.measureNumber === this.modifier.startBar) {
    			var endings = measure.getNthEndings().filter((mm) => {
    			  return mm.endingId === this.modifier.endingId;
    			});
    			if (endings.length) {
    			  endings.forEach((ending) => {
      		    this.components.forEach((component) => {
    			      ending[component.smoName] = component.getValue();
    			    });
    			  });
    		  }
    	  }
      });
	  });

    this.layout.renderStaffModifierPreview(this.modifier);
  }
  constructor(parameters) {
    if (!parameters.modifier) {
        throw new Error('modifier attribute dialog must have modifier');
    }

    super(SuiVoltaAttributeDialog.dialogElements, {
        id: 'dialog-' + parameters.modifier.attrs.id,
        top: parameters.modifier.renderedBox.y,
        left: parameters.modifier.renderedBox.x,
        ...parameters
    });
    Vex.Merge(this, parameters);
    this.selection = SmoSelection.measureSelection(this.layout.score,this.modifier.startSelector.staff,this.modifier.startSelector.measure);

  	SmoVolta.editableAttributes.forEach((attr) => {
  		var comp = this.components.find((cc)=>{return cc.smoName===attr});
  		if (comp) {
  			comp.defaultValue=this.modifier[attr];
  		}
  	});

    this.completeNotifier.unbindKeyboardForModal(this);
  }
}

class SuiHairpinAttributesDialog extends SuiStaffModifierDialog {
  get ctor() {
    return SuiHairpinAttributesDialog.ctor;
  }
  static get ctor() {
    return 'SuiHairpinAttributesDialog';
  }

  static get label() {
    SuiHairpinAttributesDialog._label = SuiHairpinAttributesDialog._label ? SuiHairpinAttributesDialog._label
      : 'Hairpin Properties';
    return SuiHairpinAttributesDialog._label;
  }
  static set label(value) {
    SuiHairpinAttributesDialog._label = value;
  }
  static get dialogElements() {
    SuiHairpinAttributesDialog._dialogElements = SuiHairpinAttributesDialog._dialogElements ? SuiHairpinAttributesDialog._dialogElements :
    [
      {
        staticText: [
          { label: 'Hairpin Properties' }
        ]
      },
      {
        parameterName: 'height',
        smoName: 'height',
        defaultValue: 10,
        control: 'SuiRockerComponent',
        label: 'Height'
      }, {
        smoName: 'yOffset',
        parameterName: 'y_shift',
        defaultValue: 0,
        control: 'SuiRockerComponent',
        label: 'Y Shift'
      }, {
        smoName: 'xOffsetRight',
        parameterName: 'right_shift_px',
        defaultValue: 0,
        control: 'SuiRockerComponent',
        label: 'Right Shift'
      }, {
        smoName: 'xOffsetLeft',
        parameterName: 'left_shift_px',
        defaultValue: 0,
        control: 'SuiRockerComponent',
        label: 'Left Shift'
      }
    ];

    return SuiHairpinAttributesDialog._dialogElements;
  }
  static createAndDisplay(parameters) {
    var dg = new SuiHairpinAttributesDialog(parameters);
    dg.display();
    return dg;
  }
  constructor(parameters) {
    if (!parameters.modifier) {
        throw new Error('modifier attribute dialog must have modifier');
    }

    super(SuiHairpinAttributesDialog.dialogElements, {
      id: 'dialog-' + parameters.modifier.attrs.id,
      top: parameters.modifier.renderedBox.y,
      left: parameters.modifier.renderedBox.x,
      ...parameters
    });
    Vex.Merge(this, parameters);
  	SmoStaffHairpin.editableAttributes.forEach((attr) => {
  		var comp = this.components.find((cc)=>{return cc.smoName===attr});
  		if (comp) {
  			comp.defaultValue=this.modifier[attr];
  		}
  	});

    this.completeNotifier.unbindKeyboardForModal(this);
  }
}
;
class Qwerty {
  static get navigationElements() {

    var kbRows =
    [
      { row: '1234567890-=',shifted:'!@#$%^&*()_+'},
      { row: 'QWERTYUIOP[]',shifted:'QWERTYIOP{}'},
      { row:"ASDFGHJKL;'", shifted:'ASDFGHJKL:"'},
      { row:'ZXCVBNM,./',shifted:'ZXCVBNM<>?'}
    ];
    var arrows = [
      {icon: 'icon-arrow-left',text:'', shifted:'',classes:'helpKey',dataKey:'ArrowLeft'},
      {icon: 'icon-arrow-right',text:'', shifted:'',classes:'helpKey',dataKey:'ArrowRight'},
      {icon:'',text:'Space',classes:'wideKey',shifted:'',dataKey:'Space'},
      {icon: 'icon-arrow-up',text:'', shifted:'',classes:'helpKey',dataKey:'ArrowUp'},
      {icon: 'icon-arrow-down' ,text:'', shifted:'',classes:'helpKey',dataKey:'ArrowDown'},
      {icon: '' ,text:'Ins', shifted:'',classes:'helpKey',dataKey:'Insert'},
      {icon: '' ,text:'Del', shifted:'',classes:'helpKey',dataKey:'Delete'}
    ];
    var keyRows = {};
    var labels = ['topNumbers','keys1','keys2','keys3','arrows'];
    var j = 0;

    kbRows.forEach((kbRow) => {
      var str = kbRow.row;
      var shifted = kbRow.shifted;
      var keys = [];
      for (var i = 0;i < str.length;++i) {
        if (j === 2 && i === 0) {
          keys.push({icon:'',text:'Shift',classes:'wideKey',dataKey:'shift'});
        }
        if (j === 3 && i === 0) {
          keys.push({icon:'',text:'Ctrl',classes:'wideKey',dataKey:'ctrl'});
          keys.push({icon:'',text:'Alt',classes:'helpKey',dataKey:'alt'});
        }
        keys.push({icon:'', text:str[i],shifted:shifted[i],classes:'helpKey',dataKey:str[i]});
      }
      keyRows[labels[j]] = {id:labels[j],rows:keys};
      j += 1;
    });
    keyRows[labels[j]] = {id:labels[j],rows:arrows};
    return keyRows;
  }
  static flashShift() {
    if (Qwerty._shiftTime) {
      Qwerty._shiftTime = 0;
      setTimeout(function() {
        Qwerty.flashShift();
      },1000);
    } else {
      $('.kb-float').removeClass('shifted');
    }
  }

  static displayForDuration() {
    Qwerty.displayAll();
    $('#row-0').hide();
    $('#row-1').hide();
    $('#row-4').hide();
  }

  static displayForTuplet() {
    Qwerty.displayAll();
    $('#row-1').hide();
    $('#row-2').hide();
  }

  static displayAll() {
    $('#row-0').show();
    $('#row-1').show();
    $('#row-2').show();
    $('#row-3').show();
    $('#row-4').show();
  }

  static _flashButton(key) {
    var e = $('[data-key="'+key+'"]');
    if (!e.length) {
       e = $('[data-shift="'+key+'"]');
    }
    if (e.length) {
      $(e).removeClass('transition-button');
      $(e).addClass('reverse-button');
      setTimeout(function() {
        $(e).removeClass('reverse-button');
        $(e).addClass('transition-button');
      },750);
    }
  }
  static get editingKeys()  {
    return ['ArrowLeft','ArrowRight','ArrowUp','ArrowDown','Insert','Delete'];
  }
  static handleKeyEvent(evdata) {
    if (Qwerty.editingKeys.indexOf(evdata.code) >= 0) {
      Qwerty._flashButton(evdata.code);
    } else if (evdata.key.length === 1
      && evdata.key.charCodeAt(0) > 32
      && evdata.key.charCodeAt(0) < 127) {
      Qwerty._flashButton(evdata.key.toUpperCase());
    }
    if (evdata.code === 'Space') {
      Qwerty._flashButton('Space');
    }
    if (evdata.ctrlKey) {
      Qwerty._flashButton('ctrl');
    }
    if (evdata.shiftKey) {
      Qwerty._flashButton('shift');
      $('.kb-float').addClass('shifted');
      Qwerty._shiftTime = 1;
      Qwerty.flashShift();
    }
    if (evdata.altKey) {
      Qwerty._flashButton('alt');
    }
  }

  static _kbButton(buttons) {
    var b = htmlHelpers.buildDom;
    var r = b('span').classes('keyContainer');
    buttons.rows.forEach((button) => {
      var text = button.text;
      var shiftedText = button.shifted ? button.shifted : text;
      r.append(b('span').classes(button.icon + ' ' + button.classes)
        .attr('data-key',button.dataKey).attr('data-shift',shiftedText)
          .append(b('span').classes('button-text').text(text))
          .append(b('span').classes('button-shifted').text(shiftedText))
      );
    });
    return r;
  }
  static _buttonBlock(buttons,id) {
    var b = htmlHelpers.buildDom;
    var r = b('div').classes('keyBlock').attr('id', id);
    r.append(Qwerty._kbButton(buttons));
    return r;
  }

  static _buildElements(rows) {
    var b = htmlHelpers.buildDom;
    var r = b('div').classes('buttonLine')
      .append(b('span').classes('icon icon-move'));
    var keys = Object.keys(rows);
    var rowIx = 0;
    keys.forEach((key) => {
      var row = rows[key];
      r.append(Qwerty._buttonBlock(row,'row-'+rowIx));
      rowIx += 1;
    });
    return r;
  }
  static displayKb() {
    $('body').addClass('showQwerty');
    $('.qwertyKb').html('');
    var b = htmlHelpers.buildDom;
    var r = b('div').classes('kb-float');
    r.append(Qwerty._buildElements(Qwerty.navigationElements));
    $('.qwertyKb').append(r.dom());

    var cb = function (x, y) {}
    htmlHelpers.draggable({
      parent: $('.qwertyKb'),
      handle: $('.qwertyKb').find('.icon-move'),
      animateDiv:'.draganime',
      cb: cb,
      moveParent: true
    });
  }


}
;

class SmoHelp {

  static displayHelp() {
    $('body').addClass('showHelpDialog');
    $('.helpDialog').html('');
    var b = htmlHelpers.buildDom;
    SmoHelp.helpHtml.forEach((cat) => {
      var r = SmoHelp._buildElements(cat);
      $('.helpDialog').append(r.dom());
    });
    $('.helpDialog').append(SmoHelp.closeButton.dom());
		$('button.help-title').off('click').on('click',function(ev) {
			$(this).closest('div.helpLine').toggleClass('showSection');
			$(this).find('span.icon').toggleClass('icon-plus');
			$(this).find('span.icon').toggleClass('icon-minus');
		});
    $('.helpDialog button.icon-cross').off('click').on('click', function () {
        $('body').removeClass('showHelpDialog');
        $('.workspace').css("height",'');
    });
    var wsh = window.innerHeight;
    $('.workspace').css("height",''+wsh+'px');
  }

  static get closeButton() {
      var b = htmlHelpers.buildDom;
      var r = b('div').classes('help-closer').append(
        b('button').classes('icon-cross close'));
      return r;
  }

  static _buildElements(helps) {
    var b = htmlHelpers.buildDom;
    var r = b('div').classes('helpLine')
      .append(b('div').classes('help-category-button')
        .append(b('button')
          .append(b('span').classes('icon icon-plus')).classes('help-title')
          .append(b('span').classes('help-category-text').text(helps.title))))
      .append(b('div').classes('help-content').html(helps.html));

    return r;
  }

  static get helpHtml() {
    return [
      {title:'Quick Start',html:SmoLanguage.getHelpFile('quickStartHtml')},
      {title:'Selections and Selecting Things',html:SmoLanguage.getHelpFile('selectionHtml')},
      {title:'Entering Music (Pitches)',html:SmoLanguage.getHelpFile('enterPitchesHtml')},
      {title:'Entering Music (Durations)',html:SmoLanguage.getHelpFile('enterDurationsHtml')},
      {title:'Working with Text, Lyrics, Chords',html:SmoLanguage.getHelpFile('workingWithText')}
    ];
  }
}
;
class SuiDom {

  static splash() {
    var b = htmlHelpers.buildDom;
    var logoPath = SmoConfig.smoPath + '/styles/images/logo.png'
    var r = b('div').classes('bug-modal').append(
        b('img').attr('src', logoPath).classes('splash-logo'))
      .append(b('button').classes('icon icon-cross bug-dismiss-button'))
      .append(b('span').classes('splash-title').text('Sm'))
      .append(b('span').classes('splash-shine').text('ooooooooo'))
      .append(b('span').classes('splash-title').text('sic'));
    $('.bugDialog').append(r.dom());
    $('body').addClass('splashScreen modal');
    setTimeout(function () {
      $('body').removeClass('splashScreen modal');
    }, 1000);
  }

	static createDom(title) {
    if (title) {
  	  $('h1.testTitle').text(title);
  	}

    var b = htmlHelpers.buildDom;
    var smoId = SmoConfig.smoDomContainer;
    var vexId = SmoConfig.vexDomContainer;
    var r=b('div').classes('dom-container')
      .append(b('div').classes('modes'))
      .append(b('div').classes('overlay'))
      .append(b('div').classes('draganime hide'))
      .append(b('div').classes('textEdit hide'))
      .append(b('div').classes('translation-editor'))
      .append(b('div').classes('attributeDialog'))
      .append(b('div').classes('qwertyKb'))
      .append(b('div').classes('saveLink'))
      .append(b('div').classes('bugDialog'))
      .append(b('div').classes('printFrame'))
      .append(b('div').classes('menuContainer'))
      .append(b('div').classes('workspace language-dir').attr('dir',SmoConfig.languageDir)
        .append(b('div').classes('helpDialog'))
        .append(b('div').classes('control-bar')
          .append(b('div').classes('titleText').text('Smoosic'))
          .append(b('div').classes('piano-container')
            .append(b('div').classes('key-left-ctrl'))
            .append(b('div').classes('piano-keys'))
            .append(b('div').classes('key-right-ctrl')))
          .append(b('div').classes('controls-top')))
        .append(b('div').classes('media')
          .append(b('div').classes('controls-left'))
          .append(b('div').classes('controls-menu-message'))
          .append(b('div').classes('musicRelief')
            .append(b('div').classes('musicContainer').attr('id',vexId)
            .attr('dir','ltr')))));
    $('#'+smoId).append(r.dom());
    var pianoDom=$('.piano-keys')[0];
    var svg=document.createElementNS(svgHelpers.namespace,'svg');
    svg.id='piano-svg';
    svg.setAttributeNS('','width',''+suiPiano.owidth*suiPiano.dimensions.octaves);
    svg.setAttributeNS('','height',''+suiPiano.dimensions.wheight);
    svg.setAttributeNS('','viewBox','0 0 '+suiPiano.owidth*suiPiano.dimensions.octaves+' '+suiPiano.dimensions.wheight);
    pianoDom.appendChild(svg);
	}


}

class UtDom {
  	static createDom() {
      var smoId = SmoConfig.smoDomContainer;
      var vexId = SmoConfig.vexDomContainer
  		var b = htmlHelpers.buildDom;
  		$('#'+smoId).html('');
  		var r = b('div').classes('dom-container')
  			.append(b('div').classes('modes'))
  			.append(b('div').classes('overlay'))
  			.append(b('div').classes('attributeDialog'))
  			.append(b('div').classes('helpDialog'))
  			.append(b('div').classes('menuContainer'))
  			.append(b('h1').classes('testTitle').text('Smoosic'))
  			.append(b('h2').classes('subTitle'))
  			.append(b('div').classes('piano-container')
          .append(b('div').classes('key-left-ctrl'))
  				.append(b('div').classes('piano-keys'))
          .append(b('div').classes('key-right-ctrl')))
  			.append(b('div').classes('workspace-container')
  				.append(b('div').classes('workspace').attr('dir',SmoConfig.languageDir)
  					.append(b('div').classes('controls-top'))
  					.append(b('div').classes('controls-left'))
  					.append(b('div').classes('musicRelief')
  						.append(b('div')
              .classes('musicContainer')
              .attr('id', vexId)
              .attr('dir','ltr')))));
  		$('#'+smoId).append(r.dom());
  	}

    static splash() {
      return;
    }
}
;

// ## suiController
// ## Description:
// Manages DOM events and binds keyboard and mouse events
// to editor and menu commands, tracker and layout manager.
// ### Event model:
// Events can come from the following sources:
// 1. menus or dialogs can send dialogDismiss or menuDismiss event, indicating a modal has been dismissed.
// 2. window resize events
// 3. keyboard, when in editor mode.  When modals or dialogs are active, wait for dismiss event
// 4. svg piano key events smo-piano-key
// 5. tracker change events tracker-selection
class suiController {

	constructor(params) {
		Vex.Merge(this, suiController.defaults);
		Vex.Merge(this, params);
		window.suiControllerInstance = this;


		this.undoBuffer = new UndoBuffer();
    this.eventSource = params.eventSource;
		this.pasteBuffer = this.tracker.pasteBuffer;
    this.tracker.setDialogModifier(this);
		this.editor.controller = this;
		this.editor.undoBuffer = this.undoBuffer;
		this.editor.pasteBuffer = this.pasteBuffer;
		this.resizing = false;
		this.undoStatus=0;
		this.trackScrolling = false;

    this.keyHandlerObj = null;

		this.ribbon = new RibbonButtons({
			ribbons: defaultRibbonLayout.ribbons,
			ribbonButtons: defaultRibbonLayout.ribbonButtons,
			menus: this.menus,
			editor: this.editor,
			tracker: this.tracker,
			score: this.score,
			controller: this,
      layout:this.tracker.layout,
      eventSource:this.eventSource
		});

    this.menus.setController(this);

		// create globbal exception instance
		this.exhandler = new SuiExceptionHandler(this);

		this.bindEvents();

    // Only display the ribbon one time b/c it's expensive operation
    this.ribbon.display();
		this.bindResize();
    this.layoutDemon.undoBuffer = this.undoBuffer;
    this.layoutDemon.startDemon();

		this.createPiano();
	}

	static get scrollable() {
		return '.musicRelief';
	}

  static get keyboardWidget() {
    return suiController._kbWidget;
  }

  static set keyboardWidget(value) {
    suiController._kbWidget = value;
    if (suiController._kbWidget) {
      Qwerty.displayKb();
    }
  }

	get isLayoutQuiet() {
		return ((this.layout.passState == suiLayoutBase.passStates.clean && this.layout.dirty == false)
		   || this.layout.passState == suiLayoutBase.passStates.replace);
	}

	handleScrollEvent(ev) {
		var self=this;
		if (self.trackScrolling) {
				return;
		}
		self.trackScrolling = true;
		setTimeout(function() {
            try {
		    // wait until redraw is done to track scroll events.
			self.trackScrolling = false;

			// self.scrollRedrawStatus = true;
            // self.tracker.updateMap(true);
            // Thisi s a WIP...
			self.scroller.handleScroll($(suiController.scrollable)[0].scrollLeft,$(suiController.scrollable)[0].scrollTop);
            } catch(e) {
                SuiExceptionHandler.instance.exceptionHandler(e);
            }
		},500);
	}

	createPiano() {
		this.piano = new suiPiano(
    {
      elementId:'piano-svg',
			ribbons: defaultRibbonLayout.ribbons,
			ribbonButtons: defaultRibbonLayout.ribbonButtons,
			menus: this.menus,
			editor: this.editor,
			tracker: this.tracker,
			score: this.score,
			controller: this,
      layout:this.tracker.layout,
      eventSource:this.eventSource,
      undoBuffer:this.undoBuffer
		});
        // $('.close-piano').click();
	}
  _setMusicDimensions() {
    $('.musicRelief').height(window.innerHeight - $('.musicRelief').offset().top);

  }
	resizeEvent() {
		var self = this;
		if (this.resizing) {
			return;
    }
    if ($('body').hasClass('printing')) {
      return;
    }
		this.resizing = true;
		setTimeout(function () {
			console.log('resizing');
			self.resizing = false;
      self._setMusicDimensions();
			self.piano.handleResize();
		}, 500);
	}

  createModifierDialog(modifierSelection) {
    var parameters = {
      modifier:modifierSelection.modifier, context:this.tracker.context, tracker:this.tracker, layout:this.layout, undoBuffer:this.undoBuffer,eventSource:this.eventSource,
         completeNotifier:this,editor:this.editor
    }
    SuiModifierDialogFactory.createDialog(modifierSelection.modifier,parameters);
  }

	// If the user has selected a modifier via the mouse/touch, bring up mod dialog
	// for that modifier
	trackerModifierSelect(ev) {
		var modSelection = this.tracker.getSelectedModifier();
		if (modSelection) {
			var dialog = this.createModifierDialog(modSelection);
      if (dialog) {
        this.tracker.selectSuggestion(ev);
  	    // this.unbindKeyboardForModal(dialog);
      } else {
        this.tracker.advanceModifierSelection(ev);
      }
		} else {
      this.tracker.selectSuggestion(ev);
    }
    var modifier = this.tracker.getSelectedModifier();
    // if (modifier) {
    //   this.createModifierDialog(modifier);
    // }
		return;
	}

    // ### bindResize
	// This handles both resizing of the music area (scrolling) and resizing of the window.
	// The latter results in a redraw, the former just resets the client/logical map of elements
	// in the tracker.
	bindResize() {
		var self = this;
		var el = $(suiController.scrollable)[0];
		// unit test programs don't have resize html
		if (!el) {
			return;
		}
    this._setMusicDimensions();
		// $(suiController.scrollable).height(window.innerHeight - $('.musicRelief').offset().top);

		window.addEventListener('resize', function () {
			self.resizeEvent();
		});

		let scrollCallback = (ev) => {
      self.handleScrollEvent(ev);
		};
		el.onscroll = scrollCallback;
	}


	// ### renderElement
	// return render element that is the DOM parent of the svg
	get renderElement() {
		return this.layout.renderElement;
	}

	// ## keyBindingDefaults
	// ### Description:
	// Different applications can create their own key bindings, these are the defaults.
	// Many editor commands can be reached by a single keystroke.  For more advanced things there
	// are menus.
	static get keyBindingDefaults() {
		var editorKeys = suiController.editorKeyBindingDefaults;
		editorKeys.forEach((key) => {
			key.module = 'editor'
		});
		var trackerKeys = suiController.trackerKeyBindingDefaults;
		trackerKeys.forEach((key) => {
			key.module = 'tracker'
		});
		return trackerKeys.concat(editorKeys);
	}

	// ## editorKeyBindingDefaults
	// ## Description:
	// execute a simple command on the editor, based on a keystroke.
	static get editorKeyBindingDefaults() {
		return defaultEditorKeys.keys;
	}

	// ## trackerKeyBindingDefaults
	// ### Description:
	// Key bindings for the tracker.  The tracker is the 'cursor' in the music
	// that lets you select and edit notes.
	static get trackerKeyBindingDefaults() {
		return defaultTrackerKeys.keys;
	}

	helpControls() {
		var self = this;
		var rebind = function () {
			self.bindEvents();
		}
  }
	static set reentry(value) {
		suiController._reentry = value;
	}
	static get reentry() {
		if (typeof(suiController['_reentry']) == 'undefined') {
			suiController._reentry = false;
		}
		return suiController._reentry;
	}

	menuHelp() {
		SmoHelp.displayHelp();
	}

	static get defaults() {
		return {
			keyBind: suiController.keyBindingDefaults
		};
	}

	showModifierDialog(modSelection) {
		return SuiDialogFactory.createDialog(modSelection, this.tracker.context, this.tracker, this.layout,this.undoBuffer,this)
	}

  // ### unbindKeyboardForModal
  // Global events from keyboard and pointer are handled by this object.  Modal
  // UI elements take over the events, and then let the controller know when
  // the modals go away.
	unbindKeyboardForModal(dialog) {
		var self=this;
    layoutDebug.addDialogDebug('controller: unbindKeyboardForModal')
		var rebind = function () {
			self.bindEvents();
      layoutDebug.addDialogDebug('controller: unbindKeyboardForModal resolve')
		}
    this.eventSource.unbindKeydownHandler(this.keydownHandler);
    this.eventSource.unbindMouseMoveHandler(this.mouseMoveHandler);
    this.eventSource.unbindMouseClickHandler(this.mouseClickHandler);

		dialog.closeModalPromise.then(rebind);
	}

	evKey(evdata) {
		var self = this;
    if ($('body').hasClass('translation-mode')) {
      return;
    }

		console.log("KeyboardEvent: key='" + evdata.key + "' | code='" +
			evdata.code + "'"
			 + " shift='" + evdata.shiftKey + "' control='" + evdata.ctrlKey + "'" + " alt='" + evdata.altKey + "'");
		evdata.preventDefault();

    if (suiController.keyboardWidget) {
      Qwerty.handleKeyEvent(evdata);
    }
		if (evdata.key == '?') {
			SmoHelp.displayHelp();
		}

		if (evdata.key == '/') {
      // set up menu DOM.
      this.menus.slashMenuMode(this);
		}

		if (evdata.key == 'Enter') {
			self.trackerModifierSelect(evdata);
      var modifier = this.tracker.getSelectedModifier();
      if (modifier) {
        this.createModifierDialog(modifier);
      }

		}

		var binding = this.keyBind.find((ev) =>
				ev.event === 'keydown' && ev.key === evdata.key && ev.ctrlKey === evdata.ctrlKey &&
				ev.altKey === evdata.altKey && evdata.shiftKey === ev.shiftKey);

		if (binding) {
			try {
			this[binding.module][binding.action](evdata);
			} catch (e) {
				this.exhandler.exceptionHandler(e);
			}
		}
	}

  mouseMove(ev) {
    this.tracker.intersectingArtifact({
      x: ev.clientX,
      y: ev.clientY
    });
  }

  mouseClick(ev) {
    this.tracker.selectSuggestion(ev);
    var modifier = this.tracker.getSelectedModifier();
    if (modifier) {
      this.createModifierDialog(modifier);
    }
  }
	bindEvents() {
		var self = this;
		var tracker = this.tracker;

		$('body').off('redrawScore').on('redrawScore',function() {
			self.handleRedrawTimer();
		});
		$('body').off('forceScrollEvent').on('forceScrollEvent',function() {
			self.handleScrollEvent();
		});
		$('body').off('forceResizeEvent').on('forceResizeEvent',function() {
			self.resizeEvent();
		});
    this.mouseMoveHandler = this.eventSource.bindMouseMoveHandler(this,'mouseMove');
    this.mouseClickHandler = this.eventSource.bindMouseClickHandler(this,'mouseClick');

		/* $(this.renderElement).off('mousemove').on('mousemove', function (ev) {
			tracker.intersectingArtifact({
				x: ev.clientX,
				y: ev.clientY
			});
		});

		$(this.renderElement).off('click').on('click', function (ev) {
      tracker.selectSuggestion(ev);
      var modifier = tracker.getSelectedModifier();
      if (modifier) {
        self.createModifierDialog(modifier);
      }
		});   */

    this.keydownHandler = this.eventSource.bindKeydownHandler(this,'evKey');

		this.helpControls();
		window.addEventListener('error', function (e) {
			SuiExceptionHandler.instance.exceptionHandler(e);
		});
	}

}
;//

// ## SmoTranslationEditor
// Create a somewhat user-friendly editor DOM to translate SMO
// dialogs and menus, and any subset, into other languages.
class SmoTranslationEditor {

   // ### _getHtmlTextInput
   // All the editable text elements contain: the code label or value from the
   // UI element, the En string, and  the translated string, or a copy of the
   // EN string if the string has not been translated.
    static _getHtmlTextInput(dbLabel,enLabel,langLabel,labelType,labelId) {
      var b = htmlHelpers.buildDom;

      const compHtml = b('div').classes('dialog-element-container')
        .attr('data-'+labelType,labelId).append(
          b('div').classes('dialog-component-label').append(
            b('span').classes('trans-label').append(
              b('span').classes('trans-db-text').text(dbLabel)
            ).append(
              b('span').classes('trans-en-text').text(enLabel)
            ).append(
              b('input').classes('trans-label-input')
            ).append(
              b('span').classes('plaintext-translate hide').text(langLabel)
            )
          )
        ).dom();
      return compHtml;
    }

    // ### _getMenuTextDialogHtml
    // Get all the menu item labels for translation
    static _getMenuTextDialogHtml(menuCtor,enStrings,langStrings) {
      const menuClass = eval(menuCtor);
      const menuItems = menuClass['defaults'].menuItems;
      var enMenu = enStrings.find((mn) => mn.ctor === menuCtor);

      // Get the JSON EN menu, or copy the DB strings if it doesn't exist
      if (!enMenu) {
        enMenu = JSON.parse(JSON.stringify(menuClass['defaults']));
        enMenu.ctor = menuCtor;
      }
      // Get the JSON language menu strings, or copy the EN strings if it doesn't exist
      var langMenu = langStrings.find((mn) => mn.ctor === menuCtor);
      if (!langMenu) {
        langMenu = JSON.parse(JSON.stringify(menuClass['defaults']));
        langMenu.ctor = menuCtor;
      }

      // create the DOM menu container
      var b = htmlHelpers.buildDom;
      const container = b('div').classes('menu-translate-container')
        .attr('data-menucontainer',menuCtor).append(
          b('button').classes('icon-plus trans-expander')).append(
            b('span').classes('menu-translate-title').text(menuCtor)
        ).dom();
      const menuItemsDom = b('div').classes('menu-element-container').dom();

      // create the label editor
      const menuLabel = SmoTranslationEditor._getHtmlTextInput(menuClass['defaults'].label,enMenu.label,langMenu.label,
        'menulabel',menuCtor);
      $(menuItemsDom).append(menuLabel);
      $(container).append(menuItemsDom);

      // create the editor for each item
      menuItems.forEach((item) => {
        var enItem  = enMenu.menuItems.find((mi) => mi.value === item.value);
        if (!enItem) {
          enItem = JSON.parse(JSON.stringify(item));
        }
        var langItem = langMenu.menuItems.find((mi) => mi.value === item.value);
        if (!langItem) {
          langItem = JSON.parse(JSON.stringify(item));
        }
        const menuItemDom = b('div').classes('menu-item-container').dom();
        const itemEditDom = SmoTranslationEditor._getHtmlTextInput(
          item.value,enItem.text,langItem.text,
          'itemtext',item.value);
        $(menuItemDom).append(itemEditDom);
        $(menuItemsDom).append(menuItemDom);
      });
      return container;
    }
    static getStaticText(dialogElements,label) {
      return dialogElements.find((x) => x.staticText).staticText.find((x) => x[label]);
    }
    static getButtonTranslateHtml(enStrings,langStrings,transContainer) {
      var b = htmlHelpers.buildDom;
      var buttonDom = b('div').classes('ribbon-translate-container')
        .attr('data-ribbon-translate','buttons').append(
          b('button').classes('icon-plus trans-expander')).append(
          b('span').classes('ribbon-translate-title').text('Button Text')
      ).dom();

      var enKeys = enStrings.find((enString) => enString.ribbonButtonText);
      if (!enKeys) {
        enKeys = JSON.parse(JSON.stringify(RibbonButtons.translateButtons));
      }
      var langKeys = langStrings.find((langString) => langString.ribbonText);
      if (!langKeys) {
        langKeys = JSON.parse(JSON.stringify(RibbonButtons.translateButtons));
      } else {
        langKeys = langKeys.ribbonText;
      }
      RibbonButtons.translateButtons.forEach((button) => {
        const langObj  = langKeys.find((langText) => langText.buttonId === button.buttonId);
        const enObj = enKeys.find((enText) => enText.buttonId === button.buttonId);
        const enString  = enObj ? enObj .buttonText: button.buttonText;
        const langString = langObj ? langObj.buttonText : button.buttonText;
        var buttonContainer = b('div').classes('ribbon-button-container')
          .attr('data-buttoncontainer',button.id).dom();
        $(buttonContainer).append(
           SmoTranslationEditor._getHtmlTextInput(button.buttonId,enString,langString,'ribbon-button',button.buttonId)
        );
        $(buttonDom).append(buttonContainer);
      });
      $(transContainer).append(buttonDom);
    }

    // ### _getStaticTextDialogHtml
    // create DOM for the static text section of the dialogs.
    static _getStaticTextDialogHtml(dialogCtor,element,enDb,langDb,htmlContainer) {
      var b = htmlHelpers.buildDom;

      const dbObj = element.staticText;
      var enStNode = enDb.find((st) => st.staticText);
      if (!enStNode) {
        const enStString = JSON.parse(JSON.stringify(element.staticText));
        enStNode = { staticText:enStString };
        enDb.push({ staticText:enStString });
      }
      var langStNode = langDb.find((st) => st.staticText);
      if (!langStNode|| !langStNode.staticText) {
        const langStString = JSON.parse(JSON.stringify(element.staticText));
        langStNode = { staticText: langStString};
        langDb.push(langStNode);
      }
      const enObj = enStNode.staticText;
      const langObj = langStNode.staticText;
      const nodeContainer = b('div')
        .classes('dialog-element-container')
        .attr('data-component','staticText')
        .dom();
      $(htmlContainer).append(nodeContainer);
      const elKeys = dbObj.map((st) => Object.keys(st)[0]);
      elKeys.forEach((elKey) => {
        var dbVal = dbObj.find((st) => st[elKey]);
        var enVal = enObj.find((st) => st[elKey]);
        var langVal = langObj.find((st) => st[elKey]);
        if (!enVal) {
          enVal = dbVal;
        }
        if (!langVal) {
          langVal = dbVal;
        }
        const translateElement = SmoTranslationEditor._getHtmlTextInput(
          elKey,enVal[elKey],langVal[elKey],'statictext',elKey);
        $(nodeContainer).append(translateElement);
      });
    }

    static _getDialogComponentHtml(dialogCtor,element,enDb,langDb,container) {
      var b = htmlHelpers.buildDom;

      var label = element.label;
      var smoName = element.smoName;
      var enComponent = enDb.find((st) => st.id === smoName);
      if (!enComponent) {
        enComponent = JSON.parse(JSON.stringify(element))
      }
      var langComponent = langDb.find((st) => st.id === smoName);
      if (!langComponent) {
        langComponent = JSON.parse(JSON.stringify(element));
      }
      const enLabel = enComponent.label ? enComponent.label : label;
      const langLabel = langComponent.label ? langComponent.label : label;
      const compHtml = SmoTranslationEditor._getHtmlTextInput(
        label,enLabel,langLabel,'component',smoName);

      if (element.options) {
        const optionsHtml = b('div').classes('dialog-component-options').dom();
        $(compHtml).append(optionsHtml);
        if (!enComponent.options) {
          enComponent.options = JSON.parse(JSON.stringify(element.options));
        }
        if (!langComponent.options) {
          langComponent.options = JSON.parse(JSON.stringify(element.options));
        }

        element.options.forEach((option) => {
          var enOption = enComponent.options.find((op) => op.value === option.value);
          var langOption = langComponent.options.find((op) => op.value === option.value);
          if (!enOption || !enOption.label) {
            enOption = JSON.parse(JSON.stringify(option));
          }
          if (!langOption || !langOption.label) {
            langOption = JSON.parse(JSON.stringify(option));
          }
          const optionHtml =  SmoTranslationEditor._getHtmlTextInput(
            option.value,enOption.label,langOption.label,'component-option',option.value);
            $(optionsHtml).append(optionHtml)
        });
        $(container).append(compHtml);
      }
    }

    static getDialogTranslationHtml(dialogCtor,enStrings,langStrings) {
      var b = htmlHelpers.buildDom;
      var container = b('div').classes('db-translate-container').attr('data-dbcontainer',dialogCtor)
        .append(b('button').classes('icon-plus trans-expander'))
        .append(b('span').classes('db-translate-title').text(dialogCtor)).dom();
      var ctor = eval(dialogCtor);
      var elements = ctor.dialogElements;
      var enDb = enStrings.find((dbStr) => dbStr.ctor === dialogCtor);
      if (!enDb) {
        enDb = JSON.parse(JSON.stringify(elements));
      } else {
        enDb = enDb.dialogElements;
      }
      var langDb = langStrings.find((dbStr) => dbStr.ctor === dialogCtor);
      if (!langDb) {
        langDb = JSON.parse(JSON.stringify(elements));
      } else {
        langDb = langDb.dialogElements;
      }
      elements.forEach((element) => {
        if (element.staticText) {
          SmoTranslationEditor._getStaticTextDialogHtml(dialogCtor,element,enDb,langDb,container);
        } else if (element.smoName) {
          SmoTranslationEditor._getDialogComponentHtml(dialogCtor,element,enDb,langDb,container);
        }
      });
      return container;
    }
    static getAllTranslationHtml(lang) {
      var enStr = SmoLanguage.en.strings
      var langStr = SmoLanguage[lang].strings;
      var b = htmlHelpers.buildDom;
      var container = b('div').classes('top-translate-container')
        .attr('dir',SmoLanguage[lang].dir).dom();
      SmoTranslator.allDialogs.forEach((dialog) => {
        $(container).append(SmoTranslationEditor.getDialogTranslationHtml(dialog,enStr,langStr))
      });
      SmoTranslator.allMenus.forEach((menu) => {
        $(container).append(SmoTranslationEditor._getMenuTextDialogHtml(menu,enStr,langStr));
      });
      SmoTranslationEditor.getButtonTranslateHtml(enStr,langStr,container);
      var resultDom = b('div').classes('translation-json-container').append(
        b('textarea').classes('translation-json-text')).append(
        b('div').append(
          b('button').classes('translate-submit-button').text('Submit')
        )
      ).dom();

      $(container).append(resultDom);

      return container;
    }
    static parseDom() {
      var json = [];
      // $('.top-translate-container .db-translate-container[data-dbcontainer] [data-component="staticText"]')
       $('.top-translate-container .db-translate-container[data-dbcontainer]').each((ix,dbEl) => {
         var db = $(dbEl).attr('data-dbcontainer');
         var obj = {ctor: db};
         var elements = [];
         var domComponents = $(dbEl).find('[data-component]');
         $(domComponents).each(function(ix,domComponent) {
           const compType = $(domComponent).attr('data-component');

           if (compType === 'staticText') {
             var stElements=[];
             $(domComponent).find('[data-statictext]').each((ix,stDom) => {
               const key=$(stDom).attr('data-statictext');
               const value = $(stDom).find('input.trans-label-input').val();
               const stNode = JSON.parse('{"'+key+'":"'+value+'"}');
               stElements.push(stNode);
             });
             elements.push({staticText:stElements});
           } else {
             var dbComponent = {id:compType};
             dbComponent.label = $(domComponent).find('input.trans-label-input').val();
             var compOptions = [];
             $(domComponent).find('[data-component-option]').each(function(ix,optionDom) {
               const value = $(optionDom).find('.trans-db-text').text();
               const label = $(optionDom).find('input.trans-label-input').val();
               compOptions.push({value:value,label:label});
             });
             dbComponent.options = compOptions;
             elements.push(dbComponent);
           }
         });
         obj.dialogElements = elements;
         json.push(obj);

       });
       $('.menu-translate-container[data-menucontainer]').each((ix,menuEl) => {
         var menuId = $(menuEl).attr('data-menucontainer');
         var obj = {ctor:menuId};
         const menuLabel = $(menuEl)
           .find('.dialog-element-container[data-menulabel] .trans-label-input')
           .val();
         obj.label = menuLabel;
         var menuItems = [];
         var itemsDom = $(menuEl).find('.menu-item-container .dialog-element-container');
         $(itemsDom).each((ix,itemDom) => {
           const value = $(itemDom).find('.trans-db-text').text();
           const text = $(itemDom).find('input.trans-label-input').val();
           menuItems.push({value:value,text:text});
         });
         obj.menuItems = menuItems;
         json.push(obj);
       });
       var ribbonText = [];
       $('.ribbon-translate-container .ribbon-button-container').each((ix,buttonEl) => {
         const buttonId = $(buttonEl).find('.trans-db-text').text();
         const buttonText = $(buttonEl).find('input.trans-label-input').val();
         ribbonText.push({buttonId: buttonId,buttonText:buttonText});
       });
       json.push({ribbonText:ribbonText});
      return json;
    }
    static startEditor(lang) {
      var transDom =  SmoTranslationEditor.getAllTranslationHtml(lang);
      $('.translation-editor').append(transDom);
      $('body').addClass('translation-mode');
      $('.plaintext-translate').each(function(ix,el) {
        var txt = $(this).text();
        var input = $(this).closest('.trans-label').find('input.trans-label-input').val(txt);
      });

      $('.db-translate-container button.trans-expander').off('click').on('click', function() {
        var exp = $(this).closest('.db-translate-container');
        if ($(exp).hasClass('expanded')) {
          $(exp).removeClass('expanded');
          $(this).removeClass('icon-minus');
          $(this).addClass('icon-plus');
        } else {
          $(exp).addClass('expanded');
          $(this).addClass('icon-minus');
          $(this).removeClass('icon-plus');
        }
      });
      $('.menu-translate-container button.trans-expander').off('click').on('click', function() {
        var exp = $(this).closest('.menu-translate-container');
        if ($(exp).hasClass('expanded')) {
          $(exp).removeClass('expanded');
          $(this).removeClass('icon-minus');
          $(this).addClass('icon-plus');
        } else {
          $(exp).addClass('expanded');
          $(this).addClass('icon-minus');
          $(this).removeClass('icon-plus');
        }
      });
      $('.ribbon-translate-container button.trans-expander').off('click').on('click', function() {
        var exp = $(this).closest('.ribbon-translate-container');
        if ($(exp).hasClass('expanded')) {
          $(exp).removeClass('expanded');
          $(this).removeClass('icon-minus');
          $(this).addClass('icon-plus');
        } else {
          $(exp).addClass('expanded');
          $(this).addClass('icon-minus');
          $(this).removeClass('icon-plus');
        }
      });
      $('.translate-submit-button').off('click').on('click',(ev) => {
        var json = SmoTranslationEditor.parseDom();
        $('.translation-json-text').val(JSON.stringify(json,null,' '));
      });


    }

}
;class SuiApplication {

  static createUtApplication(config) {
    if (!config) {
      config = {};
    }
    var _config = {
      scoreLoadOrder:['library'],
      scoreLoadJson:'emptyScoreJson',
      ribbon:false,
      editor:false,
      menus:false,
      controller:'utController',
      domSource:'UtDom',
      languageDir:'ltr'
    };
    Vex.Merge(_config,config);
    return new SuiApplication(_config);
  }
  static get defaultConfig() {
    return {
      smoPath:'..',
      language:'en',
      scoreLoadOrder:['query','local','library'],
      scoreLoadJson:'basicJson',
      eventsSource:'browserEventSource',
      controller:'suiController',
      smoDomContainer:'smoo',
      vexDomContainer:'boo',
      domSource:'SuiDom',
      ribbon:true,
      editor:true,
      menus:true,
      title:'Smoosic',
      languageDir:'ltr'
    }
  }

  constructor(params) {
    var config = {};
    Vex.Merge(config,SuiApplication.defaultConfig);
    Vex.Merge(config,params);
    window.SmoConfig = config;
    this.start();
  }
  // ## createUi
  // ### Description:
  // Convenience constructor, taking a renderElement and a score.
  createUi(score) {
    eval(SmoConfig.domSource).createDom();
    var params = suiController.keyBindingDefaults;
    params.eventSource = new browserEventSource(); // events come from the browser UI.

    params.layout = suiScoreLayout.createScoreLayout(document.getElementById(SmoConfig.vexDomContainer),score);
    params.eventSource.setRenderElement(params.layout.renderElement);
    params.scroller = new suiScroller();
    params.tracker = new suiTracker(params.layout,params.scroller);
    params.layout.setMeasureMapper(params.tracker);
    if (SmoConfig.editor) {
      params.editor = new suiEditor(params);
    }
    if (SmoConfig.menus) {
      params.menus = new suiMenuManager(params);
    }
    params.layoutDemon = new SuiLayoutDemon(params);
    var ctor = eval(SmoConfig.controller);
    var controller = new ctor(params);
    if (SmoConfig.menus) {
      params.menus.undoBuffer = controller.undoBuffer;
    }
    params.layout.score = score;
    eval(SmoConfig.domSource).splash();
    this.controller = controller;
  }

  static _nvQueryPair(str) {
    var ar = str.split('=');
    var rv = {};
    for (var i =  0;i < ar.length - 1;i += 2) {
      var name = decodeURIComponent(ar[i]);
      rv[name] = decodeURIComponent(ar[i+1]);
    }
    return rv;
  }
  start() {
    var score = null;
    for (var i = 0;i < SmoConfig.scoreLoadOrder.length; ++i) {
      var loader = SmoConfig.scoreLoadOrder[i];
      var method = loader+'ScoreLoad';
      var ss = this[method]();
      if (ss) {
        score = ss;
        break;
      }
    }
    var controller =this.createUi(score);
  }

  localScoreLoad() {
    var score = null;
    var scoreStr = localStorage.getItem(smoSerialize.localScore);
    if (scoreStr && scoreStr.length) {
      try {
        score = SmoScore.deserialize(scoreStr);
      } catch (exp) {
        console.log('could not parse '+scoreStr);
      }
    }
    return score;
  }

  queryScoreLoad() {
    var score = null;
    if (window.location.search) {
      var cmd = window.location.search.substring(1,window.location.search.length);
      var cmds = cmd.split('&');
      cmds.forEach((cmd) => {
        var pairs = SuiApplication._nvQueryPair(cmd);
        if (pairs['score']) {
          try {
            score = SmoScore.deserialize(eval(pairs['score']));
          } catch (exp) {
            console.log('could not parse '+exp);
          }
        } else if (pairs['lang']) {
          SuiApplication._deferLanguageSelection(pairs['lang']);
        } else if (pairs['translate']) {
          SuiApplication._deferCreateTranslator(pairs['translate']);
        }
      });
    }
    return score;
  }

  static _deferCreateTranslator(lang) {
    setTimeout(() => {
      var transDom =  SmoTranslationEditor.startEditor(lang);
    },1);
  }

  static _deferLanguageSelection(lang) {
    setTimeout(function() {
      SmoTranslator.setLanguage(lang);
    },1);
  }

  libraryScoreLoad() {
    if (typeof(SmoConfig.scoreLoadJson) != 'undefined') {
      return SmoScore.deserialize(eval(SmoConfig.scoreLoadJson));
    }
  }

}

//# sourceMappingURL=smoosic.js.map