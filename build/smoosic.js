
var smoDomBuilder = function (el) {}

// # htmlHelpers
// # Description:
//  Helper functions for buildling UI elements
class htmlHelpers {
	// ## buildDom
	// ## Description:
	// returns an object that  lets you build a DOM in a somewhat readable way.
	// ## Usage:
	// var b = htmlHelpers.buildDom;
	//  var r =
	// b('tr').classes('jsSharingMember').data('entitykey', key).data('name', name).data('entitytype', entityType).append(
	// b('td').classes('noSideBorderRight').append(
	// ...
	// $(parent).append(r.dom());
	//
	// Don't forget the '.dom()' !  That is the actual jquery element object
	static buildDom(el) {
		var smoDomBuilder = function (el) {
			this.e = $('<' + el + '/>');
			var self = this;
			this.classes = function (cl) {
				$(self.e).addClass(cl);
				return self;
			}
      this.html = function(value) {
        $(self.e).html(value);
        return self;
      }
			this.data = function (name, value) {
				$(self.e).attr('data-' + name, value);
				return self;
			}
			this.attr = function (name, value) {
				$(self.e).attr(name, value);
				return self;
			}
			this.css = function (name, value) {
				$(self.e).css(name, value);
				return self;
			}
			this.append = function (el) {
				$(self.e).append(el.e);
				return self;
			}
			this.text = function (tx) {
				$(self.e).append(document.createTextNode(tx));
				return self;
			}
			this.dom = function () {
				return self.e;
			}
			return this;
		}
		return new smoDomBuilder(el);
	}
	static draggable(parameters) {
		return new draggable(parameters);
	}

	static get focusableElements() {
		return ['a', 'input', 'select', 'textarea', 'button', 'li[tabindex]', 'div[tabindex]'];
	}
    static addFileLink(filename,txt,parent) {
        var anchor = $('<a></a>');
        var url = URL.createObjectURL(new Blob([txt],{type:'application/octet-stream'}));
        $(anchor).attr('href',url);
        $(anchor).attr('download',filename);
        $(anchor).text('save');
        $(parent).html('');
        $(parent).append(anchor);
    }

	static inputTrapper(selector) {
		var trapper = function () {
			this.parent = $(selector);
			this.id = $(this.parent).attr('id');
			this.parentId = $(this.parent).parent().attr('id');
			var idstr = Math.round(Math.random() * (999999 - 1) + 1);
			if (!this.id) {
				$(this.parent).attr('id', idstr + '-element');
				this.id = $(this.parent).attr('id');
			}
			if (!this.parentId) {
				$(this.parent).parent().attr('id', idstr + '-parent');
				this.parentId = $(this.parent).parent().attr('id');
			}
			this.modalInputs = [];
			this.disabledInputs = [];
			this.siblingInputs = [];

			// aria-hide peers of dialog and peers of parent that are not the parent.
			var peers = $(this.parent).parent().children().toArray();

			peers.forEach((node) => {
				var ptag = $(node)[0].tagName;
				if (ptag === 'SCRIPT' || ptag === 'LINK' || ptag === 'STYLE') { ;
				} else if ($(node).attr('id') === this.parentId ||
					$(node).attr('id') === this.id) { ;
				} else {
					var hidden = $(node).attr('aria-hidden');
					if (!hidden || hidden != 'true') {
						$(node).attr('aria-hidden', 'true');
						this.siblingInputs.push(node);
					}
				}
			});
			htmlHelpers.focusableElements.forEach((etype) => {
				var elements = $(etype).toArray();

				elements.forEach((element) => {
					var tagName = $(element)[0].tagName;
					if ($(element).attr('id') === this.id) { ;
					} else if ($(element).prop('disabled')) { ;
					} else if ($(element).hasClass('hide')) { ;
					} else if ($(element).closest(selector).length) {
						// inside
						this.modalInputs.push(element);
					} else if ((tagName === 'A' || tagName === 'DIV' || tagName === 'LI') && $(element).attr('tabIndex') === '-1') { ;
					} else {
						this.disabledInputs.push(element);
						if (tagName === 'A' || tagName === 'DIV' || tagName === 'LI') {
							$(element).attr('tabIndex', '-1');
						} else {
							$(element).prop('disabled', true);
						}
					}
				});
			});

			this.close = function () {
				this.disabledInputs.forEach(function (element) {
					var tagName = $(element)[0].tagName;
					if (tagName === 'A' || tagName === 'DIV' || tagName === 'LI') {
						$(element).attr('tabIndex', '0');
					} else {
						$(element).prop('disabled', false);
					}
				});
				this.siblingInputs.forEach((el) => {
					$(el).removeAttr('aria-hidden');
				});
			}
		}

		return new trapper(selector);
	}

	static closeDialogPromise() {
		return new Promise((resolve, reject) => {
			$('body').off('dialogDismiss').on('dialogDismiss', function () {
				resolve();
			});
		});
	}
}

class draggable {

	constructor(parameters) {
		this.parent = parameters.parent;
		this.handle = parameters.handle;
    this.animeClass = parameters.animateDiv;
    this.dragParent = parameters.dragParent;

    // TODO: make '.dom-container' a part of the configuration
    this.domOffset =  $('.dom-container').offset();

		this.svg=parameters['svg'];
		this.width = $(this.parent).outerWidth();
		this.height = $(this.parent).outerHeight();
		this.lastX = $(this.handle).offset().left - this.domOffset.left;
		this.lastY = $(this.handle).offset().top - this.domOffset.top;
		this.cb = parameters.cb;
		this.moveParent = parameters.moveParent;

		var self = this;

		// $('.itemMenu input[name="itemTitle"]').css('width','60%');
		$(this.handle)
		.off('mousedown').on('mousedown',
			function (e) {
			self.mousedown(e);
		});
		$(document)
		.on('mousemove',
			function (e) {
			self.mousemove(e);

		})
		.on('mouseup',
			function (e) {
			self.mouseup(e);
		});
	}
  disconnect() {
    $(this.handle).off('mousedown');
    $(this.document).off('mousemove');
    $(this.handle).off('mouseup');
  }
	_animate(e) {
		this.lastX = e.clientX;
		this.lastY = e.clientY;
		$(this.animeClass).css('left', this.lastX - this.domOffset.left);
		$(this.animeClass).css('top', this.lastY - this.domOffset.top);

    if (this.dragParent) {
      $(this.parent).css('left', this.lastX + 'px');
		  $(this.parent).css('top', this.lastY + 'px');
    }
	}
	mousedown(e) {
		if (!this.dragging) {
			$(this.animeClass).removeClass('hide');

			$(this.animeClass).css('width', this.width);
			$(this.animeClass).css('height', this.height);
		}

		this.dragging = true;
		this._animate(e);
	}
	enddrag(e) {
    this.lastX = this.lastX - this.domOffset.left;
    this.lastY = this.lastY - this.domOffset.top;
		if (this.moveParent) {
			$(this.parent).css('left', this.lastX + 'px');
			$(this.parent).css('top', this.lastY + 'px');
		}
		$(this.animeClass).addClass('hide');
		this.cb(this.lastX, this.lastY);
	}

	mouseup(e) {
		// stop resizing
		if (this.dragging) {
			this.dragging = false;
			this.lastX = e.clientX;
			this.lastY = e.clientY;

			this.enddrag();
		}
	}
	mousemove(e) {
		// we don't want to do anything if we aren't resizing.
		if (!this.dragging)
			return;
		this._animate(e);
	}
}
;// ## smoMusic
// Helper functions that build on the VX music theory routines, and other
// utilities I wish were in VF.Music but aren't
// ### Note on pitch and duration format
// We use some VEX music theory routines and frequently need to convert
// formats from SMO format.
//
// `Smo` uses pitch JSON:
// ``javascript``
//  {note:'c',accidental:'#',octave:4}
// `Vex` usually uses a canonical string:
//  'c#/4'
//  Depending on the operation, the octave might be omitted
//
// `Smo` uses a JSON for duration always:
// ``javascript``
// {numerator:4096,denominator:1,remainder:0}
//
// `VexFlow` uses a letter duration ('4' for 1/4 note) and 'd' for dot.
// I try to indicate whether I am using vex or smo notation
// Duration methods start around line 600
// ---
class smoMusic {
  // ### vexToCannonical
  // return Vex canonical note enharmonic - e.g. Bb to A#
  // Get the canonical form
  static vexToCannonical(vexKey) {
    vexKey = smoMusic.stripVexOctave(vexKey);
    return VF.Music.canonical_notes[VF.Music.noteValues[vexKey].int_val];
  }

  // ### circleOfFifths
  // A note array in key-signature order
  static get circleOfFifths() {
    return [{
        letter: 'c',
        accidental: 'n'
      }, {
        letter: 'g',
        accidental: 'n'
      }, {
        letter: 'd',
        accidental: 'n'
      }, {
        letter: 'a',
        accidental: 'n'
      }, {
        letter: 'e',
        accidental: 'n'
      }, {
        letter: 'b',
        accidental: 'n'
      }, {
        letter: 'f',
        accidental: '#'
      }, {
        letter: 'c',
        accidental: '#'
      }, {
        letter: 'a',
        accidental: 'b'
      }, {
        letter: 'e',
        accidental: 'b'
      }, {
        letter: 'b',
        accidental: 'b'
      }, {
        letter: 'f',
        accidental: 'n'
      }
    ];
  }

  // ### circleOfFifthsIndex
  // gives the index into circle-of-fifths array for a pitch, considering enharmonics.
  static circleOfFifthsIndex(smoPitch) {
    const en1 = smoMusic.vexToSmoKey(smoMusic.getEnharmonic(smoMusic.pitchToVexKey(smoPitch)));
    const en2 = smoMusic.vexToSmoKey(smoMusic.getEnharmonic(smoMusic.getEnharmonic(smoMusic.pitchToVexKey(smoPitch))));
    const ix = smoMusic.circleOfFifths.findIndex((el) =>
        (el.letter === smoPitch.letter && el.accidental === smoPitch.accidental) ||
        (el.letter === en1.letter && el.accidental === en1.accidental) ||
        (el.letter === en2.letter && el.accidental === en2.accidental)
      );
    return ix;
  }

  // ### addSharp
  // Get pitch to the right in circle of fifths
  static addSharp(smoPitch) {
    let rv = smoMusic.circleOfFifths[
      (smoMusic.circleOfFifthsIndex(smoPitch) + 1) % smoMusic.circleOfFifths.length];
    rv = JSON.parse(JSON.stringify(rv));
    rv.octave = smoPitch.octave;
    return rv;
  }

  // ### addFlat
  // Get pitch to the left in circle of fifths
  static addFlat(smoPitch) {
    let rv = smoMusic.circleOfFifths[
        ((smoMusic.circleOfFifths.length - 1) + smoMusic.circleOfFifthsIndex(smoPitch)) % smoMusic.circleOfFifths.length];
    rv = JSON.parse(JSON.stringify(rv));
    rv.octave = smoPitch.octave;
    return rv;
  }

  // ### addSharps
  // Add *distance* sharps/flats to given key
  static addSharps(smoPitch, distance) {
    let i = 0;
    let rv = {};
    if (distance === 0) {
      return JSON.parse(JSON.stringify(smoPitch));
    }
    rv = smoMusic.addSharp(smoPitch);
    for (i = 1; i < distance; ++i) {
      rv = smoMusic.addSharp(rv);
    }
    const octaveAdj = smoMusic.letterPitchIndex[smoPitch.letter] > smoMusic.letterPitchIndex[rv.letter] ? 1 : 0;
    rv.octave += octaveAdj;
    return rv;
  }

  // ### addFlats
  // Add *distance* sharps/flats to given key
  static addFlats(smoPitch, distance) {
    let i = 0;
    let rv = {};
    if (distance === 0) {
      return JSON.parse(JSON.stringify(smoPitch));
    }
    rv = smoMusic.addFlat(smoPitch);
    for (i = 1; i < distance; ++i) {
      rv = smoMusic.addFlat(rv);
    }
    const octaveAdj = smoMusic.letterPitchIndex[smoPitch.letter] > smoMusic.letterPitchIndex[rv.letter] ? 1 : 0;
    rv.octave += octaveAdj;
    return rv;
  }

  // ### smoPitchesToVexKeys
  // Transpose and convert from SMO to VEX format so we can use the VexFlow tables and methods
  static smoPitchesToVexKeys(pitchAr, keyOffset, noteHead) {
    const noopFunc = keyOffset > 0 ? 'addSharps' : 'addFlats';

    const rv = [];
    pitchAr.forEach((pitch) => {
      rv.push(smoMusic.pitchToVexKey(smoMusic[noopFunc](pitch, keyOffset), noteHead));
    });
    return rv;
  }

  static get scaleIntervals() {
    return {
      up: [2, 2, 1, 2, 2, 2, 1],
      down: [1, 2, 2, 2, 1, 2, 2]
    };
  }

  // ### smoScalePitchMatch
  // return true if the pitches match, but maybe not in same octave
  static smoScalePitchMatch(p1, p2) {
    const pp1 = JSON.parse(JSON.stringify(p1));
    const pp2 = JSON.parse(JSON.stringify(p2));
    pp1.octave = 0;
    pp2.octave = 0;

    return smoMusic.smoPitchToInt(pp1) === smoMusic.smoPitchToInt(pp2);
  }

  // ### pitchToLedgerLineInt
  static pitchToLedgerLine(clef, pitch) {
    // return the distance from the top ledger line, as 0.5 per line/space
    return -1.0 * (VF.keyProperties(smoMusic.pitchToVexKey(pitch, clef)).line - 4.5)
     - VF.clefProperties.values[clef].line_shift;
  }
  // ### flagStateFromNote
  // return hard-coded flag state, or flag state as based on pitch and clef
  static flagStateFromNote(clef, note) {
    let fs = note.flagState;
    if (fs ===  SmoNote.flagStates.auto) {
      fs = smoMusic.pitchToLedgerLine(clef, note.pitches[0])
        >= 2 ? SmoNote.flagStates.up : SmoNote.flagStates.down;
    }
    return fs;
  }

  // ### pitchToVexKey
  // convert from SMO to VEX format so we can use the VexFlow tables and methods
  // example:
  //   `{letter,octave,accidental}` object to vexKey string `'f#'`
  static _pitchToVexKey(smoPitch) {
    // Convert to vex keys, where f# is a string like 'f#'.
    let vexKey = smoPitch.letter.toLowerCase();
    if (smoPitch.accidental.length === 0) {
      vexKey = vexKey + 'n';
    } else {
      vexKey = vexKey + smoPitch.accidental;
    }
    if (smoPitch.octave) {
      vexKey = vexKey + '/' + smoPitch.octave;
    }
    return vexKey;
  }

  static pitchToEasyScore(smoPitch) {
    let vexKey = smoPitch.letter.toLowerCase();
    if (smoPitch.accidental.length === 0) {
      vexKey = vexKey + 'n';
    } else {
      vexKey = vexKey + smoPitch.accidental;
    }
    return vexKey + smoPitch.octave;
  }

  static pitchToVexKey(smoPitch, head) {
    if (!head) {
      return smoMusic._pitchToVexKey(smoPitch);
    }
    return smoMusic._pitchToVexKey(smoPitch) + '/' + head;
  }

  static smoPitchToInt(pitch) {
    if (typeof(pitch.octave) === 'undefined') {
      pitch.octave = 0;
    }
    var intVal = VF.Music.noteValues[
        smoMusic.stripVexOctave(smoMusic.pitchToVexKey(pitch))].int_val;
    var octave =  (pitch.letter === 'c' && pitch.accidental === 'b' && pitch.octave > 0) ?
       pitch.octave - 1 : pitch.octave;
    return octave * 12 + intVal;
  }

  static smoIntToPitch(intValue) {
    let octave = 0;
    let accidental = '';
    let noteKey = '';
    const letterInt = intValue >= 0 ? intValue % 12 :
       12 - (Math.abs(intValue) % 12);
    noteKey = Object.keys(VF.Music.noteValues).find((key) =>
        VF.Music.noteValues[key].int_val === letterInt && key.length === 1
      );
    if (!noteKey) {
      noteKey = Object.keys(VF.Music.noteValues).find((key) =>
          VF.Music.noteValues[key].int_val === letterInt && key.length === 2
        );
    }
    octave = Math.floor(intValue / 12);
    octave = octave >= 0 ? octave : 0;
    accidental = noteKey.substring(1, noteKey.length);
    accidental = accidental ? accidental : 'n';
    return {
      letter: noteKey[0],
      accidental: accidental,
      octave: octave
    };
  }

  // ### vexKeySigWithOffset
  // Consider instrument transpose when setting key -
  // e.g. Eb for Bb instruments is F.
  static vexKeySigWithOffset(vexKey, offset) {
    let newKey = smoMusic.pitchToVexKey(smoMusic.smoIntToPitch(
      smoMusic.smoPitchToInt(
        smoMusic.vexToSmoKey(vexKey)) + offset));
    newKey = smoMusic.toValidKeySignature(newKey);
    return newKey;
  }

  // ### get enharmonics
  // return a map of enharmonics for choosing or cycling.  notes are in vexKey form.
  static get enharmonics() {
    let i = 0;
    const rv = {};
    const keys = Object.keys(VF.Music.noteValues);
    for (i = 0; i < keys.length; ++i) {
      const key = keys[i];
      const int_val = VF.Music.noteValues[key].int_val;
      if (typeof(rv[int_val.toString()]) == 'undefined') {
        rv[int_val.toString()] = [];
      }
      // only consider natural note 1 time.  It is in the list twice for some reason.
      if (key.indexOf('n') === -1) {
        rv[int_val.toString()].push(key);
      }
    }
    return rv;
  }

  static getEnharmonics(vexKey) {
    const proto = smoMusic.stripVexOctave(vexKey);
    const rv = [];
    let ne = smoMusic.getEnharmonic(vexKey);
    rv.push(proto);
    while (ne[0] !== proto[0]) {
      rv.push(ne);
      ne = smoMusic.getEnharmonic(ne);
    }
    return rv;
  }

  // ### getEnharmonic(noteProp)
  // cycle through the enharmonics for a note.
  static getEnharmonic(vexKey) {
    vexKey = smoMusic.stripVexOctave(vexKey);
    const intVal = VF.Music.noteValues[vexKey.toLowerCase()].int_val;
    const ar = smoMusic.enharmonics[intVal.toString()];
    const len = ar.length;
    // 'n' for natural in key but not in value
    vexKey = vexKey.length > 1 && vexKey[1] === 'n' ? vexKey[0] : vexKey;
    const ix = ar.indexOf(vexKey);
    vexKey = ar[(ix + 1) % len];
    return vexKey;
  }

  // ### getKeyFriendlyEnharmonic
  // fix the enharmonic to match the key, if possible
  // `getKeyFriendlyEnharmonic('b','eb');  => returns 'bb'
  static getKeyFriendlyEnharmonic(letter, keySignature) {
    var rv = letter;
    var muse = new VF.Music();
    var scale = Object.values(muse.createScaleMap(keySignature));
    var prop = smoMusic.getEnharmonic(letter.toLowerCase());
    while (prop.toLowerCase() != letter.toLowerCase()) {
      for (var i = 0; i < scale.length; ++i) {
        var skey = scale[i];
        if ((skey[0] == prop && skey[1] == 'n') ||
          (skey.toLowerCase() == prop.toLowerCase())) {
          rv = skey;
          break;
        }
      }
      prop = (prop[1] == 'n' ? prop[0] : prop);
      prop = smoMusic.getEnharmonic(prop);
    }
    return rv;
  }
  static closestTonic(smoPitch, vexKey, direction) {
    direction = Math.sign(direction) < 0 ? -1 : 1;
    var tonic = smoMusic.vexToSmoKey(vexKey);
    tonic.octave=smoPitch.octave;
    var iix = smoMusic.smoPitchToInt(smoPitch);
    var smint=smoMusic.smoPitchToInt(tonic);
    if (Math.sign(smint - iix) != direction) {
      tonic.octave += direction
    }
    return tonic;
  }

  // ### toValidKeySignature
  // When transposing, make sure key signature is valid, e.g. g# should be
  // Ab
  static toValidKeySignature(vexKey) {
    let strlen = 0;
    var map = {'a#':'bb','g#':'ab','cb':'b','d#':'eb'}
    if (map[vexKey.toLowerCase()]) {
      return map[vexKey.toLowerCase()];
    }
    strlen = (vexKey.length > 2 ? 2 : vexKey.length);
    // Vex doesn't like 'n' in key signatures.
    if (strlen === 2 && vexKey[1].toLowerCase() === 'n') {
      strlen = 1;
    }
    return vexKey.substr(0, strlen);
  }

// ### getEnharmonicInKey
// Get the enharmonic equivalent that most closely matches
// a given key
  static getEnharmonicInKey(smoPitch, keySignature) {
    if (typeof(smoPitch.octave) === 'undefined') {
      smoPitch.octave = 1;
    }
    var sharpKey = keySignature.indexOf('#') >= 0 ? true : false;
    var flatKey = keySignature.indexOf('b') >= 0 ? true : false;
    var ar = smoMusic.getEnharmonics(smoMusic.pitchToVexKey(smoPitch));
    var rv = smoMusic.stripVexOctave(smoMusic.pitchToVexKey(smoPitch));
    var scaleMap = new VF.Music().createScaleMap(keySignature);
    var match = false;
    ar.forEach((vexKey) => {
      if (vexKey.length === 1) {
        vexKey += 'n';
      }
      if (vexKey === scaleMap[vexKey[0]]) {
        rv = vexKey;
        match = true;
      } else if (!match) {
        // In the absence of a match of a key tone, we bias towards more
        // 'common', like Bb is more common than A#, esp. as a chord.  This maybe
        // just be my horn player bias towards flat keys
        if (vexKey === 'a#' && !sharpKey) {
          rv = 'bb';
        } else if (vexKey === 'g#' && !sharpKey) {
          rv = 'ab';
        } else if (vexKey === 'c#' && !sharpKey) {
          rv = 'db';
        } else if (vexKey === 'd#' && !sharpKey) {
          rv = 'eb';
        } else if (vexKey === 'f#' && flatKey) {
          rv = 'gb';
        }
      }
    });
    var smoRv = smoMusic.vexToSmoKey(rv);
    smoRv.octave = smoPitch.octave;
    var rvi = smoMusic.smoPitchToInt(smoRv);
    var ori = smoMusic.smoPitchToInt(smoPitch);
    // handle the case of c0 < b0, pitch-wise
    smoRv.octave += Math.sign(ori - rvi);
    return smoRv;
  }

  // ### getIntervalInKey
  // give a pitch and a key signature, return another pitch at the given
  // diatonic interval.  Similar to getKeyOffset but diatonic.
  static getIntervalInKey(pitch, keySignature, interval) {
    if (interval === 0)
      return JSON.parse(JSON.stringify(pitch));

    var delta = interval > 0 ? 1 : -1;
    var inv = -1 * delta;
    var tonic = smoMusic.closestTonic(pitch, keySignature, inv);
    var intervals = delta > 0 ? smoMusic.scaleIntervals.up : smoMusic.scaleIntervals.down;
    var pitchInt = smoMusic.smoPitchToInt(pitch);
    var scaleIx = 0;
    var diatonicIx=0;

    var nkey = tonic;
    var nkeyInt = smoMusic.smoPitchToInt(nkey);
    while (Math.sign(nkeyInt - pitchInt) != delta && Math.sign(nkeyInt - pitchInt) != 0) {
      nkey = smoMusic.smoIntToPitch(smoMusic.smoPitchToInt(nkey) + delta * intervals[scaleIx]);
      scaleIx = (scaleIx + 1) % 7;
      nkeyInt = smoMusic.smoPitchToInt(nkey);
    }
    while (diatonicIx != interval) {
      nkey = smoMusic.smoIntToPitch(smoMusic.smoPitchToInt(nkey) + delta * intervals[scaleIx]);
      scaleIx = (scaleIx + 1) % 7;
      diatonicIx += delta;
    }
    return smoMusic.getEnharmonicInKey(nkey,keySignature);
  }

  static getLetterNotePitch(prevPitch, letter, key) {
    const pitch = JSON.parse(JSON.stringify(prevPitch));
    pitch.letter = letter;

    // Make the key 'a' make 'Ab' in the key of Eb, for instance
    const vexKsKey = smoMusic.getKeySignatureKey(letter, key);
    if (vexKsKey.length > 1) {
        pitch.accidental = vexKsKey[1];
    } else {
        pitch.accidental = 'n';
    }

    // make the octave of the new note as close to previous (or next) note as possible.
    const upv = ['bc', 'ac', 'bd', 'da', 'be', 'gc'];
    const downv = ['cb', 'ca', 'db', 'da', 'eb', 'cg'];
    const delta = prevPitch.letter + pitch.letter;
    if (upv.indexOf(delta) >= 0) {
        pitch.octave += 1;
    }
    if (downv.indexOf(delta) >= 0) {
      pitch.octave -= 1;
    }
    return pitch;
  }
  static vexKeySignatureTranspose(key, transposeIndex) {
    var key = smoMusic.vexToSmoKey(key);
    key = smoMusic.smoPitchesToVexKeys([key], transposeIndex)[0];
    key = smoMusic.stripVexOctave(key);
    key = key[0].toUpperCase() + key.substring(1, key.length);
    if (key.length > 1 && key[1] === 'n') {
      key = key[0];
    }
    return key;
  }
    static get frequencyMap() {
        return suiAudioPitch.pitchFrequencyMap;
    }

  // ### get letterPitchIndex
  // Used to adjust octave when transposing.
  // Pitches are measured from c, so that b0 is higher than c0, c1 is 1 note higher etc.
  static get letterPitchIndex() {
    return {
      'c': 0,
      'd': 1,
      'e': 2,
      'f': 3,
      'g': 4,
      'a': 5,
      'b': 6
    };
  }

  // ### letterChangedOctave
  // Indicate if a change from letter note 'one' to 'two' needs us to adjust the
  // octave due to the `smoMusic.letterPitchIndex` (b0 is higher than c0)
  static letterChangedOctave(one, two) {
    var p1 = smoMusic.letterPitchIndex[one];
    var p2 = smoMusic.letterPitchIndex[two];
    if (p1 < p2 && p2 - p1 > 2)
      return -1;
    if (p1 > p2 && p1 - p2 > 2)
      return 1;
    return 0;

  }

  static vexToSmoPitch(vexPitch) {
    let octave = 0;
    const po = vexPitch.split('/');
    const rv = smoMusic.vexToSmoKey(po[0]);
    if (po.length > 1) {
      octave = parseInt(po[1], 10);
      octave = isNaN(octave) ? 4 : octave;
    } else {
      octave = 4;
    }
    rv.octave = octave;
    return rv;
  }

  // ### vexToSmoKey
  // Convert to smo pitch, without octave
  // ``['f#'] => [{letter:'f',accidental:'#'}]``
  static vexToSmoKey(vexPitch) {
    var accidental = vexPitch.length < 2 ? 'n' : vexPitch.substring(1, vexPitch.length);
    var pp = vexPitch.split('/')[0];
    return {
      letter: pp[0].toLowerCase(),
      accidental: accidental
    };
  }

  // ### smoPitchToVes
  // {letter:'f',accidental:'#'} => [f#/
  static smoPitchesToVex(pitchAr) {
    var rv = [];
    pitchAr.forEach((p) => {
      rv.push(smoMusic.pitchToVexKey(p));
    });
    return rv;
  }

  static stripVexOctave(vexKey) {
    if (vexKey.indexOf('/') > 0) {
      vexKey = vexKey.substring(0, vexKey.indexOf('/'))
    }
    return vexKey;
  }


  // ### getKeyOffset
  // Given a vex noteProp and an offset, offset that number
  // of 1/2 steps.
  // #### Input:  smoPitch
  // #### Output:  smoPitch offset, not key-adjusted.
  static getKeyOffset(pitch, offset) {
    var canon = VF.Music.canonical_notes;

    // Convert to vex keys, where f# is a string like 'f#'.
    var vexKey = smoMusic.pitchToVexKey(pitch);
    vexKey = smoMusic.vexToCannonical(vexKey);
    var rootIndex = canon.indexOf(vexKey);
    var index = (rootIndex + canon.length + offset) % canon.length;
    var octave = pitch.octave;
    if (Math.abs(offset) >= 12) {
      var octaveOffset = Math.sign(offset) * Math.floor(Math.abs(offset) / 12);
      octave += octaveOffset;
      offset = offset % 12;
    }
    if (rootIndex + offset >= canon.length) {
      octave += 1;
    }
    if (rootIndex + offset < 0) {
      octave -= 1;
    }
    var rv = JSON.parse(JSON.stringify(pitch));
    vexKey = canon[index];
    if (vexKey.length > 1) {
      rv.accidental = vexKey.substring(1);
      vexKey = vexKey[0];
    } else {
      rv.accidental = '';
    }
    rv.letter = vexKey;
    rv.octave = octave;
    return rv;
  }

  // ### keySignatureLength
  // return the number of sharp/flat in a key signature for sizing guess.
  static get keySignatureLength() {
    return {
      'C': 0,
      'B': 5,
      'A': 3,
      'F#': 6,
      'Bb': 2,
      'Ab': 4,
      'Gg': 6,
      'G': 1,
      'F': 1,
      'Eb': 3,
      'Db': 5,
      'Cb': 7,
      'C#': 7,
      'F#': 6,
      'E': 4,
      'D': 2
    };
  }

  static getSharpsInKeySignature(key) {
    var sharpKeys = ['B','G','D','A','E','B','F#','C#'];
    if (sharpKeys.indexOf(key) < 0) {
      return 0;
    }
    return smoMusic.keySignatureLength[key];
  }

  static getFlatsInKeySignature(key) {
    var flatKeys = ['F','Bb','Eb','Ab','Db','Gb','Cb'];
    if (flatKeys.indexOf(key) < 0) {
      return 0;
    }
    return smoMusic.keySignatureLength[key];
  }

  static timeSignatureToTicks(timeSignature) {
    var nd = timeSignature.split('/');
    var num = parseInt(nd[0]);
    var den = parseInt(nd[1]);
    var base = 2048 * (8 / den);
    return base*num;
  }
  static smoTicksToVexDots(ticks) {
    var vd = smoMusic.ticksToDuration[ticks];
    var dots = (vd.match(/d/g) || []).length;
    return dots;
  }
  // ## closestVexDuration
  // ## Description:
  // return the closest vex duration >= to the actual number of ticks. Used in beaming
  // triplets which have fewer ticks then their stem would normally indicate.
  static closestVexDuration(ticks) {
    var stemTicks = VF.RESOLUTION;

    // The stem value is the type on the non-tuplet note, e.g. 1/8 note
    // for a triplet.
    while (ticks <= stemTicks) {
      stemTicks = stemTicks / 2;
    }

    stemTicks = stemTicks * 2;
    return smoMusic.ticksToDuration[stemTicks];
    var ix = Object.keys(smoMusic.ticksToDuration).findIndex((x) => {
        return x >= ticks
      });
    return smoMusic.ticksToDuration[durations[ix]];
  }

  // ### closestDurationTickLtEq
  // Price is right style, closest tick value without going over.  Used to pad
  // rests when reading musicXML.
  static closestDurationTickLtEq(ticks) {
    const sorted = Object.keys(smoMusic.ticksToDuration)
      .map((key) => parseInt(key, 10))
        .filter((key) => key <= ticks);
    return sorted[sorted.length - 1];
  }

  static splitIntoValidDurations(ticks) {
    const rv = [];
    let closest = 0;
    while (ticks > 128) {
      closest = smoMusic.closestDurationTickLtEq(ticks);
      ticks -= closest;
      rv.push(closest);
    }
    return rv;
  }
  // ### vexStemType
  // return the vex stem type (no dots)
  static vexStemType(ticks) {
    const str = smoMusic.ticksToDuration[smoMusic.splitIntoValidDurations(ticks)[0]];
    if (str.indexOf('d') >= 0) {
      return str.substr(0,str.indexOf('d'));
    }
    return str;
  }

  // ### getKeySignatureKey
  // given a letter pitch (a,b,c etc.), and a key signature, return the actual note
  // that you get without accidentals
  // ### Usage:
  //   smoMusic.getKeySignatureKey('F','G'); // returns f#
  static getKeySignatureKey(letter, keySignature) {
    var km = new VF.KeyManager(keySignature);
    return km.scaleMap[letter];
  }

  static getAccidentalForKeySignature(smoPitch, keySignature) {
      var vexKey = smoMusic.getKeySignatureKey(smoPitch.letter,keySignature);
      return vexKey.length == 1 ? 'n' : vexKey.substr(1,vexKey.length - 1);
  }

    // ### isPitchInKeySignature
    // Return true if the pitch is not an accidental in the give key, e.g.
    // f# in 'g' or c in 'Bb'
    static isPitchInKeySignature(smoPitch,keySignature) {
        var vexKey = smoMusic.getKeySignatureKey(smoPitch.letter,keySignature);
        return (vexKey.length == 1 && smoPitch.accidental == 'n' ||
            (vexKey[1]==smoPitch.accidental));
    }

  // ### Description:
  // Get ticks for this note with an added dot.  Return
  // identity if that is not a supported value.
  static getNextDottedLevel(ticks) {
    var ttd = smoMusic.ticksToDuration;
    var vals = Object.values(ttd);

    var ix = vals.indexOf(ttd[ticks]);
    if (ix >= 0 && ix < vals.length && vals[ix][0] == vals[ix + 1][0]) {
      return smoMusic.durationToTicks(vals[ix + 1]);
    }
    return ticks;
  }

  // ### Description:
  // Get ticks for this note with one fewer dot.  Return
  // identity if that is not a supported value.
  static getPreviousDottedLevel(ticks) {
    var ttd = smoMusic.ticksToDuration;
    var vals = Object.values(ttd);
    var ix = vals.indexOf(ttd[ticks]);
    if (ix > 0 && vals[ix][0] == vals[ix - 1][0]) {
      return smoMusic.durationToTicks(vals[ix - 1]);
    }
    return ticks;
  }


  // ### ticksToDuration
  // Frequently we double/halve a note duration, and we want to find the vex tick duration that goes with that.
  static get ticksToDuration() {
    var durations = ["1/2", "1", "2", "4", "8", "16", "32", "64", "128", "256"];
    smoMusic._ticksToDuration = smoMusic['_ticksToDuration'] ? smoMusic._ticksToDuration : null;
    var _ticksToDurationsF = function () {
            var ticksToDuration = smoMusic._ticksToDuration = {};
      for (var i = 0; i < durations.length - 1; ++i) {
        var dots = '';
        var ticks = 0;

        // We support up to 4 'dots'
        for (var j = 0; j <= 4 && j + i < durations.length; ++j) {
          ticks += VF.durationToTicks.durations[durations[i + j]];
          ticksToDuration[ticks.toString()] = durations[i] + dots;
          dots += 'd'
        }
      }
      return ticksToDuration;
    }
        if (!smoMusic._ticksToDuration) {
       _ticksToDurationsF();
        }
    return smoMusic._ticksToDuration;
  };

  // ### durationToTicks
  // Uses VF.durationToTicks, but handles dots.
  static durationToTicks(duration) {
    var dots = duration.indexOf('d');
    if (dots < 0) {
      return VF.durationToTicks(duration);
    } else {
      var vfDuration = VF.durationToTicks(duration.substring(0, dots));
      dots = duration.length - dots; // number of dots
      var split = vfDuration / 2;
      for (var i = 0; i < dots; ++i) {
        vfDuration += split;
        split = split / 2;
      }

      return vfDuration;
    }
  }


  static gcdMap(duration) {
    var keys = Object.keys(smoMusic.ticksToDuration).map((x) => parseInt(x));
    var dar = [];
    var gcd = function(td) {
        var rv = keys[0];
        for (var k = 1 ;k < keys.length; ++k) {
            if (td % keys[k] === 0) {
                rv = keys[k];
            }
        }
        return rv;
    }
    while (duration > 0 && !smoMusic.ticksToDuration[duration]) {
        var div = gcd(duration);
        duration = duration - div;
        dar.push(div);
    }
    if (duration > 0) {
        dar.push(duration);
    }
    return dar.sort((a,b) => a > b ? -1 : 1);
  }
}
;
class PromiseHelpers {
  // ### makePromise
  // poll on endCondition at a rate of pollTime.  Resolve the promise
  // when endCondition is met, calling preResolveMethod first.   On
  // polls where the end condition is not met, call pollMethod
  // Resolve method and pollMethod are optional
  static makePromise(instance, endCondition, preResolveMethod, pollMethod, pollTime) {
    return new Promise((resolve) => {
      var checkit = () => {
        setTimeout(() => {
          if (instance[endCondition]) {
            if (preResolveMethod) {
              instance[preResolveMethod]();
            }
            resolve();
          }
          else {
            if (pollMethod) {
              instance[pollMethod]();
            }
            checkit();
          }
        }, pollTime);
      }
      checkit();
    });
  }

  static makePromiseObj(instance, endCondition, preResolveMethod, pollMethod, pollTime) {
    return {
      instance: instance,
      endCondition: endCondition,
      preResolveMethod: preResolveMethod,
      pollMethod: pollMethod,
      pollTime: pollTime
    };
  }

  // ### afterPromise
  // Call a method after a promise is resolved that may
  // also return a promise
  static afterPromise(obj, promise, functionName) {
    const f = () => {
      obj[functionName]();
    }
    return promise.then(f);
  }
  // ### promiseChainThen
  // Call a chain of promises in array order, with parameters of makePromise
  static async promiseChainThen(promiseParameters) {
    const promiseArray = [];
    promiseParameters.forEach((promiseParameter) => {
      promiseArray.push(
        async () => {
          return PromiseHelpers.makePromise(
            promiseParameter.instance,
            promiseParameter.endCondition,
            promiseParameter.preResolveMethod,
            promiseParameter.pollMethod,
            promiseParameter.pollTime
          );
      });
    });

    let result;
    for (const f of promiseArray) {
      result = await f(result);
    }

		return result;
  }
  static renderPromise(renderer) {
    const renderPromise = () => {
      return new Promise((resolve) => {
        const checkit = () => {
          setTimeout(() => {
            if (renderer.passState === SuiRenderState.passStates.clean) {
              resolve();
            } else {
        	    checkit();
            }
          }, 500);
        }
        checkit();
      });
    }
  }
}
;// ## smoSerialize
// Helper functions that perform serialized merges, general JSON
// types of routines.
// ---
class smoSerialize {

  static tryParseUnicode(text) {
    let rv = text;
    try {
      eval('rv="' + text + '"');
    } catch (ex) {
      console.log('bad unicode');
    }
    return rv;
  }

  // ### filteredMerge
  // Like vexMerge, but only for specific attributes.
  static filteredMerge(attrs, src, dest) {
    attrs.forEach(function (attr) {
      if (typeof(src[attr]) != 'undefined') {
        dest[attr] = src[attr];
      }
    });
  }

    static get localScore() {
        return '_smoosicScore';
    }

  // This is the token map we use to reduce the size of
  // serialized data.
  static get tokenMap() {
   var _tm=`{
      "a": "score",
      "b": "layout",
      "c": "leftMargin",
      "d": "rightMargin",
      "e": "topMargin",
      "f": "bottomMargin",
      "g": "pageWidth",
      "h": "pageHeight",
      "i": "orientation",
      "j": "interGap",
      "k": "intraGap",
      "l": "svgScale",
      "m": "zoomScale",
      "n": "zoomMode",
      "o": "pages",
      "p": "pageSize",
      "q": "startIndex",
      "r": "renumberingMap",
      "s": "staves",
      "t": "staffId",
      "u": "staffX",
      "v": "staffY",
      "w": "adjY",
      "x": "staffWidth",
      "y": "staffHeight",
      "z": "keySignatureMap",
      "aa": "instrumentInfo",
      "ba": "instrumentName",
      "ca": "keyOffset",
      "da": "clef",
      "ea": "modifiers",
      "fa": "startSelector",
      "ga": "staff",
      "ha": "measure",
      "ia": "voice",
      "ja": "tick",
      "ka": "pitches",
      "la": "endSelector",
      "ma": "xOffset",
      "na": "cp1y",
      "oa": "cp2y",
      "pa": "attrs",
      "qa": "id",
      "ra": "type",
      "sa": "ctor",
      "ta": "yOffset",
      "ua": "position",
      "va": "measures",
      "wa": "timeSignature",
      "xa": "keySignature",
      "ya": "measureNumber",
      "za": "measureIndex",
      "ab": "systemIndex",
      "bb": "adjX",
      "cb": "tuplets",
      "db": "voices",
      "eb": "notes",
      "fb": "ticks",
      "gb": "numerator",
      "hb": "denominator",
      "ib": "remainder",
      "jb": "letter",
      "kb": "octave",
      "lb": "accidental",
      "mb": "symbol",
      "nb": "bpm",
      "ob": "display",
      "pb": "beatDuration",
      "qb": "beamBeats",
      "rb": "endBeam",
      "sb": "textModifiers",
      "tb": "text",
      "ub": "endChar",
      "vb": "fontInfo",
      "wb": "size",
      "xb": "family",
      "yb": "style",
      "zb": "weight",
      "ac": "classes",
      "bc": "verse",
      "cc": "fill",
      "dc": "scaleX",
      "ec": "scaleY",
      "fc": "translateX",
      "gc": "translateY",
      "hc": "selector",
      "ic": "renderedBox",
      "jc": "x",
      "kc": "y",
      "lc": "width",
      "mc": "height",
      "nc": "logicalBox",
      "oc": "noteType",
      "pc": "cautionary",
      "qc": "articulations",
      "rc": "articulation",
      "sc": "activeVoice",
      "tc": "flagState",
      "uc": "invert",
      "vc": "fontSize",
      "wc": "yOffsetLine",
      "xc": "yOffsetPixels",
      "yc": "scoreText",
      "zc": "backup",
      "ad": "edited",
      "bd": "pagination",
      "cd": "boxModel",
      "dd": "justification",
      "ed": "autoLayout",
      "fd": "ornaments",
      "gd": "offset",
      "hd": "ornament",
      "id": "tempoMode",
      "jd": "tempoText",
      "kd": "barline",
      "ld": "systemBreak",
      "md": "graceNotes",
      "nd": "tones",
      "od": "tuplet",
      "pd": "beam_group",
      "qd": "renderId",
      "rd": "numNotes",
      "sd": "totalTicks",
      "td": "stemTicks",
      "ud": "durationMap",
      "vd": "bracketed",
      "wd": "ratioed",
      "xd": "location",
      "yd": "systemGroups",
      "zd": "leftConnector",
      "ae": "padLeft",
      "be": "customStretch",
      "ce": "engravingFont",
      "de": "customProportion",
      "ee": "columnAttributeMap",
      "fe": "tempo",
      "ge": "textGroups",
      "he": "textBlocks",
      "ie": "backupBlocks",
      "je": "blocks",
      "ke": "_text",
      "le": "parser",
      "me": "fonts",
      "ne": "name",
      "oe": "purpose",
      "pe": "custom",
      "qe": "transposeIndex",
      "re": "noteHead",
      "se": "slash",
      "te": "pointSize",
      "ue": "spacing",
      "ve": "relativePosition",
      "we": "activeText",
      "xe": "attachToSelector",
      "ye": "musicXOffset",
      "ze": "musicYOffset",
      "af": "formattingIterations",
      "bf": "startBar",
      "cf": "endBar",
      "df": "endingId",
      "ef": "autoJustify",
      "ff": "thickness",
      "gf": "number",
      "hf": "preferences",
      "if": "autoPlay",
      "jf": "autoAdvance",
      "kf": "defaultDupleDuration",
      "lf": "defaultTripleDuration",
      "mf": "scoreInfo",
      "nf": "version",
      "of": "title",
      "pf": "subTitle",
      "qf": "composer",
      "rf": "copyright",
      "sf": "localIndex",
      "tf": "hairpinType",
      "uf": "customText",
      "vf": "noteSpacing",
      "wf": "lines",
      "xf": "from"
      }`;
     return JSON.parse(_tm);
    }

    static get valueTokens() {
      var vm = `{"@sn","SmoNote"}`;
      return JSON.parse(vm);
    }

    static reverseMap(map) {
      const rv = {};
      const keys = Object.keys(map);
      keys.forEach((key) => {
        rv[map[key]] = key;
      });
      return rv;
    }

  static get tokenValues() {
    return smoSerialize.reverseMap(smoSerialize.tokenMap);
  }

  // ## detokenize
  // If we are saving, replace token values with keys, since the keys are smaller.
  // if we are loading, replace the token keys with values so the score can
  // deserialize it
  static detokenize(json, dictionary) {
      const rv = {};
      const smoKey = (key) => {
        return typeof(dictionary[key]) !== 'undefined' ? dictionary[key] : key;
      }
      const _tokenRecurse = (input,output) =>  {
        const keys = Object.keys(input);
        keys.forEach((key) => {
          const val = input[key];
          const dkey = smoKey(key);
          if (typeof(val) == 'string' || typeof(val) == 'number' || typeof(val) == 'boolean') {
            output[dkey] = val;
            // console.log('240: output[' + dkey + '] = ' + val);
          }
          if (typeof(val) == 'object' && key != 'dictionary') {
            if (Array.isArray(val)) {
              output[dkey] = [];
              // console.log('245: processing array ' + dkey);
              val.forEach((arobj) => {
                if (typeof(arobj) === 'string' || typeof(arobj) === 'number' || typeof(arobj) === 'boolean') {
                  output[dkey].push(arobj);
                  // console.log('249: ar element ' + arobj);
                }
                else if (arobj && typeof(arobj) === 'object') {
                  const nobj = {};
                  _tokenRecurse(arobj,nobj);
                  output[dkey].push(nobj);
                }
              });
            } else {
              const nobj = {};
              // console.log('259: processing child object of ' + dkey);
              _tokenRecurse(val,nobj);
              output[dkey] = nobj;
            }
          }
        });
      }
      _tokenRecurse(json,rv);
      // console.log(JSON.stringify(rv,null,' '));
      return rv;
  }

  static incrementIdentifier(label) {
    const increcurse = (ar, ix) => {
      const n1 = (ar[ix].charCodeAt(0) - 97) + 1;
      if (n1 > 25) {
        ar[ix] = 'a';
        if (ar.length <= ix+1) {
          ar.push('a');
        } else {
          increcurse(ar,ix+1);
        }
      } else {
        ar[ix] = String.fromCharCode(97+n1);
      }
    }
    if (!label) {
      label = 'a';
    }
    const ar = label.split('');
    increcurse(ar,0);
    label = ar.join('');
    return label;
  }

  // used to generate a tokenization scheme that I will use to make
  // saved files smaller
  static jsonTokens(json) {
    const map = {};
    const valmap = {};
    const startKeys = Object.keys(smoSerialize.tokenMap);
    let keyLabel = startKeys[startKeys.length - 1];
    keyLabel = smoSerialize.incrementIdentifier(keyLabel);

    const exist = smoSerialize.tokenValues;
    const addMap = (key) => {
      if (!exist[key] && !map[key] && key.length > keyLabel.length) {
        map[key] = keyLabel;
        keyLabel = smoSerialize.incrementIdentifier(keyLabel);
      }
    };
    const _tokenRecurse = (obj) =>  {
      if (!obj) {
        console.warn('failure to parse');
        return;
      }
      const keys = Object.keys(obj);
      keys.forEach((key) => {
        const val = obj[key];
        if (typeof(val) === 'string' || typeof(val) === 'number'
         || typeof(val) === 'boolean') {
          addMap(key);
        }
        if (typeof(val) == 'object') {
          if (Array.isArray(val)) {
            addMap(key);
            val.forEach((arobj) => {
              if (arobj && typeof(arobj) === 'object') {
                _tokenRecurse(arobj);
              }
            });
          } else {
            addMap(key);
            _tokenRecurse(val);
          }
        }
      });
    }
    _tokenRecurse(json);
    const mkar = Object.keys(map);
    const m2 = {};
    mkar.forEach((mk) => {
      m2[map[mk]] = mk;
    })
    console.log(JSON.stringify(m2, null, ' '));
  }

  // ### serializedMerge
  // serialization-friendly, so merged, copied objects are deep-copied
  static serializedMerge(attrs, src, dest) {
    attrs.forEach(function (attr) {
      if (typeof(src[attr]) !== 'undefined') {
        // copy the number 0
        if (typeof(src[attr]) === 'number' ||
          typeof(src[attr]) === 'boolean' ||
          typeof(src[attr]) === 'string') {
          dest[attr] = src[attr];
          // copy the empty array
        } else if (Array.isArray(src[attr])) {
          dest[attr] = JSON.parse(JSON.stringify(src[attr]));
        } else {
          // but don't copy empty/null objects
          if (src[attr]) {
            if (typeof(src[attr]) == 'object') {
              dest[attr] = JSON.parse(JSON.stringify(src[attr]));
            } else {
              dest[attr] = src[attr];
            }
          }
        }
      }
    });
  }

  // ### serializedMergeNonDefault
  // Used to reduce size of serializations.  Create a serialzation of
  // the object, but don't serialize attributes that are already the default
  // since the default will be set when the object is deserialized
  // #### parameters:
  //     defaults - default Array
  //     attrs - array of attributes to save
  //     src - the object to serialize
  //     dest - the json object that is the target.
  static serializedMergeNonDefault(defaults,attrs,src,dest) {
    attrs.forEach(function (attr) {
      if (typeof(src[attr]) != 'undefined') {
        // copy the number 0
        if (typeof(src[attr]) === 'number' ||
          typeof(src[attr]) === 'boolean' ||
          typeof(src[attr]) === 'string' ) {
          if (src[attr] != defaults[attr]) {
            dest[attr] = src[attr];
          }
        // copy the empty array
        } else if (Array.isArray(src[attr])) {
          const defval = JSON.stringify(defaults[attr]);
          const srcval = JSON.stringify(src[attr]);
          if (defval != srcval) {
            dest[attr] = JSON.parse(srcval);
          }
        } else {
          // but don't copy empty/null objects
          if (src[attr]) {
            if (typeof(src[attr]) == 'object') {
              const defval = JSON.stringify(defaults[attr]);
              const srcval = JSON.stringify(src[attr]);
              if (defval != srcval) {
                dest[attr] = JSON.parse(srcval);
              }
            } else {
              if (src[attr] != defaults[attr]) {
                dest[attr] = src[attr];
              }
            }
          }
        }
      }
    });
  }

  static stringifyAttrs(attrs, obj) {
    let rv = '';
    attrs.forEach((attr) => {
      if (obj[attr]) {
        rv += attr + ':' + obj[attr] + ', ';
      } else {
        rv += attr + ': null,';
      }
    });
    return rv;
  }

  // ### printXlate
  // print json with string labels to use as a translation file seed.
  static printTranslate(_class) {
    const xxx = eval(_class + '.printTranslate');
    if (typeof(xxx) === 'function') {
      xxx();
    }
  }
}
;

// ## svgHelpers
// Mostly utilities for converting coordinate spaces based on transforms, etc.
// ### static class methods:
// ---
class svgHelpers {


  static get namespace() {
    return "http://www.w3.org/2000/svg";
  }

  // ### gradient
  // Create an svg linear gradient.
  // Stops look like this:
  // `[{color:"#eee", offset:"0%",opacity:0.5}]`
  // orientation is horizontal or vertical
  static gradient(svg,id,orientation,stops) {
    var ns = svgHelpers.namespace;
    var x2 = orientation === 'vertical' ? 0 : 1;
    var y2 = orientation === 'vertical' ? 1 : 0;

    var e = document.createElementNS(ns, 'linearGradient');
    e.setAttributeNS('','id',id);
    e.setAttributeNS('','x1',0);
    e.setAttributeNS('','x2',x2);
    e.setAttributeNS('','y1',0);
    e.setAttributeNS('','y2',y2);
    stops.forEach((stop) => {
      var s = document.createElementNS(ns, 'stop');
      var opacity = stop.opacity ? 1 : stop.opacity;
      s.setAttributeNS('','stop-opacity',opacity);
      s.setAttributeNS('','stop-color',stop.color);
      s.setAttributeNS('','offset',stop.offset);
      e.appendChild(s);

    });
    svg.appendChild(e);
  }

  static renderCursor(svg,x,y,height) {
    var ns = svgHelpers.namespace;
    const width = height * 0.4;
    x = x - (width / 2);
    var mcmd = (d,x,y) => {
      return d + 'M '+x+' '+y+' ';
    };
    var qcmd = (d,x1,y1,x2,y2) => {
      return d + 'q ' + x1 + ' ' + y1 + ' ' + x2 + ' ' + y2 + ' ';
    };
    var lcmd = (d,x,y) => {
      return d + 'L ' + x + ' ' + y + ' ';
    };
    var x1 = (width / 2) * .333;
    var y1 = -1*(x1 / 4);
    var x2 = (width / 2);
    var y2 = x2 / 4;
    var ns = svgHelpers.namespace;
    var e = document.createElementNS(ns, 'path');
    var d = '';
    d = mcmd(d,x,y);
    d = qcmd(d,x1,y1,x2,y2);
    d = lcmd(d,x + (width / 2),y + height - (width / 8));
    d = mcmd(d,x+width,y);
    d = qcmd(d,-1*x1,y1,-1*x2,y2);
    d = mcmd(d,x,y + height);
    d = qcmd(d,x1,-1*y1,x2,-1*y2);
    d = mcmd(d,x+width,y + height);
    d = qcmd(d,-1*x1, -1 * y1, -1 * x2, -1 * y2);
    e.setAttributeNS('','d',d);
    e.setAttributeNS('','stroke-width','1');
    e.setAttributeNS('','stroke','#555');
    e.setAttributeNS('','fill','none');
    svg.appendChild(e);
  }

  static buildSvg(el) {

    var smoSvgBuilder = function (el) {
      var ns = svgHelpers.namespace;
      this.e = document.createElementNS(ns, el);
      var self = this;
      this.classes = function (cl) {
        self.e.setAttributeNS('', 'class', cl);
        return self;
      }
      this.attr = function (name, value) {
        self.e.setAttributeNS('', name, value);
        return self;
      }

      this.text = function (x, y, classes, text) {
        x = typeof(x) == 'string' ? x : x.toString();
        y = typeof(y) == 'string' ? y : y.toString();
        this.e.setAttributeNS('', 'class', classes);
        this.e.setAttributeNS('', 'x', x);
        this.e.setAttributeNS('', 'y', y);

        this.e.textContent = text;
        return this;
      }
      this.rect = function (x, y, width, height, classes) {
        x = typeof(x) == 'string' ? x : x.toString();
        y = typeof(y) == 'string' ? y : y.toString();
        width = typeof(width) == 'string' ? width : width.toString();
        height = typeof(height) == 'string' ? height : height.toString();
        this.e.setAttributeNS('', 'x', x);
        this.e.setAttributeNS('', 'y', y);
        this.e.setAttributeNS('', 'width', width);
        this.e.setAttributeNS('', 'height', height);
        if (classes) {
          this.e.setAttributeNS('', 'class', classes);
        }
        return this;
      }
      this.line = function (x1, y1, x2, y2, classes) {
        x1 = typeof(x1) == 'string' ? x1 : x1.toString();
        y1 = typeof(y1) == 'string' ? y1 : y1.toString();
        x2 = typeof(x2) == 'string' ? x2 : x2.toString();
        y2 = typeof(y2) == 'string' ? y2 : y2.toString();

        this.e.setAttributeNS('', 'x1', x1);
        this.e.setAttributeNS('', 'y1', y1);
        this.e.setAttributeNS('', 'x2', x2);
        this.e.setAttributeNS('', 'y2', y2);
        if (classes) {
          this.e.setAttributeNS('', 'class', classes);
        }
        return this;
      }
      this.append = function (el) {
        self.e.appendChild(el.e);
        return self;
      }
      this.dom = function () {
        return self.e;
      }
      return this;
    }
    return new smoSvgBuilder(el);
  }

  // ### boxNote
  // update the note geometry based on current viewbox conditions.
  // This may not be the appropriate place for this...maybe in layout
  static updateArtifactBox(svg, element, artifact, scroller) {
    if (typeof(element) === 'undefined') {
      console.log('updateArtifactBox: undefined element!');
      return;
    }
    artifact.logicalBox = svgHelpers.smoBox(element.getBBox());
    artifact.renderedBox = svgHelpers.logicalToClient(svg, artifact.logicalBox, scroller);
  }

  // ### eraseOutline
  // Erases old outlineRects.
  static eraseOutline(context,style) {
      $(context.svg).find('g.vf-' + style).remove();
  }

  static _outlineRect(params) {
    const stroke = params.outlineStroke;
    const scroller = params.scroller.scrollState;
    const context = params.context;
    svgHelpers.eraseOutline(context,params.classes);
    // Don't highlight in print mode.
    if ($('body').hasClass('printing')) {
      return;
    }
    var grp = context.openGroup(params.classes, params.classes + '-outline');
    const boxes = Array.isArray(params.box) ? params.box : [params.box];

    boxes.forEach((box) => {
      if (box) {
        var strokeObj = params.outlineStroke;
        var margin = 5;
        if (params.clientToLogical === true) {
          box = svgHelpers.clientToLogical(context.svg, svgHelpers.adjustScroll(box, scroller.scroll));
        }
        context.rect(box.x - margin, box.y - margin, box.width + margin * 2, box.height + margin * 2, strokeObj);
      }
    });
    context.closeGroup(grp);
  }


  // ### outlineRect
  // Usage:
  //  outlineRect(params)
  // params ({context,box,outlineStroke,classes,scroller})
  // outlineStroke: {stroke, strokeWidth, strokeDashArray, fill}
  static outlineRect(params) {
    params.clientToLogical = true;
    svgHelpers._outlineRect(params);
  }

  static outlineLogicalRect(params) {
    svgHelpers._outlineRect(params);
  }


  static rect(svg,box,attrs,classes) {
    var rect = document.createElementNS(svgHelpers.namespace,'rect');
    var attrKeys = Object.keys(attrs);
    attrKeys.forEach((key) => {
      var val = attrs[key];
      key = (key == 'strokewidth') ? 'stroke-width' : key;
      rect.setAttributeNS('', key, val);
    });
    if (classes) {
      rect.setAttributeNS('','class',classes);
    }
    svg.appendChild(rect);
    return rect;
  }

  static line(svg, x1, y1, x2, y2, attrs, classes) {
    var line = document.createElementNS(svgHelpers.namespace,'line');
    x1 = typeof(x1) == 'string' ? x1 : x1.toString();
    y1 = typeof(y1) == 'string' ? y1 : y1.toString();
    x2 = typeof(x2) == 'string' ? x2 : x2.toString();
    y2 = typeof(y2) == 'string' ? y2 : y2.toString();

    line.setAttributeNS('', 'x1', x1);
    line.setAttributeNS('', 'y1', y1);
    line.setAttributeNS('', 'x2', x2);
    line.setAttributeNS('', 'y2', y2);
    attrs = (attrs) ? attrs : [];
    attrs.forEach((attr) => {
      var key = Object.keys(attr)[0];
      var val = attr[key];
      key = (key == 'strokewidth') ? 'stroke-width' : key;
      line.setAttributeNS('', key, val);
    });
    if (classes) {
      line.setAttributeNS('', 'class', classes);
    }
    svg.appendChild(line);
  }

  static arrowDown(svg,box,attrs,classes) {
    svgHelpers.line(svg,box.x+box.width/2,box.y,box.x+box.width/2,box.y+box.height);
    var arrowY=box.y + box.height/4;
    svgHelpers.line(svg,box.x,arrowY,box.x+box.width/2,box.y+box.height);
    svgHelpers.line(svg,box.x+box.width,arrowY,box.x+box.width/2,box.y+box.height);
  }


  // ### getTextBox
  // Get the logical bounding box of the text for placement.
  static getTextBox(svg,attributes,classes,text) {
    var el = svgHelpers.placeSvgText(svg,attributes,classes,text);
    var box = el.getBBox();
    svg.removeChild(el);
    return box;
  }

  static debugBox(svg, box, classes, voffset) {
    voffset = voffset ? voffset : 0;
    classes = classes ? classes : '';
        if (!box)
           return;
    classes += ' svg-debug-box';
    var b = svgHelpers.buildSvg;
    var mid = box.x + box.width / 2;
    var xtext = 'x1: ' + Math.round(box.x);
    var wtext = 'x2: ' + Math.round(box.width+box.x);
    var ytext = 'y1: ' + Math.round(box.y);
    var htext = 'y2: ' + Math.round(box.height+box.y);
    var ytextp = Math.round(box.y+box.height);
    var ytextp2 = Math.round(box.y+box.height-30);

    var r = b('g').classes(classes)
      .append(
        b('text').text(box.x + 20, box.y - 14+voffset, 'svg-debug-text', xtext))
      .append(
        b('text').text(mid - 20, box.y - 14+voffset, 'svg-debug-text', wtext))
      .append(
        b('line').line(box.x, box.y - 2, box.x + box.width, box.y - 2))
      .append(
        b('line').line(box.x, box.y - 8, box.x, box.y + 5))
      .append(
        b('line').line(box.x + box.width, box.y - 8, box.x + box.width, box.y + 5))
      .append(
        b('text').text(Math.round(box.x-14+voffset), ytextp, 'svg-vdebug-text', ytext)
          .attr('transform','rotate(-90,'+Math.round(box.x-14+voffset)+','+ytextp+')'));
    if (box.height > 2) {
      r.append(
        b('text').text(Math.round(box.x-14+voffset), ytextp2, 'svg-vdebug-text', htext)
          .attr('transform','rotate(-90,'+Math.round(box.x-14+voffset)+','+(ytextp2)+')'))
          .append(
        b('line').line(Math.round(box.x-2), Math.round(box.y +box.height),box.x-2,box.y))
          .append(
        b('line').line(Math.round(box.x-8), Math.round(box.y +box.height),box.x+6,Math.round(box.y+box.height)))
          .append(
        b('line').line(Math.round(box.x-8), Math.round(box.y),Math.round(box.x+6),Math.round(box.y)));
    }
    svg.appendChild(r.dom());
  }

  static fontIntoToSvgAttributes(fontInfo) {
    var rv = [];
    var fkeys = Object.keys(fontInfo);
    fkeys.forEach((key) => {
      var n='{"font-'+key+'":"'+fontInfo[key]+'"}';
      rv.push(JSON.parse(n));
    });
      return rv;
  }

  static debugSvgFont(fontFamily,fontSize,str) {
    const xoff = 20;
    const yoff = 50;
    str = str.replace('&','&amp;');
    str = str.replace('<','&lt;');
    var svg = $('#boo svg')[0];
    var attributes = [{x:xoff},{y:yoff},{"font-family":fontFamily},{"font-size":fontSize}];
    var classes = 'dbg-svg-font';
    $('.dbg-svg-font').remove();
    svgHelpers.placeSvgText(svg,attributes,classes,str,'debugSvgFont');
    var box = svgHelpers.smoBox($('#debugSvgFont')[0].getBBox());
    return svgHelpers.boxPoints(box.x - xoff,box.y - (yoff - box.height),box.width,box.height);
  }

  static svgFontInfo(fontFamily,fontSize) {
    var metrics = [];
    for (var i = 33;i < 95; ++i) {
      var st = String.fromCharCode(i);
      var metric = svgHelpers.debugSvgFont(fontFamily,fontSize,st);
      metrics.push({charCode:st,...metric});
    }
    return metrics;
  }

  static placeSvgText(svg,attributes,classes,text,id) {
    var ns = svgHelpers.namespace;
    var e = document.createElementNS(ns, 'text');
    attributes.forEach((attr) => {
      var key = Object.keys(attr)[0];
        e.setAttributeNS('', key, attr[key]);
    })
    if (classes) {
      e.setAttributeNS('', 'class', classes);
    }
    var tn = document.createTextNode(text);
    e.appendChild(tn);
    svg.appendChild(e);
    return e;
  }

  // ### findIntersectingArtifactFromMap
  // Same as findIntersectionArtifact but uses a map of keys instead of an array
  static findIntersectingArtifactFromMap(clientBox, map, scrollState) {
    var box = svgHelpers.smoBox(clientBox); //svgHelpers.untransformSvgPoint(this.context.svg,clientBox);
    // box.y = box.y - this.renderElement.offsetTop;
    // box.x = box.x - this.renderElement.offsetLeft;
    var rv = [];

    Object.keys(map).forEach((k) => {
      var object = map[k];
      // Measure has been updated, but not drawn.
      if (!object.box) {
      // console.log('there is no box');
      } else {
        var obox = svgHelpers.adjustScroll(svgHelpers.smoBox(object.box), scrollState.scroll);
        var i1 = box.x - obox.x; // handle edge not believe in x and y
        var i2 = box.y - obox.y;
        if (i1 > 0 && i1 < object.box.width && i2 > 0 && i2 < object.box.height) {
          rv.push(object);
        }
      }
    });
    return rv;
  }

  static containsPoint(box, point, scrollState) {
    var obox = svgHelpers.adjustScroll(svgHelpers.smoBox(box), scrollState.scroll);
    const i1 = point.x - box.x; // handle edge not believe in x and y
    const i2 = point.y - box.y;
    if (i1 > 0 && i1 < obox.width && i2 > 0 && i2 < obox.height) {
      return true;
    }
    return false;
  }

  // ### findIntersectionArtifact
  // find all object that intersect with the rectangle
  static findIntersectingArtifact(clientBox, objects, scrollState) {
    var box = svgHelpers.smoBox(clientBox); //svgHelpers.untransformSvgPoint(this.context.svg,clientBox);

    // box.y = box.y - this.renderElement.offsetTop;
    // box.x = box.x - this.renderElement.offsetLeft;
    var rv = [];
    objects.forEach((object) => {
      // Measure has been updated, but not drawn.
      if (!object.box) {
        // console.log('there is no box');
      } else {
        var obox = svgHelpers.adjustScroll(svgHelpers.smoBox(object.box), scrollState.scroll);
        var i1 = box.x - obox.x; // handle edge not believe in x and y
        var i2 = box.y - obox.y;
        if (i1 > 0 && i1 < object.box.width && i2 > 0 && i2 < object.box.height) {
          rv.push(object);
        }
      }
    });

    return rv;
  }
  static findSmallestIntersection(clientBox, objects, scrollState) {
    var ar = svgHelpers.findIntersectingArtifact(clientBox, objects, scrollState);
    if (!ar.length) {
      return null;
    }
    var rv = ar[0];
    var min = ar[0].box.width * ar[0].box.height;
    ar.forEach((obj) => {
      var tst = obj.box.width * obj.box.height;
      if (tst < min) {
        rv = obj;
        min = tst;
      }
    });
    return rv;
  }

  static translateElement(g,x,y) {
    g.setAttributeNS('','transform','translate('+x+' '+y+')');
  }

  // ### measureBBox
  // Return the bounding box of the measure
  static measureBBox(b1, measure, staff) {
    if (measure.renderedBox) {
      if (b1['width']) {
        return svgHelpers.unionRect(b1, measure.renderedBox);
      } else {
        return measure.renderedBox;
      }
    } else {
      var mbox = {
        x: measure.staffX,
        y: staff.staffY,
        width: measure.staffWidth,
        height: staff.staffHeight
      };
      if (b1['width']) {
        return mbox;
      }
      return svgHelpers.unionRect(b1, mbox);
    }
  }
  // ### measurePerInch
  // Supported font units
  static get unitsPerInch() {
    var rv = {};

    rv['pt'] = 72.0;
    rv['px'] = 96.0;
    rv['em'] = 6.0;
    return rv;
  }

  static convertFont(size,o,n) {
    return size * (svgHelpers.unitsPerInch[n] / svgHelpers.unitsPerInch[o]);
  }

  static stringify(box) {
    if (box['width']) {

      return JSON.stringify({
        x: box.x,
        y: box.y,
        width: box.width,
        height: box.height
      }, null, ' ');
    } else {
      return JSON.stringify({
        x: box.x,
        y: box.y
      }, null, ' ');
    }
  }

  static log(box) {
    if (box['width']) {
      console.log(JSON.stringify({
          x: box.x,
          y: box.y,
          width: box.width,
          height: box.height
        }, null, ' '));
    } else {
      console.log('{}');
    }
  }

  // ### pointBox
  // return a point-sized box at the given coordinate
  static pointBox(x, y) {
    return {
      x: x,
      y: y,
      width: 0,
      height: 0
    };
  }


  // ### smoBox:
  // return a simple box object that can be serialized, copied
  // (from svg DOM box)
  static smoBox(box) {
    var hround = (f) => {
      return Math.round((f + Number.EPSILON) * 100) / 100;
    }
        var x = typeof(box.x) == 'undefined' ? hround(box.left) : hround(box.x);
        var y = typeof(box.y) == 'undefined' ? hround(box.top) : hround(box.y);
    return ({
      x: hround(x),
      y: hround(y),
      width: hround(box.width),
      height: hround(box.height)
    });
  }
  // ### unionRect
  // grow the bounding box two objects to include both.
  static unionRect(b1, b2) {
    var x = Math.min(b1.x, b2.x);
    var y = Math.min(b1.y, b2.y);
    var width = Math.max(b1.x + b1.width, b2.x + b2.width) - x;
    var height = Math.max(b1.y + b1.height, b2.y + b2.height) - y;
    return {
      x: x,
      y: y,
      width: width,
      height: height
    };
  }

  // ### adjustScroll
  // Add the scroll to the screen coordinates so we can find the mapped
  // location of something.
  static adjustScroll(box, scroll) {
    // WIP...
    if (typeof(box) == 'undefined' || typeof(scroll) == 'undefined') {
      console.log('bad values to scroll thing');
      return;
    }
    return svgHelpers.boxPoints(box.x + scroll.x, box.y - scroll.y, box.width, box.height);
    // return box;
  }

  static boxPoints(x, y, w, h) {
    return ({
      x: x,
      y: y,
      width: w,
      height: h
    });
  }

  static copyBox(box) {
        box = svgHelpers.smoBox(box);
    return {
      x: box.x,
      y: box.y,
      width: box.width,
      height: box.height
    };
  }

  // ### svgViewport
  // set `svg` element to `width`,`height` and viewport `scale`
  static svgViewport(svg, xOffset,yOffset,width, height, scale) {
    svg.setAttributeNS('', 'width', '' + width);
    svg.setAttributeNS('', 'height', '' + height);
    svg.setAttributeNS('', 'viewBox', ''+xOffset + ' ' + yOffset + ' ' + Math.round(width / scale) + ' ' +
      Math.round(height / scale));
  }

  // ### logicalToClient
  // Convert a point from logical (pixels) to actual screen dimensions based on current
  // zoom, aspect ratio
  /* static logicalToClient(svg, logicalPoint) {
  var rect = svg.getBoundingClientRect();
  var rv = svgHelpers.copyBox(logicalPoint);
  rv.x += rect.x;
  rv.y += rect.y;
  return rv;
  }   */

  // ### clientToLogical
  // return a box or point in svg coordintes from screen coordinates
  static clientToLogical(svg, point) {
    var pt = svg.createSVGPoint();
        if (!point)
           return;
        var x = typeof(point.x) != 'undefined' ? point.x : point.left;
        var y = typeof(point.y) != 'undefined' ? point.y : point.top;
    pt.x = x;
    pt.y = y;
    var sp = pt.matrixTransform(svg.getScreenCTM().inverse());
    if (typeof(point['width']) == 'undefined') {
      return {
        x: sp.x,
        y: sp.y
      };
    }

    var endPt = svg.createSVGPoint();
    endPt.x = pt.x + point.width;
    endPt.y = pt.y + point.height;
    var ep = endPt.matrixTransform(svg.getScreenCTM().inverse());
    return {
      x: sp.x,
      y: sp.y,
      width: ep.x - sp.x,
      height: ep.y - sp.y
    };
  }

  // ### logicalToClient
  // return a box or point in screen coordinates from svg coordinates
  static logicalToClient(svg, point, scroller) {
    var pt = svg.createSVGPoint();
    const ss = scroller.scrollState;
    pt.x = point.x;
    pt.y = point.y;
    var sp = pt.matrixTransform(svg.getScreenCTM());
    if (!point['width']) {
      return {
        x: sp.x + ss.scroll.x,
        y: sp.y + ss.scroll.y
      };
    }
    var endPt = svg.createSVGPoint();
    endPt.x = pt.x + point.width;
    endPt.y = pt.y + point.height;
    var ep = endPt.matrixTransform(svg.getScreenCTM());
    return {
      x: sp.x + ss.scroll.x,
      y: sp.y + ss.scroll.y,
      width: ep.x - sp.x,
      height: ep.y - sp.y
    };
  }
}
;var basicJson = `{"score":{"layout":{"leftMargin":30,"rightMargin":30,"topMargin":40,"bottomMargin":40,"pageWidth":816,"pageHeight":1056,"orientation":0,"interGap":30,"intraGap":10,"svgScale":1,"zoomScale":2.107843137254902,"zoomMode":0,"pages":1},"startIndex":0,"renumberingMap":{}},"staves":[{"staffId":0,"staffX":10,"staffY":40,"adjY":0,"staffWidth":1600,"staffHeight":90,"startIndex":0,"renumberingMap":{},"keySignatureMap":{},"instrumentInfo":{"instrumentName":"Treble Instrument","keyOffset":"0","clef":"treble"},"modifiers":[],"measures":[{"timeSignature":"4/4","keySignature":"C","staffY":41,"measureNumber":{"measureNumber":0,"measureIndex":0,"systemIndex":0,"staffId":0},"activeVoice":0,"clef":"treble","transposeIndex":0,"adjX":64.98,"padLeft":0,"adjRight":11,"padRight":10,"rightMargin":2,"tuplets":[],"beamGroups":[],"voices":[{"notes":[{"ticks":{"numerator":2048,"denominator":1,"remainder":0},"pitches":[{"letter":"c","accidental":"n","octave":4}],"noteType":"n","attrs":{"id":"auto318077","type":"SmoNote"},"clef":"treble","endBeam":false,"beamBeats":4096,"flagState":0,"noteModifiers":[],"graceNotes":[],"articulations":[],"ornaments":[]},{"ticks":{"numerator":1024,"denominator":1,"remainder":0},"pitches":[{"letter":"d","accidental":"n","octave":4}],"noteType":"n","attrs":{"id":"auto318078","type":"SmoNote"},"clef":"treble","endBeam":false,"beamBeats":4096,"flagState":0,"noteModifiers":[],"graceNotes":[],"articulations":[],"ornaments":[]},{"ticks":{"numerator":1024,"denominator":1,"remainder":0},"pitches":[{"letter":"e","accidental":"n","octave":4}],"noteType":"n","attrs":{"id":"auto318079","type":"SmoNote"},"clef":"treble","endBeam":false,"beamBeats":4096,"flagState":0,"noteModifiers":[],"graceNotes":[],"articulations":[],"ornaments":[]},{"ticks":{"numerator":1024,"denominator":1,"remainder":0},"pitches":[{"letter":"f","accidental":"n","octave":4}],"noteType":"n","attrs":{"id":"auto318080","type":"SmoNote"},"clef":"treble","endBeam":false,"beamBeats":4096,"flagState":0,"noteModifiers":[],"graceNotes":[],"articulations":[],"ornaments":[]},{"ticks":{"numerator":1024,"denominator":1,"remainder":0},"pitches":[{"letter":"g","accidental":"n","octave":4}],"noteType":"n","attrs":{"id":"auto318081","type":"SmoNote"},"clef":"treble","endBeam":false,"beamBeats":4096,"flagState":0,"noteModifiers":[],"graceNotes":[],"articulations":[],"ornaments":[]},{"ticks":{"numerator":1024,"denominator":1,"remainder":0},"pitches":[{"letter":"a","accidental":"n","octave":4}],"noteType":"n","attrs":{"id":"auto318082","type":"SmoNote"},"clef":"treble","endBeam":false,"beamBeats":4096,"flagState":0,"noteModifiers":[],"graceNotes":[],"articulations":[],"ornaments":[]},{"ticks":{"numerator":1024,"denominator":1,"remainder":0},"pitches":[{"letter":"b","accidental":"n","octave":4}],"noteType":"n","attrs":{"id":"auto318083","type":"SmoNote"},"clef":"treble","endBeam":false,"beamBeats":4096,"flagState":0,"noteModifiers":[],"graceNotes":[],"articulations":[],"ornaments":[]},{"ticks":{"numerator":2048,"denominator":1,"remainder":0},"pitches":[{"letter":"c","accidental":"n","octave":5}],"noteType":"n","attrs":{"id":"auto318084","type":"SmoNote"},"clef":"treble","endBeam":false,"beamBeats":4096,"flagState":0,"noteModifiers":[],"graceNotes":[],"articulations":[],"ornaments":[]},{"ticks":{"numerator":1024,"denominator":1,"remainder":0},"pitches":[{"letter":"b","accidental":"n","octave":4}],"noteType":"n","attrs":{"id":"auto318085","type":"SmoNote"},"clef":"treble","endBeam":false,"beamBeats":4096,"flagState":0,"noteModifiers":[],"graceNotes":[],"articulations":[],"ornaments":[]},{"ticks":{"numerator":1024,"denominator":1,"remainder":0},"pitches":[{"letter":"a","accidental":"n","octave":4}],"noteType":"n","attrs":{"id":"auto318086","type":"SmoNote"},"clef":"treble","endBeam":false,"beamBeats":4096,"flagState":0,"noteModifiers":[],"graceNotes":[],"articulations":[],"ornaments":[]},{"ticks":{"numerator":1024,"denominator":1,"remainder":0},"pitches":[{"letter":"g","accidental":"n","octave":4}],"noteType":"n","attrs":{"id":"auto318087","type":"SmoNote"},"clef":"treble","endBeam":false,"beamBeats":4096,"flagState":0,"noteModifiers":[],"graceNotes":[],"articulations":[],"ornaments":[]},{"ticks":{"numerator":1024,"denominator":1,"remainder":0},"pitches":[{"letter":"f","accidental":"n","octave":4}],"noteType":"n","attrs":{"id":"auto318088","type":"SmoNote"},"clef":"treble","endBeam":false,"beamBeats":4096,"flagState":0,"noteModifiers":[],"graceNotes":[],"articulations":[],"ornaments":[]},{"ticks":{"numerator":1024,"denominator":1,"remainder":0},"pitches":[{"letter":"e","accidental":"n","octave":4}],"noteType":"n","attrs":{"id":"auto318089","type":"SmoNote"},"clef":"treble","endBeam":false,"beamBeats":4096,"flagState":0,"noteModifiers":[],"graceNotes":[],"articulations":[],"ornaments":[]},{"ticks":{"numerator":1024,"denominator":1,"remainder":0},"pitches":[{"letter":"d","accidental":"n","octave":4}],"noteType":"n","attrs":{"id":"auto318090","type":"SmoNote"},"clef":"treble","endBeam":false,"beamBeats":4096,"flagState":0,"noteModifiers":[],"graceNotes":[],"articulations":[],"ornaments":[]}]}],"modifiers":[{"position":0,"barline":0,"ctor":"SmoBarline"},{"position":1,"barline":0,"ctor":"SmoBarline"},{"symbol":0,"xOffset":0,"yOffset":30,"position":0,"ctor":"SmoRepeatSymbol"}]},{"timeSignature":"4/4","keySignature":"C","staffY":41,"measureNumber":{"measureNumber":1,"measureIndex":1,"systemIndex":1,"staffId":0},"activeVoice":0,"clef":"treble","transposeIndex":0,"adjX":11,"padLeft":0,"adjRight":11,"padRight":10,"rightMargin":2,"tuplets":[],"beamGroups":[],"voices":[{"notes":[{"ticks":{"numerator":2048,"denominator":1,"remainder":0},"pitches":[{"letter":"c","accidental":"n","octave":4}],"noteType":"n","attrs":{"id":"auto358929","type":"SmoNote"},"clef":"treble","endBeam":false,"beamBeats":4096,"flagState":0,"noteModifiers":[],"graceNotes":[],"articulations":[],"ornaments":[]},{"ticks":{"numerator":1024,"denominator":1,"remainder":0},"pitches":[{"letter":"e","accidental":"n","octave":4}],"noteType":"n","attrs":{"id":"auto360328","type":"SmoNote"},"clef":"treble","endBeam":false,"beamBeats":4096,"flagState":0,"noteModifiers":[],"graceNotes":[],"articulations":[],"ornaments":[]},{"ticks":{"numerator":1024,"denominator":1,"remainder":0},"pitches":[{"letter":"g","accidental":"n","octave":4}],"noteType":"n","attrs":{"id":"auto360329","type":"SmoNote"},"clef":"treble","endBeam":false,"beamBeats":4096,"flagState":0,"noteModifiers":[],"graceNotes":[],"articulations":[],"ornaments":[]},{"ticks":{"numerator":2048,"denominator":1,"remainder":0},"pitches":[{"letter":"c","accidental":"n","octave":5}],"noteType":"n","attrs":{"id":"auto372785","type":"SmoNote"},"clef":"treble","endBeam":false,"beamBeats":4096,"flagState":0,"noteModifiers":[],"graceNotes":[],"articulations":[],"ornaments":[]},{"ticks":{"numerator":1024,"denominator":1,"remainder":0},"pitches":[{"letter":"g","accidental":"n","octave":4}],"noteType":"n","attrs":{"id":"auto374186","type":"SmoNote"},"clef":"treble","endBeam":false,"beamBeats":4096,"flagState":0,"noteModifiers":[],"graceNotes":[],"articulations":[],"ornaments":[]},{"ticks":{"numerator":1024,"denominator":1,"remainder":0},"pitches":[{"letter":"e","accidental":"n","octave":4}],"noteType":"n","attrs":{"id":"auto374187","type":"SmoNote"},"clef":"treble","endBeam":false,"beamBeats":4096,"flagState":0,"noteModifiers":[],"graceNotes":[],"articulations":[],"ornaments":[]},{"ticks":{"numerator":2048,"denominator":1,"remainder":0},"pitches":[{"letter":"c","accidental":"n","octave":4}],"noteType":"n","attrs":{"id":"auto381535","type":"SmoNote"},"clef":"treble","endBeam":false,"beamBeats":4096,"flagState":0,"noteModifiers":[],"graceNotes":[],"articulations":[],"ornaments":[]},{"ticks":{"numerator":2048,"denominator":1,"remainder":0},"pitches":[{"letter":"b","accidental":"n","octave":3}],"noteType":"n","attrs":{"id":"auto354946","type":"SmoNote"},"clef":"treble","endBeam":false,"beamBeats":4096,"flagState":0,"noteModifiers":[],"graceNotes":[],"articulations":[],"ornaments":[]},{"ticks":{"numerator":4096,"denominator":1,"remainder":0},"pitches":[{"letter":"c","accidental":"n","octave":4}],"noteType":"n","attrs":{"id":"auto389896","type":"SmoNote"},"clef":"treble","endBeam":false,"beamBeats":4096,"flagState":0,"noteModifiers":[],"graceNotes":[],"articulations":[],"ornaments":[]}]}],"modifiers":[{"position":0,"barline":0,"ctor":"SmoBarline"},{"position":1,"barline":0,"ctor":"SmoBarline"},{"symbol":0,"xOffset":0,"yOffset":30,"position":0,"ctor":"SmoRepeatSymbol"}]}]}],"scoreText":[]}`;

var emptyScoreJson = `{"a":{"b":{"c":30,"d":30,"e":40,"f":40,"g":816,"h":1056,"i":0,"j":30,"k":10,"l":1,"m":2.107843137254902,"n":0,"o":1},"q":0,"r":{},"me":[{"ne":"engraving","oe":1,"xb":"Bravura","wb":1,"pe":false},{"ne":"score","oe":2,"xb":"Merriweather","wb":14,"pe":false},{"ne":"chords","oe":3,"xb":"Roboto Slab","wb":14,"pe":false},{"ne":"lyrics","oe":4,"xb":"Merriweather","wb":12,"pe":true}]},"s":[{"t":0,"u":10,"v":40,"w":0,"x":1600,"y":90,"q":0,"r":{},"z":{},"aa":{"ba":"Treble Instrument","ca":"0","da":"treble"},"ea":[],"va":[{"ya":{"ya":0,"za":0,"ab":0,"t":0},"bb":59.980000000000004,"cb":[],"db":[{"eb":[{"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble","sb":[{"vb":{"ne":"chords","oe":3,"xb":"Roboto Slab","wb":14,"pe":false},"le":2,"sa":"SmoLyric","ke":""},{"vb":{"xb":"Merriweather","wb":12},"sa":"SmoLyric","ke":""}]},{"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble"},{"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble"},{"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble"}]}],"ea":[]}]}],"yc":[],"ge":[],"yd":[],"ee":{"wa":{"0":"4/4"},"xa":{"0":"C"}},"dictionary":{"a":"score","b":"layout","c":"leftMargin","d":"rightMargin","e":"topMargin","f":"bottomMargin","g":"pageWidth","h":"pageHeight","i":"orientation","j":"interGap","k":"intraGap","l":"svgScale","m":"zoomScale","n":"zoomMode","o":"pages","p":"pageSize","q":"startIndex","r":"renumberingMap","s":"staves","t":"staffId","u":"staffX","v":"staffY","w":"adjY","x":"staffWidth","y":"staffHeight","z":"keySignatureMap","aa":"instrumentInfo","ba":"instrumentName","ca":"keyOffset","da":"clef","ea":"modifiers","fa":"startSelector","ga":"staff","ha":"measure","ia":"voice","ja":"tick","ka":"pitches","la":"endSelector","ma":"xOffset","na":"cp1y","oa":"cp2y","pa":"attrs","qa":"id","ra":"type","sa":"ctor","ta":"yOffset","ua":"position","va":"measures","wa":"timeSignature","xa":"keySignature","ya":"measureNumber","za":"measureIndex","ab":"systemIndex","bb":"adjX","cb":"tuplets","db":"voices","eb":"notes","fb":"ticks","gb":"numerator","hb":"denominator","ib":"remainder","jb":"letter","kb":"octave","lb":"accidental","mb":"symbol","nb":"bpm","ob":"display","pb":"beatDuration","qb":"beamBeats","rb":"endBeam","sb":"textModifiers","tb":"text","ub":"endChar","vb":"fontInfo","wb":"size","xb":"family","yb":"style","zb":"weight","ac":"classes","bc":"verse","cc":"fill","dc":"scaleX","ec":"scaleY","fc":"translateX","gc":"translateY","hc":"selector","ic":"renderedBox","jc":"x","kc":"y","lc":"width","mc":"height","nc":"logicalBox","oc":"noteType","pc":"cautionary","qc":"articulations","rc":"articulation","sc":"activeVoice","tc":"flagState","uc":"invert","vc":"fontSize","wc":"yOffsetLine","xc":"yOffsetPixels","yc":"scoreText","zc":"backup","ad":"edited","bd":"pagination","cd":"boxModel","dd":"justification","ed":"autoLayout","fd":"ornaments","gd":"offset","hd":"ornament","id":"tempoMode","jd":"tempoText","kd":"barline","ld":"systemBreak","md":"graceNotes","nd":"tones","od":"tuplet","pd":"beam_group","qd":"renderId","rd":"numNotes","sd":"totalTicks","td":"stemTicks","ud":"durationMap","vd":"bracketed","wd":"ratioed","xd":"location","yd":"systemGroups","zd":"leftConnector","ae":"padLeft","be":"customStretch","ce":"engravingFont","de":"customProportion","ee":"columnAttributeMap","fe":"tempo","ge":"textGroups","he":"textBlocks","ie":"backupBlocks","je":"blocks","ke":"_text","le":"parser","me":"fonts","ne":"name","oe":"purpose","pe":"custom"}}`;

var sixTestJson = `{"a":{"b":{"c":30,"d":30,"e":40,"f":40,"g":816,"h":1056,"i":0,"j":30,"k":10,"l":1,"m":2.107843137254902,"n":0,"o":1},"q":0,"r":{},"ce":"Bravura"},"s":[{"t":0,"u":10,"v":40,"w":0,"x":1600,"y":90,"q":0,"r":{},"z":{},"aa":{"ba":"Treble Instrument","ca":"0","da":"treble"},"ea":[],"va":[{"ya":{"ya":0,"za":0,"ab":0,"t":0},"bb":59.980000000000004,"cb":[],"db":[{"eb":[{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","rb":true,"qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","rb":true,"qb":6144}]}],"ea":[]}]}],"yc":[],"yd":[],"ee":{"wa":{"0":"6/8"},"xa":{"0":"C"}},"dictionary":{"a":"score","b":"layout","c":"leftMargin","d":"rightMargin","e":"topMargin","f":"bottomMargin","g":"pageWidth","h":"pageHeight","i":"orientation","j":"interGap","k":"intraGap","l":"svgScale","m":"zoomScale","n":"zoomMode","o":"pages","p":"pageSize","q":"startIndex","r":"renumberingMap","s":"staves","t":"staffId","u":"staffX","v":"staffY","w":"adjY","x":"staffWidth","y":"staffHeight","z":"keySignatureMap","aa":"instrumentInfo","ba":"instrumentName","ca":"keyOffset","da":"clef","ea":"modifiers","fa":"startSelector","ga":"staff","ha":"measure","ia":"voice","ja":"tick","ka":"pitches","la":"endSelector","ma":"xOffset","na":"cp1y","oa":"cp2y","pa":"attrs","qa":"id","ra":"type","sa":"ctor","ta":"yOffset","ua":"position","va":"measures","wa":"timeSignature","xa":"keySignature","ya":"measureNumber","za":"measureIndex","ab":"systemIndex","bb":"adjX","cb":"tuplets","db":"voices","eb":"notes","fb":"ticks","gb":"numerator","hb":"denominator","ib":"remainder","jb":"letter","kb":"octave","lb":"accidental","mb":"symbol","nb":"bpm","ob":"display","pb":"beatDuration","qb":"beamBeats","rb":"endBeam","sb":"textModifiers","tb":"text","ub":"endChar","vb":"fontInfo","wb":"size","xb":"family","yb":"style","zb":"weight","ac":"classes","bc":"verse","cc":"fill","dc":"scaleX","ec":"scaleY","fc":"translateX","gc":"translateY","hc":"selector","ic":"renderedBox","jc":"x","kc":"y","lc":"width","mc":"height","nc":"logicalBox","oc":"noteType","pc":"cautionary","qc":"articulations","rc":"articulation","sc":"activeVoice","tc":"flagState","uc":"invert","vc":"fontSize","wc":"yOffsetLine","xc":"yOffsetPixels","yc":"scoreText","zc":"backup","ad":"edited","bd":"pagination","cd":"boxModel","dd":"justification","ed":"autoLayout","fd":"ornaments","gd":"offset","hd":"ornament","id":"tempoMode","jd":"tempoText","kd":"barline","ld":"systemBreak","md":"graceNotes","nd":"tones","od":"tuplet","pd":"beam_group","qd":"renderId","rd":"numNotes","sd":"totalTicks","td":"stemTicks","ud":"durationMap","vd":"bracketed","wd":"ratioed","xd":"location","yd":"systemGroups","zd":"leftConnector","ae":"padLeft","be":"customStretch","ce":"engravingFont","de":"customProportion","ee":"columnAttributeMap","fe":"tempo"}}`;
;var inventionJson = `{"a":{"b":{"c":30,"d":30,"e":120,"f":40,"g":816,"h":1056,"i":0,"j":30,"k":20,"l":0.6,"m":1.4641000000000006,"n":2,"o":2,"p":"letter"},"q":0,"r":{},"me":[{"ne":"engraving","oe":1,"xb":"Gonville","wb":1,"pe":false},{"ne":"score","oe":2,"xb":"Merriweather","wb":14,"pe":false},{"ne":"chords","oe":3,"xb":"Roboto Slab","wb":14,"pe":false},{"ne":"lyrics","oe":4,"xb":"Merriweather","wb":12,"pe":false}]},"s":[{"t":0,"u":10,"v":40,"w":0,"x":1600,"y":90,"q":0,"r":{},"z":{},"aa":{"ba":"Treble Instrument","ca":"0","da":"treble"},"ea":[{"fa":{"ga":0,"ha":4,"ia":0,"ja":0,"ka":[]},"la":{"ga":0,"ha":4,"ia":0,"ja":1,"ka":[]},"ma":-3,"na":34,"oa":17,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":5,"ia":0,"ja":9,"ka":[]},"la":{"ga":0,"ha":5,"ia":0,"ja":12,"ka":[]},"ma":0,"ua":4,"na":40,"oa":40,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":10,"ia":0,"ja":1,"ka":[]},"la":{"ga":0,"ha":10,"ia":0,"ja":4,"ka":[]},"ma":0,"uc":true,"na":40,"oa":40,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":10,"ia":0,"ja":5,"ka":[]},"la":{"ga":0,"ha":11,"ia":0,"ja":0,"ka":[]},"ma":0,"ua":4,"na":40,"oa":40,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":11,"ia":0,"ja":1,"ka":[]},"la":{"ga":0,"ha":11,"ia":0,"ja":6,"ka":[]},"ma":0,"ua":4,"na":40,"oa":40,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":15,"ia":0,"ja":8,"ka":[]},"la":{"ga":0,"ha":16,"ia":0,"ja":0,"ka":[]},"ma":0,"ua":4,"na":40,"oa":40,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":17,"ia":0,"ja":8,"ka":[]},"la":{"ga":0,"ha":18,"ia":0,"ja":0,"ka":[]},"ma":0,"ua":4,"na":40,"oa":40,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":0,"ia":0,"ja":9,"ka":[]},"la":{"ga":0,"ha":0,"ia":0,"ja":11,"ka":[]},"sa":"SmoStaffHairpin"},{"fa":{"ga":0,"ha":1,"ia":0,"ja":9,"ka":[]},"la":{"ga":0,"ha":1,"ia":0,"ja":11,"ka":[]},"sa":"SmoStaffHairpin"},{"fa":{"ga":0,"ha":6,"ia":0,"ja":4,"ka":[]},"la":{"ga":0,"ha":6,"ia":0,"ja":10,"ka":[]},"ta":-40,"sa":"SmoStaffHairpin"},{"fa":{"ga":0,"ha":7,"ia":0,"ja":4,"ka":[]},"la":{"ga":0,"ha":7,"ia":0,"ja":10,"ka":[]},"sa":"SmoStaffHairpin"},{"fa":{"ga":0,"ha":16,"ia":0,"ja":8,"ka":[]},"la":{"ga":0,"ha":17,"ia":0,"ja":0,"ka":[]},"ma":0,"ua":4,"na":40,"oa":40,"sa":"SmoSlur"}],"va":[{"ya":{"ya":0,"za":0,"ab":0,"t":0},"bb":59.980000000000004,"cb":[],"db":[{"eb":[{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":4}],"oc":"r","da":"treble","rb":true},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":4}],"da":"treble","qb":3072},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":4}],"da":"treble","qb":3072},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":4}],"da":"treble","rb":true,"qb":3072},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","qb":8192},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","qb":8192},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":8192,"fd":[{"hd":"mordent_inverted","sa":"SmoOrnament"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","rb":true,"qb":8192}]}],"ea":[]},{"ya":{"ya":1,"za":1,"ab":1,"t":0},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qc":[{"rc":"staccato","sa":"SmoArticulation"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":8192},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":5}],"da":"treble","qb":8192},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":5}],"da":"treble","qb":8192,"fd":[{"hd":"mordent_inverted","sa":"SmoOrnament"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":5}],"da":"treble","rb":true,"qb":8192}]}],"ea":[]},{"ya":{"ya":2,"za":2,"ab":2,"t":0},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":5}],"da":"treble","qc":[{"rc":"staccato","sa":"SmoArticulation"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":5}],"da":"treble"}]}],"ea":[]},{"ya":{"ya":3,"za":3,"ab":0,"t":0},"bb":41.5,"cb":[],"db":[{"eb":[{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"#","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble"}]}],"ea":[]},{"ya":{"ya":4,"za":4,"ab":1,"t":0},"bb":6,"be":28,"de":22,"cb":[],"db":[{"eb":[{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","fd":[{"hd":"mordent_inverted","sa":"SmoOrnament"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"#","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"#","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble"}]}],"ea":[]},{"ya":{"ya":5,"za":5,"ab":2,"t":0},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":512,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":512,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","fd":[{"sa":"SmoOrnament"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble"}]}],"ea":[]},{"ya":{"ya":6,"za":6,"ab":0,"t":0},"bb":41.5,"cb":[],"db":[{"eb":[{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","rb":true},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"oc":"r","da":"treble"},{"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"oc":"r","da":"treble","rb":true},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","rb":true},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble"}]}],"ea":[]},{"ya":{"ya":7,"za":7,"ab":1,"t":0},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"#","kb":4}],"da":"treble","rb":true},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble"},{"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"oc":"r","da":"treble","rb":true},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","rb":true},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble"}]}],"ea":[]},{"ya":{"ya":8,"za":8,"ab":2,"t":0},"bb":41.5,"cb":[],"db":[{"eb":[{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","rb":true},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble"},{"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble","rb":true},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","rb":true},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble"}]}],"ea":[]},{"ld":true,"ya":{"ya":9,"za":9,"ab":0,"t":0},"bb":41.5,"be":26,"de":12,"cb":[],"db":[{"eb":[{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","rb":true},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble"},{"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":5}],"oc":"r","da":"treble","rb":true},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","rb":true},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"#","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":5}],"da":"treble"}]}],"ea":[]},{"ya":{"ya":10,"za":10,"ab":1,"t":0},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":8192},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"#","kb":5}],"da":"treble","qb":8192},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":8192},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":5}],"da":"treble","rb":true,"qb":8192},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":5}],"da":"treble","qb":8192,"tc":1},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble","qb":8192,"tc":1},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":8192,"tc":1},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"#","kb":5}],"da":"treble","rb":true,"qb":8192,"tc":1}]}],"ea":[]},{"ya":{"ya":11,"za":11,"ab":2,"t":0},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":8192,"tc":1},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"#","kb":4}],"da":"treble","qb":8192,"tc":1},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"#","kb":4}],"da":"treble","qb":8192,"tc":1},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble","rb":true,"qb":8192,"tc":1},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","tc":1},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","tc":1},{"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","tc":1}]}],"ea":[]},{"ya":{"ya":12,"za":12,"ab":0,"t":0},"bb":41.5,"cb":[],"db":[{"eb":[{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble"}]}],"ea":[]},{"ya":{"ya":13,"za":13,"ab":1,"t":0},"bb":6,"be":-28,"cb":[],"db":[{"eb":[{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"#","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","fd":[{"sa":"SmoOrnament"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble"}]}],"ea":[]},{"ya":{"ya":14,"za":14,"ab":2,"t":0},"bb":6,"be":32,"de":12,"cb":[],"db":[{"eb":[{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble","qc":[{"ua":"below","rc":"staccato","sa":"SmoArticulation"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":8192,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":5}],"da":"treble"}]}],"ea":[]},{"ld":true,"ya":{"ya":15,"za":15,"ab":0,"t":0},"bb":41.5,"be":-20,"de":12,"cb":[],"db":[{"eb":[{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":5}],"da":"treble","tc":2},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":5}],"da":"treble","tc":2},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":5}],"da":"treble","tc":2},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":5}],"da":"treble","tc":2},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":5}],"da":"treble","tc":2},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":5}],"da":"treble","tc":2},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":5}],"da":"treble","tc":2},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":5}],"da":"treble","tc":2},{"fb":{"gb":8192,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":5}],"da":"treble"}]}],"ea":[]},{"ya":{"ya":16,"za":16,"ab":1,"t":0},"bb":6,"be":-18,"de":12,"cb":[],"db":[{"eb":[{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":5}],"da":"treble","qc":[{"rc":"staccato","sa":"SmoArticulation"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":8192,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":5}],"da":"treble"}]}],"ea":[]},{"ya":{"ya":17,"za":17,"ab":2,"t":0},"bb":6,"de":32,"cb":[],"db":[{"eb":[{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":8192,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":5}],"da":"treble"}]}],"ea":[]},{"ld":true,"ya":{"ya":18,"za":18,"ab":0,"t":0},"bb":41.5,"cb":[],"db":[{"eb":[{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":5}],"da":"treble","qc":[{"rc":"staccato","sa":"SmoArticulation"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":5}],"da":"treble"}]}],"ea":[]},{"ya":{"ya":19,"za":19,"ab":1,"t":0},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":6}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":6}],"da":"treble"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble"}]}],"ea":[]},{"ya":{"ya":20,"za":20,"ab":2,"t":0},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":5}],"da":"treble"}]}],"ea":[]},{"ya":{"ya":21,"za":21,"ab":3,"t":0},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":16384,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":4},{"jb":"g","lb":"n","kb":4},{"jb":"c","lb":"n","kb":5}],"da":"treble"}]}],"ea":[{"kd":2,"sa":"SmoBarline"}]}]},{"t":1,"u":10,"v":40,"w":0,"x":1600,"y":90,"q":0,"r":{},"z":{},"aa":{"ba":"Bass Clef Staff","ca":0,"da":"bass"},"ea":[{"fa":{"ga":1,"ha":1,"ia":0,"ja":0,"ka":[0]},"la":{"ga":1,"ha":1,"ia":0,"ja":1,"ka":[]},"ma":0,"ua":4,"na":40,"oa":40,"sa":"SmoSlur"},{"fa":{"ga":1,"ha":2,"ia":0,"ja":1,"ka":[]},"la":{"ga":1,"ha":2,"ia":0,"ja":4,"ka":[]},"ma":0,"ua":4,"na":40,"oa":40,"sa":"SmoSlur"},{"fa":{"ga":1,"ha":2,"ia":0,"ja":5,"ka":[]},"la":{"ga":1,"ha":3,"ia":0,"ja":0,"ka":[]},"ma":0,"ua":4,"na":40,"oa":40,"sa":"SmoSlur"},{"fa":{"ga":1,"ha":3,"ia":0,"ja":1,"ka":[]},"la":{"ga":1,"ha":3,"ia":0,"ja":6,"ka":[]},"ma":0,"ua":4,"na":40,"oa":40,"sa":"SmoSlur"},{"fa":{"ga":1,"ha":15,"ia":0,"ja":0,"ka":[]},"la":{"ga":1,"ha":15,"ia":0,"ja":1,"ka":[]},"ma":0,"ua":4,"na":40,"oa":40,"sa":"SmoSlur"},{"fa":{"ga":1,"ha":16,"ia":0,"ja":0,"ka":[0]},"la":{"ga":1,"ha":16,"ia":0,"ja":1,"ka":[]},"ma":0,"ua":4,"na":40,"oa":40,"sa":"SmoSlur"},{"fa":{"ga":1,"ha":3,"ia":0,"ja":4,"ka":[]},"la":{"ga":1,"ha":3,"ia":0,"ja":6,"ka":[]},"sa":"SmoStaffHairpin"},{"fa":{"ga":1,"ha":17,"ia":0,"ja":0,"ka":[]},"la":{"ga":1,"ha":17,"ia":0,"ja":1,"ka":[]},"ua":4,"sa":"SmoSlur"}],"va":[{"ya":{"ya":0,"za":0,"ab":0,"t":1},"da":"bass","bb":59.980000000000004,"cb":[],"db":[{"eb":[{"fb":{"gb":8192,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":3}],"oc":"r","da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":3}],"oc":"r","da":"bass","rb":true,"qb":1024},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":3}],"da":"bass","rb":true},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":3}],"da":"bass","rb":true}]}],"ea":[]},{"ya":{"ya":1,"za":1,"ab":1,"t":1},"da":"bass","bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":2}],"da":"bass","qc":[{"rc":"staccato","sa":"SmoArticulation"}]},{"ka":[{"jb":"d","lb":"n","kb":3}],"oc":"r","da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":3}],"oc":"r","da":"bass","rb":true},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":3}],"da":"bass","rb":true},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":4}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3}],"da":"bass","rb":true}]}],"ea":[]},{"ya":{"ya":2,"za":2,"ab":2,"t":1},"da":"bass","bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":4}],"da":"bass","qb":8192},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":3}],"da":"bass","qb":8192},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":4}],"da":"bass","qb":8192},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":4}],"da":"bass","rb":true,"qb":8192},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":4}],"da":"bass","qb":8192},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3}],"da":"bass","qb":8192},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":3}],"da":"bass","qb":8192},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":3}],"da":"bass","rb":true,"qb":8192}]}],"ea":[]},{"ya":{"ya":3,"za":3,"ab":0,"t":1},"da":"bass","bb":41.5,"cb":[],"db":[{"eb":[{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":4}],"da":"bass","qb":8192},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":3}],"da":"bass","qb":8192},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"#","kb":3}],"da":"bass","qb":8192},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3}],"da":"bass","rb":true,"qb":8192},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":3}],"da":"bass"},{"ka":[{"jb":"c","lb":"n","kb":4}],"da":"bass"}]}],"ea":[]},{"ya":{"ya":4,"za":4,"ab":1,"t":1},"da":"bass","bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":4}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"#","kb":3}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"#","kb":3}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3}],"da":"bass","qb":8192},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":2}],"da":"bass","qb":8192},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":3}],"da":"bass","qb":8192},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":3}],"da":"bass","rb":true,"qb":8192}]}],"ea":[]},{"ya":{"ya":5,"za":5,"ab":2,"t":1},"da":"bass","bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":3}],"da":"bass","qb":8192},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"#","kb":3}],"da":"bass","qb":8192},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3}],"da":"bass","qb":8192},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":3}],"da":"bass","rb":true,"qb":8192},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":2}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":3}],"da":"bass","tc":1},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":2}],"da":"bass","tc":1,"qc":[{"ua":"below","rc":"staccato","sa":"SmoArticulation"}]}]}],"ea":[]},{"ya":{"ya":6,"za":6,"ab":0,"t":1},"da":"bass","bb":41.5,"cb":[],"db":[{"eb":[{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":2}],"oc":"r","da":"bass","rb":true},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":2}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":2}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":2}],"da":"bass","rb":true},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":2}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":2}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":2}],"da":"bass"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":3}],"da":"bass","qb":8192},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3}],"da":"bass","qb":8192},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"#","kb":3}],"da":"bass","qb":8192},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3}],"da":"bass","rb":true,"qb":8192}]}],"ea":[]},{"ya":{"ya":7,"za":7,"ab":1,"t":1},"da":"bass","bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":3}],"da":"bass","qc":[{"rc":"staccato","sa":"SmoArticulation"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"#","kb":3}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"#","kb":3}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":3}],"da":"bass","qb":8192},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":4}],"da":"bass","qb":8192},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":4}],"da":"bass","qb":8192},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":4}],"da":"bass","rb":true,"qb":8192}]}],"ea":[]},{"ya":{"ya":8,"za":8,"ab":2,"t":1},"bb":41.5,"cb":[],"db":[{"eb":[{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3}],"da":"treble","qc":[{"ua":"below","rc":"staccato","sa":"SmoArticulation"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":4,"pc":true}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":4}],"da":"treble","rb":true},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","qb":8192},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":4}],"da":"treble","qb":8192},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","qb":8192},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":4}],"da":"treble","rb":true,"qb":8192}]}],"ea":[]},{"ld":true,"ya":{"ya":9,"za":9,"ab":0,"t":1},"bb":41.5,"cb":[],"db":[{"eb":[{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":4}],"da":"treble"}]}],"ea":[]},{"ya":{"ya":10,"za":10,"ab":1,"t":1},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble"}]}],"ea":[]},{"ya":{"ya":11,"za":11,"ab":2,"t":1},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":3}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":3}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":3}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"#","kb":3}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":3}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":3}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":4}],"da":"treble"}]}],"ea":[]},{"ya":{"ya":12,"za":12,"ab":0,"t":1},"da":"bass","bb":41.5,"cb":[],"db":[{"eb":[{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":4}],"da":"bass"},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":4}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":4}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":4}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3,"pc":true}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"#","kb":3}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"#","kb":3}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":3}],"da":"bass"}]}],"ea":[]},{"ya":{"ya":13,"za":13,"ab":1,"t":1},"da":"bass","bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":4}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":4}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":4}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":4}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":4}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":4}],"da":"bass"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":4}],"da":"bass"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":4}],"da":"bass"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":3}],"da":"bass"}]}],"ea":[]},{"ya":{"ya":14,"za":14,"ab":2,"t":1},"da":"bass","bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":3}],"da":"bass"},{"ka":[{"jb":"c","lb":"n","kb":4}],"oc":"r","da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":4}],"oc":"r","da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":4}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":4}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":4}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":4}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"#","kb":4}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":4}],"da":"bass"}]}],"ea":[]},{"ld":true,"ya":{"ya":15,"za":15,"ab":0,"t":1},"da":"bass","bb":41.5,"be":-14,"cb":[],"db":[{"eb":[{"fb":{"gb":8192,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":4}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":4}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":4}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":4}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":4}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":3}],"da":"bass"}]}],"ea":[]},{"ya":{"ya":16,"za":16,"ab":1,"t":1},"da":"bass","bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":8192,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":4}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":4}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":4}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":4}],"da":"bass"}]}],"ea":[]},{"ya":{"ya":17,"za":17,"ab":2,"t":1},"da":"bass","bb":6,"be":-8,"de":12,"cb":[],"db":[{"eb":[{"fb":{"gb":8192,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":4}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":4}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":3}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":4}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":3}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3}],"da":"bass"}]}],"ea":[]},{"ld":true,"ya":{"ya":18,"za":18,"ab":0,"t":1},"da":"bass","bb":41.5,"be":-15,"cb":[],"db":[{"eb":[{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":3}],"da":"bass","qb":8192},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":3}],"da":"bass","qb":8192},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":3}],"da":"bass","qb":8192},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3}],"da":"bass","rb":true,"qb":8192},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":3}],"da":"bass","qb":8192},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":4}],"da":"bass","qb":8192},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":4}],"da":"bass","qb":8192},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":3}],"da":"bass","rb":true,"qb":8192}]}],"ea":[]},{"ya":{"ya":19,"za":19,"ab":1,"t":1},"da":"bass","bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":4}],"da":"bass"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":4}],"da":"bass"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":4}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":4}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":3}],"da":"bass"}]}],"ea":[]},{"ya":{"ya":20,"za":20,"ab":2,"t":1},"da":"bass","bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":2}],"da":"bass","qc":[{"rc":"staccato","sa":"SmoArticulation"}]}]}],"ea":[]},{"ya":{"ya":21,"za":21,"ab":3,"t":1},"da":"bass","bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":16384,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":2},{"jb":"c","lb":"n","kb":3}],"da":"bass"}]}],"ea":[{"kd":2,"sa":"SmoBarline"}]}]}],"yc":[],"ge":[{"he":[{"tb":{"sa":"SmoScoreText","pa":{"qa":"auto10872","ra":"SmoScoreText"},"zc":{},"ad":false,"jc":450,"kc":142,"tb":"15 Inventions  2 voix.","bd":"every","ua":"custom","vb":{"wb":"24pt","xb":"Source Serif Pro","yb":"normal","zb":"normal","te":24},"ac":"score-text auto3276 auto1875 auto1874 auto1873 auto7616 auto65353 auto1996 auto10872","cd":"none","dd":"left","cc":"black","lc":0,"mc":0,"dc":1,"ec":1,"fc":0,"gc":0,"ed":false,"ic":{"jc":832.68,"kc":-719.28,"lc":276.9,"mc":35.01},"nc":{"jc":450,"kc":112.39,"lc":315.23,"mc":39.86}},"ua":4}],"bd":1,"sa":"SmoTextGroup"},{"he":[{"tb":{"sa":"SmoScoreText","pa":{"qa":"auto10874","ra":"SmoScoreText"},"zc":{},"ad":false,"jc":1055.3413208007814,"kc":94.0898252563477,"tb":"JS Bach","bd":"once","ua":"custom","vb":{"wb":"16pt","xb":"Merriweather","yb":"normal","zb":"normal","te":16},"ac":"score-text auto177204 auto1875 auto10874","cd":"none","dd":"left","cc":"black","lc":0,"mc":0,"dc":1,"ec":1,"fc":0,"gc":0,"ed":false,"ic":{"jc":1363.41,"kc":-753.35,"lc":69.67,"mc":23.02},"nc":{"jc":1054.19,"kc":73.59,"lc":79.31,"mc":26.2}},"ua":2},{"tb":{"sa":"SmoScoreText","pa":{"qa":"auto10875","ra":"SmoScoreText"},"zc":{},"ad":false,"jc":1055.3413208007814,"kc":94.0898252563477,"tb":"Page ### of @@@","bd":"once","ua":"custom","vb":{"wb":"16pt","xb":"Merriweather","yb":"normal","zb":"normal","te":16},"ac":"score-text auto177204 auto235769 auto1876 auto10875","cd":"none","dd":"left","cc":"black","lc":0,"mc":0,"dc":1,"ec":1,"fc":0,"gc":0,"ed":false,"ic":{"jc":1364.41,"kc":-727.29,"lc":95.88,"mc":24.01},"nc":{"jc":1055.33,"kc":103.27,"lc":109.16,"mc":27.33}},"ua":2}],"ue":10,"bd":1,"sa":"SmoTextGroup"}],"yd":[{"zd":0,"la":{"ga":1,"ha":0},"sa":"SmoSystemGroup"}],"ee":{"wa":{"0":"4/4"},"xa":{"0":"C"},"fe":{"0":{"sa":"SmoTempoText","pa":{"qa":"auto10019","ra":"SmoTempoText"},"id":"text","nb":96,"ob":true,"pb":4096,"jd":"Moderato","ta":0}}},"dictionary":{"a":"score","b":"layout","c":"leftMargin","d":"rightMargin","e":"topMargin","f":"bottomMargin","g":"pageWidth","h":"pageHeight","i":"orientation","j":"interGap","k":"intraGap","l":"svgScale","m":"zoomScale","n":"zoomMode","o":"pages","p":"pageSize","q":"startIndex","r":"renumberingMap","s":"staves","t":"staffId","u":"staffX","v":"staffY","w":"adjY","x":"staffWidth","y":"staffHeight","z":"keySignatureMap","aa":"instrumentInfo","ba":"instrumentName","ca":"keyOffset","da":"clef","ea":"modifiers","fa":"startSelector","ga":"staff","ha":"measure","ia":"voice","ja":"tick","ka":"pitches","la":"endSelector","ma":"xOffset","na":"cp1y","oa":"cp2y","pa":"attrs","qa":"id","ra":"type","sa":"ctor","ta":"yOffset","ua":"position","va":"measures","wa":"timeSignature","xa":"keySignature","ya":"measureNumber","za":"measureIndex","ab":"systemIndex","bb":"adjX","cb":"tuplets","db":"voices","eb":"notes","fb":"ticks","gb":"numerator","hb":"denominator","ib":"remainder","jb":"letter","kb":"octave","lb":"accidental","mb":"symbol","nb":"bpm","ob":"display","pb":"beatDuration","qb":"beamBeats","rb":"endBeam","sb":"textModifiers","tb":"text","ub":"endChar","vb":"fontInfo","wb":"size","xb":"family","yb":"style","zb":"weight","ac":"classes","bc":"verse","cc":"fill","dc":"scaleX","ec":"scaleY","fc":"translateX","gc":"translateY","hc":"selector","ic":"renderedBox","jc":"x","kc":"y","lc":"width","mc":"height","nc":"logicalBox","oc":"noteType","pc":"cautionary","qc":"articulations","rc":"articulation","sc":"activeVoice","tc":"flagState","uc":"invert","vc":"fontSize","wc":"yOffsetLine","xc":"yOffsetPixels","yc":"scoreText","zc":"backup","ad":"edited","bd":"pagination","cd":"boxModel","dd":"justification","ed":"autoLayout","fd":"ornaments","gd":"offset","hd":"ornament","id":"tempoMode","jd":"tempoText","kd":"barline","ld":"systemBreak","md":"graceNotes","nd":"tones","od":"tuplet","pd":"beam_group","qd":"renderId","rd":"numNotes","sd":"totalTicks","td":"stemTicks","ud":"durationMap","vd":"bracketed","wd":"ratioed","xd":"location","yd":"systemGroups","zd":"leftConnector","ae":"padLeft","be":"customStretch","ce":"engravingFont","de":"customProportion","ee":"columnAttributeMap","fe":"tempo","ge":"textGroups","he":"textBlocks","ie":"backupBlocks","je":"blocks","ke":"_text","le":"parser","me":"fonts","ne":"name","oe":"purpose","pe":"custom","qe":"transposeIndex","re":"noteHead","se":"slash","te":"pointSize","ue":"spacing","ve":"relativePosition"}}`;
;var jesuBambino = `{"a":{"b":{"c":50,"d":50,"e":72,"f":40,"g":816,"h":1056,"i":0,"j":40,"k":30,"l":0.6,"m":1.5,"n":2,"o":5,"p":"letter"},"q":0,"r":{},"me":[{"ne":"engraving","oe":1,"xb":"Bravura","wb":1,"pe":false},{"ne":"score","oe":2,"xb":"Merriweather","wb":14,"pe":false},{"ne":"chords","oe":3,"xb":"Roboto Slab","wb":14,"pe":false},{"ne":"lyrics","oe":4,"xb":"Merriweather","wb":12,"pe":false}],"hf":{"if":true,"jf":true,"kf":4096,"lf":6144,"de":12},"mf":{"ne":"Jesu Bambino","nf":2}},"s":[{"t":0,"u":10,"v":40,"w":0,"x":1600,"y":90,"q":0,"r":{},"z":{},"aa":{"ba":"Treble Instrument","ca":"0","da":"treble"},"ea":[{"fa":{"ga":0,"ha":1,"ia":0,"ja":0,"ka":[]},"la":{"ga":0,"ha":1,"ia":0,"ja":1,"ka":[]},"ma":0,"na":10,"oa":10,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":1,"ia":0,"ja":2,"ka":[]},"la":{"ga":0,"ha":1,"ia":0,"ja":3,"ka":[]},"ma":0,"ta":14,"na":10,"oa":30,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":3,"ia":0,"ja":0,"ka":[]},"la":{"ga":0,"ha":3,"ia":0,"ja":1,"ka":[]},"ma":0,"ua":4,"na":40,"oa":40,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":3,"ia":0,"ja":2,"ka":[]},"la":{"ga":0,"ha":3,"ia":0,"ja":3,"ka":[]},"ma":0,"ua":4,"na":40,"oa":40,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":3,"ia":0,"ja":4,"ka":[]},"la":{"ga":0,"ha":3,"ia":0,"ja":5,"ka":[]},"ma":0,"ua":4,"na":40,"oa":40,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":3,"ia":0,"ja":6,"ka":[]},"la":{"ga":0,"ha":3,"ia":0,"ja":7,"ka":[]},"ma":0,"ua":4,"na":40,"oa":40,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":4,"ia":0,"ja":0,"ka":[]},"la":{"ga":0,"ha":4,"ia":0,"ja":1,"ka":[]},"ma":0,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":4,"ia":0,"ja":2,"ka":[]},"la":{"ga":0,"ha":4,"ia":0,"ja":3,"ka":[]},"ma":0,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":4,"ia":0,"ja":4,"ka":[]},"la":{"ga":0,"ha":4,"ia":0,"ja":5,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":4,"ia":0,"ja":6,"ka":[]},"la":{"ga":0,"ha":4,"ia":0,"ja":7,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":1,"ia":0,"ja":4,"ka":[]},"la":{"ga":0,"ha":1,"ia":0,"ja":5,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":1,"ia":0,"ja":6,"ka":[]},"la":{"ga":0,"ha":1,"ia":0,"ja":7,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":16,"ia":0,"ja":0,"ka":[]},"la":{"ga":0,"ha":17,"ia":0,"ja":0,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":18,"ia":0,"ja":0,"ka":[]},"la":{"ga":0,"ha":18,"ia":0,"ja":1,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":18,"ia":0,"ja":2,"ka":[]},"la":{"ga":0,"ha":18,"ia":0,"ja":3,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":18,"ia":0,"ja":4,"ka":[]},"la":{"ga":0,"ha":18,"ia":0,"ja":5,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":18,"ia":0,"ja":6,"ka":[]},"la":{"ga":0,"ha":18,"ia":0,"ja":7,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":20,"ia":0,"ja":0,"ka":[]},"la":{"ga":0,"ha":20,"ia":0,"ja":1,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":20,"ia":0,"ja":2,"ka":[]},"la":{"ga":0,"ha":20,"ia":0,"ja":3,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":20,"ia":0,"ja":4,"ka":[]},"la":{"ga":0,"ha":20,"ia":0,"ja":5,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":20,"ia":0,"ja":6,"ka":[]},"la":{"ga":0,"ha":20,"ia":0,"ja":7,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":21,"ia":0,"ja":0,"ka":[]},"la":{"ga":0,"ha":21,"ia":0,"ja":1,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":21,"ia":0,"ja":2,"ka":[]},"la":{"ga":0,"ha":21,"ia":0,"ja":3,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":21,"ia":0,"ja":4,"ka":[]},"la":{"ga":0,"ha":21,"ia":0,"ja":5,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":21,"ia":0,"ja":6,"ka":[]},"la":{"ga":0,"ha":21,"ia":0,"ja":7,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":22,"ia":0,"ja":0,"ka":[]},"la":{"ga":0,"ha":22,"ia":0,"ja":1,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":22,"ia":0,"ja":2,"ka":[]},"la":{"ga":0,"ha":22,"ia":0,"ja":3,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":22,"ia":0,"ja":4,"ka":[]},"la":{"ga":0,"ha":22,"ia":0,"ja":5,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":22,"ia":0,"ja":6,"ka":[]},"la":{"ga":0,"ha":22,"ia":0,"ja":7,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":27,"ia":0,"ja":0,"ka":[]},"la":{"ga":0,"ha":27,"ia":0,"ja":1,"ka":[]},"ua":4,"sa":"SmoSlur"}],"va":[{"ya":{"ya":-1,"za":0,"ab":0,"t":0},"bb":92.30000000000001,"cb":[],"db":[{"eb":[{"fb":{"gb":"2048","hb":1,"ib":0},"ka":[{"jb":"d","kb":5,"lb":"n"}],"da":"treble","sb":[{"vb":{"ne":"lyrics","oe":4,"xb":"Merriweather","wb":12,"pe":false},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":""}]}]}],"ea":[]},{"ya":{"ya":0,"za":1,"ab":1,"t":0},"bb":6,"cb":[],"db":[{"eb":[{"ka":[{"jb":"b","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":6}],"da":"treble","qb":6144},{"ka":[{"jb":"a","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":6}],"da":"treble","rb":true,"qb":2048},{"ka":[{"jb":"b","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":6}],"da":"treble","qb":6144},{"ka":[{"jb":"c","lb":"n","kb":6}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":6}],"da":"treble","rb":true,"qb":2048}]}],"ea":[]},{"ya":{"ya":1,"za":2,"ab":2,"t":0},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":6}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":6}],"da":"treble","qb":6144},{"ka":[{"jb":"c","lb":"n","kb":6}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":12288,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"#","kb":5},{"jb":"a","lb":"n","kb":5}],"da":"treble","qb":6144}]}],"ea":[]},{"ya":{"ya":2,"za":3,"ab":3,"t":0},"bb":6,"cb":[],"db":[{"eb":[{"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144},{"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","rb":true,"qb":2048},{"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144},{"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","rb":true,"qb":2048}]}],"ea":[]},{"ya":{"ya":3,"za":4,"ab":4,"t":0},"bb":60.34,"cb":[],"db":[{"eb":[{"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144},{"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","rb":true,"qb":2048},{"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144},{"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","rb":true,"qb":2048}]}],"ea":[]},{"ya":{"ya":4,"za":5,"ab":5,"t":0},"bb":6,"cb":[],"db":[{"eb":[{"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144},{"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","rb":true,"qb":2048},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","qb":6144},{"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144}]}],"ea":[]},{"ya":{"ya":5,"za":6,"ab":6,"t":0},"bb":60.34,"cb":[],"db":[{"eb":[{"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144},{"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","rb":true,"qb":6144},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144},{"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","qb":6144}]}],"ea":[]},{"ya":{"ya":6,"za":7,"ab":7,"t":0},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","qb":6144},{"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble","qb":6144},{"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble","qb":6144}]}],"ea":[]},{"ld":true,"ya":{"ya":7,"za":8,"ab":8,"t":0},"bb":60.34,"cb":[],"db":[{"eb":[{"fb":{"gb":24576,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"oc":"r","da":"treble","qb":6144}]}],"ea":[]},{"ya":{"ya":8,"za":9,"ab":9,"t":0},"bb":6,"de":72,"cb":[],"db":[{"eb":[{"ka":[{"jb":"g","lb":"n","kb":4},{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"#","kb":4},{"jb":"a","lb":"n","kb":4}],"da":"treble","qb":6144},{"ka":[{"jb":"g","lb":"n","kb":4},{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"b","kb":4},{"jb":"d","lb":"n","kb":5}],"da":"treble","rb":true,"qb":2048},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4},{"jb":"e","lb":"b","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4},{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"b","kb":4,"pc":false}],"da":"treble","rb":true,"qb":6144},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":4},{"jb":"b","lb":"b","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":4},{"jb":"a","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":4},{"jb":"g","lb":"n","kb":4}],"da":"treble","rb":true,"qb":6144}]}],"ea":[]},{"ld":true,"ya":{"ya":9,"za":10,"ab":10,"t":0},"bb":60.34,"de":72,"cb":[],"db":[{"eb":[{"ka":[{"jb":"f","lb":"#","kb":4},{"jb":"a","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"#","kb":4},{"jb":"b","lb":"b","kb":4}],"da":"treble","qb":6144},{"ka":[{"jb":"e","lb":"b","kb":4},{"jb":"g","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"b","kb":4},{"jb":"g","lb":"n","kb":4}],"da":"treble","rb":true,"qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"#","kb":4},{"jb":"a","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"#","kb":4},{"jb":"b","lb":"b","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4},{"jb":"c","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4},{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4},{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144}]}],"ea":[]},{"ya":{"ya":10,"za":11,"ab":11,"t":0},"bb":6,"cb":[],"db":[{"eb":[{"ka":[{"jb":"c","lb":"n","kb":5},{"jb":"f","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5},{"jb":"f","lb":"n","kb":5}],"da":"treble","rb":true,"qb":6144},{"ka":[{"jb":"c","lb":"n","kb":5},{"jb":"f","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5},{"jb":"f","lb":"n","kb":5}],"da":"treble","qb":6144},{"ka":[{"jb":"c","lb":"n","kb":5},{"jb":"f","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5},{"jb":"f","lb":"n","kb":5}],"da":"treble","qb":6144},{"ka":[{"jb":"c","lb":"n","kb":5},{"jb":"f","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"da":"treble","qb":6144}]}],"ea":[]},{"ya":{"ya":11,"za":12,"ab":12,"t":0},"bb":85.22,"cb":[],"db":[{"eb":[{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"b","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"b","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"da":"treble","qb":6144},{"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":4}],"da":"treble","qb":6144}]}],"ea":[]},{"ya":{"ya":12,"za":13,"ab":13,"t":0},"bb":6,"cb":[],"db":[{"eb":[{"ka":[{"jb":"b","lb":"b","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"b","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":12288,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":5}],"da":"treble","qb":6144}]}],"ea":[]},{"ya":{"ya":13,"za":14,"ab":14,"t":0},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"b","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"b","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"da":"treble","qb":6144},{"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":4}],"da":"treble","qb":6144}]}],"ea":[]},{"ya":{"ya":14,"za":15,"ab":15,"t":0},"bb":6,"cb":[],"db":[{"eb":[{"ka":[{"jb":"b","lb":"b","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"da":"treble","rb":true,"qb":2048},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"b","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":12288,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":5}],"da":"treble","qb":6144}]}],"ea":[]},{"ya":{"ya":15,"za":16,"ab":16,"t":0},"bb":66.38,"cb":[],"db":[{"eb":[{"fb":{"gb":24576,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"da":"treble","qb":6144}]}],"ea":[]},{"ya":{"ya":16,"za":17,"ab":17,"t":0},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"oc":"r","da":"treble","qb":6144},{"fb":{"gb":12288,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"oc":"r","da":"treble","qb":6144}]}],"ea":[]},{"ld":true,"ya":{"ya":17,"za":18,"ab":18,"t":0},"bb":85.22,"cb":[],"db":[{"eb":[{"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144},{"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144},{"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144},{"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144}]}],"ea":[]},{"ya":{"ya":18,"za":19,"ab":19,"t":0},"bb":6,"ef":false,"cb":[],"db":[{"eb":[{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144},{"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":12288,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"#","kb":4},{"jb":"a","lb":"n","kb":4}],"da":"treble","qb":6144}]}],"ea":[]},{"ya":{"ya":19,"za":20,"ab":20,"t":0},"bb":60.34,"cb":[],"db":[{"eb":[{"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144},{"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144},{"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144},{"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144}]}],"ea":[]},{"ya":{"ya":20,"za":21,"ab":21,"t":0},"bb":6,"cb":[],"db":[{"eb":[{"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144},{"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144},{"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144},{"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144}]}],"ea":[]},{"ya":{"ya":21,"za":22,"ab":22,"t":0},"bb":60.34,"cb":[],"db":[{"eb":[{"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144},{"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144},{"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144},{"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144}]}],"ea":[]},{"ya":{"ya":22,"za":23,"ab":23,"t":0},"bb":6,"cb":[],"db":[{"eb":[{"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144},{"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","rb":true,"qb":6144},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144},{"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"tb":"f","sa":"SmoDynamicText"}]}]}],"ea":[]},{"ld":true,"ya":{"ya":23,"za":24,"ab":24,"t":0},"bb":60.34,"cb":[],"db":[{"eb":[{"ka":[{"jb":"g","lb":"n","kb":4},{"jb":"e","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4},{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144},{"ka":[{"jb":"g","lb":"n","kb":4},{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":4},{"jb":"a","lb":"b","kb":4}],"da":"treble","qb":6144},{"ka":[{"jb":"e","lb":"b","kb":4},{"jb":"g","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"b","kb":4},{"jb":"g","lb":"n","kb":4}],"da":"treble","rb":true,"qb":2048},{"ka":[{"jb":"d","lb":"n","kb":4},{"jb":"f","lb":"#","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":4},{"jb":"g","lb":"n","kb":4}],"da":"treble","rb":true,"qb":6144}]}],"ea":[]},{"ya":{"ya":24,"za":25,"ab":25,"t":0},"bb":6,"cb":[],"db":[{"eb":[{"ka":[{"jb":"c","lb":"n","kb":4},{"jb":"f","lb":"#","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":4},{"jb":"f","lb":"#","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"b","kb":4},{"jb":"g","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"b","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"#","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"b","kb":5}],"da":"treble","qb":6144},{"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","qb":6144}]}],"ea":[]},{"ld":true,"ya":{"ya":25,"za":26,"ab":26,"t":0},"bb":60.34,"cb":[],"db":[{"eb":[{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble","qb":6144},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"b","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":5}],"da":"treble","qb":6144}]}],"ea":[]},{"ya":{"ya":26,"za":27,"ab":27,"t":0},"bb":24.48,"cb":[],"db":[{"eb":[{"fb":{"gb":12288,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4},{"jb":"b","lb":"b","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4},{"jb":"b","lb":"b","kb":4}],"da":"treble","qb":6144}]}],"ea":[]},{"ya":{"ya":27,"za":28,"ab":28,"t":0},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3},{"jb":"b","lb":"b","kb":3}],"da":"treble","qb":6144,"qc":[{"rc":"fermata","sa":"SmoArticulation"}]},{"fb":{"gb":12288,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"oc":"r","da":"treble","qb":6144}]}],"ea":[]},{"ld":true,"ya":{"ya":28,"za":29,"ab":29,"t":0},"bb":92.30000000000001,"cb":[],"db":[{"eb":[{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":6}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":6}],"da":"treble","qb":6144},{"ka":[{"jb":"c","lb":"n","kb":6}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":12288,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"#","kb":5},{"jb":"a","lb":"n","kb":5}],"da":"treble","qb":6144}]}],"ea":[]},{"ya":{"ya":29,"za":30,"ab":30,"t":0},"bb":6,"cb":[],"db":[{"eb":[{"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144},{"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","rb":true,"qb":6144},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144}]}],"ea":[{"ua":1,"tb":"a tempo","sa":"SmoMeasureText"}]},{"ya":{"ya":30,"za":31,"ab":31,"t":0},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":12288,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":5}],"da":"treble","qb":6144,"qc":[{"rc":"fermata","sa":"SmoArticulation"}]}]}],"ea":[]}]},{"t":1,"u":10,"v":40,"w":0,"x":1600,"y":90,"q":0,"r":{},"z":{},"aa":{"ba":"Bass Clef Staff","ca":0,"da":"bass"},"ea":[{"fa":{"ga":1,"ha":3,"ia":0,"ja":0,"ka":[]},"la":{"ga":1,"ha":3,"ia":0,"ja":3,"ka":[]},"ma":0,"ua":4,"na":40,"oa":40,"sa":"SmoSlur"},{"fa":{"ga":1,"ha":4,"ia":0,"ja":0,"ka":[]},"la":{"ga":1,"ha":4,"ia":0,"ja":3,"ka":[]},"ma":0,"ua":4,"na":40,"oa":40,"sa":"SmoSlur"},{"fa":{"ga":1,"ha":5,"ia":0,"ja":0,"ka":[]},"la":{"ga":1,"ha":5,"ia":0,"ja":3,"ka":[]},"ma":0,"ua":4,"na":40,"oa":40,"sa":"SmoSlur"},{"fa":{"ga":1,"ha":20,"ia":0,"ja":0,"ka":[]},"la":{"ga":1,"ha":20,"ia":0,"ja":3,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":1,"ha":21,"ia":0,"ja":0,"ka":[]},"la":{"ga":1,"ha":21,"ia":0,"ja":3,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":1,"ha":22,"ia":0,"ja":0,"ka":[]},"la":{"ga":1,"ha":22,"ia":0,"ja":3,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":1,"ha":22,"ia":0,"ja":0,"ka":[]},"la":{"ga":1,"ha":22,"ia":0,"ja":3,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":1,"ha":22,"ia":0,"ja":0,"ka":[]},"la":{"ga":1,"ha":22,"ia":0,"ja":3,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":1,"ha":23,"ia":0,"ja":0,"ka":[]},"la":{"ga":1,"ha":23,"ia":0,"ja":3,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":1,"ha":27,"ia":0,"ja":0,"ka":[]},"la":{"ga":1,"ha":27,"ia":0,"ja":1,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":1,"ha":30,"ia":0,"ja":2,"ka":[]},"la":{"ga":1,"ha":31,"ia":0,"ja":0,"ka":[]},"ua":4,"sa":"SmoSlur"}],"va":[{"ya":{"ya":-1,"za":0,"ab":0,"t":1},"da":"bass","bb":92.30000000000001,"cb":[],"db":[{"eb":[{"fb":{"gb":"2048","hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble"}]}],"ea":[]},{"ya":{"ya":0,"za":1,"ab":1,"t":1},"da":"bass","bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3},{"jb":"b","lb":"n","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"#","kb":3},{"jb":"c","lb":"n","kb":4}],"da":"bass","qb":6144},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3},{"jb":"b","lb":"n","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":3},{"jb":"c","lb":"n","kb":4}],"da":"bass","qb":6144}]}],"ea":[]},{"ya":{"ya":1,"za":2,"ab":2,"t":1},"da":"bass","bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":12288,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3},{"jb":"b","lb":"n","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":12288,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":3}],"da":"bass","qb":6144}]}],"ea":[]},{"ya":{"ya":2,"za":3,"ab":3,"t":1},"da":"bass","bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"#","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":3}],"da":"bass","qb":6144}]}],"ea":[]},{"ya":{"ya":3,"za":4,"ab":4,"t":1},"da":"bass","bb":60.34,"cb":[],"db":[{"eb":[{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"#","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":3}],"da":"bass","qb":6144}]}],"ea":[]},{"ya":{"ya":4,"za":5,"ab":5,"t":1},"da":"bass","bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"#","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":3}],"da":"bass","qb":6144}]}],"ea":[]},{"ya":{"ya":5,"za":6,"ab":6,"t":1},"da":"bass","bb":60.34,"cb":[],"db":[{"eb":[{"ka":[{"jb":"g","lb":"n","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3}],"da":"bass","qb":6144},{"ka":[{"jb":"g","lb":"n","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":3}],"oc":"r","da":"bass","qb":6144},{"ka":[{"jb":"d","lb":"n","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":3}],"da":"bass","qb":6144},{"ka":[{"jb":"d","lb":"n","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":3}],"oc":"r","da":"bass","qb":6144}]}],"ea":[]},{"ya":{"ya":6,"za":7,"ab":7,"t":1},"da":"bass","bb":6,"cb":[],"db":[{"eb":[{"ka":[{"jb":"g","lb":"n","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3}],"oc":"r","da":"bass","qb":6144},{"ka":[{"jb":"g","lb":"n","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3}],"oc":"r","da":"bass","qb":6144},{"ka":[{"jb":"g","lb":"n","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"#","kb":3}],"da":"bass","qb":6144},{"ka":[{"jb":"g","lb":"n","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3}],"da":"bass","qb":6144}]}],"ea":[]},{"ld":true,"ya":{"ya":7,"za":8,"ab":8,"t":1},"da":"bass","bb":60.34,"cb":[],"db":[{"eb":[{"ka":[{"jb":"g","lb":"n","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3}],"oc":"r","da":"bass","qb":6144},{"ka":[{"jb":"g","lb":"n","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":3}],"oc":"r","da":"bass","qb":6144},{"ka":[{"jb":"g","lb":"n","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"#","kb":3}],"da":"bass","qb":6144},{"ka":[{"jb":"g","lb":"n","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3}],"da":"bass","qb":6144}]}],"ea":[]},{"ya":{"ya":8,"za":9,"ab":9,"t":1},"da":"bass","bb":6,"de":72,"cb":[],"db":[{"eb":[{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":4}],"da":"bass","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":3}],"da":"bass","qb":6144}]}],"ea":[]},{"ld":true,"ya":{"ya":9,"za":10,"ab":10,"t":1},"da":"bass","bb":60.34,"de":72,"cb":[],"db":[{"eb":[{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":4},{"jb":"d","lb":"n","kb":4}],"da":"bass","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":3}],"oc":"r","da":"bass","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":4}],"da":"bass","qb":6144},{"ka":[{"jb":"b","lb":"b","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":3}],"da":"bass","qb":6144},{"ka":[{"jb":"d","lb":"n","kb":4}],"da":"bass","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"b","kb":4}],"da":"bass","qb":6144},{"ka":[{"jb":"d","lb":"n","kb":4}],"da":"bass","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":4}],"da":"bass","qb":6144}]}],"ea":[]},{"ya":{"ya":10,"za":11,"ab":11,"t":1},"da":"bass","bb":6,"cb":[],"db":[{"eb":[{"ka":[{"jb":"a","lb":"n","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":3}],"da":"bass","qb":6144},{"ka":[{"jb":"a","lb":"n","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":3}],"da":"bass","qb":6144},{"ka":[{"jb":"a","lb":"n","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":3}],"da":"bass","qb":6144},{"ka":[{"jb":"a","lb":"n","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":3}],"oc":"r","da":"bass","qb":6144}]}],"ea":[]},{"ya":{"ya":11,"za":12,"ab":12,"t":1},"da":"bass","bb":85.22,"cb":[],"db":[{"eb":[{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":3},{"jb":"d","lb":"n","kb":4}],"da":"bass","qb":6144},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":3},{"jb":"e","lb":"b","kb":4}],"da":"bass","qb":6144},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":3},{"jb":"e","lb":"b","kb":4}],"da":"bass","qb":6144}]}],"ea":[]},{"ya":{"ya":12,"za":13,"ab":13,"t":1},"da":"bass","bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":3},{"jb":"d","lb":"n","kb":4}],"da":"bass","qb":6144},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":3},{"jb":"e","lb":"b","kb":4}],"da":"bass","qb":6144},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":3},{"jb":"e","lb":"b","kb":4}],"da":"bass","qb":6144}]}],"ea":[]},{"ya":{"ya":13,"za":14,"ab":14,"t":1},"da":"bass","bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":3},{"jb":"d","lb":"n","kb":4}],"da":"bass","qb":6144},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":3},{"jb":"e","lb":"b","kb":4}],"da":"bass","qb":6144},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":3},{"jb":"d","lb":"n","kb":4}],"da":"bass","qb":6144},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":3},{"jb":"e","lb":"b","kb":4}],"da":"bass","qb":6144}]}],"ea":[]},{"ya":{"ya":14,"za":15,"ab":15,"t":1},"da":"bass","bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":3},{"jb":"d","lb":"n","kb":4}],"da":"bass","qb":6144},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":3},{"jb":"e","lb":"b","kb":4}],"da":"bass","qb":6144},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":3},{"jb":"d","lb":"n","kb":4}],"da":"bass","qb":6144},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":3},{"jb":"c","lb":"n","kb":4}],"da":"bass","qb":6144}]}],"ea":[]},{"ya":{"ya":15,"za":16,"ab":16,"t":1},"sc":1,"da":"bass","bb":66.38,"cb":[],"db":[{"eb":[{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":3}],"da":"bass","qb":6144,"tc":2},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":3}],"da":"bass","qb":6144,"tc":2},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":3}],"da":"bass","qb":6144,"tc":2},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":3}],"da":"bass","qb":6144,"tc":2}]},{"eb":[{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":4}],"da":"bass","qb":6144,"tc":1},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"b","kb":4}],"da":"bass","qb":6144,"tc":1},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":4}],"da":"bass","qb":6144,"tc":1},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":4}],"da":"bass","qb":6144,"tc":1},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"b","kb":4}],"da":"bass","qb":6144,"tc":1},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":4}],"da":"bass","qb":6144,"tc":1},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":4}],"da":"bass","qb":6144,"tc":1},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"b","kb":4}],"da":"bass","qb":6144,"tc":1},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":4}],"da":"bass","qb":6144,"tc":1},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":4}],"da":"bass","qb":6144,"tc":1},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"b","kb":4}],"da":"bass","qb":6144,"tc":1},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":4}],"da":"bass","qb":6144,"tc":1}]}],"ea":[]},{"ya":{"ya":16,"za":17,"ab":17,"t":1},"sc":1,"da":"bass","bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":3}],"da":"bass","qb":6144,"tc":2},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":3}],"da":"bass","qb":6144,"tc":2},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":3}],"da":"bass","qb":6144,"tc":2},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":3}],"da":"bass","qb":6144,"tc":2}]},{"eb":[{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":4}],"da":"bass","qb":6144,"tc":1},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":4}],"da":"bass","qb":6144,"tc":1},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":3}],"da":"bass","qb":6144,"tc":1},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":4}],"da":"bass","qb":6144,"tc":1},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":3}],"da":"bass","qb":6144,"tc":1},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":3}],"da":"bass","qb":6144,"tc":1},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":3}],"da":"bass","qb":6144,"tc":1},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":3}],"da":"bass","qb":6144,"tc":1},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3}],"da":"bass","qb":6144,"tc":1},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":3}],"da":"bass","qb":6144,"tc":1},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":3}],"da":"bass","qb":6144,"tc":1},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":4}],"da":"bass","qb":6144,"tc":1}]}],"ea":[]},{"ld":true,"ya":{"ya":17,"za":18,"ab":18,"t":1},"da":"bass","bb":85.22,"cb":[],"db":[{"eb":[{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3},{"jb":"b","lb":"n","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"#","kb":3},{"jb":"c","lb":"n","kb":4}],"da":"bass","qb":6144},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3},{"jb":"b","lb":"n","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":3},{"jb":"c","lb":"n","kb":4}],"da":"bass","qb":6144}]}],"ea":[]},{"ya":{"ya":18,"za":19,"ab":19,"t":1},"da":"bass","bb":6,"ef":false,"cb":[],"db":[{"eb":[{"fb":{"gb":12288,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3},{"jb":"b","lb":"n","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":12288,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":3}],"da":"bass","qb":6144}]}],"ea":[]},{"ya":{"ya":19,"za":20,"ab":20,"t":1},"da":"bass","bb":60.34,"cb":[],"db":[{"eb":[{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"#","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":3}],"da":"bass","qb":6144}]}],"ea":[]},{"ya":{"ya":20,"za":21,"ab":21,"t":1},"da":"bass","bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"#","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":3}],"da":"bass","qb":6144}]}],"ea":[]},{"ya":{"ya":21,"za":22,"ab":22,"t":1},"da":"bass","bb":60.34,"cb":[],"db":[{"eb":[{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"#","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":3}],"da":"bass","qb":6144}]}],"ea":[]},{"ya":{"ya":22,"za":23,"ab":23,"t":1},"da":"bass","bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"#","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3}],"da":"bass","qb":6144},{"ka":[{"jb":"g","lb":"n","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3}],"da":"bass","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric"},{"tb":"f","sa":"SmoDynamicText"}]}]}],"ea":[]},{"ld":true,"ya":{"ya":23,"za":24,"ab":24,"t":1},"da":"bass","bb":60.34,"cb":[],"db":[{"eb":[{"ka":[{"jb":"g","lb":"n","kb":2}],"da":"bass","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":3}],"da":"bass","rb":true,"qb":6144},{"ka":[{"jb":"g","lb":"n","kb":2}],"da":"bass","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":2}],"da":"bass","qb":6144},{"ka":[{"jb":"c","lb":"n","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":2}],"da":"bass","qb":6144},{"ka":[{"jb":"b","lb":"b","kb":2}],"da":"bass","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":3}],"da":"bass","qb":6144}]}],"ea":[]},{"ya":{"ya":24,"za":25,"ab":25,"t":1},"da":"bass","bb":6,"cb":[],"db":[{"eb":[{"ka":[{"jb":"a","lb":"n","kb":2}],"da":"bass","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":3}],"da":"bass","rb":true,"qb":6144},{"ka":[{"jb":"g","lb":"n","kb":2}],"da":"bass","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":2}],"da":"bass","rb":true,"qb":6144},{"ka":[{"jb":"c","lb":"n","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":2}],"da":"bass","qb":6144},{"ka":[{"jb":"b","lb":"b","kb":2}],"da":"bass","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":2}],"da":"bass","qb":6144}]}],"ea":[]},{"ld":true,"ya":{"ya":25,"za":26,"ab":26,"t":1},"da":"bass","bb":60.34,"cb":[],"db":[{"eb":[{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":3}],"oc":"r","da":"bass","qb":6144},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":2}],"da":"bass","qb":6144},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":2}],"da":"bass","qb":6144},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":3}],"da":"bass","qb":6144}]}],"ea":[]},{"ya":{"ya":26,"za":27,"ab":27,"t":1},"da":"bass","bb":24.48,"cb":[],"db":[{"eb":[{"fb":{"gb":12288,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"b","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"b","kb":3}],"da":"bass","qb":6144}]}],"ea":[]},{"ya":{"ya":27,"za":28,"ab":28,"t":1},"da":"bass","bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"b","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":12288,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":3}],"oc":"r","da":"bass","qb":6144}]}],"ea":[]},{"ld":true,"ya":{"ya":28,"za":29,"ab":29,"t":1},"da":"bass","bb":92.30000000000001,"cb":[],"db":[{"eb":[{"fb":{"gb":12288,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3},{"jb":"b","lb":"n","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":12288,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":3}],"da":"bass","qb":6144,"qc":[{"rc":"fermata","sa":"SmoArticulation"}]}]}],"ea":[]},{"ya":{"ya":29,"za":30,"ab":30,"t":1},"da":"bass","bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"#","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":12288,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3}],"da":"bass","qb":6144}]}],"ea":[]},{"ya":{"ya":30,"za":31,"ab":31,"t":1},"da":"bass","bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3}],"da":"bass","qb":6144},{"fb":{"gb":12288,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3}],"da":"bass","qb":6144}]}],"ea":[]}]},{"t":2,"u":10,"v":40,"w":0,"x":1600,"y":90,"q":0,"r":{},"z":{},"aa":{"ba":"Treble Clef Staff","ca":0,"da":"treble"},"ea":[{"fa":{"ga":2,"ha":3,"ia":0,"ja":0,"ka":[]},"la":{"ga":2,"ha":3,"ia":0,"ja":1,"ka":[]},"ma":-10,"na":10,"oa":10,"sa":"SmoSlur"},{"fa":{"ga":2,"ha":3,"ia":0,"ja":3,"ka":[]},"la":{"ga":2,"ha":3,"ia":0,"ja":4,"ka":[]},"ma":-10,"ua":"2","na":10,"oa":10,"sa":"SmoSlur"},{"fa":{"ga":2,"ha":3,"ia":0,"ja":6,"ka":[]},"la":{"ga":2,"ha":3,"ia":0,"ja":7,"ka":[]},"ma":-10,"na":10,"oa":10,"sa":"SmoSlur"},{"fa":{"ga":2,"ha":4,"ia":0,"ja":5,"ka":[]},"la":{"ga":2,"ha":4,"ia":0,"ja":6,"ka":[]},"sa":"SmoSlur"},{"fa":{"ga":2,"ha":9,"ia":0,"ja":0,"ka":[]},"la":{"ga":2,"ha":9,"ia":0,"ja":1,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":2,"ha":8,"ia":0,"ja":6,"ka":[]},"la":{"ga":2,"ha":9,"ia":0,"ja":0,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":2,"ha":11,"ia":0,"ja":0,"ka":[]},"la":{"ga":2,"ha":11,"ia":0,"ja":1,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":2,"ha":11,"ia":0,"ja":1,"ka":[]},"la":{"ga":2,"ha":11,"ia":0,"ja":2,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":2,"ha":7,"ia":0,"ja":0,"ka":[]},"la":{"ga":2,"ha":7,"ia":0,"ja":1,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":2,"ha":7,"ia":0,"ja":3,"ka":[]},"la":{"ga":2,"ha":7,"ia":0,"ja":4,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":2,"ha":8,"ia":0,"ja":0,"ka":[]},"la":{"ga":2,"ha":8,"ia":0,"ja":1,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":2,"ha":8,"ia":0,"ja":3,"ka":[]},"la":{"ga":2,"ha":8,"ia":0,"ja":4,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":2,"ha":19,"ia":0,"ja":5,"ka":[]},"la":{"ga":2,"ha":19,"ia":0,"ja":6,"ka":[]},"ma":-14,"sa":"SmoSlur"},{"fa":{"ga":2,"ha":21,"ia":0,"ja":0,"ka":[]},"la":{"ga":2,"ha":21,"ia":0,"ja":1,"ka":[]},"ma":-14,"sa":"SmoSlur"},{"fa":{"ga":2,"ha":20,"ia":0,"ja":0,"ka":[]},"la":{"ga":2,"ha":20,"ia":0,"ja":9,"ka":[]},"uc":true,"sa":"SmoSlur"},{"fa":{"ga":2,"ha":21,"ia":0,"ja":3,"ka":[]},"la":{"ga":2,"ha":21,"ia":0,"ja":4,"ka":[]},"ma":-10,"sa":"SmoSlur"},{"fa":{"ga":2,"ha":21,"ia":0,"ja":6,"ka":[]},"la":{"ga":2,"ha":21,"ia":0,"ja":7,"ka":[]},"ma":-12,"sa":"SmoSlur"},{"fa":{"ga":2,"ha":24,"ia":0,"ja":0,"ka":[]},"la":{"ga":2,"ha":24,"ia":0,"ja":1,"ka":[]},"ma":-10,"sa":"SmoSlur"},{"fa":{"ga":2,"ha":28,"ia":0,"ja":0,"ka":[]},"la":{"ga":2,"ha":28,"ia":0,"ja":1,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":2,"ha":29,"ia":0,"ja":0,"ka":[]},"la":{"ga":2,"ha":29,"ia":0,"ja":4,"ka":[]},"ua":4,"sa":"SmoSlur"}],"va":[{"ya":{"ya":-1,"za":0,"ab":0,"t":2},"bb":92.30000000000001,"cb":[],"db":[{"eb":[{"fb":{"gb":"2048","hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble","qb":6144}]}],"ea":[]},{"ya":{"ya":0,"za":1,"ab":1,"t":2},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":24576,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble","qb":6144}]}],"ea":[]},{"ya":{"ya":1,"za":2,"ab":2,"t":2},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":12288,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble","qb":6144},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble","qb":6144},{"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"Ne-"}]}]}],"ea":[]},{"ya":{"ya":2,"za":3,"ab":3,"t":2},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"ll'u-"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"u "}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"ni "}]},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"mile-"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"i "}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"cap-"}]},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"a "}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"-"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"-"}]},{"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"nna"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"nel"}]}]}],"ea":[]},{"ya":{"ya":3,"za":4,"ab":4,"t":2},"bb":60.34,"de":32,"cb":[],"db":[{"eb":[{"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"fre-"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","rb":true,"qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"ddo"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"e"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"po-"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","rb":true,"qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"ver-"}]},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"ta"}]},{"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble","qb":6144}]}],"ea":[]},{"ya":{"ya":4,"za":5,"ab":5,"t":2},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":24576,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble","qb":6144}]}],"ea":[]},{"ya":{"ya":5,"za":6,"ab":6,"t":2},"bb":60.34,"cb":[],"db":[{"eb":[{"fb":{"gb":12288,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble","qb":6144},{"fb":{"gb":8192,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"O-"}]}]}],"ea":[]},{"ya":{"ya":6,"za":7,"ab":7,"t":2},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"sa-"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"#","kb":5}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"nna"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"O"}]},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"sa-"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"#","kb":5}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"-"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"nna"}]},{"ka":[{"jb":"e","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"can"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","rb":true,"qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"ta-"}]},{"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"no"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"con"}]}]}],"ea":[]},{"ld":true,"ya":{"ya":7,"za":8,"ab":8,"t":2},"bb":60.34,"cb":[],"db":[{"eb":[{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"gui-"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"#","kb":5}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"-"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":5}],"da":"treble","rb":true,"qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"bi"}]},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"lan-"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"#","kb":5}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"-"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":5}],"da":"treble","rb":true,"qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"te"}]},{"fb":{"gb":12288,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"cor"}]}]}],"ea":[]},{"ya":{"ya":8,"za":9,"ab":9,"t":2},"bb":6,"de":62,"cb":[],"db":[{"eb":[{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144},{"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","rb":true,"qb":2048,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"I"}]},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"b","kb":5}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"tuo"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"-"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"i"}]},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"pa-"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"sto-"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"ri"}]}]}],"ea":[]},{"ld":true,"ya":{"ya":9,"za":10,"ab":10,"t":2},"bb":60.34,"cb":[],"db":[{"eb":[{"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"an-"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"gel-"}]},{"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"i"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"o"}]},{"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"re-"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"di"}]},{"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"luce"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"e'a"}]}]}],"ea":[]},{"ya":{"ya":10,"za":11,"ab":11,"t":2},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":12288,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"more"}]},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":5}],"da":"treble","qb":6144},{"ka":[{"jb":"f","lb":"n","kb":5}],"da":"treble","qb":6144,"qc":[{"ua":"below","rc":"fermata","sa":"SmoArticulation"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble","qb":6144}]}],"ea":[]},{"ya":{"ya":11,"za":12,"ab":12,"t":2},"bb":85.22,"cb":[],"db":[{"eb":[{"fb":{"gb":24576,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"oc":"r","da":"treble","qb":6144}]}],"ea":[]},{"ya":{"ya":12,"za":13,"ab":13,"t":2},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":24576,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"oc":"r","da":"treble","qb":6144}]}],"ea":[]},{"ya":{"ya":13,"za":14,"ab":14,"t":2},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":24576,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"oc":"r","da":"treble","qb":6144}]}],"ea":[]},{"ya":{"ya":14,"za":15,"ab":15,"t":2},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":24576,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"oc":"r","da":"treble","qb":6144}]}],"ea":[]},{"ya":{"ya":15,"za":16,"ab":16,"t":2},"bb":66.38,"cb":[],"db":[{"eb":[{"fb":{"gb":24576,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"oc":"r","da":"treble","qb":6144}]}],"ea":[]},{"ya":{"ya":16,"za":17,"ab":17,"t":2},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":12288,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"oc":"r","da":"treble","qb":6144},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"oc":"r","da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"oc":"r","da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"oc":"r","da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":2048,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"Ah-"}]}]}],"ea":[]},{"ld":true,"ya":{"ya":17,"za":18,"ab":18,"t":2},"bb":85.22,"de":32,"cb":[],"db":[{"eb":[{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"-"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"-"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":""}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":""}]},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"-"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","qb":6144},{"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"Ve"}]}]}],"ea":[]},{"ya":{"ya":18,"za":19,"ab":19,"t":2},"bb":6,"de":32,"ef":false,"cb":[],"db":[{"eb":[{"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"ni-"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","rb":true,"qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"te"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"a-"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"do-"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"re-"}]},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"mus"}]},{"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"Ah!"}]}]}],"ea":[]},{"ya":{"ya":19,"za":20,"ab":20,"t":2},"bb":60.34,"cb":[],"db":[{"eb":[{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"-"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":""}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"-"}]},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":""}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"-"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":""}]},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"-"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","qb":6144},{"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":4}],"da":"treble","qb":2048,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"a-"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":4}],"da":"treble","rb":true,"qb":2048,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"do"}]}]}],"ea":[]},{"ya":{"ya":20,"za":21,"ab":21,"t":2},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"re-"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"-"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"mus"}]},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"Do-"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"-"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"mi-"}]},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"num"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","rb":true,"qb":2048},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"ve-"}]}]}],"ea":[]},{"ya":{"ya":21,"za":22,"ab":22,"t":2},"bb":60.34,"cb":[],"db":[{"eb":[{"fb":{"gb":12288,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"ni-"}]},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"te"}]},{"ka":[{"jb":"d","lb":"n","kb":5}],"oc":"r","da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"ve-"},{"wc":2,"tb":"p","sa":"SmoDynamicText"}]}]}],"ea":[]},{"ya":{"ya":22,"za":23,"ab":23,"t":2},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":12288,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"ni-"}]},{"fb":{"gb":12288,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"te"}]}]}],"ea":[]},{"ld":true,"ya":{"ya":23,"za":24,"ab":24,"t":2},"bb":60.34,"cb":[],"db":[{"eb":[{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144},{"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","rb":true,"qb":2048,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"ve-"}]},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"b","kb":5}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"ni-"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"-"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","rb":true,"qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"te"}]},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"a"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"-"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"dor-"}]}]}],"ea":[]},{"ya":{"ya":24,"za":25,"ab":25,"t":2},"bb":6,"cb":[],"db":[{"eb":[{"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"re"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"-"}]},{"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"mus"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"oc":"r","da":"treble","rb":true,"qb":2048},{"fb":{"gb":12288,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"oc":"r","da":"treble","qb":6144}]}],"ea":[]},{"ld":true,"ya":{"ya":25,"za":26,"ab":26,"t":2},"bb":60.34,"cb":[],"db":[{"eb":[{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble","qb":6144},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"A-"}]},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"b","kb":5}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":""}]},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"do-"}]}]}],"ea":[]},{"ya":{"ya":26,"za":27,"ab":27,"t":2},"bb":24.48,"cb":[],"db":[{"eb":[{"fb":{"gb":12288,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":5}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"-"}]},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"re-"}]}]}],"ea":[]},{"ya":{"ya":27,"za":28,"ab":28,"t":2},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":12288,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"b","kb":5}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"mus"}],"qc":[{"rc":"fermata","sa":"SmoArticulation"}]},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"b","kb":5}],"da":"treble","qb":6144}]}],"ea":[]},{"ld":true,"ya":{"ya":28,"za":29,"ab":29,"t":2},"bb":92.30000000000001,"cb":[],"db":[{"eb":[{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"Do"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":""}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"-"}]},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":""}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":""}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"mi"}]},{"fb":{"gb":12288,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"num"}],"qc":[{"rc":"fermata","sa":"SmoArticulation"}]}]}],"ea":[]},{"ya":{"ya":29,"za":30,"ab":30,"t":2},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":24576,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble","qb":6144}]}],"ea":[]},{"ya":{"ya":30,"za":31,"ab":31,"t":2},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":24576,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble","qb":6144}]}],"ea":[]}]},{"t":3,"u":10,"v":40,"w":0,"x":1600,"y":90,"q":0,"r":{},"z":{},"aa":{"ba":"Treble Clef Staff","ca":0,"da":"treble"},"ea":[{"fa":{"ga":3,"ha":6,"ia":0,"ja":6,"ka":[]},"la":{"ga":3,"ha":6,"ia":0,"ja":7,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":3,"ha":6,"ia":0,"ja":6,"ka":[]},"la":{"ga":3,"ha":6,"ia":0,"ja":7,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":3,"ha":11,"ia":0,"ja":0,"ka":[]},"la":{"ga":3,"ha":11,"ia":0,"ja":1,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":3,"ha":11,"ia":0,"ja":1,"ka":[]},"la":{"ga":3,"ha":11,"ia":0,"ja":2,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":3,"ha":7,"ia":0,"ja":0,"ka":[]},"la":{"ga":3,"ha":7,"ia":0,"ja":1,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":3,"ha":7,"ia":0,"ja":3,"ka":[]},"la":{"ga":3,"ha":7,"ia":0,"ja":4,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":3,"ha":8,"ia":0,"ja":0,"ka":[]},"la":{"ga":3,"ha":8,"ia":0,"ja":1,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":3,"ha":8,"ia":0,"ja":3,"ka":[]},"la":{"ga":3,"ha":8,"ia":0,"ja":4,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":3,"ha":20,"ia":0,"ja":0,"ka":[]},"la":{"ga":3,"ha":20,"ia":0,"ja":1,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":3,"ha":22,"ia":0,"ja":6,"ka":[]},"la":{"ga":3,"ha":22,"ia":0,"ja":7,"ka":[]},"ma":-9,"sa":"SmoSlur"},{"fa":{"ga":3,"ha":24,"ia":0,"ja":0,"ka":[]},"la":{"ga":3,"ha":24,"ia":0,"ja":1,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":3,"ha":25,"ia":0,"ja":0,"ka":[]},"la":{"ga":3,"ha":25,"ia":0,"ja":1,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":3,"ha":18,"ia":0,"ja":4,"ka":[]},"la":{"ga":3,"ha":19,"ia":0,"ja":3,"ka":[]},"uc":true,"sa":"SmoSlur"},{"fa":{"ga":3,"ha":28,"ia":0,"ja":0,"ka":[]},"la":{"ga":3,"ha":28,"ia":0,"ja":1,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":3,"ha":20,"ia":0,"ja":3,"ka":[]},"la":{"ga":3,"ha":20,"ia":0,"ja":8,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":3,"ha":29,"ia":0,"ja":0,"ka":[]},"la":{"ga":3,"ha":29,"ia":0,"ja":4,"ka":[]},"sa":"SmoSlur"},{"fa":{"ga":3,"ha":22,"ia":0,"ja":0,"ka":[]},"la":{"ga":3,"ha":22,"ia":0,"ja":1,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":3,"ha":22,"ia":0,"ja":3,"ka":[]},"la":{"ga":3,"ha":22,"ia":0,"ja":4,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":3,"ha":23,"ia":0,"ja":0,"ka":[]},"la":{"ga":3,"ha":23,"ia":0,"ja":1,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":3,"ha":23,"ia":0,"ja":3,"ka":[]},"la":{"ga":3,"ha":23,"ia":0,"ja":4,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":3,"ha":5,"ia":0,"ja":0,"ka":[]},"la":{"ga":3,"ha":5,"ia":0,"ja":1,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":3,"ha":5,"ia":0,"ja":3,"ka":[]},"la":{"ga":3,"ha":5,"ia":0,"ja":4,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":3,"ha":5,"ia":0,"ja":6,"ka":[]},"la":{"ga":3,"ha":5,"ia":0,"ja":7,"ka":[]},"ua":4,"sa":"SmoSlur"}],"va":[{"ya":{"ya":-1,"za":0,"ab":0,"t":3},"bb":92.30000000000001,"cb":[],"db":[{"eb":[{"fb":{"gb":"2048","hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble","qb":6144}]}],"ea":[]},{"ya":{"ya":0,"za":1,"ab":1,"t":3},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":24576,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble","qb":6144}]}],"ea":[]},{"ya":{"ya":1,"za":2,"ab":2,"t":3},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":24576,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144}]}],"ea":[]},{"ya":{"ya":2,"za":3,"ab":3,"t":3},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":24576,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble","qb":6144}]}],"ea":[]},{"ya":{"ya":3,"za":4,"ab":4,"t":3},"bb":60.34,"de":32,"cb":[],"db":[{"eb":[{"fb":{"gb":12288,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble","qb":6144},{"fb":{"gb":8192,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"e"}]}]}],"ea":[]},{"ya":{"ya":4,"za":5,"ab":5,"t":3},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"na-"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"to"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"il"}]},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"Sa-"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":""}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"nto"}]},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"pa-"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"-"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","rb":true,"qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"rgo-"}]},{"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"lo"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":4}],"da":"treble","qb":2048,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"che-"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":4}],"da":"treble","rb":true,"qb":2048,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"il"}]}]}],"ea":[]},{"ya":{"ya":5,"za":6,"ab":6,"t":3},"bb":60.34,"cb":[],"db":[{"eb":[{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"mo-"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"-"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"ndo"}]},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"a-"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"do-"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"re"}]},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"ra"}]},{"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric"},{"tb":"f","sa":"SmoDynamicText"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"O-"}]}]}],"ea":[]},{"ya":{"ya":6,"za":7,"ab":7,"t":3},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"sa-"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"nna"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"O"}]},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"sa-"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"-"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"na"}]},{"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"can-"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","rb":true,"qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"ta-"}]},{"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"no"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"con"}]}]}],"ea":[]},{"ld":true,"ya":{"ya":7,"za":8,"ab":8,"t":3},"bb":60.34,"cb":[],"db":[{"eb":[{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"gui-"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"-"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":5}],"da":"treble","rb":true,"qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"bi"}]},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"lan-"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"-"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","rb":true,"qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"te"}]},{"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"cor"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"con"}]},{"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"bui-"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"bi-"}]}]}],"ea":[]},{"ya":{"ya":8,"za":9,"ab":9,"t":3},"bb":6,"de":62,"cb":[],"db":[{"eb":[{"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"la-"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"nte"}]},{"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"core"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","rb":true,"qb":2048,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"I"}]},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"tuo-"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":" "}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"i"}]},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"pa-"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"sto-"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"ri"}]}]}],"ea":[]},{"ld":true,"ya":{"ya":9,"za":10,"ab":10,"t":3},"bb":60.34,"cb":[],"db":[{"eb":[{"ka":[{"jb":"f","lb":"#","kb":4}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"an-"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"#","kb":4}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"gel-"}]},{"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"i "}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"o"}]},{"ka":[{"jb":"f","lb":"#","kb":4}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"re-"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"di "}]},{"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"luce"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"e'a"}]}]}],"ea":[]},{"ya":{"ya":10,"za":11,"ab":11,"t":3},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":12288,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"more"}]},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble","qb":6144},{"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble","qb":6144,"qc":[{"rc":"fermata","sa":"SmoArticulation"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble","qb":6144}]}],"ea":[]},{"ya":{"ya":11,"za":12,"ab":12,"t":3},"bb":85.22,"cb":[],"db":[{"eb":[{"fb":{"gb":24576,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"oc":"r","da":"treble","qb":6144}]}],"ea":[]},{"ya":{"ya":12,"za":13,"ab":13,"t":3},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":24576,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"oc":"r","da":"treble","qb":6144}]}],"ea":[]},{"ya":{"ya":13,"za":14,"ab":14,"t":3},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":24576,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"oc":"r","da":"treble","qb":6144}]}],"ea":[]},{"ya":{"ya":14,"za":15,"ab":15,"t":3},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":24576,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"oc":"r","da":"treble","qb":6144}]}],"ea":[]},{"ya":{"ya":15,"za":16,"ab":16,"t":3},"bb":66.38,"cb":[],"db":[{"eb":[{"fb":{"gb":24576,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"oc":"r","da":"treble","qb":6144}]}],"ea":[]},{"ya":{"ya":16,"za":17,"ab":17,"t":3},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":24576,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"oc":"r","da":"treble","qb":6144}]}],"ea":[]},{"ld":true,"ya":{"ya":17,"za":18,"ab":18,"t":3},"bb":85.22,"de":32,"cb":[],"db":[{"eb":[{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":4}],"da":"treble","qb":2048,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"Ah-"}]},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble","qb":6144}]}],"ea":[]},{"ya":{"ya":18,"za":19,"ab":19,"t":3},"bb":6,"de":32,"ef":false,"cb":[],"db":[{"eb":[{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","qb":6144},{"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"Ve-"}]},{"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"ni-"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","rb":true,"qb":2048,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"te"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"a-"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"-"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"do"}]}]}],"ea":[]},{"ya":{"ya":19,"za":20,"ab":20,"t":3},"bb":60.34,"cb":[],"db":[{"eb":[{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"re-"}]},{"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"mus"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":4}],"da":"treble","rb":true,"qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"Ah-"}]},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":""}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","qb":6144},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble","qb":6144}]}],"ea":[]},{"ya":{"ya":20,"za":21,"ab":21,"t":3},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"-"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":""}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":""}]},{"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"-"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":4}],"da":"treble","rb":true,"qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric"}]},{"fb":{"gb":8192,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"ve-"}]}]}],"ea":[]},{"ya":{"ya":21,"za":22,"ab":22,"t":3},"bb":60.34,"cb":[],"db":[{"eb":[{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"ni-"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"-"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"-"}]},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"-"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"-"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"-"}]},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"te"}]},{"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":""}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"ve-"},{"wc":2,"tb":"p","sa":"SmoDynamicText"}]}]}],"ea":[]},{"ya":{"ya":22,"za":23,"ab":23,"t":3},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"ni-"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"-"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"-"}]},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"-"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"-"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"-"}]},{"fb":{"gb":12288,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"te"}]}]}],"ea":[]},{"ld":true,"ya":{"ya":23,"za":24,"ab":24,"t":3},"bb":60.34,"cb":[],"db":[{"eb":[{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144},{"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","rb":true,"qb":2048,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"ve-"}]},{"ka":[{"jb":"b","lb":"b","kb":4}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"ni-"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"da":"treble","rb":true,"qb":2048,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"te-"}]},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"a"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"-"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"dor"}]}]}],"ea":[]},{"ya":{"ya":24,"za":25,"ab":25,"t":3},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"#","kb":4,"pc":true}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"re-"}]},{"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"mus"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble","qb":2048},{"fb":{"gb":12288,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble","qb":2048}]}],"ea":[]},{"ld":true,"ya":{"ya":25,"za":26,"ab":26,"t":3},"bb":60.34,"cb":[],"db":[{"eb":[{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble","qb":6144},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"A"}]},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"-"}]},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"b","kb":5}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"do-"}]}]}],"ea":[]},{"ya":{"ya":26,"za":27,"ab":27,"t":3},"bb":24.48,"cb":[],"db":[{"eb":[{"fb":{"gb":12288,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":5}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric"}]},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"b","kb":5}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"re-"}]}]}],"ea":[]},{"ya":{"ya":27,"za":28,"ab":28,"t":3},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":12288,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"mus"}],"qc":[{"rc":"fermata","sa":"SmoArticulation"}]},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric"}]}]}],"ea":[]},{"ld":true,"ya":{"ya":28,"za":29,"ab":29,"t":3},"bb":92.30000000000001,"cb":[],"db":[{"eb":[{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","qb":6144,"tc":2,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"Do"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble","qb":6144,"tc":2,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"-"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","qb":6144,"tc":2,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":""}]},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble","qb":6144,"tc":2,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":""}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","qb":6144,"tc":2,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"-"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"#","kb":4}],"da":"treble","qb":6144,"tc":2,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"mi"}]},{"fb":{"gb":12288,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","qb":6144,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"num"}],"qc":[{"rc":"fermata","sa":"SmoArticulation"}]}]}],"ea":[]},{"ya":{"ya":29,"za":30,"ab":30,"t":3},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":24576,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble","qb":6144}]}],"ea":[]},{"ya":{"ya":30,"za":31,"ab":31,"t":3},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":24576,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble","qb":6144}]}],"ea":[]}]}],"yc":[],"ge":[{"he":[{"tb":{"sa":"SmoScoreText","pa":{"qa":"auto635945","ra":"SmoScoreText"},"zc":{},"ad":false,"jc":995,"kc":46,"tb":" Pietro Yon","bd":"every","ua":"custom","vb":{"wb":"1em","xb":"Merriweather","yb":"normal","zb":"normal"},"ac":"score-text auto8948 auto268034 auto3068 auto130786 auto634381 auto635945","cd":"none","dd":"left","cc":"black","lc":0,"mc":0,"dc":1,"ec":1,"fc":0,"gc":0,"ed":false},"ua":2},{"tb":{"sa":"SmoScoreText","pa":{"qa":"auto635946","ra":"SmoScoreText"},"zc":{},"ad":false,"jc":995,"kc":46,"tb":"Page ### of @@@","bd":"every","ua":"custom","vb":{"wb":"1em","xb":"Merriweather","yb":"normal","zb":"normal"},"ac":"score-text auto8948 auto268034 auto475951 auto3069 auto130787 auto634382 auto635946","cd":"none","dd":"left","cc":"black","lc":0,"mc":0,"dc":1,"ec":1,"fc":0,"gc":0,"ed":false},"ua":2}],"dd":3,"ve":2,"ue":10,"bd":1,"sa":"SmoTextGroup","pa":{"qa":"auto635947","ra":"SmoTextGroup"}},{"he":[{"tb":{"sa":"SmoScoreText","pa":{"qa":"auto635948","ra":"SmoScoreText"},"zc":{},"ad":false,"jc":527,"kc":66,"tb":"Gesu Bambino","bd":"every","ua":"title","vb":{"wb":"1.8em","xb":"Merriweather","yb":"normal","zb":"normal","te":21.6},"ac":"score-text auto8947 auto268036 auto3071 auto130789 auto634384 auto635948","cd":"none","dd":"left","cc":"black","lc":0,"mc":0,"dc":1,"ec":1,"fc":0,"gc":0,"ed":true},"ua":4}],"sa":"SmoTextGroup","pa":{"qa":"auto635949","ra":"SmoTextGroup"}}],"yd":[{"zd":0,"fa":{"ga":0,"ha":1},"la":{"ga":1,"ha":1},"sa":"SmoSystemGroup"},{"zd":1,"fa":{"ga":2,"ha":0},"la":{"ga":3,"ha":0},"sa":"SmoSystemGroup"}],"ee":{"wa":{"0":"12/8","27":"9/8","29":"12/8"},"xa":{"0":"g","12":"bb","18":"g"},"fe":{"0":{"sa":"SmoTempoText","pa":{"qa":"auto1566691","ra":"SmoTempoText"},"id":"duration","nb":56,"ob":true,"pb":6144,"jd":"Allegro","ta":25}}},"dictionary":{"a":"score","b":"layout","c":"leftMargin","d":"rightMargin","e":"topMargin","f":"bottomMargin","g":"pageWidth","h":"pageHeight","i":"orientation","j":"interGap","k":"intraGap","l":"svgScale","m":"zoomScale","n":"zoomMode","o":"pages","p":"pageSize","q":"startIndex","r":"renumberingMap","s":"staves","t":"staffId","u":"staffX","v":"staffY","w":"adjY","x":"staffWidth","y":"staffHeight","z":"keySignatureMap","aa":"instrumentInfo","ba":"instrumentName","ca":"keyOffset","da":"clef","ea":"modifiers","fa":"startSelector","ga":"staff","ha":"measure","ia":"voice","ja":"tick","ka":"pitches","la":"endSelector","ma":"xOffset","na":"cp1y","oa":"cp2y","pa":"attrs","qa":"id","ra":"type","sa":"ctor","ta":"yOffset","ua":"position","va":"measures","wa":"timeSignature","xa":"keySignature","ya":"measureNumber","za":"measureIndex","ab":"systemIndex","bb":"adjX","cb":"tuplets","db":"voices","eb":"notes","fb":"ticks","gb":"numerator","hb":"denominator","ib":"remainder","jb":"letter","kb":"octave","lb":"accidental","mb":"symbol","nb":"bpm","ob":"display","pb":"beatDuration","qb":"beamBeats","rb":"endBeam","sb":"textModifiers","tb":"text","ub":"endChar","vb":"fontInfo","wb":"size","xb":"family","yb":"style","zb":"weight","ac":"classes","bc":"verse","cc":"fill","dc":"scaleX","ec":"scaleY","fc":"translateX","gc":"translateY","hc":"selector","ic":"renderedBox","jc":"x","kc":"y","lc":"width","mc":"height","nc":"logicalBox","oc":"noteType","pc":"cautionary","qc":"articulations","rc":"articulation","sc":"activeVoice","tc":"flagState","uc":"invert","vc":"fontSize","wc":"yOffsetLine","xc":"yOffsetPixels","yc":"scoreText","zc":"backup","ad":"edited","bd":"pagination","cd":"boxModel","dd":"justification","ed":"autoLayout","fd":"ornaments","gd":"offset","hd":"ornament","id":"tempoMode","jd":"tempoText","kd":"barline","ld":"systemBreak","md":"graceNotes","nd":"tones","od":"tuplet","pd":"beam_group","qd":"renderId","rd":"numNotes","sd":"totalTicks","td":"stemTicks","ud":"durationMap","vd":"bracketed","wd":"ratioed","xd":"location","yd":"systemGroups","zd":"leftConnector","ae":"padLeft","be":"customStretch","ce":"engravingFont","de":"customProportion","ee":"columnAttributeMap","fe":"tempo","ge":"textGroups","he":"textBlocks","ie":"backupBlocks","je":"blocks","ke":"_text","le":"parser","me":"fonts","ne":"name","oe":"purpose","pe":"custom","qe":"transposeIndex","re":"noteHead","se":"slash","te":"pointSize","ue":"spacing","ve":"relativePosition","we":"activeText","xe":"attachToSelector","ye":"musicXOffset","ze":"musicYOffset","af":"formattingIterations","bf":"startBar","cf":"endBar","df":"endingId","ef":"autoJustify","ff":"thickness","gf":"number","hf":"preferences","if":"autoPlay","jf":"autoAdvance","kf":"defaultDupleDuration","lf":"defaultTripleDuration","mf":"scoreInfo","nf":"version"}}`;
;var microJson = `{"score":{"layout":{"leftMargin":30,"rightMargin":30,"topMargin":40,"bottomMargin":40,"pageWidth":816,"pageHeight":1056,"orientation":0,"interGap":30,"intraGap":10,"svgScale":1,"zoomScale":2.107843137254902,"zoomMode":0,"pages":1},"startIndex":0,"renumberingMap":{}},"staves":[{"staffId":0,"staffX":10,"staffY":40,"adjY":0,"staffWidth":1600,"staffHeight":90,"startIndex":0,"renumberingMap":{},"keySignatureMap":{},"instrumentInfo":{"instrumentName":"Treble Instrument","keyOffset":"0","clef":"treble"},"modifiers":[],"measures":[{"measureNumber":{"measureNumber":0,"measureIndex":0,"systemIndex":0,"staffId":0},"adjX":64.98,"adjRight":11,"tuplets":[],"voices":[{"notes":[{"ticks":{"numerator":2048,"denominator":1,"remainder":0},"pitches":[{"letter":"c","accidental":"n","octave":5}],"attrs":{"id":"auto6268","type":"SmoNote"},"clef":"treble"},{"ticks":{"numerator":2048,"denominator":1,"remainder":0},"pitches":[{"letter":"c","accidental":"n","octave":5}],"attrs":{"id":"auto6269","type":"SmoNote"},"clef":"treble","tones":[{"attrs":{"id":"auto6679","type":"SmoMicrotone"},"ctor":"SmoMicrotone","tone":"flat75sz","pitch":0}]},{"ticks":{"numerator":2048,"denominator":1,"remainder":0},"pitches":[{"letter":"c","accidental":"n","octave":5}],"attrs":{"id":"auto6273","type":"SmoNote"},"clef":"treble"},{"ticks":{"numerator":2048,"denominator":1,"remainder":0},"pitches":[{"letter":"c","accidental":"n","octave":5}],"attrs":{"id":"auto6274","type":"SmoNote"},"clef":"treble","tones":[{"attrs":{"id":"auto7062","type":"SmoMicrotone"},"ctor":"SmoMicrotone","tone":"flat25sz","pitch":0}]},{"ticks":{"numerator":2048,"denominator":1,"remainder":0},"pitches":[{"letter":"c","accidental":"n","octave":5}],"attrs":{"id":"auto6279","type":"SmoNote"},"clef":"treble"},{"ticks":{"numerator":2048,"denominator":1,"remainder":0},"pitches":[{"letter":"c","accidental":"n","octave":5}],"attrs":{"id":"auto6280","type":"SmoNote"},"clef":"treble","tones":[{"attrs":{"id":"auto8606","type":"SmoMicrotone"},"ctor":"SmoMicrotone","tone":"flat25ar","pitch":0}]},{"ticks":{"numerator":2048,"denominator":1,"remainder":0},"pitches":[{"letter":"c","accidental":"n","octave":5}],"attrs":{"id":"auto6286","type":"SmoNote"},"clef":"treble"},{"ticks":{"numerator":2048,"denominator":1,"remainder":0},"pitches":[{"letter":"c","accidental":"n","octave":5}],"attrs":{"id":"auto6287","type":"SmoNote"},"clef":"treble","tones":[{"attrs":{"id":"auto9475","type":"SmoMicrotone"},"ctor":"SmoMicrotone","tone":"sharp75","pitch":0}]}]}],"modifiers":[{"position":0,"barline":0,"ctor":"SmoBarline"},{"position":1,"barline":0,"ctor":"SmoBarline"},{"symbol":0,"xOffset":0,"yOffset":30,"position":0,"ctor":"SmoRepeatSymbol"}]},{"measureNumber":{"measureNumber":1,"measureIndex":1,"systemIndex":1,"staffId":0},"adjX":11,"adjRight":11,"tuplets":[],"voices":[{"notes":[{"ticks":{"numerator":2048,"denominator":1,"remainder":0},"pitches":[{"letter":"c","accidental":"n","octave":5}],"attrs":{"id":"auto9944","type":"SmoNote"},"clef":"treble"},{"ticks":{"numerator":2048,"denominator":1,"remainder":0},"pitches":[{"letter":"c","accidental":"n","octave":5}],"attrs":{"id":"auto9945","type":"SmoNote"},"clef":"treble","tones":[{"attrs":{"id":"auto10352","type":"SmoMicrotone"},"ctor":"SmoMicrotone","tone":"sharp125","pitch":0}]},{"ticks":{"numerator":2048,"denominator":1,"remainder":0},"pitches":[{"letter":"c","accidental":"n","octave":5}],"attrs":{"id":"auto9949","type":"SmoNote"},"clef":"treble"},{"ticks":{"numerator":2048,"denominator":1,"remainder":0},"pitches":[{"letter":"c","accidental":"n","octave":5}],"attrs":{"id":"auto9950","type":"SmoNote"},"clef":"treble","tones":[{"attrs":{"id":"auto10728","type":"SmoMicrotone"},"ctor":"SmoMicrotone","tone":"sharp25","pitch":0}]},{"ticks":{"numerator":2048,"denominator":1,"remainder":0},"pitches":[{"letter":"c","accidental":"n","octave":5}],"attrs":{"id":"auto9955","type":"SmoNote"},"clef":"treble"},{"ticks":{"numerator":2048,"denominator":1,"remainder":0},"pitches":[{"letter":"c","accidental":"n","octave":5}],"attrs":{"id":"auto9956","type":"SmoNote"},"clef":"treble","tones":[{"attrs":{"id":"auto11106","type":"SmoMicrotone"},"ctor":"SmoMicrotone","tone":"sori","pitch":0}]},{"ticks":{"numerator":2048,"denominator":1,"remainder":0},"pitches":[{"letter":"c","accidental":"n","octave":5}],"attrs":{"id":"auto9962","type":"SmoNote"},"clef":"treble"},{"ticks":{"numerator":2048,"denominator":1,"remainder":0},"pitches":[{"letter":"c","accidental":"n","octave":5}],"attrs":{"id":"auto9963","type":"SmoNote"},"clef":"treble","tones":[{"attrs":{"id":"auto11486","type":"SmoMicrotone"},"ctor":"SmoMicrotone","tone":"koron","pitch":0}]}]}],"modifiers":[{"position":0,"barline":0,"ctor":"SmoBarline"},{"position":1,"barline":0,"ctor":"SmoBarline"},{"symbol":0,"xOffset":0,"yOffset":30,"position":0,"ctor":"SmoRepeatSymbol"}]}]}],"scoreText":[]}`;
;var preciousLord = `{"a":{"b":{"c":30,"d":30,"e":121,"f":40,"g":816,"h":1056,"i":0,"j":50,"k":40,"l":0.65,"m":1.742019121698266,"n":2,"o":1,"p":"letter"},"q":0,"r":{},"me":[{"ne":"engraving","oe":1,"xb":"Bravura","wb":1,"pe":false},{"ne":"score","oe":2,"xb":"Merriweather","wb":14,"pe":false},{"ne":"chords","oe":3,"xb":"Roboto Slab","wb":14,"pe":false},{"ne":"lyrics","oe":4,"xb":"Merriweather","wb":12,"pe":false}],"hf":{"if":true,"jf":true,"kf":4096,"lf":6144,"de":2},"mf":{"ne":"Precious Lord","nf":2}},"s":[{"t":0,"u":10,"v":40,"w":0,"x":1600,"y":90,"q":0,"r":{},"z":{},"aa":{"ba":"Treble Instrument","ca":"0","da":"treble"},"ea":[{"fa":{"ga":0,"ha":15,"ia":0,"ja":0,"ka":[]},"la":{"ga":0,"ha":16,"ia":0,"ja":0,"ka":[]},"ua":4,"sa":"SmoSlur"}],"va":[{"ya":{"ya":-1,"za":0,"ab":0,"t":0},"bb":77.42,"cb":[],"db":[{"eb":[{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":3},{"jb":"a","lb":"n","kb":3}],"da":"treble","sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"Pre-"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3},{"jb":"b","lb":"b","kb":3}],"da":"treble","sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"cious"}]}]}],"ea":[]},{"ya":{"ya":0,"za":1,"ab":1,"t":0},"bb":11,"cb":[],"db":[{"eb":[{"fb":{"gb":8192,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":3},{"jb":"c","lb":"n","kb":4}],"da":"treble","sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"Lord,"},{"vb":{"xb":"Merriweather","wb":11},"bc":1,"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"dark-"},{"vb":{"xb":"Roboto Slab","wb":14},"le":2,"sa":"SmoLyric","ke":"F"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":3},{"jb":"c","lb":"n","kb":4}],"da":"treble","sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"take"},{"vb":{"xb":"Merriweather","wb":11},"bc":1,"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"ness"},{"vb":{"xb":"Roboto Slab","wb":14},"le":2,"sa":"SmoLyric","ke":"Gm^7"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":3},{"jb":"c","lb":"n","kb":4}],"da":"treble","sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"my"},{"vb":{"xb":"Merriweather","wb":11},"bc":1,"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"a-"}]}]}],"ea":[{"ua":0,"kd":3,"sa":"SmoBarline"}]},{"ya":{"ya":1,"za":2,"ab":2,"t":0},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":8192,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":4},{"jb":"f","lb":"n","kb":4}],"da":"treble","sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"hand,"},{"vb":{"xb":"Merriweather","wb":11},"bc":1,"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"pears"},{"vb":{"xb":"Roboto Slab","wb":14},"le":2,"sa":"SmoLyric","ke":"F"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":4},{"jb":"a","lb":"n","kb":4}],"da":"treble","sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"lead"},{"vb":{"xb":"Merriweather","wb":11},"bc":1,"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"and"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"#","kb":4},{"jb":"a","lb":"n","kb":4}],"da":"treble","sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"me"},{"vb":{"xb":"Merriweather","wb":11},"bc":1,"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"the"},{"vb":{"xb":"Roboto Slab","wb":14},"le":2,"sa":"SmoLyric","ke":"F^@csymAugmented@5"}]}]}],"ea":[]},{"ya":{"ya":2,"za":3,"ab":3,"t":0},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":8192,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":4},{"jb":"g","lb":"n","kb":4}],"da":"treble","sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"on,"},{"vb":{"xb":"Merriweather","wb":11},"bc":1,"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"night"},{"vb":{"xb":"Roboto Slab","wb":14},"le":2,"sa":"SmoLyric","ke":"Gm^7"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":3},{"jb":"f","lb":"n","kb":4}],"da":"treble","sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"let"},{"vb":{"xb":"Merriweather","wb":11},"bc":1,"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"dra-"},{"vb":{"xb":"Roboto Slab","wb":14},"le":2,"sa":"SmoLyric","ke":"B@accidentalFlat@"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":3},{"jb":"f","lb":"n","kb":4}],"da":"treble","sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"me"},{"vb":{"xb":"Merriweather","wb":11},"bc":1,"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"ws"}]}]}],"ea":[]},{"ya":{"ya":3,"za":4,"ab":4,"t":0},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":3},{"jb":"d","lb":"n","kb":4}],"da":"treble","sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"sta-"},{"vb":{"xb":"Merriweather","wb":11},"bc":1,"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"ne-"}]},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":4},{"jb":"f","lb":"n","kb":4}],"da":"treble","sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"nd"},{"vb":{"xb":"Merriweather","wb":11},"bc":1,"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"ar "}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"b","kb":3},{"jb":"d","lb":"n","kb":4}],"da":"treble","sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"I"},{"vb":{"xb":"Merriweather","wb":11},"bc":1,"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"when "},{"vb":{"xb":"Roboto Slab","wb":14},"le":2,"sa":"SmoLyric","ke":"B^@csymDiminished@"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"b","kb":3},{"jb":"d","lb":"n","kb":4}],"da":"treble","sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"am"},{"vb":{"xb":"Merriweather","wb":11},"bc":1,"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"my "}]}]}],"ea":[]},{"ya":{"ya":4,"za":5,"ab":5,"t":0},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":8192,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":3},{"jb":"c","lb":"n","kb":4}],"da":"treble","sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"tired"},{"vb":{"xb":"Merriweather","wb":11},"bc":1,"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"life "},{"vb":{"xb":"Roboto Slab","wb":14},"le":2,"sa":"SmoLyric","ke":"F"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":3},{"jb":"c","lb":"n","kb":4}],"da":"treble","sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"I"},{"vb":{"xb":"Merriweather","wb":11},"bc":1,"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":""},{"vb":{"xb":"Roboto Slab","wb":14},"le":2,"sa":"SmoLyric","ke":"C^7"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":3},{"jb":"c","lb":"n","kb":4}],"da":"treble","sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"am"},{"vb":{"xb":"Merriweather","wb":11},"bc":1,"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"is-"}]}]}],"ea":[]},{"ya":{"ya":5,"za":6,"ab":6,"t":0},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":8192,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":3},{"jb":"f","lb":"n","kb":4}],"da":"treble","sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"weak"},{"vb":{"xb":"Merriweather","wb":11},"bc":1,"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"al-"},{"vb":{"xb":"Roboto Slab","wb":14},"le":2,"sa":"SmoLyric","ke":"F"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":3},{"jb":"a","lb":"n","kb":4}],"da":"treble","sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"I "},{"vb":{"xb":"Merriweather","wb":11},"bc":1,"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"most"},{"vb":{"xb":"Roboto Slab","wb":14},"le":2,"sa":"SmoLyric","ke":"G^7"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":3},{"jb":"a","lb":"n","kb":4}],"da":"treble","sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"am"},{"vb":{"xb":"Merriweather","wb":11},"bc":1,"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":""}]}]}],"ea":[]},{"ya":{"ya":6,"za":7,"ab":7,"t":0},"bb":58.94,"cb":[],"db":[{"eb":[{"fb":{"gb":8192,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":4},{"jb":"g","lb":"n","kb":4}],"da":"treble","sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"worn"},{"vb":{"xb":"Merriweather","wb":11},"bc":1,"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"gone"},{"vb":{"xb":"Roboto Slab","wb":14},"le":2,"sa":"SmoLyric","ke":"C"}]},{"ka":[{"jb":"b","lb":"n","kb":3},{"jb":"g","lb":"n","kb":4}],"da":"treble","sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"-"},{"vb":{"xb":"Merriweather","wb":11},"bc":1,"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"-"},{"vb":{"xb":"Roboto Slab","wb":14},"le":2,"sa":"SmoLyric","ke":"G^7"}]}]}],"ea":[]},{"ya":{"ya":7,"za":8,"ab":8,"t":0},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":8192,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":4},{"jb":"g","lb":"n","kb":4}],"da":"treble","sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"-"},{"vb":{"xb":"Merriweather","wb":11},"bc":1,"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"-"},{"vb":{"xb":"Roboto Slab","wb":14},"le":2,"sa":"SmoLyric","ke":"C"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":4},{"jb":"a","lb":"n","kb":4}],"da":"treble","sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"Through"},{"vb":{"xb":"Merriweather","wb":11},"bc":1,"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"at"},{"vb":{"xb":"Roboto Slab","wb":14},"le":2,"sa":"SmoLyric","ke":"F"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4},{"jb":"b","lb":"b","kb":4}],"da":"treble","sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"the"},{"vb":{"xb":"Merriweather","wb":11},"bc":1,"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"the"}]}]}],"ea":[]},{"ya":{"ya":8,"za":9,"ab":9,"t":0},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":8192,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":4},{"jb":"c","lb":"n","kb":5}],"da":"treble","sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"storm,"},{"vb":{"xb":"Merriweather","wb":11},"bc":1,"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"riv-"},{"vb":{"xb":"Roboto Slab","wb":14},"le":2,"sa":"SmoLyric","ke":"F"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":4},{"jb":"c","lb":"n","kb":5}],"da":"treble","sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"through"},{"vb":{"xb":"Merriweather","wb":11},"bc":1,"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"er"},{"vb":{"xb":"Roboto Slab","wb":14},"le":2,"sa":"SmoLyric","ke":"C^7"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":4},{"jb":"c","lb":"n","kb":5}],"da":"treble","sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"the"},{"vb":{"xb":"Merriweather","wb":11},"bc":1,"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"I"}]}]}],"ea":[]},{"ya":{"ya":9,"za":10,"ab":10,"t":0},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":8192,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":4},{"jb":"a","lb":"n","kb":4}],"da":"treble","sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"night"},{"vb":{"xb":"Merriweather","wb":11},"bc":1,"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"stand,"},{"vb":{"xb":"Roboto Slab","wb":14},"le":2,"sa":"SmoLyric","ke":"F"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"b","kb":4},{"jb":"a","lb":"n","kb":4}],"da":"treble","sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"lead"},{"vb":{"xb":"Merriweather","wb":11},"bc":1,"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"guide"},{"vb":{"xb":"Roboto Slab","wb":14},"le":2,"sa":"SmoLyric","ke":"F^7"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"b","kb":4},{"jb":"a","lb":"n","kb":4}],"da":"treble","sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"me"},{"vb":{"xb":"Merriweather","wb":11},"bc":1,"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"me"}]}]}],"ea":[]},{"ya":{"ya":10,"za":11,"ab":11,"t":0},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":8192,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":4},{"jb":"g","lb":"n","kb":4}],"da":"treble","sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"on"},{"vb":{"xb":"Merriweather","wb":11},"bc":1,"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"feet,"},{"vb":{"xb":"Roboto Slab","wb":14},"le":2,"sa":"SmoLyric","ke":"Gm^7"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":4},{"jb":"f","lb":"n","kb":4}],"da":"treble","sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"to"},{"vb":{"xb":"Merriweather","wb":11},"bc":1,"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"hold"},{"vb":{"xb":"Roboto Slab","wb":14},"le":2,"sa":"SmoLyric","ke":"B@accidentalFlat@"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":4},{"jb":"f","lb":"n","kb":4}],"da":"treble","sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"the"},{"vb":{"xb":"Merriweather","wb":11},"bc":1,"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"my"}]}]}],"ea":[]},{"ld":true,"ya":{"ya":11,"za":12,"ab":12,"t":0},"bb":58.94,"cb":[],"db":[{"eb":[{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":3},{"jb":"d","lb":"n","kb":4}],"da":"treble","sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"li-"},{"vb":{"xb":"Merriweather","wb":11},"bc":1,"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"ha-"}]},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":4},{"jb":"f","lb":"n","kb":4}],"da":"treble","sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"ght"},{"vb":{"xb":"Merriweather","wb":11},"bc":1,"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"nd"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":4}],"da":"treble","sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"Take"},{"vb":{"xb":"Merriweather","wb":11},"bc":1,"adjustNoteWidthLyric":false,"sa":"SmoLyric"},{"vb":{"xb":"Roboto Slab","wb":14},"le":2,"sa":"SmoLyric","ke":"B^@csymDiminished@"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":4}],"da":"treble","sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"my"}]}]}],"ea":[]},{"ya":{"ya":12,"za":13,"ab":13,"t":0},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":4}],"da":"treble","sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"ha-"},{"vb":{"xb":"Roboto Slab","wb":14},"le":2,"sa":"SmoLyric","ke":"F"}]},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":4}],"da":"treble","sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"nd"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":4}],"da":"treble","sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"pre-"},{"vb":{"xb":"Roboto Slab","wb":14},"le":2,"sa":"SmoLyric","ke":"Dm"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":4},{"jb":"g","lb":"n","kb":4}],"da":"treble","sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"cious"},{"vb":{"xb":"Roboto Slab","wb":14},"le":2,"sa":"SmoLyric","ke":"A^@csymAugmented@5"}]}]}],"ea":[]},{"ya":{"ya":13,"za":14,"ab":14,"t":0},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":8192,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":4},{"jb":"a","lb":"n","kb":4}],"da":"treble","sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"Lord,"},{"vb":{"xb":"Roboto Slab","wb":14},"le":2,"sa":"SmoLyric","ke":"F"}]},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":4},{"jb":"g","lb":"n","kb":4}],"da":"treble","sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"lead"},{"vb":{"xb":"Roboto Slab","wb":14},"le":2,"sa":"SmoLyric","ke":"C^@csymParensLeftTall@sus4@csymParensRightTall@"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":4},{"jb":"f","lb":"n","kb":4}],"da":"treble","sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"me"}]}]}],"ea":[]},{"ya":{"ya":14,"za":15,"ab":15,"t":0},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":12288,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":4},{"jb":"f","lb":"n","kb":4}],"da":"treble","sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"home-"},{"vb":{"xb":"Roboto Slab","wb":14},"le":2,"sa":"SmoLyric","ke":"F"}]}]}],"ea":[{"kd":1,"sa":"SmoBarline"}]},{"ya":{"ya":15,"za":16,"ab":16,"t":0},"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":8192,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":4},{"jb":"f","lb":"n","kb":4}],"da":"treble","sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":3}],"da":"treble","sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"When"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3}],"da":"treble","sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":"the"}]}]}],"ea":[{"kd":4,"sa":"SmoBarline"},{"mb":9,"ma":-40,"sa":"SmoRepeatSymbol"}]}]},{"t":1,"u":10,"v":40,"w":0,"x":1600,"y":90,"q":0,"r":{},"z":{},"aa":{"ba":"Bass Clef Staff","ca":0,"da":"bass"},"ea":[{"fa":{"ga":1,"ha":15,"ia":0,"ja":0,"ka":[]},"la":{"ga":1,"ha":16,"ia":0,"ja":0,"ka":[]},"ua":4,"sa":"SmoSlur"}],"va":[{"ya":{"ya":-1,"za":0,"ab":0,"t":1},"da":"bass","bb":77.42,"cb":[],"db":[{"eb":[{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":2},{"jb":"f","lb":"n","kb":3}],"da":"bass","tc":2},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":2},{"jb":"f","lb":"n","kb":3}],"da":"bass","tc":2}]}],"ea":[]},{"ya":{"ya":0,"za":1,"ab":1,"t":1},"da":"bass","bb":11,"ae":1,"cb":[],"db":[{"eb":[{"fb":{"gb":8192,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":2},{"jb":"f","lb":"n","kb":3}],"da":"bass","tc":2},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":2},{"jb":"f","lb":"n","kb":3}],"da":"bass","tc":2},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":2},{"jb":"e","lb":"n","kb":3}],"da":"bass","tc":2,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric"}]}]}],"ea":[{"ua":0,"kd":3,"sa":"SmoBarline"}]},{"ya":{"ya":1,"za":2,"ab":2,"t":1},"da":"bass","bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":8192,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":2},{"jb":"f","lb":"n","kb":3}],"da":"bass","tc":2,"sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":2},{"jb":"f","lb":"n","kb":3}],"da":"bass","tc":2},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":2},{"jb":"f","lb":"n","kb":3}],"da":"bass","tc":2}]}],"ea":[]},{"ya":{"ya":2,"za":3,"ab":3,"t":1},"da":"bass","bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":8192,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":2},{"jb":"f","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":3},{"jb":"f","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":3},{"jb":"f","lb":"n","kb":3}],"da":"bass"}]}],"ea":[]},{"ya":{"ya":3,"za":4,"ab":4,"t":1},"da":"bass","bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":2},{"jb":"f","lb":"n","kb":3}],"da":"bass","sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":""}]},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":2},{"jb":"d","lb":"n","kb":3}],"da":"bass","sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":3}],"da":"bass"}]}],"ea":[]},{"ya":{"ya":4,"za":5,"ab":5,"t":1},"da":"bass","bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":8192,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":3},{"jb":"f","lb":"n","kb":3}],"da":"bass","sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric","ke":""}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":3},{"jb":"e","lb":"n","kb":3}],"da":"bass","sb":[{"vb":{"xb":"Merriweather","wb":11},"adjustNoteWidthLyric":false,"sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":3},{"jb":"e","lb":"n","kb":3}],"da":"bass"}]}],"ea":[]},{"ya":{"ya":5,"za":6,"ab":6,"t":1},"da":"bass","bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":8192,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":2},{"jb":"f","lb":"n","kb":3}],"da":"bass","tc":2},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":2},{"jb":"f","lb":"n","kb":3}],"da":"bass","tc":2}]}],"ea":[]},{"ya":{"ya":6,"za":7,"ab":7,"t":1},"da":"bass","bb":58.94,"cb":[],"db":[{"eb":[{"fb":{"gb":8192,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":3},{"jb":"e","lb":"n","kb":3}],"da":"bass"},{"ka":[{"jb":"d","lb":"n","kb":3},{"jb":"f","lb":"n","kb":3}],"da":"bass"}]}],"ea":[]},{"ya":{"ya":7,"za":8,"ab":8,"t":1},"da":"bass","bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":8192,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":3},{"jb":"g","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":3},{"jb":"c","lb":"n","kb":4}],"da":"bass"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":3},{"jb":"c","lb":"n","kb":4}],"da":"bass"}]}],"ea":[]},{"ya":{"ya":8,"za":9,"ab":9,"t":1},"da":"bass","bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":8192,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":3},{"jb":"a","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3},{"jb":"b","lb":"b","kb":3}],"da":"bass"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3},{"jb":"b","lb":"b","kb":3}],"da":"bass"}]}],"ea":[]},{"ya":{"ya":9,"za":10,"ab":10,"t":1},"da":"bass","bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":8192,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":3},{"jb":"c","lb":"n","kb":4}],"da":"bass"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":3},{"jb":"c","lb":"n","kb":4}],"da":"bass"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":3},{"jb":"c","lb":"n","kb":4}],"da":"bass"}]}],"ea":[]},{"ya":{"ya":10,"za":11,"ab":11,"t":1},"da":"bass","bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":8192,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":2},{"jb":"b","lb":"b","kb":3}],"da":"bass"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":2},{"jb":"b","lb":"b","kb":3}],"da":"bass"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":2},{"jb":"b","lb":"b","kb":3}],"da":"bass"}]}],"ea":[]},{"ld":true,"ya":{"ya":11,"za":12,"ab":12,"t":1},"da":"bass","bb":58.94,"cb":[],"db":[{"eb":[{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":2},{"jb":"f","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":2},{"jb":"b","lb":"b","kb":3}],"da":"bass"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":2},{"jb":"a","lb":"b","kb":3}],"da":"bass"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":2},{"jb":"g","lb":"n","kb":3}],"da":"bass"}]}],"ea":[]},{"ya":{"ya":12,"za":13,"ab":13,"t":1},"da":"bass","bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":8192,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":3},{"jb":"a","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":3},{"jb":"a","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"b","kb":3},{"jb":"b","lb":"n","kb":3}],"da":"bass"}]}],"ea":[]},{"ya":{"ya":13,"za":14,"ab":14,"t":1},"da":"bass","bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":8192,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":3},{"jb":"c","lb":"n","kb":4}],"da":"bass"},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":3},{"jb":"b","lb":"b","kb":3}],"da":"bass"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":3},{"jb":"b","lb":"b","kb":3}],"da":"bass"}]}],"ea":[]},{"ya":{"ya":14,"za":15,"ab":15,"t":1},"da":"bass","bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":12288,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":3},{"jb":"a","lb":"n","kb":3}],"da":"bass"}]}],"ea":[{"kd":1,"sa":"SmoBarline"}]},{"ya":{"ya":15,"za":16,"ab":16,"t":1},"da":"bass","bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":8192,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":3},{"jb":"a","lb":"n","kb":3}],"da":"bass"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":2},{"jb":"f","lb":"n","kb":3}],"da":"bass","tc":2},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":2},{"jb":"f","lb":"n","kb":3}],"da":"bass","tc":2}]}],"ea":[{"kd":4,"sa":"SmoBarline"},{"mb":9,"ma":-40,"sa":"SmoRepeatSymbol"}]}]}],"yc":[],"ge":[{"he":[{"tb":{"sa":"SmoScoreText","pa":{"qa":"auto2164","ra":"SmoScoreText"},"zc":{},"ad":false,"jc":476,"kc":64,"tb":"Precious Lord","bd":"once","ua":"title","vb":{"wb":"1.8em","xb":"Merriweather","yb":"normal","zb":"normal"},"ac":"score-text auto1575 auto19265 auto90198 auto1464 auto7469 auto10183 auto37910 auto415606 auto421729 auto28921 auto1800 auto2164","cd":"none","dd":"left","cc":"black","lc":0,"mc":0,"dc":1,"ec":1,"fc":0,"gc":0,"ed":true},"ua":4}],"sa":"SmoTextGroup","pa":{"qa":"auto2165","ra":"SmoTextGroup"}}],"yd":[{"zd":0,"fa":{"ga":0,"ha":2},"la":{"ga":1,"ha":2},"sa":"SmoSystemGroup"}],"ee":{"wa":{"0":"3/4"},"xa":{"0":"f"},"fe":{"0":{"sa":"SmoTempoText","pa":{"qa":"auto1810","ra":"SmoTempoText"},"id":"duration","nb":120,"ob":false,"pb":4096,"jd":"Allegro","ta":0}}},"dictionary":{"a":"score","b":"layout","c":"leftMargin","d":"rightMargin","e":"topMargin","f":"bottomMargin","g":"pageWidth","h":"pageHeight","i":"orientation","j":"interGap","k":"intraGap","l":"svgScale","m":"zoomScale","n":"zoomMode","o":"pages","p":"pageSize","q":"startIndex","r":"renumberingMap","s":"staves","t":"staffId","u":"staffX","v":"staffY","w":"adjY","x":"staffWidth","y":"staffHeight","z":"keySignatureMap","aa":"instrumentInfo","ba":"instrumentName","ca":"keyOffset","da":"clef","ea":"modifiers","fa":"startSelector","ga":"staff","ha":"measure","ia":"voice","ja":"tick","ka":"pitches","la":"endSelector","ma":"xOffset","na":"cp1y","oa":"cp2y","pa":"attrs","qa":"id","ra":"type","sa":"ctor","ta":"yOffset","ua":"position","va":"measures","wa":"timeSignature","xa":"keySignature","ya":"measureNumber","za":"measureIndex","ab":"systemIndex","bb":"adjX","cb":"tuplets","db":"voices","eb":"notes","fb":"ticks","gb":"numerator","hb":"denominator","ib":"remainder","jb":"letter","kb":"octave","lb":"accidental","mb":"symbol","nb":"bpm","ob":"display","pb":"beatDuration","qb":"beamBeats","rb":"endBeam","sb":"textModifiers","tb":"text","ub":"endChar","vb":"fontInfo","wb":"size","xb":"family","yb":"style","zb":"weight","ac":"classes","bc":"verse","cc":"fill","dc":"scaleX","ec":"scaleY","fc":"translateX","gc":"translateY","hc":"selector","ic":"renderedBox","jc":"x","kc":"y","lc":"width","mc":"height","nc":"logicalBox","oc":"noteType","pc":"cautionary","qc":"articulations","rc":"articulation","sc":"activeVoice","tc":"flagState","uc":"invert","vc":"fontSize","wc":"yOffsetLine","xc":"yOffsetPixels","yc":"scoreText","zc":"backup","ad":"edited","bd":"pagination","cd":"boxModel","dd":"justification","ed":"autoLayout","fd":"ornaments","gd":"offset","hd":"ornament","id":"tempoMode","jd":"tempoText","kd":"barline","ld":"systemBreak","md":"graceNotes","nd":"tones","od":"tuplet","pd":"beam_group","qd":"renderId","rd":"numNotes","sd":"totalTicks","td":"stemTicks","ud":"durationMap","vd":"bracketed","wd":"ratioed","xd":"location","yd":"systemGroups","zd":"leftConnector","ae":"padLeft","be":"customStretch","ce":"engravingFont","de":"customProportion","ee":"columnAttributeMap","fe":"tempo","ge":"textGroups","he":"textBlocks","ie":"backupBlocks","je":"blocks","ke":"_text","le":"parser","me":"fonts","ne":"name","oe":"purpose","pe":"custom","qe":"transposeIndex","re":"noteHead","se":"slash","te":"pointSize","ue":"spacing","ve":"relativePosition","we":"activeText","xe":"attachToSelector","ye":"musicXOffset","ze":"musicYOffset","af":"formattingIterations","bf":"startBar","cf":"endBar","df":"endingId","ef":"autoJustify","ff":"thickness","gf":"number","hf":"preferences","if":"autoPlay","jf":"autoAdvance","kf":"defaultDupleDuration","lf":"defaultTripleDuration","mf":"scoreInfo","nf":"version"}}`;
;var testCase1 = `[{"method":"growSelectionRight","parameters":[]},{"method":"batchDurationOperation","parameters":["halveDuration"]},{"method":"batchDurationOperation","parameters":["halveDuration"]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["c"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["d"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["e"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["f"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["d"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["e"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["c"]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"beamSelections","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"transposeSelections","parameters":[-12]},{"method":"moveSelectionRight","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"batchDurationOperation","parameters":["halveDuration"]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["g"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["c"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["b"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["c"]},{"method":"moveSelectionRight","parameters":[]},{"method":"growSelectionLeft","parameters":[]},{"method":"growSelectionLeft","parameters":[]},{"method":"growSelectionLeft","parameters":[]},{"method":"transposeSelections","parameters":[12]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"crescendo","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"beamSelections","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"addStaff","parameters":[{"instrumentInfo":{"instrumentName":"Bass Clef Staff","keyOffset":0,"clef":"bass"}}]},{"method":"moveSelectionDown","parameters":[]},{"method":"batchDurationOperation","parameters":["doubleDuration"]},{"method":"moveSelectionRight","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"batchDurationOperation","parameters":["halveDuration"]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"batchDurationOperation","parameters":["halveDuration"]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["c"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["d"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["e"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["f"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["d"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["e"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["c"]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"growSelectionLeft","parameters":[]},{"method":"growSelectionLeft","parameters":[]},{"method":"beamSelections","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"addMeasure","parameters":[true]},{"method":"addMeasure","parameters":[true]},{"method":"moveSelectionUp","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"batchDurationOperation","parameters":["halveDuration"]},{"method":"batchDurationOperation","parameters":["halveDuration"]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["d"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["g"]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"transposeSelections","parameters":[-12]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["a"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["b"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["c"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["a"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["b"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["g"]},{"method":"moveSelectionRight","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"batchDurationOperation","parameters":["halveDuration"]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["d"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["g"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["f"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["g"]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"growSelectionLeft","parameters":[]},{"method":"growSelectionLeft","parameters":[]},{"method":"growSelectionLeft","parameters":[]},{"method":"beamSelections","parameters":[]},{"method":"transposeSelections","parameters":[12]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"toggleArticulation","parameters":["mordent_inverted","SmoOrnament"]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"batchDurationOperation","parameters":["halveDuration"]},{"method":"batchDurationOperation","parameters":["halveDuration"]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["e"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["a"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["g"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["f"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["e"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["g"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["f"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["a"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["g"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["f"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["e"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["d"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["c"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["e"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["d"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["f"]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionLeftMeasure","parameters":[]},{"method":"moveSelectionDown","parameters":[]},{"method":"setPitch","parameters":["g"]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"batchDurationOperation","parameters":["undotDuration"]},{"method":"batchDurationOperation","parameters":["halveDuration"]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"transposeSelections","parameters":[12]},{"method":"growSelectionRight","parameters":[]},{"method":"slur","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"toggleArticulation","parameters":["staccato","SmoArticulation"]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"batchDurationOperation","parameters":["halveDuration"]},{"method":"batchDurationOperation","parameters":["halveDuration"]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["g"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["a"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["c"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["a"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["b"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["g"]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"deleteNote","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["g"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["a"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["b"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["c"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["a"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["b"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["g"]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"growSelectionLeft","parameters":[]},{"method":"growSelectionLeft","parameters":[]},{"method":"growSelectionLeft","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"growSelectionLeft","parameters":[]},{"method":"growSelectionLeft","parameters":[]},{"method":"beamSelections","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"batchDurationOperation","parameters":["halveDuration"]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["c"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["e"]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"transposeSelections","parameters":[-12]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["f"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["g"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["a"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["b"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["c"]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"batchDurationOperation","parameters":["doubleDuration"]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"transposeSelections","parameters":[1]},{"method":"setScoreLayout","parameters":[{"leftMargin":30,"rightMargin":30,"topMargin":40,"bottomMargin":40,"pageWidth":816,"pageHeight":1056,"orientation":0,"interGap":30,"intraGap":10,"svgScale":0.55,"zoomScale":2.107843137254902,"zoomMode":0,"pages":1}]},{"method":"setScoreLayout","parameters":[{"leftMargin":30,"rightMargin":30,"topMargin":40,"bottomMargin":40,"pageWidth":816,"pageHeight":1056,"orientation":0,"interGap":30,"intraGap":10,"svgScale":0.55,"zoomScale":2.107843137254902,"zoomMode":0,"pages":1}]},{"method":"selectSuggestionNote","parameters":[{"staff":1,"measure":2,"voice":0,"tick":1,"pitches":[]},{"type":"click","shiftKey":false,"ctrlKey":false}]},{"method":"setPitch","parameters":["b"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["c"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["d"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["e"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["g"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["a"]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"batchDurationOperation","parameters":["halveDuration"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["b"]},{"method":"moveSelectionRight","parameters":[]},{"method":"growSelectionLeft","parameters":[]},{"method":"growSelectionLeft","parameters":[]},{"method":"transposeSelections","parameters":[-12]},{"method":"moveSelectionLeft","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"beamSelections","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"beamSelections","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"addMeasure","parameters":[true]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionUp","parameters":[]},{"method":"forceSystemBreak","parameters":[true]},{"method":"growSelectionRight","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"batchDurationOperation","parameters":["halveDuration"]},{"method":"batchDurationOperation","parameters":["halveDuration"]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["e"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["d"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["c"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["b"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["a"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["c"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["b"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["d"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["c"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["b"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["a"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["g"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["f"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["a"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["g"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["b"]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"transposeSelections","parameters":[1]},{"method":"moveSelectionDown","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"batchDurationOperation","parameters":["doubleDuration"]},{"method":"batchDurationOperation","parameters":["halveDuration"]},{"method":"batchDurationOperation","parameters":["halveDuration"]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["c"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["e"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["f"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["g"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["a"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["b"]},{"method":"moveSelectionRight","parameters":[]},{"method":"batchDurationOperation","parameters":["doubleDuration"]},{"method":"setPitch","parameters":["c"]},{"method":"moveSelectionRight","parameters":[]},{"method":"growSelectionLeft","parameters":[]},{"method":"growSelectionLeft","parameters":[]},{"method":"growSelectionLeft","parameters":[]},{"method":"growSelectionLeft","parameters":[]},{"method":"growSelectionLeft","parameters":[]},{"method":"transposeSelections","parameters":[-12]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"transposeSelections","parameters":[1]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"crescendo","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"slur","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"slur","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"selectSuggestionNote","parameters":[{"staff":1,"measure":1,"voice":0,"tick":9,"pitches":[]},{"type":"click","shiftKey":false,"ctrlKey":false}]},{"method":"selectSuggestionNote","parameters":[{"staff":1,"measure":1,"voice":0,"tick":9,"pitches":[]},{"type":"click","shiftKey":false,"ctrlKey":false}]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"advanceModifierSelection","parameters":[{"type":"keydown","shiftKey":false,"ctrlKey":false}]},{"method":"advanceModifierSelection","parameters":[{"type":"keydown","shiftKey":false,"ctrlKey":false}]},{"method":"advanceModifierSelection","parameters":[{"type":"keydown","shiftKey":false,"ctrlKey":false}]},{"method":"moveSelectionRight","parameters":[]},{"method":"advanceModifierSelection","parameters":[{"type":"keydown","shiftKey":false,"ctrlKey":false}]},{"method":"removeStaffModifier","parameters":[{"startSelector":{"staff":1,"measure":2,"voice":0,"tick":7,"pitches":[]},"endSelector":{"staff":1,"measure":3,"voice":0,"tick":0,"pitches":[]},"position":4,"ctor":"SmoSlur"}]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"slur","parameters":[]},{"method":"addTextGroup","parameters":[{"textBlocks":[{"text":{"ctor":"SmoScoreText","attrs":{"id":"auto277566","type":"SmoScoreText"},"backup":{},"edited":false,"x":893,"y":180.95,"text":"Smoosic","pagination":"once","position":"custom","fontInfo":{"size":"1em","family":"Merriweather","style":"normal","weight":"normal"},"classes":"score-text auto277566","boxModel":"none","justification":"left","fill":"black","width":0,"height":0,"scaleX":1,"scaleY":1,"translateX":0,"translateY":0,"autoLayout":false,"renderedBox":{"x":1209.73,"y":-229.95,"width":89.9,"height":27.02},"logicalBox":{"x":893,"y":162.83,"width":77.56,"height":23.31}},"position":4,"activeText":true}],"ctor":"SmoTextGroup","attrs":{"id":"auto277567","type":"SmoTextGroup"}}]},{"method":"updateTextGroup","parameters":[{"textBlocks":[{"text":{"ctor":"SmoScoreText","attrs":{"id":"auto277566","type":"SmoScoreText"},"backup":{},"edited":false,"x":893,"y":180.95,"text":"Smoosic","pagination":"once","position":"custom","fontInfo":{"size":"1em","family":"Merriweather","style":"normal","weight":"normal"},"classes":"score-text auto277566","boxModel":"none","justification":"left","fill":"black","width":0,"height":0,"scaleX":1,"scaleY":1,"translateX":0,"translateY":0,"autoLayout":false,"renderedBox":{"x":1209.73,"y":371.05,"width":89.9,"height":27.02},"logicalBox":{"x":893,"y":162.83,"width":77.56,"height":23.31}},"position":4,"activeText":true}],"ctor":"SmoTextGroup","attrs":{"id":"auto277567","type":"SmoTextGroup"}},{"textBlocks":[{"text":{"ctor":"SmoScoreText","attrs":{"id":"auto277566","type":"SmoScoreText"},"backup":{},"edited":false,"x":893,"y":180.95,"text":"15 Inventions a 2 voix.","pagination":"once","position":"custom","fontInfo":{"size":"1em","family":"Merriweather","style":"normal","weight":"normal"},"classes":"score-text auto277566","boxModel":"none","justification":"left","fill":"black","width":0,"height":0,"scaleX":1,"scaleY":1,"translateX":0,"translateY":0,"autoLayout":false,"renderedBox":{"x":1209.73,"y":371.05,"width":89.9,"height":27.02},"logicalBox":{"x":893,"y":162.83,"width":77.56,"height":23.31}},"position":4,"activeText":true}],"ctor":"SmoTextGroup","attrs":{"id":"auto277567","type":"SmoTextGroup"}}]},{"method":"updateTextGroup","parameters":[{"textBlocks":[{"text":{"ctor":"SmoScoreText","attrs":{"id":"auto277566","type":"SmoScoreText"},"backup":{},"edited":false,"x":893,"y":180.95,"text":"15 Inventions a 2 voix.","pagination":"once","position":"custom","fontInfo":{"size":"1em","family":"Merriweather","style":"normal","weight":"normal"},"classes":"score-text auto277566","boxModel":"none","justification":"left","fill":"black","width":0,"height":0,"scaleX":1,"scaleY":1,"translateX":0,"translateY":0,"autoLayout":false,"renderedBox":{"x":1209.73,"y":371.05,"width":235.12,"height":27.02},"logicalBox":{"x":893,"y":162.83,"width":202.86,"height":23.31}},"position":4,"activeText":true}],"ctor":"SmoTextGroup","attrs":{"id":"auto277567","type":"SmoTextGroup"}},{"textBlocks":[{"text":{"ctor":"SmoScoreText","attrs":{"id":"auto277566","type":"SmoScoreText"},"backup":{},"edited":false,"x":591.4853515625,"y":50.08321900431312,"text":"15 Inventions a 2 voix.","pagination":"once","position":"custom","fontInfo":{"size":"1em","family":"Merriweather","style":"normal","weight":"normal"},"classes":"score-text auto277566","boxModel":"none","justification":"left","fill":"black","width":0,"height":0,"scaleX":1,"scaleY":1,"translateX":0,"translateY":0,"autoLayout":false,"renderedBox":{"x":1209.73,"y":371.05,"width":235.12,"height":27.02},"logicalBox":{"x":893,"y":162.83,"width":202.86,"height":23.31}},"position":4,"activeText":true}],"ctor":"SmoTextGroup","attrs":{"id":"auto277567","type":"SmoTextGroup"}}]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"addMeasure","parameters":[true]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionUp","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"batchDurationOperation","parameters":["halveDuration"]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"batchDurationOperation","parameters":["dotDuration"]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"setPitch","parameters":["d"]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"setPitch","parameters":["a"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["d"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["c"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["d"]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"growSelectionLeft","parameters":[]},{"method":"transposeSelections","parameters":[12]},{"method":"moveSelectionRight","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"batchDurationOperation","parameters":["halveDuration"]},{"method":"batchDurationOperation","parameters":["halveDuration"]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["b"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["a"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["g"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["f"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["e"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["g"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["f"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["a"]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"transposeSelections","parameters":[1]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"transposeSelections","parameters":[1]},{"method":"moveSelectionDown","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"batchDurationOperation","parameters":["halveDuration"]},{"method":"batchDurationOperation","parameters":["halveDuration"]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["c"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["d"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["e"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["f"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["g"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["e"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["d"]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"setPitch","parameters":["g"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["d"]},{"method":"moveSelectionRight","parameters":[]},{"method":"growSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"growSelectionLeft","parameters":[]},{"method":"growSelectionLeft","parameters":[]},{"method":"growSelectionLeft","parameters":[]},{"method":"growSelectionLeft","parameters":[]},{"method":"growSelectionLeft","parameters":[]},{"method":"growSelectionLeft","parameters":[]},{"method":"transposeSelections","parameters":[-12]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"transposeSelections","parameters":[1]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"batchDurationOperation","parameters":["halveDuration"]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["g"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["b"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["c"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["d"]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"transposeSelections","parameters":[-12]},{"method":"moveSelectionLeft","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"beamSelections","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"addMeasure","parameters":[true]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionUp","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"batchDurationOperation","parameters":["halveDuration"]},{"method":"batchDurationOperation","parameters":["halveDuration"]},{"method":"moveSelectionRight","parameters":[]},{"method":"batchDurationOperation","parameters":["halveDuration"]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"setPitch","parameters":["g"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["b"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["a"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["c"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["b"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["d"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["c"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["e"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["d"]},{"method":"moveSelectionRight","parameters":[]},{"method":"batchDurationOperation","parameters":["halveDuration"]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["b"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["c"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["d"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["g"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["b"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["a"]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"growSelectionLeft","parameters":[]},{"method":"transposeSelections","parameters":[-12]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"batchDurationOperation","parameters":["halveDuration"]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["g"]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"growSelectionLeft","parameters":[]},{"method":"growSelectionLeft","parameters":[]},{"method":"growSelectionLeft","parameters":[]},{"method":"slur","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"toggleArticulation","parameters":["mordent","SmoOrnament"]},{"method":"toggleArticulation","parameters":["mordent","SmoOrnament"]},{"method":"toggleArticulation","parameters":["mordent","SmoOrnament"]},{"method":"toggleArticulation","parameters":["mordent","SmoOrnament"]},{"method":"moveSelectionRight","parameters":[]},{"method":"toggleArticulation","parameters":["mordent","SmoOrnament"]},{"method":"moveSelectionDown","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"batchDurationOperation","parameters":["halveDuration"]},{"method":"moveSelectionRight","parameters":[]},{"method":"batchDurationOperation","parameters":["halveDuration"]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"batchDurationOperation","parameters":["dotDuration"]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"batchDurationOperation","parameters":["halveDuration"]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"setPitch","parameters":["e"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["f"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["g"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["e"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["b"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["c"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["d"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["d"]},{"method":"moveSelectionRight","parameters":[]},{"method":"transposeSelections","parameters":[-12]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"transposeSelections","parameters":[1]},{"method":"moveHome","parameters":[]},{"method":"updateTempoScore","parameters":[{"tempoMode":"text","ctor":"SmoTempoText"},false]},{"method":"updateTempoScore","parameters":[{"tempoMode":"text","bpm":96,"tempoText":"Moderato","ctor":"SmoTempoText"},false]},{"method":"updateTempoScore","parameters":[{"tempoMode":"text","bpm":96,"tempoText":"Moderato","ctor":"SmoTempoText"},true]},{"method":"updateTempoScore","parameters":[{"tempoMode":"text","bpm":96,"display":true,"tempoText":"Moderato","ctor":"SmoTempoText"},true]},{"method":"moveEnd","parameters":[]},{"method":"addMeasure","parameters":[true]},{"method":"selectSuggestionNote","parameters":[{"staff":0,"measure":6,"voice":0,"tick":0,"pitches":[]},{"type":"click","shiftKey":false,"ctrlKey":false}]},{"method":"batchDurationOperation","parameters":["halveDuration"]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"batchDurationOperation","parameters":["halveDuration"]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"setPitch","parameters":["b"]},{"method":"moveSelectionRight","parameters":[]},{"method":"deleteNote","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"batchDurationOperation","parameters":["halveDuration"]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["g"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["a"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["b"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["c"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["a"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["b"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["g"]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"beamSelections","parameters":[]},{"method":"moveSelectionDown","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"batchDurationOperation","parameters":["halveDuration"]},{"method":"batchDurationOperation","parameters":["halveDuration"]},{"method":"moveSelectionRight","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"batchDurationOperation","parameters":["halveDuration"]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"setPitch","parameters":["g"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["a"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["b"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["c"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["a"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["b"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["g"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["d"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["g"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["f"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["g"]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"transposeSelections","parameters":[1]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"beamSelections","parameters":[]},{"method":"beamSelections","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"beamSelections","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"advanceModifierSelection","parameters":[{"type":"keydown","shiftKey":false,"ctrlKey":false}]},{"method":"moveSelectionLeftMeasure","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"beamSelections","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"forceSystemBreak","parameters":[true]},{"method":"selectSuggestionNote","parameters":[{"staff":0,"measure":6,"voice":0,"tick":1,"pitches":[]},{"type":"click","shiftKey":false,"ctrlKey":false}]},{"method":"moveSelectionLeft","parameters":[]},{"method":"setPitch","parameters":["g"]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveEnd","parameters":[]},{"method":"addMeasure","parameters":[true]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionUp","parameters":[]},{"method":"setPitch","parameters":["f"]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"batchDurationOperation","parameters":["halveDuration"]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"transposeSelections","parameters":[1]},{"method":"moveSelectionRight","parameters":[]},{"method":"deleteNote","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"batchDurationOperation","parameters":["halveDuration"]},{"method":"batchDurationOperation","parameters":["halveDuration"]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["a"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["b"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["c"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["d"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["b"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["c"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["a"]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"beamSelections","parameters":[]},{"method":"moveSelectionDown","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"batchDurationOperation","parameters":["halveDuration"]},{"method":"batchDurationOperation","parameters":["halveDuration"]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["a"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["d"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["e"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["f"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["g"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["e"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["f"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["d"]},{"method":"moveSelectionRight","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"batchDurationOperation","parameters":["halveDuration"]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["a"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["d"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["c"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["d"]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"transposeSelections","parameters":[12]},{"method":"moveSelectionLeft","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"beamSelections","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"transposeSelections","parameters":[1]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"transposeSelections","parameters":[1]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"toggleArticulation","parameters":["staccato","SmoArticulation"]},{"method":"moveSelectionUp","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"crescendo","parameters":[]},{"method":"addMeasure","parameters":[true]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["b"]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"batchDurationOperation","parameters":["halveDuration"]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"deleteNote","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"batchDurationOperation","parameters":["halveDuration"]},{"method":"batchDurationOperation","parameters":["halveDuration"]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"setPitch","parameters":["d"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["c"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["b"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["a"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["c"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["b"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["d"]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"growSelectionLeft","parameters":[]},{"method":"growSelectionLeft","parameters":[]},{"method":"beamSelections","parameters":[]},{"method":"moveSelectionDown","parameters":[]},{"method":"changeInstrument","parameters":[{"instrumentName":"Treble Instrument","keyOffset":0,"clef":"treble"}]},{"method":"growSelectionRight","parameters":[]},{"method":"batchDurationOperation","parameters":["halveDuration"]},{"method":"batchDurationOperation","parameters":["halveDuration"]},{"method":"setPitch","parameters":["g"]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"transposeSelections","parameters":[-12]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["g"]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"setPitch","parameters":["f"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["e"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["d"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["f"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["e"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["g"]},{"method":"moveSelectionRight","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"batchDurationOperation","parameters":["halveDuration"]},{"method":"setPitch","parameters":["g"]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"setPitch","parameters":["f"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["g"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["e"]},{"method":"moveSelectionRight","parameters":[]},{"method":"addMeasure","parameters":[true]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionUp","parameters":[]},{"method":"batchDurationOperation","parameters":["halveDuration"]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["c"]},{"method":"moveSelectionRight","parameters":[]},{"method":"deleteNote","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"batchDurationOperation","parameters":["halveDuration"]},{"method":"batchDurationOperation","parameters":["halveDuration"]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["e"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["d"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["c"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["b"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["d"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["c"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["e"]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"transposeSelections","parameters":[1]},{"method":"toggleEnharmonic","parameters":[]},{"method":"toggleEnharmonic","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"beamSelections","parameters":[]},{"method":"moveSelectionDown","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"batchDurationOperation","parameters":["halveDuration"]},{"method":"batchDurationOperation","parameters":["halveDuration"]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["e"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["a"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["g"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["f"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["e"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["g"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["f"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["a"]},{"method":"moveSelectionRight","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"batchDurationOperation","parameters":["halveDuration"]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["g"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["f"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["g"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["e"]},{"method":"moveSelectionRight","parameters":[]},{"method":"growSelectionLeft","parameters":[]},{"method":"growSelectionLeft","parameters":[]},{"method":"growSelectionLeft","parameters":[]},{"method":"beamSelections","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"forceSystemBreak","parameters":[true]},{"method":"selectSuggestionNote","parameters":[{"staff":0,"measure":9,"voice":0,"tick":10,"pitches":[]},{"type":"click","shiftKey":false,"ctrlKey":false}]},{"method":"addMeasure","parameters":[true]},{"method":"moveSelectionRight","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"batchDurationOperation","parameters":["halveDuration"]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["d"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["e"]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"setPitch","parameters":["c"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["d"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["e"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["f"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["a"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["b"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["c"]},{"method":"moveSelectionRight","parameters":[]},{"method":"growSelectionLeft","parameters":[]},{"method":"growSelectionLeft","parameters":[]},{"method":"transposeSelections","parameters":[-12]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"transposeSelections","parameters":[1]},{"method":"toggleEnharmonic","parameters":[]},{"method":"toggleEnharmonic","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"transposeSelections","parameters":[1]},{"method":"moveSelectionDown","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"batchDurationOperation","parameters":["halveDuration"]},{"method":"batchDurationOperation","parameters":["halveDuration"]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["f"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["b"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["a"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["g"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["f"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["a"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["g"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["b"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["a"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["g"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["f"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["e"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["d"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["f"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["e"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["g"]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"transposeSelections","parameters":[-1]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"transposeSelections","parameters":[-1]},{"method":"addMeasure","parameters":[true]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionUp","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"batchDurationOperation","parameters":["halveDuration"]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["d"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["f"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["g"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["a"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["b"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["c"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["d"]},{"method":"moveSelectionRight","parameters":[]},{"method":"growSelectionLeft","parameters":[]},{"method":"growSelectionLeft","parameters":[]},{"method":"growSelectionLeft","parameters":[]},{"method":"growSelectionLeft","parameters":[]},{"method":"growSelectionLeft","parameters":[]},{"method":"transposeSelections","parameters":[-12]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"transposeSelections","parameters":[1]},{"method":"moveSelectionRight","parameters":[]},{"method":"transposeSelections","parameters":[1]},{"method":"toggleEnharmonic","parameters":[]},{"method":"toggleEnharmonic","parameters":[]},{"method":"toggleEnharmonic","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"growSelectionLeft","parameters":[]},{"method":"growSelectionLeft","parameters":[]},{"method":"growSelectionLeft","parameters":[]},{"method":"growSelectionLeft","parameters":[]},{"method":"growSelectionLeft","parameters":[]},{"method":"slur","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"beamSelections","parameters":[]},{"method":"toggleBeamDirection","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"toggleBeamDirection","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"slur","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"slur","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"beamSelections","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"toggleBeamDirection","parameters":[]},{"method":"beamSelections","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"advanceModifierSelection","parameters":[{"type":"keydown","shiftKey":false,"ctrlKey":false}]},{"method":"addOrUpdateStaffModifier","parameters":[{"startSelector":{"staff":0,"measure":10,"voice":0,"tick":1,"pitches":[]},"endSelector":{"staff":0,"measure":10,"voice":0,"tick":4,"pitches":[]},"invert":true,"ctor":"SmoSlur"}]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionDown","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"growSelectionRight","parameters":[]},{"method":"batchDurationOperation","parameters":["halveDuration"]},{"method":"batchDurationOperation","parameters":["halveDuration"]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["f"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["e"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["d"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["c"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["b"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["d"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["c"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["e"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["d"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["c"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["b"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["a"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["g"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["b"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["a"]},{"method":"moveSelectionRight","parameters":[]},{"method":"setPitch","parameters":["c"]},{"method":"moveSelectionRight","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"moveSelectionLeft","parameters":[]},{"method":"transposeSelections","parameters":[1]},{"method":"toggleEnharmonic","parameters":[]},{"method":"toggleEnharmonic","parameters":[]},{"method":"toggleEnharmonic","parameters":[]}]`;
;var yamaJson = `{"a":{"b":{"c":30,"d":30,"e":50,"f":40,"g":816,"h":1056,"i":0,"j":30,"k":10,"l":0.65,"m":1.9162210338680927,"n":2,"o":2},"q":0,"r":{},"me":[{"ne":"engraving","oe":1,"xb":"Petaluma","wb":1,"pe":false},{"ne":"score","oe":2,"xb":"Merriweather","wb":14,"pe":false},{"ne":"chords","oe":3,"xb":"Roboto Slab","wb":14,"pe":false},{"ne":"lyrics","oe":4,"xb":"Merriweather","wb":12,"pe":false}]},"s":[{"t":0,"u":10,"v":40,"w":0,"x":1600,"y":90,"q":0,"r":{},"z":{},"aa":{"ba":"Treble Instrument","ca":"0","da":"treble"},"ea":[{"fa":{"ga":0,"ha":0,"ia":0,"ja":2,"ka":[]},"la":{"ga":0,"ha":0,"ia":0,"ja":3,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":2,"ia":0,"ja":2,"ka":[]},"la":{"ga":0,"ha":2,"ia":0,"ja":3,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":2,"ia":0,"ja":2,"ka":[]},"la":{"ga":0,"ha":2,"ia":0,"ja":3,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":5,"ia":0,"ja":3,"ka":[]},"la":{"ga":0,"ha":5,"ia":0,"ja":4,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":6,"ia":0,"ja":3,"ka":[]},"la":{"ga":0,"ha":6,"ia":0,"ja":4,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":1,"ia":0,"ja":2,"ka":[]},"la":{"ga":0,"ha":1,"ia":0,"ja":3,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":3,"ia":0,"ja":2,"ka":[]},"la":{"ga":0,"ha":3,"ia":0,"ja":3,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":7,"ia":0,"ja":3,"ka":[]},"la":{"ga":0,"ha":7,"ia":0,"ja":4,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":10,"ia":0,"ja":1,"ka":[]},"la":{"ga":0,"ha":10,"ia":0,"ja":2,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":10,"ia":0,"ja":4,"ka":[]},"la":{"ga":0,"ha":10,"ia":0,"ja":5,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":11,"ia":0,"ja":4,"ka":[]},"la":{"ga":0,"ha":11,"ia":0,"ja":5,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":15,"ia":0,"ja":1,"ka":[]},"la":{"ga":0,"ha":15,"ia":0,"ja":2,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":16,"ia":0,"ja":1,"ka":[]},"la":{"ga":0,"ha":16,"ia":0,"ja":2,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":17,"ia":0,"ja":12,"ka":[]},"la":{"ga":0,"ha":17,"ia":0,"ja":13,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":17,"ia":0,"ja":14,"ka":[]},"la":{"ga":0,"ha":18,"ia":0,"ja":0,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":18,"ia":0,"ja":9,"ka":[]},"la":{"ga":0,"ha":18,"ia":0,"ja":10,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":20,"ia":0,"ja":15,"ka":[]},"la":{"ga":0,"ha":20,"ia":0,"ja":16,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":25,"ia":0,"ja":12,"ka":[]},"la":{"ga":0,"ha":25,"ia":0,"ja":13,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":24,"ia":0,"ja":8,"ka":[]},"la":{"ga":0,"ha":24,"ia":0,"ja":9,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":25,"ia":0,"ja":8,"ka":[]},"la":{"ga":0,"ha":25,"ia":0,"ja":9,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":26,"ia":0,"ja":1,"ka":[]},"la":{"ga":0,"ha":26,"ia":0,"ja":2,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":26,"ia":0,"ja":11,"ka":[]},"la":{"ga":0,"ha":26,"ia":0,"ja":12,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":29,"ia":0,"ja":1,"ka":[]},"la":{"ga":0,"ha":29,"ia":0,"ja":2,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":36,"ia":0,"ja":1,"ka":[]},"la":{"ga":0,"ha":36,"ia":0,"ja":2,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":36,"ia":0,"ja":9,"ka":[]},"la":{"ga":0,"ha":36,"ia":0,"ja":10,"ka":[]},"ua":4,"sa":"SmoSlur"},{"fa":{"ga":0,"ha":36,"ia":0,"ja":11,"ka":[]},"la":{"ga":0,"ha":36,"ia":0,"ja":12,"ka":[]},"ua":4,"sa":"SmoSlur"}],"va":[{"ya":{"ya":0,"za":0,"ab":0,"t":0},"qe":2,"bb":77.42,"cb":[{"pa":{"qa":"auto196875","ra":"SmoTuplet"},"q":3},{"pa":{"qa":"auto203439","ra":"SmoTuplet"},"q":6},{"ud":[2,1],"pa":{"qa":"auto210860","ra":"SmoTuplet"},"q":1}],"db":[{"eb":[{"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"gc":8,"sa":"SmoLyric","ke":"G^-7"}]},{"fb":{"gb":2730,"hb":1,"ib":1},"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","od":{"qa":"auto210860","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":1365,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"od":{"qa":"auto210860","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":1365,"hb":1,"ib":1},"ka":[{"jb":"a","lb":"n","kb":4}],"od":{"qa":"auto196875","ra":"SmoTuplet"},"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"gc":12,"sa":"SmoLyric","ke":"C^7"}]},{"fb":{"gb":1365,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"od":{"qa":"auto196875","ra":"SmoTuplet"},"da":"treble","re":""},{"fb":{"gb":1365,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"od":{"qa":"auto196875","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":1365,"hb":1,"ib":1},"ka":[{"jb":"a","lb":"n","kb":4}],"od":{"qa":"auto203439","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":1365,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"od":{"qa":"auto203439","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":1365,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":4}],"od":{"qa":"auto203439","ra":"SmoTuplet"},"da":"treble"}]}],"ea":[]},{"ya":{"ya":1,"za":1,"ab":1,"t":0},"qe":2,"bb":6,"cb":[{"ud":[2,1],"pa":{"qa":"auto11224","ra":"SmoTuplet"},"q":1},{"pa":{"qa":"auto11233","ra":"SmoTuplet"},"q":3},{"pa":{"qa":"auto11240","ra":"SmoTuplet"},"q":6}],"db":[{"eb":[{"ka":[{"jb":"d","lb":"n","kb":4}],"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"gc":13,"sa":"SmoLyric","ke":"G^-7"}]},{"fb":{"gb":2730,"hb":1,"ib":1},"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","od":{"qa":"auto11224","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":1365,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"od":{"qa":"auto11224","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":1365,"hb":1,"ib":1},"ka":[{"jb":"a","lb":"n","kb":4}],"od":{"qa":"auto11233","ra":"SmoTuplet"},"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"gc":9,"sa":"SmoLyric","ke":"C7"}]},{"fb":{"gb":1365,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"od":{"qa":"auto11233","ra":"SmoTuplet"},"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric"}]},{"fb":{"gb":1365,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"od":{"qa":"auto11233","ra":"SmoTuplet"},"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric"}]},{"fb":{"gb":1365,"hb":1,"ib":1},"ka":[{"jb":"a","lb":"n","kb":4}],"od":{"qa":"auto11240","ra":"SmoTuplet"},"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric"}]},{"fb":{"gb":1365,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"od":{"qa":"auto11240","ra":"SmoTuplet"},"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric"}]},{"fb":{"gb":1365,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":4}],"od":{"qa":"auto11240","ra":"SmoTuplet"},"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric"}]}]}],"ea":[]},{"ya":{"ya":2,"za":2,"ab":2,"t":0},"qe":2,"bb":6,"be":83,"cb":[{"ud":[2,1],"pa":{"qa":"auto8246","ra":"SmoTuplet"},"q":1},{"pa":{"qa":"auto8256","ra":"SmoTuplet"},"q":3},{"pa":{"qa":"auto8263","ra":"SmoTuplet"},"q":6}],"db":[{"eb":[{"ka":[{"jb":"d","lb":"n","kb":4}],"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric","ke":"G^-7"}]},{"fb":{"gb":2730,"hb":1,"ib":1},"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","od":{"qa":"auto8246","ra":"SmoTuplet"},"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric"}]},{"fb":{"gb":1365,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"od":{"qa":"auto8246","ra":"SmoTuplet"},"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric"}]},{"fb":{"gb":1365,"hb":1,"ib":1},"ka":[{"jb":"a","lb":"n","kb":4}],"od":{"qa":"auto8256","ra":"SmoTuplet"},"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"gc":9,"sa":"SmoLyric","ke":"C^7"}]},{"fb":{"gb":1365,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"od":{"qa":"auto8256","ra":"SmoTuplet"},"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric"}]},{"fb":{"gb":1365,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"od":{"qa":"auto8256","ra":"SmoTuplet"},"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric"}]},{"fb":{"gb":1365,"hb":1,"ib":1},"ka":[{"jb":"a","lb":"n","kb":4}],"od":{"qa":"auto8263","ra":"SmoTuplet"},"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric"}]},{"fb":{"gb":1365,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"od":{"qa":"auto8263","ra":"SmoTuplet"},"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric"}]},{"fb":{"gb":1365,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":4}],"od":{"qa":"auto8263","ra":"SmoTuplet"},"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric"}]}]}],"ea":[]},{"ya":{"ya":3,"za":3,"ab":3,"t":0},"qe":2,"bb":6,"cb":[{"ud":[2,1],"pa":{"qa":"auto31809","ra":"SmoTuplet"},"q":1},{"pa":{"qa":"auto31819","ra":"SmoTuplet"},"q":3},{"pa":{"qa":"auto31826","ra":"SmoTuplet"},"q":6}],"db":[{"eb":[{"ka":[{"jb":"d","lb":"n","kb":4}],"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric","ke":"G^-7"}]},{"fb":{"gb":2730,"hb":1,"ib":1},"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","od":{"qa":"auto31809","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":1365,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"od":{"qa":"auto31809","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":1365,"hb":1,"ib":1},"ka":[{"jb":"a","lb":"n","kb":4}],"od":{"qa":"auto31819","ra":"SmoTuplet"},"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"gc":10,"sa":"SmoLyric","ke":"C^7"}]},{"fb":{"gb":1365,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"od":{"qa":"auto31819","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":1365,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"od":{"qa":"auto31819","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":1365,"hb":1,"ib":1},"ka":[{"jb":"g","lb":"n","kb":4}],"od":{"qa":"auto31826","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":1365,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":4}],"od":{"qa":"auto31826","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":1365,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":4}],"oc":"r","od":{"qa":"auto31826","ra":"SmoTuplet"},"da":"treble"}]}],"ea":[{"kd":1,"sa":"SmoBarline"}]},{"ld":true,"ya":{"ya":4,"za":4,"ab":0,"t":0},"qe":2,"bb":58.94,"cb":[],"db":[{"eb":[{"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric","ke":"G^-7"}]},{"ka":[{"jb":"b","lb":"b","kb":4}],"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric"}]},{"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric","ke":"F^Maj7"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric"}]}]}],"ea":[{"sa":"SmoRehearsalMark"}]},{"ya":{"ya":5,"za":5,"ab":1,"t":0},"qe":2,"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":4}],"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric","ke":"Eb^7"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"b","kb":4}],"da":"treble","re":"x2","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":4}],"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric"}]},{"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric","ke":"C^7"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"da":"treble"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric"}]}]}],"ea":[]},{"ya":{"ya":6,"za":6,"ab":2,"t":0},"qe":2,"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":4}],"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric","ke":"Db^7"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":4,"pc":true}],"da":"treble","re":"x2","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":4}],"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric"}]},{"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric","ke":"Ab^-7"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":4}],"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric"}]}]}],"ea":[]},{"ya":{"ya":7,"za":7,"ab":3,"t":0},"qe":2,"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric","ke":"Eb^7"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":4}],"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric"}]},{"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric","ke":"D^7"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"da":"treble"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble"}]}],"ea":[]},{"ld":true,"ya":{"ya":8,"za":8,"ab":0,"t":0},"qe":2,"bb":58.94,"cb":[],"db":[{"eb":[{"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric","ke":"G^-7"}],"fd":[{"hd":"SCOOP","sa":"SmoOrnament"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"#","kb":4}],"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric","ke":"D^7+5"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":4}],"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":4}],"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"#","kb":4}],"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric"}]}]}],"ea":[]},{"ya":{"ya":9,"za":9,"ab":1,"t":0},"qe":2,"bb":6,"cb":[{"pa":{"qa":"auto100919","ra":"SmoTuplet"},"q":1}],"db":[{"eb":[{"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric","ke":"Eb^7"}]},{"fb":{"gb":1365,"hb":1,"ib":1},"ka":[{"jb":"e","lb":"b","kb":4}],"od":{"qa":"auto100919","ra":"SmoTuplet"},"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric"}]},{"fb":{"gb":1365,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":4}],"od":{"qa":"auto100919","ra":"SmoTuplet"},"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric"}]},{"fb":{"gb":1365,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"od":{"qa":"auto100919","ra":"SmoTuplet"},"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric"}]},{"ka":[{"jb":"f","lb":"n","kb":4}],"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric","ke":"Ab^-7"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble","rb":true,"qb":2048,"sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":4}],"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric"}]}]}],"ea":[]},{"ya":{"ya":10,"za":10,"ab":2,"t":0},"qe":2,"bb":6,"be":10,"cb":[],"db":[{"eb":[{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":3}],"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric","ke":"G^-7"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"#","kb":4}],"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric"}]},{"ka":[{"jb":"f","lb":"#","kb":4}],"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":3}],"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric","ke":"F^Maj7"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":4}],"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric"}]},{"ka":[{"jb":"e","lb":"n","kb":4}],"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric"}]}]}],"ea":[]},{"ya":{"ya":11,"za":11,"ab":3,"t":0},"qe":2,"bb":6,"cb":[{"ud":[2,1],"pa":{"qa":"auto303621","ra":"SmoTuplet"},"q":0},{"pa":{"qa":"auto320948","ra":"SmoTuplet"},"q":6},{"pa":{"qa":"auto10785","ra":"SmoTuplet"},"q":2}],"db":[{"eb":[{"fb":{"gb":2730,"hb":1,"ib":1},"ka":[{"jb":"g","lb":"n","kb":4}],"od":{"qa":"auto303621","ra":"SmoTuplet"},"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"gc":14,"sa":"SmoLyric","ke":"Eb^7"}],"qc":[{"ua":"below","rc":"staccato","sa":"SmoArticulation"}]},{"fb":{"gb":1365,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"od":{"qa":"auto303621","ra":"SmoTuplet"},"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric"}]},{"fb":{"gb":1365,"hb":1,"ib":1},"ka":[{"jb":"c","lb":"n","kb":5}],"od":{"qa":"auto10785","ra":"SmoTuplet"},"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric"}]},{"fb":{"gb":1365,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"b","kb":5}],"od":{"qa":"auto10785","ra":"SmoTuplet"},"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric"}]},{"fb":{"gb":1365,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"od":{"qa":"auto10785","ra":"SmoTuplet"},"da":"treble"},{"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric","ke":"D^7"}]},{"fb":{"gb":1365,"hb":1,"ib":1},"ka":[{"jb":"a","lb":"b","kb":4}],"oc":"r","od":{"qa":"auto320948","ra":"SmoTuplet"},"da":"treble","rb":true,"qb":1366,"sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"gc":7,"sa":"SmoLyric"}]},{"fb":{"gb":1365,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"od":{"qa":"auto320948","ra":"SmoTuplet"},"da":"treble","rb":true,"qb":1365,"sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric"}]},{"fb":{"gb":1365,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":4}],"od":{"qa":"auto320948","ra":"SmoTuplet"},"da":"treble","rb":true,"qb":1365}]}],"ea":[]},{"ld":true,"ya":{"ya":12,"za":12,"ab":0,"t":0},"qe":2,"bb":58.94,"cb":[{"ud":[1,2],"pa":{"qa":"auto46986","ra":"SmoTuplet"},"q":3}],"db":[{"eb":[{"fb":{"gb":8192,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric","ke":"G^-7"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble","rb":true,"qb":2048,"sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","rb":true,"qb":2048,"tc":1,"sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric","ke":"C^7"}]},{"fb":{"gb":1365,"hb":1,"ib":1},"ka":[{"jb":"c","lb":"n","kb":5}],"od":{"qa":"auto46986","ra":"SmoTuplet"},"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric"}]},{"fb":{"gb":2730,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"od":{"qa":"auto46986","ra":"SmoTuplet"},"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric"}]}]}],"ea":[]},{"ya":{"ya":13,"za":13,"ab":1,"t":0},"qe":2,"bb":6,"cb":[{"td":1024,"ud":[1,1,1,1,1],"pa":{"qa":"auto147967","ra":"SmoTuplet"},"q":1}],"db":[{"eb":[{"fb":{"gb":12288,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric","ke":"F^7"}]},{"fb":{"gb":819,"hb":1,"ib":1},"ka":[{"jb":"d","lb":"b","kb":5}],"od":{"qa":"auto147967","ra":"SmoTuplet"},"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric","ke":"Bb^7"}]},{"fb":{"gb":819,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"od":{"qa":"auto147967","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":819,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"od":{"qa":"auto147967","ra":"SmoTuplet"},"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric"}]},{"fb":{"gb":819,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"od":{"qa":"auto147967","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":819,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","od":{"qa":"auto147967","ra":"SmoTuplet"},"da":"treble"}]}],"ea":[]},{"ya":{"ya":14,"za":14,"ab":2,"t":0},"qe":2,"bb":6,"cb":[{"ud":[2,1],"pa":{"qa":"auto127112","ra":"SmoTuplet"},"q":1},{"pa":{"qa":"auto127379","ra":"SmoTuplet"},"q":4}],"db":[{"eb":[{"fb":{"gb":8192,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric","ke":"Eb^7"}]},{"fb":{"gb":2730,"hb":1,"ib":1},"ka":[{"jb":"c","lb":"n","kb":4}],"oc":"r","od":{"qa":"auto127112","ra":"SmoTuplet"},"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"gc":14,"sa":"SmoLyric","ke":"D^7"}]},{"fb":{"gb":1365,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":4}],"od":{"qa":"auto127112","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":1365,"hb":1,"ib":1},"ka":[{"jb":"f","lb":"n","kb":4}],"od":{"qa":"auto127379","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":1365,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":4}],"od":{"qa":"auto127379","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":1365,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":4}],"od":{"qa":"auto127379","ra":"SmoTuplet"},"da":"treble"}]}],"ea":[]},{"ya":{"ya":15,"za":15,"ab":3,"t":0},"qe":2,"bb":6,"cb":[{"pa":{"qa":"auto239480","ra":"SmoTuplet"},"q":3}],"db":[{"eb":[{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric","ke":"G^-7"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","rb":true,"qb":2048},{"ka":[{"jb":"g","lb":"n","kb":4}],"od":{},"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"gc":10,"sa":"SmoLyric","ke":"C^7"}]},{"fb":{"gb":1365,"hb":1,"ib":1},"ka":[{"jb":"f","lb":"n","kb":4}],"od":{"qa":"auto239480","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":1365,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":4}],"od":{"qa":"auto239480","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":1365,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":4}],"od":{"qa":"auto239480","ra":"SmoTuplet"},"da":"treble"}]}],"ea":[]},{"ya":{"ya":16,"za":16,"ab":4,"t":0},"qe":2,"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":6144,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"gc":1,"sa":"SmoLyric","ke":"G^-7"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","rb":true,"qb":2048,"sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric","ke":"C^7"}]},{"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble"},{"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble"}]}],"ea":[{"kd":1,"sa":"SmoBarline"}]},{"ld":true,"ya":{"ya":17,"za":17,"ab":0,"t":0},"qe":2,"bb":58.94,"be":-25,"cb":[{"ud":[1,1,0.5,0.5],"pa":{"qa":"auto32682","ra":"SmoTuplet"},"q":8}],"db":[{"eb":[{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric","ke":"G^-7"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":5}],"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":5}],"oc":"r","da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":5}],"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":6}],"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":5}],"oc":"r","da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":5}],"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric"}]},{"fb":{"gb":1365,"hb":1,"ib":2},"ka":[{"jb":"g","lb":"n","kb":5}],"od":{"qa":"auto32682","ra":"SmoTuplet"},"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"gc":9,"sa":"SmoLyric","ke":"F^Maj7"}]},{"fb":{"gb":1365,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"od":{"qa":"auto32682","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":682,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"od":{"qa":"auto32682","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":682,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"od":{"qa":"auto32682","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"b","kb":4}],"da":"treble"}]}],"ea":[]},{"ya":{"ya":18,"za":18,"ab":1,"t":0},"qe":2,"bb":6,"be":55,"de":12,"cb":[{"td":1024,"sd":2048,"pa":{"qa":"auto439759","ra":"SmoTuplet"},"q":1},{"ud":[1,2],"pa":{"qa":"auto152250","ra":"SmoTuplet"},"q":6},{"td":1024,"sd":2048,"pa":{"qa":"auto193687","ra":"SmoTuplet"},"q":5}],"db":[{"eb":[{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"b","kb":4}],"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"gc":10,"sa":"SmoLyric","ke":"Eb^7"}]},{"fb":{"gb":682,"hb":1,"ib":2},"ka":[{"jb":"f","lb":"n","kb":4}],"od":{"qa":"auto439759","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":682,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"od":{"qa":"auto439759","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":682,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"od":{"qa":"auto439759","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":682,"hb":1,"ib":2},"ka":[{"jb":"g","lb":"n","kb":4}],"od":{"qa":"auto193687","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":682,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"od":{"qa":"auto193687","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":682,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"od":{"qa":"auto193687","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":1365,"hb":1,"ib":1},"ka":[{"jb":"e","lb":"n","kb":4}],"od":{"qa":"auto152250","ra":"SmoTuplet"},"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"gc":16,"sa":"SmoLyric","ke":"C^7"}],"fd":[{"hd":"SCOOP","sa":"SmoOrnament"}]},{"fb":{"gb":2730,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":4}],"od":{"qa":"auto152250","ra":"SmoTuplet"},"da":"treble"},{"ka":[{"jb":"c","lb":"n","kb":4}],"da":"treble"}]}],"ea":[]},{"ya":{"ya":19,"za":19,"ab":2,"t":0},"qe":2,"bb":6,"be":41,"de":12,"cb":[],"db":[{"eb":[{"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric","ke":"Db^7"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"b","kb":4}],"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":4}],"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"b","kb":4}],"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric","ke":"Ab^-7"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"b","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"b","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"b","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"b","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"b","kb":4}],"da":"treble"}]}],"ea":[]},{"ya":{"ya":20,"za":20,"ab":0,"t":0},"qe":2,"bb":58.94,"cb":[{"td":1024,"sd":2048,"pa":{"qa":"auto52582","ra":"SmoTuplet"},"q":5},{"td":1024,"sd":2048,"pa":{"qa":"auto273903","ra":"SmoTuplet"},"q":10}],"db":[{"eb":[{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble","rb":true,"qb":2048,"sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric","ke":"Eb^7"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"b","kb":4}],"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":4}],"da":"treble","rb":true,"qb":1024,"sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric"}]},{"fb":{"gb":682,"hb":1,"ib":2},"ka":[{"jb":"a","lb":"n","kb":4}],"od":{"qa":"auto52582","ra":"SmoTuplet"},"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric"}]},{"fb":{"gb":682,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"od":{"qa":"auto52582","ra":"SmoTuplet"},"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric"}]},{"fb":{"gb":682,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"od":{"qa":"auto52582","ra":"SmoTuplet"},"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric","ke":"D^7"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":682,"hb":1,"ib":2},"ka":[{"jb":"f","lb":"#","kb":4}],"od":{"qa":"auto273903","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":682,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"od":{"qa":"auto273903","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":682,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"od":{"qa":"auto273903","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":512,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"b","kb":5}],"da":"treble","qb":2048},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":5}],"da":"treble","qb":2048},{"fb":{"gb":512,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","rb":true,"qb":2048},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":2048},{"fb":{"gb":512,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","qb":2048},{"fb":{"gb":512,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","rb":true,"qb":2048}]}],"ea":[]},{"ya":{"ya":21,"za":21,"ab":1,"t":0},"qe":2,"bb":6,"cb":[],"db":[{"eb":[{"ka":[{"jb":"b","lb":"b","kb":4}],"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric","ke":"G^-7"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric"}]},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"b","kb":5}],"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"gc":6,"sa":"SmoLyric","ke":"D^7+5"}]},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"b","kb":5}],"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"b","kb":4}],"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric"}]},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"b","kb":4}],"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric"}]}]}],"ea":[]},{"ya":{"ya":22,"za":22,"ab":2,"t":0},"qe":2,"bb":6,"de":-8,"cb":[],"db":[{"eb":[{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble","rb":true,"qb":2048,"sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric","ke":"Db^7"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"b","kb":4}],"da":"treble","qb":2048,"sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":4}],"da":"treble","rb":true,"qb":2048,"sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"b","kb":4}],"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric","ke":"Ab-7"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"b","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"b","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"b","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"b","kb":5}],"da":"treble","rb":true,"qb":1024},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"oc":"r","da":"treble"}]}],"ea":[]},{"ya":{"ya":23,"za":23,"ab":0,"t":0},"qe":2,"bb":58.94,"cb":[],"db":[{"eb":[{"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"gc":13,"sa":"SmoLyric","ke":"G^-7"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"b","kb":5}],"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":5}],"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":6}],"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":5}],"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":5}],"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric","ke":"F^Maj7"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"#","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"#","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"#","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"da":"treble"}]}],"ea":[]},{"ya":{"ya":24,"za":24,"ab":1,"t":0},"qe":2,"bb":6,"cb":[{"td":1024,"sd":2048,"pa":{"qa":"auto639348","ra":"SmoTuplet"},"q":0},{"td":1024,"sd":2048,"pa":{"qa":"auto1649531","ra":"SmoTuplet"},"q":4},{"td":1024,"sd":2048,"pa":{"qa":"auto1805448","ra":"SmoTuplet"},"q":10}],"db":[{"eb":[{"fb":{"gb":682,"hb":1,"ib":2},"ka":[{"jb":"a","lb":"n","kb":4}],"od":{"qa":"auto639348","ra":"SmoTuplet"},"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"gc":17,"sa":"SmoLyric","ke":"Eb^7"}]},{"fb":{"gb":682,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"od":{"qa":"auto639348","ra":"SmoTuplet"},"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric"}]},{"fb":{"gb":682,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"od":{"qa":"auto639348","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","rb":true},{"fb":{"gb":682,"hb":1,"ib":2},"ka":[{"jb":"g","lb":"n","kb":4}],"od":{"qa":"auto1649531","ra":"SmoTuplet"},"da":"treble","qb":684},{"fb":{"gb":682,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"od":{"qa":"auto1649531","ra":"SmoTuplet"},"da":"treble","rb":true,"qb":682},{"fb":{"gb":682,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"od":{"qa":"auto1649531","ra":"SmoTuplet"},"da":"treble","rb":true,"qb":682},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":5}],"da":"treble","qb":2048},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"b","kb":5}],"da":"treble","rb":true,"qb":2048},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"b","kb":5}],"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric","ke":"D^7"}]},{"fb":{"gb":682,"hb":1,"ib":2},"ka":[{"jb":"b","lb":"b","kb":4}],"od":{"qa":"auto1805448","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":682,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"od":{"qa":"auto1805448","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":682,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"od":{"qa":"auto1805448","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"b","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":4}],"da":"treble"}]}],"ea":[]},{"ya":{"ya":25,"za":25,"ab":2,"t":0},"qe":2,"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":3}],"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"gc":9,"sa":"SmoLyric","ke":"G^-7"}]},{"fb":{"gb":512,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":512,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"da":"treble"},{"fb":{"gb":512,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":512,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"b","kb":4}],"oc":"r","da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":5}],"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"gc":5,"sa":"SmoLyric","ke":"C^7"}],"fd":[{"hd":"SCOOP","sa":"SmoOrnament"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"oc":"r","da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric"}]}]}],"ea":[]},{"ya":{"ya":26,"za":26,"ab":0,"t":0},"qe":2,"bb":58.94,"cb":[{"td":1024,"sd":2048,"pa":{"qa":"auto2041825","ra":"SmoTuplet"},"q":11}],"db":[{"eb":[{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble","qb":2048,"sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric","ke":"F^7"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":2048},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":2048},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":5}],"da":"treble","qb":2048},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"b","kb":5}],"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric","ke":"Bb^7"}],"md":[{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"se":true,"sa":"SmoGraceNote"}]},{"fb":{"gb":682,"hb":1,"ib":2},"ka":[{"jb":"b","lb":"b","kb":4}],"od":{"qa":"auto2041825","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":682,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"od":{"qa":"auto2041825","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":682,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"od":{"qa":"auto2041825","ra":"SmoTuplet"},"da":"treble","rb":true},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"da":"treble"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"b","kb":4}],"oc":"r","od":{},"da":"treble"}]}],"ea":[]},{"ya":{"ya":27,"za":27,"ab":1,"t":0},"qe":2,"bb":6,"cb":[{"td":1024,"sd":2048,"pa":{"qa":"auto2138794","ra":"SmoTuplet"},"q":7},{"td":1024,"sd":2048,"pa":{"qa":"auto2410639","ra":"SmoTuplet"},"q":10}],"db":[{"eb":[{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"#","kb":5}],"oc":"r","da":"treble","rb":true,"qb":1024,"sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric","ke":"Eb^7"}]},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"b","kb":5}],"da":"treble","qb":2048},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"da":"treble"},{"fb":{"gb":682,"hb":1,"ib":2},"ka":[{"jb":"a","lb":"n","kb":4}],"od":{"qa":"auto2138794","ra":"SmoTuplet"},"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"gc":20,"sa":"SmoLyric","ke":"D^7"}]},{"fb":{"gb":682,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"od":{"qa":"auto2138794","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":682,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"od":{"qa":"auto2138794","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":4}],"da":"treble","rb":true},{"fb":{"gb":682,"hb":1,"ib":2},"ka":[{"jb":"f","lb":"#","kb":4}],"od":{"qa":"auto2410639","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":682,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"od":{"qa":"auto2410639","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":682,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"od":{"qa":"auto2410639","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"b","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":5}],"da":"treble","rb":true}]}],"ea":[]},{"ld":true,"ya":{"ya":28,"za":28,"ab":0,"t":0},"qe":2,"bb":58.94,"cb":[{"pa":{"qa":"auto310764","ra":"SmoTuplet"},"q":1},{"td":1024,"sd":2048,"pa":{"qa":"auto1286701","ra":"SmoTuplet"},"q":8},{"td":1024,"sd":2048,"pa":{"qa":"auto1323888","ra":"SmoTuplet"},"q":11}],"db":[{"eb":[{"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric","ke":"G^-7"}]},{"fb":{"gb":1365,"hb":1,"ib":1},"ka":[{"jb":"d","lb":"n","kb":5}],"oc":"r","od":{"qa":"auto310764","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":1365,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":5}],"od":{"qa":"auto310764","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":1365,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":5}],"od":{"qa":"auto310764","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":5}],"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric","ke":"C^7"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":682,"hb":1,"ib":2},"ka":[{"jb":"e","lb":"n","kb":5}],"od":{"qa":"auto1286701","ra":"SmoTuplet"},"da":"treble","md":[{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"#","kb":5}],"se":true,"sa":"SmoGraceNote"}]},{"fb":{"gb":682,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"oc":"r","od":{"qa":"auto1286701","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":682,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"od":{"qa":"auto1286701","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":682,"hb":1,"ib":2},"ka":[{"jb":"b","lb":"b","kb":4}],"od":{"qa":"auto1323888","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":682,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"od":{"qa":"auto1323888","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":682,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"od":{"qa":"auto1323888","ra":"SmoTuplet"},"da":"treble"}]}],"ea":[]},{"ya":{"ya":29,"za":29,"ab":1,"t":0},"qe":2,"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric","ke":"G^-7"}],"md":[{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"se":true,"sa":"SmoGraceNote"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble"},{"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble"},{"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric","ke":"C^7"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":6}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":5}],"da":"treble"}]}],"ea":[{"kd":1,"sa":"SmoBarline"}]},{"ld":true,"ya":{"ya":30,"za":30,"ab":0,"t":0},"qe":2,"bb":58.94,"cb":[],"db":[{"eb":[{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":6}],"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric","ke":"G^-7"}]},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric","ke":"F^Maj"}]},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":4}],"da":"treble"}]}],"ea":[]},{"ya":{"ya":31,"za":31,"ab":1,"t":0},"qe":2,"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"b","kb":4}],"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric","ke":"Eb^7"}]},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric"}]},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":4}],"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric","ke":"C^7"}]},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":4}],"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":3}],"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric"}]},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":4}],"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric"}]}]}],"ea":[]},{"ya":{"ya":32,"za":32,"ab":2,"t":0},"qe":2,"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"b","kb":4}],"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric","ke":"Db^7"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"b","kb":4}],"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":4}],"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric"}],"fd":[{"hd":"FALL_SHORT","sa":"SmoOrnament"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble","rb":true,"qb":1024,"sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"b","kb":4}],"da":"treble","qb":3072},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"b","kb":4}],"da":"treble","qb":3072},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"da":"treble","rb":true,"qb":3072},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"b","kb":5}],"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric","ke":"Ab^-7"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"b","kb":5,"pc":true}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"b","kb":5,"pc":true}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"b","kb":5}],"da":"treble","rb":true},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"b","kb":4}],"da":"treble","rb":true,"qb":1024},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble","rb":true,"qb":2048}]}],"ea":[]},{"ya":{"ya":33,"za":33,"ab":0,"t":0},"qe":2,"bb":58.94,"cb":[],"db":[{"eb":[{"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric","ke":"Eb^7"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble","rb":true,"qb":2048},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":5}],"da":"treble","rb":true,"qb":1024},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":5}],"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric","ke":"D^7"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":6}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":5}],"da":"treble","rb":true},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":5}],"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"#","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"b","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"#","kb":5}],"da":"treble"}]}],"ea":[]},{"ya":{"ya":34,"za":34,"ab":1,"t":0},"qe":2,"bb":6,"be":9,"cb":[{"td":1024,"sd":2048,"pa":{"qa":"auto2828176","ra":"SmoTuplet"},"q":1}],"db":[{"eb":[{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":5}],"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric","ke":"G^-7"}]},{"fb":{"gb":682,"hb":1,"ib":2},"ka":[{"jb":"e","lb":"n","kb":5}],"od":{"qa":"auto2828176","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":682,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"od":{"qa":"auto2828176","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":682,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"od":{"qa":"auto2828176","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":3072,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric","ke":"D^7+5"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"b","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"b","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"#","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"#","kb":4}],"da":"treble","rb":true,"qb":1024},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"#","kb":4}],"oc":"r","da":"treble"}]}],"ea":[]},{"ya":{"ya":35,"za":35,"ab":2,"t":0},"qe":2,"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":4}],"oc":"r","da":"treble","rb":true,"qb":2048,"sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric","ke":"Eb^7"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"b","kb":4}],"da":"treble","rb":true,"qb":1024},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"b","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble","rb":true},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"b","kb":5,"pc":true}],"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric","ke":"Ab^-7"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"b","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4,"pc":false}],"da":"treble"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"b","kb":4}],"da":"treble"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"b","kb":5}],"da":"treble"}]}],"ea":[]},{"ld":true,"ya":{"ya":36,"za":36,"ab":0,"t":0},"qe":2,"bb":58.94,"cb":[{"td":1024,"sd":2048,"pa":{"qa":"auto1152853","ra":"SmoTuplet"},"q":4}],"db":[{"eb":[{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble","qb":2048,"sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric","ke":"G^-7"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":2048,"fd":[{"hd":"SCOOP","sa":"SmoOrnament"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble","qb":2048},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"da":"treble","qb":2048},{"fb":{"gb":682,"hb":1,"ib":2},"ka":[{"jb":"a","lb":"n","kb":4}],"od":{"qa":"auto1152853","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":682,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"od":{"qa":"auto1152853","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":682,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"od":{"qa":"auto1152853","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"b","kb":4}],"oc":"r","da":"treble","rb":true},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":5}],"da":"treble","qb":3072,"sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"gc":6,"sa":"SmoLyric","ke":"F^Maj7"}],"fd":[{"hd":"SCOOP","sa":"SmoOrnament"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":5}],"da":"treble","qb":3072},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","rb":true,"qb":3072},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":4}],"da":"treble"}]}],"ea":[]},{"ya":{"ya":37,"za":37,"ab":1,"t":0},"qe":2,"bb":6,"cb":[{"td":1024,"sd":2048,"pa":{"qa":"auto2273973","ra":"SmoTuplet"},"q":0},{"td":1024,"sd":2048,"pa":{"qa":"auto2275359","ra":"SmoTuplet"},"q":3},{"td":1024,"sd":2048,"pa":{"qa":"auto2447172","ra":"SmoTuplet"},"q":6},{"td":1024,"sd":2048,"pa":{"qa":"auto2571791","ra":"SmoTuplet"},"q":9},{"td":1024,"sd":2048,"pa":{"qa":"auto2694259","ra":"SmoTuplet"},"q":15},{"td":1024,"sd":2048,"ud":[1,2],"pa":{"qa":"auto2816339","ra":"SmoTuplet"},"q":16},{"td":1024,"sd":2048,"ud":[2,1],"pa":{"qa":"auto2924730","ra":"SmoTuplet"},"q":18}],"db":[{"eb":[{"fb":{"gb":682,"hb":1,"ib":2},"ka":[{"jb":"b","lb":"b","kb":4}],"oc":"r","od":{"qa":"auto2273973","ra":"SmoTuplet"},"da":"treble","rb":true,"qb":2048,"sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"gc":9,"sa":"SmoLyric","ke":"Eb^7"}]},{"fb":{"gb":682,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"oc":"r","od":{"qa":"auto2273973","ra":"SmoTuplet"},"da":"treble","rb":true,"qb":2048},{"fb":{"gb":682,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":3}],"od":{"qa":"auto2273973","ra":"SmoTuplet"},"da":"treble","qb":2048},{"fb":{"gb":682,"hb":1,"ib":2},"ka":[{"jb":"d","lb":"b","kb":4}],"od":{"qa":"auto2275359","ra":"SmoTuplet"},"da":"treble","qb":2048},{"fb":{"gb":682,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"b","kb":4}],"od":{"qa":"auto2275359","ra":"SmoTuplet"},"da":"treble","qb":2048},{"fb":{"gb":682,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":4}],"od":{"qa":"auto2275359","ra":"SmoTuplet"},"da":"treble","rb":true,"qb":2048},{"fb":{"gb":682,"hb":1,"ib":2},"ka":[{"jb":"b","lb":"b","kb":4}],"od":{"qa":"auto2447172","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":682,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"od":{"qa":"auto2447172","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":682,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"oc":"r","od":{"qa":"auto2447172","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":682,"hb":1,"ib":2},"ka":[{"jb":"a","lb":"n","kb":4}],"od":{"qa":"auto2571791","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":682,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"oc":"r","od":{"qa":"auto2571791","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":682,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"od":{"qa":"auto2571791","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"#","kb":4}],"od":{},"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric","ke":"D^7"}]},{"fb":{"gb":682,"hb":1,"ib":2},"ka":[{"jb":"f","lb":"#","kb":4}],"od":{"qa":"auto2694259","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":682,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"od":{"qa":"auto2694259","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":682,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"od":{"qa":"auto2694259","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":682,"hb":1,"ib":1},"ka":[{"jb":"e","lb":"b","kb":5,"pc":true}],"od":{"qa":"auto2816339","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":1365,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":5}],"od":{"qa":"auto2816339","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":1365,"hb":1,"ib":1},"ka":[{"jb":"d","lb":"n","kb":5}],"od":{"qa":"auto2924730","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":682,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"od":{"qa":"auto2924730","ra":"SmoTuplet"},"da":"treble"}]}],"ea":[]},{"ya":{"ya":38,"za":38,"ab":0,"t":0},"qe":2,"bb":58.94,"cb":[],"db":[{"eb":[{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":5}],"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric","ke":"G^-7"}],"md":[{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"#","kb":5}],"sa":"SmoGraceNote"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":5}],"da":"treble","md":[{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"#","kb":5}],"sa":"SmoGraceNote"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":5}],"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric","ke":"C^7"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"b","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"#","kb":5}],"da":"treble"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble"}]}],"ea":[]},{"ya":{"ya":39,"za":39,"ab":1,"t":0},"qe":2,"bb":6,"cb":[],"db":[{"eb":[{"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric","ke":"F^7"}]},{"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":5}],"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric","ke":"Bb^7"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"#","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"da":"treble"}]}],"ea":[]},{"ya":{"ya":40,"za":40,"ab":2,"t":0},"qe":2,"bb":6,"cb":[],"db":[{"eb":[{"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric","ke":"Eb^7"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"b","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"b","kb":5}],"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"gc":10,"sa":"SmoLyric","ke":"D^7"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"b","kb":5}],"da":"treble"},{"fb":{"gb":512,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":512,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"f","lb":"#","kb":5,"pc":false}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":5}],"da":"treble"}]}],"ea":[]},{"ya":{"ya":41,"za":41,"ab":0,"t":0},"qe":2,"bb":58.94,"cb":[{"td":1024,"sd":2048,"pa":{"qa":"auto1143660","ra":"SmoTuplet"},"q":4}],"db":[{"eb":[{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":5}],"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric","ke":"G^-7"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"da":"treble"},{"fb":{"gb":682,"hb":1,"ib":2},"ka":[{"jb":"a","lb":"n","kb":4}],"od":{"qa":"auto1143660","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":682,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":4}],"od":{"qa":"auto1143660","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":682,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"od":{"qa":"auto1143660","ra":"SmoTuplet"},"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":5}],"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric","ke":"C^7"}],"fd":[{"hd":"SCOOP","sa":"SmoOrnament"}]},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble"},{"ka":[{"jb":"e","lb":"n","kb":4}],"da":"treble"}]}],"ea":[]},{"ya":{"ya":42,"za":42,"ab":1,"t":0},"qe":2,"bb":6,"cb":[],"db":[{"eb":[{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble","rb":true,"qb":1024},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"d","lb":"n","kb":4}],"da":"treble","rb":true,"qb":1024,"sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric","ke":"G^-7"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble","rb":true,"qb":1024},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"b","lb":"b","kb":3}],"da":"treble","rb":true,"qb":1024},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":3}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":3}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":3}],"da":"treble"},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"c","lb":"n","kb":4}],"da":"treble","sb":[{"vb":{"xb":"Petaluma Script","wb":14},"le":2,"sa":"SmoLyric","ke":"C^7"}]},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":4}],"oc":"r","da":"treble","rb":true,"qb":1024},{"fb":{"gb":2048,"hb":1,"ib":0},"ka":[{"jb":"a","lb":"n","kb":4}],"da":"treble"},{"fb":{"gb":1024,"hb":1,"ib":0},"ka":[{"jb":"e","lb":"n","kb":4}],"da":"treble"}]}],"ea":[{"kd":1,"sa":"SmoBarline"}]},{"ya":{"ya":43,"za":43,"ab":2,"t":0},"qe":2,"bb":6,"cb":[],"db":[{"eb":[{"ka":[{"jb":"g","lb":"n","kb":4}],"da":"treble"},{"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble"},{"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble"},{"ka":[{"jb":"b","lb":"n","kb":4}],"oc":"r","da":"treble"}]}],"ea":[]}]}],"yc":[],"ge":[{"he":[{"tb":{"sa":"SmoScoreText","pa":{"qa":"auto216651","ra":"SmoScoreText"},"zc":{},"ad":false,"jc":616,"kc":54,"tb":"Yama","bd":"once","ua":"custom","vb":{"wb":"1.8000000000000007em","xb":"Times New Roman","yb":"normal","zb":"normal"},"ac":"score-text auto29633 auto57045 auto216651","cd":"none","dd":"left","cc":"black","lc":0,"mc":0,"dc":1,"ec":1,"fc":0,"gc":0,"ed":false,"ic":{"jc":1019.78,"kc":-787.25,"lc":96.14,"mc":46.01},"nc":{"jc":616,"kc":24.28,"lc":77.2,"mc":36.95}},"ua":4}],"sa":"SmoTextGroup"},{"he":[{"tb":{"sa":"SmoScoreText","pa":{"qa":"auto216653","ra":"SmoScoreText"},"zc":{},"ad":false,"jc":692,"kc":48,"tb":"(as played by Lee Morgan)","bd":"once","ua":"custom","vb":{"wb":"1em","xb":"Merriweather","yb":"normal","zb":"normal"},"ac":"score-text auto29634 auto57047 auto216653","cd":"none","dd":"left","cc":"black","lc":0,"mc":0,"dc":1,"ec":1,"fc":0,"gc":0,"ed":false,"ic":{"jc":1114.41,"kc":-780.73,"lc":300.31,"mc":30.02},"nc":{"jc":692,"kc":29.52,"lc":241.17,"mc":24.11}},"ua":4}],"sa":"SmoTextGroup"},{"he":[{"tb":{"sa":"SmoScoreText","pa":{"qa":"auto216655","ra":"SmoScoreText"},"zc":{},"ad":false,"jc":1006,"kc":44,"tb":"Bb Trumpet","bd":"once","ua":"custom","vb":{"wb":"1em","xb":"Merriweather","yb":"normal","zb":"normal"},"ac":"score-text auto29635 auto57049 auto216655","cd":"none","dd":"left","cc":"black","lc":0,"mc":0,"dc":1,"ec":1,"fc":0,"gc":0,"ed":false,"ic":{"jc":1505.41,"kc":-785.71,"lc":137.32,"mc":29.03},"nc":{"jc":1006,"kc":25.52,"lc":110.28,"mc":23.31}},"ua":4}],"sa":"SmoTextGroup"},{"he":[{"tb":{"sa":"SmoScoreText","pa":{"qa":"auto216657","ra":"SmoScoreText"},"zc":{"jc":168.86,"kc":1149.35,"tb":"-----Lay Back","bd":"once","ua":"custom","vb":{"wb":"16pt","xb":"Petaluma Script","yb":"normal","zb":"normal","te":16},"ac":"score-text auto110460 auto216657","cd":"none","dd":"left","cc":"black","lc":0,"mc":0,"dc":1,"ec":1,"fc":0,"gc":0,"ed":false},"ad":false,"jc":168.86,"kc":1149.35,"tb":"--------------------------Lay Back","bd":"once","ua":"custom","vb":{"wb":"16pt","xb":"Petaluma Script","yb":"normal","zb":"normal","te":16},"ac":"score-text auto110460 auto216657","cd":"none","dd":"left","cc":"black","lc":0,"mc":0,"dc":1,"ec":1,"fc":0,"gc":0,"ed":false,"ic":{"jc":462.99,"kc":584.69,"lc":387.13,"mc":44.03},"nc":{"jc":168.86,"kc":1126.05,"lc":310.89,"mc":35.36}},"ua":4,"we":false}],"xe":true,"hc":{"ga":0,"ha":28,"ia":0,"ja":1,"ka":[]},"ye":122.86000000000001,"ze":-5.079999999999927,"sa":"SmoTextGroup"}],"yd":[],"ee":{"wa":{"0":"4/4"},"xa":{"0":"F"},"fe":{"0":{"sa":"SmoTempoText","pa":{"qa":"auto215637","ra":"SmoTempoText"},"id":"duration","nb":96,"ob":true,"pb":4096,"jd":"Allegro","ta":24},"1":{"sa":"SmoTempoText","pa":{"qa":"auto215661","ra":"SmoTempoText"},"id":"duration","nb":96,"ob":true,"pb":4096,"jd":"Allegro","ta":0}}},"dictionary":{"a":"score","b":"layout","c":"leftMargin","d":"rightMargin","e":"topMargin","f":"bottomMargin","g":"pageWidth","h":"pageHeight","i":"orientation","j":"interGap","k":"intraGap","l":"svgScale","m":"zoomScale","n":"zoomMode","o":"pages","p":"pageSize","q":"startIndex","r":"renumberingMap","s":"staves","t":"staffId","u":"staffX","v":"staffY","w":"adjY","x":"staffWidth","y":"staffHeight","z":"keySignatureMap","aa":"instrumentInfo","ba":"instrumentName","ca":"keyOffset","da":"clef","ea":"modifiers","fa":"startSelector","ga":"staff","ha":"measure","ia":"voice","ja":"tick","ka":"pitches","la":"endSelector","ma":"xOffset","na":"cp1y","oa":"cp2y","pa":"attrs","qa":"id","ra":"type","sa":"ctor","ta":"yOffset","ua":"position","va":"measures","wa":"timeSignature","xa":"keySignature","ya":"measureNumber","za":"measureIndex","ab":"systemIndex","bb":"adjX","cb":"tuplets","db":"voices","eb":"notes","fb":"ticks","gb":"numerator","hb":"denominator","ib":"remainder","jb":"letter","kb":"octave","lb":"accidental","mb":"symbol","nb":"bpm","ob":"display","pb":"beatDuration","qb":"beamBeats","rb":"endBeam","sb":"textModifiers","tb":"text","ub":"endChar","vb":"fontInfo","wb":"size","xb":"family","yb":"style","zb":"weight","ac":"classes","bc":"verse","cc":"fill","dc":"scaleX","ec":"scaleY","fc":"translateX","gc":"translateY","hc":"selector","ic":"renderedBox","jc":"x","kc":"y","lc":"width","mc":"height","nc":"logicalBox","oc":"noteType","pc":"cautionary","qc":"articulations","rc":"articulation","sc":"activeVoice","tc":"flagState","uc":"invert","vc":"fontSize","wc":"yOffsetLine","xc":"yOffsetPixels","yc":"scoreText","zc":"backup","ad":"edited","bd":"pagination","cd":"boxModel","dd":"justification","ed":"autoLayout","fd":"ornaments","gd":"offset","hd":"ornament","id":"tempoMode","jd":"tempoText","kd":"barline","ld":"systemBreak","md":"graceNotes","nd":"tones","od":"tuplet","pd":"beam_group","qd":"renderId","rd":"numNotes","sd":"totalTicks","td":"stemTicks","ud":"durationMap","vd":"bracketed","wd":"ratioed","xd":"location","yd":"systemGroups","zd":"leftConnector","ae":"padLeft","be":"customStretch","ce":"engravingFont","de":"customProportion","ee":"columnAttributeMap","fe":"tempo","ge":"textGroups","he":"textBlocks","ie":"backupBlocks","je":"blocks","ke":"_text","le":"parser","me":"fonts","ne":"name","oe":"purpose","pe":"custom","qe":"transposeIndex","re":"noteHead","se":"slash","te":"pointSize","ue":"spacing","ve":"relativePosition","we":"activeText","xe":"attachToSelector","ye":"musicXOffset","ze":"musicYOffset"}}`;
;// ## suiAudioPitch
// helper class to compute the frequencies of the notes.
// eslint-disable-next-line no-unused-vars
class suiAudioPitch {
  // ### _frequencies
  // Compute the equal-temperment frequencies of the notes.
  static get _frequencies() {
    const map = { };
    let lix = 0;
    const octaves = [1, 2, 3, 4, 5, 6, 7];
    const letters = ['cn', 'c#', 'dn', 'd#', 'en', 'fn', 'f#', 'gn', 'g#', 'an', 'a#', 'bn'];

    const just = Math.pow(2, (1.0 / 12));
    const baseFrequency = (440 / 16) * Math.pow(just, 3);

    octaves.forEach((octave) => {
      const oint = parseInt(octave, 10);
      const base = baseFrequency * Math.pow(2, oint);
      lix = 0;
      letters.forEach((letter) => {
        const freq = base * Math.pow(just, lix);
        var enharmonics = smoMusic.getEnharmonics(letter);
        enharmonics.forEach((en) => {
          // Adjust for B4 higher than C4
          const adjOctave = (letter[0] === 'b' && en[0] === 'c') ?
            octave + 1 : octave;
          map[en + adjOctave.toString()] = freq;
        });
        lix += 1;
      });
    });

    return map;
  }

  static get pitchFrequencyMap() {
    suiAudioPitch._pmMap = typeof(suiAudioPitch._pmMap) === 'undefined' ? suiAudioPitch._frequencies : suiAudioPitch._pmMap;
    return suiAudioPitch._pmMap;
  }

  static _rawPitchToFrequency(smoPitch, offset) {
    const npitch = smoMusic.smoIntToPitch(smoMusic.smoPitchToInt(smoPitch) + offset);
    const vx = npitch.letter.toLowerCase() + npitch.accidental + npitch.octave.toString();
    return suiAudioPitch.pitchFrequencyMap[vx];
  }

  static smoPitchToFrequency(smoNote, smoPitch, ix, offset) {
    let pitchInt = 0;
    let rv = suiAudioPitch._rawPitchToFrequency(smoPitch, offset);
    const mt = smoNote.tones.filter((tt) => tt.pitch === ix);
    if (mt.length) {
      const tone = mt[0];
      const coeff = tone.toPitchCoeff;
      pitchInt = smoMusic.smoPitchToInt(smoPitch);
      pitchInt += (coeff > 0) ? 1 : -1;
      const otherSmo = smoMusic.smoIntToPitch(pitchInt);
      const otherPitch = suiAudioPitch._rawPitchToFrequency(otherSmo, offset);
      rv += Math.abs(rv - otherPitch) * coeff;
    }
    return rv;
  }
}

// eslint-disable-next-line no-unused-vars
class suiReverb {
  static get defaults() {
    return { length: 0.5, decay: 2.0 };
  }

  connect(destination) {
    this.output.connect(destination);
  }

  disconnect() {
    this.output.disconnect();
  }

  // credit: https://github.com/nick-thompson
  _buildImpulse() {
    let n = 0;
    let i = 0;
    if (suiReverb.impulse) {
      this.input.buffer = suiReverb.impulse;
      return;
    }

    const rate = this._context.sampleRate;
    const length = rate * this.length;
    const decay = this.decay;
    const impulse = this._context.createBuffer(2, length, rate);
    const impulseL = impulse.getChannelData(0);
    const impulseR = impulse.getChannelData(1);

    for (i = 0; i < length; i++) {
      n = this.reverse ? length - i : i;
      impulseL[i] = (Math.random() * 2 - 1) * Math.pow(1 - n / length, decay);
      impulseR[i] = (Math.random() * 2 - 1) * Math.pow(1 - n / length, decay);
    }
    suiReverb.impulse = impulse;

    this.input.buffer = impulse;
  }

  constructor(context) {
    this.input = this.output = context.createConvolver();
    this.length = suiReverb.defaults.length;
    this.decay = suiReverb.defaults.decay;
    this._context = context;
    this._buildImpulse();
  }
}

// ## suiOscillator
// Simple waveform synthesizer thing that plays notes
// eslint-disable-next-line no-unused-vars
class suiOscillator {
  static get defaults() {
    const obj = {
      duration: 1000,
      frequency: 440,
      attackEnv: 0.05,
      decayEnv: 0.4,
      sustainEnv: 0.45,
      releaseEnv: 0.1,
      sustainLevel: 0.4,
      releaseLevel: 0.1,
      waveform: 'custom',
      gain: 0.1
    };

    const wavetable = {
      real: [0,
        0.3, 0.3, 0, 0, 0,
        0.1, 0, 0, 0, 0,
        0.05, 0, 0, 0, 0,
        0.01, 0, 0, 0, 0,
        0.01, 0, 0, 0, 0,
        0, 0, 0, 0, 0,
        0, 0],
      imaginary: [0,
        0, 0.05, 0, 0, 0,
        0, 0.01, 0, 0, 0,
        0, 0, 0, 0, 0,
        0, 0, 0, 0, 0,
        0, 0, 0, 0, 0,
        0, 0, 0, 0, 0,
        0, 0]
    };
    obj.wavetable = wavetable;
    return obj;
  }

  static playSelectionNow(selection, gain) {
    // In the midst of re-rendering...
    if (!selection.note) {
      return;
    }
    if (selection.note.isRest()) {
      return;
    }
    setTimeout(() => {
      const ar = suiOscillator.fromNote(selection.measure, selection.note, true, gain);
      ar.forEach((osc) => {
        osc.play();
      });
    }, 1);
  }

  // ### fromNote
  // Create an areray of oscillators for each pitch in a note
  static fromNote(measure, note, isSample, gain) {
    let frequency = 0;
    let duration = 0;
    let i = 0;
    const tempo = measure.getTempo();

    const bpm = tempo.bpm;
    const beats = note.tickCount / 4096;
    duration = (beats / bpm) * 60000;

    // adjust if bpm is over something other than 1/4 note
    duration = duration * (4096 / tempo.beatDuration);
    if (isSample) {
      duration = 250;
    }

    const ar = [];
    gain = isNaN(gain) ?  0.2 : gain;
    gain = gain / note.pitches.length;
    if (note.noteType === 'r') {
      gain = 0.001;
    }
    i = 0;
    note.pitches.forEach((pitch) => {
      frequency = suiAudioPitch.smoPitchToFrequency(note, pitch, i, -1 * measure.transposeIndex);
      const osc = new suiOscillator({ frequency, duration, gain });
      // var osc = new suiSampler({frequency:frequency,duration:duration,gain:gain});
      ar.push(osc);
      i += 1;
    });

    return ar;
  }

  static get attributes() {
    return ['duration', 'frequency', 'pitch', 'attackEnv', 'sustainEnv', 'decayEnv',
      'releaseEnv', 'sustainLevel', 'releaseLevel', 'waveform', 'wavetable', 'gain'];
  }

  static samplePromise() {
    const rv = new Promise((resolve) => {
      const checkSample = () => {
        setTimeout(() => {
          if (!suiOscillator._sample) {
            checkSample();
          } else {
            resolve();
          }
        });
      };
      checkSample();
    }, 100);
    if (typeof(suiOscillator._sample) === 'undefined') {
      const audio = suiOscillator.audio;
      const media = audio.createMediaElementSource(document.getElementById('sample'));
      const req = new XMLHttpRequest();
      req.open('GET', media.mediaElement.src, true);
      req.responseType = 'arraybuffer';
      req.send();
      req.onload = () => {
        const audioData = req.response;
        audio.decodeAudioData(audioData, (decoded) => {
          suiOscillator._sample = decoded;
        });
      };
    }
    return rv;
  }

  static get audio() {
    if (typeof (suiOscillator._audio) === 'undefined') {
      suiOscillator._audio = new AudioContext();
    }
    return suiOscillator._audio;
  }

  _playPromise(osc, duration, gain) {
    const audio = suiOscillator.audio;
    const promise = new Promise((resolve) => {
      osc.start(0);

      setTimeout(() => {
        resolve();
      }, duration);

      setTimeout(() => {
        osc.stop(0);
        osc.disconnect(gain);
        gain.disconnect(audio.destination);
      }, duration + 500);
    });
    return promise;
  }

  static toFloatArray(ar) {
    const rv = new Float32Array(ar.length);
    let i = 0;
    for (i = 0; i < ar.length; ++i) {
      rv[i] = ar[i];
    }

    return rv;
  }

  _play() {
    const audio = suiOscillator.audio;
    const gain = audio.createGain();
    const osc = audio.createOscillator();

    gain.connect(this.reverb.input);

    this.reverb.connect(audio.destination);
    gain.gain.setValueAtTime(0.01, audio.currentTime);
    const attack = this.attack / 1000;
    const decay = this.decay / 1000;
    const sustain = this.sustain / 1000;
    const release = this.release / 1000;
    gain.gain.exponentialRampToValueAtTime(this.gain, audio.currentTime + attack);
    gain.gain.exponentialRampToValueAtTime(this.sustainLevel * this.gain, audio.currentTime + attack + decay);
    gain.gain.exponentialRampToValueAtTime(this.releaseLevel * this.gain, audio.currentTime + attack + decay + sustain);
    gain.gain.exponentialRampToValueAtTime(0.001, audio.currentTime + attack + decay + sustain + release);
    if (this.waveform !== 'custom') {
      osc.type = this.waveform;
    } else {
      const wave = audio.createPeriodicWave(suiOscillator.toFloatArray(this.wavetable.real),
        suiOscillator.toFloatArray(this.wavetable.imaginary),
        { disableNormalization: false });
      osc.setPeriodicWave(wave);
    }
    osc.frequency.value = this.frequency;
    osc.connect(gain);
    gain.connect(audio.destination);
    return this._playPromise(osc, this.duration, gain);
  }

  play() {
    const self = this;
    self._play();
  }

  constructor(parameters) {
    smoSerialize.serializedMerge(suiOscillator.attributes, suiOscillator.defaults, this);
    smoSerialize.serializedMerge(suiOscillator.attributes, parameters, this);
    this.reverb = new suiReverb(suiOscillator.audio);
    this.attack = this.attackEnv * this.duration;
    this.decay = this.decayEnv * this.duration;
    this.sustain = this.sustainEnv * this.duration;
    this.release = this.releaseEnv * this.duration;
    this.frequency = this.frequency / 2;  // Overtones below partial

    if (parameters.waveform && parameters.waveform !== 'custom') {
      this.waveform = parameters.waveform;
    } else {
      this.waveform = 'custom';
    }
  }
}

// ## suiSampler
// Class that replaces oscillator with a sampler.  This is
// prototype code.  I'll get back to it.
// eslint-disable-next-line no-unused-vars
class suiSampler extends suiOscillator {
  play() {
    const self = this;
    suiOscillator.samplePromise().then(() => {
      self._play();
    });
  }
  _play() {
    const audio = suiOscillator.audio;
    const osc = audio.createBufferSource();

    osc.buffer = suiOscillator._sample;
    const cents = 1200 * (Math.log(this.frequency / suiAudioPitch.pitchFrequencyMap.cn3))
      / Math.log(2);

    osc.detune.value = cents;
    osc.connect(audio.destination);
    return this._playPromise(osc, this.duration);
  }

  _playPromise(osc, duration) {
    const promise = new Promise((resolve) => {
      osc.start(0, duration / 1000);
      setTimeout(() => {
        resolve();
      }, duration);
      setTimeout(() => {
        osc.stop(0);
      }, duration + 500);
    });
    return promise;
  }
}
;

// ## suiAudioPlayer
// Play the music, ja!
class suiAudioPlayer {

    static set playing(val) {
        suiAudioPlayer._playing = val;
    }

    static get maxGain() {
        return 0.2;
    }

    static get instanceId() {
        if (typeof(suiAudioPlayer._instanceId) == 'undefined') {
            suiAudioPlayer._instanceId = 0;
        }
        return suiAudioPlayer._instanceId;
    }
    static incrementInstanceId() {
        var id = suiAudioPlayer.instanceId + 1;
        suiAudioPlayer._instanceId = id;
        return id;
    }
    static get playing() {
        if (typeof(suiAudioPlayer._playing) == 'undefined') {
            suiAudioPlayer._playing = false;
        }
        return suiAudioPlayer._playing;
    }

    static pausePlayer() {
        if (suiAudioPlayer._playingInstance) {
            var a = suiAudioPlayer._playingInstance;
            a.paused = true;
        }
        suiAudioPlayer.playing = false;
    }
    static stopPlayer() {
        if (suiAudioPlayer._playingInstance) {
            var a = suiAudioPlayer._playingInstance;
            a.paused = false;
        }
        suiAudioPlayer.playing = false;
    }

    static get playingInstance() {
        if (!suiAudioPlayer._playingInstance) {
            return null;
        }
        return suiAudioPlayer._playingInstance;
    }

    // the oscAr contains an oscillator for each pitch in the chord.
    // each inner oscillator is a promise, the combined promise is resolved when all
    // the beats have completed.
    static _playChord(oscAr) {
        var par = [];
        oscAr.forEach((osc) => {
            par.push(osc.play());
        });

        return Promise.all(par);
    }

    _createOscillatorsFromMusicData(ar) {
        var rv = [];
        ar.forEach((soundData) => {
            var osc = new suiOscillator({frequency:soundData.frequency,duration:soundData.duration,gain:soundData.gain});
            // var osc = new suiSampler({frequency:soundData.frequency,duration:soundData.duration,gain:soundData.gain});
            rv.push(osc);
        });
        return rv;
    }
    _playArrayRecurse(ix,keys,notesToPlay) {
      if (!suiAudioPlayer.playing ||
        suiAudioPlayer.instanceId != this.instanceId) {
        this.tracker.clearMusicCursor();
        return;
      }
      var self = this;
      var key = keys[ix];
      var curTime = parseInt(key);
      var proto = notesToPlay[key];
      var oscs = this._createOscillatorsFromMusicData(proto);

      // Follow the top-staff note in this tick for the cursor
      // if (proto[0].selector.staff == 0) {
        this.tracker.musicCursor(proto[0].selector);
      // }
      if (ix < keys.length - 1) {
          var diff = parseInt(keys[ix+1]);
          var delay = (diff - curTime);
          setTimeout(function() {
              self._playArrayRecurse(ix+1,keys,notesToPlay);
          },delay);
      } else {
          self.tracker.clearMusicCursor();
      }
      suiAudioPlayer._playChord(oscs);
    }
    _playPlayArray() {
        var startTimes = Object.keys(this.sounds).sort((a,b) => {return parseInt(a) > parseInt(b);});
        if (startTimes.length < 1) {
          return;
        }
        this._playArrayRecurse(0,startTimes,this.sounds);
    }
    _populatePlayArray() {
        var maxGain = suiAudioPlayer.maxGain/this.score.staves.length;
        this.sounds = {};
        this.score.staves.forEach((staff)  => {
            var accumulator = 0;
            var slurs = [];
            for (var i = this.startIndex;i<staff.measures.length;++i) {
                var measure=staff.measures[i];
                var oldAccumulator = accumulator;
                var voiceIx = 0;
                measure.voices.forEach((voice) => {
                    var prevObj = null;
                    if (voiceIx != 0) {
                        accumulator = oldAccumulator;
                    }
                    var tick = 0;
                    voice.notes.forEach((note) => {
                        var tempo = measure.getTempo();
                        tempo = tempo ? tempo : new SmoTempoText();
                        var bpm = tempo.bpm;
                        var beats = note.tickCount/4096;
                        var duration = (beats / bpm) * 60000;

                        // adjust if bpm is over something other than 1/4 note
                        duration = duration * (4096/tempo.beatDuration);
                        var selector = {staff:measure.measureNumber.staffId,measure:measure.measureNumber.measureIndex,voice:voiceIx,tick:tick}

                        var gain = maxGain/note.pitches.length;
                        if (note.noteType == 'n') {
                            var pitchIx = 0;
                            note.pitches.forEach((pitch) => {
                                var frequency = suiAudioPitch.smoPitchToFrequency(note,pitch,pitchIx,-1 * measure.transposeIndex);
                                var obj = {
                                    duration:duration,
                                    frequency: frequency,
                                    gain:gain,
                                    selector:selector,
                                    note:note,
                                    measure:measure,
                                    staff:staff
                                };
                                // Keep track of slurs, don't restart the note it is
                                // really a tie.  TODO:  deal with 1:1, 1:many etc.
                                staff.getSlursStartingAt(selector).forEach((slur) => {
                                    slurs.push({
                                        obj:obj,
                                        slur:slur
                                    });
                                });

                                var pitchTie = slurs.filter((slur) => {
                                    return (SmoSelector.sameNote(slur.slur.endSelector,selector) && slur.obj.frequency == frequency);
                                });
                                if (pitchTie.length) {
                                    pitchTie[0].obj.duration += obj.duration;
                                } else {
                                    if (this.sounds[accumulator]) {
                                        this.sounds[accumulator].push(obj);
                                    } else {
                                        this.sounds[accumulator]=[obj];
                                    }
                                }
                                pitchIx += 1;
                            });
                        }
                        accumulator += Math.round(duration);
                        tick += 1;
                    });
                    voiceIx += 1;
                });
            }
        });
    }

    play() {
        if (suiAudioPlayer.playing) {
            return;
        }
        suiAudioPlayer._playingInstance = this;
        this._populatePlayArray();
        suiAudioPlayer.playing = true;
        this._playPlayArray();
    }

    constructor(parameters) {
        this.instanceId = suiAudioPlayer.incrementInstanceId();
        suiAudioPlayer.playing=false;
        this.paused = false;
        this.startIndex = parameters.startIndex;
        this.playIndex = 0;
        this.tracker = parameters.tracker;
        this.score = parameters.score;
        this._populatePlayArray();
    }
}
;// ## SuiActionPlayback
// play back the action records.
// eslint-disable-next-line no-unused-vars
class SuiActionPlayback {
  // In the application, the object plays the actions back.
  constructor(actionRecord, view) {
    this.view = view;
    this.actions = actionRecord;
    this.running = false;
    this.currentAction = null;
  }
  // ### actionPromise
  // Render a single action, and return a promise that resolves when rendered
  static actionPromise(view, method, args) {
    view[method](...args);
    return view.renderer.updatePromise();
  }
  // ### actionPromises
  // Library convenience function that performs the same action `'`count`'` times
  // Good for navigation (left 3 etc)
  static actionPromises(view, method, args, count) {
    const promise = new Promise((resolve) => {
      const fc = (count) => {
        if (count > 0) {
          SuiActionPlayback.actionPromise(view, method, args).then(() => {
            fc(count - 1);
          });
        } else {
          resolve();
        }
      };
      fc(count);
    });
    return promise;
  }
  // promise resolve condition
  get stopped() {
    return !this.running;
  }
  // ### setPitches
  // Convenience function to set a bunch of pitches on consecutive notes
  static setPitches(view, pitches) {
    const pitchAr = pitches.split('');
    const promise = new Promise((resolve) => {
      const fcn =  (ix) => {
        if (ix < pitchAr.length) {
          SuiActionPlayback.actionPromises(view, 'setPitch', [pitchAr[ix]], 1).then(() => {
            fcn(ix + 1);
          });
        } else {
          resolve();
        }
      };
      fcn(0);
    });
    return promise;
  }
  // ### playNextAction
  // Get the next action, and execute it.  Periodically refresh the entire score
  // if there are a  lot of actions.
  playNextAction() {
    let promise = {};
    if (this.currentAction === null || this.currentAction.count < 1) {
      this.currentAction = this.actions.callNextAction();
    }
    // No actions left, stop running
    if (!this.currentAction) {
      this.running = false;
    } else {
      this.currentAction.count -= 1;
      const ts = new Date().valueOf();
      const refresh = ts - this.timestamp > SmoConfig.idleRedrawTime;
      promise = SuiActionPlayback.actionPromise(this.view, this.currentAction.method, this.currentAction.args);
      if (refresh) {
        // Periodically refresh the whole screen and scroll
        promise = this.view.renderer.renderPromise();
        this.view.renderer.rerenderAll();
        this.timestamp = ts;
        promise.then(() => {
          const ls = this.view.score.staves[this.view.score.staves.length - 1];
          const lm = ls.measures[ls.measures.length - 1];
          if (lm.renderedBox) {
            this.view.tracker.scroller.scrollVisibleBox(lm.renderedBox);
          }
          this.playNextAction();
        });
      } else {
        // Usually, just perform the action and play the next action when any
        // redrawing has completed.
        promise.then(() => {
          this.playNextAction();
        });
      }
    }
  }
  // ### start
  // Start playing all the actions in the buffer.  Stop when stopped or we run out
  // of things to do.
  start() {
    this.running = true;
    this.timestamp = new Date().valueOf();
    this.actions.executeIndex = 0;
    this.playNextAction();
    return PromiseHelpers.makePromise(this, 'stopped', null, null, 50);
  }
}
;
// ## suiAdjuster
// Perform adjustments on the score based on the rendered components so we can re-render it more legibly.
class suiLayoutAdjuster {

  static estimateMusicWidth(smoMeasure, noteSpacing, accidentMap) {
    var widths = [];
    var voiceIx = 0;
    // Accidental map:
    // If we accidentals on different notes in a justified column, need to increase width
    // for both.
    //     |          |
    //    #o  x   x   o
    //     |  x   x   |
    //     o  x   x  #o
    var tmObj = smoMeasure.createMeasureTickmaps();
    smoMeasure.voices.forEach((voice) => {
      let accidentJustify = 0;
      Object.keys(accidentMap).forEach((k) => {
        accidentJustify += accidentMap[k];
      });
      var tickIndex = 0;
      var width = 0;
      var duration = 0;
      var tm = tmObj.tickmaps[voiceIx];
      voice.notes.forEach((note) => {
        var noteWidth = 0;
        var dots = (note.dots ? note.dots : 0);
        noteWidth += vexGlyph.dimensions.noteHead.width + vexGlyph.dimensions.noteHead.spacingRight * noteSpacing;
        // TODO: Consider engraving font and adjust grace note size?
        noteWidth += (vexGlyph.dimensions.noteHead.width + vexGlyph.dimensions.noteHead.spacingRight) * note.graceNotes.length;
        noteWidth += vexGlyph.dimensions.dot.width * dots + vexGlyph.dimensions.dot.spacingRight * dots;
        note.pitches.forEach((pitch) => {
          var keyAccidental = smoMusic.getAccidentalForKeySignature(pitch,smoMeasure.keySignature);
          var accidentals = tmObj.accidentalArray.filter((ar) =>
            ar.duration < duration && ar.pitches[pitch.letter]);
          var acLen = accidentals.length;
          var declared = acLen > 0 ?
            accidentals[acLen - 1].pitches[pitch.letter].pitch.accidental: keyAccidental;
          if (declared != pitch.accidental || pitch.cautionary) {
            noteWidth += vexGlyph.accidental(pitch.accidental).width;
            if (!accidentMap[duration]) {
              accidentMap[duration] = vexGlyph.accidental(pitch.accidental).width;
            } else {
              // if accidentals are aligned, don't count width twice
              accidentJustify -= vexGlyph.accidental(pitch.accidental).width;
            }
          }
        });

        var verse = 0;
        var lyric;
        while (lyric = note.getLyricForVerse(verse,SmoLyric.parsers.lyric)) {
          let lyricWidth = 0;
          let i = 0;
          // TODO: kerning and all that...
          if (!lyric.length) {
            break;
          }
          // why did I make this return an array?
          // oh...because of voices
          const textFont =
            VF.TextFont.getTextFontFromVexFontData({ family: lyric[0].fontInfo.family,
              size: lyric[0].fontInfo.size, weight: 'normal' });
          const lyricText = lyric[0].getText();
          for (i = 0;i < lyricText.length; ++i) {
            lyricWidth += textFont.getWidthForCharacter(lyricText[i]);
          }
          if (lyric[0].isHyphenated()) {
            lyricWidth +=  2 * textFont.getWidthForCharacter('-');
          } else {
            lyricWidth +=  2 * textFont.getWidthForCharacter('H');
          }
          noteWidth = Math.max(lyricWidth, noteWidth);
          verse += 1;
        }
        tickIndex += 1;
        duration += note.tickCount;
        width += noteWidth;
      });
      if (accidentJustify > 0) {
        width += accidentJustify;
      }
      voiceIx += 1;
      widths.push(width);
    });
    widths.sort((a,b) => a > b ? -1 : 1);
    return widths[0];
  }

  static estimateStartSymbolWidth(smoMeasure) {
    var width = 0;
    if (smoMeasure.forceKeySignature) {
      if ( smoMeasure.canceledKeySignature) {
          width += vexGlyph.keySignatureLength(smoMeasure.canceledKeySignature);
      }
            width += vexGlyph.keySignatureLength(smoMeasure.keySignature);
    }
    if (smoMeasure.forceClef) {
      width += vexGlyph.clef(smoMeasure.clef).width + vexGlyph.clef(smoMeasure.clef).spacingRight;
    }
    if (smoMeasure.forceTimeSignature) {
            var digits = smoMeasure.timeSignature.split('/')[0].length;
      width += vexGlyph.dimensions.timeSignature.width*digits + vexGlyph.dimensions.timeSignature.spacingRight;
    }
    var starts = smoMeasure.getStartBarline();
    if (starts) {
      width += vexGlyph.barWidth(starts);
    }
    return width;
  }

  static estimateEndSymbolWidth(smoMeasure) {
    var width = 0;
    var ends  = smoMeasure.getEndBarline();
    if (ends) {
      width += vexGlyph.barWidth(ends);
    }
    return width;
  }


  static estimateTextOffset(renderer,smoMeasure) {
    var leftText = smoMeasure.modifiers.filter((mm) => mm.ctor ==='SmoMeasureText' && mm.position === SmoMeasureText.positions.left);
    var rightText = smoMeasure.modifiers.filter((mm) => mm.ctor ==='SmoMeasureText' && mm.position === SmoMeasureText.positions.right);
    var svg = renderer.getContext().svg;
    var xoff = 0;
    var width = 0;
    leftText.forEach((tt) => {
      const testText = new SmoScoreText({text:tt.text});
      const box = svgHelpers.getTextBox(svg,testText.toSvgAttributes(), testText.classes, testText.text);
      xoff += box.width;
    });
    rightText.forEach((tt) => {
      const testText = new SmoScoreText({text:tt.text});
      const box = svgHelpers.getTextBox(svg,testText.toSvgAttributes(), testText.classes, testText.text);
      width += box.width;
    });
    return svgHelpers.boxPoints(xoff, 0, width, 0);
  }

  static estimateMeasureWidth(measure, noteSpacing, accidentMap) {
    // Calculate the existing staff width, based on the notes and what we expect to be rendered.
    var prevWidth = measure.staffWidth;
    var measureWidth = suiLayoutAdjuster.estimateMusicWidth(measure, noteSpacing, accidentMap);
    measure.adjX = suiLayoutAdjuster.estimateStartSymbolWidth(measure);
    measure.adjRight = suiLayoutAdjuster.estimateEndSymbolWidth(measure);
    measureWidth += measure.adjX + measure.adjRight + measure.customStretch;
    var y = measure.logicalBox ? measure.logicalBox.y : measure.staffY;
    measure.setWidth(measureWidth, 'estimateMeasureWidth adjX adjRight ');
    // Calculate the space for left/right text which displaces the measure.
    // var textOffsetBox=suiLayoutAdjuster.estimateTextOffset(renderer,measure);
    // measure.setX(measure.staffX  + textOffsetBox.x,'estimateMeasureWidth');
    measure.setBox(svgHelpers.boxPoints(measure.staffX, y, measure.staffWidth, measure.logicalBox.height),
      'estimate measure width');
  }
  static _beamGroupForNote(measure,note) {
    var rv = null;
    if (!note.beam_group) {
      return null;
    }
    measure.beamGroups.forEach((bg) => {
      if (!rv) {
        if (bg.notes.findIndex((nn) => note.beam_group && note.beam_group.id === bg.attrs.id) >= 0) {
          rv = bg;
        }
      }
    });
    return rv;
  }

  // ### _highestLowestHead
  // highest value is actually the one lowest on the page
  static _highestLowestHead(measure,note) {
    const hilo = { hi: 0, lo: 9999999 };
    note.pitches.forEach((pitch) => {
      // 10 pixels per line
      const ledger = smoMusic.pitchToLedgerLine(measure.clef, pitch);
      const noteHeight = ledger > 0 ? 10 : -10;
      const px = (10 * ledger) + noteHeight;
      hilo.lo = Math.min(hilo.lo, px);
      hilo.hi = Math.max(hilo.hi, px);
    });
    return hilo;
  }
  static textFont(lyric) {
    const fonts = VF.TextFont.fontRegistry;
    const rv = fonts.find((font) => font.family === lyric.fontInfo.family);
    if (!rv) {
      return new VF.TextFont(fonts[0]);
    }
    return new VF.TextFont(rv);
  }

  // ### estimateMeasureHeight
  // The baseline is the top line of the staff.  aboveBaseline is a negative number
  // that indicates how high above the baseline the measure goes.  belowBaseline
  // is a positive number that indicates how far below the baseline the measure goes.
  // the height of the measure is below-above.  Vex always renders a staff such that
  // the y coordinate passed in for the stave is on the baseline.
  // Note to past self: this was a really useful comment.  Thank you.
  static estimateMeasureHeight(measure, layout) {
    let heightOffset = 50;  // assume 5 lines, todo is non-5-line staffs
    let yOffset = 0;
    let flag = '';
    let lyricOffset = 0;
    if (measure.forceClef) {
      heightOffset += vexGlyph.clef(measure.clef).yTop + vexGlyph.clef(measure.clef).yBottom;
      yOffset = yOffset - vexGlyph.clef(measure.clef).yTop;
    }

    if (measure.forceTempo) {
      yOffset = Math.min(-1 * vexGlyph.tempo.yTop, yOffset);
    }
    var hasDynamic = false;

    measure.voices.forEach((voice) => {
      voice.notes.forEach((note) => {
        const bg = suiLayoutAdjuster._beamGroupForNote(measure, note);
        flag = SmoNote.flagStates.auto;
        if (bg && note.noteType === 'n') {
          flag = bg.notes[0].flagState;
          // an  auto-flag note is up if the 1st note is middle line
          if (flag === SmoNote.flagStates.auto) {
            var pitch = bg.notes[0].pitches[0];
            flag = smoMusic.pitchToLedgerLine(measure.clef,pitch)
               >= 2 ? SmoNote.flagStates.up : SmoNote.flagStates.down;
          }
        }  else {
          flag = note.flagState;
          // an  auto-flag note is up if the 1st note is middle line
          if (flag === SmoNote.flagStates.auto) {
            const pitch = note.pitches[0];
            flag = smoMusic.pitchToLedgerLine(measure.clef, pitch)
              >= 2 ? SmoNote.flagStates.up : SmoNote.flagStates.down;
          }
        }
        const hiloHead = suiLayoutAdjuster._highestLowestHead(measure, note);
        if (flag == SmoNote.flagStates.down) {
          yOffset = Math.min(hiloHead.lo,yOffset);
          heightOffset = Math.max(hiloHead.hi + vexGlyph.stem.height,heightOffset);
        } else {
          yOffset = Math.min(hiloHead.lo - vexGlyph.stem.height,yOffset);
          heightOffset = Math.max(hiloHead.hi,heightOffset);
        }
        // Lyrics will be rendered below the lowest thing on the staff, so add to
        // belowBaseline value based on the max number of verses and font size
        // it will extend
        const lyrics = note.getTrueLyrics();
        if (lyrics.length) {
          const maxLyric = lyrics.reduce((a, b)=> a.verse > b.verse ? a : b);
          const fontInfo = suiLayoutAdjuster.textFont(maxLyric);
          const maxHeight = fontInfo.maxHeight;
          lyricOffset = Math.max((maxLyric.verse + 2) * fontInfo.maxHeight, lyricOffset);
        }
        const dynamics = note.getModifiers('SmoDynamicText');
        dynamics.forEach((dyn) => {
          heightOffset = Math.max((10 * dyn.yOffsetLine - 50) + 11, heightOffset);
          yOffset = Math.min(10 * dyn.yOffsetLine - 50, yOffset)
        });
      });
    });
    heightOffset += lyricOffset;
    return { belowBaseline: heightOffset, aboveBaseline: yOffset };
  }
}
;
class layoutDebug {
  static get values() {
    return {
      pre: 1,
      post: 2,
      adjust: 4,
      system: 8,
      note: 16,
      adjustHeight: 32,
      measureHistory: 64,
      textEditorHistory: 128,
      dialogEvents: 256
    };
  }

    static get classes() {
      return {
        pre: 'measure-place-dbg',
        post: 'measure-render-dbg',
        adjust: 'measure-adjust-dbg',
        system: 'system-place-dbg',
        note: 'measure-note-dbg',
        adjustHeight: 'measure-adjustHeight-dbg',
        measureHistory: '',
        textEditorHistory: '',
        dialogEvents: ''
      };
    }
    static get codeRegions() {
      return {
        COMPUTE: 0,
        PREFORMATA: 1,
        PREFORMATB: 2,
        PREFORMATC: 3,
        FORMAT: 4,
        RENDER: 5,
        POST_RENDER: 6,
        MAP: 7,
        LAST: 7
      };
    }
    static get codeRegionStrings() {
      return ['COMPUTE', 'PREFORMATA', 'PREFORMATB', 'PREFORMATC', 'FORMAT', 'RENDER', 'POST_RENDER', 'MAP'];
    }

	static get mask() {
    if (typeof(layoutDebug._flags) === 'undefined') {
      layoutDebug._flags = 0;
    }
    return layoutDebug._flags;
	}
  static get timestampHash() {
    if (typeof(layoutDebug.timestampInstance) === 'undefined') {
      layoutDebug.timestampInstance = {};
      layoutDebug.clearTimestamps();
    }
    return layoutDebug.timestampInstance;
  }
  static clearTimestamps() {
    for (var i = 0; i <= layoutDebug.codeRegions.LAST; ++i) {
      layoutDebug.timestampHash[i] = 0;
    }
  }

  static setTimestamp(region, millis) {
    layoutDebug.timestampHash[region] += millis;
  }
  static printTimeReport() {
    let total = 0;
    let report = {};
    let i = 0;
    for (i = 0;i <= layoutDebug.codeRegions.LAST; ++i) {
      total += layoutDebug.timestampHash[i];
      report[layoutDebug.codeRegionStrings[i]] = {
        time: layoutDebug.timestampHash[i], percent: 0
      };
    }
    report.total = total;
    for (i = 0; i <= layoutDebug.codeRegions.LAST; ++i) {
      report[layoutDebug.codeRegionStrings[i]].percent =
        Math.round((report[layoutDebug.codeRegionStrings[i]].time * 100) / report.total);
    }
    console.log(JSON.stringify(report, null, ' '));
  }

  static set mask(value) {
    layoutDebug._flags = value;
  }

  static flagSet(value) {
    return layoutDebug.mask & layoutDebug.values[value];
  }

  static clearAll(svg) {
    layoutDebug._flags = 0;
  }
  static setAll() {
    layoutDebug._flags = 1+2+4+8+16+32+64+128+256;
  }
  static setRenderFlags() {
    layoutDebug._flags = 1+2+4+8+16+32;
  }
  static clearDebugBoxes(value) {
    if (layoutDebug.flagSet(value)) {
      var selector = 'g.'+layoutDebug.classes[value];
      $(selector).remove();
    }
  }
  static debugBox(svg,box,flag) {
    if (!box) {
      return;
    }
    if (!box.height) {
      box.height=1;
    }
    if (layoutDebug.flagSet(flag)) {
      svgHelpers.debugBox(svg, box, layoutDebug.classes[flag]);
    }
  }
  static clearFlag(value) {
    clearFlagSvg(value);
    var flag = layoutDebug.values[value];
    if (typeof(layoutDebug._flags) == 'undefined') {
      layoutDebug._flags = 0;
    }
    layoutDebug._flags = layoutDebug._flags & (~flag);
  }

	static setFlag(value) {
    var flag = layoutDebug.values[value];
    if (typeof(layoutDebug._flags) == 'undefined') {
        layoutDebug._flags = flag;
        return;
    }
    layoutDebug._flags |= flag;
	}

  static get textDebug() {
    if (!layoutDebug['_textDebug']) {
      layoutDebug['_textDebug'] = [];
    }
    return layoutDebug['_textDebug']
  }

  static addTextDebug(value) {
    if (!layoutDebug.mask & layoutDebug.textEditorHistory) {
      return;
    }
    if (!layoutDebug['_textDebug']) {
      layoutDebug['_textDebug'] = [];
    }
    layoutDebug['_textDebug'].push(value);
    console.log(value);
  }

  static addDialogDebug(value) {
    if (!layoutDebug.mask & layoutDebug.dialogEvents) {
      return;
    }
    if (!layoutDebug['_dialogEvents']) {
      layoutDebug['_dialogEvents'] = [];
    }
    layoutDebug['_dialogEvents'].push(value);
    console.log(value);
  }

  static measureHistory(measure,oldVal,newVal,description) {
    if (layoutDebug.flagSet('measureHistory')) {
      var oldExp = (typeof(measure.svg[oldVal]) == 'object') ? JSON.stringify(measure.svg[oldVal]).replace(/"/g,'') : measure.svg[oldVal];
      var newExp = (typeof(newVal) == 'object') ? JSON.stringify(newVal).replace(/"/g,'') : newVal;
      measure.svg.history.push(oldVal + ': '+oldExp +'=> '+newExp + ' ' + description);
    }
  }
}
;
class SuiRenderDemon {
  constructor(parameters) {
    this.idleLayoutTimer = 0; // how long the score has been idle
    this.undoStatus = 0;

    Vex.Merge(this, parameters);
    this.handling = false;
  }

  get isLayoutQuiet() {
    return ((this.view.renderer.passState == SuiRenderState.passStates.clean && this.view.renderer.dirty == false)
       || this.view.renderer.passState == SuiRenderState.passStates.replace);
  }
  resetIdleTimer() {
      this.idleLayoutTimer = Date.now();
  }

  handleRedrawTimer() {
    if (this.handling) {
      return;
    }
    this.handling = true;
    const redrawTime = Math.max(this.view.renderer.renderTime, SmoConfig.idleRedrawTime);
    // If there has been a change, redraw the score
    if (this.view.renderer.passState === SuiRenderState.passStates.initial) {
      this.view.renderer.dirty = true;
      this.undoStatus = this.undoBuffer.opCount;
      this.idleLayoutTimer = Date.now();

      // indicate the display is 'dirty' and we will be refreshing it.
      $('body').addClass('refresh-1');
      try {
        // Sort of a hack.  If the viewport changed, the scroll state is already reset
        // so we can't preserver the scroll state.
        if (!this.view.renderer.viewportChanged) {
          this.view.preserveScroll();
        }
        this.render();
      } catch (ex) {
        console.error(ex);
        SuiExceptionHandler.instance.exceptionHandler(ex);
        this.handling = false;
      }
    } else if (this.view.renderer.passState === SuiRenderState.passStates.replace && this.undoStatus === this.undoBuffer.opCount) {
      // Consider navigation as activity when deciding to refresh
      this.idleLayoutTimer = Math.max(this.idleLayoutTimer, this.view.tracker.idleTimer);
      $('body').addClass('refresh-1');
      // Do we need to refresh the score?
      if (this.view.renderer.backgroundRender === false && Date.now() - this.idleLayoutTimer > redrawTime) {
        this.view.renderer.passState = SuiRenderState.passStates.initial;
        if (!this.view.renderer.viewportChanged) {
          this.view.preserveScroll();
        }
        this.render();
      }
    } else {
      this.idleLayoutTimer = Date.now();
      this.undoStatus = this.undoBuffer.opCount;
      if (this.view.renderer.replaceQ.length > 0) {
        this.render();
      }
    }
    this.handling = false;
}

    // ### pollRedraw
  // if anything has changed over some period, prepare to redraw everything.
  pollRedraw() {
    setTimeout(() => {
      this.handleRedrawTimer();
      this.pollRedraw();
    }, SmoConfig.demonPollTime);
  }

  startDemon() {
      this.pollRedraw();
  }

  render() {
    this.view.renderer.render();
    if (this.view.renderer.passState === SuiRenderState.passStates.clean && this.view.renderer.dirty === false) {
       this.view.tracker.updateMap();
       // indicate the display is 'clean' and up-to-date with the score
       $('body').removeClass('refresh-1');
    }
  }
}
;// ## suiMapper
// Map the notes in the svg so they can respond to events and interact
// with the mouse/keyboard
// eslint-disable-next-line no-unused-vars
class suiMapper {
  constructor(renderer, scroller, pasteBuffer) {
    // renderer renders the music when it changes
    this.renderer = renderer;
    // measure to selector map
    this.measureMap = {};
    this.measureNoteMap = {}; // Map for tracker
    this.scroller = scroller;
    // notes currently selected.  Something is always selected
    this.selections = [];
    // modifiers (text etc.) that have been selected
    this.modifierSelections = [];
    // all the modifiers
    this.modifierTabs = [];
    // the index of the currently selected modifier
    this.modifierIndex = -1;
    // The list of modifiers near the current selection
    this.localModifiers = [];
    // mouse-over that might be selected soon
    this.modifierSuggestion = -1;
    this.suggestion = {};
    // index if a single pitch of a chord is selected
    this.pitchIndex = -1;
    // the current selection, which is also the copy/paste destination
    this.pasteBuffer = pasteBuffer;
  }

  // ### loadScore
  // We are loading a new score.  clear the maps so we can rebuild them after
  // rendering
  loadScore() {
    this.measureMap = {};
    this.measureNoteMap = {};
    this.clearModifierSelections();
    this.selections = [];
  }

  // ### _clearMeasureArtifacts
  // clear the measure from the measure and note maps so we can rebuild it.
  clearMeasureMap(staff, measure) {
    const selector = { staff: measure.measureNumber.staffId, measure: measure.measureNumber.measureIndex };
    const measureKey = SmoSelector.getMeasureKey(selector);
    if (this.measureMap[measureKey]) {
      const nkeys = Object.keys(this.measureMap[measureKey].keys);
      nkeys.forEach((key) => {
        delete this.measureNoteMap[key];
      });

      delete this.measureMap[measureKey];
    }
    // Unselect selections in this measure so we can reselect them when re-tracked
    const ar = [];
    this.selections.forEach((selection) => {
      if (selection.selector.staff !== selector.staff || selection.selector.measure !== selector.measure) {
        ar.push(selection);
      }
    });
    this.selections = ar;
  }

  deleteMeasure(selection) {
    const selCopy = this._copySelectionsByMeasure(selection.selector.staff, selection.selector.measure)
      .selectors;
    this.clearMeasureMap(selection.staff, selection.measure);
    if (selCopy.length) {
      selCopy.forEach((selector) => {
        const nsel = JSON.parse(JSON.stringify(selector));
        if (selector.measure === 0) {
          nsel.measure += 1;
        } else {
          nsel.measure -= 1;
        }
        this.selections.push(this._getClosestTick(nsel));
      });
    }
  }
  updateMap() {
    this._updateMap();
  }
  _updateNoteModifier(selection, modMap, modifier, ix) {
    if (!modMap[modifier.attrs.id]) {
      this.modifierTabs.push({
        modifier,
        selection,
        box: svgHelpers.logicalToClient(this.renderer.svg, modifier.logicalBox, this.scroller),
        index: ix
      });
      ix += 1;
      modMap[modifier.attrs.id] = {
        exists: true
      };
    }
    return ix;
  }

  _updateModifiers() {
    let ix = 0;
    this.modifierTabs = [];
    this.modifierBoxes = [];
    const modMap = {};
    this.renderer.score.scoreText.forEach((modifier) => {
      if (!modMap[modifier.attrs.id]) {
        this.modifierTabs.push({
          modifier,
          selection: null,
          box: svgHelpers.logicalToClient(this.renderer.svg, modifier.logicalBox, this.scroller),
          index: ix
        });
        ix += 1;
      }
    });
    this.renderer.score.textGroups.forEach((modifier) => {
      if (!modMap[modifier.attrs.id] && modifier.logicalBox) {
        this.modifierTabs.push({
          modifier,
          selection: null,
          box: svgHelpers.logicalToClient(this.renderer.svg, modifier.logicalBox, this.scroller),
          index: ix
        });
        ix += 1;
      }
    });
    const keys = Object.keys(this.measureNoteMap);
    keys.forEach((selKey) => {
      const selection = this.measureNoteMap[selKey];
      selection.staff.modifiers.forEach((modifier) => {
        if (SmoSelector.contains(selection.selector, modifier.startSelector, modifier.endSelector)) {
          if (!modMap[modifier.attrs.id]) {
            if (modifier.logicalBox) {
              this.modifierTabs.push({
                modifier,
                selection,
                box: svgHelpers.logicalToClient(this.renderer.svg, modifier.logicalBox, this.scroller),
                index: ix
              });
              ix += 1;
              modMap[modifier.attrs.id] = { exists: true };
            }
          }
        }
      });
      selection.measure.modifiers.forEach((modifier) => {
        if (modifier.attrs.id
          && !modMap[modifier.attrs.id]
          && modifier.renderedBox) {
          this.modifierTabs.push({
            modifier,
            selection,
            box: svgHelpers.adjustScroll(modifier.renderedBox, this.scroller.netScroll),
            index: ix
          });
          ix += 1;
          modMap[modifier.attrs.id] = {
            exists: true
          };
        }
      });
      selection.note.textModifiers.forEach((modifier) => {
        if (modifier.logicalBox) {
          ix = this._updateNoteModifier(selection, modMap, modifier, ix);
        }
      });

      selection.note.graceNotes.forEach((modifier) => {
        ix = this._updateNoteModifier(selection, modMap, modifier, ix);
      });
    });
  }
  // ### _getClosestTick
  // given a musical selector, find the note artifact that is closest to it,
  // if an exact match is not available
  _getClosestTick(selector) {
    let tickKey = '';
    const measureKey = Object.keys(this.measureNoteMap).find((k) =>
      SmoSelector.sameMeasure(this.measureNoteMap[k].selector, selector)
        && this.measureNoteMap[k].selector.tick === 0);
    tickKey = Object.keys(this.measureNoteMap).find((k) =>
      SmoSelector.sameNote(this.measureNoteMap[k].selector, selector));
    const firstObj = this.measureNoteMap[Object.keys(this.measureNoteMap)[0]];

    if (tickKey) {
      return this.measureNoteMap[tickKey];
    }
    if (measureKey) {
      return this.measureNoteMap[measureKey];
    }
    return firstObj;
  }

  // ### _setModifierBoxes
  // Create the DOM modifiers for the lyrics and other modifiers
  _setModifierBoxes(measure) {
    measure.voices.forEach((voice) => {
      voice.notes.forEach((smoNote) =>  {
        const el = this.renderer.svg.getElementById(smoNote.renderId);
        if (el) {
          svgHelpers.updateArtifactBox(this.renderer.svg, el, smoNote, this.scroller);
          // TODO: fix this, only works on the first line.
          smoNote.getModifiers('SmoLyric').forEach((lyric) => {
            if (lyric.getText().length || lyric.isHyphenated()) {
              lyric.selector = '#' + smoNote.renderId + ' ' + lyric.getClassSelector();
              svgHelpers.updateArtifactBox(this.renderer.svg, $(lyric.selector)[0], lyric, this.scroller);
            }
          });
          smoNote.graceNotes.forEach((g) => {
            var gel = this.context.svg.getElementById('vf-' + g.renderedId);
            $(gel).addClass('grace-note');
            svgHelpers.updateArtifactBox(this.renderer.svg, gel, g, this.scroller);
          });
          smoNote.textModifiers.forEach((modifier) => {
            const modEl = $('.' + modifier.attrs.id);
            if (modifier.logicalBox && modEl.length) {
              svgHelpers.updateArtifactBox(this.renderer.svg, modEl[0], modifier, this.scroller);
            }
          });
        }
      });
    });
  }

  // ### updateMeasure
  // A measure has changed.  Update the music geometry for it
  mapMeasure(staff, measure, printing) {
    let voiceIx = 0;
    let selectedTicks = 0;
    let selectionChanged = false;
    let vix = 0;
    if (!measure.logicalBox) {
      return;
    }
    measure.renderedBox = svgHelpers.logicalToClient(this.renderer.svg, measure.logicalBox, this.scroller);
    this._setModifierBoxes(measure);
    const timestamp = new Date().valueOf();
    // Keep track of any current selections in this measure, we will try to restore them.
    const sels = this._copySelectionsByMeasure(staff.staffId, measure.measureNumber.measureIndex);
    this.clearMeasureMap(staff, measure);
    vix = measure.getActiveVoice();
    sels.selectors.forEach((sel) => {
      sel.voice = vix;
    });

    measure.voices.forEach((voice) => {
      let tick = 0;
      voice.notes.forEach((note) => {
        const selector = {
          staff: staff.staffId,
          measure: measure.measureNumber.measureIndex,
          voice: voiceIx,
          tick,
          pitches: []
        };
        // create a selection for the newly rendered note
        const selection = new SmoSelection({
          selector,
          _staff: staff,
          _measure: measure,
          _note: note,
          _pitches: [],
          box: svgHelpers.logicalToClient(this.renderer.svg, note.logicalBox, this.scroller),
          type: 'rendered'
        });
        // and add it to the map
        this._updateMeasureNoteMap(selection, printing);

        // If this note is the same location as something that was selected, reselect it
        if (sels.selectors.length && selection.selector.tick === sels.selectors[0].tick &&
          selection.selector.voice === vix) {
          this.selections.push(selection);
          // Reselect any pitches.
          if (sels.selectors[0].pitches.length > 0) {
            sels.selectors[0].pitches.forEach((pitchIx) => {
              if (selection.pitches.length > pitchIx) {
                selection.selector.pitches.push(pitchIx);
              }
            });
          }
          selectedTicks += selection.note.tickCount;
          selectionChanged = true;
        } else if (selectedTicks > 0 && selectedTicks < sels.ticks && selection.selector.voice === vix) {
          // try to select the same length of music as was previously selected.  So a 1/4 to 2 1/8, both
          // are selected
          this.selections.push(selection);
          selectedTicks += selection.note.tickCount;
        } else if (this.selections.length === 0 && sels.selectors.length === 0) {
          this.selections = [selection];
          selectionChanged = true;
        }
        tick += 1;
      });
      voiceIx += 1;
    });
    // If there were selections on this measure, highlight them.
    if (selectionChanged) {
      this.highlightSelection();
    }
    layoutDebug.setTimestamp(layoutDebug.codeRegions.MAP, new Date().valueOf() - timestamp);
  }

  // ### updateMap
  // This should be called after rendering the score.  It updates the score to
  // graphics map and selects the first object.
  _updateMap() {
    this.mapping = true;
    let tickSelected = 0;
    const selCopy = this._copySelections();
    const ticksSelectedCopy = this._getTicksFromSelections();
    const firstSelection = this.getExtremeSelection(-1);
    this._updateModifiers();
    this.selections = [];

    // Try to restore selection.  If there were none, just select the fist
    // thing in the score
    const keys = Object.keys(this.measureNoteMap);
    if (keys.length && !selCopy.length) {
    // If there is nothing rendered, don't update tracker
      this.selections = [this.measureNoteMap[keys[0]]];
    }  else {
      if (!firstSelection) {
        return;
      }
      this._findClosestSelection(firstSelection.selector);
      const first = this.selections[0];
      tickSelected = first.note.tickCount;
      while (tickSelected < ticksSelectedCopy && first) {
        const delta = this._growSelectionRight(true);
        if (!delta)  {
          break;
        }
        tickSelected += delta;
      }
    }
    this.highlightSelection();
    this._createLocalModifiersList();
    // Is this right?  Don't update the past buffer with data until the display is redrawn
    // because some of the selections may not exist in the score.
    if (this.renderer.isDirty === false) {
      this.pasteBuffer.clearSelections();
      this.pasteBuffer.setSelections(this.score, this.selections);
    }
    this.mapping = false;
  }

  // ### intersectingArtifact
  // given a bounding box, find any rendered elements that intersect with it
  intersectingArtifact(bb) {
    let sel = 0;
    bb = svgHelpers.boxPoints(bb.x, bb.y, bb.width ? bb.width : 1, bb.height ? bb.height : 1);
    const artifacts = svgHelpers.findIntersectingArtifactFromMap(bb, this.measureNoteMap, this.scroller.scrollState);
    // TODO: handle overlapping suggestions
    if (!artifacts.length) {
      sel = svgHelpers.findIntersectingArtifact(bb, this.modifierTabs, this.scroller.scrollState);
      if (sel.length) {
        sel = sel[0];
        this._setModifierAsSuggestion(bb, sel);
      }
      return;
    }
    const artifact = artifacts[0];
    this._setArtifactAsSuggestion(bb, artifact);
  }
  _updateMeasureNoteMap(artifact, printing) {
    const noteKey = SmoSelector.getNoteKey(artifact.selector);
    const measureKey = SmoSelector.getMeasureKey(artifact.selector);
    const activeVoice = artifact.measure.getActiveVoice();
    if (artifact.selector.voice !== activeVoice && !artifact.note.fillStyle && !printing) {
      const vvv = artifact.selector.voice;
      const r = 128 + ((vvv * 32767 | vvv * 157) % 127);
      const g = 128 / vvv;
      const b = 128 - ((vvv * 32767 | vvv * 157) % 127);
      const fill = 'rgb(' + r + ',' + g + ',' + b + ')';
      $('#' + artifact.note.renderId).find('.vf-notehead path').each((ix, el) => {
        el.setAttributeNS('', 'fill', fill);
      });
    }
    // not has not been drawn yet.
    if (!artifact.box) {
      return;
    }
    if (!this.measureNoteMap[noteKey]) {
      this.measureNoteMap[noteKey] = artifact;
      artifact.scrollBox = { x: artifact.box.x,
        y: artifact.measure.renderedBox.y };
    } else {
      const mm = this.measureNoteMap[noteKey];
      mm.scrollBox = { x: Math.min(
        artifact.box.x, mm.x), y: Math.min(artifact.measure.renderedBox.y, mm.y) };
    }

    if (!this.measureMap[measureKey]) {
      this.measureMap[measureKey] = { keys: {} };
      this.measureMap[measureKey].keys[noteKey] = true;
    } else {
      const measureHash = this.measureMap[measureKey].keys;
      if (!measureHash[noteKey]) {
        measureHash[noteKey] = true;
      }
    }
  }
}
;class suiPiano {
  constructor(parameters) {
    Vex.Merge(this, parameters);
    this.renderElement = document.getElementById('piano-svg');
    this.render();
    this.octaveOffset = 0;
    this.chordPedal = false;
    this.scroller = new suiScroller('.piano-keys');
  }

  static get dimensions() {
    return {
      wwidth: 23,
      bwidth: 13,
      wheight: 120,
      bheight: 80,
      octaves:1
    };
  }
    // 7 white keys per octave
  static get wkeysPerOctave() {
    return 7;
  }
  static get owidth() {
    return suiPiano.dimensions.wwidth * suiPiano.wkeysPerOctave;
  }

  static createAndDisplay(parms) {
    // Called by ribbon button.
    // $('body').toggleClass('show-piano');
        $('body').trigger('show-piano-event');
    $('body').trigger('forceScrollEvent');
    // handle resize work area.
  }
  _mapKeys() {
    this.objects = [];
    var keys = [].slice.call(this.renderElement.getElementsByClassName('piano-key'));
    keys.forEach((key) => {
      var rect = svgHelpers.smoBox(key.getBoundingClientRect());
      var id = key.getAttributeNS('', 'id');
      var artifact = {
        keyElement: key,
        box: rect,
        id: id
      };
      this.objects.push(artifact);
    });
  }
  _removeClass(classes) {
    Array.from(this.renderElement.getElementsByClassName('piano-key')).forEach((el) => {
      $(el).removeClass(classes);
    });
  }
  _removeGlow() {
    this._removeClass('glow-key');
  }
  _fadeGlow(el) {
    if (this['suggestFadeTimer']) {
      clearTimeout(this.suggestFadeTimer);
    }
    // Make selection fade if there is a selection.
    this.suggestFadeTimer = setTimeout(function () {
        $(el).removeClass('glow-key');
      }, 1000);
  }
  bind() {
    $('body').off('show-piano-event').on('show-piano-event', () => {
        $('body').toggleClass('show-piano');
        this._mapKeys();
    });
    $('#piano-8va-button').off('click').on('click', (ev) => {
      $('#piano-8vb-button').removeClass('activated');
      if (this.octaveOffset === 0) {
        $(ev.currentTarget).addClass('activated');
        this.octaveOffset = 1;
      } else {
        $(ev.currentTarget).removeClass('activated');
        this.octaveOffset = 0;
      }
    });
    $('#piano-8vb-button').off('click').on('click', (ev) => {
      $('#piano-8va-button').removeClass('activated');
      if (this.octaveOffset === 0) {
        $(ev.currentTarget).addClass('activated');
        this.octaveOffset = -1;
      } else {
        $(ev.currentTarget).removeClass('activated');
        this.octaveOffset = 0;
      }
    });
    $('#piano-xpose-up').off('click').on('click', () => {
      this.keyCommands.transposeUp();
    });
    $('#piano-xpose-down').off('click').on('click', () => {
      this.keyCommands.transposeDown();
    });
    $('#piano-enharmonic').off('click').on('click', () => {
      this.keyCommands.toggleEnharmonic();
    });
    $('button.jsLeft').off('click').on('click', () => {
      this.view.tracker.moveSelectionLeft();
    });
    $('button.jsRight').off('click').on('click', () => {
      this.view.tracker.moveSelectionRight();
    });
    $('button.jsGrowDuration').off('click').on('click', () => {
      this.keyCommands.doubleDuration();
    });
    $('button.jsGrowDot').off('click').on('click', () => {
      this.keyCommands.dotDuration();
    });
    $('button.jsShrinkDuration').off('click').on('click', () => {
      this.keyCommands.halveDuration();
    });
    $('button.jsShrinkDot').off('click').on('click', () => {
      this.keyCommands.undotDuration();
    });
    $('button.jsChord').off('click').on('click', (ev) => {
      $(ev.currentTarget).toggleClass('activated');
      this.chordPedal = !this.chordPedal;
    });
    $(this.renderElement).off('mousemove').on('mousemove', (ev) => {
      if (Math.abs(this.objects[0].box.x - this.objects[0].keyElement.getBoundingClientRect().x)
        > this.objects[0].box.width / 2) {
          console.log('remap piano');
          this._mapKeys();
      }
      var keyPressed = svgHelpers.findSmallestIntersection({
        x: ev.clientX,
        y: ev.clientY
        }, this.objects, this.scroller.scrollState);
      if (!keyPressed) {
        return;
      }
      var el = this.renderElement.getElementById(keyPressed.id);
      if ($(el).hasClass('glow-key')) {
        return;
      }
      this._removeGlow();
      $(el).addClass('glow-key');
      this._fadeGlow(el);
    });
    $(this.renderElement).off('blur').on('blur', (ev) => {
      this._removeGlow();
    });
    $(this.renderElement).off('click').on('click', (ev) => {
      this._updateSelections(ev);
    });

    $('.close-piano').off('click').on('click', () => {
      $('body').removeClass('show-piano');
      // resize the work area.
      $('body').trigger('forceScrollEvent');
    });
  }
  _updateSelections(ev) {
    // fake a scroller (piano scroller w/b cool tho...)
    var keyPressed = svgHelpers.findSmallestIntersection({
        x: ev.clientX,
        y: ev.clientY
      }, this.objects, this.scroller.scrollState);
    if (!keyPressed) {
      return;
    }
    if (!ev.shiftKey && !this.chordPedal) {
      this._removeClass('glow-key pressed-key');
    } else {
      var el = this.renderElement.getElementById(keyPressed.id);
      $(el).addClass('pressed-key');
    }
    var key = keyPressed.id.substr(6, keyPressed.id.length - 6);
    var pitch = {
      letter: key[0].toLowerCase(),
      octave: this.octaveOffset,
      accidental: key.length > 1 ? key[1] : 'n'
    };

    this.view.setPitchPiano(pitch, this.chordPedal);
  }
  _renderControls() {
    var b = htmlHelpers.buildDom;
    var r =b('button').classes('icon icon-cross close close-piano');
    $('.piano-container .key-right-ctrl').append(r.dom());
    r = b('button').classes('piano-ctrl jsGrowDuration').append(b('span').classes('icon icon-duration_grow'));
    $('.piano-container .key-right-ctrl').append(r.dom());
    r = b('button').classes('piano-ctrl jsShrinkDuration').append(b('span').classes('icon icon-duration_less'));
    $('.piano-container .key-right-ctrl').append(r.dom());
    r = b('button').classes('piano-ctrl jsGrowDot').append(b('span').classes('icon icon-duration_grow_dot'));
    $('.piano-container .key-right-ctrl').append(r.dom());
    r = b('button').classes('piano-ctrl jsShrinkDot').append(b('span').classes('icon icon-duration_less_dot'));
    $('.piano-container .key-right-ctrl').append(r.dom());

    r = b('button').classes('key-ctrl jsLeft').append(b('span').classes('icon icon-arrow-left'));
    $('.piano-container .piano-keys').prepend(r.dom());
    r = b('button').classes('key-ctrl jsRight').append(b('span').classes('icon icon-arrow-right'));
    $('.piano-container .piano-keys').append(r.dom());

    r = b('button').classes('piano-ctrl').attr('id','piano-8va-button').append(
      b('span').classes('bold-italic').text('8')).append(
        b('sup').classes('italic').text('va'));
    $('.piano-container .key-left-ctrl').append(r.dom());
    r = b('button').classes('piano-ctrl ').attr('id','piano-8vb-button').append(
      b('span').classes('bold-italic').text('8')).append(
        b('sup').classes('italic').text('vb'));
    $('.piano-container .key-left-ctrl').append(r.dom());
    r = b('button').classes('piano-ctrl jsXposeUp').attr('id','piano-xpose-up').append(
      b('span').classes('bold').text('+'));
    $('.piano-container .key-left-ctrl').append(r.dom());
    r = b('button').classes('piano-ctrl jsXposeDown').attr('id','piano-xpose-down').append(
      b('span').classes('bold').text('-'));
    $('.piano-container .key-left-ctrl').append(r.dom());
    r = b('button').classes('piano-ctrl jsEnharmonic').attr('id','piano-enharmonic').append(
      b('span').classes('bold icon icon-accident'));

    $('.piano-container .key-left-ctrl').append(r.dom());
    r = b('button').classes('piano-ctrl jsChord')
      .append(b('span').classes('icon icon-chords'));
    $('.piano-container .key-left-ctrl').append(r.dom());
  }
  handleResize() {
    this._mapKeys();
  }
  playNote() {
  }
  render() {
    $('body').addClass('show-piano');
    var b = svgHelpers.buildSvg;
    var d = suiPiano.dimensions;
    // https://www.mathpages.com/home/kmath043.htm

    // Width of white key at back for C,D,E
    var b1off = d.wwidth - (d.bwidth * 2 / 3);

    // Width of other white keys at the back.
    var b2off=d.wwidth-(d.bwidth*3)/4;

    var keyAr = [];
    var xwhite = [{
        note: 'C',
        x: 0
      }, {
        note: 'D',
        x: d.wwidth
      }, {
        note: 'E',
        x: 2 * d.wwidth
      }, {
        note: 'F',
        x: 3 * d.wwidth
      }, {
        note: 'G',
        x: 4 * d.wwidth
      }, {
        note: 'A',
        x: 5 * d.wwidth
      }, {
        note: 'B',
        x: 6 * d.wwidth
      }
    ];
    var xblack = [{
        note: 'Db',
        x: b1off
      }, {
        note: 'Eb',
        x: 2*b1off+d.bwidth
      }, {
        note: 'Gb',
        x: 3*d.wwidth+b2off
      }, {
        note: 'Ab',
        x: (3*d.wwidth+b2off)+b2off+d.bwidth
      }, {
        note: 'Bb',
        x: suiPiano.owidth-(b2off+d.bwidth)
      }
    ];
    var wwidth = d.wwidth;
    var bwidth = d.bwidth;
    var wheight = d.wheight;
    var bheight = d.bheight;
    var owidth = suiPiano.wkeysPerOctave * wwidth;

    // Start on C2 to C6 to reduce space
    var octaveOff = 7-d.octaves;

    var x = 0;
    var y = 0;
    var r = b('g');
    for (var i = 0; i < d.octaves; ++i) {
      x = i * owidth;
      xwhite.forEach((key) => {
        var nt = key.note;
        var classes = 'piano-key white-key';
        if (nt == 'C4') {
          classes += ' middle-c';
        }
        var rect = b('rect').attr('id', 'keyId-' + nt).rect(x + key.x, y, wwidth, wheight, classes);
        r.append(rect);

        var tt = b('text').text(x + key.x + (wwidth / 5), bheight + 16, 'note-text', nt);
        r.append(tt);
      });
      xblack.forEach((key) => {
        var nt = key.note;
        var classes = 'piano-key black-key';
        var rect = b('rect').attr('id', 'keyId-' + nt).attr('fill','url(#piano-grad)').rect(x + key.x, 0, bwidth, bheight, classes);
        r.append(rect);
      });
    }
    var el = document.getElementById(this.elementId);
    svgHelpers.gradient(el,'piano-grad','vertical',[{color:'#000',offset:'0%'},{color:'#777',offset:'50%'},{color:'#ddd',offset:'100%'}]);
    el.appendChild(r.dom());
    this._renderControls();
    this._mapKeys();
    this.bind();
  }
}
;// ## SuiRenderState
// Manage the state of the score rendering.  The score can be rendered either completely,
// or partially for editing.  This class works with the RenderDemon to decide when to
// render the score after it has been modified, and keeps track of what the current
// render state is (dirty, etc.)
// eslint-disable-next-line no-unused-vars
class SuiRenderState {
  constructor(ctor) {
    this.attrs = {
      id: VF.Element.newID(),
      type: ctor
    };
    this.dirty = true;
    this.replaceQ = [];
    this.renderTime = 0;  // ms to render before time slicing
    this.partialRender = false;
    this.stateRepCount = 0;
    this.viewportPages = 1;
    this.backgroundRender = false;
    this.setPassState(SuiRenderState.initial, 'ctor');
    this.viewportChanged = false;
    this._resetViewport = false;
    this.measureMapper = null;
  }

  // ### setMeasureMapper
  // DI/notifier pattern.  The measure mapper/tracker is updated when the score is rendered
  // so the UI stays in sync with the location of elements in the score.
  setMeasureMapper(mapper) {
    this.measureMapper = mapper;
  }

  static get Fonts() {
    return {
      Bravura: [VF.Fonts.Bravura, VF.Fonts.Gonville, VF.Fonts.Custom],
      Gonville: [VF.Fonts.Gonville, VF.Fonts.Bravura, VF.Fonts.Custom],
      Petaluma: [VF.Fonts.Petaluma, VF.Fonts.Gonville, VF.Fonts.Custom],
      Leland: [VF.Fonts.Leland, VF.Fonts.Bravura, VF.Fonts.Gonville, VF.Fonts.Custom]
    };
  }

  static setFont(font) {
    VF.DEFAULT_FONT_STACK = SuiRenderState.Fonts[font];
  }

  static get passStates() {
    return { initial: 0, clean: 2, replace: 3 };
  }

  addToReplaceQueue(selection) {
    if (this.passState === SuiRenderState.passStates.clean ||
      this.passState === SuiRenderState.passStates.replace) {
      if (Array.isArray(selection)) {
        this.replaceQ = this.replaceQ.concat(selection);
      } else {
        this.replaceQ.push(selection);
      }
      this.setDirty();
    }
  }

  setDirty() {
    if (!this.dirty) {
      this.dirty = true;
      if (this.passState === SuiRenderState.passStates.clean) {
        this.setPassState(SuiRenderState.passStates.replace);
      }
    }
  }
  setRefresh() {
    this.dirty = true;
    this.setPassState(SuiRenderState.passStates.initial, 'setRefresh');
  }
  rerenderAll() {
    this.dirty = true;
    this.setPassState(SuiRenderState.passStates.initial, 'rerenderAll');
    this._resetViewport = true;
  }

  remapAll() {
    this.partialRender = false;
    this.setRefresh();
  }
  get renderStateClean() {
    return this.passState === SuiRenderState.passStates.clean;
  }
  get renderStateRendered() {
    return this.passState === SuiRenderState.passStates.clean ||
      (this.passState === SuiRenderState.passStates.replace && this.replaceQ.length === 0);
  }

  // ### renderPromise
  // return a promise that resolves when the score is in a fully rendered state.
  renderPromise() {
    return PromiseHelpers.makePromise(this, 'renderStateClean', null, null, SmoConfig.demonPollTime);
  }

  // ### renderPromise
  // return a promise that resolves when the score is in a fully rendered state.
  updatePromise() {
    return PromiseHelpers.makePromise(this, 'renderStateRendered', null, null, SmoConfig.demonPollTime);
  }
  // Number the measures at the first measure in each system.
  numberMeasures() {
    const printing = $('body').hasClass('print-render');
    const staff = this.score.staves[0];
    const measures = staff.measures.filter((measure) => measure.measureNumber.systemIndex === 0);
    $('.measure-number').remove();

    measures.forEach((measure) => {
      if (measure.measureNumber.measureNumber > 0 && measure.measureNumber.systemIndex === 0) {
        const numAr = [];
        numAr.push({ y: measure.logicalBox.y - 10 });
        numAr.push({ x: measure.logicalBox.x });
        numAr.push({ 'font-family': SourceSansProFont.fontFamily });
        numAr.push({ 'font-size': '10pt' });
        svgHelpers.placeSvgText(this.context.svg, numAr, 'measure-number', (measure.measureNumber.measureNumber + 1).toString());

        // Show line-feed symbol
        const formatIndex = SmoMeasure.systemOptions.findIndex((option) => measure[option] !== SmoMeasure.defaults[option]);
        if (formatIndex >= 0 && !printing) {
          const starAr = [];
          starAr.push({ y: measure.logicalBox.y - 5 });
          starAr.push({ x: measure.logicalBox.x + 25 });
          starAr.push({ 'font-family': SourceSansProFont.fontFamily });
          starAr.push({ 'font-size': '12pt' });
          svgHelpers.placeSvgText(this.context.svg, starAr, 'measure-format', '\u21b0');
        }
      }
    });
  }

  // ### _setViewport
  // Create (or recrate) the svg viewport, considering the dimensions of the score.
  _setViewport(reset, elementId) {
    // this.screenWidth = window.innerWidth;
    const layout = this._score.layout;
    this.zoomScale = layout.zoomMode === SmoScore.zoomModes.zoomScale ?
      layout.zoomScale : (window.innerWidth - 200) / layout.pageWidth;

    if (layout.zoomMode !== SmoScore.zoomModes.zoomScale) {
      layout.zoomScale = this.zoomScale;
    }

    this.svgScale = layout.svgScale * this.zoomScale;
    this.orientation = this._score.layout.orientation;
    const w = Math.round(layout.pageWidth * this.zoomScale);
    const h = Math.round(layout.pageHeight * this.zoomScale);
    this.pageWidth =  (this.orientation  === SmoScore.orientations.portrait) ? w : h;
    this.pageHeight = (this.orientation  === SmoScore.orientations.portrait) ? h : w;
    this.totalHeight = this.pageHeight * this.score.layout.pages;
    this.viewportPages = this.score.layout.pages;

    this.leftMargin = this._score.layout.leftMargin;
    this.rightMargin = this._score.layout.rightMargin;
    $(elementId).css('width', '' + Math.round(this.pageWidth) + 'px');
    $(elementId).css('height', '' + Math.round(this.totalHeight) + 'px');
    // Reset means we remove the previous SVG element.  Otherwise, we just alter it
    if (reset) {
      $(elementId).html('');
      this.renderer = new VF.Renderer(elementId, VF.Renderer.Backends.SVG);
      this.viewportChanged = true;
      if (this.measureMapper) {
        this.measureMapper.scroller.scrollAbsolute(0, 0);
      }
    }
    svgHelpers.svgViewport(this.context.svg, 0, 0, this.pageWidth, this.totalHeight, this.svgScale);
    // this.context.setFont(this.font.typeface, this.font.pointSize, "").setBackgroundFillStyle(this.font.fillStyle);
    this.resizing = false;
    console.log('layout setViewport: pstate initial');
    this.dirty = true;
    SuiRenderState._renderer = this.renderer;
  }

  setViewport(reset) {
    this._setViewport(reset, this.elementId);
    this.score.staves.forEach((staff) => {
      staff.measures.forEach((measure) => {
        if (measure.logicalBox && reset) {
          measure.svg.history = ['reset'];
        }
      });
    });
    this.partialRender = false;
  }
  renderForPrintPromise() {
    $('body').addClass('print-render');
    const self = this;
    this._backupLayout = JSON.parse(JSON.stringify(this.score.layout));
    this.score.layout.zoomMode = SmoScore.zoomModes.zoomScale;
    this.score.layout.zoomScale = 1.0;
    this.setViewport(true);
    this.setRefresh();

    const promise = new Promise((resolve) => {
      const poll = () => {
        setTimeout(() => {
          if (!self.dirty && !self.backgroundRender) {
            // tracker.highlightSelection();
            $('body').removeClass('print-render');
            $('.vf-selection').remove();
            $('body').addClass('printing');
            $('.musicRelief').css('height', '');
            resolve();
          } else {
            poll();
          }
        }, 500);
      };
      poll();
    });
    return promise;
  }

  restoreLayoutAfterPrint() {
    if (this._backupLayout) {
      this.score.setLayout(this._backupLayout);
      this.setViewport(true);
      this.setRefresh();
      this._backupLayout = null;
    }
  }

  clearLine(measure) {
    const lineIndex = measure.lineIndex;
    const startIndex = (lineIndex > 1 ? lineIndex - 1 : 0);
    let i = 0;
    for (i = startIndex; i < lineIndex + 1; ++i) {
      // for lint error
      const index = i;
      this.score.staves.forEach((staff) => {
        const mms = staff.measures.filter((mm) => mm.lineIndex === index);
        mms.forEach((mm) => {
          delete mm.logicalBox;
        });
      });
    }
  }

  setPassState(st, location) {
    const oldState = this.passState;
    let msg = '';
    if (oldState !== st) {
      this.stateRepCount = 0;
    } else {
      this.stateRepCount += 1;
    }

    msg = location + ': passState ' + this.passState + '=>' + st;
    if (this.stateRepCount > 0) {
      msg += ' (' + this.stateRepCount + ')';
    }
    console.log(msg);
    this.passState = st;
  }
  static get defaults() {
    return {
      clefWidth: 70,
      staffWidth: 250,
      totalWidth: 250,
      leftMargin: 15,
      topMargin: 15,
      pageWidth: 8 * 96 + 48,
      pageHeight: 11 * 96,
      svgScale: 0.7,
    };
  }

  static get debugLayout() {
    SuiRenderState._debugLayout = SuiRenderState._debugLayout ? SuiRenderState._debugLayout : false;
    return SuiRenderState._debugLayout;
  }

  static set debugLayout(value) {
    SuiRenderState._debugLayout = value;
    if (value) {
      $('body').addClass('layout-debug');
    } else {
      $('body').removeClass('layout-debug');
    }
  }

  // ### get context
  // ### Description:
  // return the VEX renderer context.
  get context() {
    return this.renderer.getContext();
  }
  get renderElement() {
    return this.renderer.elementId;
  }

  get svg() {
    return this.context.svg;
  }

  get score() {
    return this._score;
  }

  set score(score) {
    let shouldReset = false;
    if (this._score) {
      shouldReset = true;
    }
    this.setPassState(SuiRenderState.passStates.initial, 'load score');
    const font = score.fonts.find((fn) => fn.purpose === SmoScore.fontPurposes.ENGRAVING);
    SuiRenderState.setFont(font.family);
    this.dirty = true;
    this._score = score;
    if (shouldReset) {
      this.renderTime = 0;
      if (this.measureMapper) {
        this.measureMapper.loadScore();
      }
      this.setViewport(true);
    }
  }

  // ### undo
  // Undo is handled by the render state machine, because the layout has to first
  // delete areas of the viewport that may have changed,
  // then create the modified score, then render the 'new' score.
  undo(undoBuffer) {
    const buffer = undoBuffer.peek();
    let op = 'setDirty';
    // Unrender the modified music because the IDs may change and normal unrender won't work
    if (buffer) {
      const sel = buffer.selector;
      if (buffer.type === UndoBuffer.bufferTypes.MEASURE) {
        this.unrenderMeasure(SmoSelection.measureSelection(this._score, sel.staff, sel.measure).measure);
      } else if (buffer.type === UndoBuffer.bufferTypes.STAFF) {
        this.unrenderStaff(SmoSelection.measureSelection(this._score, sel.staff, 0).staff);
        op = 'setRefresh';
      } else {
        this.unrenderAll();
        op = 'setRefresh';
      }
      this._score = undoBuffer.undo(this._score);
      this[op]();
    }
  }

  // ### unrenderMeasure
  // All SVG elements are associated with a logical SMO element.  We need to erase any SVG element before we change a SMO
  // element in such a way that some of the logical elements go away (e.g. when deleting a measure).
  unrenderMeasure(measure) {
    if (!measure) {
      return;
    }
    $(this.renderer.getContext().svg).find('g.' + measure.getClassId()).remove();
    measure.setYTop(0, 'unrender');
  }

  unrenderColumn(measure) {
    this.score.staves.forEach((staff) => {
      this.unrenderMeasure(staff.measures[measure.measureNumber.measureIndex]);
    });
  }

  // ### unrenderStaff
  // ### Description:
  // See unrenderMeasure.  Like that, but with a staff.
  unrenderStaff(staff) {
    staff.measures.forEach((measure) => {
      this.unrenderMeasure(measure);
    });
    staff.modifiers.forEach((modifier) => {
      $(this.renderer.getContext().svg).find('g.' + modifier.attrs.id).remove();
    });
  }

  // ### _renderModifiers
  // ### Description:
  // Render staff modifiers (modifiers straddle more than one measure, like a slur).  Handle cases where the destination
  // is on a different system due to wrapping.
  _renderModifiers(staff, system) {
    const svg = this.svg;
    let nextNote = null;
    let lastNote = null;
    let testNote = null;
    let vxStart = null;
    let vxEnd = null;
    const removedModifiers = [];
    staff.modifiers.forEach((modifier) => {
      const startNote = SmoSelection.noteSelection(this._score,
        modifier.startSelector.staff, modifier.startSelector.measure, modifier.startSelector.voice, modifier.startSelector.tick);
      const endNote = SmoSelection.noteSelection(this._score,
        modifier.endSelector.staff, modifier.endSelector.measure, modifier.endSelector.voice, modifier.endSelector.tick);
      if (!startNote || !endNote) {
        // If the modifier doesn't have score endpoints, delete it from the score
        removedModifiers.push(modifier);
        return;
      }

      vxStart = system.getVxNote(startNote.note);
      vxEnd = system.getVxNote(endNote.note);

      // If the modifier goes to the next staff, draw what part of it we can on this staff.
      if (vxStart && !vxEnd) {
        nextNote = SmoSelection.nextNoteSelection(this._score,
          modifier.startSelector.staff, modifier.startSelector.measure, modifier.startSelector.voice, modifier.startSelector.tick);
        if (nextNote === null) {
          console.warn('bad selector ' + JSON.stringify(modifier.startSelector, null, ' '));
        } else {
          testNote = system.getVxNote(nextNote.note);
          while (testNote) {
            vxEnd = testNote;
            nextNote = SmoSelection.nextNoteSelection(this._score,
              nextNote.selector.staff, nextNote.selector.measure, nextNote.selector.voice, nextNote.selector.tick);
            if (!nextNote) {
              break;
            }
            testNote = system.getVxNote(nextNote.note);
          }
        }
      }
      if (vxEnd && !vxStart) {
        lastNote = SmoSelection.lastNoteSelection(this._score,
          modifier.endSelector.staff, modifier.endSelector.measure, modifier.endSelector.voice, modifier.endSelector.tick);
        if (lastNote) {
          testNote = system.getVxNote(lastNote.note);
          while (testNote) {
            vxStart = testNote;
            lastNote = SmoSelection.lastNoteSelection(this._score,
              lastNote.selector.staff, lastNote.selector.measure, lastNote.selector.voice, lastNote.selector.tick);
            if (!lastNote) {
              break;
            }
            testNote = system.getVxNote(lastNote.note);
          }
        }
      }
      if (!vxStart && !vxEnd) {
        return;
      }
      modifier.renderedBox = system.renderModifier(modifier, vxStart, vxEnd, startNote, endNote);
      modifier.logicalBox = svgHelpers.clientToLogical(svg, modifier.renderedBox);
    });
    // Silently remove modifiers from the score if the endpoints no longer exist
    removedModifiers.forEach((mod) => {
      staff.removeStaffModifier(mod);
    });
  }

  _drawPageLines() {
    let i = 0;
    $(this.context.svg).find('.pageLine').remove();
    const printing = $('body').hasClass('print-render');
    if (printing) {
      return;
    }
    for (i = 1; i < this._score.layout.pages; ++i) {
      const y = (this.pageHeight / this.svgScale) * i;
      svgHelpers.line(this.svg, 0, y, this.score.layout.pageWidth / this.score.layout.svgScale, y,
        [
          { 'stroke': '#321' },
          { 'stroke-width': '2' },
          { 'stroke-dasharray': '4,1' },
          { 'fill': 'none' }], 'pageLine');
    }
  }

  // ### _replaceMeasures
  // Do a quick re-render of a measure that has changed.
  _replaceMeasures() {
    const staffMap = {};
    let system = {};
    this.replaceQ.forEach((change) => {
      smoBeamerFactory.applyBeams(change.measure);
      // Defer modifier update until all selected measures are drawn.
      if (!staffMap[change.staff.staffId]) {
        system = new VxSystem(this.context, change.measure.staffY, change.measure.lineIndex, this.score);
        staffMap[change.staff.staffId] = { system, staff: change.staff };
      } else {
        system = staffMap[change.staff.staffId].system;
      }
      const selections = SmoSelection.measuresInColumn(this.score, change.measure.measureNumber.measureIndex);
      selections.forEach((selection) => {
        system.renderMeasure(selection.measure, this.measureMapper);
      });

      // Fix a bug: measure change needs to stay true so we recaltulate the width
      change.measure.changed = true;
    });
    Object.keys(staffMap).forEach((key) => {
      const obj = staffMap[key];
      this._renderModifiers(obj.staff, obj.system);
      obj.system.renderEndings();
      obj.system.updateLyricOffsets();
    });
    this.replaceQ = [];
  }

  // ### forceRender
  // For unit test applictions that want to render right-away
  forceRender() {
    this.setRefresh();
    this.render();
  }

  render() {
    if (this._resetViewport) {
      this.setViewport(true);
      this._resetViewport = false;
    }
    try {
      if (SuiRenderState.passStates.replace === this.passState) {
        this._replaceMeasures();
      } else if (SuiRenderState.passStates.initial === this.passState) {
        if (this.backgroundRender) {
          return;
        }
        this.layout();
        this._drawPageLines();
        this.setPassState(SuiRenderState.passStates.clean, 'rs: complete render');
      }
    } catch (excp) {
      console.warn('exception in render: ' + excp);
    }
    this.dirty = false;
  }
}
;// ## SuiScoreRender
// This module renders the entire score.  It calculates the layout first based on the
// computed dimensions.
// eslint-disable-next-line no-unused-vars
class SuiScoreRender extends SuiRenderState {
  constructor(params) {
    super('SuiScoreRender');
    Vex.Merge(this, SuiRenderState.defaults);
    Vex.Merge(this, params);
    this.setViewport(true);

    this.attrs = {
      id: VF.Element.newID(),
      type: 'testLayout'
    };
  }

  // ### createScoreRenderer
  // ### Description;
  // to get the score to appear, a div and a score object are required.  The layout takes care of creating the
  // svg element in the dom and interacting with the vex library.
  static createScoreRenderer(renderElement, score, layoutParams) {
    const ctorObj = {
      elementId: renderElement,
      score
    };
    if (layoutParams) {
      Vex.Merge(ctorObj, layoutParams);
    }
    const layout = new SuiScoreRender(ctorObj);
    return layout;
  }

  // ### unrenderAll
  // ### Description:
  // Delete all the svg elements associated with the score.
  unrenderAll() {
    this._score.staves.forEach((staff) => {
      this.unrenderStaff(staff);
    });
    $(this.renderer.getContext().svg).find('g.lineBracket').remove();
  }

  get logicalPageWidth() {
    return this.pageMarginWidth;
  }
  get logicalPageHeight() {
    return this.pageMarginHeigh;
  }

  // ### _measureToLeft
  // measure to 'left' is on previous row if this is the first column in a system
  // but we still use it to compute beginning symbols (key sig etc.)
  _measureToLeft(measure) {
    const j = measure.measureNumber.staffId;
    const i = measure.measureNumber.measureIndex;
    if (this._score.staves.length <= j) {
      console.log('no staff');
    }
    return (i > 0 ? this._score.staves[j].measures[i - 1] : null);
  }

  renderScoreText(st) {
    const tg = new SmoTextGroup();
    tg.addScoreText(st);
    this.score.addTextGroup(tg);
    this.renderTextGroup(tg);
  }

  renderTextGroup(gg) {
    let ix = 0;
    let jj = 0;
    if (gg.skipRender) {
      return;
    }
    gg.renderedBox = {};
    gg.logicalBox = {};
    const group = this.context.openGroup();
    group.id = gg.attrs.id;

    // If this is a per-page score text, get a text group copy for each page.
    // else the array contains the original.
    const groupAr = SmoTextGroup.getPagedTextGroups(gg, this.scaledScoreLayout.pages, this.scaledScoreLayout.pageHeight);
    groupAr.forEach((newGroup) => {
      // If this text is attached to the measure, base the block location on the rendered measure location.
      if (newGroup.attachToSelector) {
        // If this text is attached to a staff that is not visible, don't draw it.
        const mappedStaff = this.score.staves.find((staff) => staff.mappedStaffId === newGroup.selector.staff);
        if (!mappedStaff) {
          return;
        }
        // Indicate the new map;
        // newGroup.selector.staff = mappedStaff.staffId;
        const mm = SmoSelection.measureSelection(this.score, mappedStaff.staffId, newGroup.selector.measure).measure;
        if (typeof(mm.logicalBox) !== 'undefined') {
          const xoff = mm.logicalBox.x + newGroup.musicXOffset;
          const yoff = mm.logicalBox.y - newGroup.musicYOffset;
          newGroup.textBlocks[0].text.x = xoff;
          newGroup.textBlocks[0].text.y = yoff;
        }
      }
      const block = SuiTextBlock.fromTextGroup(newGroup, this.renderer.getContext(), this.measureMapper.scroller);
      block.render();
      // For the first one we render, use that as the bounding box for all the text, for
      // purposes of mapper/tracker
      if (ix === 0) {
        gg.renderedBox = JSON.parse(JSON.stringify(block.renderedBox));
        gg.logicalBox = JSON.parse(JSON.stringify(block.logicalBox));
        // map all the child scoreText objects, too.
        for (jj = 0; jj < gg.textBlocks.length; ++jj) {
          gg.textBlocks[jj].text.renderedBox = JSON.parse(JSON.stringify(block.inlineBlocks[jj].text.renderedBox));
          gg.textBlocks[jj].text.logicalBox = JSON.parse(JSON.stringify(block.inlineBlocks[jj].text.logicalBox));
        }
      }
      ix += 1;
    });
    this.context.closeGroup();
  }

  renderScoreModifiers() {
    $(this.renderer.getContext().svg).find('.all-score-text').remove();
    const group = this.context.openGroup();
    group.classList.add('all-score-text');

    this._score.scoreText.forEach((tt) => {
      this.renderScoreText(tt);
    });

    this._score.textGroups.forEach((tg) => {
      this.renderTextGroup(tg);
    });
    this.context.closeGroup();
  }

  // ### calculateBeginningSymbols
  // calculate which symbols like clef, key signature that we have to render in this measure.
  calculateBeginningSymbols(systemIndex, measure, clefLast, keySigLast, timeSigLast, tempoLast) {
    const measureKeySig = smoMusic.vexKeySignatureTranspose(measure.keySignature, measure.transposeIndex);
    measure.forceClef = (systemIndex === 0 || measure.clef !== clefLast);
    measure.forceTimeSignature = (measure.measureNumber.measureIndex === 0 || measure.timeSignature !== timeSigLast);
    measure.forceTempo = false;
    const tempo = measure.getTempo();
    if (tempo && measure.measureNumber.measureIndex === 0) {
      measure.forceTempo = tempo.display && measure.svg.rowInSystem === 0;
    } else if (tempo && tempoLast) {
      if (!SmoTempoText.eq(tempo, tempoLast) && measure.svg.rowInSystem === 0) {
        measure.forceTempo = tempo.display;
      }
    } else if (tempo) {
      measure.forceTempo = tempo.display && measure.svg.rowInSystem === 0;
    }
    if (measureKeySig !== keySigLast) {
      measure.canceledKeySignature = keySigLast;
      measure.forceKeySignature = true;
    } else if (systemIndex === 0 && measureKeySig !== 'C') {
      measure.forceKeySignature = true;
    } else {
      measure.forceKeySignature = false;
    }
  }

  _getMeasuresInColumn(ix) {
    const rv = [];
    this.score.staves.forEach((staff) => {
      const inst = staff.measures.find((ss) => ss.measureNumber.measureIndex === ix);
      if (inst) {
        rv.push(inst);
      }
    });
    return rv;
  }
  get scaledScoreLayout() {
    const svgScale = this.score.layout.svgScale;
    const rv = JSON.parse(JSON.stringify(this.score.layout));
    const attrs = ['topMargin', 'bottomMargin', 'interGap', 'intraGap', 'pageHeight', 'pageWidth', 'leftMargin', 'rightMargin'];
    attrs.forEach((attr) => {
      rv[attr] = rv[attr] / svgScale;
    });
    return rv;
  }
  _renderSystem(key, mscore, printing) {
    const columns = {};
    const vxSystem = new VxSystem(this.context, 0, parseInt(key, 10), this.score);
    mscore[key].forEach((measure) => {
      if (!columns[measure.measureNumber.systemIndex]) {
        columns[measure.measureNumber.systemIndex] = [];
      }
      columns[measure.measureNumber.systemIndex].push(measure);
    });
    const colKeys = Object.keys(columns);
    colKeys.forEach((colKey) => {
      columns[colKey].forEach((measure) => {
        vxSystem.renderMeasure(measure, this.measureMapper, printing);
        const formatIndex = SmoMeasure.formattingOptions.findIndex((option) => measure[option] !== SmoMeasure.defaults[option]);
        if (formatIndex >= 0 && !printing) {
          const at = [];
          at.push({ y: measure.logicalBox.y - 5 });
          at.push({ x: measure.logicalBox.x + 25 });
          at.push({ 'font-family': SourceSansProFont.fontFamily });
          at.push({ 'font-size': '12pt' });
          svgHelpers.placeSvgText(this.context.svg, at, 'measure-format', '*');
        }
      });
    });
    const timestamp = new Date().valueOf();
    vxSystem.renderEndings();
    vxSystem.updateLyricOffsets();
    this._score.staves.forEach((stf) => {
      this._renderModifiers(stf, vxSystem);
    });
    layoutDebug.setTimestamp(layoutDebug.codeRegions.POST_RENDER, new Date().valueOf() - timestamp);
  }
  _renderNextSystemPromise(systemIx, mscore, keys, printing) {
    return new Promise((resolve) => {
      this._renderSystem(keys[systemIx], mscore, printing);
      resolve();
    });
  }
  _deferNextSystemPromise(systemIx, mscore, keys, printing) {
    return new Promise((resolve) => {
      this._renderNextSystemPromise(systemIx, mscore, keys, printing).then(() => {
        setTimeout(() => {
          resolve();
        }, 10);
      });
    });
  }
  _renderNextSystem(systemIx, mscore, keys, printing) {
    if (systemIx < keys.length) {
      const progress = Math.round((100 * systemIx) / keys.length);
      $('#renderProgress').val(progress);
      this._deferNextSystemPromise(systemIx, mscore, keys, printing).then(() => {
        systemIx++;
        this._renderNextSystem(systemIx, mscore, keys, printing);
      });
    } else {
      this.renderScoreModifiers();
      this.numberMeasures();
      this.renderTime = new Date().valueOf() - this.startRenderTime;
      $('body').removeClass('show-render-progress');
      this.backgroundRender = false;
    }
  }

  renderAllMeasures() {
    const mscore = {};
    const printing = $('body').hasClass('print-render');
    $('.measure-format').remove();
    this.score.staves.forEach((staff) => {
      staff.measures.forEach((measure) => {
        if (!mscore[measure.lineIndex]) {
          mscore[measure.lineIndex] = [];
        }
        mscore[measure.lineIndex].push(measure);
      });
    });

    const keys = Object.keys(mscore);
    if (!printing) {
      $('body').addClass('show-render-progress');
    }
    this.backgroundRender = true;
    this.startRenderTime = new Date().valueOf();
    this._renderNextSystem(0, mscore, keys, printing);
  }

  // ### _justifyY
  // when we have finished a line of music, adjust the measures in the system so the
  // top of the staff lines up.
  _justifyY(svg, scoreLayout, measureEstimate, currentLine, lastSystem) {
    let i = 0;
    // We estimate the staves at the same absolute y value.
    // Now, move them down so the top of the staves align for all measures in a  row.
    for (i = 0; i < measureEstimate.measures.length; ++i) {
      let justifyX = 0;
      const index = i;
      const rowAdj = currentLine.filter((mm) => mm.svg.rowInSystem === index);
      // lowest staff has greatest staffY value.
      const lowestStaff = rowAdj.reduce((a, b) =>
        a.staffY > b.staffY ? a : b
      );
      const sh = svgHelpers;
      rowAdj.forEach((measure) => {
        const adj = lowestStaff.staffY - measure.staffY;
        measure.setY(measure.staffY + adj);
        measure.setBox(sh.boxPoints(measure.logicalBox.x, measure.logicalBox.y + adj, measure.logicalBox.width, measure.logicalBox.height));
      });
      const rightStaff = rowAdj.reduce((a, b) =>
        a.staffX + a.staffWidth > b.staffX + b.staffWidth ?  a : b);

      if (!lastSystem) {
        justifyX = Math.round((scoreLayout.pageWidth - (scoreLayout.leftMargin + scoreLayout.rightMargin + rightStaff.staffX + rightStaff.staffWidth))
          / rowAdj.length);
      }
      const ld = layoutDebug;
      rowAdj.forEach((measure) => {
        measure.setWidth(measure.staffWidth + justifyX, '_estimateMeasureDimensions justify');
        const offset = measure.measureNumber.systemIndex * justifyX;
        measure.setX(measure.staffX + offset);
        measure.setBox(sh.boxPoints(measure.logicalBox.x + offset, measure.logicalBox.y, measure.staffWidth, measure.logicalBox.height));
        ld.debugBox(svg, measure.logicalBox, 'adjust');
      });
    }
  }

  // ### _checkPageBreak
  // See if this line breaks the page boundary
  _checkPageBreak(scoreLayout, currentLine, bottomMeasure) {
    let pageAdj = 0;
    // See if this measure breaks a page.
    const maxY = bottomMeasure.logicalBox.y +  bottomMeasure.logicalBox.height;
    if (maxY > (scoreLayout.pages * scoreLayout.pageHeight) - scoreLayout.bottomMargin) {
      // When adjusting the page, make it so the top staff of the system
      // clears the bottom of the page.
      const topMeasure = currentLine.reduce((a, b) =>
        a.logicalBox.y < b.logicalBox.y ? a : b
      );
      const minMaxY = topMeasure.logicalBox.y;
      pageAdj = (scoreLayout.pages * scoreLayout.pageHeight) - minMaxY;
      pageAdj = pageAdj + scoreLayout.topMargin;
      scoreLayout.pages += 1;
      currentLine.forEach((measure) => {
        measure.setBox(svgHelpers.boxPoints(
          measure.logicalBox.x, measure.logicalBox.y + pageAdj, measure.logicalBox.width, measure.logicalBox.height));
        measure.setY(measure.staffY + pageAdj);
      });
    }
  }

  layout() {
    let measureIx = 0;
    let systemIndex = 0;
    let y = 0;
    let x = 0;
    let lineIndex = 0;
    let currentLine = []; // the system we are esimating
    let measureEstimate = {};
    $('head title').text(this.score.scoreInfo.name);

    layoutDebug.clearDebugBoxes('pre');
    layoutDebug.clearDebugBoxes('post');
    layoutDebug.clearDebugBoxes('adjust');
    layoutDebug.clearDebugBoxes('system');
    layoutDebug.clearDebugBoxes('note');
    const timestamp = new Date().valueOf();

    const svg = this.context.svg;
    const scoreLayout = this.scaledScoreLayout;
    scoreLayout.pages = 1;

    y = scoreLayout.topMargin;
    x = scoreLayout.leftMargin;

    while (measureIx < this.score.staves[0].measures.length) {
      measureEstimate = this._estimateColumn(scoreLayout, measureIx, systemIndex, lineIndex, x, y);
      x = measureEstimate.x;

      if (systemIndex > 0 &&
        (measureEstimate.measures[0].getForceSystemBreak() || measureEstimate.x > (scoreLayout.pageWidth - scoreLayout.leftMargin))) {
        this._justifyY(svg, scoreLayout, measureEstimate, currentLine, false);
        // find the measure with the lowest y extend (greatest y value), not necessarily one with lowest
        // start of staff.
        const bottomMeasure = currentLine.reduce((a, b) =>
          a.logicalBox.y + a.logicalBox.height > b.logicalBox.y + b.logicalBox.height ? a : b
        );
        this._checkPageBreak(scoreLayout, currentLine, bottomMeasure);

        const ld = layoutDebug;
        const sh = svgHelpers;
        if (layoutDebug.mask & layoutDebug.values.system) {
          currentLine.forEach((measure) => {
            ld.debugBox(svg, measure.logicalBox, 'system');
            ld.debugBox(svg, sh.boxPoints(measure.staffX, measure.logicalBox.y, measure.adjX, measure.logicalBox.height), 'post');
          });
        }

        // Now start rendering on the next system.
        y = bottomMeasure.logicalBox.height + bottomMeasure.logicalBox.y + this.score.layout.interGap;
        currentLine = [];
        systemIndex = 0;
        x = scoreLayout.leftMargin;
        lineIndex += 1;
        measureEstimate = this._estimateColumn(scoreLayout, measureIx, systemIndex, lineIndex, x, y);
        x = measureEstimate.x;
      }
      // ld declared for lint
      const ld = layoutDebug;
      measureEstimate.measures.forEach((measure) => {
        ld.debugBox(svg, measure.logicalBox, 'pre');
      });

      currentLine = currentLine.concat(measureEstimate.measures);
      measureIx += 1;
      systemIndex += 1;
      // If this is the last measure but we have not filled the x extent,
      // still justify the vertical staves and check for page break.
      if (measureIx >= this.score.staves[0].measures.length) {
        this._justifyY(svg, scoreLayout, measureEstimate, currentLine, true);
        const bottomMeasure = currentLine.reduce((a, b) =>
          a.logicalBox.y + a.logicalBox.height > b.logicalBox.y + b.logicalBox.height ? a : b
        );
        this._checkPageBreak(scoreLayout, currentLine, bottomMeasure);
      }
    }
    if (scoreLayout.pages !== this.score.layout.pages) {
      this.score.layout.pages = scoreLayout.pages;
      this.setViewport(true);
    }
    layoutDebug.setTimestamp(layoutDebug.codeRegions.COMPUTE, new Date().valueOf() - timestamp);
    this.renderAllMeasures();
  }

  // ### _estimateColumns
  // the new logic to estimate the dimensions of a column of music, corresponding to
  // a certain measure index.
  // returns:
  // {measures,y,x}  the x and y at the left/bottom of the render
  _estimateColumn(scoreLayout, measureIx, systemIndex, lineIndex, x, y) {
    const s = {};
    let measureToLeft = {};
    const measures = this._getMeasuresInColumn(measureIx);
    let rowInSystem = 0;
    // Keep running tab of accidental widths for justification
    const accidentalMap = {};
    measures.forEach((measure) => {
      smoBeamerFactory.applyBeams(measure);
      measure.measureNumber.systemIndex = systemIndex;
      measure.svg.rowInSystem = rowInSystem;
      measure.lineIndex = lineIndex;

      // use measure to left to figure out whether I need to render key signature, etc.
      // If I am the first measure, just use self and we always render them on the first measure.
      measureToLeft = this._measureToLeft(measure);
      if (!measureToLeft) {
        measureToLeft = measure;
      }
      s.measureKeySig = smoMusic.vexKeySignatureTranspose(measure.keySignature, measure.transposeIndex);
      s.keySigLast = smoMusic.vexKeySignatureTranspose(measureToLeft.keySignature, measure.transposeIndex);
      s.tempoLast = measureToLeft.getTempo();
      s.timeSigLast = measureToLeft.timeSignature;
      s.clefLast = measureToLeft.clef;
      this.calculateBeginningSymbols(systemIndex, measure, s.clefLast, s.keySigLast, s.timeSigLast, s.tempoLast);

      // calculate vertical offsets from the baseline
      const offsets = suiLayoutAdjuster.estimateMeasureHeight(measure, this.score.layout);
      measure.setYTop(offsets.aboveBaseline);
      measure.setY(y - measure.yTop, '_estimateColumns height');
      measure.setX(x);

      // Add custom width to measure:
      measure.setBox(svgHelpers.boxPoints(measure.staffX, y, measure.staffWidth, offsets.belowBaseline - offsets.aboveBaseline));
      suiLayoutAdjuster.estimateMeasureWidth(measure, this.score.layout.noteSpacing, accidentalMap);
      y = y + measure.logicalBox.height + scoreLayout.intraGap;
      rowInSystem += 1;
    });

    // justify this column to the maximum width
    const maxMeasure = measures.reduce((a, b) => a.staffX + a.staffWidth > b.staffX + b.staffWidth ? a : b);
    const maxX = maxMeasure.staffX + maxMeasure.staffWidth;
    const maxAdjMeasure = measures.reduce((a, b) => a.adjX > b.adjX  ? a : b);
    const maxAdj = maxAdjMeasure.adjX;
    measures.forEach((measure) => {
      measure.setWidth(measure.staffWidth + (maxX - (measure.staffX + measure.staffWidth)));
      measure.adjX = maxAdj;
    });
    const rv = { measures, y, x: maxX };
    return rv;
  }
}
;// ## SuiScoreView
// Do a thing to the music.  Save in undo buffer before.  Render the score to reflect
// the change after.  Map the operation on the score view to the actual score.
// eslint-disable-next-line no-unused-vars
class SuiScoreView {
  // ### _reverseMapSelection
  // For operations that affect all columns, we operate on the
  // entire score and update the view score.  Some selections
  // will not have an equivalent in the reverse map since the
  // view can be a subset.
  _reverseMapSelection(selection) {
    const staffIndex = this.staffMap.indexOf(selection.selector.staff);
    if (staffIndex < 0) {
      return null;
    }
    if (typeof(selection.selector.tick) === 'undefined') {
      return SmoSelection.measureSelection(this.score, staffIndex, selection.selector.measure);
    }
    if (typeof(selection.selector.pitches) === 'undefined') {
      return SmoSelection.noteSelection(this.score, staffIndex, selection.selector.measure, selection.selector.voice,
        selection.selector.tick);
    }
    return SmoSelection.pitchSelection(this.score, staffIndex, selection.selector.measure, selection.selector.voice,
      selection.selector.tick, selection.selector.pitches);
  }
  _reverseMapSelections(selections) {
    const rv = [];
    selections.forEach((selection) => {
      const rsel = this._reverseMapSelection(selection);
      if (rsel !== null) {
        rv.push(rsel);
      }
    });
    return rv;
  }

  // ### _getEquivalentSelections
  // The plural form of _getEquivalentSelection
  _getEquivalentSelections(selections) {
    const rv = [];
    selections.forEach((selection) => {
      rv.push(this._getEquivalentSelection(selection));
    });
    return rv;
  }
  _undoStaffModifier(label, staffModifier, subtype) {
    const copy = StaffModifierBase.deserialize(staffModifier.serialize());
    copy.startSelector = this._getEquivalentSelector(copy.startSelector);
    copy.endSelector = this._getEquivalentSelector(copy.endSelector);
    this.undoBuffer.addBuffer(label, UndoBuffer.bufferTypes.STAFF_MODIFIER, null,
      staffModifier.serialize(), subtype);
    this.storeUndo.addBuffer(label, UndoBuffer.bufferTypes.STAFF_MODIFIER, null,
      copy.serialize(), subtype);
  }
  // ### _undoRectangle
  // Create a rectangle undo, like a multiple columns but not necessarily the whole
  // score.
  _undoRectangle(label, startSelector, endSelector, score, undoBuffer) {
    undoBuffer.addBuffer(label, UndoBuffer.bufferTypes.RECTANGLE, null, { score, topLeft: startSelector, bottomRight: endSelector });
  }
  _undoColumn(label, measureIndex) {
    this.undoBuffer.addBuffer(label, UndoBuffer.bufferTypes.COLUMN, null, { score: this.score, measureIndex });
    this.storeUndo.addBuffer(label, UndoBuffer.bufferTypes.COLUMN, null, { score: this.storeScore, measureIndex });
  }
  _undoScorePreferences(label) {
    this.undoBuffer.addBuffer(label, UndoBuffer.bufferTypes.SCORE_ATTRIBUTES, null, this.score);
    this.storeUndo.addBuffer(label, UndoBuffer.bufferTypes.SCORE_ATTRIBUTES, null, this.storeScore);
  }
  // ### _getRectangleFromStaffGroup
  // For selections that affect a system of staves, find the rectangle based on one of the
  // staves and return the selectors.
  _getRectangleFromStaffGroup(selection, staffMap) {
    let startSelector = {};
    let endSelector = {};
    let staffFilter = [];
    const sygrp = this.score.getSystemGroupForStaff(selection);
    if (sygrp) {
      startSelector = { staff: sygrp.startSelector.staff, measure: selection.selector.measure };
      endSelector = { staff: sygrp.endSelector.staff, measure: selection.selector.measure };
      // Because of the staff map, some staves may not be in the view,
      // so only include staves actually in the map.
      // staffFilter is all the staves eligible for the group in the view.
      staffFilter = staffMap.filter((map) => map >= sygrp.startSelector.staff && map <= sygrp.endSelector.staff);
      // min is start staff
      startSelector.staff = staffFilter.reduce((a, b) => a < b ? a : b);
      // max is end staff
      endSelector.staff = staffFilter.reduce((a, b) => a > b ? a : b);
    } else {
      startSelector = { staff: selection.selector.staff, measure: selection.selector.measure };
      endSelector = JSON.parse(JSON.stringify(startSelector));
    }
    return { startSelector, endSelector };
  }

  // ### _undoTrackerSelections
  // Add to the undo buffer the current set of measures selected.
  _undoTrackerMeasureSelections(label) {
    const measureSelections = SmoSelection.getMeasureList(this.tracker.selections);
    measureSelections.forEach((measureSelection) => {
      const equiv = this._getEquivalentSelection(measureSelection);
      this.undoBuffer.addBuffer(label, UndoBuffer.bufferTypes.MEASURE, measureSelection.selector, measureSelection.measure);
      this.storeUndo.addBuffer(label, UndoBuffer.bufferTypes.MEASURE, equiv.selector, equiv.measure);
    });
    return measureSelections;
  }
  // ### _undoFirstMeasureSelection
  // operation that only affects the first selection.  Setup undo for the measure
  _undoFirstMeasureSelection(label) {
    const sel = this.tracker.selections[0];
    const equiv = this._getEquivalentSelection(sel);
    this.undoBuffer.addBuffer(label, UndoBuffer.bufferTypes.MEASURE, sel.selector, sel.measure);
    this.storeUndo.addBuffer(label, UndoBuffer.bufferTypes.MEASURE, equiv.selector, equiv.measure);
    return sel;
  }
  _undoSelection(label, selection) {
    const equiv = this._getEquivalentSelection(selection);
    this.undoBuffer.addBuffer(label,
      UndoBuffer.bufferTypes.MEASURE, selection.selector, selection.measure);
    this.storeUndo.addBuffer(label,
      UndoBuffer.bufferTypes.MEASURE, equiv.selector, equiv.measure);
  }
  // ###_renderChangedMeasures
  // Update renderer for measures that have changed
  _renderChangedMeasures(measureSelections) {
    if (!Array.isArray(measureSelections)) {
      measureSelections = [measureSelections];
    }
    measureSelections.forEach((measureSelection) => {
      this.renderer.addToReplaceQueue(measureSelection);
    });
  }
  _renderRectangle(fromSelector, toSelector) {
    this._getRectangleSelections(fromSelector, toSelector, this.score).forEach((s) => {
      this.renderer.addToReplaceQueue(s);
    });
  }

  // ###_renderChangedMeasures
  // Setup undo for operation that affects the whole score
  _undoScore(label) {
    this.undoBuffer.addBuffer(label, UndoBuffer.bufferTypes.SCORE, null, this.score);
    this.storeUndo.addBuffer(label, UndoBuffer.bufferTypes.SCORE, null, this.storeScore);
  }
  _getEquivalentSelector(selector) {
    const rv = JSON.parse(JSON.stringify(selector));
    rv.staff = this.staffMap[selector.staff];
    return rv;
  }
  _getEquivalentSelection(selection) {
    try {
      if (typeof(selection.selector.tick) === 'undefined') {
        return SmoSelection.measureSelection(this.storeScore, this.staffMap[selection.selector.staff], selection.selector.measure);
      }
      if (typeof(selection.selector.pitches) === 'undefined') {
        return SmoSelection.noteSelection(this.storeScore, this.staffMap[selection.selector.staff], selection.selector.measure, selection.selector.voice,
          selection.selector.tick);
      }
      return SmoSelection.pitchSelection(this.storeScore, this.staffMap[selection.selector.staff], selection.selector.measure, selection.selector.voice,
        selection.selector.tick, selection.selector.pitches);
    } catch (ex) {
      console.warn(ex);
      return null;
    }
  }
  _removeStandardModifier(modifier) {
    $(this.renderer.context.svg).find('g.' + modifier.attrs.id).remove();
  }

  _getEquivalentGraceNote(selection, gn) {
    return selection.note.getGraceNotes().find((gg) => gg.attrs.id === gn.attrs.id);
  }
  _getRectangleSelections(startSelector, endSelector, score) {
    const rv = [];
    let i = 0;
    let j = 0;
    for (i = startSelector.staff; i <= endSelector.staff; i++) {
      for (j = startSelector.measure; j <= endSelector.measure; j++) {
        const target = SmoSelection.measureSelection(score, i, j);
        rv.push(target);
      }
    }
    return rv;
  }

  static get Instance() {
    if (typeof(SuiScoreView._instance) !== 'undefined') {
      return SuiScoreView._instance;
    }
    return null;
  }
  // ### groupUndo
  // Indicate we want to group the undo operations into one undo
  groupUndo(val) {
    this.undoBuffer.grouping = val;
    this.storeUndo.grouping = val;
  }

  // ### defaultStaffMap
  // Show all staves, 1:1 mapping of view score staff to stored score staff
  get defaultStaffMap() {
    let i = 0;
    const rv = [];
    for (i = 0; i < this.storeScore.staves.length; ++i) {
      rv.push(i);
    }
    return rv;
  }
  constructor(renderer, score, scrollSelector) {
    this.score = score;
    this.renderer = renderer;
    const scoreJson = score.serialize();
    this.scroller = new suiScroller(scrollSelector);
    this.pasteBuffer = new PasteBuffer();
    this.storePaste = new PasteBuffer();
    this.tracker = new suiTracker(this.renderer, this.scroller, this.pasteBuffer);
    this.renderer.setMeasureMapper(this.tracker);

    this.storeScore = SmoScore.deserialize(JSON.stringify(scoreJson));
    this.undoBuffer = new UndoBuffer();
    this.layoutDemon = new SuiRenderDemon({ view: this, undoBuffer: this.undoBuffer });
    this.storeUndo = new UndoBuffer();
    this.staffMap = this.defaultStaffMap;
    SuiScoreView._instance = this; // for debugging
    this.setMappedStaffIds();
    this.actionBuffer = new SmoActionRecord();
    this.tracker.recordBuffer = this.actionBuffer;
  }
  startRenderingEngine() {
    this.layoutDemon.startDemon();
  }
  static debugUnitTest() {
    const dbg = SuiScoreView.Instance;
    if (dbg === null) {
      return;
    }
    dbg.changeScore(SmoScore.getDefaultScore());
    dbg.actionBuffer.actions = JSON.parse(testCase1);
    dbg.actionBuffer.executeIndex = SuiScoreView.Instance.actionBuffer.actions.length;
    dbg.replayActions();
  }

  getView() {
    const rv = [];
    let i = 0;
    for (i = 0; i < this.storeScore.staves.length; ++i) {
      const show = this.staffMap.indexOf(i) >= 0;
      rv.push({ show });
    }
    return rv;
  }
  playActions(actionJson) {
    if (!this.actionBuffer.endCondition) {
      return;
    }
    this.oldActions = JSON.parse(JSON.stringify(this.actionBuffer.actions));
    this.actionBuffer.actions = actionJson;
    this.actionBuffer.resetRunner();
    this.replayActions();
  }
  setMappedStaffIds() {
    this.score.staves.forEach((staff) => {
      staff.mappedStaffId = this.staffMap[staff.staffId];
    });
  }

  // ### setView
  // Send a list of rows with a 'show' boolean in each, we display that line
  // in the staff and hide the rest
  setView(rows) {
    let i = 0;
    const any = rows.find((row) => row.show === true);
    if (!any) {
      return;
    }
    this._undoScore('change view');
    const nscore = SmoScore.deserialize(JSON.stringify(this.storeScore.serialize()));
    const staveScore =  SmoScore.deserialize(JSON.stringify(this.storeScore.serialize()));
    nscore.staves = [];
    const staffMap = [];
    for (i = 0; i < rows.length; ++i) {
      const row = rows[i];
      if (row.show) {
        nscore.staves.push(staveScore.staves[i]);
        staffMap.push(i);
      }
    }
    nscore.numberStaves();
    this.staffMap = staffMap;
    this.score = nscore;
    // Indicate which score staff view staves are mapped to, to decide to display
    // modifiers.
    this.setMappedStaffIds();
    this.renderer.score = nscore;
    this.renderer.setViewport(true);
    setTimeout(() => {
      $('body').trigger('forceResizeEvent');
    }, 1);
  }
  // ### viewAll
  // view all the staffs in score mode.
  viewAll() {
    this.score = SmoScore.deserialize(JSON.stringify(this.storeScore.serialize()));
    this.staffMap = this.defaultStaffMap;
    this.renderer.score = this.score;
    this.renderer.setViewport(true);
  }
  // ### changeScore
  // Update the view after loading or restoring a completely new score
  changeScore(score) {
    this._undoScore('load new score');
    this.renderer.score = score;
    this.renderer.setViewport(true);
    this.storeScore = SmoScore.deserialize(JSON.stringify(score.serialize()));
    this.score = score;
    this.staffMap = this.defaultStaffMap;
    this.actionBuffer.clearActions();
    setTimeout(() => {
      $('body').trigger('forceResizeEvent');
    }, 1);
  }
  preserveScroll() {
    const scrollState = this.scroller.scrollState;
    this.renderer.renderPromise().then(() => {
      this.scroller.restoreScrollState(scrollState);
    });
  }

  // ### undo
  // for the view score, we the renderer decides what to render
  // depending on what is undone.
  undo() {
    this.renderer.undo(this.undoBuffer);
    // A score-level undo might have changed the score.
    this.score = this.renderer.score;
    this.storeScore = this.storeUndo.undo(this.storeScore);
  }
}
;// ## ScoreViewOperations
// MVVM-like operations on the displayed score.
// All operations that can be performed on a 'live' score go through this
// module.  It maps the score view to the actual score and makes sure the
// model and view stay in sync.
/* global: SmoSelection */
// eslint-disable-next-line no-unused-vars
class SuiScoreViewOperations extends SuiScoreView {
  addTextGroup(textGroup) {
    this.actionBuffer.addAction('addTextGroup', textGroup);
    const altNew = SmoTextGroup.deserialize(textGroup.serialize());
    SmoUndoable.changeTextGroup(this.score, this.undoBuffer, textGroup,
      UndoBuffer.bufferSubtypes.ADD);
    SmoUndoable.changeTextGroup(this.storeScore, this.storeUndo, altNew,
      UndoBuffer.bufferSubtypes.ADD);
    this.renderer.renderScoreModifiers();
  }

  removeTextGroup(textGroup) {
    this.actionBuffer.addAction('removeTextGroup', textGroup);
    const index = this.score.textGroups.findIndex((grp) => textGroup.attrs.id === grp.attrs.id);
    const altGroup = this.storeScore.textGroups[index];
    SmoUndoable.changeTextGroup(this.score, this.undoBuffer, textGroup,
      UndoBuffer.bufferSubtypes.REMOVE);
    SmoUndoable.changeTextGroup(this.storeScore, this.storeUndo, altGroup,
      UndoBuffer.bufferSubtypes.REMOVE);
    this.renderer.renderScoreModifiers();
  }

  updateTextGroup(oldVersion, newVersion) {
    this.actionBuffer.addAction('updateTextGroup', oldVersion, newVersion);
    const index = this.score.textGroups.findIndex((grp) => oldVersion.attrs.id === grp.attrs.id);
    SmoUndoable.changeTextGroup(this.score, this.undoBuffer, oldVersion,
      UndoBuffer.bufferSubtypes.UPDATE);
    SmoUndoable.changeTextGroup(this.storeScore, this.storeUndo, this.storeScore.textGroups[index], UndoBuffer.bufferSubtypes.UPDATE);
    const altNew = SmoTextGroup.deserialize(newVersion.serialize());
    this.storeScore.textGroups[index] = altNew;
    // TODO: only render the one TG.
    this.renderer.renderScoreModifiers();
  }
  updateProportionDefault(oldValue, newValue) {
    this.actionBuffer.addAction('updateProportionDefault', oldValue, newValue);
    this._undoScorePreferences('Update proportion');
    SmoOperation.updateProportionDefault(this.score, oldValue, newValue);
    SmoOperation.updateProportionDefault(this.storeScore, oldValue, newValue);
    this.renderer.setDirty();
  }
  // ### updateScorePreferences
  // The score preferences for view score have changed, sync them
  updateScorePreferences() {
    this._undoScorePreferences('Update preferences');
    // TODO: add action buffer here?
    smoSerialize.serializedMerge(SmoScore.preferences, this.score, this.storeScore);
    this.renderer.setDirty();
  }
  // ### updateScorePreferences
  // The score preferences for view score have changed, sync them
  updateScoreInfo(scoreInfo) {
    this._undoScorePreferences('Update preferences');
    // TODO: add action buffer here?
    this.score.scoreInfo = scoreInfo;
    this.storeScore.scoreInfo = JSON.parse(JSON.stringify(scoreInfo));
    this.renderer.setDirty();
  }

  addRemoveMicrotone(tone) {
    this.actionBuffer.addAction('addRemoveMicrotone', tone);
    const selections = this.tracker.selections;
    const altSelections = this._getEquivalentSelections(selections);
    const measureSelections = this._undoTrackerMeasureSelections('add/remove microtone');

    SmoOperation.addRemoveMicrotone(null, selections, tone);
    SmoOperation.addRemoveMicrotone(null, altSelections, tone);
    this._renderChangedMeasures(measureSelections);
  }
  addDynamic(dynamic) {
    const sel = this.tracker.selections[0];
    if (typeof(dynamic) === 'string') {
      dynamic = new SmoDynamicText({
        selector: sel.selector,
        text: dynamic,
        yOffsetLine: 11,
        fontSize: 38
      });
    }
    this.actionBuffer.addAction('addDynamic', dynamic);
    this._undoFirstMeasureSelection('add dynamic');
    this._removeDynamic(sel, dynamic);
    const equiv = this._getEquivalentSelection(sel);
    SmoOperation.addDynamic(sel, dynamic);
    SmoOperation.addDynamic(equiv, SmoNoteModifierBase.deserialize(dynamic.serialize()));
    this.renderer.addToReplaceQueue(sel);
  }
  _removeDynamic(selection, dynamic) {
    const equiv = this._getEquivalentSelection(selection);
    const altModifiers = equiv.note.getModifiers('SmoDynamicText');
    SmoOperation.removeDynamic(selection, dynamic);
    if (altModifiers.length) {
      SmoOperation.removeDynamic(equiv, altModifiers[0]);
    }
  }
  removeDynamic(dynamic) {
    const sel = this.tracker.modifierSelections[0];
    if (!sel) {
      return;
    }
    this.tracker.selections = [sel.selection];
    this.actionBuffer.addAction('removeDynamic', dynamic);
    this._undoFirstMeasureSelection('remove dynamic');
    this._removeDynamic(sel.selection, dynamic);
    this.renderer.addToReplaceQueue(sel.selection);
  }
  // ### deleteNote
  // we never really delete a note, but we will convert it into a rest and if it's
  // already a rest we will try to hide it.
  deleteNote() {
    this.actionBuffer.addAction('deleteNote');
    const measureSelections = this._undoTrackerMeasureSelections('delete note');
    this.tracker.selections.forEach((sel) => {
      const altSel = this._getEquivalentSelection(sel);

      // set the pitch to be a good position for the rest
      const pitch = JSON.parse(JSON.stringify(
        SmoMeasure.defaultPitchForClef[sel.measure.clef]));
      const altPitch = JSON.parse(JSON.stringify(
        SmoMeasure.defaultPitchForClef[altSel.measure.clef]));
      sel.note.pitches = [pitch];
      altSel.note.pitches = [altPitch];

      // If the note is a note, make it into a rest.  If the note is a rest already,
      // make it invisible.  If it is invisible already, make it back into a rest.
      if (sel.note.isRest() && !sel.note.hidden) {
        sel.note.makeHidden(true);
        altSel.note.makeHidden(true);
      } else {
        sel.note.makeRest();
        altSel.note.makeRest();
        sel.note.makeHidden(false);
        altSel.note.makeHidden(false);
      }
    });
    this._renderChangedMeasures(measureSelections);
  }
  // ### removeLyric
  // The lyric editor moves around, so we can't depend on the tracker for the
  // correct selection.  We get it directly from the editor.
  removeLyric(selector, lyric) {
    this.actionBuffer.addAction('removeLyric', selector, lyric);
    const selection = SmoSelection.noteFromSelector(this.score, selector);
    this._undoSelection('remove lyric', selection);
    selection.note.removeLyric(lyric);
    const equiv = this._getEquivalentSelection(selection);
    const storeLyric = equiv.note.getLyricForVerse(lyric.verse, lyric.parser);
    if (typeof(storeLyric) !== 'undefined') {
      equiv.note.removeLyric(lyric);
    }
    this.renderer.addToReplaceQueue(selection);
  }

  addOrUpdateLyric(selector, lyric) {
    this.actionBuffer.addAction('addOrUpdateLyric', selector, lyric);
    const selection = SmoSelection.noteFromSelector(this.score, selector);
    this._undoSelection('update lyric', selection);
    selection.note.addLyric(lyric);
    const equiv = this._getEquivalentSelection(selection);
    equiv.note.addLyric(SmoNoteModifierBase.deserialize(lyric.serialize()));
    this.renderer.addToReplaceQueue(selection);
  }

  depopulateVoice() {
    this.actionBuffer.addAction('depopulateVoice');
    const measureSelections = this._undoTrackerMeasureSelections('depopulate voice');
    measureSelections.forEach((selection) => {
      const ix = selection.measure.getActiveVoice();
      if (ix !== 0) {
        SmoOperation.depopulateVoice(selection, ix);
        SmoOperation.depopulateVoice(this._getEquivalentSelection(selection), ix);
      }
    });
    SmoOperation.setActiveVoice(this.score, 0);
    this._renderChangedMeasures(measureSelections);
  }
  _changeActiveVoice(index) {
    const measuresToAdd = [];
    const measureSelections = SmoSelection.getMeasureList(this.tracker.selections);
    measureSelections.forEach((measureSelection) => {
      if (index === measureSelection.measure.voices.length) {
        measuresToAdd.push(measureSelection);
      }
    });
    return measuresToAdd;
  }
  populateVoice(index) {
    const measuresToAdd = this._changeActiveVoice(index);
    if (measuresToAdd.length === 0) {
      SmoOperation.setActiveVoice(this.score, index);
      this.tracker.selectActiveVoice();
      return;
    }
    this.actionBuffer.addAction('populateVoice', index);
    measuresToAdd.forEach((selection) => {
      this._undoSelection('popualteVoice', selection);
      SmoOperation.populateVoice(selection, index);
      SmoOperation.populateVoice(this._getEquivalentSelection(selection), index);
    });
    SmoOperation.setActiveVoice(this.score, index);
    this._renderChangedMeasures(measuresToAdd);
  }
  changeInstrument(instrument) {
    this.actionBuffer.addAction('changeInstrument', instrument);
    const measureSelections = this._undoTrackerMeasureSelections('change instrument');
    const selections = this.tracker.selections;
    const altSelections = this._getEquivalentSelections(selections);
    SmoOperation.changeInstrument(instrument, selections);
    SmoOperation.changeInstrument(instrument, altSelections);
    this._renderChangedMeasures(measureSelections);
  }
  setTimeSignature(timeSignature) {
    this.actionBuffer.addAction('setTimeSignature', timeSignature);
    this._undoScore('Set time signature');
    const selections = this.tracker.selections;
    const altSelections = this._getEquivalentSelections(selections);
    SmoOperation.setTimeSignature(this.score, selections, timeSignature);
    SmoOperation.setTimeSignature(this.storeScore, altSelections, timeSignature);
    this._renderChangedMeasures(SmoSelection.getMeasureList(this.tracker.selections));
  }
  moveStaffUpDown(index) {
    this.actionBuffer.addAction('moveStaffUpDown', index);
    this._undoScore('re-order staves');
    // Get staff to move
    const selection = this._getEquivalentSelection(this.tracker.selections[0]);
    // Make the move in the model, and reset the view so we can see the new
    // arrangement
    SmoOperation.moveStaffUpDown(this.storeScore, selection, index);
    const newScore = SmoScore.deserialize(JSON.stringify(this.storeScore.serialize()));
    this.viewAll(newScore);
  }
  addOrUpdateStaffGroup(staffGroup) {
    this.actionBuffer.addAction('addOrUpdateStaffGroup', staffGroup);
    this._undoScore('group staves');
    // Assume that the view is now set to full score
    this.score.addOrReplaceSystemGroup(staffGroup);
    this.storeScore.addOrReplaceSystemGroup(staffGroup);
    this.renderer.setDirty();
  }
  addStaffGroupDown(braceType) {
    this.actionBuffer.addAction('addStaffGroupDown', braceType);
    this._undoScore('group staves');
    const ft = this._getEquivalentSelection(this.tracker.getExtremeSelection(-1));
    const tt = this._getEquivalentSelection(this.tracker.getExtremeSelection(1));
    const selections = this._getEquivalentSelections(this.tracker.selections);
    SmoOperation.addConnectorDown(this.storeScore, selections, {
      startSelector: ft.selector, endSelector: tt.selector,
      mapType: SmoSystemGroup.mapTypes.allMeasures, leftConnector: braceType,
      rightConnector: SmoSystemGroup.connectorTypes.single
    });
    const newScore = SmoScore.deserialize(JSON.stringify(this.storeScore.serialize()));
    this.viewAll(newScore);
  }
  // ### updateTempoScore
  // Update the tempo for the entire score
  updateTempoScore(tempo, scoreMode) {
    let measureIndex = 0;
    let startSelection = this.tracker.selections[0];
    this._undoScore('update score tempo');
    this.actionBuffer.addAction('updateTempoScore', tempo, scoreMode);
    if (!scoreMode) {
      startSelection = this.tracker.getExtremeSelection(-1);
    }
    const measureCount = this.score.staves[0].measures.length;
    let endSelection = SmoSelection.measureSelection(this.score,
      startSelection.selector.staff, measureCount - 1);
    if (!scoreMode) {
      endSelection = this.tracker.getExtremeSelection(1);
    }
    measureIndex = startSelection.selector.measure;
    while (measureIndex <= endSelection.selector.measure) {
      const mi = measureIndex;
      this.score.staves.forEach((staff) => {
        SmoOperation.addTempo(this.score,
          SmoSelection.measureSelection(this.score,
            staff.staffId, mi), tempo);
      });
      measureIndex++;
    }
    measureIndex = startSelection.selector.measure;
    while (measureIndex <= endSelection.selector.measure) {
      const mi = measureIndex;
      this.storeScore.staves.forEach((staff) => {
        SmoOperation.addTempo(this.storeScore,
          SmoSelection.measureSelection(this.storeScore,
            staff.staffId, mi), tempo);
      });
      measureIndex++;
    }
    this.renderer.setRefresh();
  }
  removeTempo(scoreMode) {
    this.actionBuffer.addAction('removeTempo', scoreMode);
    const startSelection = this.tracker.selections[0];
    if (startSelection.selector.measure > 0) {
      const measureIx = startSelection.selector.measure - 1;
      const target = startSelection.staff.measures[measureIx];
      const tempo = target.getTempo();
      this.updateTempoScore(tempo, scoreMode);
    } else {
      this.updateTempoScore(new SmoTempoText(), scoreMode);
    }
  }
  addGraceNote() {
    this.actionBuffer.addAction('addGraceNote');
    const selections = this.tracker.selections;
    const measureSelections = this._undoTrackerMeasureSelections('add grace note');
    selections.forEach((selection) => {
      const index = selection.note.getGraceNotes().length;
      const pitches = JSON.parse(JSON.stringify(selection.note.pitches));
      const grace = new SmoGraceNote({ pitches, ticks:
        { numerator: 2048, denominator: 1, remainder: 0 } });
      SmoOperation.addGraceNote(selection, grace, index);

      const altPitches = JSON.parse(JSON.stringify(selection.note.pitches));
      const altGrace =  new SmoGraceNote({ pitches: altPitches, ticks:
        { numerator: 2048, denominator: 1, remainder: 0 } });
      altGrace.attrs.id = grace.attrs.id;
      const altSelection = this._getEquivalentSelection(selection);
      SmoOperation.addGraceNote(altSelection, altGrace, index);
    });
    this._renderChangedMeasures(measureSelections);
  }

  removeGraceNote() {
    this.actionBuffer.addAction('removeGraceNote');
    const selections = this.tracker.selections;
    const measureSelections = this._undoTrackerMeasureSelections('remove grace note');
    selections.forEach((selection) => {
      // TODO: get the correct offset
      SmoOperation.removeGraceNote(selection, 0);
      SmoOperation.removeGraceNote(this._getEquivalentSelection(selection), 0);
    });
    this._renderChangedMeasures(measureSelections);
  }

  slashGraceNotes() {
    this.actionBuffer.addAction('slashGraceNotes');
    const grace = this.tracker.getSelectedGraceNotes();
    const measureSelections = this._undoTrackerMeasureSelections('slash grace note toggle');
    grace.forEach((gn) => {
      SmoOperation.slashGraceNotes(gn);
      const altSelection = this._getEquivalentSelection(gn.selection);
      const altGn = this._getEquivalentGraceNote(altSelection, gn.modifier);
      SmoOperation.slashGraceNotes({ selection: altSelection, modifier: altGn });
    });
    this._renderChangedMeasures(measureSelections);
  }

  // ### transposeSelections
  // tranpose whatever is selected in tracker the given offset.
  transposeSelections(offset) {
    this.actionBuffer.addAction('transposeSelections', offset);
    const selections = this.tracker.selections;
    const measureSelections = this._undoTrackerMeasureSelections('transpose');
    const grace = this.tracker.getSelectedGraceNotes();
    if (grace.length) {
      grace.forEach((artifact) => {
        const altSelection = this._getEquivalentSelection(artifact.selection);
        SmoOperation.transposeGraceNotes(artifact.selection, artifact.modifier, offset);
        SmoOperation.transposeGraceNotes(altSelection,
          this._getEquivalentGraceNote(altSelection, artifact.modifier), offset);
      });
    } else {
      selections.forEach((selected) => {
        SmoOperation.transpose(selected, offset);
        SmoOperation.transpose(this._getEquivalentSelection(selected), offset);
      });
      if (selections.length === 1 && this.score.preferences.autoPlay) {
        suiOscillator.playSelectionNow(selections[0]);
      }
    }
    this._renderChangedMeasures(measureSelections);
  }
  toggleEnharmonic() {
    this.actionBuffer.addAction('toggleEnharmonic');
    const selections = this.tracker.selections;
    const measureSelections = this._undoTrackerMeasureSelections('toggle enharmonic');
    const grace = this.tracker.getSelectedGraceNotes();
    if (grace.length) {
      grace.forEach((artifact) => {
        SmoOperation.toggleGraceNoteEnharmonic(artifact.selection, artifact.modifier);
        const altSelection = this._getEquivalentSelection(artifact.selection);
        SmoOperation.toggleGraceNoteEnharmonic(this._getEquivalentSelection(artifact.selection),
          this._getEquivalentGraceNote(altSelection, artifact.modifier));
      });
    } else {
      selections.forEach((selected) => {
        if (typeof(selected.selector.pitches) === 'undefined') {
          selected.selector.pitches = [];
        }
        SmoOperation.toggleEnharmonic(selected);
        SmoOperation.toggleEnharmonic(this._getEquivalentSelection(selected));
      });
    }
    this._renderChangedMeasures(measureSelections);
  }

  toggleCourtesyAccidentals() {
    this.actionBuffer.addAction('toggleCourtesyAccidentals');
    const selections = this.tracker.selections;
    const measureSelections = this._undoTrackerMeasureSelections('toggle courtesy accidental');
    const grace = this.tracker.getSelectedGraceNotes();
    if (grace.length) {
      grace.forEach((artifact) => {
        SmoOperation.toggleGraceNoteCourtesy(artifact.selection, artifact.modifier);
        SmoUndoable.toggleGraceNoteCourtesyAccidental(
          this._getEquivalentSelection(artifact.selection), artifact.modifier);
      });
    } else {
      selections.forEach((selection) => {
        SmoOperation.toggleCourtesyAccidental(selection);
        SmoOperation.toggleCourtesyAccidental(this._getEquivalentSelection(selection));
      });
    }
    this._renderChangedMeasures(measureSelections);
  }

  batchDurationOperation(operation) {
    this.actionBuffer.addAction('batchDurationOperation', operation);
    const selections = this.tracker.selections;
    const measureSelections = this._undoTrackerMeasureSelections('change duration');
    const grace = this.tracker.getSelectedGraceNotes();
    const graceMap = { doubleDuration: 'doubleGraceNoteDuration',
      halveDuration: 'halveGraceNoteDuration' };
    if (grace.length && typeof(graceMap[operation]) !== 'undefined') {
      operation = graceMap[operation];
      grace.forEach((artifact) => {
        SmoOperation[operation](artifact.selection, artifact.modifier);
        const altSelection = this._getEquivalentSelection(artifact.selection);
        SmoOperation[operation](this._getEquivalentSelection(artifact.selection),
          this._getEquivalentGraceNote(altSelection, artifact.modifier));
      });
    } else {
      const altAr = this._getEquivalentSelections(selections);
      SmoOperation.batchSelectionOperation(this.score, selections, operation);
      SmoOperation.batchSelectionOperation(this.storeScore, altAr, operation);
    }
    this._renderChangedMeasures(measureSelections);
  }
  toggleArticulation(articulation, ctor) {
    this.actionBuffer.addAction('toggleArticulation', articulation, ctor);
    const measureSelections = this._undoTrackerMeasureSelections('toggle articulation');
    this.tracker.selections.forEach((sel) => {
      if (ctor === 'SmoArticulation') {
        const aa = new SmoArticulation({ articulation });
        const altAa = new SmoArticulation({ articulation });
        altAa.attrs.id = aa.attrs.id;
        SmoOperation.toggleArticulation(sel, aa);
        SmoOperation.toggleArticulation(this._getEquivalentSelection(sel), altAa);
      } else {
        const aa = new SmoOrnament({ ornament: articulation });
        const altAa = new SmoOrnament({ ornament: articulation });
        altAa.attrs.id = aa.attrs.id;
        SmoOperation.toggleOrnament(sel,  aa);
        SmoOperation.toggleOrnament(this._getEquivalentSelection(sel), altAa);
      }
    });
    this._renderChangedMeasures(measureSelections);
  }

  makeTuplet(numNotes) {
    this.actionBuffer.addAction('makeTuplet', numNotes);
    const selection = this.tracker.selections[0];
    const measureSelections = this._undoTrackerMeasureSelections('make tuplet');
    SmoOperation.makeTuplet(selection, numNotes);
    SmoOperation.makeTuplet(this._getEquivalentSelection(selection), numNotes);
    this._renderChangedMeasures(measureSelections);
  }
  unmakeTuplet() {
    this.actionBuffer.addAction('unmakeTuplet');
    const selection = this.tracker.selections[0];
    const measureSelections = this._undoTrackerMeasureSelections('unmake tuplet');
    SmoOperation.unmakeTuplet(selection);
    SmoOperation.unmakeTuplet(this._getEquivalentSelection(selection));
    this._renderChangedMeasures(measureSelections);
  }

  setInterval(interval) {
    this.actionBuffer.addAction('setInterval', interval);
    const selections = this.tracker.selections;
    const measureSelections = this._undoTrackerMeasureSelections('set interval');
    selections.forEach((selected) => {
      SmoOperation.interval(selected, interval);
      SmoOperation.interval(this._getEquivalentSelection(selected), interval);
    });
    this._renderChangedMeasures(measureSelections);
  }

  collapseChord() {
    this.actionBuffer.addAction('collapseChord');
    const selections = this.tracker.selections;
    const measureSelections = this._undoTrackerMeasureSelections('collapse chord');
    selections.forEach((selected) => {
      const pp = JSON.parse(JSON.stringify(selected.note.pitches[0]));
      const altpp = JSON.parse(JSON.stringify(selected.note.pitches[0]));
      // No operation for this?
      selected.note.pitches = [pp];
      const altSelection = this._getEquivalentSelection(selected);
      altSelection.note.pitches = [altpp];
    });
    this._renderChangedMeasures(measureSelections);
  }

  makeRest() {
    this.actionBuffer.addAction('makeRest');
    const selections = this.tracker.selections;
    const measureSelections = this._undoTrackerMeasureSelections('make rest');
    selections.forEach((selection) => {
      SmoOperation.toggleRest(selection);
      const altSel = this._getEquivalentSelection(selection);
      SmoOperation.toggleRest(altSel);
    });
    this._renderChangedMeasures(measureSelections);
  }
  toggleBeamGroup() {
    this.actionBuffer.addAction('toggleBeamGroup');
    const selections = this.tracker.selections;
    const measureSelections = this._undoTrackerMeasureSelections('toggle beam group');
    selections.forEach((selection) => {
      SmoOperation.toggleBeamGroup(selection);
      SmoOperation.toggleBeamGroup(this._getEquivalentSelection(selection));
    });
    this._renderChangedMeasures(measureSelections);
  }
  toggleBeamDirection() {
    this.actionBuffer.addAction('toggleBeamDirection');
    const selections = this.tracker.selections;
    if (selections.length < 1) {
      return;
    }
    const measureSelections = this._undoTrackerMeasureSelections('toggle beam direction');
    SmoOperation.toggleBeamDirection(selections);
    SmoOperation.toggleBeamDirection(this._getEquivalentSelections(selections));
    this._renderChangedMeasures(measureSelections);
  }
  beamSelections() {
    this.actionBuffer.addAction('beamSelections');
    const selections = this.tracker.selections;
    const measureSelections = this._undoTrackerMeasureSelections('beam selections');
    SmoOperation.beamSelections(this.score, selections);
    SmoOperation.beamSelections(this.storeScore, this._getEquivalentSelections(selections));
    this._renderChangedMeasures(measureSelections);
  }
  addKeySignature(keySignature) {
    this.actionBuffer.addAction('addKeySignature', keySignature);
    const measureSelections = this._undoTrackerMeasureSelections('set key signature ' + keySignature);
    measureSelections.forEach((sel) => {
      SmoOperation.addKeySignature(this.score, sel, keySignature);
      SmoOperation.addKeySignature(this.storeScore, this._getEquivalentSelection(sel), keySignature);
    });
    this._renderChangedMeasures(measureSelections);
  }
  setPitchPiano(pitch, chordPedal) {
    this.actionBuffer.addAction('setAbsolutePitch', pitch);
    const measureSelections = this._undoTrackerMeasureSelections(
      'setAbsolutePitch ' + pitch.letter + '/' + pitch.accidental);
    this.tracker.selections.forEach((selected) => {
      const npitch = { letter: pitch.letter,
        accidental: pitch.accidental, octave: pitch.octave };
      const octave = SmoMeasure.defaultPitchForClef[selected.measure.clef].octave;
      npitch.octave += octave;
      const altSel = this._getEquivalentSelection(selected);
      if (chordPedal) {
        selected.note.toggleAddPitch(npitch);
        altSel.note.toggleAddPitch(npitch);
      } else {
        SmoOperation.setPitch(selected, npitch);
        SmoOperation.setPitch(altSel, npitch);
      }
    });
    this._renderChangedMeasures(measureSelections);
  }

  setPitch(letter) {
    this.actionBuffer.addAction('setPitch', letter);
    const selections = this.tracker.selections;
    const measureSelections = this._undoTrackerMeasureSelections('set pitch ' + letter);
    selections.forEach((selected) => {
      const selector = selected.selector;
      let hintSel = SmoSelection.lastNoteSelection(this.score,
        selector.staff, selector.measure, selector.voice, selector.tick);
      if (!hintSel) {
        hintSel = SmoSelection.nextNoteSelection(this.score,
          selector.staff, selector.measure, selector.voice, selector.tick);
      }
      // The selection no longer exists, possibly deleted
      if (!hintSel) {
        return;
      }
      const pitch = smoMusic.getLetterNotePitch(hintSel.note.pitches[0],
        letter, hintSel.measure.keySignature);
      SmoOperation.setPitch(selected, pitch);
      SmoOperation.setPitch(this._getEquivalentSelection(selected), pitch);
      if (this.score.preferences.autoAdvance) {
        this.tracker.moveSelectionRight(null, true);
      }
    });
    if (selections.length === 1 && this.score.preferences.autoPlay) {
      suiOscillator.playSelectionNow(selections[0]);
    }
    this._renderChangedMeasures(measureSelections);
  }
  copy() {
    this.actionBuffer.addAction('copy');
    this.pasteBuffer.setSelections(this.score, this.tracker.selections);
    const altAr = [];
    this.tracker.selections.forEach((sel) => {
      const noteSelection = this._getEquivalentSelection(sel);
      altAr.push(noteSelection);
    });
    this.storePaste.setSelections(this.storeScore, altAr);
  }
  paste() {
    // We undo the whole score on a paste, since we don't yet know the
    // extent of the overlap
    this.actionBuffer.addAction('paste');
    this._undoScore('paste');
    this.preserveScroll();
    const firstSelection = this.tracker.selections[0];
    const pasteTarget = firstSelection.selector;
    const altSelection = this._getEquivalentSelection(firstSelection);
    const altTarget = altSelection.selector;
    this.pasteBuffer.pasteSelections(this.score, pasteTarget);
    this.storePaste.pasteSelections(this.storeScore, altTarget);
    this._renderChangedMeasures(this.pasteBuffer.replacementMeasures);
  }
  setNoteHead(head) {
    this.actionBuffer.addAction('setNoteHead', head);
    const selections = this.tracker.selections;
    const measureSelections = this._undoTrackerMeasureSelections('set note head');
    SmoOperation.setNoteHead(selections, head);
    SmoOperation.setNoteHead(this._getEquivalentSelections(selections), head);
    this._renderChangedMeasures(measureSelections);
  }

  setAutoJustify(value) {
    this.actionBuffer.addAction('setAutoJustify', value);
    const selection = this.tracker.selections[0];
    const altSelection = this._getEquivalentSelection(selection);
    const rect = this._getRectangleFromStaffGroup(selection, this.staffMap);
    const altRect = this._getRectangleFromStaffGroup(altSelection, this.defaultStaffMap);
    this._undoRectangle('Set measure proportion', rect.startSelector, rect.endSelector, this.score, this.undoBuffer);
    this._undoRectangle('Set measure proportion', altRect.startSelector, altRect.endSelector, this.storeScore, this.storeUndo);
    const rs = this._getRectangleSelections(rect.startSelector, rect.endSelector, this.score);
    const altRs = this._getRectangleSelections(altRect.startSelector, altRect.endSelector, this.storeScore);
    rs.forEach((s) => {
      this.renderer.addToReplaceQueue(s);
      SmoOperation.setAutoJustify(this.score, s, value);
    });
    altRs.forEach((s) => {
      SmoOperation.setAutoJustify(this.storeScore, s, value);
    });
  }
  // ### padMeasure
  // spacing to the left, and column means all measures in system.
  padMeasure(spacing, column) {
    let selection = this.tracker.selections[0];
    this.actionBuffer.addAction('padMeasure', spacing, column);
    if (column) {
      this._undoColumn('set measure padding', selection.selector.measure);
      this.storeScore.staves.forEach((staff) => {
        const altSel = SmoSelection.measureSelection(this.storeScore, staff.staffId, selection.selector.measure);
        const viewSel = this._reverseMapSelection(altSel);
        SmoOperation.padMeasureLeft(altSel, spacing);
        if (viewSel) {
          SmoOperation.padMeasureLeft(viewSel, spacing);
          this.renderer.addToReplaceQueue(viewSel);
        }
      });
    } else {
      selection = this._undoFirstMeasureSelection('add dynamic');
      const altSel = this._getEquivalentSelection(selection);
      SmoOperation.padMeasureLeft(selection, spacing);
      SmoOperation.padMeasureLeft(altSel, spacing);
    }
  }

  addEnding() {
    // TODO: we should have undo for columns
    this._undoScore('Add Volta');
    this.actionBuffer.addAction('addEnding');
    const ft = this.tracker.getExtremeSelection(-1);
    const tt = this.tracker.getExtremeSelection(1);
    const volta = new SmoVolta({ startBar: ft.selector.measure, endBar: tt.selector.measure, number: 1 });
    const altVolta = new SmoVolta({ startBar: ft.selector.measure, endBar: tt.selector.measure, number: 1 });
    SmoOperation.addEnding(this.storeScore, altVolta);
    SmoOperation.addEnding(this.score, volta);
    this.renderer.setRefresh();
  }
  updateEnding(ending) {
    this.actionBuffer.addAction('updateEnding', ending);
    this._undoScore('Change Volta');
    $(this.renderer.context.svg).find('g.' + ending.attrs.id).remove();
    SmoOperation.removeEnding(this.storeScore, ending);
    SmoOperation.removeEnding(this.score, ending);
    const altVolta = new SmoVolta(ending);
    SmoOperation.addEnding(this.storeScore, altVolta);
    SmoOperation.addEnding(this.score, ending);
    this.renderer.setRefresh();
  }
  removeEnding(ending) {
    this.actionBuffer.addAction('removeEnding', ending);
    this._undoScore('Remove Volta');
    $(this.renderer.context.svg).find('g.' + ending.attrs.id).remove();
    SmoOperation.removeEnding(this.storeScore, ending);
    SmoOperation.removeEnding(this.score, ending);
    this.renderer.setRefresh();
  }
  setBarline(position, barline) {
    this.actionBuffer.addAction('setBarline', position, barline);
    const obj = new SmoBarline({ position, barline });
    const altObj = new SmoBarline({ position, barline });
    const selection = this.tracker.selections[0];
    this._undoColumn('set barline', selection.selector.measure);
    SmoOperation.setMeasureBarline(this.score, selection, obj);
    SmoOperation.setMeasureBarline(this.storeScore, this._getEquivalentSelection(selection), altObj);
    this._renderChangedMeasures([selection]);
  }
  setRepeatSymbol(position, symbol) {
    this.actionBuffer.addAction('setRepeatSymbol', position, symbol);
    const obj = new SmoRepeatSymbol({ position, symbol });
    const altObj = new SmoRepeatSymbol({ position, symbol });
    const selection = this.tracker.selections[0];
    this._undoColumn('set repeat symbol', selection.selector.measure);
    SmoOperation.setRepeatSymbol(this.score, selection, obj);
    SmoOperation.setRepeatSymbol(this.storeScore, this._getEquivalentSelection(selection), altObj);
    this._renderChangedMeasures(selection);
  }
  toggleRehearsalMark() {
    this.actionBuffer.addAction('toggleRehearsalMark');
    const selection = this.tracker.getExtremeSelection(-1);
    const altSelection = this._getEquivalentSelection(selection);
    const cmd = selection.measure.getRehearsalMark() ? 'removeRehearsalMark' : 'addRehearsalMark';
    SmoOperation[cmd](this.score, selection, new SmoRehearsalMark());
    SmoOperation[cmd](this.storeScore, altSelection, new SmoRehearsalMark());
    this._renderChangedMeasures(selection);
  }
  _removeStaffModifier(modifier) {
    this.score.staves[modifier.startSelector.staff].removeStaffModifier(modifier);
    const altModifier = StaffModifierBase.deserialize(modifier.serialize());
    altModifier.startSelector = this._getEquivalentSelector(altModifier.startSelector);
    altModifier.endSelector = this._getEquivalentSelector(altModifier.endSelector);
    this.storeScore.staves[altModifier.startSelector.staff].removeStaffModifier(altModifier);
  }
  removeStaffModifier(modifier) {
    this.actionBuffer.addAction('removeStaffModifier', modifier);
    this._undoStaffModifier('Set measure proportion', modifier,
      UndoBuffer.bufferSubtypes.REMOVE);
    this._removeStaffModifier(modifier);
    this._removeStandardModifier(modifier);
    this._renderRectangle(modifier.startSelector, modifier.endSelector);
  }
  addOrUpdateStaffModifier(original, modifier) {
    if (!modifier) {
      if (original) {
        // Handle legacy API changed
        modifier = StaffModifierBase.deserialize(original);
      } else {
        console.warn('update modifier: bad modifier');
        return;
      }
    }
    this.actionBuffer.addAction('addOrUpdateStaffModifier', modifier);
    const existing = this.score.staves[modifier.startSelector.staff]
      .getModifier(modifier);
    const subtype = existing === null ? UndoBuffer.bufferSubtypes.ADD :
      UndoBuffer.bufferSubtypes.UPDATE;
    this._undoStaffModifier('Set measure proportion', original,
      subtype);
    this._removeStaffModifier(modifier);
    const copy = StaffModifierBase.deserialize(modifier.serialize());
    copy.startSelector = this._getEquivalentSelector(copy.startSelector);
    copy.endSelector = this._getEquivalentSelector(copy.endSelector);
    const sel = SmoSelection.noteFromSelector(this.score, modifier.startSelector);
    const altSel = this._getEquivalentSelection(sel);
    SmoOperation.addStaffModifier(sel, modifier);
    SmoOperation.addStaffModifier(altSel, copy);
    this._renderRectangle(modifier.startSelector, modifier.endSelector);
  }
  _lineOperation(op) {
    // if (this.tracker.selections.length < 2) {
    //   return;
    // }
    const measureSelections = this._undoTrackerMeasureSelections(op);
    const ft = this.tracker.getExtremeSelection(-1);
    const tt = this.tracker.getExtremeSelection(1);
    const ftAlt = this._getEquivalentSelection(ft);
    const ttAlt = this._getEquivalentSelection(tt);
    const modifier = SmoOperation[op](ft, tt);
    SmoOperation[op](ftAlt, ttAlt);
    this._undoStaffModifier('add ' + op, modifier, UndoBuffer.bufferSubtypes.ADD);
    this._renderChangedMeasures(measureSelections);
  }
  crescendo() {
    this.actionBuffer.addAction('crescendo');
    this._lineOperation('crescendo');
  }
  decrescendo() {
    this.actionBuffer.addAction('decrescendo');
    this._lineOperation('decrescendo');
  }
  slur() {
    this.actionBuffer.addAction('slur');
    this._lineOperation('slur');
  }
  tie() {
    this.actionBuffer.addAction('tie');
    this._lineOperation('tie');
  }
  setScoreLayout(layout) {
    const oldLayout = JSON.stringify(this.score.layout);
    const curLayout = JSON.stringify(layout);
    if (oldLayout === curLayout) {
      return;
    }
    this.actionBuffer.addAction('setScoreLayout', layout);
    this.score.setLayout(layout);
    this.storeScore.setLayout(layout);
    this.renderer.rerenderAll();
  }
  setEngravingFontFamily(family) {
    this.actionBuffer.addAction('setEngravingFontFamily', family);
    const engrave = this.score.fonts.find((fn) => fn.purpose === SmoScore.fontPurposes.ENGRAVING);
    const altEngrave = this.storeScore.fonts.find((fn) => fn.purpose === SmoScore.fontPurposes.ENGRAVING);
    engrave.family = family;
    altEngrave.family = family;
    SuiRenderState.setFont(engrave.family);
  }
  setLyricFont(fontInfo) {
    this.actionBuffer.addAction('setLyricFont', fontInfo);
    this._undoScore('Set Lyric Font');
    this.score.setLyricFont(fontInfo);
    this.storeScore.setLyricFont(fontInfo);
    this.renderer.setRefresh();
  }
  setLyricAdjustWidth(value) {
    this.actionBuffer.addAction('setLyricAdjustWidth', value);
    this._undoScore('Set Lyric Adj Width');
    this.score.setLyricAdjustWidth(value);
    this.storeScore.setLyricAdjustWidth(value);
    this.renderer.setRefresh();
  }
  deleteMeasure() {
    this.actionBuffer.addAction('deleteMeasure');
    this._undoScore('Delete Measure');
    if (this.storeScore.staves[0].measures.length < 2) {
      return;
    }
    const selections = SmoSelection.getMeasureList(this.tracker.selections);
    // THe measures get renumbered, so keep the index at 0
    const index = selections[0].selector.measure;
    selections.forEach((selection) => {
      // Unrender the deleted measure
      this.score.staves.forEach((staff) => {
        this.renderer.unrenderMeasure(staff.measures[index]);
        this.renderer.unrenderMeasure(staff.measures[staff.measures.length - 1]);
        // A little hacky - delete the modifiers if they start or end on
        // the measure
        staff.modifiers.forEach((modifier) => {
          if (modifier.startSelector.measure === index || modifier.endSelector.measure === index) {
            $(this.renderer.context.svg).find('g.' + modifier.attrs.id).remove();
          }
        });
      });
      // Remove the SVG artifacts mapped to this measure.
      this.tracker.deleteMeasure(selection);
      this.score.deleteMeasure(index);
      this.storeScore.deleteMeasure(index);
    });
    this.tracker.loadScore();
    this.renderer.setRefresh();
  }
  addMeasures(append, numberToAdd) {
    let pos = 0;
    let ix = 0;
    this.actionBuffer.addAction('addMeasures', append, numberToAdd);
    this._undoScore('Add Measure');
    for (ix = 0; ix < numberToAdd; ++ix) {
      const measure = this.tracker.getFirstMeasureOfSelection();
      const nmeasure = SmoMeasure.getDefaultMeasureWithNotes(measure);
      const altMeasure = SmoMeasure.deserialize(nmeasure.serialize());

      pos = measure.measureNumber.measureIndex;
      if (append) {
        pos += 1;
      }
      nmeasure.measureNumber.measureIndex = pos;
      nmeasure.setActiveVoice(0);
      this.score.addMeasure(pos, nmeasure);
      this.storeScore.addMeasure(pos, altMeasure);
    }
    this.renderer.setRefresh();
  }
  addMeasure(append) {
    this.actionBuffer.addAction('addMeasure', append);
    this._undoScore('Add Measure');
    let pos = 0;
    const measure = this.tracker.getFirstMeasureOfSelection();
    const nmeasure = SmoMeasure.getDefaultMeasureWithNotes(measure);
    const altMeasure = SmoMeasure.deserialize(nmeasure.serialize());

    pos = measure.measureNumber.measureIndex;
    if (append) {
      pos += 1;
    }
    nmeasure.measureNumber.measureIndex = pos;
    nmeasure.setActiveVoice(0);
    this.score.addMeasure(pos, nmeasure);
    this.storeScore.addMeasure(pos, altMeasure);
    this.renderer.clearLine(measure);
    this.renderer.setRefresh();
  }
  removeStaff() {
    this.actionBuffer.addAction('removeStaff');
    this._undoScore('Remove Instrument');
    if (this.storeScore.staves.length < 2 || this.score.staves.length < 2) {
      return;
    }
    // if we are looking at a subset of the score,
    // revert to the full score view before removing the staff.
    const sel = this.tracker.selections[0];
    const scoreSel = this._getEquivalentSelection(sel);
    const staffIndex = scoreSel.selector.staff;
    SmoOperation.removeStaff(this.storeScore, staffIndex);
    this.viewAll();
    this.renderer.setRefresh();
  }
  addStaff(instrument) {
    this.actionBuffer.addAction('addStaff', instrument);
    this._undoScore('Add Instrument');
    // if we are looking at a subset of the score, we won't see the new staff.  So
    // revert to the full view
    SmoOperation.addStaff(this.storeScore, instrument);
    this.viewAll();
  }
  saveScore(filename) {
    const json = this.storeScore.serialize();
    const jsonText = JSON.stringify(json);
    htmlHelpers.addFileLink(filename, jsonText, $('.saveLink'));
    $('.saveLink a')[0].click();
  }
  saveXml(filename) {
    const dom = SmoToXml.convert(this.storeScore);
    const ser = new XMLSerializer();
    const xmlText = ser.serializeToString(dom);
    htmlHelpers.addFileLink(filename, xmlText, $('.saveLink'));
    $('.saveLink a')[0].click();
  }
  saveActions(filename) {
    const jsonText = JSON.stringify(this.actionBuffer.actions);
    htmlHelpers.addFileLink(filename, jsonText, $('.saveLink'));
    $('.saveLink a')[0].click();
  }
  quickSave() {
    const scoreStr = JSON.stringify(this.storeScore.serialize());
    localStorage.setItem(smoSerialize.localScore, scoreStr);
  }
  createPickup(duration) {
    const sel = this.tracker.selections[0];
    const measureIndex = sel.selector.measure;
    this._undoColumn('create pickup', measureIndex);
    this.actionBuffer.addAction('createPickup', duration);
    this.score.convertToPickupMeasure(sel.selector.measure, duration);
    this.storeScore.convertToPickupMeasure(sel.selector.measure, duration);
    this.renderer.setRefresh();
  }
  _columnAction(label, value, method) {
    this.actionBuffer.addAction(label, value);
    const fromSelector = this.tracker.getExtremeSelection(-1).selector;
    const toSelector = this.tracker.getExtremeSelection(1).selector;
    const measureSelections = this.tracker.getSelectedMeasures();
    measureSelections.forEach((m) => {
      this._undoColumn(label + value.toString(), m.selector.measure);
      SmoOperation[method](this.score, m, value);
      const alt = this._getEquivalentSelection(m);
      SmoOperation[method](this.storeScore, alt, value);
    });
    this._renderRectangle(fromSelector, toSelector);
  }
  setCollisionAvoidance(value) {
    this._columnAction('Collision avoidance', value, 'setFormattingIterations');
  }

  // ### stretchWidth
  // Stretch the width of a measure, including all columns in the measure since they are all
  // the same width
  setMeasureStretch(stretch) {
    this._columnAction('Stretch Measure', stretch, 'setMeasureStretch');
  }
  forceSystemBreak(value) {
    this._columnAction('forceSystemBreak', value, 'setForceSystemBreak');
  }
  // For these rectangle ones, treat view score and store score differently
  // b/c the rectangles may be different
  setMeasureProportion(value) {
    this._columnAction('Measure proportion', value, 'setMeasureProportion');
  }

  replayActions() {
    if (!this.actionBuffer.endCondition) {
      return;
    }
    const prefs = JSON.parse(JSON.stringify(this.score.preferences));
    this.storeScore.preferences.autoPlay = false;
    this.storeScore.preferences.autoAdvance = false;
    this.score.preferences = JSON.parse(JSON.stringify(this.storeScore.preferences));
    const oldPollTime = SmoConfig.demonPollTime;
    const oldRedrawTime = SmoConfig.idleRedrawTime;
    const recover = () => {
      this.score.preferences = prefs;
      this.storeScore.preferences = JSON.parse(JSON.stringify(prefs));
      SmoConfig.demonPollTime = oldPollTime;
      SmoConfig.idleRedrawTime = oldRedrawTime;
    };
    SmoConfig.demonPollTime = 50;
    SmoConfig.idleRedrawTime = 3000;
    const playback = new SuiActionPlayback(this.actionBuffer, this);
    playback.start().then(recover);
  }

  // Tracker operations, used for macro replay
  moveHome(ev) {
    this.tracker.moveHome(ev);
  }
  moveEnd(ev) {
    this.tracker.moveEnd(ev);
  }
  growSelectionLeft() {
    this.tracker.growSelectionLeft();
  }
  growSelectionRight() {
    this.tracker.growSelectionRight();
  }
  advanceModifierSelection(keyEv) {
    this.tracker.advanceModifierSelection(keyEv);
  }
  growSelectionRightMeasure() {
    this.tracker.growSelectionRightMeasure();
  }
  moveSelectionRight(ev) {
    this.tracker.moveSelectionRight(ev);
  }
  moveSelectionLeft() {
    this.tracker.moveSelectionLeft();
  }
  moveSelectionLeftMeasure() {
    this.tracker.moveSelectionLeftMeasure();
  }
  moveSelectionRightMeasure() {
    this.tracker.moveSelectionRightMeasure();
  }
  moveSelectionPitchUp() {
    this.tracker.moveSelectionPitchUp();
  }
  moveSelectionPitchDown() {
    this.tracker.moveSelectionPitchDown();
  }
  moveSelectionUp() {
    this.tracker.moveSelectionUp();
  }
  moveSelectionDown() {
    this.tracker.moveSelectionDown();
  }
  selectSuggestion(evData) {
    this.tracker.selectSuggestion(evData);
  }
  intersectingArtifact(evData) {
    this.tracker.intersectingArtifact(evData);
  }
  setSelection(selector) {
    view.tracker.selections = [SmoSelection.selectionFromSelector(this.score, selector)];
  }
  selectSuggestionNote(selector, evData) {
    const key = SmoSelector.getNoteKey(selector);
    if (typeof(this.tracker.measureNoteMap[key]) !== 'undefined') {
      this.tracker.suggestion = this.tracker.measureNoteMap[SmoSelector.getNoteKey(selector)];
      this.tracker.selectSuggestion(evData);
    }
  }
  selectSuggestionModifier(selector, evData, modifierObj) {
    let modIndex = -1;
    if (typeof(modifierObj.startSelector) !== 'undefined' && typeof(modifierObj.endSelector) !== 'undefined') {
      modIndex = this.tracker.modifierTabs.findIndex((tb) =>
        modifierObj.ctor === tb.modifier.ctor &&
        SmoSelector.eq(tb.selection.selector, selector) && SmoSelector.eq(tb.modifier.startSelector, modifierObj.startSelector) &&
        SmoSelector.eq(tb.modifier.endSelector, modifierObj.endSelector));
    } else {
      // TODO: grace notes have multiple per note and no selector
      modIndex = this.tracker.modifierTabs.findIndex((tb) =>
        modifierObj.ctor === tb.modifier.ctor &&
          SmoSelector.eq(tb.selection.selector, selector));
    }
    if (modIndex >= 0) {
      this.tracker.modifierSuggestions = [modIndex];
      this.tracker.selectSuggestion(evData);
    }
  }
  refreshViewport() {
    this.preserveScroll();
    this.renderer.setViewport(true);
    this.renderer.setRefresh();
  }
}
;

// ## suiScroller
// Respond to scroll events, and handle the scroll of the viewport
//
//
// ---
class suiScroller  {
  // ### constructor
  // selector is the scrollable DOM container of the music container
  // (grandparent of svg element)
  constructor(selector) {
    this.selector = selector;
    this._scroll = { x: 0, y: 0 };
    this._scrollInitial = { x: 0, y: 0 };
    var scroller = $(selector);
    this._offsetInitial = { x: $(scroller).offset().left, y: $(scroller).offset().top };

    this.viewport = svgHelpers.boxPoints(
      $(selector).offset().left,
      $(selector).offset().top,
      $(selector).width(),
      $(selector).height());
  }

  get scrollState() {
    const initial = JSON.parse(JSON.stringify(this._scrollInitial));
    const scroll = JSON.parse(JSON.stringify(this._scroll));
    return { initial, scroll };
  }
  restoreScrollState(state) {
    this.scrollOffset(state.scroll.x - this._scroll.x, state.scroll.y - this._scroll.y);
  }

  // ### handleScroll
  // update viewport in response to scroll events
  handleScroll(x, y) {
    this._scroll = { x: x, y: y };
    this.viewport = svgHelpers.boxPoints(
      $(this.selector).offset().left,
      $(this.selector).offset().top,
      $(this.selector).width(),
      $(this.selector).height());
  }

  scrollAbsolute(x, y) {
    $(this.selector)[0].scrollLeft = x;
    $(this.selector)[0].scrollTop = y;
    this.netScroll.x = this._scroll.x = x;
    this.netScroll.y = this._scroll.y = y;
  }

  // ### scrollVisible
  // Scroll such that the box is fully visible, if possible (if it is
  // not larger than the screen)
  scrollVisibleBox(box) {
    let xoff = 0;
    let yoff = 0;
    const curBox = this.scrollBox;
    if (box.width > curBox.width || box.height > curBox.height) {
      return;
    }
    if (box.height < curBox.height) {
      if (box.y < curBox.y) {
        yoff = box.y - (curBox.y + 25);
      }
      else if (box.y + box.height > curBox.y + curBox.height) {
        yoff = box.y + box.height - (curBox.y + curBox.height) + 25;
      }
    }

    if (box.x < curBox.width) {
      if (box.x < curBox.x) {
        xoff = box.x - curBox.x;
      } else if (box.x + box.width > curBox.x + curBox.width) {
        xoff = box.x + box.width - (curBox.x + curBox.width);
      }
    }

    if (xoff !== 0 || yoff !== 0) {
        this.scrollOffset(xoff,yoff);
    }
  }

  // ### scrollBox
  // get the current viewport, in scrolled coordinates.  When tracker maps the
  // music element to client coordinates, these are the coordinates used in the
  // map
  get scrollBox() {
    return svgHelpers.boxPoints(this.viewport.x + this.netScroll.x,
     this.viewport.y + this.netScroll.y,
     this.viewport.width,
     this.viewport.height
    );
  }

  get absScroll() {
    var x = $(this.selector).offset().left + $(this.selector)[0].scrollLeft;
    var y = $(this.selector).offset().top + $(this.selector)[0].scrollTop;
    return svgHelpers.boxPoints(x,
      y,
      this.viewport.width,
      this.viewport.height
    );
  }

  // ### scrollOffset
  // scroll the offset from the starting scroll point
  scrollOffset(x, y) {
    const self = this;
    const cur = { x: this._scroll.x, y: this._scroll.y };
    setTimeout(() => {
      if (x) {
        $(this.selector)[0].scrollLeft = cur.x + x;
      }
      if (y) {
        $(this.selector)[0].scrollTop = cur.y + y;
      }
      self.handleScroll( $(this.selector)[0].scrollLeft, $(this.selector)[0].scrollTop);
    }, 1);
  }

  // ### netScroll
  // return the net amount we've scrolled, based on when the maps were make (initial)
  // , the offset of the container, and the absolute coordinates of the scrollbar.
  get netScroll() {
    var xoffset = $(this.selector).offset().left - this._offsetInitial.x;
    var yoffset = $(this.selector).offset().top - this._offsetInitial.y;
    return { x: this._scroll.x - xoffset, y: this._scroll.y - yoffset };
  }

  // ### invScroll
  // invert the scroll parameters.
  get invScroll() {
    var vect = this.netScroll;
    return { x: vect.x * (-1), y: vect.y * (-1)};
  }
}
;// The heirarchy of text editing objects goes:
// dialog -> component -> session -> editor
//
// Editors and Sessions are defined in this module.
// ### editor
//  handles low-level events and renders the preview using one
// of the text layout objects.
//
// ### session
// creates and destroys editors, e.g. for lyrics that have a Different
// editor instance for each note.
//
// ## SuiTextEditor
// Next-gen text editor.  The base text editor handles the positioning and inserting
// of text blocks into the text area.  The derived class shoud interpret key events.
// A container class will manage the session for starting/stopping the editor
// and retrieving the results into the target object.
// eslint-disable-next-line no-unused-vars
class SuiTextEditor {
  static get States() {
    return { RUNNING: 1, STOPPING: 2, STOPPED: 4, PENDING_EDITOR: 8 };
  }
  // parsers use this convention to represent text types (superscript)
  static textTypeToChar(textType) {
    if (textType === SuiInlineText.textTypes.superScript) {
      return '^';
    }
    if (textType === SuiInlineText.textTypes.subScript) {
      return '%';
    }
    return '';
  }

  static textTypeFromChar(char) {
    if (char === '^') {
      return SuiInlineText.textTypes.superScript;
    }
    if (char === '%') {
      return SuiInlineText.textTypes.subScript;
    }
    return SuiInlineText.textTypes.normal;
  }

  static get defaults() {
    return {
      svgText: null,
      context: null,
      x: 0,
      y: 0,
      text: '',
      textPos: 0,
      selectionStart: -1,
      selectionLength: 0,
      empty: true,
      suggestionIndex: -1,
      textType: SuiInlineText.textTypes.normal
    };
  }
  constructor(params) {
    Vex.Merge(this, SuiTextEditor.defaults);
    Vex.Merge(this, params);
    if (typeof(params.scroller) !== 'object') {
      throw 'bad scroller in ctor of SuiTextEditor';
    }
  }

  static get strokes() {
    return {
      'text-suggestion': {
        'stroke': '#cce',
        'stroke-width': 1,
        'stroke-dasharray': '4,1',
        'fill': 'none'
      },
      'text-selection': {
        'stroke': '#99d',
        'stroke-width': 1,
        'fill': 'none'
      }, 'text-highlight': {
        'stroke': '#dd9',
        'stroke-width': 1,
        'stroke-dasharray': '4,1',
        'fill': 'none'
      }, 'text-drag': {
        'stroke': '#d99',
        'stroke-width': 1,
        'stroke-dasharray': '2,1',
        'fill': '#eee',
        'opacity': '0.3'
      }
    };
  }

  // ### _suggestionParameters
  // Create the svg text outline parameters
  _suggestionParameters(box, strokeName) {
    const outlineStroke = SuiTextEditor.strokes[strokeName];
    return {
      context: this.context, box, classes: strokeName,
      outlineStroke, scroller: this.scroller
    };
  }

  // ### _expandSelectionToSuggestion
  // Expand the selection to include the character the user clicked on.
  _expandSelectionToSuggestion() {
    if (this.suggestionIndex < 0) {
      return;
    }
    if (this.selectionStart < 0) {
      this._setSelectionToSugggestion();
      return;
    }  else if (this.selectionStart > this.suggestionIndex) {
      const oldStart = this.selectionStart;
      this.selectionStart = this.suggestionIndex;
      this.selectionLength = (oldStart - this.selectionStart) + this.selectionLength;
    }  else if (this.selectionStart < this.suggestionIndex
        && this.selectionStart > this.selectionStart + this.selectionLength) {
      this.selectionLength = (this.suggestionIndex - this.selectionStart) + 1;
    }
    this._updateSelections();
  }

  // ### _setSelectionToSugggestion
  // Set the selection to the character the user clicked on.
  _setSelectionToSugggestion() {
    this.selectionStart = this.suggestionIndex;
    this.selectionLength = 1;
    this.suggestionIndex = -1;
    this._updateSelections();
  }

  // ### handleMouseEvent
  // Handle hover/click behavior for the text under edit.
  // Returns: true if the event was handled here
  handleMouseEvent(ev) {
    let handled = false;
    var blocks = this.svgText.getIntersectingBlocks({
      x: ev.clientX,
      y: ev.clientY
    }, this.scroller.scrollState);

    // The mouse is not over the text
    if (!blocks.length) {
      svgHelpers.eraseOutline(this.context, 'text-suggestion');

      // If the user clicks and there was a previous selection, treat it as selected
      if (ev.type === 'click' && this.suggestionIndex >= 0) {
        if (ev.shiftKey) {
          this._expandSelectionToSuggestion();
        } else {
          this._setSelectionToSugggestion();
        }
        handled = true;
        this.svgText.render();
      }
      return handled;
    }
    handled = true;
    // outline the text that is hovered.  Since mouse is a point
    // there should only be 1
    blocks.forEach((block) => {
      svgHelpers.outlineRect(this._suggestionParameters(block.box, 'text-suggestion'));
      this.suggestionIndex = block.index;
    });
    // if the user clicked on it, add it to the selection.
    if (ev.type === 'click') {
      svgHelpers.eraseOutline(this.context, 'text-suggestion');
      if (ev.shiftKey) {
        this._expandSelectionToSuggestion();
      } else {
        this._setSelectionToSugggestion();
      }
      const npos = this.selectionStart + this.selectionLength;
      if (npos >= 0 && npos <= this.svgText.blocks.length) {
        this.textPos = npos;
      }
      this.svgText.render();
    }
    return handled;
  }

  // ### _serviceCursor
  // Flash the cursor as a background task
  _serviceCursor() {
    if (this.cursorState) {
      this.svgText.renderCursorAt(this.textPos - 1, this.textType);
    } else {
      this.svgText.removeCursor();
    }
    this.cursorState = !this.cursorState;
  }
  // ### _refreshCursor
  // If the text position changes, update the cursor position right away
  // don't wait for blink.
  _refreshCursor() {
    this.svgText.removeCursor();
    this.cursorState = true;
    this._serviceCursor();
  }

  get _endCursorCondition() {
    return this.cursorRunning === false;
  }

  _cursorPreResolve() {
    this.svgText.removeCursor();
  }

  _cursorPoll() {
    this._serviceCursor();
  }

  // ### startCursorPromise
  // Used by the calling logic to start the cursor.
  // returns a promise that can be pended when the editing ends.
  startCursorPromise() {
    var self = this;
    this.cursorRunning = true;
    this.cursorState = true;
    self.svgText.renderCursorAt(this.textPos);
    return PromiseHelpers.makePromise(this, '_endCursorCondition', '_cursorPreResolve', '_cursorPoll', 333);
  }
  stopCursor() {
    this.cursorRunning = false;
  }

  // ### setTextPos
  // Set the text position within the editor space and update the cursor
  setTextPos(val) {
    this.textPos = val;
    this._refreshCursor();
  }
  // ### moveCursorRight
  // move cursor right within the block of text.
  moveCursorRight() {
    if (this.textPos <= this.svgText.blocks.length) {
      this.setTextPos(this.textPos + 1);
    }
  }
  // ### moveCursorRight
  // move cursor left within the block of text.
  moveCursorLeft() {
    if (this.textPos > 0) {
      this.setTextPos(this.textPos - 1);
    }
  }

  // ### moveCursorRight
  // highlight the text selections
  _updateSelections() {
    let i = 0;
    const end = this.selectionStart + this.selectionLength;
    const start =  this.selectionStart;
    this.svgText.blocks.forEach((block) => {
      const val = start >= 0 && i >= start && i < end;
      this.svgText.setHighlight(block, val);
      ++i;
    });
  }

  // ### _checkGrowSelectionLeft
  // grow selection within the bounds
  _checkGrowSelectionLeft() {
    if (this.selectionStart > 0) {
      this.selectionStart -= 1;
      this.selectionLength += 1;
    }
  }
  // ### _checkGrowSelectionRight
  // grow selection within the bounds
  _checkGrowSelectionRight() {
    const end = this.selectionStart + this.selectionLength;
    if (end < this.svgText.blocks.length) {
      this.selectionLength += 1;
    }
  }

  // ### growSelectionLeft
  // handle the selection keys
  growSelectionLeft() {
    if (this.selectionStart === -1) {
      this.moveCursorLeft();
      this.selectionStart = this.textPos;
      this.selectionLength = 1;
    } else if (this.textPos === this.selectionStart) {
      this.moveCursorLeft();
      this._checkGrowSelectionLeft();
    }
    this._updateSelections();
  }

  // ### growSelectionRight
  // handle the selection keys
  growSelectionRight() {
    if (this.selectionStart === -1) {
      this.selectionStart = this.textPos;
      this.selectionLength = 1;
      this.moveCursorRight();
    } else if (this.selectionStart + this.selectionLength === this.textPos) {
      this._checkGrowSelectionRight();
      this.moveCursorRight();
    }
    this._updateSelections();
  }

  // ### _clearSelections
  // Clear selected text
  _clearSelections() {
    this.selectionStart = -1;
    this.selectionLength = 0;
  }

  // ### deleteSelections
  // delete the selected blocks of text/glyphs
  deleteSelections() {
    let i = 0;
    const blockPos = this.selectionStart;
    for (i = 0; i < this.selectionLength; ++i) {
      this.svgText.removeBlockAt(blockPos); // delete shifts blocks so keep index the same.
    }
    this.setTextPos(blockPos);
    this.selectionStart = -1;
    this.selectionLength = 0;
  }

  // ### parseBlocks
  // THis can be overridden by the base class to create the correct combination
  // of text and glyph blocks based on the underlying text
  parseBlocks() {
    let i = 0;
    this.svgText = new SuiInlineText({ context: this.context, startX: this.x, startY: this.y,
      fontFamily: this.fontFamily, fontSize: this.fontSize, fontWeight: this.fontWeight, scroller: this.scroller });
    for (i = 0; i < this.text.length; ++i) {
      this.svgText.addTextBlockAt(i, { text: this.text[i] });
      this.empty = false;
    }
    this.textPos = this.text.length;
    this.state = SuiTextEditor.States.RUNNING;
    this.svgText.render();
  }
  // ### evKey
  // Handle key events that filter down to the editor
  evKey(evdata) {
    if (evdata.code === 'ArrowRight') {
      if (evdata.shiftKey) {
        this.growSelectionRight();
      } else {
        this.moveCursorRight();
      }
      this.svgText.render();
      return true;
    }
    if (evdata.code === 'ArrowLeft') {
      if (evdata.shiftKey) {
        this.growSelectionLeft();
      } else {
        this.moveCursorLeft();
      }
      this.svgText.render();
      return true;
    }
    if (evdata.code === 'Backspace') {
      if (this.selectionStart >= 0) {
        this.deleteSelections();
      } else {
        if (this.textPos > 0) {
          this.selectionStart = this.textPos - 1;
          this.selectionLength = 1;
          this.deleteSelections();
        }
      }
      this.svgText.render();
      return true;
    }
    if (evdata.code === 'Delete') {
      if (this.selectionStart >= 0) {
        this.deleteSelections();
      } else {
        if (this.textPos > 0 && this.textPos < this.svgText.blocks.length) {
          this.selectionStart = this.textPos;
          this.selectionLength = 1;
          this.deleteSelections();
        }
      }
      this.svgText.render();
      return true;
    }
    if (evdata.key.charCodeAt(0) >= 33 && evdata.key.charCodeAt(0) <= 126  && evdata.key.length === 1) {
      if (this.empty) {
        this.svgText.removeBlockAt(0);
        this.empty = false;
        this.svgText.addTextBlockAt(0, { text: evdata.key });
        this.setTextPos(1);
      } else {
        if (this.selectionStart >= 0) {
          this.deleteSelections();
        }
        this.svgText.addTextBlockAt(this.textPos, { text: evdata.key, textType: this.textType });
        this.setTextPos(this.textPos + 1);
      }
      this.svgText.render();
      return true;
    }
    return false;
  }
}
// eslint-disable-next-line no-unused-vars
class SuiTextBlockEditor extends SuiTextEditor {
  // ### ctor
  // ### args
  // params: {lyric: SmoLyric,...}
  constructor(params) {
    super(params);
    this.parseBlocks();
  }

  _highlightEditor() {
    if (this.svgText.blocks.length === 0) {
      return;
    }
    const bbox = this.svgText.getLogicalBox();
    const outlineStroke = SuiTextEditor.strokes['text-highlight'];
    const obj = {
      context: this.context, box: bbox, classes: 'text-highlight',
      outlineStroke, scroller: this.scroller
    };
    svgHelpers.outlineLogicalRect(obj);
  }

  getText() {
    return this.svgText.getText();
  }

  evKey(evdata) {
    if (evdata.key.charCodeAt(0) === 32) {
      if (this.empty) {
        this.svgText.removeBlockAt(0);
        this.empty = false;
        this.svgText.addTextBlockAt(0, { text: ' ' });
        this.setTextPos(1);
      } else {
        if (this.selectionStart >= 0) {
          this.deleteSelections();
        }
        this.svgText.addTextBlockAt(this.textPos, { text: ' ', textType: this.textType });
        this.setTextPos(this.textPos + 1);
      }
      this.svgText.render();
      return true;
    }
    const rv = super.evKey(evdata);
    this._highlightEditor();
    return rv;
  }

  stopEditor() {
    this.state = SuiTextEditor.States.STOPPING;
    $(this.context.svg).find('g.vf-text-highlight').remove();
    this.stopCursor();
    this.svgText.unrender();
  }
}

// eslint-disable-next-line no-unused-vars
class SuiLyricEditor extends SuiTextEditor {
  static get States() {
    return { RUNNING: 1, STOPPING: 2, STOPPED: 4 };
  }
  parseBlocks() {
    let i = 0;
    this.svgText = new SuiInlineText({ context: this.context, startX: this.x, startY: this.y, scroller: this.scroller });
    for (i = 0; i < this.text.length; ++i) {
      this.svgText.addTextBlockAt(i, { text: this.text[i] });
      this.empty = false;
    }
    this.textPos = this.text.length;
    this.state = SuiTextEditor.States.RUNNING;
    this.svgText.render();
  }

  getText() {
    return this.svgText.getText();
  }

  // ### ctor
  // ### args
  // params: {lyric: SmoLyric,...}
  constructor(params) {
    super(params);
    this.text = params.lyric.getText();
    if (params.lyric.isHyphenated()) {
      this.text += '-';
    }
    this.lyric = params.lyric;
    this.parseBlocks();
  }

  stopEditor() {
    this.state = SuiTextEditor.States.STOPPING;
    this.stopCursor();
    this.svgText.unrender();
  }
}

// eslint-disable-next-line no-unused-vars
class SuiChordEditor extends SuiTextEditor {
  static get States() {
    return { RUNNING: 1, STOPPING: 2, STOPPED: 4 };
  }
  static get SymbolModifiers() {
    return {
      NONE: 1,
      SUBSCRIPT: 2,
      SUPERSCRIPT: 3
    };
  }

  // ### toTextTypeChar
  // Given an old text type and a desited new text type,
  // return what the new text type character should be
  static toTextTypeChar(oldTextType, newTextType) {
    const tt = SuiInlineText.getTextTypeResult(oldTextType, newTextType);
    return SuiTextEditor.textTypeToChar(tt);
  }

  static toTextTypeTransition(oldTextType, result) {
    const tt = SuiInlineText.getTextTypeTransition(oldTextType, result);
    return SuiTextEditor.textTypeToChar(tt);
  }

  setTextType(textType) {
    this.textType = textType;
  }

  // Handle the case where user changed super/subscript in the middle of the
  // string.
  _updateSymbolModifiers() {
    let change = this.textPos;
    let render = false;
    let i = 0;
    for (i = this.textPos; i < this.svgText.blocks.length; ++i) {
      const block = this.svgText.blocks[i];
      if (block.textType !== this.textType &&
        block.textType !== change) {
        change = block.textType;
        block.textType = this.textType;
        render = true;
      } else {
        break;
      }
    }
    if (render) {
      this.svgText.render();
    }
  }
  _setSymbolModifier(char) {
    if (['^', '%'].indexOf(char) < 0) {
      return false;
    }
    const currentTextType = this.textType;
    const transitionType = SuiTextEditor.textTypeFromChar(char);
    this.textType = SuiInlineText.getTextTypeResult(currentTextType, transitionType);
    this._updateSymbolModifiers();
    return true;
  }

  parseBlocks() {
    let readGlyph = false;
    let curGlyph = '';
    let blockIx = 0; // so we skip modifier characters
    let i = 0;
    this.svgText = new SuiInlineText({ context: this.context, startX: this.x, startY: this.y, scroller: this.scroller });

    for (i = 0; i < this.text.length; ++i) {
      const char = this.text[i];
      const isSymbolModifier = this._setSymbolModifier(char);
      if (char === '@') {
        if (!readGlyph) {
          readGlyph = true;
          curGlyph = '';
        } else {
          this._addGlyphAt(blockIx, curGlyph);
          blockIx += 1;
          readGlyph = false;
        }
      } else if (!isSymbolModifier) {
        if (readGlyph) {
          curGlyph = curGlyph + char;
        } else {
          this.svgText.addTextBlockAt(blockIx, { text: char, textType: this.textType });
          blockIx += 1;
        }
      }
      this.empty = false;
    }
    this.textPos = blockIx;
    this.state = SuiTextEditor.States.RUNNING;
    this.svgText.render();
  }

  // ### getText
  // Get the text value that we persist
  getText() {
    if (this.svgText.blocks < 1) {
      return '';
    }
    let text = '';
    let textType = this.svgText.blocks[0].textType;
    this.svgText.blocks.forEach((block) => {
      if (block.textType !== textType) {
        text += SuiChordEditor.toTextTypeTransition(textType, block.textType);
        textType = block.textType;
      }
      if (block.symbolType === SuiInlineText.symbolTypes.GLYPH) {
        text += '@' + block.glyphCode + '@';
      } else {
        text += block.text;
      }
    });
    return text;
  }

  _addGlyphAt(ix, code) {
    if (this.selectionStart >= 0) {
      this.deleteSelections();
    }
    this.svgText.addGlyphBlockAt(ix, { glyphCode: code, textType: this.textType });
    this.textPos += 1;
  }

  evKey(evdata) {
    let edited = false;
    if (this._setSymbolModifier(evdata.key)) {
      return true;
    }
    // Dialog gives us a specific glyph code
    if (evdata.key[0] === '@' && evdata.key.length > 2) {
      const glyph = evdata.key.substr(1, evdata.key.length - 2);
      this._addGlyphAt(this.textPos, glyph);
      this.svgText.render();
      edited  = true;
    } else if (VF.ChordSymbol.glyphs[evdata.key[0]]) { // glyph shortcut like 'b'
      this._addGlyphAt(this.textPos, VF.ChordSymbol.glyphs[evdata.key[0]].code);
      this.svgText.render();
      edited = true;
    } else {
      // some ordinary key
      edited = super.evKey(evdata);
    }
    if (this.svgText.blocks.length > this.textPos && this.textPos >= 0) {
      this.textType = this.svgText.blocks[this.textPos].textType;
    }
    return edited;
  }

  // ### ctor
  // ### args
  // params: {lyric: SmoLyric,...}
  constructor(params) {
    super(params);
    this.text = params.lyric._text;
    this.lyric = params.lyric;
    this.textType = SuiInlineText.textTypes.normal;
    this.parseBlocks();
  }

  stopEditor() {
    this.state = SuiTextEditor.States.STOPPING;
    this.stopCursor();
    this.svgText.unrender();
  }

  // ### _markStopped
  // Indicate this editor session is done running
  _markStopped() {
    this.state = SuiTextEditor.States.STOPPED;
  }
}

// eslint-disable-next-line no-unused-vars
class SuiDragSession {
  constructor(params) {
    this.textGroup = params.textGroup;
    this.context = params.context;
    this.scroller = params.scroller;
    this.xOffset = 0;
    this.yOffset = 0;
    this.textObject = SuiTextBlock.fromTextGroup(this.textGroup, this.context, this.scroller); // SuiTextBlock
    this.dragging = false;
    this.startBox = this.textObject.getLogicalBox();
    this.startBox.y += this.textObject.maxFontHeight(1);
    this.currentBox = svgHelpers.smoBox(this.startBox);
    this.currentClientBox = svgHelpers.logicalToClient(this.context.svg, this.currentBox, this.scroller);
  }

  _outlineBox() {
    const outlineStroke = SuiTextEditor.strokes['text-drag'];
    const obj = {
      context: this.context, box: this.currentBox, classes: 'text-drag',
      outlineStroke, scroller: this.scroller
    };
    svgHelpers.outlineLogicalRect(obj);
  }

  startDrag(e) {
    if (!svgHelpers.containsPoint(this.currentClientBox, { x: e.clientX, y: e.clientY }, this.scroller.scrollState)) {
      return;
    }
    this.dragging = true;
    // calculate offset of mouse start vs. box UL
    this.yOffset = this.currentClientBox.y - e.clientY;
    this.xOffset = this.currentClientBox.x - e.clientX;
    this._outlineBox();
  }

  mouseMove(e) {
    if (!this.dragging) {
      return;
    }
    const svgX = this.currentBox.x;
    const svgY = this.currentBox.y;
    this.currentClientBox.x = e.clientX - this.xOffset;
    this.currentClientBox.y = e.clientY - this.yOffset;
    const coor = svgHelpers.clientToLogical(this.context.svg, { x: this.currentClientBox.x, y: this.currentClientBox.y });
    this.currentBox.x = coor.x;
    this.currentBox.y = coor.y;
    this.textObject.offsetStartX(this.currentBox.x - svgX);
    this.textObject.offsetStartY(this.currentBox.y - svgY);
    this.textObject.render();
    this._outlineBox();
  }
  get deltaX() {
    return this.currentBox.x - this.startBox.x;
  }
  get deltaY() {
    return this.currentBox.y - this.startBox.y;
  }

  endDrag() {
    svgHelpers.eraseOutline(this.context, 'text-drag');
    this.textObject.render();
    this.textGroup.offsetX(this.deltaX);
    this.textGroup.offsetY(this.deltaY);
    this.dragging = false;
  }
}

// ## SuiTextSession
// session for editing plain text
// eslint-disable-next-line no-unused-vars
class SuiTextSession {
  static get States() {
    return { RUNNING: 1, STOPPING: 2, STOPPED: 4, PENDING_EDITOR: 8 };
  }
  constructor(params) {
    this.scroller = params.scroller;
    this.renderer = params.renderer;
    this.scoreText = params.scoreText;
    this.text = params.text ? params.text : '';
    this.x = params.x;
    this.y = params.y;
    this.textGroup = params.textGroup;
    this.scoreText = params.scoreText;

    // Create a text group if one was not a startup parameter
    if (!this.textGroup) {
      this.textGroup = new SmoTextGroup();
    }
    // Create a scoreText if one was not a startup parameter, or
    // get it from the text group
    if (!this.scoreText) {
      if (this.textGroup && this.textGroup.textBlocks.length) {
        this.scoreText = this.textGroup.textBlocks[0].text;
      } else {
        this.scoreText = new SmoScoreText({ x: this.x, y: this.y });
        this.textGroup.addScoreText(this.scoreText, null, SmoTextGroup.relativePositions.RIGHT);
      }
    }
    this.fontFamily = this.scoreText.fontInfo.family;
    this.fontWeight = this.scoreText.fontInfo.weight;
    this.fontSize = SmoScoreText.fontPointSize(this.scoreText.fontInfo.size);
    this.text = this.scoreText.text;
  }

  // ### _isRefreshed
  // renderer has partially rendered text(promise condition)
  get _isRefreshed() {
    return this.renderer.dirty === false;
  }

  get isStopped() {
    return this.state === SuiTextEditor.States.STOPPED;
  }

  get isRunning() {
    return this.state === SuiTextEditor.States.RUNNING;
  }

  _markStopped() {
    this.state = SuiTextEditor.States.STOPPED;
  }

  // ### _isRendered
  // renderer has rendered text(promise condition)
  get _isRendered() {
    return this.renderer.passState ===  SuiRenderState.passStates.clean;
  }

  _removeScoreText() {
    const selector = '#' + this.scoreText.attrs.id;
    $(selector).remove();
  }

  // ### _startSessionForNote
  // Start the lyric session
  startSession() {
    this.editor = new SuiTextBlockEditor({ renderer: this.renderer,
      x: this.x, y: this.y, scroller: this.scroller,
      fontFamily: this.fontFamily, fontSize: this.fontSize, fontWeight: this.fontWeight,
      text: this.scoreText.text, context: this.renderer.context });
    this.cursorPromise = this.editor.startCursorPromise();
    this.state = SuiTextEditor.States.RUNNING;
    this._removeScoreText();
  }

  // ### _startSessionForNote
  // Stop the lyric session, return promise for done
  stopSession() {
    if (this.editor) {
      this.scoreText.text = this.editor.getText();
      this.scoreText.tryParseUnicode(); // convert unicode chars
      this.editor.stopEditor();
    }
    return PromiseHelpers.makePromise(this, '_isRendered', '_markStopped', null, 100);
  }

  // ### evKey
  // Key handler (pass to editor)
  evKey(evdata) {
    if (this.state !== SuiTextEditor.States.RUNNING) {
      return false;
    }
    const rv = this.editor.evKey(evdata);
    if (rv) {
      this._removeScoreText();
    }
    return rv;
  }

  handleMouseEvent(ev) {
    if (this.isRunning) {
      this.editor.handleMouseEvent(ev);
    }
  }
}
// ## SuiLyricSession
// Manage editor for lyrics, jupmping from note to note if asked
// eslint-disable-next-line no-unused-vars
class SuiLyricSession {
  static get States() {
    return { RUNNING: 1, STOPPING: 2, STOPPED: 4, PENDING_EDITOR: 8 };
  }
  constructor(params) {
    this.score = params.score;
    this.renderer = params.renderer;
    this.scroller = params.scroller;
    this.view = params.view;
    this.parser = params.parser ? params.parser : SmoLyric.parsers.lyric;
    this.verse = params.verse;
    this.selector = params.selector;
    this.selection = SmoSelection.noteFromSelector(this.score, this.selector);
    this.note = this.selection.note;
    this.originalText = '';
  }

  // ### _setLyricForNote
  // Get the text from the editor and update the lyric with it.
  _setLyricForNote() {
    this.lyric = null;
    const lar = this.note.getLyricForVerse(this.verse, SmoLyric.parsers.lyric);
    if (lar.length) {
      this.lyric = lar[0];
    }
    if (!this.lyric) {
      const scoreFont = this.score.fonts.find((fn) => fn.name === 'lyrics');
      const fontInfo = JSON.parse(JSON.stringify(scoreFont));
      this.lyric = new SmoLyric({  _text: '', verse: this.verse, fontInfo });
    }
    this.text = this.lyric._text;
    this.originalText = this.text;
    // this.view.addOrUpdateLyric(this.selection.selector, this.lyric);
  }

  // ### _endLyricCondition
  // Lyric editor has stopped running (promise condition)
  get _endLyricCondition()  {
    return this.editor.state !== SuiTextEditor.States.RUNNING;
  }

  // ### _endLyricCondition
  // renderer has partially rendered text(promise condition)
  get _isRefreshed() {
    return this.renderer.dirty === false;
  }

  // ### _isRendered
  // renderer has rendered text(promise condition)
  get _isRendered() {
    return this.renderer.passState ===  SuiRenderState.passStates.clean;
  }

  get _pendingEditor() {
    return this.state !== SuiTextEditor.States.PENDING_EDITOR;
  }

  // ### _hideLyric
  // Hide the lyric so you only see the editor.
  _hideLyric() {
    if (this.lyric.selector) {
      $(this.lyric.selector).remove();
    }
  }

  get isStopped() {
    return this.state === SuiTextEditor.States.STOPPED;
  }

  get isRunning() {
    return this.state === SuiTextEditor.States.RUNNING;
  }

  // ### _markStopped
  // Indicate this editor session is done running
  _markStopped() {
    this.state = SuiTextEditor.States.STOPPED;
  }

  // ### _startSessionForNote
  // Start the lyric editor for a note (current selected note)
  _startSessionForNote() {
    this.lyric.skipRender = true;
    const lyricRendered = this.lyric._text.length > 0 && typeof(this.lyric.logicalBox) !== 'undefined';
    const startX = lyricRendered ? this.lyric.logicalBox.x : this.note.logicalBox.x;
    const startY = lyricRendered ? this.lyric.logicalBox.y + this.lyric.logicalBox.height :
      this.note.logicalBox.y + this.note.logicalBox.height;
    this.editor = new SuiLyricEditor({ context: this.view.renderer.context,
      lyric: this.lyric, x: startX, y: startY, scroller: this.scroller });
    this.state = SuiTextEditor.States.RUNNING;
    if (!lyricRendered) {
      const delta = 2 * this.editor.svgText.maxFontHeight(1.0) * (this.lyric.verse + 1);
      this.editor.svgText.offsetStartY(delta);
    }
    this.cursorPromise = this.editor.startCursorPromise();
    this._hideLyric();
  }

  // ### _startSessionForNote
  // Start the lyric session
  startSession() {
    this._setLyricForNote();
    this._startSessionForNote();
    this.state = SuiTextEditor.States.RUNNING;
  }

  // ### _startSessionForNote
  // Stop the lyric session, return promise for done
  stopSession() {
    if (this.editor && !this._endLyricCondition) {
      this._updateLyricFromEditor();
      this.editor.stopEditor();
    }
    return PromiseHelpers.makePromise(this, '_isRendered', '_markStopped', null, 100);
  }

  // ### _advanceSelection
  // Based on a skip character, move the editor forward/back one note.
  _advanceSelection(isShift) {
    const nextSelection = isShift ? SmoSelection.lastNoteSelectionFromSelector(this.score, this.selector)
      : SmoSelection.nextNoteSelectionFromSelector(this.score, this.selector);
    if (nextSelection) {
      this.selector = nextSelection.selector;
      this.selection = nextSelection;
      this.note = nextSelection.note;
      this._setLyricForNote();
      const conditionArray = [];
      this.state = SuiTextEditor.States.PENDING_EDITOR;
      conditionArray.push(PromiseHelpers.makePromiseObj(this, '_endLyricCondition', null, null, 100));
      conditionArray.push(PromiseHelpers.makePromiseObj(this, '_isRefreshed', '_startSessionForNote', null, 100));
      PromiseHelpers.promiseChainThen(conditionArray);
    }
  }

  // ### advanceSelection
  // external interfoace to move to next/last note
  advanceSelection(isShift) {
    if (this.isRunning) {
      this._updateLyricFromEditor();
      this._advanceSelection(isShift);
    }
  }

  removeLyric() {
    if (this.selection && this.lyric) {
      this.view.removeLyric(this.selection.selector, this.lyric);
      this.lyric.deleted = true;
      this.lyric.skipRender = true;
      this.advanceSelection();
    }
  }

  // ### _updateLyricFromEditor
  // The editor is done running, so update the lyric now.
  _updateLyricFromEditor() {
    const txt = this.editor.getText();
    this.lyric.setText(txt);
    this.lyric.skipRender = false;
    this.editor.stopEditor();
    if (!this.lyric.deleted && this.originalText !== txt) {
      this.view.addOrUpdateLyric(this.selection.selector, this.lyric);
    }
  }
  // ### evKey
  // Key handler (pass to editor)
  evKey(evdata) {
    if (this.state !== SuiTextEditor.States.RUNNING) {
      return;
    }
    if (evdata.key === '-' || evdata.key === ' ') {
      // skip
      const back = evdata.shiftKey && evdata.key === ' ';
      if (evdata.key === '-') {
        this.editor.evKey(evdata);
      }
      this._updateLyricFromEditor();
      this._advanceSelection(back);
    } else {
      this.editor.evKey(evdata);
      this._hideLyric();
    }
  }

  // ### handleMouseEvent
  // Mouse event (send to editor)
  handleMouseEvent(ev) {
    if (this.state !== SuiTextEditor.States.RUNNING) {
      return;
    }
    this.editor.handleMouseEvent(ev);
  }
}

// eslint-disable-next-line no-unused-vars
class SuiChordSession extends SuiLyricSession {
  constructor(params) {
    super(params);
    this.parser = SmoLyric.parsers.chord;
  }
  get textType() {
    if (this.isRunning) {
      return this.editor.textType;
    }
    return SuiInlineText.textTypes.normal;
  }

  set textType(type) {
    this.editor.setTextType(type);
  }

  // ### evKey
  // Key handler (pass to editor)
  evKey(evdata) {
    let edited = false;
    if (this.state !== SuiTextEditor.States.RUNNING) {
      return false;
    }
    if (evdata.code === 'Enter') {
      this._updateLyricFromEditor();
      this._advanceSelection(evdata.shiftKey);
      edited = true;
    } else {
      edited = this.editor.evKey(evdata);
    }
    this._hideLyric();
    return edited;
  }

  // ### _setLyricForNote
  // Get the text from the editor and update the lyric with it.
  _setLyricForNote() {
    this.lyric = null;
    const lar = this.note.getLyricForVerse(this.verse, this.parser);
    if (lar.length) {
      this.lyric = lar[0];
    }
    if (!this.lyric) {
      const scoreFont = this.score.fonts.find((fn) => fn.name === 'chords');
      const fontInfo = JSON.parse(JSON.stringify(scoreFont));
      this.lyric = new SmoLyric({ _text: '', verse: this.verse, parser: this.parser, fontInfo });
      this.note.addLyric(this.lyric);
    }
    this.text = this.lyric._text;
  }
  // ### _startSessionForNote
  // Start the lyric editor for a note (current selected note)
  _startSessionForNote() {
    const lyricRendered = this.lyric._text.length && this.lyric.logicalBox;
    const startX = lyricRendered ? this.lyric.logicalBox.x : this.note.logicalBox.x;
    const startY = lyricRendered ? this.lyric.logicalBox.y + this.lyric.adjY + this.lyric.logicalBox.height :
      this.selection.measure.logicalBox.y + this.selection.measure.logicalBox.height - 70;
    this.editor = new SuiChordEditor({ context: this.view.renderer.context,
      lyric: this.lyric, x: startX, y: startY, scroller: this.scroller });
    this.state = SuiTextEditor.States.RUNNING;
    if (!lyricRendered) {
      const delta = (-1) * this.editor.svgText.maxFontHeight(1.0) * (this.lyric.verse + 1);
      this.editor.svgText.offsetStartY(delta);
    }
    this.cursorPromise = this.editor.startCursorPromise();
    this._hideLyric();
  }
}
;// ## textRender.js
// Classes responsible for formatting and rendering text in SVG space.
// ## SuiInlineText
// Inline text is a block of SVG text with the same font.  Each block can
// contain eithr text or an svg (vex) glyph.  Each block in the text has its own
// metrics so we can support inline svg text editors (cursor).
class SuiInlineText {
  static get textTypes() {
    return { normal: 0, superScript: 1, subScript: 2 };
  }
  static get symbolTypes() {
    return {
      GLYPH: 1,
      TEXT: 2,
      LINE: 3
    };
  }

  // ### textTypeTransitions
  // Given a current text type and a type change request, what is the result
  // text type?  This truth table tells you.
  static get textTypeTransitions() {
    return [
      [1, 1, 0],
      [1, 0, 1],
      [1, 2, 2],
      [2, 2, 0],
      [2, 0, 2],
      [2, 1, 1],
      [0, 1, 1],
      [0, 0, 0],
      [0, 2, 2]
    ];
  }

  static getTextTypeResult(oldType, newType) {
    let rv = SuiInlineText.textTypes.normal;
    let i = 0;
    for (i = 0; i < SuiInlineText.textTypeTransitions.length; ++i) {
      const tt = SuiInlineText.textTypeTransitions[i];
      if (tt[0] === oldType && tt[1] === newType) {
        rv = tt[2];
        break;
      }
    }
    return rv;
  }

  static getTextTypeTransition(oldType, result) {
    let rv = SuiInlineText.textTypes.normal;
    let i = 0;
    for (i = 0; i < SuiInlineText.textTypeTransitions.length; ++i) {
      const tt = SuiInlineText.textTypeTransitions[i];
      if (tt[0] === oldType && tt[2] === result) {
        rv = tt[1];
        break;
      }
    }
    return rv;
  }
  static get superscriptOffset() {
    return VF.ChordSymbol.chordSymbolMetrics.global.superscriptOffset / VF.ChordSymbol.engravingFontResolution;
  }

  static get subscriptOffset() {
    return VF.ChordSymbol.chordSymbolMetrics.global.subscriptOffset / VF.ChordSymbol.engravingFontResolution;
  }

  get spacing() {
    return this.textFont.spacing / this.textFont.resolution;
  }

  static get defaults() {
    return {
      blocks: [],
      fontFamily: 'Merriweather',
      fontSize: 14,
      startX: 100,
      startY: 100,
      fontWeight: 500,
      fontStyle: 'normal',
      scale: 1,
      activeBlock: -1,
      artifacts: [],
      classes: '',
      updatedMetrics: false
    };
  }

  updateFontInfo() {
    this.textFont = VF.TextFont.getTextFontFromVexFontData({
      family: this.fontFamily,
      weight: this.fontWeight,
      size: this.fontSize,
      style: this.fontStyle
    });
  }
  // ### constructor just creates an empty svg
  constructor(params) {
    Vex.Merge(this, SuiInlineText.defaults);
    Vex.Merge(this, params);
    this.attrs = {
      id: VF.Element.newID(),
      type: 'SuiInlineText'
    };

    if (!this.context) {
      throw 'context for SVG must be set';
    }
    if (!this.scroller) {
      throw 'scroller for inline text must be set';
    }
    this.updateFontInfo();
  }

  static fromScoreText(scoreText, context, scroller) {
    var pointSize = scoreText.fontInfo.pointSize ? scoreText.fontInfo.pointSize
      : SmoScoreText.fontPointSize(scoreText.fontInfo.size);
    const params = { fontFamily: scoreText.fontInfo.family,
      fontWeight: scoreText.fontInfo.weight,
      fontStyle: scoreText.fontInfo.style,
      startX: scoreText.x, startY: scoreText.y,
      scroller,
      fontSize: pointSize, context };
    const rv = new SuiInlineText(params);
    rv.attrs.id = scoreText.attrs.id;
    rv.addTextBlockAt(0, { text: scoreText.text });
    return rv;
  }

  static get blockDefaults() {
    return {
      symbolType: SuiInlineText.symbolTypes.TEXT,
      textType: SuiInlineText.textTypes.normal,
      highlighted: false
    };
  }

  // ### pointsToPixels
  // The font size is specified in points, convert to 'pixels' in the svg space
  get pointsToPixels() {
    return this.textFont.pointsToPixels;
  }

  offsetStartX(offset) {
    this.startX += offset;
    this.blocks.forEach((block) => {
      block.x += offset;
    });
  }

  offsetStartY(offset) {
    this.startY += offset;
    this.blocks.forEach((block) => {
      block.y += offset;
    });
  }
  maxFontHeight(scale) {
    return this.textFont.maxHeight * scale;
  }

  _glyphOffset(block) {
    return block.metrics.yOffset / VF.ChordSymbol.engravingFontResolution * this.pointsToPixels * block.scale;
  }

  // ### _calculateBlockIndex
  // Based on the font metrics, compute the width of the strings and glyph that make up
  // this block.
  _calculateBlockIndex() {
    var curX = this.startX;
    var maxH = 0;
    let superXAlign = 0;
    let superXWidth = 0;
    let prevBlock = null;
    let i = 0;
    this.textFont.setFontSize(this.fontSize);
    this.blocks.forEach((block) => {
      // super/subscript
      const sp = this.isSuperscript(block);
      const sub = this.isSubcript(block);

      block.width = 0;
      block.height = 0;

      // coeff for sub/super script
      const subAdj = (sp || sub) ? VF.ChordSymbol.superSubRatio : 1.0;
      // offset for super/sub
      let subOffset =  0;
      if (sp) {
        subOffset = SuiInlineText.superscriptOffset * this.pointsToPixels;
      } else if (sub) {
        subOffset = SuiInlineText.subscriptOffset * this.pointsToPixels;
      } else {
        subOffset = 0;
      }
      block.x = curX;
      if (block.symbolType === SuiInlineText.symbolTypes.TEXT) {
        for (i = 0; i < block.text.length; ++i) {
          const ch = block.text[i];

          const glyph = this.textFont.getMetricForCharacter(ch);
          block.width += ((glyph.advanceWidth) / this.textFont.resolution) * this.pointsToPixels * block.scale * subAdj;
          const blockHeight = (glyph.ha / this.textFont.resolution) *  this.pointsToPixels * block.scale;
          block.height = block.height < blockHeight ? blockHeight : block.height;
          block.y = this.startY +  (subOffset * block.scale);
        }
      } else if (block.symbolType === SuiInlineText.symbolTypes.GLYPH) {
        block.width = (block.metrics.advanceWidth / VF.ChordSymbol.engravingFontResolution) * this.pointsToPixels * block.scale;
        block.height = (block.glyph.metrics.ha / VF.ChordSymbol.engravingFontResolution) * this.pointsToPixels * block.scale;
        block.x += block.metrics.leftSideBearing / VF.ChordSymbol.engravingFontResolution * this.pointsToPixels * block.scale;
        block.y = this.startY + this._glyphOffset(block) + subOffset;
      }
      // Line subscript up with super if the follow each other
      if (sp) {
        if (superXAlign === 0) {
          superXAlign = block.x;
        }
      } else if (sub) {
        if (superXAlign > 0) {
          block.x = superXAlign;
          superXWidth = prevBlock.x + prevBlock.width;
          curX = superXAlign;
          superXAlign = 0;
        } else {
          if (superXWidth > 0 && superXWidth < block.width + block.x) {
            superXWidth = block.width + block.x;
          }
        }
      } else if (superXWidth > 0) {
        block.x = superXWidth + VF.ChordSymbol.spacingBetweenBlocks;
        superXWidth = 0;
      }  else {
        superXAlign = 0;
      }
      curX += block.width;
      maxH = block.height > maxH ? maxH : block.height;
      prevBlock = block;
    });
    this.width = curX - this.startX;
    this.height = maxH;
    this.updatedMetrics = true;
  }

  // ### getLogicalBox
  // return the calculated svg metrics.  In SMO parlance the
  // logical box is in SVG space, 'renderedBox' is in client space.
  getLogicalBox() {
    let rv = {};
    if (!this.updatedMetrics) {
      this._calculateBlockIndex();
    }
    const adjBox = (box) => {
      const nbox = svgHelpers.smoBox(box);
      nbox.y = nbox.y - nbox.height;
      return nbox;
    };
    this.blocks.forEach((block) => {
      if (!rv.x) {
        rv = svgHelpers.smoBox(adjBox(block));
      } else {
        rv = svgHelpers.unionRect(rv, adjBox(block));
      }
    });
    return rv;
  }

  _getTextBlock(params) {
    const block = JSON.parse(JSON.stringify(SuiInlineText.blockDefaults));
    Vex.Merge(block, params);
    block.text = params.text;
    block.scale = params.scale ? params.scale : 1;
    return block;
  }
  // ### renderCursorAt
  // When we are using textLayout to render editor, create a cursor that adjusts it's size
  renderCursorAt(position, textType) {
    let adjH = 0;
    let adjY = 0;
    if (!this.updatedMetrics) {
      this._calculateBlockIndex();
    }
    const group = this.context.openGroup();
    group.id = 'inlineCursor';
    const h = this.fontSize;
    if (this.blocks.length <= position || position < 0) {
      svgHelpers.renderCursor(group, this.startX, this.startY - h, h);
      this.context.closeGroup();
      return;
    }
    const block = this.blocks[position];
    adjH = block.symbolType === SuiInlineText.symbolTypes.GLYPH ? h / 2 : h;
    // For glyph, add y adj back to the cursor since it's not a glyph
    adjY = block.symbolType === SuiInlineText.symbolTypes.GLYPH ? block.y - this._glyphOffset(block) :
      block.y;
    if (typeof(textType) === 'number' && textType !== SuiInlineText.textTypes.normal) {
      const ratio = textType !== SuiInlineText.textTypes.normal ? VF.ChordSymbol.superSubRatio : 1.0;
      adjH = adjH * ratio;
      if (textType !== block.textType) {
        if (textType === SuiInlineText.textTypes.superScript) {
          adjY -= h / 2;
        } else {
          adjY += h / 2;
        }
      }
    }
    svgHelpers.renderCursor(group, block.x + block.width, adjY - (adjH * block.scale), adjH * block.scale);
    this.context.closeGroup();
  }
  removeCursor() {
    $('svg #inlineCursor').remove();
  }
  unrender() {
    $('svg #' + this.attrs.id).remove();
  }
  getIntersectingBlocks(box, scroller) {
    if (!this.artifacts) {
      return [];
    }
    return svgHelpers.findIntersectingArtifact(box, this.artifacts, scroller);
  }
  _addBlockAt(position, block) {
    if (position >= this.blocks.length) {
      this.blocks.push(block);
    } else {
      this.blocks.splice(position, 0, block);
    }
  }
  removeBlockAt(position) {
    this.blocks.splice(position, 1);
    this.updatedMetrics = false;
  }

  // ### addTextBlockAt
  // Add a text block to the line of text.
  // params must contain at least:
  // {text:'xxx'}
  addTextBlockAt(position, params) {
    const block = this._getTextBlock(params);
    this._addBlockAt(position, block);
    this.updatedMetrics = false;
  }
  _getGlyphBlock(params) {
    const block = JSON.parse(JSON.stringify(SuiInlineText.blockDefaults));
    block.symbolType = SuiInlineText.symbolTypes.GLYPH;
    block.glyphCode = params.glyphCode;
    block.glyph = new VF.Glyph(block.glyphCode, this.fontSize);
    block.metrics = VF.ChordSymbol.getMetricForGlyph(block.glyphCode);
    block.scale  = (params.textType && params.textType !== SuiInlineText.textTypes.normal) ?
      2 * VF.ChordSymbol.superSubRatio * block.metrics.scale : 2 * block.metrics.scale;

    block.textType = params.textType ? params.textType : SuiInlineText.textTypes.normal;

    block.glyph.scale = block.glyph.scale * block.scale;
    return block;
  }
  // ### addGlyphBlockAt
  // Add a glyph block to the line of text.  Params must include:
  // {glyphCode:'csymDiminished'}
  addGlyphBlockAt(position, params) {
    const block = this._getGlyphBlock(params);
    this._addBlockAt(position, block);
    this.updatedMetrics = false;
  }
  isSuperscript(block) {
    return block.textType === SuiInlineText.textTypes.superScript;
  }
  isSubcript(block) {
    return block.textType === SuiInlineText.textTypes.subScript;
  }
  getHighlight(block) {
    return block.highlighted;
  }
  setHighlight(block, value) {
    block.highlighted = value;
  }

  rescale(scale) {
    scale = (scale * this.fontSize < 6) ? 6 / this.fontSize : scale;
    scale = (scale * this.fontSize > 72) ? 72 / this.fontSize : scale;
    this.blocks.forEach((block) => {
      block.scale = scale;
    });
    this.updatedMetrics = false;
  }

  render() {
    $('svg #' + this.attrs.id).remove();

    if (!this.updatedMetrics) {
      this._calculateBlockIndex();
    }

    this.context.setFont(this.fontFamily, this.fontSize, this.fontWeight);
    const group = this.context.openGroup();
    const mmClass = 'suiInlineText';
    let ix = 0;
    group.classList.add('vf-' + this.attrs.id);
    group.classList.add(this.attrs.id);
    group.classList.add(mmClass);
    group.id = this.attrs.id;
    this.artifacts = [];

    this.blocks.forEach((block) => {
      var bg = this.context.openGroup();
      bg.classList.add('textblock-' + this.attrs.id + ix);
      this._drawBlock(block);
      this.context.closeGroup();
      const artifact = { block };
      artifact.box = svgHelpers.smoBox(bg.getBoundingClientRect());
      artifact.index = ix;
      this.artifacts.push(artifact);
      ix += 1;
    });
    this.context.closeGroup();
    this.logicalBox = svgHelpers.smoBox(group.getBBox());
    this.renderedBox = svgHelpers.logicalToClient(this.context.svg, this.logicalBox, this.scroller);
  }

  _drawBlock(block) {
    const sp = this.isSuperscript(block);
    const sub = this.isSubcript(block);
    const highlight = this.getHighlight(block);
    const y = block.y;

    if (highlight) {
      this.context.save();
      this.context.setFillStyle('#999');
    }

    // This is how svgcontext expects to get 'style'
    const weight = this.fontWeight + ',' + this.fontStyle;

    if (sp || sub) {
      this.context.save();
      this.context.setFont(this.fontFamily, this.fontSize * VF.ChordSymbol.superSubRatio * block.scale, weight);
    } else {
      this.context.setFont(this.fontFamily, this.fontSize * block.scale, weight);
    }
    if (block.symbolType === SuiInlineText.symbolTypes.TEXT) {
      this.context.fillText(block.text, block.x, y);
    } else if (block.symbolType === SuiInlineText.symbolTypes.GLYPH) {
      block.glyph.render(this.context, block.x, y);
    }
    if (sp || sub) {
      this.context.restore();
    }
    if (highlight) {
      this.context.restore();
    }
  }

  getText() {
    let rv = '';
    this.blocks.forEach((block) => {
      rv += block.text;
    });
    return rv;
  }
}

// ## SuiTextBlock
// A text block is a set of inline blocks that can be aligned/arranged in different ways.
// eslint-disable-next-line no-unused-vars
class SuiTextBlock {
  static get relativePosition() {
    return { ABOVE: SmoTextGroup.relativePositions.ABOVE,
      BELOW: SmoTextGroup.relativePositions.BELOW,
      LEFT: SmoTextGroup.relativePositions.LEFT,
      RIGHT: SmoTextGroup.relativePositions.RIGHT
    };
  }
  constructor(params) {
    this.inlineBlocks = [];
    if (!typeof(params.scroller) === 'object') {
      throw 'bad text block, no scroller';
    }
    this.scroller = params.scroller;
    this.spacing = 0;
    if (typeof(params.spacing) !== 'undefined') {
      this.spacing = params.spacing;
    }
    this.context = params.context;
    this.skipRender = false; // used when editing the text
    if (!params.blocks) {
      const inst = new SuiInlineText(params);
      params.blocks = [{ text: inst, position: SmoTextGroup.relativePositions.RIGHT }];
    }
    params.blocks.forEach((block) => {
      if (!this.currentBlock) {
        this.currentBlock = block;
        this.currentBlockIndex = 0;
      }
      this.inlineBlocks.push(block);
    });
    this.justification = params.justification ? params.justification :
      SmoTextGroup.justifications.LEFT;
  }
  addTextAt(position, params) {
    this.currentBlock.text.addTextBlockAt(position, params);
  }
  addGlyphAt(position, params) {
    this.currentBlock.text.addGlyphBlockAt(position, params);
  }
  render() {
    this.unrender();
    this.renderedBox = null;
    this.logicalBox = null;
    this.inlineBlocks.forEach((block) => {
      block.text.render();
      if (block.activeText) {
        this._outlineBox(this.context, block.text.logicalBox);
      }
      if (!this.renderedBox) {
        this.renderedBox = svgHelpers.smoBox(block.text.renderedBox);
        this.logicalBox = svgHelpers.smoBox(block.text.logicalBox);
      } else {
        this.renderedBox = svgHelpers.unionRect(this.renderedBox, block.text.renderedBox);
        this.logicalBox = svgHelpers.unionRect(this.logicalBox, block.text.logicalBox);
      }
    });
  }
  _outlineBox(context, box) {
    const outlineStroke = SuiTextEditor.strokes['text-highlight'];
    const obj = {
      context, box, classes: 'text-drag',
      outlineStroke, scroller: { netScroll: { x: 0, y: 0 } }
    };
    svgHelpers.outlineLogicalRect(obj);
  }

  offsetStartX(offset) {
    this.inlineBlocks.forEach((block) => {
      block.text.offsetStartX(offset);
    });
  }

  offsetStartY(offset) {
    this.inlineBlocks.forEach((block) => {
      block.text.offsetStartY(offset);
    });
  }

  rescale(scale) {
    this.inlineBlocks.forEach((block) => {
      block.text.rescale(scale);
    });
  }

  get x() {
    return this.getLogicalBox().x;
  }
  get y() {
    return this.getLogicalBox().y;
  }

  maxFontHeight(scale) {
    let rv = 0;
    this.inlineBlocks.forEach((block) => {
      const blockHeight = block.text.maxFontHeight(scale);
      rv = blockHeight > rv ? blockHeight : rv;
    });
    return rv;
  }

  static inlineParamsFromScoreText(scoreText, context, scroller) {
    const pointSize = scoreText.fontInfo.pointSize ? scoreText.fontInfo.pointSize
      : SmoScoreText.fontPointSize(scoreText.fontInfo.size);
    const rv = { fontFamily: scoreText.fontInfo.family,
      startX: scoreText.x, startY: scoreText.y,
      fontSize: pointSize, context, scroller };
    return rv;
  }
  static blockFromScoreText(scoreText, context, position, scroller) {
    var inlineText = SuiInlineText.fromScoreText(scoreText, context, scroller);
    return  { text: inlineText, position };
  }

  getLogicalBox() {
    return this._calculateBoundingClientRect();
  }
  getRenderedBox() {
    return svgHelpers.logicalToClient(this.context.svg, this._calculateBoundingClientRect(), this.scroller);
  }
  _calculateBoundingClientRect() {
    var rv = {};
    this.inlineBlocks.forEach((block) => {
      if (!rv.x) {
        rv = block.text.getLogicalBox();
      } else {
        rv = svgHelpers.unionRect(rv, block.text.getLogicalBox());
      }
    });
    rv.y = rv.y - rv.height;
    return rv;
  }
  static fromTextGroup(tg, context, scroller) {
    const blocks = [];

    // Create an inline block for each ScoreText
    tg.textBlocks.forEach((stBlock) => {
      const st = stBlock.text;
      const newText = SuiTextBlock.blockFromScoreText(st, context, stBlock.position, scroller);
      newText.activeText = stBlock.activeText;
      blocks.push(newText);
    });
    const rv = new SuiTextBlock({ blocks, justification: tg.justification, spacing: tg.spacing, context, scroller });
    rv._justify();
    return rv;
  }
  unrender() {
    this.inlineBlocks.forEach((block) => {
      const selector = '#' + block.text.attrs.id;
      $(selector).remove();
    });
  }
  // ### _justify
  // justify the blocks according to the group justify policy and the
  // relative position of the blocks
  _justify() {
    let hIx = 0;
    let left = 0;
    let minx = 0;
    let maxx = 0;
    let lvl = 0;
    let maxwidth = 0;
    let runningWidth = 0;
    let runningHeight = 0;
    if (!this.inlineBlocks.length) {
      return;
    }
    minx = this.inlineBlocks[0].text.startX;
    // We justify relative to first block x/y.
    const initialX = this.inlineBlocks[0].text.startX;
    const initialY = this.inlineBlocks[0].text.startY;
    const vert = {};
    this.inlineBlocks.forEach((inlineBlock) => {
      const block = inlineBlock.text;
      const blockBox = block.getLogicalBox();
      // If this is a horizontal positioning, reset to first blokc position
      //
      if (hIx > 0) {
        block.startX = initialX;
        block.startY = initialY;
      }
      minx = block.startX < minx ? block.startX : minx;
      maxx = (block.startX + blockBox.width) > maxx ? block.startX + blockBox.width : maxx;

      lvl = inlineBlock.position === SmoTextGroup.relativePositions.ABOVE ? lvl + 1 : lvl;
      lvl = inlineBlock.position === SmoTextGroup.relativePositions.BELOW ? lvl - 1 : lvl;
      if (inlineBlock.position === SmoTextGroup.relativePositions.RIGHT) {
        block.startX += runningWidth;
        if (hIx > 0) {
          block.startX += this.spacing;
        }
      }
      if (inlineBlock.position === SmoTextGroup.relativePositions.LEFT) {
        if (hIx > 0) {
          block.startX = minx - blockBox.width;
          minx = block.startX;
          block.startX -= this.spacing;
        }
      }
      if (inlineBlock.position === SmoTextGroup.relativePositions.BELOW) {
        block.startY += runningHeight;
        if (hIx > 0) {
          block.startY += this.spacing;
        }
      }
      if (inlineBlock.position === SmoTextGroup.relativePositions.ABOVE) {
        block.startY -= runningHeight;
        if (hIx > 0) {
          block.startY -= this.spacing;
        }
      }
      if (!vert[lvl]) {
        vert[lvl] = {};
        vert[lvl].blocks = [block];
        vert[lvl].minx = block.startX;
        vert[lvl].maxx = block.startX + blockBox.width;
        maxwidth = vert[lvl].width = blockBox.width;
      }  else {
        vert[lvl].blocks.push(block);
        vert[lvl].minx = vert[lvl].minx < block.startX ? vert[lvl].minx : block.startX;
        vert[lvl].maxx = vert[lvl].maxx > (block.startX + blockBox.width) ?
          vert[lvl].maxx : (block.startX + blockBox.width);
        vert[lvl].width += blockBox.width;
        maxwidth = maxwidth > vert[lvl].width ? maxwidth : vert[lvl].width;
      }
      runningWidth += blockBox.width;
      runningHeight += blockBox.height;
      hIx += 1;
      block.updatedMetrics = false;
    });

    const levels = Object.keys(vert);

    // Horizontal justify the vertical blocks
    levels.forEach((level) => {
      const vobj = vert[level];
      if (this.justification === SmoTextGroup.justifications.LEFT) {
        left = minx - vobj.minx;
      } else if (this.justification === SmoTextGroup.justifications.RIGHT) {
        left = maxx - vobj.maxx;
      } else {
        left = (maxwidth / 2) - (vobj.width / 2);
        left +=  minx - vobj.minx;
      }
      vobj.blocks.forEach((block) => {
        block.offsetStartX(left);
      });
    });
  }
  addBlockPosition(scoreText, position) {
    const blockBox = this.currentBlock.text.getRenderedBox();
    position = typeof(position) !== 'undefined' ? position : SuiTextBlock.relativePosition.BELOW;
    const ycoff = position === SuiTextBlock.relativePosition.ABOVE ? -1 : 1;
    const xcoff = position === SuiTextBlock.relativePosition.LEFT ? -1 : 1;
    const yoffset = position === SuiTextBlock.relativePosition.ABOVE
      || position === SuiTextBlock.relativePosition.BELOW ?
      blockBox.height + this.currentBlock.text.spacing : 0;
    const xoffset = position === SuiTextBlock.relativePosition.LEFT
     || position === SuiTextBlock.relativePosition.RIGHT ?
      blockBox.width + this.currentBlock.text.spacing : 0;
    const params = SuiTextBlock.inlineParamsFromScoreText(scoreText, this.context);
    params.startX = this.currentBlock.text.startX + (xoffset * xcoff);
    params.startY = this.currentBlock.text.startY + (yoffset * ycoff);
    const textBlock = new SuiInlineText(params);
    textBlock.attrs.id = scoreText.attrs.id;
    this.currentBlock = { text: textBlock, position };
    this.currentBlock.text.addTextBlockAt(0, { text: scoreText.text });
    this.inlineBlocks.push(this.currentBlock);
    this.currentBlockIndex += 1;
    this._justify();
  }
}
;// ## suiTracker
// A tracker maps the UI elements to the logical elements ,and allows the user to
// move through the score and make selections, for navigation and editing.
//
// ### See also:
// `suiBaseLayout`, `controller`, `menu`
// ### class methods:
// ---
// eslint-disable-next-line no-unused-vars
class suiTracker extends suiMapper {
  constructor(renderer, scroller, pasteBuffer) {
    super(renderer, scroller, pasteBuffer);
    this.idleTimer = Date.now();
  }
  // ### _checkBoxOffset
  // If the mapped note and actual note don't match, re-render the notes so they do.
  // Otherwise the selections are off.
  _checkBoxOffset() {
    const note = this.selections[0].note;
    const r = note.renderedBox;
    const b = this.selections[0].box;
    const ydiff = Math.abs(r.y - b.y);
    const xdiff = Math.abs(r.x - b.x);
    const preventScroll = $('body').hasClass('modal');

    if (ydiff > 1 || xdiff > 1) {
      if (this.renderer.passState === SuiRenderState.passStates.replace ||
        this.renderer.passState === SuiRenderState.passStates.clean) {
        console.log('tracker: rerender conflicting map');
        this.renderer.remapAll();
      }
      if (!preventScroll) {
        console.log('prevent scroll conflicting map');
        $('body').addClass('modal');
        this.renderer.renderPromise().then(() => {
          $('body').removeClass('modal');
        });
      }
    }
  }

  replaceSelectedMeasures() {
    const mm = SmoSelection.getMeasureList(this.selections);
    this.renderer.addToReplaceQueue(mm);
  }

  setDialogModifier(notifier) {
    this.modifierDialogFactory = notifier;
  }

  // ### renderElement
  // the element the score is rendered on
  get renderElement() {
    return this.renderer.renderer.elementId;
  }

  get score() {
    return this.renderer.score;
  }

  get context() {
    return this.renderer.renderer.getContext();
  }

  _copySelections() {
    const rv = [];
    this.selections.forEach((sel) => {
      rv.push(sel.selector);
    });
    return rv;
  }

  _copySelectionsByMeasure(staffIndex, measureIndex) {
    const rv = this.selections.filter((sel) => sel.selector.staff === staffIndex && sel.selector.measure === measureIndex);
    const ticks = rv.length < 1 ? 0 : rv.map((sel) => sel.note.tickCount).reduce((a, b) => a + b);
    const selectors = [];
    rv.forEach((sel) => {
      const nsel = JSON.parse(JSON.stringify(sel.selector));
      if (!nsel.pitches) {
        nsel.pitches = [];
      }
      selectors.push(nsel);
    });
    return { ticks, selectors };
  }

  _getTicksFromSelections() {
    let rv = 0;
    this.selections.forEach((sel) => {
      if (sel.note) {
        rv += sel.note.tickCount;
      }
    });
    return rv;
  }

  // Hack - lyric should be handled consistently
  _reboxTextModifier(modifier) {
    let el = null;
    if (modifier.attrs.type === 'SmoGraceNote') {
      el = this.context.svg.getElementById('vf-' + modifier.renderedId);
    } else if (modifier.attrs.type !== 'SmoLyric') {
      el = this.context.svg.getElementsByClassName(modifier.attrs.id)[0];
    }
    if (!el) {
      return;
    }
    svgHelpers.updateArtifactBox(this.context.svg, el, modifier, this.scroller);
  }

  clearMusicCursor() {
    $('.workspace #birdy').remove();
  }

  // ### musicCursor
  // the little birdie that follows the music as it plays
  musicCursor(selector) {
    const key = SmoSelector.getNoteKey(selector);
    // Get note from 0th staff if we can
    if (this.measureNoteMap[key]) {
      const measureSel = SmoSelection.measureSelection(this.renderer.score,
        this.renderer.score.staves.length - 1, selector.measure);
      const zmeasureSel = SmoSelection.measureSelection(this.renderer.score,
        0, selector.measure);
      const measure = measureSel.measure;
      const mbox = measure.renderedBox;
      const pos = this.measureNoteMap[key].scrollBox;
      const b = htmlHelpers.buildDom;
      const r = b('span').classes('birdy icon icon-arrow-down').attr('id', 'birdy');
      $('.workspace #birdy').remove();
      const rd = r.dom();
      const y = zmeasureSel.measure.renderedBox.y - this.scroller.netScroll.y;
      const x = pos.x - this.scroller.netScroll.x;
      $(rd).css('top', y).css('left', x);
      $('.workspace').append(rd);
      // todo, need lower right for x
      this.scroller.scrollVisibleBox(svgHelpers.boxPoints(
        mbox.x, mbox.y, mbox.width, mbox.height));
    }
  }

  // ### selectModifierById
  // programatically select a modifier by ID.  Used by text editor.
  selectId(id) {
    this.modifierIndex = this.modifierTabs.findIndex((mm) =>  mm.modifier.attrs.id === id);
  }

  // used by remove dialogs to clear removed thing
  clearModifierSelections() {
    this.modifierSelections = [];
    this._createLocalModifiersList();
    this.modifierIndex = -1;
    this.eraseRect('staffModifier');
  }

  getSelectedModifier() {
    if (this.modifierSelections.length) {
      return this.modifierSelections[0];
    }
    return null;
  }

  getSelectedModifiers() {
    return this.modifierSelections;
  }

  _createLocalModifiersList() {
    this.localModifiers = [];
    this.selections.forEach((sel) => {
      sel.note.getGraceNotes().forEach((gg) => {
        this.localModifiers.push({ selection: sel, modifier: gg, box: gg.renderedBox });
      });
      sel.note.getModifiers('SmoDynamicText').forEach((dyn) => {
        this.localModifiers.push({ selection: sel, modifier: dyn, box: dyn.renderedBox });
      });
      sel.measure.getModifiersByType('SmoVolta').forEach((volta) => {
        this.localModifiers.push({ selection: sel, modifier: volta, box: volta.renderedBox });
      });
      sel.measure.getModifiersByType('SmoTempoText').forEach((tempo) => {
        this.localModifiers.push({ selection: sel, modifier: tempo, box: tempo.renderedBox });
      });
      sel.staff.getModifiers().forEach((mod) => {
        if (SmoSelector.gteq(sel.selector, mod.startSelector) &&
          SmoSelector.lteq(sel.selector, mod.endSelector) && mod.renderedBox)  {
          const exists = this.localModifiers.find((mm) => mm.isStaffModifier &&
            mm.ctor === mod.ctor);
          if (!exists) {
            this.localModifiers.push({ selection: sel, modifier: mod, box: mod.renderedBox });
          }
        }
      });
    });
  }
  static serializeEvent(evKey) {
    const rv = {};
    smoSerialize.serializedMerge(['type', 'shiftKey', 'ctrlKey', 'altKey', 'key', 'keyCode'], evKey, rv);
    return rv;
  }

  advanceModifierSelection(keyEv) {
    if (this.recordBuffer) {
      this.recordBuffer.addAction('advanceModifierSelection', suiTracker.serializeEvent(keyEv));
    }

    this.idleTimer = Date.now();
    this.eraseRect('staffModifier');
    const offset = keyEv.key === 'ArrowLeft' ? -1 : 1;

    if (!this.modifierTabs.length) {
      return;
    }
    this.modifierIndex = this.modifierIndex + offset;
    this.modifierIndex = (this.modifierIndex === -2 && this.localModifiers.length) ?
      this.localModifiers.length - 1 : this.modifierIndex;
    if (this.modifierIndex >= this.localModifiers.length || this.modifierIndex < 0) {
      this.modifierIndex = -1;
      this.modifierSelections = [];
      return;
    }
    this.modifierSelections = [this.localModifiers[this.modifierIndex]];
    this._highlightModifier();
  }

  _findClosestSelection(selector) {
    var artifact = this._getClosestTick(selector);
    if (!artifact) {
      return;
    }
    if (this.selections.find((sel) => JSON.stringify(sel.selector)
      === JSON.stringify(artifact.selector))) {
      return;
    }
    if (selector.pitches && selector.pitches.length && selector.pitches.length <= artifact.note.pitches.length) {
      // If the old selection had only a single pitch, try to recreate that.
      artifact.selector.pitches = JSON.parse(JSON.stringify(selector.pitches));
    }
    this.selections.push(artifact);
  }

  static stringifyBox(box) {
    return '{x:' + box.x + ',y:' + box.y + ',width:' + box.width + ',height:' + box.height + '}';
  }

  // ### getExtremeSelection
  // Get the rightmost (1) or leftmost (-1) selection
  getExtremeSelection(sign) {
    let i = 0;
    let rv = this.selections[0];
    for (i = 1; i < this.selections.length; ++i) {
      const sa = this.selections[i].selector;
      if (sa.measure * sign > rv.selector.measure * sign) {
        rv = this.selections[i];
      } else if (sa.measure === rv.selector.measure && sa.tick * sign > rv.selector.tick * sign) {
        rv = this.selections[i];
      }
    }
    return rv;
  }

  // ### _getOffsetSelection
  // Get the selector that is the offset of the first existing selection
  _getOffsetSelection(offset) {
    let testSelection = this.getExtremeSelection(Math.sign(offset));
    const scopyTick = JSON.parse(JSON.stringify(testSelection.selector));
    const scopyMeasure = JSON.parse(JSON.stringify(testSelection.selector));
    scopyTick.tick += offset;
    scopyMeasure.measure += offset;
    const targetMeasure = SmoSelection.measureSelection(this.score, testSelection.selector.staff,
      scopyMeasure.measure);
    if (targetMeasure && targetMeasure.measure && targetMeasure.measure.voices.length <= scopyMeasure.voice) {
      scopyMeasure.voice = 0;
    }
    if (targetMeasure && targetMeasure.measure) {
      scopyMeasure.tick = (offset < 0) ? targetMeasure.measure.voices[scopyMeasure.voice].notes.length - 1 : 0;
    }

    if (testSelection.measure.voices.length > scopyTick.voice &&
      testSelection.measure.voices[scopyTick.voice].notes.length > scopyTick.tick && scopyTick.tick >= 0) {
      if (testSelection.selector.voice !== testSelection.measure.getActiveVoice()) {
        scopyTick.voice = testSelection.measure.getActiveVoice();
        testSelection = this._getClosestTick(scopyTick);
        return testSelection.selector;
      }
      return scopyTick;
    } else if (targetMeasure &&
      scopyMeasure.measure < testSelection.staff.measures.length && scopyMeasure.measure >= 0) {
      return scopyMeasure;
    }
    return testSelection.selector;
  }

  getSelectedGraceNotes() {
    if (!this.modifierSelections.length) {
      return [];
    }
    const ff = this.modifierSelections.filter((mm) =>
      mm.modifier.attrs.type === 'SmoGraceNote'
    );
    return ff;
  }

  isGraceNoteSelected() {
    if (this.modifierSelections.length) {
      const ff = this.modifierSelections.findIndex((mm) => mm.modifier.attrs.type === 'SmoGraceNote');
      return ff >= 0;
    }
    return false;
  }

  _growGraceNoteSelections(offset) {
    this.idleTimer = Date.now();
    const far = this.modifierSelections.filter((mm) => mm.modifier.attrs.type === 'SmoGraceNote');
    if (!far.length) {
      return;
    }
    const ix = (offset < 0) ? 0 : far.length - 1;
    const sel = far[ix];
    const left = this.modifierTabs.filter((mt) =>
      mt.modifier.attrs.type === 'SmoGraceNote' && SmoSelector.sameNote(mt.selection.selector, sel.selection.selector)
    );
    if (ix + offset < 0 || ix + offset >= left.length) {
      return;
    }
    this.modifierSelections.push(left[ix + offset]);
    this._highlightModifier();
  }
  get autoPlay() {
    return this.renderer.score.preferences.autoPlay;
  }

  growSelectionRight() {
    if (this.recordBuffer) {
      this.recordBuffer.addAction('growSelectionRight');
    }
    this._growSelectionRight(false);
  }
  _growSelectionRight(skipPlay) {
    this.idleTimer = Date.now();
    if (this.isGraceNoteSelected()) {
      this._growGraceNoteSelections(1);
      return 0;
    }
    const nselect = this._getOffsetSelection(1);
    // already selected
    const artifact = this._getClosestTick(nselect);
    if (!artifact) {
      return 0;
    }
    if (this.selections.find((sel) => SmoSelector.sameNote(sel.selector, artifact.selector))) {
      return 0;
    }
    if (!this.mapping && this.autoPlay && skipPlay === false) {
      suiOscillator.playSelectionNow(artifact);
    }
    this.selections.push(artifact);
    this.highlightSelection();
    this._createLocalModifiersList();
    return artifact.note.tickCount;
  }
  moveHome(evKey) {
    evKey = typeof(evKey) === 'undefined' || evKey === null ? {} : evKey;
    if (this.recordBuffer) {
      this.recordBuffer.addAction('moveHome', suiTracker.serializeEvent(evKey));
    }
    this.idleTimer = Date.now();
    const ls = this.selections[0].staff;
    if (evKey.ctrlKey) {
      const mm = ls.measures[0];
      const homeSel = this._getClosestTick({ staff: ls.staffId,
        measure: 0, voice: mm.getActiveVoice(), tick: 0 });
      if (evKey.shiftKey) {
        this._selectBetweenSelections(this.selections[0], homeSel);
      } else {
        this.selections = [homeSel];
        this.highlightSelection();
        this._createLocalModifiersList();
        if (homeSel.measure.renderedBox) {
          this.scroller.scrollVisibleBox(homeSel.measure.renderedBox);
        }
      }
    } else {
      const system = this.selections[0].measure.lineIndex;
      const lm = ls.measures.find((mm) =>
        mm.lineIndex === system && mm.measureNumber.systemIndex === 0);
      const homeSel = this._getClosestTick({ staff: ls.staffId,
        measure: lm.measureNumber.measureIndex, voice: lm.getActiveVoice(),
        tick: 0 });
      if (evKey.shiftKey) {
        this._selectBetweenSelections(this.selections[0], homeSel);
      } else {
        this.selections = [homeSel];
        this.scroller.scrollVisibleBox(homeSel.measure.renderedBox);
        this.highlightSelection();
        this._createLocalModifiersList();
      }
    }
  }
  moveEnd(evKey) {
    evKey = typeof(evKey) === 'undefined' || evKey === null ? {} : evKey;
    if (this.recordBuffer) {
      this.recordBuffer.addAction('moveEnd', suiTracker.serializeEvent(evKey));
    }
    this.idleTimer = Date.now();
    const ls = this.selections[0].staff;
    if (evKey.ctrlKey) {
      const lm = ls.measures[ls.measures.length - 1];
      const voiceIx = lm.getActiveVoice();
      const voice = lm.voices[voiceIx];
      const endSel = this._getClosestTick({ staff: ls.staffId,
        measure: ls.measures.length - 1, voice: voiceIx, tick: voice.notes.length - 1 });
      if (evKey.shiftKey) {
        this._selectBetweenSelections(this.selections[0], endSel);
      } else {
        this.selections = [endSel];
        this.highlightSelection();
        this._createLocalModifiersList();
        if (endSel.measure.renderedBox) {
          this.scroller.scrollVisibleBox(endSel.measure.renderedBox);
        }
      }
    } else {
      const system = this.selections[0].measure.lineIndex;
      // find the largest measure index on this staff in this system
      const measures = ls.measures.filter((mm) =>
        mm.lineIndex === system);
      const lm = measures.reduce((a, b) =>
        b.measureNumber.measureIndex > a.measureNumber.measureIndex ? b : a);
      const ticks = lm.voices[lm.getActiveVoice()].notes.length;
      const endSel = this._getClosestTick({ staff: ls.staffId,
        measure: lm.measureNumber.measureIndex, voice: lm.getActiveVoice(), tick: ticks - 1 });
      if (evKey.shiftKey) {
        this._selectBetweenSelections(this.selections[0], endSel);
      } else {
        this.selections = [endSel];
        this.highlightSelection();
        this._createLocalModifiersList();
        if (endSel.measure.renderedBox) {
          this.scroller.scrollVisibleBox(endSel.measure.renderedBox);
        }
      }
    }
  }
  growSelectionRightMeasure() {
    let toSelect = 0;
    const rightmost = this.getExtremeSelection(1);
    const ticksLeft = rightmost.measure.voices[rightmost.measure.activeVoice]
      .notes.length - rightmost.selector.tick;
    if (this.recordBuffer) {
      this.recordBuffer.addAction('growSelectionRightMeasure');
    }
    if (ticksLeft === 0) {
      if (rightmost.selector.measure < rightmost.staff.measures.length) {
        const mix = rightmost.selector.measure + 1;
        toSelect = rightmost.staff.measures[mix]
          .voices[rightmost.staff.measures[mix].activeVoice].notes.length;
      }
    } else {
      toSelect = ticksLeft;
    }
    while (toSelect > 0) {
      this._growSelectionRight(true);
      toSelect -= 1;
    }
  }

  growSelectionLeft() {
    if (this.isGraceNoteSelected()) {
      this._growGraceNoteSelections(-1);
      return 0;
    }
    if (this.recordBuffer) {
      this.recordBuffer.addAction('growSelectionLeft');
    }
    this.idleTimer = Date.now();
    const nselect = this._getOffsetSelection(-1);
    // already selected
    const artifact = this._getClosestTick(nselect);
    if (!artifact) {
      return 0;
    }
    if (this.selections.find((sel) => SmoSelector.sameNote(sel.selector, artifact.selector))) {
      return 0;
    }
    this.selections.push(artifact);
    if (this.autoPlay) {
      suiOscillator.playSelectionNow(artifact);
    }
    this.highlightSelection();
    this._createLocalModifiersList();
    return artifact.note.tickCount;
  }

  // if we are being moved right programmatically, avoid playing the selected note.
  moveSelectionRight(evKey, skipPlay) {
    evKey = typeof(evKey) === 'undefined' || evKey === null ? {} : evKey;
    if (this.selections.length === 0) {
      return;
    }
    if (this.recordBuffer) {
      this.recordBuffer.addAction('moveSelectionRight', suiTracker.serializeEvent(evKey));
    }
    const nselect = this._getOffsetSelection(1);
    this._replaceSelection(nselect, skipPlay);
  }

  moveSelectionLeft() {
    if (this.selections.length === 0) {
      return;
    }
    if (this.recordBuffer) {
      this.recordBuffer.addAction('moveSelectionLeft');
    }
    const nselect = this._getOffsetSelection(-1);
    this._replaceSelection(nselect);
  }
  moveSelectionLeftMeasure() {
    if (this.recordBuffer) {
      this.recordBuffer.addAction('moveSelectionLeftMeasure');
    }
    this._moveSelectionMeasure(-1);
  }
  moveSelectionRightMeasure() {
    if (this.recordBuffer) {
      this.recordBuffer.addAction('moveSelectionRightMeasure');
    }
    this._moveSelectionMeasure(1);
  }
  moveSelectionOffset(offset) {
    let i = 0;
    const fcn = (offset >= 0 ? 'moveSelectionRight' : 'moveSelectionLeft');
    offset = (offset < 0) ? -1 * offset : offset;
    for (i = 0; i < offset; ++i) {
      this[fcn]();
    }
  }

  _moveSelectionMeasure(offset) {
    let selection = this.getExtremeSelection(Math.sign(offset));
    this.idleTimer = Date.now();
    selection = JSON.parse(JSON.stringify(selection.selector));
    selection.measure += offset;
    selection.tick = 0;
    const selObj = this._getClosestTick(selection);
    if (selObj) {
      this.selections = [selObj];
    }
    this.highlightSelection();
    this._createLocalModifiersList();
  }

  setSelection(selection) {
    const selObj = this._getClosestTick(selection);
    this.idleTimer = Date.now();
    if (selObj) {
      this.selections = [selObj];
    }
    this.highlightSelection();
  }

  _moveStaffOffset(offset) {
    if (this.selections.length === 0) {
      return;
    }
    this.idleTimer = Date.now();
    const nselector = JSON.parse(JSON.stringify(this.selections[0].selector));
    nselector.staff = this.score.incrementActiveStaff(offset);
    this.selections = [this._getClosestTick(nselector)];
    this.highlightSelection();
    this._createLocalModifiersList();
  }

  // ### _moveSelectionPitch
  // Suggest a specific pitch in a chord, so we can transpose just the one note vs. the whole chord.
  _moveSelectionPitch(index) {
    this.idleTimer = Date.now();
    if (!this.selections.length) {
      return;
    }
    const sel = this.selections[0];
    const note = sel.note;
    if (note.pitches.length < 2) {
      this.pitchIndex = -1;
      return;
    }
    this.pitchIndex = (this.pitchIndex + index) % note.pitches.length;
    sel.selector.pitches = [];
    sel.selector.pitches.push(this.pitchIndex);
    this._highlightPitchSelection(note, this.pitchIndex);
  }
  moveSelectionPitchUp() {
    if (this.recordBuffer) {
      this.recordBuffer.addAction('moveSelectionPitchUp');
    }
    this._moveSelectionPitch(1);
  }
  moveSelectionPitchDown() {
    if (!this.selections.length) {
      return;
    }
    if (this.recordBuffer) {
      this.recordBuffer.addAction('moveSelectionPitchDown');
    }
    this._moveSelectionPitch(this.selections[0].note.pitches.length - 1);
  }

  moveSelectionUp() {
    if (this.recordBuffer) {
      this.recordBuffer.addAction('moveSelectionUp');
    }
    this._moveStaffOffset(-1);
  }
  moveSelectionDown() {
    if (this.recordBuffer) {
      this.recordBuffer.addAction('moveSelectionDown');
    }
    this._moveStaffOffset(1);
  }

  containsArtifact() {
    return this.selections.length > 0;
  }

  _replaceSelection(nselector, skipPlay) {
    var artifact = SmoSelection.noteSelection(this.score, nselector.staff, nselector.measure, nselector.voice, nselector.tick);
    if (!artifact) {
      artifact = SmoSelection.noteSelection(this.score, nselector.staff, nselector.measure, 0, nselector.tick);
    }
    if (!artifact) {
      artifact = SmoSelection.noteSelection(this.score, nselector.staff, nselector.measure, 0, 0);
    }
    if (!artifact) {
      // disappeared - default to start
      artifact = SmoSelection.noteSelection(this.score, 0, 0, 0, 0);
    }
    if (!skipPlay && this.autoPlay) {
      suiOscillator.playSelectionNow(artifact);
    }

    // clear modifier selections
    this.clearModifierSelections();
    this.score.setActiveStaff(nselector.staff);
    const mapKey = Object.keys(this.measureNoteMap).find((k) =>
      SmoSelector.sameNote(this.measureNoteMap[k].selector, artifact.selector)
    );
    if (!mapKey) {
      return;
    }
    const mapped = this.measureNoteMap[mapKey];
    // If this is a new selection, remove pitch-specific and replace with note-specific
    if (!nselector.pitches || nselector.pitches.length === 0) {
      this.pitchIndex = -1;
    }

    this.selections = [mapped];
    this.highlightSelection();
    this._createLocalModifiersList();
  }

  getFirstMeasureOfSelection() {
    if (this.selections.length) {
      return this.selections[0].measure;
    }
    return null;
  }
  // ## measureIterator
  // Description: iterate over the any measures that are part of the selection
  getSelectedMeasures() {
    const set = [];
    const rv = [];
    this.selections.forEach((sel) => {
      const measure = SmoSelection.measureSelection(this.score, sel.selector.staff, sel.selector.measure);
      const ix = measure.selector.measure;
      if (set.indexOf(ix) === -1) {
        set.push(ix);
        rv.push(measure);
      }
    });
    return rv;
  }

  _selectFromToInStaff(sel1, sel2) {
    this.selections = [];
    this.idleTimer = Date.now();
    const order = [sel1, sel2].sort((a, b) => SmoSelector.lteq(a.selector, b.selector) ? -1 : 1);

    // TODO: we could iterate directly over the selectors, that would be faster
    Object.keys(this.measureNoteMap).forEach((k) => {
      const obj = this.measureNoteMap[k];
      if (SmoSelector.gteq(obj.selector, order[0].selector) && SmoSelector.lteq(obj.selector, order[1].selector)) {
        this.selections.push(obj);
      }
    });
  }

  _addSelection(selection) {
    const ar = this.selections.filter((sel) =>
      SmoSelector.neq(sel.selector, selection.selector)
    );
    if (this.autoPlay) {
      suiOscillator.playSelectionNow(selection);
    }
    ar.push(selection);
    this.selections = ar;
  }

  recordSelectSuggestion(ev, selector) {
    if (this.recordBuffer) {
      this.recordBuffer.addAction('selectSuggestionNote', selector, suiTracker.serializeEvent(ev));
    }
  }
  recordModifierSelectSuggestion(ev) {
    if (this.recordBuffer) {
      const artifact = this.modifierTabs[this.modifierSuggestion];
      if (!artifact) {
        this.clearModifierSelections();
        return; // in SVG but not in model, ignore.
      }
      const modKey = artifact.modifier.serialize();
      if (artifact === null || artifact.selection === null) {
        return;
      }
      const selector = artifact.selection.selector;
      this.recordBuffer.addAction('selectSuggestionModifier', selector,
        suiTracker.serializeEvent(ev), modKey);
    }
  }
  _selectBetweenSelections(s1, s2) {
    const min = SmoSelector.gt(s1.selector, s2.selector) ? s2 : s1;
    const max = SmoSelector.lt(min.selector, s2.selector) ? s2 : s1;
    this._selectFromToInStaff(min, max);
    this._createLocalModifiersList();
    this.highlightSelection();
  }
  // ### _matchSelectionToModifier
  // assumes a modifier is selected
  _matchSelectionToModifier() {
    const mod = this.modifierSelections[0].modifier;
    if (mod.startSelector && mod.endSelector) {
      const s1 = SmoSelection.noteFromSelector(this.score, mod.startSelector);
      const s2 = SmoSelection.noteFromSelector(this.score, mod.endSelector);
      this._selectBetweenSelections(s1, s2);
    }
  }
  selectSuggestion(ev) {
    if (!this.suggestion.measure && this.modifierSuggestion < 0) {
      return;
    }
    this.idleTimer = Date.now();

    if (this.modifierSuggestion >= 0) {
      if (this.suggestFadeTimer) {
        clearTimeout(this.suggestFadeTimer);
      }
      this.recordModifierSelectSuggestion(ev);
      this.modifierIndex = -1;
      this.modifierSelections = [this.modifierTabs[this.modifierSuggestion]];
      this.modifierSuggestion = -1;
      // If we selected due to a mouse click, move the selection to the
      // selected modifier
      // this._matchSelectionToModifier();
      this._highlightModifier();
      return;
    } else if (ev.type === 'click') {
      this.clearModifierSelections(); // if we click on a non-modifier, clear the
      // modifier selections
    }

    if (ev.shiftKey) {
      const sel1 = this.getExtremeSelection(-1);
      if (sel1.selector.staff === this.suggestion.selector.staff) {
        this.recordSelectSuggestion(ev, this.suggestion.selector);
        this._selectBetweenSelections(sel1, this.suggestion);
        return;
      }
    }

    if (ev.ctrlKey) {
      this.recordSelectSuggestion(ev, this.suggestion.selector);
      this._addSelection(this.suggestion);
      this._createLocalModifiersList();
      this.highlightSelection();
      return;
    }
    if (this.autoPlay) {
      suiOscillator.playSelectionNow(this.suggestion);
    }

    const preselected = this.selections[0] ?
      SmoSelector.sameNote(this.suggestion.selector, this.selections[0].selector) && this.selections.length === 1 : false;

    if (preselected && this.selections[0].note.pitches.length > 1) {
      this.pitchIndex =  (this.pitchIndex + 1) % this.selections[0].note.pitches.length;
      this.selections[0].selector.pitches = [this.pitchIndex];
      this.recordSelectSuggestion(ev, this.selections[0].selector);
    } else {
      this.recordSelectSuggestion(ev, this.suggestion.selector);
      this.selections = [this.suggestion];
    }
    if (preselected && this.modifierTabs.length) {
      const mods  = this.modifierTabs.filter((mm) => mm.selection && SmoSelector.sameNote(mm.selection.selector, this.selections[0].selector));
      if (mods.length) {
        this.modifierSelections[0] = mods[0];
        this.modifierIndex = mods[0].index;
        this._highlightModifier();
        return;
      }
    }
    this.score.setActiveStaff(this.selections[0].selector.staff);
    this.highlightSelection();
    this._createLocalModifiersList();
  }

  static get strokes() {
    return {
      'suggestion': {
        'stroke': '#fc9',
        'stroke-width': 2,
        'stroke-dasharray': '4,1',
        'fill': 'none'
      },
      'selection': {
        'stroke': '#99d',
        'stroke-width': 2,
        'fill': 'none'
      },
      'staffModifier': {
        'stroke': '#933',
        'stroke-width': 2,
        'fill': 'none'
      }
    };
  }

  _setFadeTimer() {
    if (this.suggestFadeTimer) {
      clearTimeout(this.suggestFadeTimer);
    }
    const tracker = this;
    this.suggestFadeTimer = setTimeout(() => {
      if (tracker.containsArtifact()) {
        tracker.eraseRect('suggestion');
        tracker.modifierSuggestion = -1;
      }
    }, 1000);
  }

  _setModifierAsSuggestion(bb, artifact) {
    this.modifierSuggestion = artifact.index;
    this._drawRect(artifact.box, 'suggestion');
    this._setFadeTimer();
  }

  _setArtifactAsSuggestion(bb, artifact) {
    const sameSel =
      this.selections.find((ss) => SmoSelector.sameNote(ss.selector, artifact.selector));

    if (sameSel) {
      return;
    }
    this.modifierSuggestion = -1;

    this.suggestion = artifact;
    this._drawRect(artifact.box, 'suggestion');
    this._setFadeTimer();
  }

  eraseAllSelections() {
    const strokeKeys = Object.keys(suiTracker.strokes);
    strokeKeys.forEach((key) => {
      this.eraseRect(key);
    });
  }

  eraseRect(stroke) {
    $(this.renderElement).find('g.vf-' + stroke).remove();
  }

  _highlightModifier() {
    let box = null;
    if (!this.modifierSelections.length) {
      return;
    }
    this.modifierSelections.forEach((artifact) => {
      if (!box) {
        box = artifact.modifier.renderedBox;
      } else {
        box = svgHelpers.unionRect(box, artifact.modifier.renderedBox);
      }
    });
    this._drawRect(box, 'staffModifier');
  }

  _highlightPitchSelection(note, index) {
    this.eraseAllSelections();
    const noteDiv = $(this.renderElement).find('#' + note.renderId);
    const heads = noteDiv.find('.vf-notehead');
    if (!heads.length) {
      return;
    }
    const headEl = heads[index];
    const box = svgHelpers.adjustScroll(svgHelpers.smoBox(headEl.getBoundingClientRect()),
      this.scroller.invScroll);
    this._drawRect(box, 'staffModifier');
  }

  _highlightActiveVoice(selection) {
    let i = 0;
    const selector = selection.selector;
    for (i = 1; i <= 4; ++i) {
      const cl = 'v' + i.toString() + '-active';
      $('body').removeClass(cl);
    }
    const c2 = 'v' + (selector.voice + 1).toString() + '-active';
    $('body').addClass(c2);
  }
  // The user has just switched voices, select the active voice
  selectActiveVoice() {
    const selection = this.selections[0];
    const selector = JSON.parse(JSON.stringify(selection.selector));
    selector.voice = selection.measure.activeVoice;
    this.selections = [this._getClosestTick(selector)];
    this.highlightSelection();
  }

  highlightSelection() {
    let i = 0;
    let prevSel = {};
    let curBox = {};
    this.idleTimer = Date.now();
    const grace = this.getSelectedGraceNotes();
    // If this is not a note with grace notes, logically unselect the grace notes
    if (grace.length) {
      if (!SmoSelector.sameNote(grace[0].selection.selector, this.selections[0].selector)) {
        this.clearModifierSelections();
      } else {
        this._highlightModifier();
        return;
      }
    }
    if (this.pitchIndex >= 0 && this.selections.length === 1 &&
      this.pitchIndex < this.selections[0].note.pitches.length) {
      this._highlightPitchSelection(this.selections[0].note, this.pitchIndex);
      this._highlightActiveVoice(this.selections[0]);
      return;
    }

    this.pitchIndex = -1;
    this.eraseAllSelections();
    if (this.selections.length === 1 && this.selections[0].box) {
      this._checkBoxOffset();
      this._drawRect(this.selections[0].box, 'selection');
      this._highlightActiveVoice(this.selections[0]);
      return;
    }
    const sorted = this.selections.sort((a, b) => SmoSelector.gt(a.selector, b.selector) ? 1 : -1);
    prevSel = sorted[0];
    // rendered yet?
    if (!prevSel || !prevSel.box) {
      return;
    }
    curBox = svgHelpers.smoBox(prevSel.box);
    const boxes = [];
    for (i = 1; i < sorted.length; ++i) {
      const sel = sorted[i];
      const ydiff = Math.abs(prevSel.box.y - sel.box.y);
      if (sel.selector.staff === prevSel.selector.staff && ydiff < 1.0) {
        curBox = svgHelpers.unionRect(curBox, sel.box);
      } else {
        boxes.push(curBox);
        curBox = sel.box;
      }
      this._highlightActiveVoice(sel);
      prevSel = sel;
    }
    boxes.push(curBox);
    this._drawRect(boxes, 'selection');
  }

  _suggestionParameters(box, strokeName) {
    const outlineStroke = suiTracker.strokes[strokeName];
    return {
      context: this.context, box, classes: strokeName,
      outlineStroke, scroller: this.scroller
    };
  }

  _drawRect(bb, stroke) {
    svgHelpers.outlineRect(this._suggestionParameters(bb, stroke));
  }
}
;// eslint-disable-next-line no-unused-vars
class vexGlyph {
  static accidental(a) {
    return vexGlyph.accidentals[a];
  }
  static barWidth(b) {
    const str = SmoBarline.barlineString(b);
    const cc = vexGlyph.dimensions[str];
    return cc.width + cc.spacingRight;
  }
  static get accidentals() {
    return {
      'b': vexGlyph.dimensions.flat,
      '#': vexGlyph.dimensions.sharp,
      'bb': vexGlyph.dimensions.doubleFlat,
      '##': vexGlyph.dimensions.doubleSharp,
      'n': vexGlyph.dimensions.natural
    };
  }

  static get tempo() {
    return vexGlyph.dimensions.tempo;
  }
  static keySignatureLength(key) {
    return smoMusic.getSharpsInKeySignature(key) * vexGlyph.dimensions.sharp.width +
      smoMusic.getFlatsInKeySignature(key) * vexGlyph.dimensions.flat.width +
      vexGlyph.dimensions.keySignature.spacingRight;
  }
  static get timeSignature() {
    return vexGlyph.dimensions.timeSignature;
  }
  static get dot() {
    return vexGlyph.dimensions.dot;
  }

  static get tupletBeam() {
    return vexGlyph.dimensions.tupletBeam;
  }

  static get stem() {
    return vexGlyph.dimensions.stem;
  }
  static get flag() {
    return vexGlyph.dimensions.flag;
  }

  static clef(c) {
    const key = c.toLowerCase() + 'Clef';
    if (!vexGlyph.dimensions[key]) {
      return vexGlyph.dimensions.tenorClef;
    }
    return vexGlyph.dimensions[key];
  }
  static get dimensions() {
    return {
      tupletBeam: {
        width: 5,
        height: 6,
        yTop: 0,
        yBottom: 0,
        spacingRight: 5
      },
      singleBar: {
        width: 1,
        height: 41,
        yTop: 0,
        yBottom: 0,
        spacingRight: 5
      },
      endBar: {
        width: 5.22,
        height: 40.99,
        yTop: 0,
        yBottom: 0,
        spacingRight: 10
      },
      doubleBar: {
        width: 3.22,
        height: 40.99,
        yTop: 0,
        yBottom: 0,
        spacingRight: 0
      },
      endRepeat: {
        width: 6,
        height: 40.99,
        yTop: 0,
        yBottom: 0,
        spacingRight: 0,
      },
      startRepeat: {
        width: 6,
        height: 40.99,
        yTop: 0,
        yBottom: 0,
        spacingRight: 5,
      },
      noteHead: {
        width: 15.3,
        height: 10.48,
        yTop: 0,
        yBottom: 0,
        spacingRight: 10.71,
      },
      dot: {
        width: 15,
        height: 5,
        spacingRight: 2
      }, // This isn't accurate, but I don't
      // want to add extra space just for clef.
      trebleClef: {
        width: 35,
        height: 68.32,
        yTop: 3,
        yBottom: 3,
        spacingRight: 10,
      },
      bassClef: {
        width: 36,
        height: 31.88,
        yTop: 0,
        yBottom: 0,
        spacingRight: 5,
      },
      altoClef: {
        width: 31.5,
        yTop: 0,
        yBottom: 0,
        height: 85.5,
        spacingRight: 10
      },
      tenorClef: {
        width: 31.5,
        yTop: 10,
        yBottom: 0,
        height: 41,
        spacingRight: 10
      },
      timeSignature: {
        width: 22.36,
        height: 85,
        yTop: 0,
        yBottom: 0,
        spacingRight: 5
      },
      tempo: {
        width: 10,
        height: 37,
        yTop: 37,
        yBottom: 0,
        spacingRight: 0
      },
      flat: {
        width: 15,
        height: 23.55,
        yTop: 0,
        yBottom: 0,
        spacingRight: 2
      },
      keySignature: {
        width: 0,
        height: 85.5,
        yTop: 0,
        yBottom: 0,
        spacingRight: 10
      },
      sharp: {
        width: 17,
        height: 62,
        yTop: 0,
        yBottom: 0,
        spacingRight: 2
      },
      natural: {
        width: 15,
        height: 53.35,
        yTop: 0,
        yBottom: 0,
        spacingRight: 2
      },
      doubleSharp: {
        height: 10.04,
        width: 21.63,
        yTop: 0,
        yBottom: 0,
        spacingRight: 2
      },
      doubleFlat: {
        width: 13.79,
        height: 49.65,
        yTop: 0,
        yBottom: 0,
        spacingRight: 2
      }, stem: {
        width: 1,
        height: 35,
        yTop: 0,
        yBottom: 0,
        spacingRight: 0
      }, flag: {
        width: 10,
        height: 35,
        yTop: 0,
        yBottom: 0,
        spacingRight: 0
      }
    };
  }
}
;// ## Description:
// This file calls the vexflow routines that actually render a
// measure of music.  If multiple measures are justified in a
// column, the rendering is deferred until all the measures have been
// preformatted.
// eslint-disable-next-line no-unused-vars
class VxMeasure {
  constructor(context, options) {
    this.context = context;
    Vex.Merge(this, VxMeasure.defaults);
    Vex.Merge(this, options);
    this.rendered = false;
    this.selection = options.selection;
    this.smoMeasure = this.selection.measure;
    this.noteToVexMap = {};
    this.beamToVexMap = {};
    this.tupletToVexMap = {};
    this.modifierOptions = {};

    this.vexNotes = [];
    this.vexBeamGroups = [];
    this.vexTuplets = [];
    this.vexBeamGroups = [];
    this.beamToVexMap = {};
  }

  static get adjLeftPixels() {
    return 5;
  }
  static get fillStyle() {
    return '#000';
  }

  static get adjRightPixels() {
    return 5;
  }

  static get defaults() {
    // var defaultLayout = new smrfSimpleLayout();
    return {
      smoMeasure: null,
      printing: false
    };
  }
  addCustomModifier(ctor, parameters) {
    this.smoMeasure.addCustomModifier(ctor, parameters);
  }

  applyTransform(actor) {
    SmoTickTransformer.applyTransform(this.smoMeasure, [actor]);
    smoModifierFactory.applyModifiers(this.smoMeasure);
  }
  applyModifiers() {
    smoModifierFactory.applyModifiers(this.smoMeasure);
  }

  // ## Description:
  // decide whether to force stem direction for multi-voice, or use the default.
  // ## TODO:
  // use x position of ticks in other voices, pitch of note, and consider
  // stem direction modifier.
  applyStemDirection(vxParams, voiceIx, flagState) {
    if (this.smoMeasure.voices.length === 1 && flagState === SmoNote.flagStates.auto) {
      vxParams.auto_stem = true;
    } else if (flagState !== SmoNote.flagStates.auto) {
      vxParams.stem_direction = flagState ===  SmoNote.flagStates.up ? 1 : -1;
    } else if (voiceIx % 2) {
      vxParams.stem_direction = -1;
    } else {
      vxParams.stem_direction = 1;
    }
  }

  // We add microtones to the notes, without regard really to how they interact
  _createMicrotones(smoNote, vexNote) {
    // let added = false;
    const tones = smoNote.getMicrotones();
    tones.forEach((tone) => {
      const acc = new VF.Accidental(tone.toVex);
      vexNote.addAccidental(tone.pitch, acc);
      added = true;
    });
    // if (added) {
    //   this._addSpacingAnnotation(vexNote);
    // }
  }
  _createAccidentals(smoNote, vexNote, tickIndex, voiceIx) {
    let i = 0;
    for (i = 0; i < smoNote.pitches.length; ++i) {
      const pitch = smoNote.pitches[i];
      const duration = this.tickmapObject.tickmaps[voiceIx].durationMap[tickIndex];
      const keyAccidental = smoMusic.getAccidentalForKeySignature(pitch, this.smoMeasure.keySignature);
      const accidentals = this.tickmapObject.accidentalArray.filter((ar) =>
        ar.duration < duration && ar.pitches[pitch.letter]);
      const acLen = accidentals.length;
      const declared = acLen > 0 ?
        accidentals[acLen - 1].pitches[pitch.letter].pitch.accidental : keyAccidental;

      if ((declared !== pitch.accidental
        || pitch.cautionary) && smoNote.noteType === 'n') {
        const acc = new VF.Accidental(pitch.accidental);

        if (pitch.cautionary) {
          acc.setAsCautionary();
        }
        vexNote.addAccidental(i, acc);
      }
    }
    for (i = 0; i < smoNote.dots; ++i) {
      vexNote.addDotToAll();
    }
    this._createMicrotones(smoNote, vexNote);
  }

  _createJazzOrnaments(smoNote, vexNote) {
    const o = smoNote.getJazzOrnaments();
    o.forEach((ll) => {
      const mod = new VF.Ornament(ll.toVex());
      vexNote.addModifier(0, mod);
    });
  }

  _createOrnaments(smoNote, vexNote) {
    const o  = smoNote.getOrnaments();
    o.forEach((ll) => {
      const mod = new VF.Ornament(ll.ornament);
      if (ll.offset === SmoOrnament.offsets.after) {
        mod.setDelayed(true);
      }
      vexNote.addModifier(0, mod);
    });
  }
  _addLyricAnnotationToNote(vexNote, lyric) {
    let classString = 'lyric lyric-' + lyric.verse;
    let text = lyric.getText();
    if (lyric.skipRender) {
      return;
    }
    lyric.vexRenderY = 0;
    if (!text.length && lyric.isHyphenated()) {
      text = '-';
    }
    // no text, no hyphen, don't add it.
    if (!text.length) {
      return;
    }
    const vexL = new VF.Annotation(text); // .setReportWidth(lyric.adjustNoteWidth);
    vexL.setAttribute(lyric.attrs.id); //

    // If we adjusted this note for the lyric, adjust the lyric as well.
    vexL.setFont(lyric.fontInfo.family, lyric.fontInfo.size, lyric.fontInfo.weight);
    vexL.setVerticalJustification(VF.Annotation.VerticalJustify.BOTTOM);
    vexNote.addAnnotation(0, vexL);
    if (lyric.isHyphenated()) {
      classString += ' lyric-hyphen';
    }
    vexL.addClass(classString);
  }

  _addChordChangeToNote(vexNote, lyric) {
    const cs = new VF.ChordSymbol();
    const blocks = lyric.getVexChordBlocks();
    blocks.forEach((block) => {
      if (block.glyph) {
        cs.addGlyph(block.glyph, block);
      } else {
        cs.addGlyphOrText(block.text, block);
      }
    });
    cs.setFont(lyric.fontInfo.family, lyric.fontInfo.size).setReportWidth(lyric.adjustNoteWidth);
    vexNote.addModifier(0, cs);
    const classString = 'chord chord-' + lyric.verse;
    cs.addClass(classString);
  }

  _createLyric(smoNote, vexNote) {
    const lyrics = smoNote.getTrueLyrics();
    lyrics.forEach((ll) => {
      this._addLyricAnnotationToNote(vexNote, ll);
    });
    const chords = smoNote.getChords();
    chords.forEach((chord) => {
      this._addChordChangeToNote(vexNote, chord);
    });
  }

  _createGraceNotes(smoNote, vexNote) {
    let i = 0;
    const gar = smoNote.getGraceNotes();
    var toBeam = true;
    if (gar && gar.length) {
      const group = [];
      gar.forEach((g) => {
        const gr = new VF.GraceNote(g.toVexGraceNote());
        for (i = 0; i < g.pitches.length; ++i) {
          const pitch = g.pitches[i];
          if (!pitch.accidental) {
            console.warn('no accidental in grace note');
          }
          if (pitch.accidental && pitch.accidental !== 'n' || pitch.cautionary)  {
            const accidental = new VF.Accidental(pitch.accidental);
            if (pitch.cautionary) {
              accidental.setAsCautionary();
            }
            gr.addAccidental(i, accidental);
          }
        }
        if (g.tickCount() >= 4096) {
          toBeam = false;
        }
        gr.addClass('grace-note'); // note: this doesn't work :(

        g.renderedId = gr.attrs.id;
        group.push(gr);
      });
      const grace = new VF.GraceNoteGroup(group);
      if (toBeam) {
        grace.beamNotes();
      }
      vexNote.addModifier(0, grace);
    }
  }

  // ## Description:
  // convert a smoNote into a vxNote so it can be rasterized
  _createVexNote(smoNote, tickIndex, voiceIx, x_shift) {
    let vexNote = {};
    let timestamp = new Date().valueOf();
    // If this is a tuplet, we only get the duration so the appropriate stem
    // can be rendered.  Vex calculates the actual ticks later when the tuplet is made
    var duration =
      smoNote.isTuplet ?
        smoMusic.closestVexDuration(smoNote.tickCount) :
        smoMusic.ticksToDuration[smoNote.tickCount];

    if (typeof(duration) === 'undefined') {
      console.warn('bad duration in measure ' + this.smoMeasure.measureNumber.measureIndex);
      duration = '8';
    }
    // transpose for instrument-specific keys
    const keys = smoMusic.smoPitchesToVexKeys(smoNote.pitches, 0, smoNote.noteHead);
    const noteParams = {
      clef: smoNote.clef,
      keys,
      duration: duration + smoNote.noteType
    };

    this.applyStemDirection(noteParams, voiceIx, smoNote.flagState);
    layoutDebug.setTimestamp(layoutDebug.codeRegions.PREFORMATA, new Date().valueOf() - timestamp);
    timestamp = new Date().valueOf();
    vexNote = new VF.StaveNote(noteParams);
    layoutDebug.setTimestamp(layoutDebug.codeRegions.PREFORMATB, new Date().valueOf() - timestamp);
    timestamp = new Date().valueOf();
    if (smoNote.fillStyle) {
      vexNote.setStyle({ fillStyle: smoNote.fillStyle });
    }
    vexNote.attrs.classes = 'voice-' + voiceIx;
    smoNote.renderId = 'vf-' + vexNote.attrs.id; // where does 'vf' come from?

    this._createAccidentals(smoNote, vexNote, tickIndex, voiceIx);
    this._createLyric(smoNote, vexNote, x_shift);
    this._createOrnaments(smoNote, vexNote);
    this._createJazzOrnaments(smoNote, vexNote);
    this._createGraceNotes(smoNote, vexNote);
    layoutDebug.setTimestamp(layoutDebug.codeRegions.PREFORMATC, new Date().valueOf() - timestamp);

    return vexNote;
  }

  _renderArticulations(vix) {
    const i = 0;
    this.smoMeasure.voices[vix].notes.forEach((smoNote) => {
      smoNote.articulations.forEach((art) => {
        const vx = this.noteToVexMap[smoNote.attrs.id];
        const position = SmoArticulation.positionToVex[art.position];
        const vexArt = SmoArticulation.articulationToVex[art.articulation];
        const vxArt = new VF.Articulation(vexArt).setPosition(position);
        vx.addArticulation(i, vxArt);
      });
    });
  }

  _renderNoteGlyph(smoNote, textObj) {
    var x = this.noteToVexMap[smoNote.attrs.id].getAbsoluteX() + textObj.xOffset;
    // the -3 is copied from vexflow textDynamics
    var y = this.stave.getYForLine(textObj.yOffsetLine - 3) + textObj.yOffsetPixels;
    var group = this.context.openGroup();
    group.classList.add(textObj.attrs.id + '-' + smoNote.attrs.id);
    group.classList.add(textObj.attrs.id);
    textObj.text.split('').forEach((ch) => {
      const glyphCode = VF.TextDynamics.GLYPHS[ch];
      if (glyphCode) {
        const glyph = new VF.Glyph(glyphCode.code, textObj.fontSize);
        glyph.render(this.context, x, y);
        x += VF.TextDynamics.GLYPHS[ch].width;
      }
    });
    textObj.logicalBox = svgHelpers.smoBox(group.getBBox());
    this.context.closeGroup();
  }

  renderDynamics() {
    this.smoMeasure.voices.forEach((voice) => {
      voice.notes.forEach((smoNote) => {
        const mods = smoNote.textModifiers.filter((mod) =>
          mod.attrs.type === 'SmoDynamicText'
        );
        mods.forEach((tm) => {
          this._renderNoteGlyph(smoNote, tm);
        });
      });
    });
  }

  // ## Description:
  // create an a array of VF.StaveNote objects to render the active voice.
  createVexNotes(voiceIx) {
    let i = 0;
    const shiftIndex = 0;
    this.voiceNotes = [];
    const voice =  this.smoMeasure.voices[voiceIx];
    for (i = 0;
      i < voice.notes.length; ++i) {
      const smoNote = voice.notes[i];
      const vexNote = this._createVexNote(smoNote, i, voiceIx, shiftIndex);
      this.noteToVexMap[smoNote.attrs.id] = vexNote;
      this.vexNotes.push(vexNote);
      this.voiceNotes.push(vexNote);
      if (isNaN(smoNote.ticks.numerator) || isNaN(smoNote.ticks.denominator)
          || isNaN(smoNote.ticks.remainder)) {
        throw ('vxMeasure: NaN in ticks');
      }
    }
    this._renderArticulations(voiceIx);
  }

  // ### createVexBeamGroups
  // create the VX beam groups. VexFlow has auto-beaming logic, but we use
  // our own because the user can specify stem directions, breaks etc.
  createVexBeamGroups(vix) {
    let keyNoteIx = -1;
    let i = 0;
    let j = 0;
    let stemDirection = VF.Stem.DOWN;
    for (i = 0; i < this.smoMeasure.beamGroups.length; ++i) {
      const bg = this.smoMeasure.beamGroups[i];
      if (bg.voice !== vix) {
        continue;
      }
      const vexNotes = [];
      keyNoteIx = bg.notes.findIndex((nn) => nn.noteType === 'n');

      // Fix stem bug: key off first non-rest note.
      keyNoteIx = (keyNoteIx >= 0) ? keyNoteIx : 0;
      for (j = 0; j < bg.notes.length; ++j) {
        const note = bg.notes[j];
        const vexNote = this.noteToVexMap[note.attrs.id];
        if (keyNoteIx === j) {
          stemDirection = note.flagState === SmoNote.flagStates.auto ?
            vexNote.getStemDirection() : note.toVexStemDirection();
        }
        vexNote.setStemDirection(stemDirection);
        vexNotes.push(this.noteToVexMap[note.attrs.id]);
      }
      const vexBeam = new VF.Beam(vexNotes);
      this.beamToVexMap[bg.attrs.id] = vexBeam;
      this.vexBeamGroups.push(vexBeam);
    }
  }

  // ### createVexTuplets
  // Create the VF tuplet objects based on the smo tuplet objects
  // that have been defined.
  createVexTuplets(vix) {
    var j = 0;
    var i = 0;
    this.vexTuplets = [];
    this.tupletToVexMap = {};
    for (i = 0; i < this.smoMeasure.tuplets.length; ++i) {
      const tp = this.smoMeasure.tuplets[i];
      if (tp.voice !== vix) {
        continue;
      }
      const vexNotes = [];
      for (j = 0; j < tp.notes.length; ++j) {
        const smoNote = tp.notes[j];
        vexNotes.push(this.noteToVexMap[smoNote.attrs.id]);
      }
      const direction = tp.getStemDirection(this.smoMeasure.clef) === SmoNote.flagStates.up ?
        VF.Tuplet.LOCATION_TOP : VF.Tuplet.LOCATION_BOTTOM;
      const vexTuplet = new VF.Tuplet(vexNotes, {
        num_notes: tp.num_notes,
        notes_occupied: tp.notes_occupied,
        ratioed: false,
        bracketed: true,
        location: direction
      });
      this.tupletToVexMap[tp.attrs.id] = vexTuplet;
      this.vexTuplets.push(vexTuplet);
    }
  }
  unrender() {
    $(this.context.svg).find('g.' + this.smoMeasure.attrs.id).remove();
  }

  handleMeasureModifiers() {
    const sb = this.smoMeasure.getStartBarline();
    const eb = this.smoMeasure.getEndBarline();
    const sym = this.smoMeasure.getRepeatSymbol();

    // don't create a begin bar for any but the 1st measure.
    if (this.smoMeasure.measureNumber.systemIndex !== 0 && sb.barline === SmoBarline.barlines.singleBar
      && this.smoMeasure.padLeft === 0) {
      this.stave.setBegBarType(VF.Barline.type.NONE);
    } else {
      this.stave.setBegBarType(sb.toVexBarline());
    }
    if (eb.barline !== SmoBarline.barlines.singleBar) {
      this.stave.setEndBarType(eb.toVexBarline());
    }
    if (sym && sym.symbol !== SmoRepeatSymbol.symbols.None) {
      const rep = new VF.Repetition(sym.toVexSymbol(), sym.xOffset + this.smoMeasure.staffX, sym.yOffset);
      this.stave.modifiers.push(rep);
    }
    const tms = this.smoMeasure.getMeasureText();
    // TODO: set font
    tms.forEach((tm) => {
      const offset = tm.position === SmoMeasureText.positions.left ? this.smoMeasure.padLeft : 0;
      this.stave.setText(
        tm.text, tm.toVexPosition(), {
          shift_x: tm.adjustX + offset, shift_y: tm.adjustY, justification: tm.toVexJustification()
        });

      // hack - we can't create staveText directly so this is the only way I could set the font
      const ar = this.stave.getModifiers();
      const vm = ar[ar.length - 1];
      vm.setFont(tm.fontInfo);
    });

    const rm = this.smoMeasure.getRehearsalMark();
    if (rm) {
      this.stave.setSection(rm.symbol, 0);
    }

    const tempo = this.smoMeasure.getTempo();
    if (tempo && this.smoMeasure.forceTempo) {
      this.stave.setTempo(tempo.toVexTempo(), -1 * tempo.yOffset);
      const vexTempo = this.stave.modifiers.find((mod) => mod.attrs.type === 'StaveTempo');
      vexTempo.font = { family: SourceSerifProFont.fontFamily, size: 14, weight: 'bold' };
    }
  }

  // ## Description:
  // Create all Vex notes and modifiers.  We defer the format and rendering so
  // we can align across multiple staves
  preFormat() {
    var j = 0;
    $(this.context.svg).find('g.' + this.smoMeasure.getClassId()).remove();

    const key = smoMusic.vexKeySignatureTranspose(this.smoMeasure.keySignature, 0);
    const canceledKey = this.smoMeasure.canceledKeySignature ? smoMusic.vexKeySignatureTranspose(this.smoMeasure.canceledKeySignature, 0)
      : this.smoMeasure.canceledKeySignature;

    const staffX = this.smoMeasure.staffX + this.smoMeasure.padLeft;

    this.stave = new VF.Stave(staffX, this.smoMeasure.staffY, this.smoMeasure.staffWidth - this.smoMeasure.padLeft,
      { font: { family: SourceSansProFont.fontFamily, size: '12pt' }, fill_style: VxMeasure.fillStyle });
    // If there is padLeft, draw an invisible box so the padding is included in the measure box
    if (this.smoMeasure.padLeft) {
      this.context.rect(this.smoMeasure.staffX, this.smoMeasure.staffY, this.smoMeasure.padLeft, 50, {
        fill: 'none', 'stroke-width': 1, stroke: 'white'
      });
    }

    this.stave.options.space_above_staff_ln = 0; // don't let vex place the staff, we want to.

    // Add a clef and time signature.
    if (this.smoMeasure.forceClef) {
      this.stave.addClef(this.smoMeasure.clef);
    }
    if (this.smoMeasure.forceKeySignature) {
      const sig = new VF.KeySignature(key);
      if (this.smoMeasure.canceledKeySignature) {
        sig.cancelKey(canceledKey);
      }
      sig.addToStave(this.stave);
    }
    if (this.smoMeasure.forceTimeSignature) {
      this.stave.addTimeSignature(this.smoMeasure.timeSignature);
    }
    // Connect it to the rendering context and draw!
    this.stave.setContext(this.context);

    this.handleMeasureModifiers();

    this.tickmapObject = this.smoMeasure.createMeasureTickmaps();

    this.voiceAr = [];
    this.vexNotes = [];
    this.noteToVexMap = {};

    // If there are multiple voices, add them all to the formatter at the same time so they don't collide
    for (j = 0; j < this.smoMeasure.voices.length; ++j) {
      this.createVexNotes(j);
      this.createVexTuplets(j);
      this.createVexBeamGroups(j);

      // Create a voice in 4/4 and add above notes
      const voice = new VF.Voice({
        num_beats: this.smoMeasure.numBeats,
        beat_value: this.smoMeasure.beatValue
      }).setMode(VF.Voice.Mode.SOFT);
      voice.addTickables(this.voiceNotes);
      this.voiceAr.push(voice);
    }

    // Need to format for x position, then set y position before drawing dynamics.
    this.formatter = new VF.Formatter({ softmaxFactor: this.smoMeasure.customProportion, maxIterations: 5 });
    this.voiceAr.forEach((voice) => {
      this.formatter.joinVoices([voice]);
    });
  }
  format(voices) {
    let i = 0;
    const timestamp = new Date().valueOf();
    this.formatter.format(voices,
      this.smoMeasure.staffWidth -
      (this.smoMeasure.adjX + this.smoMeasure.adjRight + this.smoMeasure.padLeft) - 10);
    const iterations = this.smoMeasure.getFormattingIterations();
    for (i = 0; i < iterations; ++i) {
      this.formatter.tune();
    }
    layoutDebug.setTimestamp(layoutDebug.codeRegions.FORMAT, new Date().valueOf() - timestamp);
  }
  render() {
    var self = this;
    var group = this.context.openGroup();
    var mmClass = this.smoMeasure.getClassId();
    var j = 0;
    const timestamp = new Date().valueOf();
    try {
      group.classList.add(this.smoMeasure.attrs.id);
      group.classList.add(mmClass);
      group.id = this.smoMeasure.attrs.id;

      this.stave.draw();

      for (j = 0; j < this.voiceAr.length; ++j) {
        this.voiceAr[j].draw(this.context, this.stave);
      }

      this.vexBeamGroups.forEach((b) => {
        b.setContext(self.context).draw();
      });

      this.vexTuplets.forEach((tuplet) => {
        tuplet.setContext(self.context).draw();
      });
      // this._updateLyricDomSelectors();
      this.renderDynamics();
      // this.smoMeasure.adjX = this.stave.start_x - (this.smoMeasure.staffX);

      this.context.closeGroup();
      layoutDebug.setTimestamp(layoutDebug.codeRegions.RENDER, new Date().valueOf() - timestamp);

      const lbox = this.stave.getBoundingBox();
      this.smoMeasure.setBox({ x: lbox.x, y: lbox.y, width: lbox.w, height: lbox.h }, 'vxMeasure bounding box');
      this.smoMeasure.changed = false;
      this.rendered = true;
    } catch (exc) {
      console.warn('unable to render measure ' + this.smoMeasure.measureNumber.measureIndex);
      this.context.closeGroup();
    }
  }
}
;// ## Description:
//   Create a system of staves and draw music on it.
//
// ##  Options:
//  clef:'treble',
//  num_beats:num_beats,
//  timeSignature: '4/4',
//  smoMeasures: []
// eslint-disable-next-line no-unused-vars
class VxSystem {
  constructor(context, topY, lineIndex, score) {
    this.context = context;
    this.leftConnector = [null, null];
    this.lineIndex = lineIndex;
    this.score = score;
    this.maxStaffIndex = -1;
    this.maxSystemIndex = -1;
    this.width = -1;
    this.smoMeasures = [];
    this.vxMeasures = [];
    this.staves = [];
    this.endcaps = [];
    this.endings = [];
    this.box = {
      x: -1,
      y: -1,
      width: 0,
      height: 0
    };
    this.currentY = 0;
    this.topY = topY;
    this.clefWidth = 70;
    this.ys = [];
    this.measures = [];
    this.modifiers = [];
  }

  getVxMeasure(smoMeasure) {
    let i = 0;
    for (i = 0; i < this.vxMeasures.length; ++i) {
      const vm = this.vxMeasures[i];
      if (vm.smoMeasure.attrs.id === smoMeasure.attrs.id) {
        return vm;
      }
    }

    return null;
  }

  getVxNote(smoNote) {
    let i = 0;
    if (!smoNote) {
      return null;
    }
    for (i = 0; i < this.measures.length; ++i) {
      const mm = this.measures[i];
      if (mm.noteToVexMap[smoNote.attrs.id]) {
        return mm.noteToVexMap[smoNote.attrs.id];
      }
    }
    return null;
  }

  _updateChordOffsets(note) {
    var i = 0;
    for (i = 0; i < 3; ++i) {
      const chords = note.getLyricForVerse(i, SmoLyric.parsers.chord);
      chords.forEach((chord) => {
        const dom = $(this.context.svg).find(chord.selector)[0];
        if (dom) {
          dom.setAttributeNS('', 'transform', 'translate(' + chord.translateX + ' ' + (-1 * chord.translateY) + ')');
        }
      });
    }
  }
  _lowestYLowestVerse(lyrics) {
    let lowVerse = 5;
    let lowestY = 0;
    lyrics.forEach((lyric) => {
      if (lyric.logicalBox && lyric.verse < lowVerse) {
        lowestY = lyric.logicalBox.y;
        lowVerse = lyric.verse;
      }
      if (lyric.verse === lowVerse && lyric.logicalBox && lyric.logicalBox.y > lowestY) {
        lowestY = lyric.logicalBox.y;
      }
    });
    this.vxMeasures.forEach((vxMeasure) => {
      vxMeasure.smoMeasure.voices.forEach((voice) => {
        voice.notes.forEach((note) => {
          const lyrics = note.getTrueLyrics();
          if (lyrics.length) {
            const topVerse = lyrics.reduce((a, b) => a.verse < b.verse ? a : b);
            if (topVerse && topVerse.logicalBox) {
              const offset =  lowestY - topVerse.logicalBox.y;
              lyrics.forEach((lyric) => {
                lyric.adjY = offset + lyric.translateY;
              });
            }
          }
        });
      });
    });
  }

  // ### updateLyricOffsets
  // Adjust the y position for all lyrics in the line so they are even.
  // Also replace '-' with a longer dash do indicate 'until the next measure'
  /* global svgHelpers */
  updateLyricOffsets() {
    let i = 0;
    for (i = 0; i < this.score.staves.length; ++i) {
      const tmpI = i;
      const lyricsDash = [];
      const lyricHyphens = [];
      const lyricVerseMap = {};
      const lyrics = [];
      // is this necessary? They should all be from the current line
      const vxMeasures = this.vxMeasures.filter((vx) =>
        vx.smoMeasure.measureNumber.staffId === tmpI
      );

      // All the lyrics on this line
      // The vertical bounds on each line
      vxMeasures.forEach((mm) => {
        var smoMeasure = mm.smoMeasure;

        // Get lyrics from any voice.
        smoMeasure.voices.forEach((voice) => {
          voice.notes.forEach((note) => {
            this._updateChordOffsets(note);
            note.getTrueLyrics().forEach((ll) => {
              const hasLyric = ll.getText().length > 0 || ll.isHyphenated();
              if (hasLyric && !lyricVerseMap[ll.verse]) {
                lyricVerseMap[ll.verse] = [];
              }
              if (hasLyric && ll.logicalBox) {
                lyricVerseMap[ll.verse].push(ll);
                lyrics.push(ll);
              }
            });
          });
        });
      });
      // calculate y offset so the lyrics all line up
      this._lowestYLowestVerse(lyrics);
      const vkey = Object.keys(lyricVerseMap).sort((a, b) => a - b);
      vkey.forEach((verse) => {
        let hyphenLyric = null;
        const lastVerse = lyricVerseMap[verse][lyricVerseMap[verse].length - 1].attrs.id;
        lyricVerseMap[verse].forEach((ll) => {
          if (hyphenLyric !== null) {
            const x = ll.logicalBox.x - (ll.logicalBox.x -
              (hyphenLyric.logicalBox.x + hyphenLyric.logicalBox.width)) / 2;
            ll.hyphenX = x;
            lyricHyphens.push(ll);
          }
          if (ll.isHyphenated()) {
            if (ll.attrs.id === lastVerse) {
              // Last word on the system, place the hyphen after the word
              ll.hyphenX = ll.logicalBox.x + ll.logicalBox.width + ll.fontInfo.size / 2;
              lyricHyphens.push(ll);
            } else if (ll.getText().length) {
              // place the hyphen 1/2 between next word and this one.
              hyphenLyric = ll;
            }
          } else {
            hyphenLyric = null;
          }
        });
      });
      lyrics.forEach((lyric) => {
        const dom = $(this.context.svg).find(lyric.selector)[0];
        if (typeof(dom) !== 'undefined') {
          dom.setAttributeNS('', 'transform', 'translate(' + lyric.adjX + ' ' + lyric.adjY + ')');
          // Keep track of lyrics that are 'dash'
          if (lyric.isDash()) {
            lyricsDash.push(lyric);
          }
        }
      });
      lyricHyphens.forEach((lyric) => {
        const parent = $(this.context.svg).find(lyric.selector)[0];
        if (parent) {
          const text = document.createElementNS(svgHelpers.namespace, 'text');
          text.textContent = '-';
          text.setAttributeNS('', 'x', lyric.hyphenX);
          text.setAttributeNS('', 'y', lyric.logicalBox.y + (lyric.logicalBox.height * 2) / 3);
          const fontSize = lyric.fontInfo.size * 1.2;
          text.setAttributeNS('', 'fontSize', '' + fontSize + 'pt');
          parent.appendChild(text);
        }
      });
      lyricsDash.forEach((lyric) => {
        const parent = $(this.context.svg).find(lyric.selector)[0];
        if (parent) {
          const line = document.createElementNS(svgHelpers.namespace, 'line');
          const ymax = Math.round(lyric.logicalBox.y + lyric.logicalBox.height / 2);
          const offset = Math.round(lyric.logicalBox.width / 2);
          line.setAttributeNS('', 'x1', lyric.logicalBox.x - offset);
          line.setAttributeNS('', 'y1', ymax);
          line.setAttributeNS('', 'x2', lyric.logicalBox.x + lyric.logicalBox.width + offset);
          line.setAttributeNS('', 'y2', ymax);
          line.setAttributeNS('', 'stroke-width', 1);
          line.setAttributeNS('', 'fill', 'none');
          line.setAttributeNS('', 'stroke', '#999999');
          parent.appendChild(line);
          const text = $(this.context.svg).find(lyric.selector).find('text')[0];
          text.setAttributeNS('', 'fill', '#fff');
        }
      });
    }
  }

  // ### renderModifier
  // render a line-type modifier that is associated with a staff (e.g. slur)
  renderModifier(modifier, vxStart, vxEnd, smoStart, smoEnd) {
    let xoffset = 0;
    const setSameIfNull = (a, b) => {
      if (typeof(a) === 'undefined' || a === null) {
        return b;
      }
      return a;
    };
    // if it is split between lines, render one artifact for each line, with a common class for
    // both if it is removed.
    if (vxStart) {
      $(this.context.svg).find('g.' +  modifier.attrs.id).remove();
    }
    const artifactId = modifier.attrs.id + '-' + this.lineIndex;
    const group = this.context.openGroup();
    group.classList.add(modifier.attrs.id);
    group.classList.add(artifactId);
    if ((modifier.ctor === 'SmoStaffHairpin' && modifier.hairpinType === SmoStaffHairpin.types.CRESCENDO) ||
      (modifier.ctor === 'SmoStaffHairpin' && modifier.hairpinType === SmoStaffHairpin.types.DECRESCENDO)) {
      if (!vxStart && !vxEnd) {
        this.context.closeGroup();
        return svgHelpers.pointBox(1, 1);
      }
      vxStart = setSameIfNull(vxStart, vxEnd);
      vxEnd = setSameIfNull(vxEnd, vxStart);
      const hairpin = new VF.StaveHairpin({
        first_note: vxStart,
        last_note: vxEnd
      }, modifier.hairpinType);
      hairpin.setRenderOptions({
        height: modifier.height,
        y_shift: modifier.yOffset,
        left_shift_px: modifier.xOffsetLeft,
        right_shift_px: modifier.xOffsetRight
      });
      hairpin.setContext(this.context).setPosition(modifier.position).draw();
    } else if (modifier.ctor === 'SmoSlur') {
      const lyric = smoStart.note.longestLyric();
      if (lyric && lyric.getText()) {
        // If there is a lyric, the bounding box of the start note is stretched to the right.
        // slide the slur left, and also make it a bit wider.
        const xtranslate = (-1 * lyric.getText().length * 6);
        xoffset += (xtranslate / 2) - SmoSlur.defaults.xOffset;
      }
      const curve = new VF.Curve(vxStart, vxEnd,
        {
          thickness: modifier.thickness,
          x_shift: modifier.xOffset,
          y_shift: modifier.yOffset,
          spacing: modifier.spacing,
          cps: modifier.controlPoints,
          invert: modifier.invert,
          position: modifier.position
        });
      curve.setContext(this.context).draw();
    } else if (modifier.ctor === 'SmoTie') {
      if (modifier.lines.length > 0) {
        // Hack: if a chord changed, the ties may no longer be valid.  We should check
        // this when it changes.
        modifier.checkLines(smoStart, smoEnd);
        const fromLines = modifier.lines.map((ll) => ll.from);
        const toLines = modifier.lines.map((ll) => ll.to);
        const tie = new VF.StaveTie({
          first_note: vxStart,
          last_note: vxEnd,
          first_indices: fromLines,
          last_indices: toLines
        });
        Vex.Merge(tie.render_options, modifier.vexOptions);
        tie.setContext(this.context).draw();
      }
    }

    this.context.closeGroup();
    if (xoffset) {
      const slurBox = $('.' + artifactId)[0];
      svgHelpers.translateElement(slurBox, xoffset, 0);
    }
    return svgHelpers.smoBox(group.getBoundingClientRect());
  }

  renderEndings() {
    let j = 0;
    for (j = 0; j < this.smoMeasures.length; ++j) {
      const smoMeasure = this.smoMeasures[j];
      if (smoMeasure.svg.rowInSystem > 0) {
        continue;
      }
      const staffId = smoMeasure.measureNumber.staffId;
      const endings = smoMeasure.getNthEndings();
      endings.forEach((ending) => {
        $(this.context.svg).find('g.' + ending.attrs.id).remove();
        const group = this.context.openGroup(null, ending.attrs.id);
        const voAr = [];
        group.classList.add(ending.attrs.id);
        group.classList.add(ending.endingId);
        let i = 0;

        for (i = ending.startBar; i <= ending.endBar; ++i) {
          const mix = i;
          const endMeasure = this.getMeasureByIndex(mix, staffId);
          if (!endMeasure) {
            continue;
          }
          voAr.push(endMeasure);
          const vxMeasure = this.getVxMeasure(endMeasure);
          const vtype = ending.toVexVolta(endMeasure.measureNumber.measureNumber);
          const vxVolta = new VF.Volta(vtype, ending.number, endMeasure.staffX + ending.xOffsetStart, ending.yOffset);
          vxMeasure.stave.modifiers.push(vxVolta);
          vxVolta.setContext(this.context).draw(vxMeasure.stave, -1 * ending.xOffsetEnd);
        }
        this.context.closeGroup();
        ending.renderedBox = svgHelpers.smoBox(group.getBoundingClientRect());
        ending.logicalBox = svgHelpers.clientToLogical(this.context.svg, ending.renderedBox);

        // Adjust real height of measure to match volta height
        voAr.forEach((mm) => {
          const delta =  mm.logicalBox.y - ending.logicalBox.y;
          if (delta > 0) {
            mm.setBox(svgHelpers.boxPoints(
              mm.logicalBox.x, mm.logicalBox.y - delta, mm.logicalBox.width, mm.logicalBox.height + delta),
            'vxSystem adjust for volta');
          }
        });
      });
    }
  }

  getMeasureByIndex(measureIndex, staffId) {
    let i = 0;
    for (i = 0; i < this.smoMeasures.length; ++i) {
      const mm = this.smoMeasures[i];
      if (measureIndex === mm.measureNumber.measureNumber && staffId === mm.measureNumber.staffId) {
        return mm;
      }
    }
    return null;
  }

  // ## renderMeasure
  // ## Description:
  // Create the graphical (VX) notes and render them on svg.  Also render the tuplets and beam
  // groups
  renderMeasure(smoMeasure, measureMapper, printing) {
    let brackets = false;
    const staff = this.score.staves[smoMeasure.measureNumber.staffId];
    const staffId = staff.staffId;
    const systemIndex = smoMeasure.measureNumber.systemIndex;
    const selection = SmoSelection.measureSelection(this.score, staff.staffId, smoMeasure.measureNumber.measureIndex);
    this.smoMeasures.push(smoMeasure);
    if (this.staves.length <= staffId) {
      this.staves.push(staff);
    }

    const vxMeasure = new VxMeasure(this.context, { selection, printing });

    // create the vex notes, beam groups etc. for the measure
    vxMeasure.preFormat();
    this.vxMeasures.push(vxMeasure);

    const lastStaff = (staffId === this.score.staves.length - 1);
    const smoGroupMap = {};

    // If this is the last staff in the column, render the column with justification
    if (lastStaff) {
      this.vxMeasures.forEach((vv) => {
        if (!vv.rendered) {
          const systemGroup = this.score.getSystemGroupForStaff(vv.selection);
          const justifyGroup = (systemGroup && vv.smoMeasure.getAutoJustify()) ? systemGroup.attrs.id : vv.selection.staff.attrs.id;
          if (!smoGroupMap[justifyGroup]) {
            smoGroupMap[justifyGroup] = { firstMeasure: vv, voices: [] };
          }
          smoGroupMap[justifyGroup].voices =
            smoGroupMap[justifyGroup].voices.concat(vv.voiceAr);
        }
      });
    }
    const keys = Object.keys(smoGroupMap);
    keys.forEach((key) => {
      smoGroupMap[key].firstMeasure.format(smoGroupMap[key].voices);
    });
    if (lastStaff) {
      this.vxMeasures.forEach((vv) => {
        if (!vv.rendered) {
          vv.render();
          // unit test codes don't have tracker.
          if (measureMapper) {
            const tmpStaff = this.staves.find((ss) => ss.staffId === vv.smoMeasure.measureNumber.staffId);
            measureMapper.mapMeasure(tmpStaff, vv.smoMeasure, printing);
          }
        }
      });
    }

    // Keep track of the y coordinate for the nth staff
    const renderedConnection = {};

    if (systemIndex === 0 && lastStaff) {
      $(this.context.svg).find('g.lineBracket-' + this.lineIndex).remove();
      const group = this.context.openGroup();
      group.classList.add('lineBracket-' + this.lineIndex);
      group.classList.add('lineBracket');
      this.vxMeasures.forEach((vv) => {
        const systemGroup = this.score.getSystemGroupForStaff(vv.selection);
        if (systemGroup && !renderedConnection[systemGroup.attrs.id]) {
          renderedConnection[systemGroup.attrs.id] = 1;
          const startSel = this.vxMeasures[systemGroup.startSelector.staff];
          const endSel = this.vxMeasures[systemGroup.endSelector.staff];
          if (startSel && endSel) {
            const c1 = new VF.StaveConnector(startSel.stave, endSel.stave)
              .setType(systemGroup.leftConnectorVx());
            c1.setContext(this.context).draw();
            brackets = true;
          }
        }
      });

      if (!brackets && this.vxMeasures.length > 1)  {
        const c2 = new VF.StaveConnector(this.vxMeasures[0].stave, this.vxMeasures[this.vxMeasures.length - 1].stave,
          VF.StaveConnector.type.SINGLE_LEFT);
        c2.setContext(this.context).draw();
      }
      this.context.closeGroup();
    } else if (lastStaff && smoMeasure.measureNumber.measureIndex + 1 < staff.measures.length) {
      if (staff.measures[smoMeasure.measureNumber.measureIndex + 1].measureNumber.systemIndex === 0) {
        const endMeasure = vxMeasure;
        const startMeasure = this.vxMeasures.find((vv) => vv.selection.selector.staff === 0 &&
          vv.selection.selector.measure === vxMeasure.selection.selector.measure);
        if (endMeasure && startMeasure) {
          $(this.context.svg).find('g.endBracket-' + this.lineIndex).remove();
          const group = this.context.openGroup();
          group.classList.add('endBracket-' + this.lineIndex);
          group.classList.add('endBracket');
          const c2 = new VF.StaveConnector(startMeasure.stave, endMeasure.stave)
            .setType(VF.StaveConnector.type.SINGLE_RIGHT);
          c2.setContext(this.context).draw();
          this.context.closeGroup();
        }
      }
    }

    // keep track of left-hand side for system connectors
    if (systemIndex === 0) {
      if (staffId === 0) {
        this.leftConnector[0] = vxMeasure.stave;
      } else if (staffId > this.maxStaffIndex) {
        this.maxStaffIndex = staffId;
        this.leftConnector[1] = vxMeasure.stave;
      }
    } else if (smoMeasure.measureNumber.systemIndex > this.maxSystemIndex) {
      this.endcaps = [];
      this.endcaps.push(vxMeasure.stave);
      this.maxSystemIndex = smoMeasure.measureNumber.systemIndex;
    } else if (smoMeasure.measureNumber.systemIndex === this.maxSystemIndex) {
      this.endcaps.push(vxMeasure.stave);
    }
    this.measures.push(vxMeasure);
  }
}
;// This is a WIP to handle parts, instruments, etc.
// A score is a set of staves with notes.  A composition can tie scores together
// for purposes of part extraction, playback data, layout etc.
// ## Places to deserialize scores:
// .  controller/scoreFromQueryString
// .  fileDialog.js/SuiLoadFileDialog.commit
// . menus.js/SuiFileMenu.selection
// there is a reference to deserialize in undo.js but that is probably OK to stay.
class SmoComposition {

    constructor(parameters) {
        this.masterScore = {};
        this.staveScoreMap = {};
        this.displayScore = null;
        this.layoutNotifier = parameters.layoutNotifier;
        this.title = 'Beautiful Smoosic';
    }
    setMasterAsDisplayScore() {
        this.displayScore = this.masterScore;
    }
    setPartScore(staveId) {
        var staff = this.masterScore.staves[staffId];
        if (!staff) {
            this.setMasterAsDisplayScore();
        }
        if (!staveScoreMap[staff]) {

        }
    }

    static serialize() {

    }

}
;// ## SmoMeasure - data for a measure of music
// Many rules of musical engraving are enforced at a measure level, e.g. the duration of
// notes, accidentals, etc.
// ### See Also:
// Measures contain *notes*, *tuplets*, and *beam groups*.  So see `SmoNote`, etc.
// Measures are contained in staves, see also `SystemStaff.js`
// ## SmoMeasure Methods:
// eslint-disable-next-line no-unused-vars
class SmoMeasure {
  constructor(params) {
    this.tuplets = [];
    this.svg = {};
    this.beamGroups = [];
    this.modifiers = [];
    this.pageGap = 0;
    this.changed = true;
    this.prevY = 0;
    this.prevX = 0;
    this.padLeft = 0;
    this.svg.staffWidth = 200;
    this.svg.staffX = 0;
    this.svg.staffY = 0;
    this.svg.history = [];
    this.svg.logicalBox = {};
    this.svg.yTop = 0;

    const defaults = SmoMeasure.defaults;

    smoSerialize.serializedMerge(SmoMeasure.defaultAttributes, defaults, this);
    smoSerialize.serializedMerge(SmoMeasure.defaultAttributes, params, this);
    this.voices = params.voices ? params.voices : [];
    this.tuplets = params.tuplets ? params.tuplets : [];
    this.modifiers = params.modifiers ? params.modifiers : defaults.modifiers;

    this.setDefaultBarlines();

    this.keySignature = smoMusic.vexKeySigWithOffset(this.keySignature, this.transposeIndex);

    if (!this.attrs) {
      this.attrs = {
        id: VF.Element.newID(),
        type: 'SmoMeasure'
      };
    } else {
      // inherit attrs id for deserialized
    }
  }

  // ### defaultAttributes
  // attributes that are to be serialized for a measure.
  static get defaultAttributes() {
    return [
      'timeSignature', 'keySignature', 'systemBreak', 'pageBreak',
      'measureNumber',
      'activeVoice', 'clef', 'transposeIndex',
      'adjX', 'customStretch', 'customProportion', 'padLeft', 'padRight', 'rightMargin',
      'formattingIterations', 'autoJustify'
    ];
  }

  static get formattingOptions() {
    return ['customStretch', 'customProportion', 'autoJustify', 'formattingIterations', 'systemBreak',
      'pageBreak', 'padLeft'];
  }
  static get systemOptions() {
    return ['systemBreak', 'pageBreak'];
  }
  static get columnMappedAttributes() {
    return ['timeSignature', 'keySignature', 'tempo'];
  }
  static get serializableAttributes() {
    const rv = [];
    SmoMeasure.defaultAttributes.forEach((attr) => {
      if (SmoMeasure.columnMappedAttributes.indexOf(attr) < 0) {
        rv.push(attr);
      }
    });
    return rv;
  }

  static get defaults() {
    if (typeof(SmoMeasure._defaults) !== 'undefined') {
      return SmoMeasure._defaults;
    }
    // var noteDefault = SmoMeasure.defaultVoice44;
    const modifiers = [];
    modifiers.push(new SmoBarline({
      position: SmoBarline.positions.start,
      barline: SmoBarline.barlines.singleBar
    }));
    modifiers.push(new SmoBarline({
      position: SmoBarline.positions.end,
      barline: SmoBarline.barlines.singleBar
    }));
    modifiers.push(new SmoRepeatSymbol({
      position: SmoRepeatSymbol.positions.start,
      symbol: SmoRepeatSymbol.symbols.None
    }));

    SmoMeasure._defaults = {
      timeSignature: '4/4',
      keySignature: 'C',
      canceledKeySignature: null,
      adjX: 0,
      pageBreak: false,
      systemBreak: false,
      adjRight: 0,
      padRight: 10,
      padLeft: 0,
      tuplets: [],
      transposeIndex: 0,
      customStretch: 0,
      customProportion: 12,
      modifiers,
      autoJustify: true,
      formattingIterations: 0,
      rightMargin: 2,
      staffY: 40,
      // bars: [1, 1], // follows enumeration in VF.Barline
      measureNumber: {
        localIndex: 0,
        systemIndex: 0,
        measureNumber: 0,
        staffId: 0
      },
      clef: 'treble',
      changed: true,
      forceClef: false,
      forceKeySignature: false,
      forceTimeSignature: false,
      voices: [],
      activeVoice: 0,
      tempo: new SmoTempoText()
    };
    return SmoMeasure._defaults;
  }

  // ### serializeColumnMapped
  // Some measure attributes that apply to the entire column are serialized
  // separately.  Serialize those attributes, but only add them to the
  // hash if they already exist for an earlier measure
  serializeColumnMapped(attrColumnHash, attrCurrentValue) {
    let curValue = {};
    SmoMeasure.columnMappedAttributes.forEach((attr) => {
      if (this[attr]) {
        curValue = this[attr];
        if (!attrColumnHash[attr]) {
          attrColumnHash[attr] = {};
          attrCurrentValue[attr] = {};
        }
        const curAttrHash  = attrColumnHash[attr];
        // If this is key signature, make sure we normalize to concert pitch
        // from instrument pitch
        if (attr === 'keySignature') {
          curValue = smoMusic.vexKeySigWithOffset(curValue, -1 * this.transposeIndex);
        }
        if (this[attr].ctor && this[attr].ctor === 'SmoTempoText') {
          if (this[attr].compare(attrCurrentValue[attr]) === false) {
            curAttrHash[this.measureNumber.measureIndex] = curValue;
            attrCurrentValue[attr] = curValue;
          }
        } else if (attrCurrentValue[attr] !== curValue) {
          curAttrHash[this.measureNumber.measureIndex] = curValue;
          attrCurrentValue[attr] = curValue;
        }
      } // else attr doesn't exist in this measure
    });
  }

  // ### serialize
  // Convert this measure object to a JSON object, recursively serializing all the notes,
  // note modifiers, etc.
  serialize() {
    const params = {};
    let ser = true;
    smoSerialize.serializedMergeNonDefault(SmoMeasure.defaults, SmoMeasure.serializableAttributes, this, params);
    params.tuplets = [];
    params.voices = [];
    params.modifiers = [];

    this.tuplets.forEach((tuplet) => {
      params.tuplets.push(tuplet.serialize());
    });

    this.voices.forEach((voice) => {
      const obj = {
        notes: []
      };
      voice.notes.forEach((note) => {
        obj.notes.push(note.serialize());
      });
      params.voices.push(obj);
    });

    this.modifiers.forEach((modifier) => {
      ser = true;
      /* don't serialize default modifiers */
      if (modifier.ctor === 'SmoBarline' && modifier.position === SmoBarline.positions.start &&
        modifier.barline === SmoBarline.barlines.singleBar) {
        ser = false;
      } else if (modifier.ctor === 'SmoBarline' && modifier.position === SmoBarline.positions.end
        && modifier.barline === SmoBarline.barlines.singleBar) {
        ser = false;
      } else if (modifier.ctor === 'SmoTempoText') {
        // we don't save tempo text as a modifier anymore
        ser = false;
      } else if (modifier.ctor === 'SmoRepeatSymbol' && modifier.position === SmoRepeatSymbol.positions.start
        && modifier.symbol === SmoRepeatSymbol.symbols.None) {
        ser = false;
      }
      if (ser) {
        params.modifiers.push(modifier.serialize());
      }
    });
    return params;
  }

  // ### deserialize
  // restore a serialized measure object.  Usually called as part of deserializing a score,
  // but can also be used to restore a measure due to an undo operation.
  static deserialize(jsonObj) {
    let j = 0;
    let i = 0;
    const voices = [];
    const noteSum = [];
    for (j = 0; j < jsonObj.voices.length; ++j) {
      const voice = jsonObj.voices[j];
      const notes = [];
      voices.push({
        notes
      });
      for (i = 0; i < voice.notes.length; ++i) {
        const noteParams = voice.notes[i];
        const smoNote = SmoNote.deserialize(noteParams);
        notes.push(smoNote);
        noteSum.push(smoNote);
      }
    }

    const tuplets = [];
    for (j = 0; j < jsonObj.tuplets.length; ++j) {
      const tupJson = jsonObj.tuplets[j];
      const noteAr = noteSum.filter((nn) =>
        nn.isTuplet && nn.tuplet.id === tupJson.attrs.id);

      // Bug fix:  A tuplet with no notes may be been overwritten
      // in a copy/paste operation
      if (noteAr.length > 0) {
        tupJson.notes = noteAr;
        const tuplet = new SmoTuplet(tupJson);
        tuplets.push(tuplet);
      }
    }

    const modifiers = [];
    jsonObj.modifiers.forEach((modParams) => {
      const ctor = eval(modParams.ctor);
      const modifier = new ctor(modParams);
      modifiers.push(modifier);
    });

    const params = {
      voices,
      tuplets,
      beamGroups: [],
      modifiers
    };

    smoSerialize.serializedMerge(SmoMeasure.defaultAttributes, jsonObj, params);
    const rv = new SmoMeasure(params);
    if (jsonObj.tempo) {
      rv.tempo = new SmoTempoText(jsonObj.tempo);
    }

    // Handle migration for measure-mapped parameters
    rv.modifiers.forEach((mod) => {
      if (mod.ctor === 'SmoTempoText') {
        rv.tempo = mod;
      }
    });
    return rv;
  }

  // ### defaultPitchForClef
  // Accessor for clef objects, which are set at a measure level.
  // #### TODO: learn what all these clefs are
  static get defaultPitchForClef() {
    return {
      'treble': {
        letter: 'b',
        accidental: 'n',
        octave: 4
      },
      'bass': {
        letter: 'd',
        accidental: 'n',
        octave: 3
      },
      'tenor': {
        letter: 'a',
        accidental: 'n',
        octave: 3
      },
      'alto': {
        letter: 'c',
        accidental: 'n',
        octave: 4
      },
      'soprano': {
        letter: 'b',
        accidental: 'n',
        octave: 4
      },
      'percussion': {
        letter: 'b',
        accidental: 'n',
        octave: 4
      },
      'mezzo-soprano': {
        letter: 'b',
        accidental: 'n',
        octave: 4
      },
      'baritone-c': {
        letter: 'b',
        accidental: 'n',
        octave: 3
      },
      'baritone-f': {
        letter: 'e',
        accidental: 'n',
        octave: 3
      },
      'subbass': {
        letter: 'd',
        accidental: '',
        octave: 2
      },
      'french': {
        letter: 'b',
        accidental: '',
        octave: 4
      } // no idea
    };
  }
  static set emptyMeasureNoteType(tt) {
    SmoMeasure._emptyMeasureNoteType = tt;
  }
  static get emptyMeasureNoteType() {
    SmoMeasure._emptyMeasureNoteType = SmoMeasure._emptyMeasureNoteType ? SmoMeasure._emptyMeasureNoteType : 'r';
    return SmoMeasure._emptyMeasureNoteType;
  }
  // ### getDefaultNotes
  // Get a measure full of default notes for a given timeSignature/clef.
  // returns 8th notes for triple-time meters, etc.
  static getDefaultNotes(params) {
    let beamBeats = 0;
    let beats = 0;
    let i = 0;
    let ticks = {
      numerator: 4096,
      denominator: 1,
      remainder: 0
    };
    if (params === null) {
      params = {};
    }
    params.timeSignature = params.timeSignature ? params.timeSignature : '4/4';
    params.clef = params.clef ? params.clef : 'treble';
    const meterNumbers = params.timeSignature.split('/').map(number => parseInt(number, 10));
    beamBeats = ticks.numerator;
    beats = meterNumbers[0];
    if (meterNumbers[1] === 8) {
      ticks = {
        numerator: 2048,
        denominator: 1,
        remainder: 0
      };
      if (meterNumbers[0] % 3 === 0) {
        ticks.numerator = 2048 * 3;
        beats = meterNumbers[0] / 3;
      }
      beamBeats = 2048 * 3;
    }
    const pitches =
      JSON.parse(JSON.stringify(SmoMeasure.defaultPitchForClef[params.clef]));
    const rv = [];

    // Treat 2/2 like 4/4 time.
    if (meterNumbers[1] === 2) {
      beats = beats * 2;
    }

    for (i = 0; i < beats; ++i) {
      const note = new SmoNote({
        clef: params.clef,
        pitches: [pitches],
        ticks,
        timeSignature: params.timeSignature,
        beamBeats,
        noteType: SmoMeasure.emptyMeasureNoteType
      });
      rv.push(note);
    }
    return rv;
  }

  // ### getDefaultMeasure
  // For create the initial or new measure, get a measure with notes.
  static getDefaultMeasure(params) {
    const obj = {};
    smoSerialize.serializedMerge(SmoMeasure.defaultAttributes, SmoMeasure.defaults, obj);
    smoSerialize.serializedMerge(SmoMeasure.defaultAttributes, params, obj);
    // Don't copy column-formatting options to new measure in new column
    smoSerialize.serializedMerge(SmoMeasure.formattingOptions, SmoMeasure.defaults, obj);
    // Don't redisplay tempo for a new measure
    const rv = new SmoMeasure(obj);
    if (rv.tempo && rv.tempo.display) {
      rv.tempo.display = false;
    }
    return rv;
  }

  // ### SmoMeasure.getDefaultMeasureWithNotes
  // Get a new measure with the appropriate notes for the supplied clef, instrument
  static getDefaultMeasureWithNotes(params) {
    var measure = SmoMeasure.getDefaultMeasure(params);
    measure.voices.push({
      notes: SmoMeasure.getDefaultNotes(params)
    });
    // fix a bug.
    // new measures only have 1 voice, make sure active voice is 0
    measure.activeVoice = 0;
    return measure;
  }

  static get defaultVoice44() {
    return SmoMeasure.getDefaultNotes({
      clef: 'treble',
      timeSignature: '4/4'
    });
  }

  setDefaultBarlines() {
    if (!this.getStartBarline()) {
      this.modifiers.push(new SmoBarline({
        position: SmoBarline.positions.start,
        barline: SmoBarline.barlines.singleBar
      }));
    }
    if (!this.getEndBarline()) {
      this.modifiers.push(new SmoBarline({
        position: SmoBarline.positions.end,
        barline: SmoBarline.barlines.singleBar
      }));
    }
  }

  setForcePageBreak(val) {
    this.pageBreak = val;
  }

  setForceSystemBreak(val) {
    this.systemBreak = val;
  }

  setAutoJustify(val) {
    this.autoJustify = val;
  }
  getAutoJustify() {
    return this.autoJustify;
  }
  getForceSystemBreak() {
    return this.systemBreak;
  }

  getForcePageBreak() {
    return this.pageBreak;
  }

  // ###   SVG mixins
  // We store some rendering data in the instance for UI mapping.
  get staffWidth() {
    return this.svg.staffWidth;
  }

  setWidth(width, description) {
    if (layoutDebug.flagSet('measureHistory')) {
      this.svg.history.push('setWidth ' + this.staffWidth + '=> ' + width + ' ' + description);
    }
    if (isNaN(width)) {
      throw ('NAN in setWidth');
    }
    this.svg.staffWidth = width;
  }

  get staffX() {
    return this.svg.staffX;
  }

  setX(x, description) {
    if (isNaN(x)) {
      throw ('NAN in setX');
    }
    layoutDebug.measureHistory(this, 'staffX', x, description);
    this.svg.staffX = Math.round(x);
  }

  get staffY() {
    return this.svg.staffY;
  }

  setY(y, description) {
    if (isNaN(y)) {
      throw ('NAN in setY');
    }
    layoutDebug.measureHistory(this, 'staffY', y, description);
    this.svg.staffY = Math.round(y);
  }

  get logicalBox() {
    return typeof(this.svg.logicalBox.x) === 'number' ? this.svg.logicalBox : null;
  }

  get yTop() {
    return this.svg.yTop;
  }

  setYTop(y, description) {
    layoutDebug.measureHistory(this, 'yTop', y, description);
    this.svg.yTop = y;
  }

  deleteLogicalBox(description) {
    this.svg.logicalBox = {};
    this.svg.history.push('delete box ' + description);
  }

  setBox(box, description) {
    layoutDebug.measureHistory(this, 'logicalBox', box, description);
    this.svg.logicalBox = svgHelpers.smoBox(box);
  }

  saveUnjustifiedWidth() {
    this.svg.unjustifiedWidth = this.svg.staffWidth;
  }

  // ### getClassId
  // create a identifier unique to this measure index so it can be easily removed.
  getClassId() {
    return 'mm-' + this.measureNumber.staffId + '-' + this.measureNumber.measureIndex;
  }

  pickupMeasure(duration) {
    const timeSig = this.timeSignature;
    const proto = SmoMeasure.deserialize(this.serialize());
    proto.attrs.id =  VF.Element.newID();
    const note = proto.voices[0].notes[0];
    proto.voices = [];
    note.pitches = [note.pitches[0]];
    note.ticks.numerator = duration;
    note.makeRest();
    proto.voices.push({ notes: [note] });
    proto.timeSignature = timeSig;
    return proto;
  }

  // ### getRenderedNote
  // The renderer puts a mapping between rendered svg groups and
  // the logical notes in SMO.  The UI needs this mapping to be interactive,
  // figure out where a note is rendered, what its bounding box is, etc.
  getRenderedNote(id) {
    let j = 0;
    let i = 0;
    for (j = 0; j < this.voices.length; ++j) {
      const voice = this.voices[j];
      for (i = 0; i < voice.notes.length; ++i) {
        const note = voice.notes[i];
        if (note.renderId === id) {
          return {
            smoNote: note,
            voice: j,
            tick: i
          };
        }
      }
    }
    return null;
  }

  getNotes() {
    return this.voices[this.activeVoice].notes;
  }

  getActiveVoice() {
    return this.activeVoice;
  }

  setActiveVoice(vix) {
    if (vix >= 0 && vix < this.voices.length) {
      this.activeVoice = vix;
    }
  }

  tickmapForVoice(voiceIx) {
    const tickmap = new smoTickIterator(this, { voice: voiceIx });
    tickmap.iterate(smoTickIterator.nullActor, this);
    return tickmap;
  }

  // ### createMeasureTickmaps
  // A tickmap is a map of notes to ticks for the measure.  It is speciifc per-voice
  // since each voice may have different numbers of ticks.  The accidental map is
  // overall since accidentals in one voice apply to accidentals in the other
  // voices.  So we return the tickmaps and the overall accidental map.
  createMeasureTickmaps() {
    let i = 0;
    const tickmapArray = [];
    const accidentalMap = {};
    for (i = 0; i < this.voices.length; ++i) {
      tickmapArray.push(this.tickmapForVoice(i));
    }

    for (i = 0; i < this.voices.length; ++i) {
      const tickmap = tickmapArray[i];
      const durationKeys = Object.keys(tickmap.durationAccidentalMap);

      durationKeys.forEach((durationKey) => {
        if (!accidentalMap[durationKey]) {
          accidentalMap[durationKey] = tickmap.durationAccidentalMap[durationKey];
        } else {
          const amap = accidentalMap[durationKey];
          const pitchKeys = Object.keys(tickmap.durationAccidentalMap[durationKey]);
          pitchKeys.forEach((pitchKey) => {
            if (!amap[pitchKey]) {
              amap[pitchKey] = tickmap.durationAccidentalMap[durationKey][pitchKey];
            }
          });
        }
      });
    }
    const accidentalArray = [];
    Object.keys(accidentalMap).forEach((durationKey) => {
      accidentalArray.push({ duration: durationKey, pitches: accidentalMap[durationKey] });
    });
    return {
      tickmaps: tickmapArray,
      accidentalMap,
      accidentalArray
    };
  }
  // ### createRestNoteWithDuration
  // pad some duration of music with rests.
  static createRestNoteWithDuration(duration, clef) {
    const pitch = JSON.parse(JSON.stringify(
      SmoMeasure.defaultPitchForClef[clef]));
    const note = new SmoNote({
      pitches: [pitch], noteType: 'r', hidden: true,
      ticks: { numerator: duration, denominator: 1, remainder: 0 } });
    return note;
  }

  getMaxTicksVoice() {
    let i = 0;
    let max = 0;
    for (i = 0; i < this.voices.length; ++i) {
      const voiceTicks = this.getTicksFromVoice(i);
      max = Math.max(voiceTicks, max);
    }
    return max;
  }

  getTicksFromVoice(voice) {
    let ticks = 0;
    this.voices[voice].notes.forEach((note) => {
      ticks += note.tickCount;
    });
    return ticks;
  }

  isPickup() {
    const ticks = this.getTicksFromVoice(0);
    const goal = smoMusic.timeSignatureToTicks(this.timeSignature);
    return (ticks < goal);
  }

  // ### getDynamicMap
  // ### Description:
  // returns the dynamic text for each tick index.  If
  // there are no dynamics, the empty array is returned.
  getDynamicMap() {
    const rv = [];
    let hasDynamic = false;
    this.voices.forEach((voice) => {
      voice.notes.forEach((note) => {
        if (note.dynamicText) {
          rv.push({
            note,
            text: note.dynamicText
          });
          hasDynamic = true;
        } else {
          rv.push({
            note,
            text: ''
          });
        }
      });
    });

    if (hasDynamic) {
      return rv;
    }
    return [];
  }

  clearBeamGroups() {
    this.beamGroups = [];
  }

  // ### updateLyricFont
  // Update the lyric font, which is the same for all lyrics.
  setLyricFont(fontInfo) {
    this.voices.forEach((voice) => {
      voice.notes.forEach((note) => {
        note.setLyricFont(fontInfo);
      });
    });
  }
  setLyricAdjustWidth(adjustNoteWidth) {
    this.voices.forEach((voice) => {
      voice.notes.forEach((note) => {
        note.setLyricAdjustWidth(adjustNoteWidth);
      });
    });
  }

  setChordAdjustWidth(adjustNoteWidth) {
    this.voices.forEach((voice) => {
      voice.notes.forEach((note) => {
        note.setChordAdjustWidth(adjustNoteWidth);
      });
    });
  }
  setFormattingIterations(val) {
    this.formattingIterations = val;
  }

  getFormattingIterations() {
    return this.formattingIterations;
  }

  // ### updateLyricFont
  // Update the lyric font, which is the same for all lyrics.
  setChordFont(fontInfo) {
    this.voices.forEach((voice) => {
      voice.notes.forEach((note) => {
        note.setChordFont(fontInfo);
      });
    });
  }

  // ### tuplet methods.
  //
  // #### tupletNotes
  tupletNotes(tuplet) {
    let j = 0;
    let i = 0;
    let notes = [];
    for (j = 0; j < this.voices.length; ++j) {
      notes = this.voices[j].notes;
      for (i = 0; i < notes.length; ++i) {
        if (notes[i].tuplet && notes[i].tuplet.id === tuplet.attrs.id) {
          notes.push(notes[i]);
        }
      }
    }
    return notes;
  }

  // #### tupletIndex
  // return the index of the given tuplet
  tupletIndex(tuplet) {
    let j = 0;
    let i = 0;
    for (j = 0; j < this.voices.length; ++j) {
      const notes = this.voices[j].notes;
      for (i = 0; i < notes.length; ++i) {
        if (notes[i].tuplet && notes[i].tuplet.id === tuplet.attrs.id) {
          return i;
        }
      }
    }
    return -1;
  }

  // #### getTupletForNote
  // Finds the tuplet for a given note, or null if there isn't one.
  getTupletForNote(note) {
    let i = 0;
    if (!note.isTuplet) {
      return null;
    }
    for (i = 0; i < this.tuplets.length; ++i) {
      const tuplet = this.tuplets[i];
      if (tuplet.attrs.id === note.tuplet.id) {
        return tuplet;
      }
    }
    return null;
  }

  removeTupletForNote(note) {
    let i = 0;
    const tuplets = [];
    for (i = 0; i < this.tuplets.length; ++i) {
      const tuplet = this.tuplets[i];
      if (note.tuplet.id !== tuplet.attrs.id) {
        tuplets.push(tuplet);
      }
    }
    this.tuplets = tuplets;
  }

  // ### populateVoice
  // Create a new voice in this measure, and populate it with the default note
  // for this measure/key/clef
  populateVoice(index) {
    if (index !==  this.voices.length) {
      return;
    }
    this.voices.push({ notes: SmoMeasure.getDefaultNotes(this) });
    this.activeVoice = index;
    this.changed = true;
  }

  // ### measure modifier mixins
  _addSingletonModifier(name, parameters) {
    const ctor = eval(name);
    const ar = this.modifiers.filter(obj => obj.attrs.type !== name);
    this.modifiers = ar;
    this.modifiers.push(new ctor(parameters));
  }
  _removeSingletonModifier(name) {
    const ar = this.modifiers.filter(obj => obj.attrs.type !== name);
    this.modifiers = ar;
  }

  _getSingletonModifier(name) {
    return this.modifiers.find(obj => obj.attrs.type === name);
  }

  addRehearsalMark(parameters) {
    this._addSingletonModifier('SmoRehearsalMark', parameters);
  }
  removeRehearsalMark() {
    this._removeSingletonModifier('SmoRehearsalMark');
  }
  getRehearsalMark() {
    return this._getSingletonModifier('SmoRehearsalMark');
  }
  getModifiersByType(type) {
    return this.modifiers.filter((mm) => type === mm.attrs.type);
  }

  addTempo(params) {
    this.tempo = new SmoTempoText(params);
  }
  removeTempo() {
    this.tempo = new SmoTempoText();
  }
  getTempo() {
    if (typeof(this.tempo) === 'undefined') {
      this.tempo = new SmoTempoText();
    }
    return this.tempo;
  }
  addMeasureText(mod) {
    var exist = this.modifiers.filter((mm) =>
      mm.attrs.id === mod.attrs.id
    );
    if (exist.length) {
      return;
    }
    this.modifiers.push(mod);
  }

  getMeasureText() {
    return this.modifiers.filter(obj => obj.ctor === 'SmoMeasureText');
  }

  removeMeasureText(id) {
    var ar = this.modifiers.filter(obj => obj.attrs.id !== id);
    this.modifiers = ar;
  }

  setRepeatSymbol(rs) {
    const ar = [];
    let toAdd = true;
    const exSymbol = this.getRepeatSymbol();
    if (exSymbol && exSymbol.symbol === rs.symbol) {
      toAdd = false;
    }
    this.modifiers.forEach((modifier) => {
      if (modifier.ctor !== 'SmoRepeatSymbol') {
        ar.push(modifier);
      }
    });
    this.modifiers = ar;
    if (toAdd) {
      ar.push(rs);
    }
  }
  getRepeatSymbol() {
    const rv = this.modifiers.filter(obj => obj.ctor === 'SmoRepeatSymbol');
    return rv.length ? rv[0] : null;
  }
  clearRepeatSymbols() {
    const ar = [];
    this.modifiers.forEach((modifier) => {
      if (modifier.ctor !== 'SmoRepeatSymbol') {
        ar.push(modifier);
      }
    });
    this.modifiers = ar;
  }

  setBarline(barline) {
    var ar = [];
    this.modifiers.forEach((modifier) => {
      if (modifier.ctor !== 'SmoBarline' || modifier.position !== barline.position) {
        ar.push(modifier);
      }
    });
    this.modifiers = ar;
    ar.push(barline);
  }

  _getBarline(pos) {
    let rv = null;
    this.modifiers.forEach((modifier) => {
      if (modifier.ctor === 'SmoBarline' && modifier.position === pos) {
        rv = modifier;
      }
    });
    return rv;
  }
  getEndBarline() {
    return this._getBarline(SmoBarline.positions.end);
  }
  getStartBarline() {
    return this._getBarline(SmoBarline.positions.start);
  }

  addNthEnding(ending) {
    const mods = [];
    this.modifiers.forEach((modifier) => {
      if (modifier.ctor !== 'SmoVolta' || modifier.startBar !== ending.startBar || modifier.endBar !== ending.endBar) {
        mods.push(modifier);
      }
    });
    mods.push(ending);
    this.modifiers = mods;
  }

  removeNthEnding(number) {
    const mods = [];
    this.modifiers.forEach((modifier) => {
      if (modifier.ctor !== 'SmoVolta' || modifier.number !== number) {
        mods.push(modifier);
      }
    });
    this.modifiers = mods;
  }

  getNthEndings() {
    const rv = [];
    this.modifiers.forEach((modifier) => {
      if (modifier.ctor === 'SmoVolta') {
        rv.push(modifier);
      }
    });
    return rv;
  }
  getEndEndings() {
    const rv = null;
    this.modifiers.forEach((modifier) => {
      if (modifier.ctor === 'SmoVolta' && modifier.endBar === this.measureNumber.systemIndex
         && modifier.startBar !== this.measureNumber.systemIdnex) {
        rv.push(modifier);
      }
    });
    return rv;
  }
  getMidEndings() {
    const rv = null;
    this.modifiers.forEach((modifier) => {
      if (modifier.ctor === 'SmoVolta' && modifier.endBar > this.measureNumber.systemIndex
         && modifier.startBar < this.measureNumber.systemIndex) {
        rv.push(modifier);
      }
    });
    return rv;
  }

  get numBeats() {
    return this.timeSignature.split('/').map(number => parseInt(number, 10))[0];
  }
  setKeySignature(sig) {
    this.keySignature = sig;
    this.voices.forEach((voice) => {
      voice.notes.forEach((note) => {
        note.keySignature = sig;
      });
    });
  }
  get beatValue() {
    return this.timeSignature.split('/').map(number => parseInt(number, 10))[1];
  }

  setMeasureNumber(num) {
    this.measureNumber = num;
  }

  getBeamGroupForNote(note) {
    let i = 0;
    let j = 0;
    for (i = 0; i < this.beamGroups.length; ++i) {
      const bg = this.beamGroups[i];
      for (j = 0; j < bg.notes.length; ++j) {
        if (bg.notes[j].attrs.id === note.attrs.id) {
          return bg;
        }
      }
    }
    return null;
  }
}
;
// ## Measure modifiers are elements that are attached to the bar itself, like barlines or measure-specific text,
// repeats - lots of stuff
class SmoMeasureModifierBase {
  constructor(ctor) {
    this.ctor = ctor;
    if (!this['attrs']) {
      this.attrs = {
        id: VF.Element.newID(),
        type: ctor
      };
    } else {
      console.log('inherit attrs');
    }
  }
  static deserialize(jsonObj) {
    const ctor = eval(jsonObj.ctor);
    const rv = new ctor(jsonObj);
    return rv;
  }
}

class SmoBarline extends SmoMeasureModifierBase {
  static get positions() {
    return {
      start: 0,
      end: 1
    }
  };

  static get barlines() {
    return {
      singleBar: 0,
      doubleBar: 1,
      endBar: 2,
      startRepeat: 3,
      endRepeat: 4,
      noBar: 5
    }
  }

  static get _barlineToString() {
    return  ['singleBar', 'doubleBar', 'endBar', 'startRepeat', 'endRepeat', 'noBar'];
  }
  static barlineString(inst) {
    return SmoBarline._barlineToString[inst.barline];
  }

  static get defaults() {
    return {
      position: SmoBarline.positions.end,
      barline: SmoBarline.barlines.singleBar
    };
  }

  static get attributes() {
    return ['position', 'barline'];
  }
  serialize() {
    const params = {};
    smoSerialize.serializedMergeNonDefault(SmoBarline.defaults, SmoBarline.attributes, this, params);
    params.ctor = 'SmoBarline';
    return params;
  }

  constructor(parameters) {
    super('SmoBarline');
    parameters = typeof(parameters) !== 'undefined' ? parameters : {};
    smoSerialize.serializedMerge(SmoBarline.attributes, SmoBarline.defaults, this);
    smoSerialize.serializedMerge(SmoBarline.attributes, parameters, this);
  }

  static get toVexBarline() {
    return [VF.Barline.type.SINGLE, VF.Barline.type.DOUBLE, VF.Barline.type.END,
      VF.Barline.type.REPEAT_BEGIN, VF.Barline.type.REPEAT_END, VF.Barline.type.NONE];

  }
  static get toVexPosition() {
    return [VF.StaveModifier.BEGIN, VF.StaveModifier.END];
  }

  toVexBarline() {
    return SmoBarline.toVexBarline[this.barline];
  }
  toVexPosition() {
    return SmoBarline.toVexPosition[this.position];
  }
}

class SmoRepeatSymbol extends SmoMeasureModifierBase {
  static get symbols() {
    return {
      None: 0,
      Coda: 1,
      Segno: 2,
      Dc: 3,
      ToCoda:1,
      DcAlCoda: 4,
      DcAlFine: 5,
      Ds: 6,
      DsAlCoda: 7,
      DsAlFine: 8,
      Fine: 9
    };
  }

  static get defaultXOffset() {
    return [0, 0, 0, -20, -60, -60, -50, -60, -50, -40];
  }
  static get positions() {
    return {
      start: 0,
      end: 1
    }
  };
  static get defaults() {
    return {
      symbol: SmoRepeatSymbol.Coda,
      xOffset: 0,
      yOffset: 30,
      position: SmoRepeatSymbol.positions.end
    }
  }
  static get toVexSymbol() {
    return [VF.Repetition.type.NONE, VF.Repetition.type.CODA_LEFT, VF.Repetition.type.SEGNO_LEFT, VF.Repetition.type.DC,
      VF.Repetition.type.DC_AL_CODA, VF.Repetition.type.DC_AL_FINE, VF.Repetition.type.DS,
      VF.Repetition.type.DS_AL_CODA, VF.Repetition.type.DS_AL_FINE, VF.Repetition.type.FINE];
  }
  static get attributes() {
    return ['symbol', 'xOffset', 'yOffset', 'position'];
  }
  toVexSymbol() {
    return SmoRepeatSymbol.toVexSymbol[this.symbol];
  }
  serialize() {
    const params = {};
    smoSerialize.serializedMergeNonDefault(SmoRepeatSymbol.defaults, SmoRepeatSymbol.attributes, this, params);
    params.ctor = 'SmoRepeatSymbol';
    return params;
  }
  constructor(parameters) {
    super('SmoRepeatSymbol');
    smoSerialize.serializedMerge(SmoRepeatSymbol.attributes, SmoRepeatSymbol.defaults, this);
    this.xOffset = SmoRepeatSymbol.defaultXOffset[parameters.symbol];
    smoSerialize.serializedMerge(SmoRepeatSymbol.attributes, parameters, this);
  }
}

class SmoVolta extends SmoMeasureModifierBase {
  constructor(parameters) {
    super('SmoVolta');
    this.original = {};
    smoSerialize.serializedMerge(SmoVolta.attributes, SmoVolta.defaults, this);
    smoSerialize.serializedMerge(SmoVolta.attributes, parameters, this);
  }
  get id() {
    return this.attrs.id;
  }
  get type() {
    return this.attrs.type;
  }
  static get attributes() {
    return ['startBar', 'endBar', 'endingId', 'startSelector', 'endSelector', 'xOffsetStart', 'xOffsetEnd', 'yOffset', 'number'];
  }
  static get editableAttributes() {
    return ['xOffsetStart', 'xOffsetEnd', 'yOffset', 'number'];
  }

  serialize() {
    const params = {};
    smoSerialize.serializedMergeNonDefault(SmoVolta.defaults, SmoVolta.attributes, this, params);
    params.ctor = 'SmoVolta';
    return params;
  }

  static get defaults() {
    return {
      startBar: 1,
      endBar: 1,
      xOffsetStart: 0,
      xOffsetEnd: 0,
      yOffset: 20,
      number: 1
    }
  }

 backupOriginal() {
    if (!this['original']) {
      this.original = {};
      smoSerialize.filteredMerge(
        SmoVolta.attributes,
        this, this.original);
    }
  }
  restoreOriginal() {
    if (this['original']) {
      smoSerialize.filteredMerge(
        SmoVolta.attributes,
        this.original, this);
      this.original = null;
    }
  }

  toVexVolta(measureNumber) {
    if (this.startBar === measureNumber && this.startBar === this.endBar) {
      return VF.Volta.type.BEGIN_END;
    }
    if (this.startBar === measureNumber) {
      return VF.Volta.type.BEGIN;
    }
    if (this.endBar === measureNumber) {
      return VF.Volta.type.END;
    }
    if (this.startBar < measureNumber && this.endBar > measureNumber) {
      return VF.Volta.type.MID;
    }
    return VF.Volta.type.NONE;
  }
}

class SmoMeasureText extends SmoMeasureModifierBase {
  static get positions() {
    return {above:0,below:1,left:2,right:3,none:4};
  }

  static get justifications() {
    return {left:0,right:1,center:2}
  }

  static get _positionToString() {
    return ['above','below','left','right'];
  }

  static get toVexPosition() {
    return [VF.Modifier.Position.ABOVE,VF.Modifier.Position.BELOW,VF.Modifier.Position.LEFT,VF.Modifier.Position.RIGHT];
  }
  static get toVexJustification() {
    return [VF.TextNote.LEFT,VF.TextNote.RIGHT,VF.TextNote.CENTER];
  }

  toVexJustification() {
    return SmoMeasureText.toVexJustification[this.justification];
  }
  toVexPosition() {
    return SmoMeasureText.toVexPosition[parseInt(this.position)];
  }
  static get attributes() {
    return ['position','fontInfo','text','adjustX','adjustY','justification'];
  }

  static get defaults() {
    return {
      position:SmoMeasureText.positions.above,
      fontInfo: {
        size: '9',
        family:'times',
        style:'normal',
        weight:'normal'
      },
      text:'Smo',
      adjustX:0,
      adjustY:0,
      justification:SmoMeasureText.justifications.center
    };
  }
  serialize() {
        var params = {};
        smoSerialize.serializedMergeNonDefault(SmoMeasureText.defaults,SmoMeasureText.attributes,this,params)
        params.ctor = 'SmoMeasureText';
        return params;
  }

  constructor(parameters) {
    super('SmoMeasureText');
        parameters = parameters ? parameters : {};
        smoSerialize.serializedMerge(SmoMeasureText.attributes, SmoMeasureText.defaults, this);
        smoSerialize.serializedMerge(SmoMeasureText.attributes, parameters, this);

    // right-justify left text and left-justify right text by default
    if (!parameters['justification']) {
      this.justification = (this.position === SmoMeasureText.positions.left) ? SmoMeasureText.justifications.right :
           (this.position === SmoMeasureText.positions.right ? SmoMeasureText.justifications.left : this.justification);
    }
  }
}

class SmoRehearsalMark extends SmoMeasureModifierBase {

  static get cardinalities() {
    return {capitals:'capitals',lowerCase:'lowerCase',numbers:'numbers'};
  }
  static get positions() {
    return {above:0,below:1,left:2,right:3};
  }
  static get _positionToString() {
    return ['above','below','left','right'];
  }

  // TODO: positions don't work.
  static get defaults() {
    return {
      position:SmoRehearsalMark.positions.above,
      cardinality:SmoRehearsalMark.cardinalities.capitals,
      symbol:'A',
            increment:true
    }
  }
  static get attributes() {
    return ['cardinality','symbol','position','increment'];
  }
  getIncrement() {
    if (!this.cardinality != 'number') {
      var code = this.symbol.charCodeAt(0);
      code += 1;
      var symbol=String.fromCharCode(code);
      return symbol;
    } else {
            return parseInt(symbol)+1;
        }
  }
    getInitial() {
        return this.cardinality == SmoRehearsalMark.cardinalities.capitals ? 'A' :
            (this.cardinality == SmoRehearsalMark.cardinalities.lowerCase ? 'a' : '1');
    }
  serialize() {
        var params = {};
        smoSerialize.serializedMergeNonDefault(SmoRehearsalMark.defaults,SmoRehearsalMark.attributes,this,params)
        params.ctor = 'SmoRehearsalMark';
        return params;
  }
  constructor(parameters) {
    super('SmoRehearsalMark');
        parameters = parameters ? parameters : {};
        smoSerialize.serializedMerge(SmoRehearsalMark.attributes, SmoRehearsalMark.defaults, this);
        smoSerialize.serializedMerge(SmoRehearsalMark.attributes, parameters, this);
        if (!parameters.symbol) {
            this.symbol=this.getInitial();
        }
  }
}


// ### SmoTempoText
// Tempo marking and also the information about the tempo.
class SmoTempoText extends SmoMeasureModifierBase {
  static get tempoModes() {
    return {
      durationMode: 'duration',
      textMode: 'text',
      customMode: 'custom'
    };
  }

  static get tempoTexts() {
    return {
      larghissimo: 'Larghissimo',
      grave: 'Grave',
      lento: 'Lento',
      largo: 'Largo',
      larghetto: 'Larghetto',
      adagio: 'Adagio',
      adagietto: 'Adagietto',
      andante_moderato: 'Andante moderato',
      andante: 'Andante',
      andantino: 'Andantino',
      moderator: 'Moderato',
      allegretto: 'Allegretto',
      allegro: 'Allegro',
      vivace: 'Vivace',
      presto: 'Presto',
      prestissimo: 'Prestissimo'
    };
  }

  static get defaults() {
    return {
      tempoMode: SmoTempoText.tempoModes.durationMode,
      bpm: 120,
      beatDuration: 4096,
      tempoText: SmoTempoText.tempoTexts.allegro,
      yOffset: 0,
      display: false,
      customText: ''
    };
  }
  static get attributes() {
    return ['tempoMode', 'bpm', 'display', 'beatDuration', 'tempoText', 'yOffset', 'customText'];
  }
  compare(instance) {
    var rv = true;
    SmoTempoText.attributes.forEach((attr) => {
      if (this[attr] != instance[attr]) {
        rv = false;
      }
    });
    return rv;
  }
  _toVexTextTempo() {
    return { name: this.tempoText };
  }

  // ### eq
  // Return equality wrt the tempo marking, e.g. 2 allegro in textMode will be equal but
  // an allegro and duration 120bpm will not.
  static eq (t1,t2) {
    if (t1.tempoMode !== t2.tempoMode) {
      return false;
    }
    if (t1.tempoMode === SmoTempoText.tempoModes.durationMode) {
      return t1.bpm === t2.bpm && t1.beatDuration === t2.beatDuration;
    }
    if (t1.tempoMode === SmoTempoText.tempoModes.textMode) {
      return t1.tempoText === t2.tempoText;
    } else {
      return t1.bpm === t2.bpm && t1.beatDuration === t2.beatDuration &&
        t1.tempoText === t2.tempoText;
    }
  }

  static get bpmFromText() {
    // TODO: learn these
    var rv = {};
    rv[SmoTempoText.tempoTexts.larghissimo] = 24;
    rv[SmoTempoText.tempoTexts.grave] = 40;
    rv[SmoTempoText.tempoTexts.lento] = 45;
    rv[SmoTempoText.tempoTexts.largo] = 40;
    rv[SmoTempoText.tempoTexts.larghetto] = 60;
    rv[SmoTempoText.tempoTexts.adagio] = 72;
    rv[SmoTempoText.tempoTexts.adagietto] = 72;
    rv[SmoTempoText.tempoTexts.andante_moderato] = 72;
    rv[SmoTempoText.tempoTexts.andante] = 84;
    rv[SmoTempoText.tempoTexts.andantino] = 92;
    rv[SmoTempoText.tempoTexts.moderator] = 96;
    rv[SmoTempoText.tempoTexts.allegretto] = 96;
    rv[SmoTempoText.tempoTexts.allegro] = 120;
    rv[SmoTempoText.tempoTexts.vivace] = 144;
    rv[SmoTempoText.tempoTexts.presto] = 168;
    rv[SmoTempoText.tempoTexts.prestissimo] = 240;
    return rv;
  }

  _toVexDurationTempo() {
    var vd = smoMusic.ticksToDuration[this.beatDuration];
    var dots = (vd.match(/d/g) || []).length;
    vd = vd.replace(/d/g, '');
    const rv = { duration: vd, dots: dots, bpm: this.bpm };
    if (this.customText.length) {
      rv.name = this.customText;
    }
    return rv;
  }
  toVexTempo() {
    if (this.tempoMode === SmoTempoText.tempoModes.durationMode ||
      this.tempoMode === SmoTempoText.tempoModes.customMode) {
      return this._toVexDurationTempo();
    }
    return this._toVexTextTempo();
  }
  backupOriginal() {
    this.backup = {};
    smoSerialize.serializedMerge(SmoTempoText.attributes, this, this.backup);
  }
  restoreOriginal() {
    smoSerialize.serializedMerge(SmoTempoText.attributes, this.backup, this);
  }
  serialize() {
    var params = {};
    smoSerialize.serializedMergeNonDefault(SmoTempoText.defaults, SmoTempoText.attributes, this, params)
    params.ctor = 'SmoTempoText';
    return params;
  }
  constructor(parameters) {
    super('SmoTempoText');
    parameters = typeof(parameters) !== 'undefined' ? parameters : {};
    smoSerialize.serializedMerge(SmoTempoText.attributes, SmoTempoText.defaults, this);
    smoSerialize.serializedMerge(SmoTempoText.attributes, parameters, this);
  }
}
;// ## SmoNote
// ## Description:
// Data for a musical note.  THe most-contained-thing, except there can be note modifiers
// Basic note information.  Leaf node of the SMO dependency tree (so far)
// ## SmoNote Methods
// ---
// eslint-disable-next-line no-unused-vars
class SmoNote {
  // ### Description:
  // see defaults for params format.
  constructor(params) {
    Vex.Merge(this, SmoNote.defaults);
    smoSerialize.serializedMerge(SmoNote.parameterArray, params, this);
    if (!this.attrs) {
      this.attrs = {
        id: VF.Element.newID(),
        type: 'SmoNote'
      };
    } // else inherit
  }
  static get flagStates() {
    return { auto: 0, up: 1, down: 2 };
  }
  static get parameterArray() {
    return ['ticks', 'pitches', 'noteType', 'tuplet', 'clef',
      'endBeam', 'beamBeats', 'flagState', 'noteHead', 'fillStyle', 'hidden'];
  }

  toggleFlagState() {
    this.flagState = (this.flagState + 1) % 3;
  }

  toVexStemDirection() {
    return (this.flagState === SmoNote.flagStates.up ? VF.Stem.UP : VF.Stem.DOWN);
  }
  get id() {
    return this.attrs.id;
  }

  get dots() {
    if (this.isTuplet) {
      return 0;
    }
    const vexDuration = smoMusic.ticksToDuration[this.tickCount];
    if (!vexDuration) {
      return 0;
    }
    return vexDuration.split('d').length - 1;
  }

  // ### _addModifier
  // ### Description
  // add or remove sFz, mp, etc.
  _addModifier(dynamic, toAdd) {
    var tms = [];
    this.textModifiers.forEach((tm) => {
      if (tm.attrs.type !== dynamic.attrs.type) {
        tms.push(tm);
      }
    });
    if (toAdd) {
      tms.push(dynamic);
    }
    this.textModifiers = tms;
  }

  _addArticulation(articulation, toAdd) {
    var tms = [];
    this.articulations.forEach((tm) => {
      if (tm.articulation !== articulation.articulation) {
        tms.push(tm);
      }
    });
    if (toAdd) {
      tms.push(articulation);
    }
    this.articulations = tms;
  }

  addModifier(dynamic) {
    this._addModifier(dynamic, true);
  }
  removeModifier(dynamic) {
    this._addModifier(dynamic, false);
  }
  getModifiers(type) {
    var ms = this.textModifiers.filter((mod) =>
      mod.attrs.type === type
    );
    return ms;
  }

  longestLyric() {
    const tms = this.textModifiers.filter((mod) =>
      mod.attrs.type === 'SmoLyric' && mod.parser === SmoLyric.parsers.lyric
    );
    if (!tms.length) {
      return null;
    }
    return tms.reduce((m1, m2) =>
      m1.getText().length > m2.getText().length ? m1 : m2
    );
  }

  addLyric(lyric) {
    const tms = this.textModifiers.filter((mod) =>
      mod.attrs.type !== 'SmoLyric' || mod.parser !== lyric.parser ||
        mod.verse !== lyric.verse
    );
    tms.push(lyric);
    this.textModifiers = tms;
  }

  getTrueLyrics() {
    const ms = this.textModifiers.filter((mod) =>
      mod.attrs.type === 'SmoLyric' && mod.parser === SmoLyric.parsers.lyric);
    ms.sort((a, b) => a.verse - b.verse);
    return ms;
  }

  getChords() {
    const ms = this.textModifiers.filter((mod) =>
      mod.attrs.type === 'SmoLyric' && mod.parser === SmoLyric.parsers.chord
    );
    return ms;
  }

  removeLyric(lyric) {
    const tms = this.textModifiers.filter((mod) =>
      mod.attrs.type !== 'SmoLyric' || mod.verse !== lyric.verse || mod.parser !== lyric.parser
    );
    this.textModifiers = tms;
  }

  getLyricForVerse(verse, parser) {
    return this.textModifiers.filter((mod) =>
      mod.attrs.type === 'SmoLyric' && mod.parser === parser && mod.verse === verse
    );
  }

  // ### setLyricFont
  // Lyric font is score-wide, so we set all lyrics to the same thing.
  setLyricFont(fontInfo) {
    const lyrics = this.getTrueLyrics();

    lyrics.forEach((lyric) => {
      lyric.fontInfo = JSON.parse(JSON.stringify(fontInfo));
    });
  }

  // ### setLyricFont
  // Set whether we ajust note width for lyrics, a scope-wide setting.
  setLyricAdjustWidth(adjustNoteWidth) {
    const lyrics = this.getTrueLyrics();
    lyrics.forEach((lyric) => {
      lyric.adjustNoteWidth = adjustNoteWidth;
    });
  }

  setChordAdjustWidth(adjustNoteWidth) {
    const chords = this.getChords();
    chords.forEach((chord) => {
      chord.adjustNoteWidth = adjustNoteWidth;
    });
  }

  setChordFont(fontInfo) {
    const chords = this.getChords();
    chords.forEach((chord) => {
      chord.fontInfo = JSON.parse(JSON.stringify(fontInfo));
    });
  }

  getOrnaments() {
    return this.ornaments.filter((oo) => oo.isJazz() === false);
  }

  getJazzOrnaments() {
    return this.ornaments.filter((oo) => oo.isJazz());
  }

  toggleOrnament(ornament) {
    const aix = this.ornaments.filter((a) =>
      a.attrs.type === 'SmoOrnament' && a.ornament === ornament.ornament
    );
    if (!aix.length) {
      this.ornaments.push(ornament);
    } else {
      this.ornaments = [];
    }
  }

  // Toggle between articulation above, below, or remove
  toggleArticulation(articulation) {
    var aix = this.articulations.findIndex((a) =>
      a.articulation === articulation.articulation
    );
    if (aix >= 0) {
      const cur = this.articulations[aix];
      if (cur.position === SmoArticulation.positions.above) {
        cur.position = SmoArticulation.positions.below;
        return;
      } else {
        this._addArticulation(articulation, false);
        return;
      }
    }
    this._addArticulation(articulation, true);
  }

  static _sortPitches(note) {
    const canon = VF.Music.canonical_notes;
    const keyIndex = ((pitch) =>
      canon.indexOf(pitch.letter) + pitch.octave * 12
    );
    note.pitches.sort((a, b) => keyIndex(a) - keyIndex(b));
  }
  setNoteHead(noteHead) {
    if (this.noteHead === noteHead) {
      this.noteHead = '';
    } else {
      this.noteHead = noteHead;
    }
  }
  addGraceNote(graceNote, offset) {
    if (typeof(offset) === 'undefined') {
      offset = 0;
    }
    graceNote.clef = this.clef;
    this.graceNotes.push(graceNote);
  }
  removeGraceNote(offset) {
    if (offset >= this.graceNotes.length) {
      return;
    }
    this.graceNotes.splice(offset, 1);
  }
  getGraceNotes() {
    return this.graceNotes;
  }
  addPitchOffset(offset) {
    if (this.pitches.length === 0) {
      return;
    }
    this.noteType = 'n';
    const pitch = this.pitches[0];
    this.pitches.push(smoMusic.getKeyOffset(pitch, offset));
    SmoNote._sortPitches(this);
  }
  toggleRest() {
    this.noteType = (this.noteType === 'r' ? 'n' : 'r');
  }

  makeRest() {
    this.noteType = 'r';
  }
  isRest() {
    return this.noteType === 'r';
  }

  makeNote() {
    this.noteType = 'n';
    // clear fill style if we were hiding rests
    this.fillStyle = '';
    this.hidden = false;
  }
  makeHidden(val) {
    this.hidden = val;
    this.fillStyle = val ? '#aaaaaa7f' : '';
  }

  get isTuplet() {
    return this.tuplet && this.tuplet.id;
  }

  addMicrotone(tone) {
    const ar = this.tones.filter((tn) => tn.pitch !== tone.pitch);
    ar.push(tone);
    this.tones = ar;
  }
  removeMicrotone(tone) {
    const ar = this.tones.filter((tn) => tn.pitch !== tone.pitch
      && tone.tone !== tn.tone);
    this.tones = ar;
  }

  getMicrotones() {
    return this.tones;
  }
  static toggleEnharmonic(pitch) {
    const lastLetter = pitch.letter;
    let vexPitch = smoMusic.stripVexOctave(smoMusic.pitchToVexKey(pitch));
    vexPitch = smoMusic.getEnharmonic(vexPitch);

    pitch.letter = vexPitch[0];
    pitch.accidental = vexPitch.length > 1 ?
      vexPitch.substring(1, vexPitch.length) : 'n';
    pitch.octave += smoMusic.letterChangedOctave(lastLetter, pitch.letter);
    return pitch;
  }

  transpose(pitchArray, offset, keySignature) {
    return SmoNote._transpose(this, pitchArray, offset, keySignature);
  }
  // ### addPitch
  // used to add chord and pitch by piano widget
  toggleAddPitch(pitch) {
    const pitches = [];
    let exists = false;
    this.pitches.forEach((o) => {
      if (o.letter !== pitch.letter ||
        o.octave !== pitch.octave ||
        o.accidental !== pitch.accidental) {
        pitches.push(o);
      } else {
        exists = true;
      }
    });
    this.pitches = pitches;
    if (!exists) {
      this.pitches.push(JSON.parse(JSON.stringify(pitch)));
      this.noteType = 'n';
    }
    SmoNote._sortPitches(this);
  }
  static _transpose(note, pitchArray, offset, keySignature) {
    let index = 0;
    let j = 0;
    let letterKey = 'a';
    note.noteType = 'n';
    if (pitchArray.length === 0) {
      note.pitches.forEach((m) => {
        pitchArray.push(note.pitches.indexOf(m));
      });
    }
    for (j = 0; j < pitchArray.length; ++j) {
      index = pitchArray[j];
      if (index + 1 > note.pitches.length) {
        note.addPitchOffset(offset);
      } else {
        const pitch = smoMusic.getKeyOffset(note.pitches[index], offset);
        if (keySignature) {
          letterKey = pitch.letter + pitch.accidental;
          letterKey = smoMusic.getKeyFriendlyEnharmonic(letterKey, keySignature);
          pitch.letter = letterKey[0];
          if (letterKey.length < 2) {
            pitch.accidental = 'n';
          } else {
            pitch.accidental = letterKey.substring(1);
          }
        }
        note.pitches[index] = pitch;
      }
    }
    SmoNote._sortPitches(note);
    return note;
  }
  get tickCount() {
    return this.ticks.numerator / this.ticks.denominator + this.ticks.remainder;
  }

  static clone(note) {
    var rv = SmoNote.deserialize(note.serialize());

    // make sure id is unique
    rv.attrs = {
      id: VF.Element.newID(),
      type: 'SmoNote'
    };
    return rv;
  }

  // ## Description:
  // Clone the note, but use the different duration.  Changes the length
  // of the note but nothing else.
  static cloneWithDuration(note, ticks) {
    if (typeof(ticks) === 'number') {
      ticks = { numerator: ticks, denominator: 1, remainder: 0 };
    }
    const rv = SmoNote.clone(note);
    rv.ticks = ticks;
    return rv;
  }

  _serializeModifiers(params) {
    ['textModifiers', 'graceNotes', 'articulations', 'ornaments', 'tones'].forEach((attr) => {
      if (this[attr] && this[attr].length) {
        params[attr] = [];
        this[attr].forEach((mod) => {
          params[attr].push(mod.serialize());
        });
      }
    });
  }
  serialize() {
    var params = {};
    smoSerialize.serializedMergeNonDefault(SmoNote.defaults, SmoNote.parameterArray, this, params);
    if (params.ticks) {
      params.ticks = JSON.parse(JSON.stringify(params.ticks));
    }
    this._serializeModifiers(params);
    return params;
  }

  static get defaults() {
    return {
      noteType: 'n',
      noteHead: 'n',
      textModifiers: [],
      articulations: [],
      graceNotes: [],
      ornaments: [],
      tones: [],
      endBeam: false,
      fillStyle: '',
      hidden: false,
      beamBeats: 4096,
      flagState: SmoNote.flagStates.auto,
      ticks: {
        numerator: 4096,
        denominator: 1,
        remainder: 0
      },
      pitches: [{
        letter: 'b',
        octave: 4,
        accidental: ''
      }],
    };
  }
  static deserialize(jsonObj) {
    var note = new SmoNote(jsonObj);
    ['textModifiers', 'graceNotes', 'ornaments', 'articulations', 'tones'].forEach((attr) => {
      if (!jsonObj[attr]) {
        note[attr] = [];
      } else {
        jsonObj[attr].forEach((mod) => {
          note[attr].push(SmoNoteModifierBase.deserialize(mod));
        });
      }
    });
    // Due to a bug, text modifiers were serialized into noteModifiers array
    if (jsonObj.noteModifiers) {
      jsonObj.noteModifiers.forEach((mod) => {
        note.textModifiers.push(mod);
      });
    }
    return note;
  }
}

// eslint-disable-next-line no-unused-vars
class SmoBeamGroup {
  constructor(params) {
    let i = 0;
    this.notes = params.notes;
    Vex.Merge(this, params);

    if (!this.attrs) {
      this.attrs = {
        id: VF.Element.newID(),
        type: 'SmoBeamGroup'
      };
    }
    for (i = 0; i < this.notes.length; ++i) {
      const note = this.notes[i];
      if (note.tickCount < 4096) {
        note.beam_group = this.attrs;
      }
    }
  }
}
;// ## SmoNoteModifierBase
// A note modifier is anything that is mapped to the note, but not part of the
// pitch itself.  This includes grace notes, and note-text like lyrics
// eslint-disable-next-line no-unused-vars
class SmoNoteModifierBase {
  constructor(ctor) {
    this.attrs = {
      id: VF.Element.newID(),
      type: ctor
    };
    this.ctor = ctor;
  }
  static deserialize(jsonObj) {
    const ctor = eval(jsonObj.ctor);
    const rv = new ctor(jsonObj);
    return rv;
  }
}

// eslint-disable-next-line no-unused-vars
class SmoGraceNote extends SmoNoteModifierBase {
  static get defaults() {
    return {
      flagState: SmoGraceNote.flagStates.auto,
      noteType: 'n',
      beamBeats: 4096,
      endBeam: false,
      clef: 'treble',
      slash: false,
      ticks: {
        numerator: 4096,
        denominator: 1,
        remainder: 0
      },
      pitches: [{
        letter: 'b',
        octave: 4,
        accidental: ''
      }
      ],
    };
  }
  // TODO: Matches SmoNote - move to smoMusic?
  static get flagStates() {
    return { auto: 0, up: 1, down: 2 };
  }
  static get parameterArray() {
    return ['ticks', 'pitches', 'noteType', 'clef', 'endBeam', 'beamBeats', 'flagState', 'slash', 'ctor'];
  }
  tickCount() {
    return this.ticks.numerator / this.ticks.denominator + this.ticks.remainder;
  }

  toVexGraceNote() {
    const p = smoMusic.smoPitchesToVex(this.pitches);
    const rv = { duration: smoMusic.closestVexDuration(this.tickCount()), keys: p, slash: this.slash };
    return rv;
  }

  serialize() {
    const params = {};
    smoSerialize.serializedMergeNonDefault(SmoGraceNote.defaults,
      SmoGraceNote.parameterArray, this, params);
    return params;
  }

  constructor(parameters) {
    super('SmoGraceNote');
    smoSerialize.serializedMerge(SmoGraceNote.parameterArray, SmoGraceNote.defaults, this);
    smoSerialize.serializedMerge(SmoGraceNote.parameterArray, parameters, this);
  }
}

// ## SmoMicrotone
// Microtones are treated similarly to ornaments at this time.  There are not
// rules for persisting throughout a measure.
// eslint-disable-next-line no-unused-vars
class SmoMicrotone extends SmoNoteModifierBase {
  // This is how VexFlow notates them
  static get smoToVex() {
    return {
      flat75sz: 'db',
      flat25sz: 'd',
      flat25ar: 'bs',
      flat125ar: 'afhf',
      sharp75: '++',
      sharp125: 'ashs',
      sharp25: '+',
      sori: 'o',
      koron: 'k'
    };
  }

  // The audio frequency offsets
  static get pitchCoeff() {
    return {
      flat75sz: -1.5,
      flat25sz: -0.5,
      flat25ar: -0.5,
      flat125ar: -2.5,
      sharp75: 1.5,
      sharp125: 2.5,
      sharp25: 0.5,
      sori: 0.5,
      koron: -0.5
    };
  }

  get toPitchCoeff() {
    return SmoMicrotone.pitchCoeff[this.tone];
  }

  get toVex() {
    return SmoMicrotone.smoToVex[this.tone];
  }
  static get defaults() {
    return {
      tone: 'flat25sz',
      pitch: 0
    };
  }
  static get parameterArray() {
    return ['tone', 'pitch', 'ctor'];
  }
  serialize() {
    var params = {};
    smoSerialize.serializedMergeNonDefault(SmoMicrotone.defaults,
      SmoMicrotone.parameterArray, this, params);
    return params;
  }
  constructor(parameters) {
    super('SmoMicrotone');
    smoSerialize.serializedMerge(SmoMicrotone.parameterArray, SmoMicrotone.defaults, this);
    smoSerialize.serializedMerge(SmoMicrotone.parameterArray, parameters, this);
  }
}

// ## SmoOrnament
// Maps to a vexflow ornament like trill etc.
// eslint-disable-next-line no-unused-vars
class SmoOrnament extends SmoNoteModifierBase {
  static get ornaments() {
    return {
      mordent: 'mordent',
      mordentInverted: 'mordent_inverted',
      turn: 'turn',
      turnInverted: 'turn_inverted',
      trill: 'tr',
      upprail: 'upprail',
      prailup: 'prailup',
      praildown: 'praildown',
      upmordent: 'upmordent',
      downmordent: 'downmordent',
      lineprail: 'linepraile',
      prailprail: 'prailprail',
      scoop: 'scoop',
      fall_short: 'fall',
      dropLong: 'fallLong',
      doit: 'doit',
      doitLong: 'doitLong',
      flip: 'flip',
      smear: 'smear'
    };
  }
  static get jazzOrnaments() {
    return ['SCOOP', 'FALL_SHORT', 'FALL_LONG', 'DOIT', 'LIFT', 'FLIP', 'SMEAR'];
  }
  toVex() {
    return SmoOrnament.ornaments[this.ornament.toLowerCase()];
  }

  isJazz() {
    return SmoOrnament.jazzOrnaments.indexOf(this.ornament) >= 0;
  }

  static get parameterArray() {
    return ['position', 'offset', 'ornament', 'ctor'];
  }

  static get positions() {
    return {
      above: 'above',
      below: 'below'
    };
  }
  static get offsets() {
    return {
      on: 'on',
      after: 'after'
    };
  }
  static get defaults() {
    return {
      ornament: SmoOrnament.ornaments.mordent,
      position: SmoOrnament.positions.above,
      offset: SmoOrnament.offsets.on
    };
  }
  serialize() {
    const params = {};
    smoSerialize.serializedMergeNonDefault(SmoOrnament.defaults,
      SmoOrnament.parameterArray, this, params);
    return params;
  }
  constructor(parameters) {
    super('SmoOrnament');
    smoSerialize.serializedMerge(SmoOrnament.parameterArray, SmoOrnament.defaults, this);
    smoSerialize.serializedMerge(SmoOrnament.parameterArray, parameters, this);
    this.selector = parameters.selector;
  }
}

// eslint-disable-next-line no-unused-vars
class SmoArticulation extends SmoNoteModifierBase {
  static get articulations() {
    return {
      accent: 'accent',
      staccato: 'staccato',
      marcato: 'marcato',
      tenuto: 'tenuto',
      upStroke: 'upStroke',
      downStroke: 'downStroke',
      pizzicato: 'pizzicato',
      fermata: 'fermata'
    };
  }
  static get positions() {
    return {
      above: 'above',
      below: 'below'
    };
  }
  static get articulationToVex() {
    return {
      accent: 'a>',
      staccato: 'a.',
      marcato: 'a^',
      tenuto: 'a-',
      upStroke: 'a|',
      downStroke: 'am',
      pizzicato: 'ao',
      fermata: 'a@a'
    };
  }

  static get vexToArticulation() {
    return {
      'a>': 'accent',
      'a.': 'staccato',
      'a^': 'marcato',
      'a-': 'tenuto',
      'a|': 'upStroke',
      'am': 'downStroke',
      'ao': 'pizzicato',
      'a@a': 'fermata'
    };
  }
  static get parameterArray() {
    return ['position', 'articulation', 'ctor'];
  }

  static get positionToVex() {
    return {
      'above': 3,
      'below': 4
    };
  }
  static get defaults() {
    return {
      position: SmoArticulation.positions.above,
      articulation: SmoArticulation.articulations.accent
    };
  }
  serialize() {
    var params = {};
    smoSerialize.serializedMergeNonDefault(SmoArticulation.defaults,
      SmoArticulation.parameterArray, this, params);
    return params;
  }
  constructor(parameters) {
    super('SmoArticulation');
    smoSerialize.serializedMerge(SmoArticulation.parameterArray, SmoArticulation.defaults, this);
    smoSerialize.serializedMerge(SmoArticulation.parameterArray, parameters, this);
    this.selector = parameters.selector;
    this.adjX = 0;
  }
}

// ## SmoLyric
// Lyrics and Chords are both notated represented by
// instances of this class.  The parser enum says
// which is which
// eslint-disable-next-line no-unused-vars
class SmoLyric extends SmoNoteModifierBase {
  static get defaults() {
    return {
      _text: '\xa0',
      endChar: '',
      verse: 0,
      fontInfo: {
        size: 12,
        family: 'times',
        style: 'normal',
        weight: 'normal'
      },
      fill: 'black',
      rotate: 0,
      classes: 'score-text',
      scaleX: 1.0,
      scaleY: 1.0,
      translateX: 0,
      translateY: 0,
      symbolBlocks: [],
      adjustNoteWidthLyric: true,
      adjustNoteWidthChord: false,
      parser: SmoLyric.parsers.lyric
    };
  }
  static get parsers() {
    return { lyric: 0, anaylysis: 1, chord: 2 };
  }
  static get symbolPosition() {
    return {
      SUPERSCRIPT: 1,
      SUBSCRIPT: 2,
      NORMAL: 3
    };
  }

  static toVexPosition(chordPos) {
    if (chordPos === SmoLyric.symbolPosition.NORMAL) {
      return VF.ChordSymbol.symbolModifiers.NONE;
    } else if (chordPos === SmoLyric.symbolPosition.SUPERSCRIPT) {
      return VF.ChordSymbol.symbolModifiers.SUPERSCRIPT;
    }
    return VF.ChordSymbol.symbolModifiers.SUBSCRIPT;
  }

  static get parameterArray() {
    return ['endChar', 'fontInfo', 'classes', 'verse', 'parser', 'adjustNoteWidthLyric',
      'adjustNoteWidthChord',
      'fill', 'scaleX', 'scaleY', 'translateX', 'translateY', 'ctor', '_text'];
  }
  serialize() {
    var params = {};
    smoSerialize.serializedMergeNonDefault(SmoLyric.defaults,
      SmoLyric.parameterArray, this, params);
    return params;
  }
  // For lyrics, we default to adjust note width on lyric size.  For chords, this is almost never what
  // you want, so it is off by default.
  get adjustNoteWidth() {
    return (this.parser === SmoLyric.parsers.lyric) ? this.adjustNoteWidthLyric : this.adjustNoteWidthChord;
  }
  set adjustNoteWidth(val) {
    if (this.parser === SmoLyric.parsers.lyric) {
      this.adjustNoteWidthLyric = val;
    } else {
      this.adjustNoteWidthChord = val;
    }
  }

  // ### getClassSelector
  // returns a selector used to find this text block within a note.
  getClassSelector() {
    var parser = (this.parser === SmoLyric.parsers.lyric ? 'lyric' : 'chord');
    return 'g.' + parser + '-' + this.verse;
  }

  setText(text) {
    // For chords, trim all whitespace
    if (this.parser !== SmoLyric.parsers.lyric) {
      if (text.trim().length) {
        text.replace(/\s/g, '');
      }
    }
    this._text = text;
  }

  isHyphenated() {
    const text = this._text.trim();
    return this.parser === SmoLyric.parsers.lyric &&
      text.length &&
      text[text.length - 1] === '-';
  }

  getText() {
    const text = this._text.trim();
    if (this.isHyphenated()) {
      return smoSerialize.tryParseUnicode(text.substr(0, text.length - 1)).trim();
    }
    return smoSerialize.tryParseUnicode(text);
  }

  isDash() {
    return this.getText().length === 0 && this.isHyphenated();
  }

  static _chordGlyphFromCode(code) {
    const obj = Object.keys(VF.ChordSymbol.glyphs).find((glyph) => VF.ChordSymbol.glyphs[glyph].code === code);
    return obj;
  }
  static _tokenizeChordString(str) {
    // var str = this._text;
    const reg = /^([A-Z|a-z|0-9|]+)/g;
    let mmm = str.match(reg);
    let tokeType = '';
    let toke = '';
    const tokens = [];
    while (str.length) {
      if (!mmm) {
        tokeType = str[0];
        tokens.push(tokeType);
        str = str.slice(1, str.length);
      } else {
        toke = mmm[0].substr(0, mmm[0].length);
        str = str.slice(toke.length, str.length);
        tokens.push(toke);
        tokeType = '';
        toke = '';
      }
      mmm = str.match(reg);
    }
    return tokens;
  }

  getVexChordBlocks() {
    let mod = VF.ChordSymbol.symbolModifiers.NONE;
    let isGlyph = false;
    const tokens = SmoLyric._tokenizeChordString(this._text);
    const blocks = [];
    tokens.forEach((token) => {
      if (token === '^') {
        mod = (mod === VF.ChordSymbol.symbolModifiers.SUPERSCRIPT) ?
          VF.ChordSymbol.symbolModifiers.NONE : VF.ChordSymbol.symbolModifiers.SUPERSCRIPT;
      } else if (token === '%') {
        mod = (mod === VF.ChordSymbol.symbolModifiers.SUBSCRIPT) ?
          VF.ChordSymbol.symbolModifiers.NONE : VF.ChordSymbol.symbolModifiers.SUBSCRIPT;
      } else if (token === '@') {
        isGlyph = !isGlyph;
      } else if (token.length) {
        if (isGlyph) {
          const glyph = SmoLyric._chordGlyphFromCode(token);
          blocks.push({ glyph, symbolModifier: mod,
            symbolType: VF.ChordSymbol.symbolTypes.GLYPH });
        } else {
          blocks.push({ text: token, symbolModifier: mod,
            symbolType: VF.ChordSymbol.symbolTypes.TEXT });
        }
      }
    });
    return blocks;
  }

  constructor(parameters) {
    super('SmoLyric');
    smoSerialize.serializedMerge(SmoLyric.parameterArray, SmoLyric.defaults, this);
    smoSerialize.serializedMerge(SmoLyric.parameterArray, parameters, this);

    this.skipRender = false;

    // backwards-compatibility for lyric text
    if (parameters.text) {
      this._text = parameters.text;
    }

    // Return these for the text editor that expects them.
    // this.translateX = this.translateY = 0;
    this.scaleX = this.scaleY = 1.0;
    this.boxModel = 'none';

    // calculated adjustments for alignment purposes
    this.adjY = 0;
    this.adjX = 0;
    this.verse = parseInt(this.verse, 10);

    if (!this.attrs) {
      this.attrs = {
        id: VF.Element.newID(),
        type: 'SmoLyric'
      };
    }
  }
}

// ## SmoDynamicText
// ## Description:
// standard dynamics text
// eslint-disable-next-line no-unused-vars
class SmoDynamicText extends SmoNoteModifierBase {
  static get defaults() {
    return {
      xOffset: 0,
      fontSize: 38,
      yOffsetLine: 11,
      yOffsetPixels: 0,
      text: SmoDynamicText.dynamics.MP,
    };
  }

  static get dynamics() {
    // matches VF.modifier
    return {
      PP: 'pp',
      P: 'p',
      MP: 'mp',
      MF: 'mf',
      F: 'f',
      FF: 'ff',
      SFZ: 'sfz'
    };
  }

  serialize() {
    const params = {};
    smoSerialize.serializedMergeNonDefault(SmoDynamicText.defaults,
      SmoDynamicText.parameterArray, this, params);
    return params;
  }
  constructor(parameters) {
    super('SmoDynamicText');
    Vex.Merge(this, SmoDynamicText.defaults);
    smoSerialize.filteredMerge(SmoDynamicText.parameterArray, parameters, this);
    this.selector = parameters.selector;

    if (!this.attrs) {
      this.attrs = {
        id: VF.Element.newID(),
        type: 'SmoDynamicText'
      };
    }
  }

  static get parameterArray() {
    return ['xOffset', 'fontSize', 'yOffsetLine', 'yOffsetPixels', 'text', 'ctor'];
  }
  backupOriginal() {
    if (!this.original) {
      this.original = {};
      smoSerialize.filteredMerge(
        SmoDynamicText.parameterArray,
        this, this.original);
    }
  }
  restoreOriginal() {
    if (this.original) {
      smoSerialize.filteredMerge(
        SmoDynamicText.parameterArray,
        this.original, this);
      this.original = null;
    }
  }
}
;// ## SmoScore
// ## Description:
// The whole score.
// ## Score methods:
// ---
// eslint-disable-next-line no-unused-vars
class SmoScore {
  constructor(params) {
    Vex.Merge(this, SmoScore.defaults);
    Vex.Merge(this, params);
    if (!this.layout.pages) {
      this.layout.pages = 1;
    }
    if (this.staves.length) {
      this.numberStaves();
    }
  }
  static get engravingFonts() {
    return { Bravura: 'Bravura', Gonville: 'Gonville', Petaluma: 'Petaluma' };
  }
  static get zoomModes() {
    return { fitWidth: 0, wholePage: 1, zoomScale: 2 };
  }
  static get fontPurposes() {
    return { ENGRAVING: 1, SCORE: 2, CHORDS: 3, LYRICS: 4 };
  }
  static get defaults() {
    return {
      layout: {
        leftMargin: 30,
        rightMargin: 30,
        topMargin: 40,
        bottomMargin: 40,
        pageWidth: 8 * 96 + 48,
        pageHeight: 11 * 96,
        orientation: SmoScore.orientations.portrait,
        interGap: 30,
        intraGap: 10,
        svgScale: 1.0,
        zoomScale: 2.0,
        zoomMode: SmoScore.zoomModes.fitWidth,
        noteSpacing: 1.0,
        pages: 1
      },
      fonts: [
        { name: 'engraving', purpose: SmoScore.fontPurposes.ENGRAVING, family: 'Bravura', size: 1, custom: false },
        { name: 'score', purpose: SmoScore.fontPurposes.SCORE, family: 'Merriweather', size: 14, custom: false },
        { name: 'chords', purpose: SmoScore.fontPurposes.CHORDS, family: 'Roboto Slab', size: 14, custom: false  },
        { name: 'lyrics', purpose: SmoScore.fontPurposes.LYRICS, family: 'Merriweather', size: 12, custom: false }
      ],
      staffWidth: 1600,
      scoreInfo: {
        name: 'Smoosical', // deprecated
        title: 'Smoosical',
        subTitle: '(Op. 1)',
        composer: 'Me',
        copyright: '',
        version: 1,
      },
      preferences: {
        autoPlay: true,
        autoAdvance: true,
        defaultDupleDuration: 4096,
        defaultTripleDuration: 6144,
        customProportion: 100
      },
      startIndex: 0,
      renumberingMap: {},
      keySignatureMap: {},
      measureTickmap: [],
      staves: [],
      activeStaff: 0,
      scoreText: [],
      textGroups: [],
      systemGroups: []
    };
  }
  static get pageSizes() {
    return ['letter', 'tabloid', 'A4', 'custom'];
  }
  static get pageDimensions() {
    return {
      'letter': { width: 8 * 96 + 48, height: 11 * 96 },
      'tabloid': { width: 1056, height: 1632 },
      'A4': { width: 794, height: 1122 },
      'custom': { width: 1, height: 1 }
    };
  }

  static get orientationLabels() {
    return ['portrait', 'landscape'];
  }
  static get orientations() {
    return { 'portrait': 0, 'landscape': 1 };
  }

  static get defaultAttributes() {
    return ['layout', 'startIndex', 'renumberingMap', 'renumberIndex', 'fonts',
      'preferences', 'scoreInfo'];
  }
  static get layoutAttributes() {
    return ['leftMargin', 'rightMargin', 'topMargin', 'bottomMargin',
      'pageWidth', 'pageHeight', 'orientation', 'interGap', 'intraGap', 'svgScale', 'zoomScale', 'zoomMode', 'noteSpacing', 'pages'];
  }
  static get preferences() {
    return ['preferences', 'fonts', 'scoreInfo', 'layout'];
  }

  serializeColumnMapped() {
    const attrColumnHash = {};
    const attrCurrentValue  = {};
    this.staves[0].measures.forEach((measure) => {
      measure.serializeColumnMapped(attrColumnHash, attrCurrentValue);
    });
    return attrColumnHash;
  }

  // ### deserializeColumnMapped
  // Column-mapped attributes stay the same in each measure until
  // changed, like key-signatures.  We don't store each measure value to
  // make the files smaller
  static deserializeColumnMapped(scoreObj) {
    let curValue = 0;
    let mapIx = 0;
    if (!scoreObj.columnAttributeMap) {
      return;
    }
    const attrs = Object.keys(scoreObj.columnAttributeMap);
    scoreObj.staves.forEach((staff) => {
      const attrIxMap = {};
      attrs.forEach((attr) => {
        attrIxMap[attr] = 0;
      });

      staff.measures.forEach((measure) => {
        attrs.forEach((attr) => {
          mapIx = attrIxMap[attr];
          const curHash = scoreObj.columnAttributeMap[attr];
          const attrKeys = Object.keys(curHash);
          curValue = curHash[attrKeys[mapIx.toString()]];
          attrKeys.sort((a, b) => parseInt(a, 10) > parseInt(b, 10) ? 1 : -1);
          if (attrKeys.length > mapIx + 1) {
            if (measure.measureNumber.measureIndex >= attrKeys[mapIx + 1]) {
              mapIx += 1;
              curValue = curHash[attrKeys[mapIx.toString()]];
            }
          }
          measure[attr] = curValue;
          attrIxMap[attr] = mapIx;
        });
      });
    });
  }

  // ### serialize
  // ### Serialize the score.  The resulting JSON string will contain all the staves, measures, etc.
  serialize() {
    const params = {};
    let obj = {
      score: params,
      staves: [],
      scoreText: [],
      textGroups: [],
      systemGroups: []
    };
    smoSerialize.serializedMerge(SmoScore.defaultAttributes, this, params);
    this.staves.forEach((staff) => {
      obj.staves.push(staff.serialize());
    });
    // Score text is not part of text group, so don't save separately.
    this.textGroups.forEach((tg) => {
      if (tg.isTextVisible()) {
        obj.textGroups.push(tg.serialize());
      }
    });
    this.systemGroups.forEach((gg) => {
      obj.systemGroups.push(gg.serialize());
    });
    obj.columnAttributeMap = this.serializeColumnMapped();
    smoSerialize.jsonTokens(obj);
    obj = smoSerialize.detokenize(obj, smoSerialize.tokenValues);
    obj.dictionary = smoSerialize.tokenMap;
    return obj;
  }

  // ### deserialize
  // Restore an earlier JSON string.  Unlike other deserialize methods, this one expects the string.
  static deserialize(jsonString) {
    let jsonObj = JSON.parse(jsonString);
    if (jsonObj.dictionary) {
      jsonObj = smoSerialize.detokenize(jsonObj, jsonObj.dictionary);
    }
    const params = {};
    const staves = [];
    jsonObj.textGroups = jsonObj.textGroups ? jsonObj.textGroups : [];

    // Explode the sparse arrays of attributes into the measures
    SmoScore.deserializeColumnMapped(jsonObj);
    if (typeof(jsonObj.score.preferences) !== 'undefined' && typeof(jsonObj.score.preferences.customProportion) === 'number') {
      SmoMeasure.defaults.customProportion = jsonObj.score.preferences.customProportion;
    }
    params.layout = JSON.parse(JSON.stringify(SmoScore.defaults.layout));
    smoSerialize.serializedMerge(
      SmoScore.defaultAttributes,
      jsonObj.score, params);
    SmoScore.layoutAttributes.forEach((attr) => {
      if (typeof(params.layout[attr]) === 'undefined') {
        params.layout[attr] = SmoScore.defaults.layout[attr];
      }
    });
    /* if (!params.layout.noteSpacing) {
      params.layout.noteSpacing = SmoScore.defaults.layout.noteSpacing;
    }  should not need this */
    jsonObj.staves.forEach((staffObj) => {
      const staff = SmoSystemStaff.deserialize(staffObj);
      staves.push(staff);
    });
    const scoreText = [];
    jsonObj.scoreText.forEach((tt) => {
      const st = SmoScoreModifierBase.deserialize(tt);
      st.autoLayout = false; // since this has been layed out, presumably, before save
      st.classes = 'score-text ' + st.attrs.id;
      scoreText.push(st);
    });

    const textGroups = [];
    jsonObj.textGroups.forEach((tg) => {
      textGroups.push(SmoTextGroup.deserialize(tg));
    });

    const systemGroups = [];
    if (jsonObj.systemGroups) {
      jsonObj.systemGroups.forEach((tt) => {
        var st = SmoScoreModifierBase.deserialize(tt);
        st.autoLayout = false; // since this has been layed out, presumably, before save
        systemGroups.push(st);
      });
    }
    params.staves = staves;
    const score = new SmoScore(params);
    score.scoreText = scoreText;
    score.textGroups = textGroups;
    score.systemGroups = systemGroups;
    score.scoreInfo.version += 1;
    return score;
  }

  // ### getDefaultScore
  // Gets a score consisting of a single measure with all the defaults.
  static getDefaultScore(scoreDefaults, measureDefaults) {
    scoreDefaults = typeof(scoreDefaults) !== 'undefined' ? scoreDefaults : SmoScore.defaults;
    measureDefaults = typeof(measureDefaults) !== 'undefined' ? measureDefaults : SmoMeasure.defaults;
    const score = new SmoScore(scoreDefaults);
    score.addStaff();
    const measure = SmoMeasure.getDefaultMeasure(measureDefaults);
    score.addMeasure(0, measure);
    measure.voices.push({
      notes: SmoMeasure.getDefaultNotes(measureDefaults)
    });
    return score;
  }

  // ### getEmptyScore
  // Create a score object, but don't populate it with anything.
  static getEmptyScore(scoreDefaults) {
    const score = new SmoScore(scoreDefaults);
    score.addStaff();
    return score;
  }

  setLayout(layout) {
    const param = {};
    smoSerialize.serializedMerge(SmoScore.layoutAttributes, SmoScore.defaults.layout, param);
    smoSerialize.serializedMerge(SmoScore.layoutAttributes, layout, param);
    this.layout = JSON.parse(JSON.stringify(param));
  }
  // ### numberStaves
  // recursively renumber staffs and measures.
  numberStaves() {
    let i = 0;
    for (i = 0; i < this.staves.length; ++i) {
      const stave = this.staves[i];
      stave.staffId = i;
      stave.numberMeasures();
    }
  }

  // ### addDefaultMeasureWithNotes
  // ### Description:
  // Add a measure to the score with the supplied parameters at the supplied index.
  // The defaults per staff may be different depending on the clef, key of the staff.
  addDefaultMeasureWithNotes(measureIndex, parameters) {
    this.staves.forEach((staff) => {
      const defaultMeasure =
        SmoMeasure.getDefaultMeasureWithNotes(parameters);
      staff.addMeasure(measureIndex, defaultMeasure);
    });
  }

  // ### deleteMeasure
  // Delete the measure at the supplied index in all the staves.
  deleteMeasure(measureIndex) {
    this.staves.forEach((staff) => {
      staff.deleteMeasure(measureIndex);
    });
    // adjust offset if text was attached to any missing measures after the deleted one.
    this.textGroups.forEach((tg) => {
      if (tg.attachToSelector && tg.selector.measure >= measureIndex && tg.selector.measure > 0) {
        tg.selector.measure -= 1;
      }
    });
  }

  convertToPickupMeasure(measureIndex, duration) {
    let i = 0;
    for (i = 0; i < this.staves.length; ++i) {
      const staff = this.staves[i];
      const protomeasure = staff.measures[measureIndex].pickupMeasure(duration);
      staff.measures[measureIndex] = protomeasure;
    }
    this.numberStaves();
  }

  addPickupMeasure(measureIndex, duration) {
    this.convertToPickupMeasure(measureIndex, duration);
  }
  getPrototypeMeasure(measureIndex, staffIndex) {
    const staff = this.staves[staffIndex];
    let protomeasure = {};

    // Since this staff may already have instrument settings, use the
    // immediately preceeding or post-ceding measure if it exists.
    if (measureIndex < staff.measures.length) {
      protomeasure = staff.measures[measureIndex];
    } else if (staff.measures.length) {
      protomeasure = staff.measures[staff.measures.length - 1];
    }
    return SmoMeasure.getDefaultMeasureWithNotes(protomeasure);
  }

  // ### addMeasure
  // Give a measure prototype, create a new measure and add it to each staff, with the
  // correct settings for current time signature/clef.
  addMeasure(measureIndex) {
    let i = 0;
    for (i = 0; i < this.staves.length; ++i) {
      const staff = this.staves[i];
      const nmeasure = this.getPrototypeMeasure(measureIndex, i);
      if (nmeasure.voices.length <= nmeasure.getActiveVoice()) {
        nmeasure.setActiveVoice(0);
      }
      staff.addMeasure(measureIndex, nmeasure);
    }
    // Update offsets for score modifiers that have a selector
    this.textGroups.forEach((tg) => {
      if (tg.attachToSelector && tg.selector.measure >= measureIndex && tg.selector.measure < this.staves[0].measures.length) {
        tg.selector.measure += 1;
      }
    });
    this.numberStaves();
  }

  // ### replaceMeasure
  // Replace the measure at the given location.  Probably due to an undo operation or paste.
  replaceMeasure(selector, measure) {
    var staff = this.staves[selector.staff];
    staff.measures[selector.measure] = measure;
  }

  getSystemGroupForStaff(selection) {
    const exist = this.systemGroups.find((sg) =>
      sg.startSelector.staff <= selection.staff.staffId &&
        sg.endSelector.staff >= selection.staff.staffId &&
        (sg.mapType === SmoSystemGroup.mapTypes.allMeasures ||
        (sg.startSelector.measure <= selection.measure.measureNumber.measureIndex &&
        sg.endSelector.measure >= selection.measure.measureNumber.measureIndex))
    );
    return exist;
  }

  getStavesForGroup(group) {
    return this.staves.filter((staff) => staff.staffId >= group.startSelector.staff &&
      staff.staffId <= group.endSelector.staff);
  }

  // ### addOrReplaceSystemGroup
  // Add a new staff grouping, or replace it if it overlaps and is different, or
  // remove it if it is identical (toggle)
  addOrReplaceSystemGroup(newGroup) {
    // Replace this group for any groups that overlap it.
    this.systemGroups = this.systemGroups.filter((sg) => !sg.overlaps(newGroup));
    this.systemGroups.push(newGroup);
  }

  // ### replace staff
  // Probably due to an undo operation, replace the staff at the given index.
  replaceStaff(index, staff) {
    const staves = [];
    let i = 0;
    for (i = 0; i < this.staves.length; ++i) {
      if (i !== index) {
        staves.push(this.staves[i]);
      } else {
        staves.push(staff);
      }
    }
    this.staves = staves;
  }
  // ### addKeySignature
  // Add a key signature at the specified index in all staves.
  addKeySignature(measureIndex, key) {
    this.staves.forEach((staff) => {
      // Consider transpose for key of instrument
      const netOffset = staff.measures[measureIndex].transposeIndex;
      const newKey = smoMusic.vexKeySigWithOffset(key, netOffset);
      staff.addKeySignature(measureIndex, newKey);
    });
  }

  // ### addInstrument
  // add a new staff (instrument) to the score
  addStaff(parameters) {
    let i = 0;
    if (this.staves.length === 0) {
      const staff = new SmoSystemStaff(parameters);
      this.staves.push(staff);
      this.activeStaff = 0;
      // For part views, we renumber the staves even if there is only one staff.
      if (staff.measures.length) {
        this.numberStaves();
      }
      return;
    }
    if (!parameters) {
      parameters = SmoSystemStaff.defaults;
    }
    const proto = this.staves[0];
    const measures = [];
    for (i = 0; i < proto.measures.length; ++i) {
      const newParams = {};
      const measure = proto.measures[i];
      smoSerialize.serializedMerge(SmoMeasure.defaultAttributes, measure, newParams);
      newParams.clef = parameters.instrumentInfo.clef;
      newParams.transposeIndex = parameters.instrumentInfo.keyOffset;
      const newMeasure = SmoMeasure.getDefaultMeasureWithNotes(newParams);
      newMeasure.measureNumber = measure.measureNumber;
      // Consider key change if the proto measure is non-concert pitch
      newMeasure.keySignature =
        smoMusic.vexKeySigWithOffset(newMeasure.keySignature,
          newMeasure.transposeIndex - measure.transposeIndex);
      newMeasure.modifiers = [];
      measure.modifiers.forEach((modifier) => {
        const ctor = eval(modifier.ctor);
        const nmod = new ctor(modifier);
        newMeasure.modifiers.push(nmod);
      });
      measures.push(newMeasure);
    }
    parameters.measures = measures;
    const staff = new SmoSystemStaff(parameters);
    this.staves.push(staff);
    this.activeStaff = this.staves.length - 1;
    this.numberStaves();
  }

  // ### removeStaff
  // Remove stave at the given index
  removeStaff(index) {
    const staves = [];
    let ix = 0;
    this.staves.forEach((staff) => {
      if (ix !== index) {
        staves.push(staff);
      }
      ix += 1;
    });
    this.staves = staves;
    this.numberStaves();
  }

  swapStaves(index1, index2) {
    if (this.staves.length < index1 || this.staves.length < index2) {
      return;
    }
    const tmpStaff = this.staves[index1];
    this.staves[index1] = this.staves[index2];
    this.staves[index2] = tmpStaff;
    this.numberStaves();
  }

  _updateScoreText(textObject, toAdd) {
    var texts = [];
    this.scoreText.forEach((tt) => {
      if (textObject.attrs.id !==  tt.attrs.id) {
        texts.push(tt);
      }
    });
    if (toAdd) {
      texts.push(textObject);
    }
    this.scoreText = texts;
  }

  _updateTextGroup(textGroup, toAdd) {
    const tgid = typeof(textGroup) === 'string' ? textGroup :
      textGroup.attrs.id;
    const ar = this.textGroups.filter((tg) => tg.attrs.id !== tgid);
    this.textGroups = ar;
    if (toAdd) {
      this.textGroups.push(textGroup);
    }
  }
  addTextGroup(textGroup) {
    this._updateTextGroup(textGroup, true);
  }
  getTextGroups() {
    return this.textGroups;
  }

  removeTextGroup(textGroup) {
    this._updateTextGroup(textGroup, false);
  }

  addScoreText(textObject) {
    this._updateScoreText(textObject, true);
  }

  getScoreText(id) {
    if (!this.scoreText.length) {
      return null;
    }
    const ar = this.scoreText.filter((tt) =>
      tt.attrs.id === id
    );
    if (ar.length) {
      return ar[0];
    }
    return null;
  }

  removeScoreText(textObject) {
    this._updateScoreText(textObject, false);
  }
  setLyricAdjustWidth(adjustNoteWidth) {
    this.staves.forEach((staff) => {
      staff.setLyricAdjustWidth(adjustNoteWidth);
    });
  }

  setChordAdjustWidth(adjustNoteWidth) {
    this.staves.forEach((staff) => {
      staff.setChordAdjustWidth(adjustNoteWidth);
    });
  }
  // ### setLyricFont
  // set the font for lyrics, which are the same for all lyrics in the score
  setLyricFont(fontInfo) {
    this.staves.forEach((staff) => {
      staff.setLyricFont(fontInfo);
    });

    const fontInst = this.fonts.find((fn) => fn.name === 'lyrics');
    fontInst.family = fontInfo.family;
    fontInst.size = fontInfo.size;
    fontInst.custom = true;
  }

  setChordFont(fontInfo) {
    this.staves.forEach((staff) => {
      staff.setChordFont(fontInfo);
    });
  }

  get measures() {
    if (this.staves.length === 0) {
      return [];
    }
    return this.staves[this.activeStaff].measures;
  }
  incrementActiveStaff(offset) {
    if (offset < 0) {
      offset = offset + this.staves.length;
    }
    const nextStaff = (this.activeStaff + offset) % this.staves.length;
    if (nextStaff >= 0 && nextStaff < this.staves.length) {
      this.activeStaff = nextStaff;
    }
    return this.activeStaff;
  }

  setActiveStaff(index) {
    this.activeStaff = index <= this.staves.length ? index : this.activeStaff;
  }

  getRenderedNote(id) {
    let i = 0;
    for (i = 0; i < this.staves.length; ++i) {
      const stave = this.staves[i];
      const note = stave.getRenderedNote(id);
      if (note) {
        note.selection.staffIndex = i;
        return note;
      }
    }
    return null;
  }
}
;// ## SmoScoreModifierBase
// A score modifier is something that appears in the score, but not
// associated with a measure of music.
// eslint-disable-next-line no-unused-vars
class SmoScoreModifierBase {
  constructor(ctor) {
    this.ctor = ctor;
    if (!this.attrs) {
      this.attrs = {
        id: VF.Element.newID(),
        type: ctor
      };
    }
  }

  static deserialize(jsonObj) {
    const ctor = eval(jsonObj.ctor);
    const rv = new ctor(jsonObj);
    return rv;
  }
}

// ## SmoSystemGroup
// System group is the grouping of staves into a system.
// eslint-disable-next-line no-unused-vars
class SmoSystemGroup extends SmoScoreModifierBase {
  constructor(params) {
    super('SmoSystemGroup');
    smoSerialize.serializedMerge(SmoSystemGroup.attributes, SmoSystemGroup.defaults, this);
    smoSerialize.serializedMerge(SmoSystemGroup.attributes, params, this);

    if (!this.attrs) {
      this.attrs = {
        id: VF.Element.newID(),
        type: 'SmoSystemGroup'
      };
    }
  }
  static get connectorTypes() {
    return { brace: 0, bracket: 1, single: 2, double: 3 };
  }
  static get mapTypes() {
    return { allMeasures: 0, range: 1 };
  }
  static get attributes() {
    return ['leftConnector', 'rightConnector', 'text', 'shortText', 'justify',
      'startSelector', 'endSelector', 'mapType'];
  }
  static get defaults() {
    return {
      leftConnector: SmoSystemGroup.connectorTypes.single,
      rightConnector: SmoSystemGroup.connectorTypes.single,
      mapType: SmoSystemGroup.mapTypes.allMeasures,
      text: '',
      shortText: '',
      justify: true,
      startSelector: { staff: 0, measure: 0 },
      endSelector: { staff: 0, measure: 0 }
    };
  }
  stavesOverlap(group) {
    return (this.startSelector.staff >= group.startSelector.staff && this.startSelector.staff <= group.endSelector.staff) ||
      (this.endSelector.staff >= group.startSelector.staff && this.endSelector.staff <= group.endSelector.staff);
  }
  measuresOverlap(group) {
    return this.stavesOverlap(group) &&
      ((this.startSelector.measure >= group.startSelector.measure && this.endSelector.measure <= group.startSelector.measure) ||
        (this.endSelector.measure >= group.startSelector.measure && this.endSelector.measure <= group.endSelector.measure));
  }
  overlaps(group) {
    return (this.stavesOverlap(group) && this.mapType === SmoSystemGroup.mapTypes.allMeasures) ||
      (this.measuresOverlap(group) && this.mapType === SmoSystemGroup.mapTypes.range);
  }
  leftConnectorVx() {
    switch (this.leftConnector) {
      case SmoSystemGroup.connectorTypes.single:
        return VF.StaveConnector.type.SINGLE_LEFT;
      case SmoSystemGroup.connectorTypes.double:
        return VF.StaveConnector.type.DOUBLE_LEFT;
      case SmoSystemGroup.connectorTypes.brace:
        return VF.StaveConnector.type.BRACE;
      case SmoSystemGroup.connectorTypes.bracket:
      default:
        return VF.StaveConnector.type.BRACKET;
    }
  }
  rightConnectorVx() {
    switch (this.rightConnector) {
      case SmoSystemGroup.connectorTypes.single:
        return StaveConnector.type.SINGLE_RIGHT;
      case SmoSystemGroup.connectorTypes.double:
      default:
        return StaveConnector.type.DOUBLE_RIGHT;
    }
  }
  serialize() {
    const params = {};
    smoSerialize.serializedMergeNonDefault(SmoSystemGroup.defaults, SmoSystemGroup.attributes, this, params);
    params.ctor = 'SmoSystemGroup';
    return params;
  }
}

// ## SmoTextGroup
// A grouping of text that can be used as a block for
// justification, alignment etc.
// eslint-disable-next-line no-unused-vars
class SmoTextGroup extends SmoScoreModifierBase {
  static get justifications() {
    return {
      LEFT: 1,
      RIGHT: 2,
      CENTER: 3
    };
  }
  static get paginations() {
    return { EVERY: 1, EVENT: 2, ODD: 3, ONCE: 4, SUBSEQUENT: 5 };
  }

  // The position of block n relative to block n-1.  Each block
  // has it's own position.  Justification is inter-block.
  static get relativePositions() {
    return { ABOVE: 1, BELOW: 2, LEFT: 3, RIGHT: 4 };
  }

  static get purposes() {
    return {
      NONE: 1, TITLE: 2, SUBTITLE: 3, COMPOSER: 4, COPYRIGHT: 5
    };
  }
  static get attributes() {
    return ['textBlocks', 'justification', 'relativePosition', 'spacing', 'pagination', 'attachToSelector', 'selector', 'musicXOffset', 'musicYOffset'];
  }
  static get purposeToFont() {
    const rv = {};
    rv[SmoTextGroup.purposes.TITLE] = {
      fontFamily: 'Merriweather',
      fontSize: 18,
      justification: SmoTextGroup.justifications.CENTER,
      xPlacement: 0.5,
      yOffset: 4
    };
    rv[SmoTextGroup.purposes.SUBTITLE] = {
      fontFamily: 'Merriweather',
      fontSize: 16,
      justification: SmoTextGroup.justifications.CENTER,
      xPlacement: 0.5,
      yOffset: 20,
    };
    rv[SmoTextGroup.purposes.COMPOSER] = {
      fontFamily: 'Merriweather',
      fontSize: 12,
      justification: SmoTextGroup.justifications.RIGHT,
      xPlacement: 0.8,
      yOffset: 10
    };
    rv[SmoTextGroup.purposes.COPYRIGHT] = {
      fontFamily: 'Merriweather',
      fontSize: 12,
      xPlacement: 0.5,
      justification: SmoTextGroup.justifications.CENTER,
      yOffset: -12
    };
    return rv;
  }
  // ### createTextForLayout
  // Create a specific score text type (title etc.) based on the supplied
  // score layout
  static createTextForLayout(purpose, text, layout) {
    let x = 0;
    const textAttr = SmoTextGroup.purposeToFont[purpose];
    const pageWidth = layout.pageWidth / layout.svgScale;
    const pageHeight = layout.pageHeight / layout.svgScale;
    const bottomMargin = layout.bottomMargin / layout.svgScale;
    const topMargin = layout.topMargin / layout.svgScale;
    x = textAttr.xPlacement > 0 ? pageWidth * textAttr.xPlacement
      : pageWidth - (pageWidth * textAttr.xPlacement);
    const y = textAttr.yOffset > 0 ?
      topMargin + textAttr.yOffset :
      pageHeight + textAttr.yOffset - bottomMargin;
    const st = new SmoScoreText({ text, x, y,
      fontInfo: { family: textAttr.fontFamily, size: textAttr.fontSize } });
    const width = st.estimateWidth();
    x -= width / 2;
    const tg = new SmoTextGroup({ blocks: [st], purpose, pagination: SmoTextGroup.paginations.EVERY });
    return tg;
  }

  static get defaults() {
    return { textBlocks: [],
      justification: SmoTextGroup.justifications.LEFT,
      relativePosition: SmoTextGroup.relativePositions.RIGHT,
      pagination: SmoTextGroup.paginations.ONCE,
      purpose: SmoTextGroup.purposes.NONE,
      spacing: 0,
      attachToSelector: false,
      selector: null,
      musicXOffset: 0,
      musicYOffset: 0
    };
  }
  static deserialize(jObj) {
    const blocks = [];
    const params = {};

    // Create new scoreText object for the text blocks
    jObj.textBlocks.forEach((st) => {
      const tx = new SmoScoreText(st.text);
      blocks.push({ text: tx, position: st.position });
    });
    // fill in the textBlock configuration
    SmoTextGroup.attributes.forEach((attr) => {
      if (attr !== 'textBlocks') {
        if (typeof(jObj[attr]) !== 'undefined') {
          params[attr] = jObj[attr];
        }
      }
    });
    params.blocks = blocks;
    return new SmoTextGroup(params);
  }
  // ### getPagedTextGroups
  // If this text is repeated on page, create duplicates for each page, and
  // resolve page numbers;
  static getPagedTextGroups(tg, pages, pageHeight) {
    const rv = [];
    let i = 0;
    if (tg.pagination === SmoTextGroup.paginations.ONCE) {
      rv.push(tg);
      return rv;
    }
    for (i = 0; i < pages; ++i) {
      const ix = i;
      const nblocks = [];
      // deep copy the blocks so the page offsets don't bleed into
      // original.
      tg.textBlocks.forEach((block) => {
        const nscoreText = new SmoScoreText(block.text);
        nblocks.push({
          text: nscoreText, position: block.position
        });
      });
      const params = {};
      SmoTextGroup.attributes.forEach((attr) => {
        if (attr !== 'textBlocks') {
          params[attr] = tg[attr];
        }
      });
      params.blocks = nblocks;
      const ngroup = new SmoTextGroup(params);
      ngroup.textBlocks.forEach((block) => {
        const xx = block.text;
        xx.classes = 'score-text ' + xx.attrs.id;
        xx.text = xx.text.replace('###', ix + 1); /// page number
        xx.text = xx.text.replace('@@@', pages); /// page number
        xx.y += pageHeight * ix;
      });
      rv.push(ngroup);
    }
    return rv;
  }
  serialize() {
    const params = {};
    smoSerialize.serializedMergeNonDefault(SmoTextGroup.defaults, SmoTextGroup.attributes, this, params);
    params.ctor = 'SmoTextGroup';
    params.attrs = JSON.parse(JSON.stringify(this.attrs));
    return params;
  }
  _isScoreText(st) {
    return st.ctor && st.ctor === 'SmoScoreText';
  }
  constructor(params) {
    super('SmoTextGroup');
    if (typeof(params) === 'undefined') {
      params = {};
    }
    this.textBlocks = [];
    this.backupBlocks = [];
    Vex.Merge(this, SmoTextGroup.defaults);
    Vex.Merge(this, params);
    if (params.blocks) {
      params.blocks.forEach((block) => {
        if (this._isScoreText(block)) {
          this.textBlocks.push({ text: block, position: SmoTextGroup.relativePositions.RIGHT });
        } else if (this._isScoreText(block.text)) {
          this.textBlocks.push(block);
        } else {
          throw 'Invalid object in SmoTextGroup';
        }
      });
    }
  }
  // ### tryParseUnicode
  // Try to parse unicode strings.
  tryParseUnicode() {
    this.textBlocks.forEach((tb) => {
      tb.text.tryParseUnicode();
    });
  }
  estimateWidth() {
    let rv = 0;
    this.textBlocks.forEach((tb) => {
      rv += tb.text.estimateWidth();
    });
    return rv;
  }
  // avoid saving text that can't be deleted
  isTextVisible() {
    let rv = true;
    if (this.attachToSelector) {
      return true;
    }
    this.textBlocks.forEach((block) => {
      if (block.text.x < 0 || block.text.y < 0) {
        rv = false;
      }
    });
    return rv;
  }
  // ### setActiveBlock
  // let the UI know which block is being edited.  Parameter null means reset all
  setActiveBlock(scoreText) {
    this.textBlocks.forEach((block) => {
      if (scoreText != null && block.text.attrs.id === scoreText.attrs.id) {
        block.activeText = true;
      } else {
        block.activeText = false;
      }
    });
  }
  // For editing, keep track of the active text block.
  getActiveBlock() {
    const rv = this.textBlocks.find((block) => block.activeText === true);
    if (typeof(rv) !== 'undefined') {
      return rv.text;
    }
    return this.textBlocks[0].text;
  }
  setRelativePosition(position) {
    this.textBlocks.forEach((block) => {
      block.position = position;
    });
    this.relativePosition = position;
  }
  firstBlock() {
    return this.textBlocks[0].text;
  }
  indexOf(scoreText) {
    return this.textBlocks.findIndex((block) => block.text.attrs.id === scoreText.attrs.id);
  }
  addScoreText(scoreText, prevBlock, position) {
    if (!this._isScoreText(scoreText)) {
      throw 'Need SmoScoreText to add to TextGroup';
    }
    if (typeof(position) === 'undefined') {
      position = this.relativePosition;
    }
    if (!prevBlock) {
      this.textBlocks.push({ text: scoreText, position });
    } else {
      const bbid =  (typeof(prevBlock) === 'string') ? prevBlock : prevBlock.attrs.id;
      const ix = this.textBlocks.findIndex((bb) => bb.attrs.id === bbid);
      this.textBlocks.splice(ix, 0, nextBlock);
    }
  }
  ul() {
    const rv = { x: 0, y: 0 };
    this.textBlocks.forEach((block) => {
      rv.x = block.text.x > rv.x ? block.text.x : rv.x;
      rv.y = block.text.y > rv.y ? block.text.y : rv.y;
    });
    return rv;
  }
  removeBlock(scoreText) {
    if (!this._isScoreText(scoreText)) {
      throw 'Need SmoScoreText to add to TextGroup';
    }
    const bbid = (typeof(scoreText) === 'string') ? scoreText : scoreText.attrs.id;
    const ix = this.textBlocks.findIndex((bb) => bb.text.attrs.id === bbid);
    this.textBlocks.splice(ix, 1);
  }
  offsetX(offset) {
    if (this.attachToSelector) {
      this.musicXOffset += offset;
    }
    this.textBlocks.forEach((block) => {
      block.text.offsetX(offset);
    });
  }
  offsetY(offset) {
    if (this.attachToSelector) {
      this.musicYOffset -= offset;
    }
    this.textBlocks.forEach((block) => {
      block.text.offsetY(offset);
    });
  }

  scaleInPlace(factor) {
    this.textBlocks.forEach((block) => {
      block.text.scaleInPlace(factor);
    });
  }
  scaleXInPlace(factor) {
    this.textBlocks.forEach((block) => {
      block.text.scaleXInPlace(factor);
    });
  }
  scaleYInPlace(factor) {
    this.textBlocks.forEach((block) => {
      block.text.scaleYInPlace(factor);
    });
  }
}
// ## SmoScoreText
// Identify some text in the score, not associated with any musical element, like page
// decorations, titles etc.
// Note: score text is always contained in a text group.  So this isn't directly accessed
// by score, but we keep the collection in score for backwards-compatibility
// eslint-disable-next-line no-unused-vars
class SmoScoreText extends SmoScoreModifierBase {
  // convert EM to a number, or leave as a number etc.
  static fontPointSize(size) {
    let rv = 12;
    if (typeof(size) === 'number') {
      return size;
    }
    const ptString = size.substring(0, size.length - 2);
    rv = parseFloat(ptString);
    if (size.indexOf('em') > 0) {
      rv *= 14;
    } else if (size.indexOf('px') > 0) {
      rv *= (96.0 / 72.0);
    }
    return rv;
  }

  // ### weightString
  // Convert a numeric or string weight into either 'bold' or 'normal'
  static weightString(fontWeight) {
    let rv = 'normal';
    if (fontWeight) {
      const numForm = parseInt(fontWeight, 10);
      if (isNaN(numForm)) {
        rv = fontWeight;
      } else if (numForm > 500) {
        rv = 'bold';
      }
    }
    return rv;
  }

  static get paginations() {
    return { every: 'every', even: 'even', odd: 'odd', once: 'once', subsequent: 'subsequent' };
  }
  static get positions() {
    return { title: 'title', copyright: 'copyright', footer: 'footer', header: 'header', custom: 'custom' };
  }
  static get justifications() {
    return { left: 'left', right: 'right', center: 'center' };
  }
  static get fontFamilies() {
    return { serif: 'Merriweather', sansSerif: 'Roboto,sans-serif', monospace: 'monospace', cursive: 'cursive',
      times: 'Merriweather', arial: 'Arial' };
  }
  // If box model is 'none', the font and location determine the size.
  // spacing and spacingGlyph fit the box into a container based on the svg policy
  static get boxModels() {
    return { none: 'none', spacing: 'spacing', spacingAndGlyphs: 'spacingAndGlyphs', wrap: 'wrap' };
  }
  static get defaults() {
    return {
      x: 15,
      y: 15,
      width: 0,
      height: 0,
      text: 'Smoosic',
      fontInfo: {
        size: 14,
        family: SmoScoreText.fontFamilies.serif,
        style: 'normal',
        weight: 'normal'
      },
      fill: 'black',
      rotate: 0,
      justification: SmoScoreText.justifications.left,
      classes: 'score-text',
      boxModel: 'none',
      scaleX: 1.0,
      scaleY: 1.0,
      translateX: 0,
      translateY: 0,
      pagination: 'once',
      position: 'custom',
      autoLayout: false // set to true if one of the pre-canned positions are used.
    };
  }
  static toSvgAttributes(inst) {
    const rv = [];
    const fkeys = Object.keys(inst.fontInfo);
    const fontFamily = SmoScoreText[inst.fontInfo.family] ? SmoScoreText[inst.fontInfo.family] : inst.fontInfo.family;
    fkeys.forEach((key) => {
      var n = JSON.parse('{"font-' + key + '":"' + inst.fontInfo[key] + '"}');
      if (n['font-family']) {
        n['font-family'] = fontFamily;
      }
      rv.push(n);
    });

    rv.push({ fill: inst.fill });
    rv.push({ x: inst.x });
    rv.push({ y: inst.y });
    if (inst.boxModel !== 'none' && inst.width) {
      const len = '' + inst.width + 'px';
      rv.push({ textLength: len });
    }
    rv.push({ transform: 'translate (' + inst.translateX + ' ' + inst.translateY + ') scale (' +
        inst.scaleX + ' ' + inst.scaleY + ')' });
    return rv;
  }

  getText() {
    return this.text;
  }
  estimateWidth() {
    let i = 0;
    let rv = 0;
    const textFont = VF.TextFont.getTextFontFromVexFontData({
      family: this.fontInfo.family,
      size: this.fontInfo.size,
      weight: this.fontInfo.weight,
      style: this.fontInfo.style
    });
    textFont.setFontSize(this.fontInfo.size);
    for (i = 0; i < this.text.length; ++i) {
      rv += textFont.getWidthForCharacter(this.text[i]);
    }
    return rv;
  }

  toSvgAttributes() {
    return SmoScoreText.toSvgAttributes(this);
  }

  // ### backupParams
  // For animation or estimation, create a copy of the attributes that can be modified without affecting settings.
  backupParams() {
    this.backup = {};
    smoSerialize.serializedMerge(SmoScoreText.attributes, this, this.backup);
    return this.backup;
  }

  tryParseUnicode() {
    return smoSerialize.tryParseUnicode(this.text);
  }
  restoreParams() {
    smoSerialize.serializedMerge(SmoScoreText.attributes, this.backup, this);
  }

  offsetX(offset) {
    this.x += offset;
  }
  offsetY(offset) {
    this.y += offset;
  }

  serialize() {
    const params = {};
    smoSerialize.serializedMergeNonDefault(SmoScoreText.defaults, SmoScoreText.attributes, this, params);
    params.ctor = 'SmoScoreText';
    return params;
  }
  static get attributes() {
    return ['x', 'y', 'text', 'pagination', 'position', 'fontInfo', 'classes',
      'boxModel', 'justification', 'fill', 'width', 'height', 'scaleX', 'scaleY',
      'translateX', 'translateY', 'autoLayout'];
  }

  // scale the text without moving it.
  scaleInPlace(factor) {
    this.fontInfo.size = SmoScoreText.fontPointSize(this.fontInfo.size) * factor;
  }
  scaleXInPlace(factor) {
    this.scaleX = factor;
    const deltax = this.x - this.x * this.scaleX;
    this.translateX = deltax;
  }
  scaleYInPlace(factor) {
    this.scaleY = factor;
    const deltay = this.y - this.y * this.scaleY;
    this.translateY = deltay;
  }
  constructor(parameters) {
    let rx = '';
    super('SmoScoreText');
    this.backup = {};
    this.edited = false; // indicate to UI that the actual text has not been edited.

    smoSerialize.serializedMerge(SmoScoreText.attributes, SmoScoreText.defaults, this);
    smoSerialize.serializedMerge(SmoScoreText.attributes, parameters, this);
    if (!this.classes) {
      this.classes = '';
    }
    if (this.classes.indexOf(this.attrs.id) < 0) {
      this.classes += ' ' + this.attrs.id;
    }
    if (this.boxModel === SmoScoreText.boxModels.wrap) {
      this.width = parameters.width ? this.width : 200;
      this.height = parameters.height ? this.height : 150;
    }
    const weight = parameters.fontInfo ? parameters.fontInfo.weight : 'normal';
    this.fontInfo.weight = SmoScoreText.weightString(weight);
    if (this.text) {
      rx = this.text;
      eval('rx="' + this.text + '"');
      this.text = rx;
    }
  }
}
;// ## StaffModifiers
// ## Description:
// This file contains modifiers that might take up multiple measures, and are thus associated
// with the staff.
// ## Staff Modifier Classes:
// ---
// ## StaffModifierBase
// ## Description:
// Base class that mostly standardizes the interface and deals with serialization.
// eslint-disable-next-line no-unused-vars
class StaffModifierBase {
  constructor(ctor) {
    this.ctor = ctor;
  }
  static deserialize(params) {
    const ctor = eval(params.ctor);
    const rv = new ctor(params);
    return rv;
  }
  get isStaffModifier() {
    return true;
  }
}

// ## SmoStaffHairpin
// ## Descpription:
// crescendo/decrescendo
// eslint-disable-next-line no-unused-vars
class SmoStaffHairpin extends StaffModifierBase {
  static get editableAttributes() {
    return ['xOffsetLeft', 'xOffsetRight', 'yOffset', 'height'];
  }
  static get defaults() {
    return {
      xOffsetLeft: -2,
      xOffsetRight: 0,
      yOffset: -50,
      height: 10,
      position: SmoStaffHairpin.positions.BELOW,
      hairpinType: SmoStaffHairpin.types.CRESCENDO
    };
  }
  static get positions() {
    // matches VF.modifier
    return {
      LEFT: 1,
      RIGHT: 2,
      ABOVE: 3,
      BELOW: 4,
    };
  }
  static get types() {
    return {
      CRESCENDO: 1,
      DECRESCENDO: 2
    };
  }
  static get attributes() {
    return ['position', 'startSelector', 'endSelector', 'xOffsetLeft',
      'xOffsetRight', 'yOffset', 'hairpinType', 'height'];
  }
  serialize() {
    const params = {};
    smoSerialize.serializedMergeNonDefault(SmoStaffHairpin.defaults, SmoStaffHairpin.attributes, this, params);
    params.ctor = 'SmoStaffHairpin';
    return params;
  }
  constructor(params) {
    super('SmoStaffHairpin');
    Vex.Merge(this, SmoStaffHairpin.defaults);
    smoSerialize.filteredMerge(SmoStaffHairpin.attributes, params, this);
    // If start/end selector on same note, make sure the hairpin extends
    if (SmoSelector.eq(this.startSelector, this.endSelector)) {
      if (this.xOffsetRight === SmoStaffHairpin.defaults.xOffsetRight
        && this.xOffsetLeft === SmoStaffHairpin.defaults.xOffsetLeft) {
        this.xOffsetLeft = -10;
        this.xOffsetRight = 10;
      }
    }

    if (!this.attrs) {
      this.attrs = {
        id: VF.Element.newID(),
        type: 'SmoStaffHairpin'
      };
    }
  }
}

// ## SmoSlur
// ## Description:
// slur staff modifier
// ## SmoSlur Methods:
// ---
// eslint-disable-next-line no-unused-vars
class SmoSlur extends StaffModifierBase {
  static get defaults() {
    return {
      spacing: 2,
      thickness: 2,
      xOffset: -5,
      yOffset: 10,
      position: SmoSlur.positions.HEAD,
      position_end: SmoSlur.positions.HEAD,
      invert: false,
      cp1x: 0,
      cp1y: 15,
      cp2x: 0,
      cp2y: 15,
      pitchesStart: [],
      pitchesEnd: []
    };
  }

  // matches VF curve
  static get positions() {
    return {
      HEAD: 1,
      TOP: 2
    };
  }
  static get parameterArray() {
    return ['startSelector', 'endSelector', 'spacing', 'xOffset', 'yOffset', 'position', 'position_end', 'invert',
      'cp1x', 'cp1y', 'cp2x', 'cp2y', 'thickness', 'pitchesStart', 'pitchesEnd'];
  }

  serialize() {
    const params = {};
    smoSerialize.serializedMergeNonDefault(SmoSlur.defaults,
      SmoSlur.parameterArray, this, params);

    params.ctor = 'SmoSlur';
    return params;
  }
  get controlPoints() {
    const ar = [{
      x: this.cp1x,
      y: this.cp1y
    }, {
      x: this.cp2x,
      y: this.cp2y
    }];
    return ar;
  }

  constructor(params) {
    super('SmoSlur');
    smoSerialize.serializedMerge(SmoSlur.parameterArray, SmoSlur.defaults, this);
    smoSerialize.serializedMerge(SmoSlur.parameterArray, params, this);
    this.startSelector = params.startSelector;
    this.endSelector = params.endSelector;
    // TODO: allow user to customize these
    if (!this.attrs) {
      this.attrs = {
        id: VF.Element.newID(),
        type: 'SmoSlur'
      };
    }
  }
}

// ## SmoTie
// like slur but multiple pitches
// ---
// eslint-disable-next-line no-unused-vars
class SmoTie extends StaffModifierBase {
  static get defaults() {
    return {
      invert: false,
      cp1: 8,
      cp2: 12,
      first_x_shift: 0,
      last_x_shift: 0,
      lines: []
    };
  }

  static get parameterArray() {
    return ['startSelector', 'endSelector', 'invert', 'lines', 'cp1', 'cp2', 'first_x_shift', 'last_x_shift'];
  }
  static get vexParameters() {
    return ['cp1', 'cp2', 'first_x_shift', 'last_x_shift'];
  }
  static createLines(fromNote, toNote) {
    const maxPitches = Math.max(fromNote.pitches.length, toNote.pitches.length);
    let i = 0;
    const lines = [];
    // By default, just tie all the pitches to all the other pitches in order
    for (i = 0; i < maxPitches; ++i) {
      const from = i < fromNote.pitches.length ? i : fromNote.pitches.length - 1;
      const to = i < toNote.pitches.length ? i : toNote.pitches.length - 1;
      lines.push({ from, to });
    }
    return lines;
  }
  get vexOptions() {
    const rv = {};
    rv.direction = this.invert ? VF.Stem.DOWN : VF.Stem.UP;
    SmoTie.vexParameters.forEach((p) => {
      rv[p] = this[p];
    });
    return rv;
  }

  serialize() {
    const params = {};
    smoSerialize.serializedMergeNonDefault(SmoTie.defaults,
      SmoTie.parameterArray, this, params);

    params.ctor = 'SmoTie';
    return params;
  }
  // ### checkLines
  // If the note chords have changed, the lines may no longer be valid so update them
  checkLines(fromNote, toNote) {
    const maxTo = this.lines.map((ll) => ll.to).reduce((a, b) => a > b ? a : b);
    const maxFrom = this.lines.map((ll) => ll.from).reduce((a, b) => a > b ? a : b);
    if (maxTo < toNote.pitches.length && maxFrom < fromNote.pitches.length) {
      return;
    }
    this.lines = SmoTie.createLines(fromNote, toNote);
  }
  constructor(params) {
    super('SmoTie');
    smoSerialize.serializedMerge(SmoTie.parameterArray, SmoTie.defaults, this);
    smoSerialize.serializedMerge(SmoTie.parameterArray, params, this);
    if (!this.attrs) {
      this.attrs = {
        id: VF.Element.newID(),
        type: 'SmoTie'
      };
    }
  }
}
;// ## SmoSystemStaff
// A staff is a line of music that can span multiple measures.
// A system is a line of music for each staff in the score.  So a staff
// spans multiple systems.
// A staff modifier connects 2 points in the staff.
// eslint-disable-next-line no-unused-vars
class SmoSystemStaff {
  constructor(params) {
    this.measures = [];
    Vex.Merge(this, SmoSystemStaff.defaults);
    Vex.Merge(this, params);
    if (this.measures.length) {
      this.numberMeasures();
    }
    if (!this.attrs) {
      this.attrs = {
        id: VF.Element.newID(),
        type: 'SmoSystemStaff'
      };
    }
  }

  // ### defaultParameters
  // the parameters that get saved with the score.
  static get defaultParameters() {
    return [
      'staffId', 'staffX', 'staffY', 'adjY', 'staffWidth', 'staffHeight', 'startIndex',
      'renumberingMap', 'keySignatureMap', 'instrumentInfo'];
  }

  // ### defaults
  // default values for all instances
  static get defaults() {
    return {
      staffX: 10,
      staffY: 40,
      adjY: 0,
      staffWidth: 1600,
      staffHeight: 90,
      startIndex: 0,
      staffId: 0,
      renumberingMap: { },
      keySignatureMap: { },
      instrumentInfo: {
        instrumentName: 'Treble Instrument',
        keyOffset: '0',
        clef: 'treble'
      },
      measures: [],
      modifiers: []
    };
  }

  // ### serialize
  // JSONify self.
  serialize() {
    const params = {};
    smoSerialize.serializedMerge(SmoSystemStaff.defaultParameters, this, params);
    params.modifiers = [];
    params.measures = [];

    this.measures.forEach((measure) => {
      params.measures.push(measure.serialize());
    });

    this.modifiers.forEach((modifier) => {
      params.modifiers.push(modifier.serialize());
    });

    return params;
  }

  // ### deserialize
  // parse formerly serialized staff.
  static deserialize(jsonObj) {
    const params = {};
    smoSerialize.serializedMerge(
      ['staffId', 'staffX', 'staffY', 'staffWidth',
        'startIndex', 'renumberingMap', 'renumberIndex', 'instrumentInfo'],
      jsonObj, params);
    params.measures = [];
    jsonObj.measures.forEach((measureObj) => {
      const measure = SmoMeasure.deserialize(measureObj);
      params.measures.push(measure);
    });
    const rv = new SmoSystemStaff(params);
    if (jsonObj.modifiers) {
      jsonObj.modifiers.forEach((params) => {
        const mod = StaffModifierBase.deserialize(params);
        rv.modifiers.push(mod);
      });
    }
    return rv;
  }

  // ### addStaffModifier
  // add a staff modifier, or replace a modifier of same type
  // with same endpoints.
  addStaffModifier(modifier) {
    this.removeStaffModifier(modifier);
    this.modifiers.push(modifier);
  }

  // ### removeStaffModifier
  // Remove a modifier of given type and location
  removeStaffModifier(modifier) {
    const mods = [];
    this.modifiers.forEach((mod) => {
      if (mod.attrs.type !== modifier.attrs.type ||
        SmoSelector.neq(mod.startSelector, modifier.startSelector) ||
        SmoSelector.neq(mod.endSelector, modifier.endSelector)) {
        mods.push(mod);
      }
    });
    this.modifiers = mods;
  }

  // ### getModifiersAt
  // get any modifiers at the selected location
  getModifiersAt(selector) {
    const rv = [];
    this.modifiers.forEach((mod) => {
      if (SmoSelector.sameNote(mod.startSelector, selector)) {
        rv.push(mod);
      }
    });
    return rv;
  }
  getModifier(modData) {
    return this.getModifiers().find((mod) =>
      SmoSelector.eq(mod.startSelector, modData.startSelector) && mod.attrs.type === modData.attrs.type);
  }

  setLyricFont(fontInfo) {
    this.measures.forEach((measure) => {
      measure.setLyricFont(fontInfo);
    });
  }
  setLyricAdjustWidth(adjustNoteWidth) {
    this.measures.forEach((measure) => {
      measure.setLyricAdjustWidth(adjustNoteWidth);
    });
  }
  setChordFont(fontInfo) {
    this.measures.forEach((measure) => {
      measure.setChordFont(fontInfo);
    });
  }
  setChordAdjustWidth(adjustNoteWidth) {
    this.measures.forEach((measure) => {
      measure.setChordAdjustWidth(adjustNoteWidth);
    });
  }

  // ### getSlursStartingAt
  // like it says.  Used by audio player to slur notes
  getSlursStartingAt(selector) {
    return this.modifiers.filter((mod) =>
      SmoSelector.sameNote(mod.startSelector, selector) && mod.attrs.type === 'SmoSlur'
    );
  }
  // ### getSlursEndingAt
  // like it says.
  getSlursEndingAt(selector) {
    return this.modifiers.filter((mod) =>
      SmoSelector.sameNote(mod.endSelector, selector)
    );
  }

  getTieStartingAt(selector) {
    return this.modifiers.filter((mod) =>
      SmoSelector.sameNote(mod.startSelector, selector) && mod.attrs.type === 'SmoTie'
    );
  }
  getTieEndingAt(selector) {
    return this.modifiers.filter((mod) =>
      SmoSelector.sameNote(mod.endSelector, selector) && mod.attrs.type === 'SmoTie'
    );
  }

  // ### accesor getModifiers
  getModifiers() {
    return this.modifiers;
  }

  // ### applyBeams
  // group all the measures' notes into beam groups.
  applyBeams() {
    for (let i = 0; i < this.measures.length; ++i) {
      const measure = this.measures[i];
      smoBeamerFactory.applyBeams(measure);
    }
  }

  // ### getRenderedNote
  // used by mapper to get the rendered note from it's SVG DOM ID.
  getRenderedNote(id) {
    let i = 0;
    for (i = 0; i < this.measures.length; ++i) {
      const measure = this.measures[i];
      const note = measure.getRenderedNote(id);
      if (note) {
        return {
          smoMeasure: measure,
          smoNote: note.smoNote,
          smoSystem: this,
          selection: {
            measureIndex: measure.measureNumber.measureIndex,
            voice: measure.activeVoice,
            tick: note.tick,
            maxTickIndex: measure.notes.length,
            maxMeasureIndex: this.measures.length
          },
          type: note.smoNote.attrs.type,
          id: note.smoNote.attrs.id
        };
      }
    }
    return null;
  }

  // ### addRehearsalMark
  // for all measures in the system, and also bump the
  // auto-indexing
  addRehearsalMark(index, parameters) {
    let i = 0;
    let symbol = '';
    var mark = new SmoRehearsalMark(parameters);
    if (!mark.increment) {
      this.measures[index].addRehearsalMark(mark);
      return;
    }

    symbol = mark.symbol;
    for (i = 0; i < this.measures.length; ++i) {
      const mm = this.measures[i];
      if (i < index) {
        const rm = mm.getRehearsalMark();
        if (rm && rm.cardinality === mark.cardinality && rm.increment) {
          symbol = rm.getIncrement();
          mark.symbol = symbol;
        }
      }
      if (i === index) {
        mm.addRehearsalMark(mark);
        symbol = mark.getIncrement();
      }
      if (i > index) {
        const rm = mm.getRehearsalMark();
        if (rm && rm.cardinality === mark.cardinality && rm.increment) {
          rm.symbol = symbol;
          symbol = rm.getIncrement();
        }
      }
    }
  }

  removeTempo(index) {
    this.measures[index].removeTempo();
  }

  addTempo(tempo, index) {
    this.measures[index].addTempo(tempo);
  }

  // ### removeRehearsalMark
  // for all measures in the system, and also decrement the
  // auto-indexing
  removeRehearsalMark(index) {
    let ix = 0;
    let symbol = null;
    let card = null;
    this.measures.forEach((measure) => {
      if (ix === index) {
        const mark = measure.getRehearsalMark();
        if (mark) {
          symbol = mark.symbol;
          card = mark.cardinality;
        }
        measure.removeRehearsalMark();
      }
      if (ix > index && symbol && card) {
        const mark = measure.getRehearsalMark();
        if (mark && mark.increment) {
          mark.symbol = symbol;
          symbol = mark.getIncrement();
        }
      }
      ix += 1;
    });
  }

  // ### deleteMeasure
  // delete the measure, and any staff modifiers that start/end there.
  deleteMeasure(index) {
    if (this.measures.length < 2) {
      return; // don't delete last measure.
    }
    const nm = [];
    this.measures.forEach((measure) => {
      if (measure.measureNumber.measureIndex !== index) {
        nm.push(measure);
      }
    });
    const sm = [];
    this.modifiers.forEach((mod) => {
      // Bug: if we are deleting a measure before the selector, change the measure number.
      if (mod.startSelector.measure !== index && mod.endSelector.measure !== index) {
        if (index < mod.startSelector.measure) {
          mod.startSelector.measure -= 1;
        }
        if (index < mod.endSelector.measure) {
          mod.endSelector.measure -= 1;
        }
        sm.push(mod);
      }
    });
    this.measures = nm;
    this.modifiers = sm;
    this.numberMeasures();
  }

  // ### addKeySignature
  // Add key signature to the given measure and update map so we know
  // when it changes, cancels etc.
  addKeySignature(measureIndex, key) {
    this.keySignatureMap[measureIndex] = key;
    const target = this.measures[measureIndex];
    target.keySignature = key;
  }

  // ### removeKeySignature
  // remove key signature and update map so we know
  // when it changes, cancels etc.
  removeKeySignature(measureIndex) {
    const keys = Object.keys(this.keySignatureMap);
    const nmap = {};
    keys.forEach((key) => {
      if (key !== measureIndex) {
        nmap[key] = this.keySignatureMap[key];
      }
    });
    this.keySignatureMap = nmap;
    this._updateKeySignatures();
  }
  _updateKeySignatures() {
    let i = 0;
    const currentSig = this.measures[0].keySignature;

    for (i = 0; i < this.measures.length; ++i) {
      const measure = this.measures[i];
      const nextSig = this.keySignatureMap[i] ? this.keySignatureMap[i] : currentSig;
      measure.setKeySignature(nextSig);
    }
  }

  // ### numberMeasures
  // After anything that might change the measure numbers, update them iteratively
  numberMeasures() {
    let currentOffset = 0;
    let i = 0;
    this.renumberIndex = this.startIndex;
    if (this.measures[0].getTicksFromVoice(0) < smoMusic.timeSignatureToTicks(this.measures[0].timeSignature)) {
      currentOffset = -1;
    }

    for (i = 0; i < this.measures.length; ++i) {
      const measure = this.measures[i];

      this.renumberIndex = this.renumberingMap[i] ? this.renumberingMap[i].startIndex : this.renumberIndex;
      const localIndex = this.renumberIndex + i + currentOffset;
      // If this is the first full measure, call it '1'
      const numberObj = {
        measureNumber: localIndex,
        measureIndex: i + this.startIndex,
        systemIndex: i,
        staffId: this.staffId
      };
      measure.setMeasureNumber(numberObj);
      // If we are renumbering measures, we assume we want to redo the layout so set measures to changed.
      measure.changed = true;
    }
  }

  getSelection(measureNumber, voice, tick, pitches) {
    let i = 0;
    for (i = 0; i < this.measures.length; ++i) {
      const measure = this.measures[i];
      if (measure.measureNumber.measureNumber === measureNumber) {
        const target = this.measures[i].getSelection(voice, tick, pitches);
        if (!target) {
          return null;
        }
        return ({
          measure,
          note: target.note,
          selection: target.selection
        });
      }
    }
    return null;
  }

  addDefaultMeasure(index, params) {
    const measure = SmoMeasure.getDefaultMeasure(params);
    this.addMeasure(index, measure);
  }

  // ## addMeasure
  // ## Description:
  // Add the measure at the specified index, splicing the array as required.
  addMeasure(index, measure) {
    if (index === 0 && this.measures.length) {
      measure.setMeasureNumber(this.measures[0].measureNumber);
    }
    if (index >= this.measures.length) {
      this.measures.push(measure);
    } else {
      this.measures.splice(index, 0, measure);
    }
    const modifiers = this.modifiers.filter((mod) => mod.startSelector.measure >= index);
    modifiers.forEach((mod) => {
      if (mod.startSelector.measure < this.measures.length) {
        mod.startSelector.measure += 1;
      }
      if (mod.endSelector.measure < this.measures.length) {
        mod.endSelector.measure += 1;
      }
    });
    this.numberMeasures();
  }
}
;// eslint-disable-next-line no-unused-vars
class SmoTuplet {
  constructor(params) {
    this.notes = params.notes;
    Vex.Merge(this, SmoTuplet.defaults);
    smoSerialize.serializedMerge(SmoTuplet.parameterArray, params, this);
    if (!this.attrs) {
      this.attrs = {
        id: VF.Element.newID(),
        type: 'SmoTuplet'
      };
    }
    this._adjustTicks();
  }

  static get longestTuplet() {
    return 8192;
  }

  get clonedParams() {
    const paramAr = ['stemTicks', 'ticks', 'totalTicks', 'durationMap'];
    const rv = {};
    smoSerialize.serializedMerge(paramAr, this, rv);
    return rv;
  }

  static get parameterArray() {
    return ['stemTicks', 'ticks', 'totalTicks',
      'durationMap', 'attrs', 'ratioed', 'bracketed', 'voice', 'startIndex'];
  }

  serialize() {
    const params = {};
    smoSerialize.serializedMergeNonDefault(SmoTuplet.defaults,
      SmoTuplet.parameterArray, this, params);
    return params;
  }

  static calculateStemTicks(totalTicks, numNotes) {
    const stemValue = totalTicks / numNotes;
    let stemTicks = SmoTuplet.longestTuplet;

    // The stem value is the type on the non-tuplet note, e.g. 1/8 note
    // for a triplet.
    while (stemValue < stemTicks) {
      stemTicks = stemTicks / 2;
    }
    return stemTicks * 2;
  }

  static cloneTuplet(tuplet) {
    let i = 0;
    const noteAr = tuplet.notes;
    const durationMap = JSON.parse(JSON.stringify(tuplet.durationMap)); // deep copy array

    // Add any remainders for oddlets
    const totalTicks = noteAr.map((nn) => nn.ticks.numerator + nn.ticks.remainder)
      .reduce((acc, nn) => acc + nn);

    const numNotes = tuplet.numNotes;
    const stemTicks = SmoTuplet.calculateStemTicks(totalTicks, numNotes);

    const tupletNotes = [];

    noteAr.forEach((note) => {
      const textModifiers = note.textModifiers;
      // Note preserver remainder
      note = SmoNote.cloneWithDuration(note, {
        numerator: stemTicks * tuplet.durationMap[i],
        denominator: 1,
        remainder: note.ticks.remainder
      });

      // Don't clone modifiers, except for first one.
      if (i === 0) {
        const ntmAr = [];
        textModifiers.forEach((tm) => {
          const ntm = SmoNoteModifierBase.deserialize(tm);
          ntmAr.push(ntm);
        });
        note.textModifiers = ntmAr;
      }
      i += 1;
      tupletNotes.push(note);
    });
    const rv = new SmoTuplet({
      notes: tupletNotes,
      stemTicks,
      totalTicks,
      ratioed: false,
      bracketed: true,
      startIndex: tuplet.startIndex,
      durationMap
    });
    return rv;
  }

  _adjustTicks() {
    let i = 0;
    const sum = this.durationSum;
    for (i = 0; i < this.notes.length; ++i) {
      const note = this.notes[i];
      // TODO:  notes_occupied needs to consider vex duration
      note.ticks.denominator = 1;
      note.ticks.numerator = Math.floor((this.totalTicks * this.durationMap[i]) / sum);
      note.tuplet = this.attrs;
    }

    // put all the remainder in the first note of the tuplet
    const noteTicks = this.notes.map((nn) => nn.tickCount)
      .reduce((acc, dd) => acc + dd);
    // bug fix:  if this is a clones tuplet, remainder is already set
    this.notes[0].ticks.remainder =
      this.notes[0].ticks.remainder + this.totalTicks - noteTicks;
  }
  getIndexOfNote(note) {
    let rv = -1;
    let i = 0;
    for (i = 0; i < this.notes.length; ++i) {
      const tn = this.notes[i];
      if (note.attrs.id === tn.attrs.id) {
        rv = i;
      }
    }
    return rv;
  }

  split(combineIndex) {
    let i = 0;
    const multiplier = 0.5;
    const nnotes = [];
    const nmap = [];

    for (i = 0; i < this.notes.length; ++i) {
      const note = this.notes[i];
      if (i === combineIndex) {
        nmap.push(this.durationMap[i] * multiplier);
        nmap.push(this.durationMap[i] * multiplier);
        note.ticks.numerator *= multiplier;

        const onote = SmoNote.clone(note);
        // remainder is for the whole tuplet, so don't duplicate that.
        onote.ticks.remainder = 0;
        nnotes.push(note);
        nnotes.push(onote);
      } else {
        nmap.push(this.durationMap[i]);
        nnotes.push(note);
      }
    }
    this.notes = nnotes;
    this.durationMap = nmap;
  }
  combine(startIndex, endIndex) {
    let i = 0;
    let base = 0.0;
    let acc = 0.0;
    // can't combine in this way, too many notes
    if (this.notes.length <= endIndex || startIndex >= endIndex) {
      return this;
    }
    for (i = startIndex; i <= endIndex; ++i) {
      acc += this.durationMap[i];
      if (i === startIndex) {
        base = this.durationMap[i];
      } else if (this.durationMap[i] !== base) {
        // Can't combine non-equal tuplet notes
        return this;
      }
    }
    // how much each combined value will be multiplied by
    const multiplier = acc / base;

    const nmap = [];
    const nnotes = [];
    // adjust the duration map
    for (i = 0; i < this.notes.length; ++i) {
      const note = this.notes[i];
      // notes that don't change are unchanged
      if (i < startIndex || i > endIndex) {
        nmap.push(this.durationMap[i]);
        nnotes.push(note);
      }
      // changed note with combined duration
      if (i === startIndex) {
        note.ticks.numerator = note.ticks.numerator * multiplier;
        nmap.push(acc);
        nnotes.push(note);
      }
      // other notes after startIndex are removed from the map.
    }
    this.notes = nnotes;
    this.durationMap = nmap;
    return this;
  }

  // ### getStemDirection
  // Return the stem direction, so we can bracket the correct place
  getStemDirection(clef) {
    const note = this.notes.find((nn) => nn.noteType === 'n');
    if (!note) {
      return SmoNote.flagStates.down;
    }
    if (note.flagState !== SmoNote.flagStates.auto) {
      return note.flagState;
    }
    return smoMusic.pitchToLedgerLine(clef, note.pitches[0])
       >= 2 ? SmoNote.flagStates.up : SmoNote.flagStates.down;
  }
  get durationSum() {
    let acc = 0;
    let i = 0;
    for (i = 0; i < this.durationMap.length; ++i) {
      acc += this.durationMap[i];
    }
    return Math.round(acc);
  }
  get num_notes() {
    return this.durationSum;
  }
  get notes_occupied() {
    return Math.floor(this.totalTicks / this.stemTicks);
  }
  get note_ticks_occupied() {
    return this.totalTicks / this.stemTicks;
  }
  get tickCount() {
    let rv = 0;
    let i = 0;
    for (i = 0; i < this.notes.length; ++i) {
      const note = this.notes[i];
      rv += (note.ticks.numerator / note.ticks.denominator) + note.ticks.remainder;
    }
    return rv;
  }

  static get defaults() {
    return {
      numNotes: 3,
      totalTicks: 4096, // how many ticks this tuple takes up
      stemTicks: 2048, // the stem ticks, for drawing purposes.  >16th, draw as 8th etc.
      durationMap: [1.0, 1.0, 1.0],
      bracketed: true,
      voice: 0,
      ratioed: false
    };
  }
}
;// eslint-disable-next-line no-unused-vars
class SmoToXml {
  static get beamStates() {
    return {
      none: 1, start: 2, continue: 3, stop: 4
    };
  }
  static convert(score) {
    const nn = mxmlHelpers.createTextElementChild;
    const dom = mxmlHelpers.createRootElement();
    const root = dom.children[0];
    const work = nn(root, 'work');
    nn(work, 'work-title', score.scoreInfo, 'title');
    const identification = nn(root, 'identification');
    const creator = nn(identification, 'creator', score.scoreInfo, 'composer');
    mxmlHelpers.createAttributes(creator, { type: 'composer' });
    const encoding = nn(identification, 'encoding');
    nn(encoding, 'software', { software: 'Some pre-release version of Smoosic' }, 'software');
    nn(encoding, 'encoding-date', { date: new Date().toDateString() }, 'date');
    const defaults = nn(root, 'defaults');
    const scaling = nn(root, 'scaling');
    // reverse this:
    // scoreDefaults.layout.svgScale =  (scale * 42 / 40) / mxmlScore.mmPerPixel;
    const mm = mxmlScore.mmPerPixel * 42 * score.layout.svgScale;
    nn(scaling, 'millimeters', { mm }, 'mm');
    nn(scaling, 'tenths', { tenths: 40 }, 'tenths');
    const pageLayout = nn(defaults, 'page-layout');
    mxmlScore.pageLayoutMap.forEach((map) => {
      nn(pageLayout, map.xml, score.layout, map.smo);
    });
    const pageMargins = nn(pageLayout, 'page-margins');
    mxmlScore.pageMarginMap.forEach((map) => {
      nn(pageMargins, map.xml, score.layout, map.smo);
    });
    const partList =  nn(root, 'part-list');
    score.staves.forEach((staff) => {
      const id = 'P' + staff.staffId;
      const scorePart = nn(partList, 'score-part');
      mxmlHelpers.createAttributes(scorePart, { id });
      nn(scorePart, 'part-name', { name: staff.instrumentInfo.instrumentName }, 'name');
    });
    const smoState = {};
    score.staves.forEach((staff) => {
      const part = nn(root, 'part');
      const id = 'P' + staff.staffId;
      mxmlHelpers.createAttributes(part, { id });
      smoState.measureNumber = 1;
      smoState.tickCount = 0;
      smoState.staff = staff;
      smoState.slurs = [];
      smoState.lyricState = {};
      smoState.slurNumber = 1;
      staff.measures.forEach((measure) => {
        smoState.measureTicks = 0;
        smoState.measure = measure;
        const measureElement = nn(part, 'measure');
        SmoToXml.measure(measureElement, smoState);
        smoState.measureNumber += 1;
      });
    });
    return dom;
  }
  // ### measure
  // .../part/measure
  static measure(measureElement, smoState) {
    const nn = mxmlHelpers.createTextElementChild;
    const measure = smoState.measure;
    if (smoState.measureNumber === 1 && measure.isPickup()) {
      smoState.measureNumber = 0;
    }
    if (smoState.measure.systemBreak) {
      const printElement = nn(measureElement, 'print');
      mxmlHelpers.createAttributes(printElement, { 'new-system': 'yes' });
    }
    mxmlHelpers.createAttributes(measureElement, { number: smoState.measureNumber });
    SmoToXml.attributes(measureElement, smoState);
    smoState.voiceIndex = 1;
    smoState.beamState = SmoToXml.beamStates.none;
    smoState.beamTicks = 0;
    measure.voices.forEach((voice) => {
      smoState.voiceTickIndex = 0;
      smoState.voice = voice;
      voice.notes.forEach((note) => {
        smoState.note = note;
        // Start wedge before note starts
        SmoToXml.direction(measureElement, smoState, true);
        SmoToXml.note(measureElement, smoState);
        // End wedge on next tick
        SmoToXml.direction(measureElement, smoState, false);
      });
      if (measure.voices.length > smoState.voiceIndex) {
        smoState.voiceIndex += 1;
        const backupElement = nn(measureElement, 'backup');
        nn(backupElement, 'duration', { duration: smoState.measureTicks }, 'duration');
      } else {
        smoState.tickCount += smoState.measureTicks;
      }
      smoState.measureTicks = 0;
    });
  }

  // ### slur
  // /score-partwise/part/measure/note/notations/slur
  static slur(notationsElement, smoState) {
    const nn = mxmlHelpers.createTextElementChild;
    const staff = smoState.staff;
    const measure = smoState.measure;
    const selector = {
      staff: staff.staffId,
      measure: measure.measureNumber.measureIndex,
      voice: smoState.voiceIndex - 1,
      tick: smoState.voiceTickIndex
    };
    const starts = smoState.staff.getSlursStartingAt(selector);
    const ends = smoState.staff.getSlursEndingAt(selector);
    const remove = [];
    const newSlurs = [];
    ends.forEach((slur) => {
      const match = smoState.slurs.find((ss) => SmoSelector.eq(ss.startSelector, slur.startSelector) &&
        SmoSelector.eq(ss.endSelector, slur.endSelector));
      if (match) {
        remove.push(match);
        const slurElement = nn(notationsElement, 'slur');
        mxmlHelpers.createAttributes(slurElement, { number: match.number, type: 'stop' });
      }
    });
    smoState.slurs.forEach((slur) => {
      if (remove.findIndex((rr) => rr.number === slur.number) <= 0) {
        newSlurs.push(slur);
      }
    });
    smoState.slurs = newSlurs;
    smoState.slurNumber = 1;
    if (smoState.slurs.length > 0) {
      // set next slur number to 1+ highest slur number in the 'waiting to resolve' list
      smoState.slurNumber = smoState.slurs.map((slur) => slur.number).reduce((a, b) => a > b ? a : b) + 1;
    }
    starts.forEach((slur) => {
      smoState.slurs.push({ startSelector: slur.startSelector,
        endSelector: slur.endSelector,
        number: smoState.slurNumber });
      const slurElement = nn(notationsElement, 'slur');
      mxmlHelpers.createAttributes(slurElement, { number: smoState.slurNumber, type: 'start' });
      smoState.slurNumber += 1;
    });
  }
  // ### /score-partwise/measure/note/time-modification
  // ### /score-partwise/measure/note/tuplet
  static tuplet(noteElement, notationsElement, smoState) {
    const nn = mxmlHelpers.createTextElementChild;
    const measure = smoState.measure;
    const note = smoState.note;
    const tuplet = measure.getTupletForNote(note);
    if (!tuplet) {
      return;
    }
    const obj = {
      actualNotes: tuplet.numNotes, normalNotes: 4096 / tuplet.stemTicks
    };
    const timeModification = nn(noteElement, 'time-modification');
    nn(timeModification, 'actual-notes', obj, 'actualNotes');
    nn(timeModification, 'normal-notes', obj, 'normalNotes');
    if (tuplet.getIndexOfNote(note) === 0) {
      const tupletElement = nn(notationsElement, 'tuplet');
      mxmlHelpers.createAttributes(tupletElement, {
        number: 1, type: 'start'
      });
    } else if (tuplet.getIndexOfNote(note) === tuplet.notes.length - 1) {
      const tupletElement = nn(notationsElement, 'tuplet');
      mxmlHelpers.createAttributes(tupletElement, {
        number: 1, type: 'stop'
      });
    }
  }
  // ### /score-partwise/measure/note/pitch
  static pitch(pitch, noteElement) {
    const nn = mxmlHelpers.createTextElementChild;
    const accidentalOffset = ['bb', 'b', 'n', '#', '##'];
    const adjust = accidentalOffset.indexOf(pitch.accidental) - 2;
    const pitchElement = nn(noteElement, 'pitch');
    nn(pitchElement, 'step', { letter: pitch.letter.toUpperCase() }, 'letter');
    nn(pitchElement, 'octave', pitch, 'octave');
    nn(pitchElement, 'adjust', { adjust }, 'adjust');
  }
  // ### /score-partwise/measure/beam
  static beamNote(noteElement, smoState) {
    const nn = mxmlHelpers.createTextElementChild;
    const note = smoState.note;
    const nextNote = (smoState.voiceTickIndex + 1) >= smoState.voice.notes.length ?
      null : smoState.voice.notes[smoState.voiceTickIndex + 1];
    const exceedTicks = smoState.beamTicks + note.tickCount >= note.beamBeats;
    // don't start a beam on a rest
    if (note.isRest() && smoState.beamState === SmoToXml.beamStates.none) {
      return;
    }
    let toBeam = SmoToXml.beamStates.none;
    if (note.tickCount <= 2048 && !exceedTicks) {
      // Explicit end beam, or no more notes to beam, so stop beam
      if (note.endBeam || nextNote === null) {
        if (smoState.beamState !== SmoToXml.beamStates.none) {
          toBeam = SmoToXml.beamStates.stop;
        }
      } else {
        // else if the next note is beamable, start or continue the beam
        if (nextNote.tickCount <= 2048) {
          toBeam = smoState.beamState === SmoToXml.beamStates.continue ?
            SmoToXml.beamStates.continue : SmoToXml.beamStates.start;
        }
      }
    }
    if (toBeam === SmoToXml.beamStates.start || toBeam === SmoToXml.beamStates.continue) {
      smoState.beamTicks += smoState.note.tickCount;
    } else {
      smoState.beamTicks = 0;
    }
    // slur is start/stop, beam is begin, end, gf
    if (toBeam === SmoToXml.beamStates.start) {
      const beamElement = nn(noteElement, 'beam', { type: 'begin' }, 'type');
      mxmlHelpers.createAttributes(beamElement, { number: 1 });
      smoState.beamState = SmoToXml.beamStates.continue;
    } else if (toBeam === SmoToXml.beamStates.continue) {
      const beamElement = nn(noteElement, 'beam', { type: 'continue' }, 'type');
      mxmlHelpers.createAttributes(beamElement, { number: 1 });
    } else if ((toBeam === SmoToXml.beamStates.stop) ||
      (toBeam === SmoToXml.beamStates.none && smoState.beamState !== SmoToXml.beamStates.none)) {
      const beamElement = nn(noteElement, 'beam', { type: 'end' }, 'type');
      mxmlHelpers.createAttributes(beamElement, { number: 1 });
      smoState.beamState = SmoToXml.beamStates.none;
    }
  }
  // ### /score-partwise/measure/direction/direction-type
  static direction(measureElement, smoState, beforeNote) {
    let addDirection = false;
    const nn = mxmlHelpers.createTextElementChild;
    const directionElement = measureElement.ownerDocument.createElement('direction');
    const dtype  = nn(directionElement, 'direction-type');
    const staff = smoState.staff;
    const measure = smoState.measure;
    const selector = {
      staff: staff.staffId,
      measure: measure.measureNumber.measureIndex,
      voice: smoState.voiceIndex - 1,
      tick: smoState.voiceTickIndex
    };
    if (!beforeNote) {
      selector.tick -= 1;
    }
    const startWedge = staff.modifiers.find((mod) =>
      SmoSelector.sameNote(mod.startSelector, selector) &&
      (mod.attrs.type === 'SmoStaffHairpin'));
    const endWedge =  staff.modifiers.find((mod) =>
      SmoSelector.sameNote(mod.endSelector, selector) &&
      (mod.attrs.type === 'SmoStaffHairpin'));
    if (endWedge && !beforeNote) {
      const wedgeElement = nn(dtype, 'wedge');
      mxmlHelpers.createAttributes(wedgeElement, { type: 'stop', spread: '20' });
      addDirection = true;
    }
    if (startWedge && beforeNote) {
      const wedgeElement = nn(dtype, 'wedge');
      const wedgeType = startWedge.hairpinType === SmoStaffHairpin.types.CRESCENDO ?
        'crescendo' : 'diminuendo';
      mxmlHelpers.createAttributes(wedgeElement, { type: wedgeType });
      addDirection = true;
    }
    if (addDirection) {
      measureElement.appendChild(directionElement);
    }
  }
  // ### /score-partwise/measure/note/lyric
  static lyric(noteElement, smoState) {
    const smoNote = smoState.note;
    const nn = mxmlHelpers.createTextElementChild;
    const lyrics = smoNote.getTrueLyrics();
    lyrics.forEach((lyric) => {
      let syllabic = 'single';
      if (lyric.isHyphenated() === false && lyric.isDash() === false) {
        if (smoState.lyricState[lyric.verse] === 'begin') {
          syllabic = 'end';
        } // else stays single
      } else {
        if (lyric.isHyphenated()) {
          syllabic = smoState.lyricState[lyric.verse] === 'begin' ?
            'middle' : 'begin';
        } else if (lyric.isDash()) {
          syllabic = 'middle';
        }
      }
      smoState.lyricState[lyric.verse] = syllabic;
      const lyricElement = nn(noteElement, 'lyric');
      mxmlHelpers.createAttribute(lyricElement, 'number', lyric.verse + 1);
      mxmlHelpers.createAttribute(lyricElement, 'placement', 'below');
      mxmlHelpers.createAttribute(lyricElement, 'default-y',
        -80 - 10 * lyric.verse);
      nn(lyricElement, 'syllabic', syllabic);
      nn(lyricElement, 'text', lyric.getText());
    });
  }
  // ### /score-partwise/measure/note
  static note(measureElement, smoState) {
    const note = smoState.note;
    const nn = mxmlHelpers.createTextElementChild;
    let i = 0;
    for (i = 0; i < note.pitches.length; ++i) {
      const noteElement = nn(measureElement, 'note');
      if (i > 0) {
        nn(noteElement, 'chord');
      } else {
        SmoToXml.beamNote(noteElement, smoState);
        SmoToXml.lyric(noteElement, smoState);
        nn(noteElement, 'type', { type: mxmlHelpers.closestStemType(note.tickCount) },
          'type');
        if (note.flagState === SmoNote.flagStates.up) {
          nn(noteElement, 'stem', { direction: 'up' }, 'direction');
        }
        if (note.flagState === SmoNote.flagStates.down) {
          nn(noteElement, 'stem', { direction: 'down' }, 'direction');
        }
      }
      if (note.isRest()) {
        nn(noteElement, 'rest');
      }
      nn(noteElement, 'voice', { voice: smoState.voiceIndex }, 'voice');
      SmoToXml.pitch(note.pitches[i], noteElement);
      const duration = note.tickCount;
      smoState.measureTicks += duration;
      nn(noteElement, 'duration', { duration }, 'duration');
      const notationsElement = noteElement.ownerDocument.createElement('notations');
      SmoToXml.tuplet(noteElement, notationsElement, smoState);
      SmoToXml.slur(notationsElement, smoState);
      if (notationsElement.children.length) {
        noteElement.appendChild(notationsElement);
      }
    }
    smoState.voiceTickIndex += 1;
  }
  // ### /score-partwise/measure/attributes/key
  static key(attributesElement, smoState) {
    let fifths = 0;
    const measure = smoState.measure;
    if (smoState.keySignature && measure.keySignature === smoState.keySignature) {
      return; // no key change
    }
    const flats = smoMusic.getFlatsInKeySignature(measure.keySignature);
    const nn = mxmlHelpers.createTextElementChild;
    if (flats > 0) {
      fifths = -1 * flats;
    } else {
      fifths = smoMusic.getSharpsInKeySignature(measure.keySignature);
    }
    const keyElement = nn(attributesElement, 'key');
    nn(keyElement, 'fifths', { fifths }, 'fifths');
    nn(keyElement, 'mode', { mode: 'major' }, 'major');
    smoState.keySignature = measure.keySignature;
  }
  // ### time
  // score-partwise/part/measure/attributes/time
  static time(attributesElement, smoState) {
    const nn = mxmlHelpers.createTextElementChild;
    const measure = smoState.measure;
    if (smoState.timeSignature && smoState.timeSignature === measure.timeSignature) {
      return;
    }
    const timeAr = measure.timeSignature.split('/');
    const time = { beats: parseInt(timeAr[0], 10), beatType: parseInt(timeAr[1], 10) };
    const timeElement = nn(attributesElement, 'time');
    nn(timeElement, 'beats', time, 'beats');
    nn(timeElement, 'beat-type', time, 'beatType');
    smoState.timeSignature = measure.timeSignature;
  }
  // ### clef
  // /score-partwise/part/measure/attributes/clef
  static clef(attributesElement, smoState) {
    const measure = smoState.measure;
    if (smoState.clef && smoState.clef === measure.clef) {
      return; // no change
    }
    const nn = mxmlHelpers.createTextElementChild;
    const clef = {};
    if (measure.clef === 'treble') {
      clef.sign = 'G';
      clef.line = 2;
    } else if (measure.clef === 'bass') {
      clef.sign = 'F';
      clef.line = 4;
    } else {
      clef.sign = 'C';
      if (measure.clef === 'tenor') {
        clef.sign = 3;
      } else {
        clef.sign = 4; // todo: other clefs
      }
    }
    const clefElement = nn(attributesElement, 'clef');
    nn(clefElement, 'sign', clef, 'sign');
    nn(clefElement, 'line', clef, 'line');
    smoState.clef = measure.clef;
  }
  static attributes(measureElement, smoState) {
    const nn = mxmlHelpers.createTextElementChild;
    const attributesElement = measureElement.ownerDocument.createElement('attributes');
    if (!smoState.divisions) {
      nn(attributesElement, 'divisions', { divisions: 4096 }, 'divisions');
      smoState.divisions = 4096;
    }
    SmoToXml.key(attributesElement, smoState);
    SmoToXml.time(attributesElement, smoState);
    SmoToXml.clef(attributesElement, smoState);
    if (attributesElement.children.length > 0) {
      // don't add an empty attributes element
      measureElement.appendChild(attributesElement);
    }
  }
}
;// ## mxmlHelpers
// Utilities for parsing and serialzing musicXML.
// eslint-disable-next-line no-unused-vars
class mxmlHelpers {
  // ### noteTypesToSmoMap
  // mxml note 'types', really s/b stem types.
  // For grace notes, we use the note type and not duration
  // to get the flag
  static get noteTypesToSmoMap() {
    return {
      'breve': 8192 * 4,
      'whole': 8192 * 2,
      'half': 8192,
      'quarter': 4096,
      'eighth': 2048,
      '16th': 1024,
      '32nd': 512,
      '64th': 256,
      '128th': 128
    };
  }
  static get ticksToNoteTypeMap() {
    if (mxmlHelpers._ticksToNoteTypeMap) {
      return mxmlHelpers._ticksToNoteTypeMap;
    }
    mxmlHelpers._ticksToNoteTypeMap = smoSerialize.reverseMap(mxmlHelpers.noteTypesToSmoMap);
    return mxmlHelpers._ticksToNoteTypeMap;
  }
  // ### closestStemType
  // smo infers the stem type from the duration, but other applications don't
  static closestStemType(ticks) {
    const nticks = VF.durationToTicks(smoMusic.vexStemType(ticks));
    return mxmlHelpers.ticksToNoteTypeMap[nticks];
  }
  static get beamStates() {
    return {
      BEGIN: 1,
      END: 2,
      AUTO: 3
    };
  }
  static get ornamentXmlToSmoMap() {
    return {
      staccato: { ctor: 'SmoArticulation', params: { articulation: SmoArticulation.articulations.staccato } },
      tenuto: { ctor: 'SmoArticulation', params: { articulation: SmoArticulation.articulations.tenuto } },
      marcato: { ctor: 'SmoArticulation', params: { articulation: SmoArticulation.articulations.marcato } },
      accent: { ctor: 'SmoArticulation', params: { articulation: SmoArticulation.articulations.accent } },
      doit: { ctor: 'SmoOrnament', params: { ornament: SmoOrnament.ornaments.doitLong } },
      falloff: { ctor: 'SmoOrnament', params: { ornament: SmoOrnament.ornaments.fall } },
      scoop: { ctor: 'SmoOrnament', params: { ornament: SmoOrnament.ornaments.scoop } },
      'delayed-turn': { ctor: 'SmoOrnament', params: { ornament: SmoOrnament.ornaments.turn, offset: SmoOrnament.offsets.after } },
      turn: { ctor: 'SmoOrnament', params: { ornament: SmoOrnament.ornaments.turn, offset: SmoOrnament.offsets.on } },
      'inverted-turn': { ctor: 'SmoOrnament', params: { ornament: SmoOrnament.ornaments.turnInverted } },
      mordent: { ctor: 'SmoOrnament', params: { ornament: SmoOrnament.ornaments.mordent } },
      'inveterd-mordent': { ctor: 'SmoOrnament', params: { ornament: SmoOrnament.ornaments.mordentInverted } },
      shake: { ctor: 'SmoOrnament', params: { ornament: SmoOrnament.ornaments.mordentInverted } },
      'trill-mark': { ctor: 'SmoOrnament', params: { ornament: SmoOrnament.ornaments.trill } },
    };
  }
  // ### createRootElement
  // Create score-partwise document with prelude
  // https://bugzilla.mozilla.org/show_bug.cgi?id=318086
  static createRootElement() {
    const doc = document.implementation.createDocument('', '', null);
    const rootElem = doc.createElement('score-partwise');
    const piElement = doc.createProcessingInstruction('xml', 'version="1.0" encoding="UTF8"');
    rootElem.setAttribute('version', '2.0');
    doc.appendChild(rootElem);
    doc.insertBefore(piElement, rootElem);
    return doc;
  }
  // Parse an element whose child has a number in the textContent
  static getNumberFromElement(parent, path, defaults) {
    let rv = (typeof(defaults) === 'undefined' || defaults === null)
      ? 0 : defaults;
    const tval = mxmlHelpers.getTextFromElement(parent, path, defaults);
    if (!tval) {
      return rv;
    }
    if (typeof(tval) === 'number') {
      return tval;
    }
    if (tval.indexOf('.')) {
      const tf = parseFloat(tval);
      rv = isNaN(tf) ? rv : tf;
    } else {
      const ff = parseInt(tval, 10);
      rv = isNaN(ff) ? rv : ff;
    }
    return rv;
  }
  // Parse an element whose child has a textContent
  static getTextFromElement(parent, path, defaults) {
    const rv = (typeof(defaults) === 'undefined' || defaults === null)
      ? 0 : defaults;
    const el = [...parent.getElementsByTagName(path)];
    if (!el.length) {
      return rv;
    }
    return el[0].textContent;
  }
  // ### getChildrenFromPath
  // Like xpath, given ['foo', 'bar'] and parent element
  // 'moo' return any element /moo/foo/bar as an array of elements
  static getChildrenFromPath(parent, pathAr) {
    let i = 0;
    let node = parent;
    for (i = 0; i < pathAr.length; ++i) {
      const tag = pathAr[i];
      node = [...node.getElementsByTagName(tag)];
      if (node.length === 0) {
        return [];
      }
      if (i < pathAr.length - 1) {
        node = node[0];
      }
    }
    return node;
  }
  static getStemType(noteElement) {
    const tt = mxmlHelpers.getTextFromElement(noteElement, 'stem', '');
    if (tt === 'up') {
      return SmoNote.flagStates.up;
    } else if (tt === 'down') {
      return SmoNote.flagStates.down;
    }
    return SmoNote.flagStates.auto;
  }
  // ### assignDefaults
  // Map SMO layout data from xml layout data (default node)
  static assignDefaults(node, defObj, parameters) {
    parameters.forEach((param) => {
      if (!isNaN(parseInt(defObj[param.smo], 10))) {
        const smoParam = param.smo;
        const xmlParam = param.xml;
        defObj[smoParam] = mxmlHelpers.getNumberFromElement(node, xmlParam, defObj[smoParam]);
      }
    });
  }
  // ### nodeAttributes
  // turn the attributes of an element into a JS hash
  static nodeAttributes(node) {
    const rv = {};
    node.getAttributeNames().forEach((attr) => {
      rv[attr] = node.getAttribute(attr);
    });
    return rv;
  }
  // Some measures have staff ID, some don't.
  // convert xml 1 index to array 0 index
  static getStaffId(node) {
    const staff = [...node.getElementsByTagName('staff')];
    if (staff.length) {
      return parseInt(staff[0].textContent, 10) - 1;
    }
    return 0;
  }
  static noteBeamState(noteNode) {
    const beamNodes = [...noteNode.getElementsByTagName('beam')];
    if (!beamNodes.length) {
      return mxmlHelpers.beamStates.AUTO;
    }
    const beamText = beamNodes[0].textContent;
    if (beamText === 'begin') {
      return mxmlHelpers.beamStates.BEGIN;
    } else if (beamText === 'end') {
      return mxmlHelpers.beamStates.END;
    }
    return mxmlHelpers.beamStates.AUTO;
  }
  // same with notes and voices.  same convert
  static getVoiceId(node) {
    const voice = [...node.getElementsByTagName('voice')];
    if (voice.length) {
      return parseInt(voice[0].textContent, 10) - 1;
    }
    return 0;
  }
  static smoPitchFromNote(noteNode, defaultPitch) {
    const accidentals = ['bb', 'b', 'n', '#', '##'];
    const letter = mxmlHelpers.getTextFromElement(noteNode, 'step', defaultPitch.letter).toLowerCase();
    const octave = mxmlHelpers.getNumberFromElement(noteNode, 'octave', defaultPitch.octave);
    const xaccidental = mxmlHelpers.getNumberFromElement(noteNode, 'alter', 0);
    return { letter, accidental: accidentals[xaccidental + 2], octave };
  }
  static isGrace(noteNode) {
    const path = mxmlHelpers.getChildrenFromPath(noteNode, ['grace']);
    return path.length > 0;
  }
  static isSystemBreak(measureNode) {
    const printNodes = measureNode.getElementsByTagName('print');
    if (printNodes.length) {
      const attrs = mxmlHelpers.nodeAttributes(printNodes[0]);
      if (typeof(attrs['new-system']) !== 'undefined') {
        return attrs['new-system'] === 'yes';
      }
    }
    return false;
  }
  // ### durationFromType
  // Get the SMO tick duration of a note, based on the XML type element (quarter, etc)
  static durationFromType(noteNode, def) {
    const typeNodes = [...noteNode.getElementsByTagName('type')];
    if (typeNodes.length) {
      const txt = typeNodes[0].textContent;
      if (txt && mxmlHelpers.noteTypesToSmoMap[txt]) {
        return mxmlHelpers.noteTypesToSmoMap[txt];
      }
    }
    return def;
  }
  // ### durationFromNode
  // the true duration value, used to handle forward/backward
  static durationFromNode(noteNode, def) {
    const durationNodes = [...noteNode.getElementsByTagName('duration')];
    if (durationNodes.length) {
      const duration = parseInt(durationNodes[0].textContent, 10);
      return duration;
    }
    return def;
  }
  static ticksFromDuration(noteNode, divisions, def) {
    const rv = { tickCount: def };
    const durationNodes = [...noteNode.getElementsByTagName('duration')];
    const timeAlteration = mxmlHelpers.getTimeAlteration(noteNode);
    rv.alteration = { noteCount: 1, noteDuration: 1 };
    // different ways to declare note duration - from type is the graphical
    // type, SMO uses ticks for everything
    if (durationNodes.length) {
      rv.duration = parseInt(durationNodes[0].textContent, 10);
      rv.tickCount = 4096 * (rv.duration / divisions);
    } else {
      rv.tickCount = mxmlHelpers.durationFromType(noteNode, def);
      rv.duration = (divisions / 4096) * rv.tickCount;
    }
    // If this is a tuplet, we adjust the note duration back to the graphical type
    // and SMO will create the tuplet after.  We keep track of tuplet data though for beaming
    if (timeAlteration) {
      rv.tickCount = (rv.tickCount * timeAlteration.noteCount) / timeAlteration.noteDuration;
      rv.alteration = timeAlteration;
    }
    return rv;
  }
  // Get placement or orientation of a tie or slur.  Xml docs
  // a little unclear on what to expect and what each mean.
  static getCurveDirection(node) {
    const orientation = node.getAttribute('orientation');
    const placement = node.getAttribute('placement');
    if (orientation) {
      return orientation;
    }
    if (placement && placement === 'above') {
      return 'over';
    }
    if (placement && placement === 'below') {
      return 'under';
    }
    return 'auto';
  }
  static getTieData(noteNode, selector, pitchIndex) {
    const rv = [];
    let number = 0;
    const nNodes = [...noteNode.getElementsByTagName('notations')];
    nNodes.forEach((nNode) => {
      const slurNodes = [...nNode.getElementsByTagName('tied')];
      slurNodes.forEach((slurNode) => {
        const orientation = mxmlHelpers.getCurveDirection(slurNode);
        const type = slurNode.getAttribute('type');
        number = parseInt(slurNode.getAttribute('number'), 10);
        if (isNaN(number)) {
          number = 1;
        }
        rv.push({ number, type, orientation, selector, pitchIndex });
      });
    });
    return rv;
  }
  static getSlurData(noteNode, selector) {
    const rv = [];
    const nNodes = [...noteNode.getElementsByTagName('notations')];
    nNodes.forEach((nNode) => {
      const slurNodes = [...nNode.getElementsByTagName('slur')];
      slurNodes.forEach((slurNode) => {
        const number = parseInt(slurNode.getAttribute('number'), 10);
        const type = slurNode.getAttribute('type');
        const orientation = mxmlHelpers.getCurveDirection(slurNode);
        const slurInfo = { number, type, orientation, selector };
        console.log('slur data: ', JSON.stringify(slurInfo, null, ' '));
        rv.push(slurInfo);
      });
    });
    return rv;
  }
  static getCrescendoData(directionElement) {
    let rv = {};
    const nNodes = mxmlHelpers.getChildrenFromPath(directionElement,
      ['direction-type', 'wedge']);
    nNodes.forEach((nNode) => {
      rv = { type: nNode.getAttribute('type') };
    });
    return rv;
  }
  static getTupletData(noteNode) {
    const rv = [];
    const nNodes = [...noteNode.getElementsByTagName('notations')];
    nNodes.forEach((nNode) => {
      const slurNodes = [...nNode.getElementsByTagName('tuplet')];
      slurNodes.forEach((slurNode) => {
        const number = parseInt(slurNode.getAttribute('number'), 10);
        const type = slurNode.getAttribute('type');
        rv.push({ number, type });
      });
    });
    return rv;
  }
  static articulationsAndOrnaments(noteNode) {
    const rv = [];
    const nNodes = [...noteNode.getElementsByTagName('notations')];
    nNodes.forEach((nNode) => {
      ['articulations', 'ornaments'].forEach((typ) => {
        const articulations = [...nNode.getElementsByTagName(typ)];
        articulations.forEach((articulation) => {
          Object.keys(mxmlHelpers.ornamentXmlToSmoMap).forEach((key) => {
            if ([...articulation.getElementsByTagName(key)].length) {
              const ctor = eval(mxmlHelpers.ornamentXmlToSmoMap[key].ctor);
              rv.push(new ctor(mxmlHelpers.ornamentXmlToSmoMap[key].params));
            }
          });
        });
      });
    });
    return rv;
  }
  static lyrics(noteNode) {
    const rv = [];
    const nNodes = [...noteNode.getElementsByTagName('lyric')];
    nNodes.forEach((nNode) => {
      const text = mxmlHelpers.getTextFromElement(nNode, 'text', '_');
      const verse = nNode.getAttribute('number');
      rv.push({ _text: text, verse });
    });
    return rv;
  }

  static getTimeAlteration(noteNode) {
    const timeNodes = mxmlHelpers.getChildrenFromPath(noteNode, ['time-modification']);
    if (timeNodes.length) {
      return { noteCount: mxmlHelpers.getNumberFromElement(timeNodes[0], 'actual-notes'),
        noteDuration: mxmlHelpers.getNumberFromElement(timeNodes[0], 'normal-notes') };
    }
    return null;
  }
  // ### createTextElementChild
  // In:  ../parent
  // Out: ../parent/elementName/obj[field]
  // returns elementName element.  If obj is null, just creates and returns child
  // if obj is a string, it uses it as the text value
  static createTextElementChild(parentElement, elementName, obj, field) {
    const el = parentElement.ownerDocument.createElement(elementName);
    if (obj) {
      if (typeof(obj) === 'string') {
        el.textContent = obj;
      } else {
        el.textContent = obj[field];
      }
    }
    parentElement.appendChild(el);
    return el;
  }
  static createAttributes(element, obj) {
    Object.keys(obj).forEach((key) => {
      const attr = element.ownerDocument.createAttribute(key);
      attr.value = obj[key];
      element.setAttributeNode(attr);
    });
  }
  static createAttribute(element, name, value) {
    const obj = {};
    obj[name] = value;
    mxmlHelpers.createAttributes(element, obj);
  }
}
;// ## mxmlScore
// Parse music xml into a smoosic score object
// eslint-disable-next-line no-unused-vars
class mxmlScore {
  static get mmPerPixel() {
    return 0.264583;
  }
  static get customProportionDefault() {
    return 42;
  }
  static get pageLayoutMap() {
    return [
      { xml: 'page-height', smo: 'pageHeight' },
      { xml: 'page-width', smo: 'pageWidth' }
    ];
  }
  static get pageMarginMap() {
    return [
      { xml: 'left-margin', smo: 'leftMargin' },
      { xml: 'right-margin', smo: 'rightMargin' },
      { xml: 'top-margin', smo: 'topMargin' },
      { xml: 'bottom-margin', smo: 'bottomMargin' }
    ];
  }
  static get scoreInfoFields() {
    return ['title', 'subTitle', 'composer', 'copyright'];
  }
  // ### smoScoreFromXml
  // Main entry point for Smoosic mxml parser
  static smoScoreFromXml(xmlDoc) {
    try {
      const scoreRoots = [...xmlDoc.getElementsByTagName('score-partwise')];
      if (!scoreRoots.length) {
        // no score node
        return SmoScore.deserialize(emptyScoreJson);
      }

      const scoreRoot = scoreRoots[0];
      const scoreDefaults = JSON.parse(JSON.stringify(SmoScore.defaults));
      scoreDefaults.layout.svgScale = 0.5; // if no scale given in score, default to
      // something small.
      const xmlState = new XmlState();
      xmlState.newTitle = false;
      scoreDefaults.scoreInfo.name = 'Imported Smoosic';
      mxmlScore.scoreInfoFields.forEach((field) => {
        scoreDefaults.scoreInfo[field] = '';
      });
      const childNodes = [...scoreRoot.children];
      childNodes.forEach((scoreElement) => {
        if (scoreElement.tagName === 'work') {
          const scoreNameNode = [...scoreElement.getElementsByTagName('work-title')];
          if (scoreNameNode.length) {
            scoreDefaults.scoreInfo.title = scoreNameNode[0].textContent;
            scoreDefaults.scoreInfo.name = scoreDefaults.scoreInfo.title;
            xmlState.newTitle = true;
          }
        } else if (scoreElement.tagName === 'identification') {
          const creators = [...scoreElement.getElementsByTagName('creator')];
          creators.forEach((creator) => {
            if (creator.getAttribute('type') === 'composer') {
              scoreDefaults.scoreInfo.composer = creator.textContent;
            }
          });
        } else if (scoreElement.tagName === 'movement-title') {
          if (xmlState.newTitle) {
            scoreDefaults.scoreInfo.subTitle = scoreElement.textContent;
          } else {
            scoreDefaults.scoreInfo.title = scoreElement.textContent;
            scoreDefaults.scoreInfo.name = scoreDefaults.scoreInfo.title;
            xmlState.newTitle = true;
          }
        } else if (scoreElement.tagName === 'defaults') {
          mxmlScore.defaults(scoreElement, scoreDefaults);
        } else if (scoreElement.tagName === 'part') {
          xmlState.initializeForPart(xmlState);
          mxmlScore.part(scoreElement, xmlState);
        }
      });
      // The entire score is parsed and xmlState now contains the staves.
      const rv = new SmoScore(scoreDefaults);
      rv.staves = xmlState.smoStaves;
      xmlState.updateStaffGroups();
      rv.systemGroups = xmlState.systems;

      // Fix tempo to be column mapped
      rv.staves[0].measures.forEach((measure) => {
        const tempoStaff = rv.staves.find((ss) => ss.measures[measure.measureNumber.measureIndex].tempo.display === true);
        if (tempoStaff) {
          const tempo = tempoStaff.measures[measure.measureNumber.measureIndex].tempo;
          rv.staves.forEach((ss) => {
            ss.measures[measure.measureNumber.measureIndex].tempo =
              SmoMeasureModifierBase.deserialize(tempo);
          });
        }
      });
      if (rv.scoreInfo.title) {
        rv.addTextGroup(SmoTextGroup.createTextForLayout(
          SmoTextGroup.purposes.TITLE, rv.scoreInfo.title, rv.layout
        ));
      }
      if (rv.scoreInfo.subTitle) {
        rv.addTextGroup(SmoTextGroup.createTextForLayout(
          SmoTextGroup.purposes.SUBTITLE, rv.scoreInfo.subTitle, rv.layout
        ));
      }
      if (rv.scoreInfo.composer) {
        rv.addTextGroup(SmoTextGroup.createTextForLayout(
          SmoTextGroup.purposes.COMPOSER, rv.scoreInfo.composer, rv.layout
        ));
      }
      return rv;
    } catch (exc) {
      console.warn(exc);
      return SmoScore.deserialize(emptyScoreJson);
    }
  }

  // ### defaults
  // /score-partwise/defaults
  static defaults(defaultsElement, scoreDefaults)  {
    // Default scale for mxml
    let scale = 1 / 7;
    const pageLayoutNode = defaultsElement.getElementsByTagName('page-layout');
    if (pageLayoutNode.length) {
      mxmlHelpers.assignDefaults(pageLayoutNode[0], scoreDefaults.layout, mxmlScore.pageLayoutMap);
    }
    const pageMarginNode = mxmlHelpers.getChildrenFromPath(defaultsElement,
      ['page-layout', 'page-margins']);
    if (pageMarginNode.length) {
      mxmlHelpers.assignDefaults(pageMarginNode[0], scoreDefaults.layout, mxmlScore.pageMarginMap);
    }

    const scaleNode =  defaultsElement.getElementsByTagName('scaling');
    if (scaleNode.length) {
      const mm = mxmlHelpers.getNumberFromElement(scaleNode[0], 'millimeters', 1);
      const tn = mxmlHelpers.getNumberFromElement(scaleNode[0], 'tenths', 7);
      if (tn > 0 && mm > 0) {
        scale = mm / tn;
      }
    }
    // Convert from mm to pixels, this is our default svg scale
    // mm per tenth * pixels / mm gives us pixels per tenth
    scoreDefaults.layout.svgScale =  (scale * 45 / 40) / mxmlScore.mmPerPixel;
  }

  // ### part
  // /score-partwise/part
  static part(partElement, xmlState) {
    let staffId = xmlState.smoStaves.length;
    console.log('part ' + partElement.getAttribute('id'));
    xmlState.initializeForPart();
    const stavesForPart = [];
    const measureElements = [...partElement.getElementsByTagName('measure')];
    measureElements.forEach((measureElement) => {
      // Parse the measure element, populate staffArray of xmlState with the
      // measure data
      mxmlScore.measure(measureElement, xmlState);
      const newStaves = xmlState.staffArray;
      if (newStaves.length > 1 && stavesForPart.length <= newStaves[0].clefInfo.staffId) {
        xmlState.staffGroups.push({ start: staffId, length: newStaves.length });
      }
      xmlState.globalCursor += newStaves[0].measure.getMaxTicksVoice();
      newStaves.forEach((staffMeasure) => {
        if (stavesForPart.length <= staffMeasure.clefInfo.staffId) {
          stavesForPart.push(new SmoSystemStaff({ staffId }));
          staffId += 1;
        }
        const smoStaff = stavesForPart[staffMeasure.clefInfo.staffId];
        smoStaff.measures.push(staffMeasure.measure);
      });
      const oldStaffId = staffId - stavesForPart.length;
      xmlState.backtrackHairpins(stavesForPart[0], oldStaffId + 1);
    });
    xmlState.smoStaves = xmlState.smoStaves.concat(stavesForPart);
    xmlState.completeSlurs();
    xmlState.completeTies();
  }
  // ### tempo
  // /score-partwise/measure/direction/sound:tempo
  static tempo(element) {
    let tempoText = '';
    let customText = tempoText;
    const rv = [];
    const soundNodes = mxmlHelpers.getChildrenFromPath(element,
      ['sound']);
    soundNodes.forEach((sound) => {
      let tempoMode = SmoTempoText.tempoModes.durationMode;
      tempoText = sound.getAttribute('tempo');
      if (tempoText) {
        const bpm = parseInt(tempoText, 10);
        const wordNode =
          [...element.getElementsByTagName('words')];
        tempoText = wordNode.length ? wordNode[0].textContent :
          tempoText.toString();
        if (isNaN(tempoText)) {
          if (SmoTempoText.tempoTexts[tempoText.toLowerCase()]) {
            tempoMode = SmoTempoText.tempoModes.textMode;
          } else {
            tempoMode = SmoTempoText.tempoModes.customMode;
            customText = tempoText;
          }
        }
        const tempo = new SmoTempoText({
          tempoMode, bpm, tempoText, customText, display: true
        });
        const staffId = mxmlHelpers.getStaffId(element);
        rv.push({ staffId, tempo });
      }
    });
    return rv;
  }
  // ### dynamics
  // /score-partwise/part/measure/direction/dynamics
  static dynamics(directionElement, xmlState) {
    let offset = 1;
    const dynamicNodes = mxmlHelpers.getChildrenFromPath(directionElement,
      ['direction-type', 'dynamics']);
    const offsetNodes = mxmlHelpers.getChildrenFromPath(directionElement,
      ['offset']);
    if (offsetNodes.length) {
      offset = parseInt(offsetNodes[0].textContent, 10);
    }
    dynamicNodes.forEach((dynamic) => {
      xmlState.dynamics.push({ dynamic: dynamic.children[0].tagName,
        offset: (offset / xmlState.divisions) * 4096 });
    });
  }

  // ### attributes
  // /score-partwise/part/measure/attributes
  static attributes(measureElement, xmlState) {
    let smoKey = {};
    const attributesNodes = mxmlHelpers.getChildrenFromPath(measureElement, ['attributes']);
    if (!attributesNodes.length) {
      return;
    }
    const attributesNode = attributesNodes[0];
    xmlState.divisions =
      mxmlHelpers.getNumberFromElement(attributesNode, 'divisions', xmlState.divisions);

    const keyNode = mxmlHelpers.getChildrenFromPath(attributesNode, ['key']);
    // MusicXML expresses keys in 'fifths' from C.
    if (keyNode.length) {
      const fifths = mxmlHelpers.getNumberFromElement(keyNode[0], 'fifths', 0);
      if (fifths < 0) {
        smoKey = smoMusic.circleOfFifths[smoMusic.circleOfFifths.length + fifths];
      } else {
        smoKey = smoMusic.circleOfFifths[fifths];
      }
      xmlState.keySignature = smoKey.letter.toUpperCase();
      if (smoKey.accidental !== 'n') {
        xmlState.keySignature += smoKey.accidental;
      }
    }

    const currentTime = xmlState.timeSignature.split('/');
    const timeNodes = mxmlHelpers.getChildrenFromPath(attributesNode, ['time']);
    if (timeNodes.length) {
      const timeNode = timeNodes[0];
      const num = mxmlHelpers.getNumberFromElement(timeNode, 'beats', currentTime[0]);
      const den = mxmlHelpers.getNumberFromElement(timeNode, 'beat-type', currentTime[1]);
      xmlState.timeSignature = '' + num + '/' + den;
    }

    const clefNodes =  mxmlHelpers.getChildrenFromPath(attributesNode, ['clef']);
    if (clefNodes.length) {
      // We expect the number of clefs to equal the number of staves in each measure
      clefNodes.forEach((clefNode) => {
        let clefNum = 0;
        let clef = 'treble';
        const clefAttrs = mxmlHelpers.nodeAttributes(clefNode);
        if (typeof(clefAttrs.number) !== 'undefined') {
          // staff numbers index from 1 in mxml
          clefNum = parseInt(clefAttrs.number, 10) - 1;
        }
        const clefType = mxmlHelpers.getTextFromElement(clefNode, 'sign', 'G');
        const clefLine = mxmlHelpers.getNumberFromElement(clefNode, 'line', 2);
        // mxml supports a zillion clefs, just implement the basics.
        if (clefType === 'F') {
          clef = 'bass';
        } else if (clefType === 'C') {
          if (clefLine === 4) {
            clef = 'alto';
          } else if (clefLine === 3) {
            clef = 'tenor';
          } else if (clefLine === 1) {
            clef = 'soprano';
          }
        } else if (clefType === 'percussion') {
          clef = 'percussion';
        }
        if (xmlState.clefInfo.length <= clefNum) {
          xmlState.clefInfo.push({ clef, staffId: clefNum });
        } else {
          xmlState.clefInfo[clefNum].clef = clef;
        }
      });
    }
  }

  // ### wedge (hairpin)
  // /score-partwise/part/measure/direction/direction-type/wedge
  static wedge(directionElement, xmlState) {
    let crescInfo = {};
    const wedgeNodes = mxmlHelpers.getChildrenFromPath(directionElement,
      ['direction-type', 'wedge']);
    wedgeNodes.forEach((wedgeNode) => {
      crescInfo = { type: wedgeNode.getAttribute('type') };
    });
    // If this is a start hairpin, start it.  If an end hairpin, add it to the
    // hairpin array with the type and start/stop ticks
    xmlState.processWedge(crescInfo);
  }
  // ### direction
  // /score-partwise/part/measure/direction
  static direction(directionElement, xmlState) {
    const tempo = mxmlScore.tempo(directionElement);
    // Only display tempo if changes.
    if (tempo.length) {
      // TODO: staff ID is with tempo, but tempo is per column in SMO
      if (!SmoTempoText.eq(xmlState.tempo, tempo[0].tempo)) {
        xmlState.tempo = tempo[0].tempo;
        xmlState.tempo.display = true;
      }
    }
    // parse dynamic node and add to xmlState
    mxmlScore.dynamics(directionElement, xmlState);

    // parse wedge (hairpin)
    mxmlScore.wedge(directionElement, xmlState);
  }
  // ### note
  // /score-partwise/part/measure/note
  static note(noteElement, xmlState) {
    let noteData = {};
    let grIx = 0;
    const staffIndex = mxmlHelpers.getStaffId(noteElement);
    xmlState.staffIndex = staffIndex;
    // We assume the clef information from attributes comes before the notes
    // xmlState.staffArray[staffIndex] = { clefInfo: { clef }, voices[voiceIndex]: notes[] }
    if (xmlState.staffArray.length <= staffIndex) {
      // mxml has measures for all staves in a part interleaved.  In SMO they are
      // each in a separate stave object.  Base the staves we expect based on
      // the number of clefs in the xml state object
      xmlState.clefInfo.forEach((clefInfo) => {
        xmlState.staffArray.push({ clefInfo, voices: { } });
      });
    }
    const chordNode = mxmlHelpers.getChildrenFromPath(noteElement, ['chord']);
    if (chordNode.length === 0) {
      xmlState.currentDuration += mxmlHelpers.durationFromNode(noteElement, 0);
    }
    // voices are not sequential, seem to have artitrary numbers and
    // persist per part (same with staff IDs).  Update XML state if these are new
    // staves
    const voiceIndex = mxmlHelpers.getVoiceId(noteElement);
    xmlState.voiceIndex = voiceIndex;
    xmlState.initializeStaff(staffIndex, voiceIndex);
    const voice = xmlState.staffArray[staffIndex].voices[voiceIndex];
    // Calculate the tick and staff index for selectors
    const tickIndex = chordNode.length < 1 ? voice.notes.length : voice.notes.length - 1;
    const smoVoiceIndex = xmlState.staffVoiceHash[staffIndex].indexOf(voiceIndex);
    const pitchIndex = chordNode.length ? xmlState.previousNote.pitches.length : 0;
    const smoStaffIndex = xmlState.smoStaves.length + staffIndex;
    const selector = {
      staff: smoStaffIndex, measure: xmlState.measureIndex, voice: smoVoiceIndex,
      tick: tickIndex
    };
    const divisions = xmlState.divisions;
    const printText = noteElement.getAttribute('print-object');
    const hideNote = typeof(printText) === 'string' && printText === 'no';
    const isGrace = mxmlHelpers.isGrace(noteElement);
    const restNode = mxmlHelpers.getChildrenFromPath(noteElement, ['rest']);
    const noteType = restNode.length ? 'r' : 'n';
    const durationData = mxmlHelpers.ticksFromDuration(noteElement, divisions, 4096);
    const tickCount = durationData.tickCount;
    if (chordNode.length === 0) {
      xmlState.staffArray[staffIndex].voices[voiceIndex].ticksUsed += tickCount;
    }
    xmlState.tickCursor = (xmlState.currentDuration / divisions) * 4096;
    const beamState = mxmlHelpers.noteBeamState(noteElement);
    const slurInfos = mxmlHelpers.getSlurData(noteElement, selector);
    const tieInfos = mxmlHelpers.getTieData(noteElement, selector, pitchIndex);
    const tupletInfos = mxmlHelpers.getTupletData(noteElement);
    const ornaments = mxmlHelpers.articulationsAndOrnaments(noteElement);
    const lyrics = mxmlHelpers.lyrics(noteElement);
    const flagState = mxmlHelpers.getStemType(noteElement);

    const pitch = mxmlHelpers.smoPitchFromNote(noteElement,
      SmoMeasure.defaultPitchForClef[xmlState.staffArray[staffIndex].clefInfo.clef]);
    if (isGrace === false) {
      if (chordNode.length) {
        // If this is a note in a chord, just add the pitch to previous note.
        xmlState.previousNote.pitches.push(pitch);
        xmlState.updateTieStates(tieInfos, selector);
      } else {
        // Create a new note
        noteData = JSON.parse(JSON.stringify(SmoNote.defaults));
        noteData.noteType = noteType;
        noteData.pitches = [pitch];
        // If this is a non-grace note, add any grace notes to the note since SMO
        // treats them as note modifiers
        noteData.ticks = { numerator: tickCount, denominator: 1, remainder: 0 };
        noteData.flagState = flagState;
        xmlState.previousNote = new SmoNote(noteData);
        if (hideNote) {
          xmlState.previousNote.makeHidden(true);
        }
        xmlState.updateDynamics();
        ornaments.forEach((ornament) => {
          if (ornament.ctor === 'SmoOrnament') {
            xmlState.previousNote.toggleOrnament(ornament);
          } else if (ornament.ctor === 'SmoArticulation') {
            xmlState.previousNote.toggleArticulation(ornament);
          }
        });
        lyrics.forEach((lyric) => {
          xmlState.addLyric(xmlState.previousNote, lyric);
        });
        for (grIx = 0; grIx < xmlState.graceNotes.length; ++grIx) {
          xmlState.previousNote.addGraceNote(xmlState.graceNotes[grIx], grIx);
        }
        xmlState.graceNotes = []; // clear the grace note array
        // If this note starts later than the cursor due to forward, pad with rests
        if (xmlState.tickCursor > xmlState.staffArray[staffIndex].voices[voiceIndex].ticksUsed) {
          const pads = smoMusic.splitIntoValidDurations(
            xmlState.tickCursor - xmlState.staffArray[staffIndex].voices[voiceIndex].ticksUsed);
          pads.forEach((pad) => {
            const padNote = SmoMeasure.createRestNoteWithDuration(pad,
              xmlState.staffArray[staffIndex].clefInfo.clef);
            padNote.makeHidden(true);
            voice.notes.push(padNote);
          });
          // Offset any partially-completed ties or slurs with the padding
          slurInfos.forEach((slurInfo) => {
            slurInfo.selector.tick += pads.length;
          });
          tieInfos.forEach((tieInfo) => {
            tieInfo.selector.tick += pads.length;
          });
          selector.tick += pads.length;
          console.log('Added ' + pads.length + ' ticks to ' + JSON.stringify(selector, null, ' '));
          // then reset the cursor since we are now in sync
          xmlState.staffArray[staffIndex].voices[voiceIndex].ticksUsed = xmlState.tickCursor;
        }
        xmlState.updateSlurStates(slurInfos);
        xmlState.updateTieStates(tieInfos);
        voice.notes.push(xmlState.previousNote);
        xmlState.updateBeamState(beamState, durationData.alteration, voice, voiceIndex);
        xmlState.updateTupletStates(tupletInfos, voice,
          staffIndex, voiceIndex);
      }
    } else {
      if (chordNode.length) {
        xmlState.graceNotes[xmlState.graceNotes.length - 1].pitches.push(pitch);
      } else {
        // grace note durations don't seem to have explicit duration, so
        // get it from note type
        xmlState.updateSlurStates(slurInfos);
        xmlState.updateTieStates(tieInfos);
        xmlState.graceNotes.push(new SmoGraceNote({
          pitches: [pitch],
          ticks: { numerator: tickCount, denominator: 1, remainder: 0 }
        }));
      }
    }
  }
  // ### parseMeasureElement
  // /score-partwise/part/measure
  // A measure in music xml might represent several measures in SMO at the same
  // column in the score
  static measure(measureElement, xmlState) {
    xmlState.initializeForMeasure(measureElement);
    const elements = [...measureElement.children];
    let hasNotes = false;
    elements.forEach((element) => {
      if (element.tagName === 'backup') {
        xmlState.currentDuration -= mxmlHelpers.durationFromNode(element);
      }
      if (element.tagName === 'forward') {
        xmlState.currentDuration += mxmlHelpers.durationFromNode(element);
      }
      if (element.tagName === 'attributes') {
        // update the running state of the XML with new information from this measure
        // if an XML attributes element is present
        mxmlScore.attributes(measureElement, xmlState);
      } else if (element.tagName === 'direction') {
        mxmlScore.direction(element, xmlState);
      } else if (element.tagName === 'note') {
        mxmlScore.note(element, xmlState);
        hasNotes = true;
      }
    });
    // If a measure has no notes, just make one with the defaults
    if (hasNotes === false && xmlState.staffArray.length < 1 && xmlState.clefInfo.length >= 1) {
      xmlState.clefInfo.forEach((clefInfo) => {
        xmlState.staffArray.push({ clefInfo, voices: { } });
      });
    }
    xmlState.staffArray.forEach((staffData) => {
      const smoMeasure = SmoMeasure.getDefaultMeasure({
        clef: staffData.clefInfo.clef
      });
      smoMeasure.systemBreak = mxmlHelpers.isSystemBreak(measureElement);
      smoMeasure.tempo = xmlState.tempo;
      smoMeasure.customProportion = mxmlScore.customProportionDefault;
      smoMeasure.keySignature = xmlState.keySignature;
      smoMeasure.timeSignature = xmlState.timeSignature;
      smoMeasure.measureNumber.measureNumber = xmlState.measureNumber;
      smoMeasure.measureNumber.measureIndex = xmlState.measureIndex;
      smoMeasure.measureNumber.staffId = staffData.clefInfo.staffId + xmlState.smoStaves.length;
      // voices not in array, put them in an array
      Object.keys(staffData.voices).forEach((voiceKey) => {
        const voice = staffData.voices[voiceKey];
        xmlState.addTupletsToMeasure(smoMeasure, staffData.clefInfo.staffId,
          parseInt(voiceKey, 10));
        voice.notes.forEach((note) => {
          if (!note.clef) {
            note.clef = smoMeasure.clef;
          }
        });
        smoMeasure.voices.push(voice);
      });
      if (smoMeasure.voices.length === 0) {
        smoMeasure.voices.push({ notes: SmoMeasure.getDefaultNotes(smoMeasure) });
      }
      staffData.measure = smoMeasure;
    });
    // Pad incomplete measures/voices with rests
    const maxTicks = xmlState.staffArray.map((staffData) => staffData.measure.getMaxTicksVoice())
      .reduce((a, b) => a > b ? a : b);
    xmlState.staffArray.forEach((staffData) => {
      let i = 0;
      let j = 0;
      for (i = 0; i < staffData.measure.voices.length; ++i) {
        const curTicks = staffData.measure.getTicksFromVoice(i);
        if (curTicks < maxTicks) {
          const tickAr = smoMusic.splitIntoValidDurations(maxTicks - curTicks);
          for (j = 0; j < tickAr.length; ++j) {
            staffData.measure.voices[i].notes.push(
              SmoMeasure.createRestNoteWithDuration(tickAr[j], staffData.measure.clef)
            );
          }
        }
      }
    });
  }
}
;// ## XmlState
// Keep state of musical objects while parsing music xml
// eslint-disable-next-line no-unused-vars
class XmlState {
  static get defaults() {
    return {
      divisions: 1, tempo: new SmoTempoText(), timeSignature: '4/4', keySignature: 'C',
      clefInfo: [], staffGroups: [], smoStaves: []
    };
  }
  constructor() {
    Vex.Merge(this, XmlState.defaults);
  }

  // Initialize things that persist throughout a staff
  // likc hairpins and slurs
  initializeForPart() {
    this.slurs = {};
    this.ties = {};
    this.wedges = {};
    this.hairpins = [];
    this.globalCursor = 0;
    this.staffVoiceHash = {};
    this.measureIndex = -1;
    this.completedSlurs = [];
    this.completedTies = [];
    this.verseMap = {};
  }
  // ### initializeForMeasure
  // reset state for a new measure:  beam groups, tuplets
  // etc. that don't cross measure boundaries
  initializeForMeasure(measureElement) {
    const oldMeasure = this.measureNumber;
    this.measureNumber =
      parseInt(measureElement.getAttribute('number'), 10) - 1;
    if (isNaN(this.measureNumber)) {
      this.measureNumber = oldMeasure + 1;
    }
    this.tuplets = {};
    this.tickCursor = 0;
    this.tempo = SmoMeasureModifierBase.deserialize(this.tempo.serialize());
    this.tempo.display = false;
    this.staffArray = [];
    this.graceNotes = [];
    this.currentDuration = 0;
    this.beamGroups = {};
    this.completedTuplets = [];
    this.dynamics = [];
    this.previousNote = {};
    this.measureIndex += 1;
  }
  // ### initializeStaff
  // voices are not sequential, seem to have artitrary numbers and
  // persist per part, so we treat them as a hash.
  // staff IDs persist per part but are sequential.
  initializeStaff(staffIndex, voiceIndex) {
    if (typeof(this.staffArray[staffIndex].voices[voiceIndex]) === 'undefined') {
      this.staffArray[staffIndex].voices[voiceIndex] = { notes: [] };
      this.staffArray[staffIndex].voices[voiceIndex].ticksUsed = 0;
      // keep track of 0-indexed voice for slurs and other modifiers
      if (!this.staffVoiceHash[staffIndex]) {
        this.staffVoiceHash[staffIndex] = [];
      }
      if (this.staffVoiceHash[staffIndex].indexOf(voiceIndex) < 0) {
        this.staffVoiceHash[staffIndex].push(voiceIndex);
      }
      // The smo 0-indexed voice index, used in selectors
      this.beamGroups[voiceIndex] = null;
    }
  }
  // ### updateStaffGroups
  // once everything is parsed, figure out how to group the staves
  updateStaffGroups() {
    this.systems = [];
    this.staffGroups.forEach((staffGroup) => {
      const len = this.smoStaves[staffGroup.start].measures.length;
      const startSelector = { staff: staffGroup.start, measure: 0 };
      const endSelector = { staff: staffGroup.start + (staffGroup.length - 1),
        measure: len };
      this.systems.push(
        new SmoSystemGroup({
          startSelector, endSelector, leftConnector: SmoSystemGroup.connectorTypes.brace
        })
      );
    });
  }
  addLyric(note, lyricData) {
    if (!this.verseMap[lyricData.verse]) {
      const keys = Object.keys(this.verseMap);
      this.verseMap[lyricData.verse] = keys.length;
    }
    lyricData.verse = this.verseMap[lyricData.verse];
    const lyric = new SmoLyric(lyricData);
    note.addLyric(lyric);
  }
  // ### processWedge (hairpin)
  processWedge(wedgeInfo) {
    if (wedgeInfo.type) {
      // If we already know about this wedge, it must have been
      // started, so complete it
      if (this.wedges.type) {
        this.hairpins.push({ type: this.wedges.type,
          start: this.wedges.start,
          end: this.tickCursor + this.globalCursor });
        this.wedges = {};
      } else {
        this.wedges.type = wedgeInfo.type;
        this.wedges.start = this.tickCursor + this.globalCursor;
      }
    }
  }
  // ### backtrackHairpins
  // For the measure just parsed, find the correct tick for the
  // beginning and end of hairpins, if a hairpin stop directive
  // was received.  These are not associated with a staff or voice, so
  // we use the first one in the measure element for both
  backtrackHairpins(smoStaff, staffId) {
    this.hairpins.forEach((hairpin) => {
      let hpMeasureIndex = this.measureIndex;
      let hpMeasure = smoStaff.measures[hpMeasureIndex];
      let startTick = hpMeasure.voices[0].notes.length - 1;
      let hpTickCount = this.globalCursor; // All ticks read so far
      const endSelector = {
        staff: staffId - 1, measure: hpMeasureIndex, voice: 0,
        tick: -1
      };
      while (hpMeasureIndex >= 0 && hpTickCount > hairpin.start) {
        if (endSelector.tick < 0 && hpTickCount <= hairpin.end) {
          endSelector.tick = startTick;
        }
        hpTickCount -= hpMeasure.voices[0].notes[startTick].ticks.numerator;
        if (hpTickCount > hairpin.start) {
          startTick -= 1;
          if (startTick < 0) {
            hpMeasureIndex -= 1;
            hpMeasure = smoStaff.measures[hpMeasureIndex];
            startTick = hpMeasure.voices[0].notes.length - 1;
          }
        }
      }
      const startSelector = {
        staff: staffId - 1, measure: hpMeasureIndex, voice: 0, tick: startTick
      };
      const smoHp = new SmoStaffHairpin({
        startSelector, endSelector, hairpinType: hairpin.type === 'crescendo' ?
          SmoStaffHairpin.types.CRESCENDO :
          SmoStaffHairpin.types.DECRESCENDO
      });
      smoStaff.modifiers.push(smoHp);
    });
    this.hairpins = [];
  }

  // ### updateDynamics
  // Based on note just parsed, put the dynamics on the closest
  // note, based on the offset of dynamic
  updateDynamics() {
    const smoNote = this.previousNote;
    const tickCursor = this.tickCursor;
    const newArray = [];
    this.dynamics.forEach((dynamic) => {
      if (tickCursor >= dynamic.offset) {
        // TODO: change the smonote name of this interface
        smoNote.addModifier(new SmoDynamicText({ text: dynamic.dynamic }));
      } else {
        newArray.push(dynamic);
      }
    });
    this.dynamics = newArray;
  }
  // For the given voice, beam the notes according to the
  // note beam length
  backtrackBeamGroup(voice, beamGroup) {
    let i = 0;
    for (i = 0; i < beamGroup.notes; ++i) {
      const note = voice.notes[voice.notes.length - (i + 1)];
      if (!note) {
        console.warn('no note for beam group');
        return;
      }
      note.endBeam = i === 0;
      note.beamBeats = beamGroup.ticks;
    }
  }
  // ### updateBeamState
  // Keep track of beam instructions found while parsing note element
  // includes time alteration from tuplets
  updateBeamState(beamState, alteration, voice, voiceIndex) {
    const note = voice.notes[voice.notes.length - 1];
    if (beamState === mxmlHelpers.beamStates.BEGIN) {
      this.beamGroups[voiceIndex] = { ticks: (note.tickCount * alteration.noteCount) / alteration.noteDuration,
        notes: 1 };
    } else if (this.beamGroups[voiceIndex]) {
      this.beamGroups[voiceIndex].ticks += note.tickCount;
      this.beamGroups[voiceIndex].notes += 1;
      if (beamState === mxmlHelpers.beamStates.END) {
        this.backtrackBeamGroup(voice, this.beamGroups[voiceIndex]);
        this.beamGroups[voiceIndex] = null;
      }
    }
  }
  updateTieStates(tieInfos) {
    tieInfos.forEach((tieInfo) => {
      // tieInfo = { number, type, orientation, selector, pitchIndex }
      if (tieInfo.type === 'start') {
        this.ties[tieInfo.number] = JSON.parse(JSON.stringify(tieInfo));
      } else if (tieInfo.type === 'stop') {
        if (this.ties[tieInfo.number]) {
          this.completedTies.push({
            startSelector: JSON.parse(JSON.stringify(this.ties[tieInfo.number].selector)),
            endSelector: JSON.parse(JSON.stringify(tieInfo.selector)),
            fromPitch: this.ties[tieInfo.number].pitchIndex,
            toPitch: tieInfo.pitchIndex
          });
        }
      }
    });
  }
  static slurDirectionFromNote(clef, note, orientation) {
    const rv = { invert: false, yOffset: SmoSlur.defaults.yOffset };
    const flagState = smoMusic.flagStateFromNote(clef, note);
    if (flagState === SmoNote.flagStates.up && orientation === 'over') {
      rv.invert = true;
      rv.yOffset += 50;
    }
    if (flagState === SmoNote.flagStates.down && orientation === 'under') {
      rv.invert = true;
      rv.yOffset -= 50;
    }
    return rv;
  }
  // ### updateSlurStates
  // While parsing a measure,
  // on a slur element, either complete a started
  // slur or start a new one.
  updateSlurStates(slurInfos) {
    const clef = this.staffArray[this.staffIndex].clefInfo.clef;
    const note = this.previousNote;
    slurInfos.forEach((slurInfo) =>  {
      // slurInfo = { number, type, selector }
      if (slurInfo.type === 'start') {
        if (this.slurs[slurInfo.number] && this.slurs[slurInfo.number].type === 'stop') {
          // if start and stop come out of order
          const slurParams = {
            endSelector: JSON.parse(JSON.stringify(this.slurs[slurInfo.number].selector)),
            startSelector: slurInfo.selector
          };
          const alter = XmlState.slurDirectionFromNote(clef, note, slurInfo.orientation);
          slurParams.yOffset = alter.yOffset;
          slurParams.invert = alter.invert;
          console.log('complete slur stop first ' + slurInfo.number + JSON.stringify(slurParams, null, ' '));
          this.completedSlurs.push(slurParams);
          this.slurs[slurInfo.number] = null;
        } else {
          const alter = XmlState.slurDirectionFromNote(clef, note, slurInfo.orientation);
          this.slurs[slurInfo.number] = JSON.parse(JSON.stringify(slurInfo));
          this.slurs[slurInfo.number].yOffset = alter.yOffset;
          this.slurs[slurInfo.number].invert = alter.invert;
        }
      } else if (slurInfo.type === 'stop') {
        if (this.slurs[slurInfo.number] && this.slurs[slurInfo.number].type === 'start') {
          const slurParams = {
            startSelector: JSON.parse(JSON.stringify(this.slurs[slurInfo.number].selector)),
            endSelector: slurInfo.selector,
            yOffset: this.slurs[slurInfo.number].yOffset,
            invert: this.slurs[slurInfo.number].invert
          };
          console.log('complete slur ' + slurInfo.number + JSON.stringify(slurParams, null, ' '));
          this.completedSlurs.push(slurParams);
          this.slurs[slurInfo.number] = null;
        } else {
          this.slurs[slurInfo.number] = JSON.parse(JSON.stringify(slurInfo));
        }
      }
    });
  }
  // ### completeTies
  completeTies() {
    this.completedTies.forEach((tie) => {
      const smoTie = new SmoTie({
        startSelector: tie.startSelector,
        endSelector: tie.endSelector
      });
      smoTie.lines = [{
        from: tie.fromPitch, to: tie.toPitch
      }];
      this.smoStaves[tie.startSelector.staff].addStaffModifier(smoTie);
    });
  }
  // ### completeSlurs
  // After reading in a measure, update any completed slurs and make them
  // into SmoSlur and add them to the SmoSystemGroup objects.
  // staffIndexOffset is the offset from the xml staffId and the score staff Id
  // (i.e. the staves that have already been parsed in other parts)
  completeSlurs() {
    this.completedSlurs.forEach((slur) => {
      const smoSlur = new SmoSlur({
        startSelector: slur.startSelector,
        endSelector: slur.endSelector,
        yOffset: slur.yOffset,
        invert: slur.invert
      });
      this.smoStaves[slur.startSelector.staff].addStaffModifier(smoSlur);
    });
  }
  // ### backtrackTuplets
  // If we received a tuplet end, go back through the voice
  // and construct the SmoTuplet.
  backtrackTuplets(voice, tupletNumber, staffId, voiceId) {
    const tupletState = this.tuplets[tupletNumber];
    let i = tupletState.start.tick;
    const notes = [];
    const durationMap = [];
    while (i < voice.notes.length) {
      const note = voice.notes[i];
      notes.push(note);
      if (i === tupletState.start.tick) {
        durationMap.push(1.0);
      } else {
        const prev = voice.notes[i - 1];
        durationMap.push(note.ticks.numerator / prev.ticks.numerator);
      }
      i += 1;
    }
    const tuplet = new SmoTuplet({
      notes,
      durationMap,
      voice: voiceId
    });
    // Store the tuplet with the staff ID and voice so we
    // can add it to the right measure when it's created.
    this.completedTuplets.push({ tuplet, staffId, voiceId });
  }
  // ### updateTupletStates
  // react to a tuplet start or stop directive
  updateTupletStates(tupletInfos, voice, staffIndex, voiceIndex) {
    const tick = voice.notes.length - 1;
    tupletInfos.forEach((tupletInfo) =>  {
      if (tupletInfo.type === 'start') {
        this.tuplets[tupletInfo.number] = {
          start: { staff: staffIndex, voice: voiceIndex, tick }
        };
      } else if (tupletInfo.type === 'stop') {
        this.tuplets[tupletInfo.number].end = {
          staff: staffIndex, voice: voiceIndex, tick
        };
        this.backtrackTuplets(voice, tupletInfo.number, staffIndex, voiceIndex);
      }
    });
  }
  addTupletsToMeasure(smoMeasure, staffId, voiceId) {
    const completed = [];
    this.completedTuplets.forEach((tuplet) => {
      if (tuplet.voiceId === voiceId && tuplet.staffId === staffId) {
        smoMeasure.tuplets.push(tuplet.tuplet);
      } else {
        completed.push(tuplet);
      }
    });
    this.completedTuplets = completed;
  }
}
;// ## SmoActionRecord
// Record a list of actions, for playback or unit testing.
// eslint-disable-next-line no-unused-vars
class SmoActionRecord {
  static get refreshTimer() {
    return 10000;
  }
  static get actionInterval() {
    return 50;
  }
  constructor() {
    this.actions = [];
    this.executeIndex = 0;
    this._target = null;
    this.refreshTime = 0;
  }
  addAction(method, ...args) {
    // Don't add actions while running
    if (this.actions.length && !this.endCondition) {
      return;
    }
    const obj = {};
    obj.method = method;
    obj.parameters = [];
    args.forEach((arg) => {
      if (typeof(arg) === 'object' && arg !== null) {
        if (typeof(arg.serialize) === 'function') {
          obj.parameters.push(arg.serialize());
        } else {
          obj.parameters.push(JSON.parse(JSON.stringify(arg)));
        }
      } else {
        if (typeof(arg) !== 'undefined') {
          obj.parameters.push(arg);
        }
      }
    });
    if (this.actions.length > 0) {
      const lastAction = this.actions[this.actions.length - 1];
      if (lastAction.method === obj.method) {
        const lastStr = JSON.stringify(lastAction.parameters);
        const thisStr = JSON.stringify(obj.parameters);
        if (lastStr === thisStr) {
          this._refreshing = false;
          lastAction.count += 1;
          return;
        }
      }
    }
    obj.count = 1;
    this.actions.push(obj);
    this.executeIndex = this.actions.length;
    this._refreshing = false;
  }
  resetRunner() {
    this.executeIndex = this.actions.length;
  }
  clearActions() {
    this.actions = [];
    this.executeIndex = 0;
  }
  cancelRun() {
    this.executeIndex = this.actions.length;
  }
  get endCondition() {
    return this.actions.length < 1 || this.executeIndex >= this.actions.length;
  }
  callNextAction() {
    if (this.endCondition) {
      return null;
    }
    const action = this.actions[this.executeIndex];
    const args = [];
    action.parameters.forEach((param) => {
      if (typeof(param) === 'object') {
        if (typeof(param.ctor) === 'string') {
          const ctor = eval(param.ctor);
          args.push(new ctor(param));
        } else {
          args.push(JSON.parse(JSON.stringify(param)));
        }
      } else {
        args.push(param);
      }
    });
    if (typeof(action.count) === 'undefined' || isNaN(action.count)) {
      action.count = 1;
    }
    this.executeIndex += 1;
    return { method: action.method, args, count: action.count };
  }
}
;// eslint-disable-next-line no-unused-vars
class smoBeamerFactory {
  static applyBeams(measure) {
    let i = 0;
    for (i = 0; i < measure.voices.length; ++i) {
      const beamer = new smoBeamModifier(measure, i);
      const apply = new smoBeamerIterator(measure, beamer, i);
      apply.run();
    }
  }
}

class smoBeamerIterator {
  constructor(measure, actor, voice) {
    this.actor = actor;
    this.measure = measure;
    this.voice = voice;
  }

  //  ### run
  //  ###  Description:  start the iteration on this set of notes
  run() {
    let i = 0;
    const tickmap = this.measure.tickmapForVoice(this.voice);
    for (i = 0; i < tickmap.durationMap.length; ++i) {
      this.actor.beamNote(tickmap, i, this.measure.voices[this.voice].notes[i]);
    }
  }
}

class smoBeamModifier {
  constructor(measure, voice) {
    this.measure = measure;
    this._removeVoiceBeam(measure, voice);
    this.duration = 0;
    this.timeSignature = measure.timeSignature;
    this.meterNumbers = this.timeSignature.split('/').map(number => parseInt(number, 10));
    // beam on 1/4 notes in most meter, triple time dotted quarter
    this.beamBeats = 2 * 2048;
    if (this.meterNumbers[0] % 3 === 0) {
      this.beamBeats = 3 * 2048;
    }
    this.skipNext = 0;
    this.currentGroup = [];
  }

  get beamGroups() {
    return this.measure.beamGroups;
  }
  _removeVoiceBeam(measure, voice) {
    const beamGroups = [];
    measure.beamGroups.forEach((gr) => {
      if (gr.voice !== voice) {
        beamGroups.push(gr);
      }
    });
    measure.beamGroups = beamGroups;
  }

  _completeGroup(voice) {
    const nrCount = this.currentGroup.filter((nn) =>
      nn.isRest() === false
    );
    // don't beam groups of 1
    if (nrCount.length > 1) {
      this.measure.beamGroups.push(new SmoBeamGroup({
        notes: this.currentGroup,
        voice
      }));
    }
  }

  _advanceGroup() {
    this.currentGroup = [];
    this.duration = 0;
  }

  // ### _isRemainingTicksBeamable
  // look ahead, and see if we need to beam the tuplet now or if we
  // can combine current beam with future notes.
  _isRemainingTicksBeamable(tickmap, index) {
    let acc = 0;
    let i = 0;
    if (this.duration >= this.beamBeats) {
      return false;
    }
    acc = this.duration;
    for (i = index + 1; i < tickmap.deltaMap.length; ++i) {
      acc += tickmap.deltaMap[i];
      if (acc === this.beamBeats) {
        return true;
      }
      if (acc > this.beamBeats) {
        return false;
      }
    }
    return false;
  }
  beamNote(tickmap, index, note) {
    this.beamBeats = note.beamBeats;
    this.duration += tickmap.deltaMap[index];

    // beam tuplets
    if (note.isTuplet) {
      const tuplet = this.measure.getTupletForNote(note);
      // The underlying notes must have been deleted.
      if (!tuplet) {
        return;
      }
      const ult = tuplet.notes[tuplet.notes.length - 1];
      const first = tuplet.notes[0];

      if (first.endBeam) {
        this._advanceGroup();
        return;
      }

      // is this beamable length-wise
      const vexDuration = smoMusic.closestVexDuration(note.tickCount);
      const stemTicks = VF.durationToTicks.durations[vexDuration];
      if (stemTicks < 4096) {
        this.currentGroup.push(note);
      }
      // Ultimate note in tuplet
      if (ult.attrs.id === note.attrs.id && !this._isRemainingTicksBeamable(tickmap, index)) {
        this._completeGroup(tickmap.voice);
        this._advanceGroup();
      }
      return;
    }

    // don't beam > 1/4 note in 4/4 time.  Don't beam rests.
    if (tickmap.deltaMap[index] >= 4096 || (note.isRest() && this.currentGroup.length === 0)) {
      this._completeGroup(tickmap.voice);
      this._advanceGroup();
      return;
    }

    this.currentGroup.push(note);
    if (note.endBeam) {
      this._completeGroup(tickmap.voice);
      this._advanceGroup();
    }

    if (this.duration === this.beamBeats) {
      this._completeGroup(tickmap.voice);
      this._advanceGroup();
      return;
    }

    // If this does not align on a beat, don't beam it
    if (this.duration > this.beamBeats) {
      this._advanceGroup();
    }
  }
}
;// ## PasteBuffer
// ### Description:
// Hold some music that can be pasted back to the score
// eslint-disable-next-line no-unused-vars
class PasteBuffer {
  constructor() {
    this.notes = [];
    this.noteIndex = 0;
    this.measures = [];
    this.measureIndex = -1;
    this.remainder = 0;
    this.replacementMeasures = [];
  }

  setSelections(score, selections) {
    this.notes = [];
    this.noteIndex = 0;
    this.score = score;
    if (selections.length < 1) {
      return;
    }
    this.tupletNoteMap = {};
    const first = selections[0];
    const last = selections[selections.length - 1];

    const startTuplet = first.measure.getTupletForNote(first.note);
    if (startTuplet) {
      if (startTuplet.getIndexOfNote(first.note) !== 0) {
        return; // can't paste from the middle of a tuplet
      }
    }
    const endTuplet = last.measure.getTupletForNote(last.note);
    if (endTuplet) {
      if (endTuplet.getIndexOfNote(last.note) !== endTuplet.notes.length - 1) {
        return; // can't paste part of a tuplet.
      }
    }
    this._populateSelectArray(selections);
  }
  // ### _populateSelectArray
  // copy the selected notes into the paste buffer with their original locations.
  _populateSelectArray(selections) {
    let selector = {};
    this.modifiers = [];
    selections.forEach((selection) => {
      selector = JSON.parse(JSON.stringify(selection.selector));
      const mod = selection.staff.getModifiersAt(selector);
      if (mod.length) {
        mod.forEach((modifier) => {
          const cp = StaffModifierBase.deserialize(modifier.serialize());
          cp.attrs.id = VF.Element.newID();
          this.modifiers.push(cp);
        });
      }
      if (selection.note.isTuplet) {
        const tuplet = selection.measure.getTupletForNote(selection.note);
        const index = tuplet.getIndexOfNote(selection.note);
        if (index === 0) {
          const ntuplet = SmoTuplet.cloneTuplet(tuplet);
          this.tupletNoteMap[ntuplet.attrs.id] = ntuplet;
          ntuplet.notes.forEach((nnote) => {
            this.notes.push({ selector, note: nnote });
            selector = JSON.parse(JSON.stringify(selector));
            selector.tick += 1;
          });
        }
      } else {
        const note = SmoNote.clone(selection.note);
        this.notes.push({ selector, note });
      }
    });
    this.notes.sort((a, b) =>
      SmoSelector.gt(a.selector, b.selector) ? 1 : -1
    );
  }

  clearSelections() {
    this.notes = [];
  }

  _findModifier(selector) {
    const rv = this.modifiers.filter((mod) => SmoSelector.eq(selector, mod.startSelector));
    return (rv && rv.length) ? rv[0] : null;
  }
  _findPlacedModifier(selector) {
    const rv = this.modifiers.filter((mod) => SmoSelector.eq(selector, mod.endSelector));
    return (typeof(rv) !== 'undefined' && rv.length) ? rv[0] : null;
  }

  // ### _populateMeasureArray
  // Before pasting, populate an array of existing measures from the paste destination
  // so we know how to place the notes.
  _populateMeasureArray() {
    let measureSelection = SmoSelection.measureSelection(this.score, this.destination.staff, this.destination.measure);
    const measure = measureSelection.measure;
    const tickmap = measure.tickmapForVoice(this.destination.voice);
    let currentDuration = tickmap.durationMap[this.destination.tick];
    this.measures = [];
    this.staffSelectors = [];
    this.measures.push(measure);
    this.notes.forEach((selection) => {
      if (currentDuration + selection.note.tickCount > tickmap.totalDuration && measureSelection !== null) {
        // If this note will overlap the measure boundary, the note will be split in 2 with the
        // remainder going to the next measure.  If they line up exactly, the remainder is 0.
        const remainder = (currentDuration + selection.note.tickCount) - tickmap.totalDuration;
        currentDuration = remainder;

        measureSelection = SmoSelection.measureSelection(this.score,
          measureSelection.selector.staff,
          measureSelection.selector.measure + 1);

        // If the paste buffer overlaps the end of the score, we can't paste (TODO:  add a measure in this case)
        if (measureSelection != null) {
          this.measures.push(measureSelection.measure);
        }
      } else if (measureSelection != null) {
        currentDuration += selection.note.tickCount;
      }
    });
  }

  // ### _populatePre
  // When we paste, we replace entire measures.  Populate the first measure up until the start of pasting.
  _populatePre(voiceIndex, measure, startTick, tickmap) {
    const voice = {
      notes: []
    };
    let i = 0;
    let j = 0;
    let ticksToFill = tickmap.durationMap[startTick];
    // TODO: bug here, need to handle tuplets in pre-part, create new tuplet
    for (i = 0; i < measure.voices[voiceIndex].notes.length; ++i) {
      const note = measure.voices[voiceIndex].notes[i];
      // If this is a tuplet, clone all the notes at once.
      if (note.isTuplet) {
        const tuplet = measure.getTupletForNote(note);
        if (!tuplet) {
          continue;  // we remove the tuplet after first iteration
        }
        const ntuplet = SmoTuplet.cloneTuplet(tuplet);
        voice.notes = voice.notes.concat(ntuplet.notes);
        measure.removeTupletForNote(note);
        measure.tuplets.push(ntuplet);
        ticksToFill -= tuplet.tickCount;
      } else if (ticksToFill >= note.tickCount) {
        ticksToFill -= note.tickCount;
        voice.notes.push(SmoNote.clone(note));
      } else {
        const duration = note.tickCount - ticksToFill;
        const durMap = smoMusic.gcdMap(duration);
        for (j = 0; j < durMap.length; ++j) {
          const dd = durMap[j];
          SmoNote.cloneWithDuration(note, {
            numerator: dd,
            denominator: 1,
            remainder: 0
          });
        }
        ticksToFill = 0;
      }
      if (ticksToFill < 1) {
        break;
      }
    }
    return voice;
  }

  // ### _populateVoice
  // ### Description:
  // Create a new voice for a new measure in the paste destination
  _populateVoice(voiceIndex) {
    this._populateMeasureArray();
    const measures = this.measures;
    let measure = measures[0];
    let tickmap = measure.tickmapForVoice(this.destination.voice);
    let voice = this._populatePre(voiceIndex, measure, this.destination.tick, tickmap);
    let startSelector = JSON.parse(JSON.stringify(this.destination));
    this.measureIndex = 0;
    const measureVoices = [];
    measureVoices.push(voice);
    while (this.measureIndex < measures.length) {
      measure = measures[this.measureIndex];
      tickmap = measure.tickmapForVoice(this.destination.voice);
      this._populateNew(voice, voiceIndex, measure, tickmap, startSelector);
      if (this.noteIndex < this.notes.length && this.measureIndex < measures.length) {
        voice = {
          notes: []
        };
        measureVoices.push(voice);
        startSelector = {
          staff: startSelector.staff,
          measure: startSelector.measure,
          voice: voiceIndex,
          tick: 0
        };
        this.measureIndex += 1;
        startSelector.measure += 1;
      } else {
        break;
      }
    }
    this._populatePost(voice, voiceIndex, measure, tickmap, startSelector.tick);
    return measureVoices;
  }

  static _countTicks(voice) {
    let voiceTicks = 0;
    voice.notes.forEach((note) => {
      voiceTicks += note.tickCount;
    });
    return voiceTicks;
  }

  // ### _populateModifier
  // If the destination contains a modifier start and end, copy and paste it.
  _populateModifier(srcSelector, destSelector, staff) {
    // If this is the ending point of a staff modifier, paste the modifier
    const mod = this._findPlacedModifier(srcSelector);
    if (mod) {
      mod.endSelector = JSON.parse(JSON.stringify(destSelector));
      mod.attrs.id = VF.Element.newID();
      staff.addStaffModifier(mod);
    }
  }

  // ### _populateNew
  // Start copying the paste buffer into the destination by copying the notes and working out
  // the measure overlap
  _populateNew(voice, voiceIndex, measure, tickmap, startSelector) {
    let currentDuration = tickmap.durationMap[startSelector.tick];
    let i = 0;
    let j = 0;
    const totalDuration = tickmap.totalDuration;
    while (currentDuration < totalDuration && this.noteIndex < this.notes.length) {
      const selection = this.notes[this.noteIndex];
      const note = selection.note;
      this._populateModifier(selection.selector, startSelector, this.score.staves[selection.selector.staff]);
      if (note.isTuplet) {
        const tuplet = this.tupletNoteMap[note.tuplet.id];
        const ntuplet = SmoTuplet.cloneTuplet(tuplet);
        this.noteIndex += ntuplet.notes.length;
        startSelector.tick += ntuplet.notes.length;
        currentDuration += tuplet.tickCount;
        for (i = 0; i < ntuplet.notes.length; ++i) {
          const tn = ntuplet.notes[i];
          tn.clef = measure.clef;
          voice.notes.push(tn);
        }
        measure.tuplets.push(ntuplet);
      } else if (currentDuration + note.tickCount <= totalDuration && this.remainder === 0) {
        // The whole note fits in the measure, paste it.
        const nnote = SmoNote.clone(note);
        nnote.clef = measure.clef;
        voice.notes.push(nnote);
        currentDuration += note.tickCount;
        this.noteIndex += 1;
        startSelector.tick += 1;
      } else if (this.remainder > 0) {
        // This is a note that spilled over the last measure
        const nnote = SmoNote.cloneWithDuration(note, {
          numerator: this.remainder,
          denominator: 1,
          remainder: 0
        });
        nnote.clef = measure.clef;
        voice.notes.push(nnote);
        currentDuration += this.remainder;
        this.remainder = 0;
      } else {
        // The note won't fit, so we split it in 2 and paste the remainder in the next measure.
        // TODO:  tie the last note to this one.
        const partial = totalDuration - currentDuration;
        const dar = smoMusic.gcdMap(partial);
        for (j = 0; j < dar.length; ++j) {
          const ddd = dar[j];
          const vnote = SmoNote.cloneWithDuration(note, {
            numerator: ddd,
            denominator: 1,
            remainder: 0
          });
          voice.notes.push(vnote);
        }
        currentDuration += partial;

        // Set the remaining length of the current note, this will be added to the
        // next measure with the previous note's pitches
        this.remainder = note.tickCount - partial;
      }
    }
  }

  // ### _populatePost
  // When we paste, we replace entire measures.  Populate the last measure from the end of paste to the
  // end of the measure with notes in the existing measure.
  _populatePost(voice, voiceIndex, measure, tickmap) {
    let startTicks = PasteBuffer._countTicks(voice);
    let existingIndex = 0;
    const totalDuration = tickmap.totalDuration;
    while (startTicks < totalDuration) {
      // Find the point in the music where the paste area runs out, or as close as we can get.
      existingIndex = tickmap.durationMap.indexOf(startTicks);
      existingIndex = (existingIndex < 0) ? measure.voices[voiceIndex].notes.length - 1 : existingIndex;
      const note = measure.voices[voiceIndex].notes[existingIndex];
      if (note.isTuplet) {
        const tuplet = measure.getTupletForNote(note);
        const ntuplet = SmoTuplet.cloneTuplet(tuplet);
        startTicks += tuplet.tickCount;
        voice.notes = voice.notes.concat(ntuplet.notes);
        measure.tuplets.push(ntuplet);
        measure.removeTupletForNote(note);
      } else {
        const ticksLeft = totalDuration - startTicks;
        if (ticksLeft >= note.tickCount) {
          startTicks += note.tickCount;
          voice.notes.push(SmoNote.clone(note));
        } else {
          const remainder = totalDuration - startTicks;
          voice.notes.push(SmoNote.cloneWithDuration(note, {
            numerator: remainder,
            denominator: 1,
            remainder: 0
          }));
          startTicks = totalDuration;
        }
      }
    }
  }

  _pasteVoiceSer(ser, vobj, voiceIx) {
    const voices = [];
    let ix = 0;
    ser.voices.forEach((vc) => {
      if (ix !== voiceIx) {
        voices.push(vc);
      } else {
        voices.push(vobj);
      }
      ix += 1;
    });
    ser.voices = voices;
  }

  pasteSelections(score, selector) {
    let i = 0;
    this.destination = selector;
    if (this.notes.length < 1) {
      return;
    }
    this.noteIndex = 0;
    this.measureIndex = -1;
    this.remainder = 0;
    const voices = this._populateVoice(this.destination.voice);
    const measureSel = JSON.parse(JSON.stringify(this.destination));
    const selectors = [];
    for (i = 0; i < this.measures.length; ++i) {
      const measure = this.measures[i];
      const nvoice = voices[i];
      const ser = measure.serialize();
      // deserialize column-mapped attributes, these are not normally serialized
      // since they are mapped to measures on a delta basis.
      SmoMeasure.columnMappedAttributes.forEach((attr) => {
        if (typeof(measure[attr]) === 'string') {
          ser[attr] = measure[attr];
        } else if (typeof(measure[attr]) === 'object') {
          if (measure[attr].ctor) {
            ser[attr] = measure[attr].serialize();
          }
        }
      });
      const vobj = {
        notes: []
      };
      nvoice.notes.forEach((note) => {
        vobj.notes.push(note.serialize());
      });

      // TODO: figure out how to do this with multiple voices
      this._pasteVoiceSer(ser, vobj, this.destination.voice);
      const nmeasure = SmoMeasure.deserialize(ser);
      // If this is the non-display buffer, don't try to reset the display rectangles.
      // Q: Is this even required since we are going to re-render?
      // A: yes, because until we do, the replaced measure needs the formatting info
      if (typeof(measure.renderedBox) !== 'undefined') {
        nmeasure.renderedBox = svgHelpers.smoBox(measure.renderedBox);
        nmeasure.setBox(svgHelpers.smoBox(measure.logicalBox), 'copypaste');
        nmeasure.setX(measure.logicalBox.x, 'copyPaste');
        nmeasure.setWidth(measure.logicalBox.width, 'copypaste');
        nmeasure.setY(measure.logicalBox.y, 'copypaste');
        nmeasure.lineIndex = measure.lineIndex;
      }
      ['forceClef', 'forceKeySignature', 'forceTimeSignature', 'forceTempo'].forEach((flag) => {
        nmeasure[flag] = measure[flag];
      });
      this.score.replaceMeasure(measureSel, nmeasure);
      measureSel.measure += 1;
      selectors.push(
        { staff: selector.staff, measure: nmeasure.measureNumber.measureIndex }
      );
    }
    this.replacementMeasures = [];
    selectors.forEach((selector) => {
      this.replacementMeasures.push(SmoSelection.measureSelection(this.score, selector.staff, selector.measure));
    });
  }
}
;
VF = Vex.Flow;
Vex.Xform = (typeof(Vex.Xform) == 'undefined' ? {}
     : Vex.Xform);
VX = Vex.Xform;

// ## smoTickIterator
// This file implements over the notes in a single measure.
// This is useful when redrawing the notes to transform them into something else.
// E.g. changing the duration of a note in a measure.  It keeps track of accidentals,
// ticks used etc.
// ### Usage:
// ``javascript``
// `var iterator=new smoTickIterator(measure)
// `iterator.iterate (actor)`
// where actor is a function that is called at each tick in the voice.
//
// ### iterator format:
//   iterator: {
//      notes:[note1,note2...],
//      delta: tick value of this note
//      totalDuration: ticks up until this point
//      note: current note,
//      index: running index
//
// ### Tickmap format
// `VX.TICKMAP(measure)`
// Iterate through all notes and creates information about the notes, like
// tuplet ticks, index-to-tick map.  The tickmap is useful for finding things out like how much
// time is left in a measure at a given note index (tickIndex).
//
//     tickmap = {
//        totalDuration: 16384,
//        accidentalMap:[{'F':'#','G':'b'},....
//        durationMap:[2048,4096,..],  // A running total
//        deltaMap:[2048,2048...], a map of deltas
//        tupletMap: {
//          noteId1:
//          {startIndex:1,endIndex:3,numNotes:3,startTick:4096,endTick:8196,durations:[1365,...],smallestDuration:2048}
//
//
// ## method documentation follows
// ---
class smoTickIterator {

    constructor(measure, options) {
        this.keySignature = measure.keySignature;

        Vex.Merge(this, options);
        this.voice = typeof(options['voice']) == 'number' ? options.voice : measure.activeVoice;
        if (measure.voices.length <= this.voice) {
          console.warn('tickmap for invalid voice');
          return;
        }
        this.notes = measure.voices[this.voice].notes;
        this.index = 0;
        this.startIndex = 0;
        this.endIndex = this.notes.length;

        // so a client can tell if the iterator's been run or not
        var states = ['CREATED', 'RUNNING', 'COMPLETE'];
        this.state = 'CREATED';

        // ticks as we iterate.
        // duration is duration of the current range
        this.duration = 0;
        // duration is the accumulated duraition over all the notes
        this.totalDuration = 0;
        // delta is the tick contribution of this note
        this.delta = 0;
        // the tick start location of notes[x]
        this.durationMap = [];
        this.deltaMap = [];

        this.tupletMap = {};
        this.accidentalMap = [];
        this.durationAccidentalMap={};

        this.hasRun = false;
        this.beattime = 4096;
    }

    // empty function for a default iterator (tickmap)
    static nullActor() {}

    // ### _getAccidentalsForKey
    // Update `map` with the correct accidental based on the key signature.
    static _getAccidentalsForKey(keySignature, map) {
        var music = new VF.Music();
        var keys = music.createScaleMap(keySignature);
        var keyKeys = Object.keys(keys);
        keyKeys.forEach((keyKey) => {
            var vexKey = keys[keyKey];
            if (vexKey.length > 1 && (vexKey[1] === 'b' || vexKey[1] === '#')) {
                var pitch = {
                    letter: vexKey[0],
                    accidental: vexKey[1]
                };
                map[vexKey[0]] = {
                    duration:0,
                    pitch:pitch
                }
            }
        });
    }

	// ### updateAccidentalMap
	// Keep a running tally of the accidentals for this voice
    // based on the key and previous accidentals.
    static updateAccidentalMap(note, iterator, keySignature, accidentalMap) {
        var sigObj = {};
        var newObj = {};
        if (iterator.index === 0) {
            smoTickIterator._getAccidentalsForKey(keySignature, newObj);
            sigObj = newObj;
        } else {
            sigObj = accidentalMap[iterator.index - 1];
        }
        for (var i = 0; i < note.pitches.length; ++i) {
            if (note.noteType != 'n') {
                continue;
            }
            var pitch = note.pitches[i];
            var letter = pitch.letter.toLowerCase();
            var sigLetter = letter + pitch.accidental;
            var sigKey = smoMusic.getKeySignatureKey(letter, keySignature);

            if (sigObj && sigObj[letter]) {
                var currentVal = sigObj[letter].key + sigObj[letter].accidental;
                if (sigLetter != currentVal) {
                    newObj[letter] = {pitch:pitch,duration:iterator.duration};
                }
            } else {
                if (sigLetter != sigKey) {
                    newObj[letter] = {pitch:pitch,duration:iterator.duration};
                }
            }
        }
        accidentalMap.push(newObj);
        // Mark the accidental with the start of this note.
        iterator.durationAccidentalMap[iterator.durationMap[iterator.index]] = newObj;
    }

	// ### getActiveAccidental
	// return the active accidental for the given note
    getActiveAccidental(pitch, iteratorIndex, keySignature) {
		var defaultAccidental = smoMusic.getKeySignatureKey(pitch.letter, keySignature);
		defaultAccidental = defaultAccidental.length > 1 ? defaultAccidental[1] : 'n';
        if (iteratorIndex === 0)
            return defaultAccidental;
        var accidental = pitch.accidental.length > 0 ? pitch.accidental : 'n';
		var letter = pitch.letter;

        // Back up the accidental map until we have a match, or until we run out
        for (var i = iteratorIndex; i > 0; --i) {
            var map = this.accidentalMap[i - 1];
            var mapKeys = Object.keys(map);
            for (var j = 0; j < mapKeys.length; ++j) {
                var mapKey = mapKeys[j];
                // The letter name + accidental in the map
                var mapLetter = map[mapKey];
                var mapAcc = mapLetter.accidental ? mapLetter.accidental : 'n';

                // if the letters match and the accidental...
                if (mapLetter.pitch.letter.toLowerCase() === letter) {
                    return mapAcc;
                }
            }
        }
        return defaultAccidental;
    }

    // ### _iterate
    // Internal callback for iterator.
    _iterate(actor) {
        this.state = 'RUNNING';
        for (this.index = this.startIndex; this.index < this.endIndex; ++this.index) {
            var note = this.notes[this.index];

            // save the starting point, tickwise
            this.durationMap.push(this.totalDuration);

            // the number of ticks for this note
            this.delta = (note.ticks.numerator / note.ticks.denominator) + note.ticks.remainder;
            this.deltaMap.push(this.delta);

            if (note['tuplet'] && note.tuplet['attrs']) {
                var normalizedTicks = VF.durationToTicks(note.duration);
                if (typeof(this.tupletMap[note.tuplet.attrs.id]) == 'undefined') {
                    this.tupletMap[note.tuplet.attrs.id] = {
                        startIndex: this.index,
                        tupletIndex: 0,
                        startTick: this.totalDuration,
                        smallestDuration: normalizedTicks,
                        num_notes: note.tuplet.num_notes,
                        durations: [this.delta]
                    };
                } else {
                    var entry = this.tupletMap[note.tuplet.attrs.id];

                    entry.endIndex = this.index;
                    entry.endTick = this.totalDuration + this.delta;
                    entry.smallestDuration = ((normalizedTicks < entry.smallestDuration) ? normalizedTicks : entry.smallestDuration);
                    entry.durations.push(this.delta);
                }
            }

            // update the tick count for the current range.
            this.duration += this.delta;

            // update the tick count for the whole array/measure
            this.totalDuration += this.delta;

            smoTickIterator.updateAccidentalMap(note, this, this.keySignature, this.accidentalMap);

            var rv = actor(this, note, this.accidentalMap);
            if (rv === false) {
                break;
            }
        }
        this.state = 'COMPLETE';
    }

    // ### iterate
    // Call `actor` for each iterator tick
    iterate(actor) {
        // todo add promise
        this._iterate(actor);
    }

    // ### getTickIndex
    // get the index into notes array that takes up
    // duration of ticks */
    getTickIndex(index, duration) {
        if (index == 0)
            return 0;
        var initial = this.durationMap[index];
        var delta = 0;
        while (index < this.notes.length && delta < duration) {
            index += 1;
            delta += this.durationMap[index] - this.durationMap[index - 1];
        }
        return index;
    }
    // ### skipNext
    // skip some number of notes in the iteration, because we want to skip over them.
    skipNext(skipCount) {
        var rv = [];
        var startRange = this.index;
        // var tuplen = note.tupletStack[0].notes.length;
        var endRange = this.index + skipCount;
        rv = this.notes.slice(startRange, endRange);
        this.index = endRange;
        // this.startRange = this.index;
        return rv;
    }
}
;
// An operation works on a selection or set of selections to edit the music
class SmoOperation {

  static setForcePageBreak(score, selection, value) {
    score.staves.forEach((staff) => {
      staff.measures[selection.selector.measure].setForcePageBreak(value);
    });
  }
  static setForceSystemBreak(score, selection, value) {
    score.staves.forEach((staff) => {
      staff.measures[selection.selector.measure].setForceSystemBreak(value);
    });
  }
  static setMeasureStretch(score, selection, value) {
    score.staves.forEach((staff) => {
      const measure = staff.measures[selection.selector.measure];
      const delta = measure.customStretch;
      measure.customStretch = value;
      const nwidth = measure.staffWidth - (delta - measure.customStretch);
      measure.setWidth(nwidth);
    });
  }

  static setAutoJustify(score, selection, value) {
    score.staves.forEach((staff) => {
      staff.measures[selection.selector.measure].setAutoJustify(value);
    });
  }

  static updateProportionDefault(score, oldValue, newValue) {
    score.preferences.customProportion = newValue;
    SmoMeasure.defaults.customProportion = newValue;
    // since we are setting a default that has already been written locally, update the
    // measures.
    score.staves.forEach((staff) => {
      staff.measures.forEach((measure) => {
        if (measure.customProportion === oldValue) {
          measure.customProportion = newValue;
        }
      });
    });
  }

  static setFormattingIterations(score, selection, value) {
    score.staves.forEach((staff) => {
      staff.measures[selection.selector.measure].setFormattingIterations(value);
    });
  }

  static addKeySignature(score, selection, keySignature) {
    score.addKeySignature(selection.selector.measure, keySignature);
  }

  static deleteMeasure(score, selection) {
  var measureIndex = selection.selector.measure;

  score.deleteMeasure(measureIndex);
  }

  static addPickupMeasure(score, duration) {
    score.addPickupMeasure(0, duration);
  }

  static addConnectorDown(score,selections,parameters) {
    var msel = SmoSelection.getMeasureList(selections);
    var len = msel.length - 1;
    if (score.staves.length <= msel[len].selector.staff) {
      return;
    }
    var existing = score.getSystemGroupForStaff(msel[0]);
    if (existing && existing.endSelector.staff < selections[len].selector.staff) {
      existing.endSelector.staff = msel[len].selector.staff+1;
    } else {
      parameters.startSelector = {staff:msel[0].selector.staff,measure:msel[0].selector.measure};
      parameters.endSelector = {staff:msel[len].selector.staff + 1,measure:msel[len].selector.measure};
      score.addOrReplaceSystemGroup(new SmoSystemGroup(parameters));
    }
  }

  static convertToPickupMeasure(score, duration) {
    score.convertToPickupMeasure(0,duration);
  }
  static toggleBeamGroup(noteSelection) {
    noteSelection.note.endBeam = !(noteSelection.note.endBeam);
  }

  static padMeasureLeft(selection, padding) {
    selection.measure.padLeft = padding;
  }

  static setActiveVoice(score, voiceIx) {
    score.staves.forEach((staff) => {
      staff.measures.forEach((measure) => {
        measure.setActiveVoice(voiceIx);
      });
    });
  }

  static addRemoveMicrotone(ignore, selections, tone) {
    selections.forEach((sel) => {
      if (sel.note.tones.findIndex((tt) => tt.tone === tone.tone
        && tt.pitch === tone.pitch) >= 0) {
          sel.note.removeMicrotone(tone);
        } else {
          sel.note.addMicrotone(tone);
        }
    });
  }

  static moveStaffUpDown(score,selection,index) {
    const index1 = selection.selector.staff;
    const index2 = selection.selector.staff + index;
    if (index2 < score.staves.length && index2 >= 0) {
      score.swapStaves(index1,index2);
    }
  }

  static depopulateVoice(selection,voiceIx) {
    var ix = 0;
    var voices = [];
    var measure = selection.measure;
    measure.voices.forEach((voice) => {
      if (measure.voices.length <2 || ix != voiceIx)  {
        voices.push(voice);
      }
      ix += 1;
    });
    measure.voices = voices;

    if (measure.getActiveVoice() >= measure.voices.length) {
      measure.setActiveVoice(0);
    }
  }

  static populateVoice(selection, voiceIx) {
    selection.measure.populateVoice(voiceIx);
  }
  // ### setMeasureProportion
  // Change the softmax factor.
  static setMeasureProportion(score, selection, proportion) {
    score.staves.forEach((staff) => {
      staff.measures[selection.selector.measure].customProportion = proportion;
    });
  }
  static setTimeSignature(score, selections, timeSignature) {
    const selectors = [];
    let nm = {};
    let i = 0;
    let ticks = 0;
    selections.forEach((selection) => {
      for (i = 0; i < score.staves.length; ++i) {
        var measureSel = {
          staff: i,
          measure: selection.selector.measure
        };
        selectors.push(measureSel);
      }
    });
    const tsTicks = smoMusic.timeSignatureToTicks(timeSignature);

    selectors.forEach((selector) => {
      const params = {};
      const voices = [];
      const rowSelection = SmoSelection.measureSelection(score, selector.staff, selector.measure);
      let nm = {};
      const attrs = SmoMeasure.defaultAttributes.filter((aa) => aa !== 'timeSignature');
      const psel =  SmoSelection.measureSelection(score,selector.staff, selector.measure);
      if (!psel['measure']) {
        console.log('Error: score has changed in time signature change');
      } else {
        const proto = SmoSelection.measureSelection(score, selector.staff,selector.measure).measure;
        smoSerialize.serializedMerge(attrs, proto, params);
        params.timeSignature = timeSignature;
        nm = SmoMeasure.getDefaultMeasure(params);
        const spareNotes = SmoMeasure.getDefaultNotes(params);
        nm.setX(rowSelection.measure.staffX);
        nm.setY(rowSelection.measure.staffY);
        nm.setWidth(rowSelection.measure.staffWidth);
        ['forceKeySignature', 'forceTimeSignature', 'forceTempo', 'forceClef'].forEach((attr) => {
          nm[attr] = rowSelection.measure[attr];
        });
        ticks = 0;
        proto.voices.forEach((voice) => {
          const nvoice=[];
          for (i = 0; i < voice.notes.length; ++i) {
            const pnote = voice.notes[i];
            const nnote = SmoNote.deserialize(pnote.serialize());
            if (ticks + pnote.tickCount <= tsTicks) {
              nnote.ticks = JSON.parse(JSON.stringify(pnote.ticks))
              nvoice.push(nnote);
              ticks += nnote.tickCount;
            } else {
              const remain = (ticks + pnote.tickCount)-tsTicks;
              nnote.ticks = { numerator: remain, denominator: 1, remainder: 0};
              nvoice.push(nnote);
              ticks += nnote.tickCount;
            }
            if (ticks >= tsTicks) {
              break;
            }
          }
          if (ticks < tsTicks) {
            const adjNote = SmoNote.cloneWithDuration(nvoice[nvoice.length - 1], { numerator: tsTicks - ticks, denominator: 1, remainder: 0 });
            nvoice.push(adjNote);
          }
          voices.push({ notes: nvoice });
        });
      }
      nm.voices = voices;
      score.replaceMeasure(selector, nm);
    });
  }

  static batchSelectionOperation(score, selections, operation) {
    var measureTicks = [];
    selections.forEach((selection) => {
    var measureSel = {
      staff: selection.selector.staff,
      measure: selection.selector.measure,
      voice: selection.selector.voice
    };
    if (!measureTicks[measureSel]) {
      var tm = selection.measure.tickmapForVoice(selection.selector.voice);
      var tickOffset = tm.durationMap[selection.selector.tick];
      var selector = JSON.parse(JSON.stringify(selection.selector));
      measureTicks.push({
        selector: selector,
        tickOffset: tickOffset
      });
    }
    });
    measureTicks.forEach((measureTick) => {
      var selection = SmoSelection.measureSelection(score, measureTick.selector.staff, measureTick.selector.measure);
      var tickmap = selection.measure.tickmapForVoice(measureTick.selector.voice);
      var ix = tickmap.durationMap.indexOf(measureTick.tickOffset);
      if (ix >= 0) {
        var nsel = SmoSelection.noteSelection(score, measureTick.selector.staff, measureTick.selector.measure,
        measureTick.selector.voice, ix);
        SmoOperation[operation](nsel);
      }
    });
  }
  // ## doubleDuration
  // ## Description
  // double the duration of a note in a measure, at the expense of the following
  // note, if possible.  Works on tuplets also.
  static doubleDuration(selection) {
    var note = selection.note;
    var measure = selection.measure;
    var selector = selection.selector;
    var notes = measure.voices[selector.voice].notes;
    var tuplet = measure.getTupletForNote(note);
    if (!tuplet) {
      SmoDuration.doubleDurationNonTuplet(selection);
    } else {
      SmoDuration.doubleDurationTuplet(selection);
    }
    return true;
  }

  // ## halveDuration
  // ## Description
  // Replace the note with 2 notes of 1/2 duration, if possible
  // Works on tuplets also.
  static halveDuration(selection) {
    const note = selection.note;
    let divisor = 2;
    const measure = selection.measure;
    const tuplet = measure.getTupletForNote(note);
    if (measure.numBeats % 3 === 0 && selection.note.tickCount === 6144) {
      // special behavior, if this is dotted 1/4 in 6/8, split to 3
      divisor = 3;
    }
    if (!tuplet) {
      const nticks = note.tickCount / divisor;
      if (!smoMusic.ticksToDuration[nticks]) {
        return;
      }
      var actor = new SmoContractNoteActor({
        startIndex: selection.selector.tick,
        tickmap: measure.tickmapForVoice(selection.selector.voice),
        newTicks: nticks
      });
      SmoTickTransformer.applyTransform(measure, actor, selection.selector.voice);
      smoBeamerFactory.applyBeams(measure);
    } else {
      const startIndex = measure.tupletIndex(tuplet) + tuplet.getIndexOfNote(note);
      const actor = new SmoContractTupletActor({
        changeIndex: startIndex,
        measure,
        voice: selection.selector.voice
      });
      SmoTickTransformer.applyTransform(measure, actor, selection.selector.voice);
    }
  }

  // ## makeTuplet
  // ## Description
  // Makes a non-tuplet into a tuplet of equal value.
  static makeTuplet(selection, numNotes) {
    const note = selection.note;
    const measure = selection.measure;

    if (measure.getTupletForNote(note)) {
      return;
    }
    const nticks = note.tickCount;

    var actor = new SmoMakeTupletActor({
      index: selection.selector.tick,
      totalTicks: nticks,
      numNotes: numNotes,
      selection: selection
    });
    SmoTickTransformer.applyTransform(measure, actor,selection.selector.voice);

    return true;
  }

  static removeStaffModifier(selection, modifier) {
    selection.staff.removeStaffModifier(modifier);
  }
  static addStaffModifier(selection, modifier) {
    selection.staff.addStaffModifier(modifier);
  }
  static toggleRest(selection) {
    selection.note.toggleRest();
  }

  static makeRest(selection) {
    selection.note.makeRest();
  }
  static makeNote(selection) {
    selection.note.makeNote();
  }
  static setNoteHead(selections,noteHead) {
    selections.forEach((selection) => {
      selection.note.setNoteHead(noteHead);
    });
  }

  static addGraceNote(selection, g, offset) {
    selection.note.addGraceNote(g, offset);
  }


  static removeGraceNote(selection, offset) {
    selection.note.removeGraceNote(offset);
    selection.measure.changed= true;
  }

  static doubleGraceNoteDuration(selection,modifiers) {
    if (!Array.isArray(modifiers)) {
      modifiers=[modifiers];
    }
    modifiers.forEach((mm) => {
      mm.ticks.numerator = mm.ticks.numerator * 2;
    });
    selection.measure.changed = true;
  }
  static halveGraceNoteDuration(selection,modifiers) {
    if (!Array.isArray(modifiers)) {
        modifiers=[modifiers];
    }
    modifiers.forEach((mm) => {
        mm.ticks.numerator = mm.ticks.numerator / 2;
    });
    selection.measure.changed = true;
  }

  static toggleGraceNoteCourtesy(selection,modifiers) {
    if (!Array.isArray(modifiers)) {
      modifiers=[modifiers];
    }
    modifiers.forEach((mm) => {
      mm.modifiers.pitches.forEach((pitch)=> {
        pitch.cautionary = pitch.cautionary ? false : true;
      });
    });
  }
  static toggleGraceNoteEnharmonic(selection, modifiers, offset) {
    if (!Array.isArray(modifiers)) {
      modifiers=[modifiers];
    }
    modifiers.forEach((mm) => {
      var par = [];
      mm.pitches.forEach((pitch)=> {
        SmoNote.toggleEnharmonic(pitch);
      });
    });
  }

  static transposeGraceNotes(selection, modifiers, offset) {
    if (!Array.isArray(modifiers)) {
      modifiers=[modifiers];
    }
    modifiers.forEach((mm) => {
      var par = [];
      if (!mm) {
        console.warn('bad modifier grace note');
        return;
      }
      mm.pitches.forEach((pitch)=> {
          par.push(par.length);
      });
      SmoNote._transpose(mm, par, offset, selection.measure.keySignature);
    });
  }

  static slashGraceNotes(selections) {
    if (!Array.isArray(selections)) {
      selections=[selections];
    }
    selections.forEach((mm) => {
      if (mm.modifier && mm.modifier.ctor === 'SmoGraceNote') {
        mm.modifier.slash = !mm.modifier.slash;
      }
    });
  }


  // ## unmakeTuplet
  // ## Description
  // Makes a tuplet into a single with the duration of the whole tuplet
  static unmakeTuplet(selection) {
    var note = selection.note;
    var measure = selection.measure;
    if (!measure.getTupletForNote(note)) {
      return;
    }
    var tuplet = measure.getTupletForNote(note);
    if (tuplet === null) {
      return;
    }
    var startIndex = measure.tupletIndex(tuplet);
    var endIndex = tuplet.notes.length + startIndex - 1;

    var actor = new SmoUnmakeTupletActor({
      startIndex: startIndex,
      endIndex: endIndex,
      measure: measure
    });
    SmoTickTransformer.applyTransform(measure, actor, selection.selector.voice);
    return true;
  }

  // ## dotDuration
  // ## Description
  // Add a dot to a note, if possible, and make the note ahead of it shorter
  // to compensate.
  static dotDuration(selection) {
    var note = selection.note;
    var measure = selection.measure;
    var nticks = smoMusic.getNextDottedLevel(note.tickCount);
    if (nticks == note.tickCount) {
      return;
    }
    // Don't dot if the thing on the right of the . is too small
    var dotCount = smoMusic.smoTicksToVexDots(nticks);
    var multiplier = Math.pow(2, dotCount);
    var baseDot = VF.durationToTicks(smoMusic.closestVexDuration(nticks)) / (multiplier * 2);
    if (baseDot <= 128) {
      return;
    }
    // If this is the ultimate note in the measure, we can't increase the length
    if (selection.selector.tick + 1 === selection.measure.voices[selection.selector.voice].notes.length) {
      return;
    }
    if (selection.measure.voices[selection.selector.voice].notes[selection.selector.tick + 1].tickCount > selection.note.tickCount) {
      console.log('too long');
      return;
    }
    // is dot too short?
    if (!smoMusic.ticksToDuration[selection.measure.voices[selection.selector.voice].notes[selection.selector.tick + 1].tickCount / 2]) {
      return;
    }
    var actor = new SmoStretchNoteActor({
      startIndex: selection.selector.tick,
      tickmap: measure.tickmapForVoice(selection.selector.voice),
      newTicks: nticks
    });
    SmoTickTransformer.applyTransform(measure, actor, selection.selector.voice);
    return true;
  }

  // ## undotDuration
  // ## Description
  // Add the value of the last dot to the note, increasing length and
  // reducing the number of dots.
  static undotDuration(selection) {
    const note = selection.note;
    const measure = selection.measure;
    const nticks = smoMusic.getPreviousDottedLevel(note.tickCount);
    if (nticks == note.tickCount) {
      return;
    }
    const actor = new SmoContractNoteActor({
      startIndex: selection.selector.tick,
      tickmap: measure.tickmapForVoice(selection.selector.voice),
      newTicks: nticks
    });
    SmoTickTransformer.applyTransform(measure, actor, selection.selector.voice);
    return true;
  }

  // ## transpose
  // ## Description
  // Transpose the selected note, trying to find a key-signature friendly value
  static transpose(selection, offset) {
    let pitchIx = 0;
    let voiceIx = 0;
    let trans = false;
    let transInt = 0;
    let i = 0;
    if (typeof(selection.selector.pitches) === 'undefined') {
      selection.selector.pitches = [];
    }
    const measure = selection.measure;
    const note = selection.note;
    if (measure && note) {
      const pitchar = [];
      pitchIx = 0;
      voiceIx = 0;
      const accidentalMap = {};
      const activeTm = measure.tickmapForVoice(measure.getActiveVoice());
      const targetDuration = activeTm.durationMap[selection.selector.tick];

      note.pitches.forEach((opitch) => {
        // Only translate selected pitches
        const shouldXpose = selection.selector.pitches.length === 0 ||
          selection.selector.pitches.indexOf(pitchIx) >= 0;

        // Translate the pitch, ignoring enharmonic
        trans =  shouldXpose ? smoMusic.getKeyOffset(opitch, offset)
          : JSON.parse(JSON.stringify(opitch));
        trans = smoMusic.getEnharmonicInKey(trans, measure.keySignature);
        if (!trans.accidental) {
          trans.accidental = 'n';
        }
        transInt = smoMusic.smoPitchToInt(trans);

        // Look through the earlier notes in the measure and try
        // to find an equivalent note, and convert it if it exists.
        measure.voices.forEach((voice) => {
          for (i = 0; i < selection.selector.tick
            && i < voice.notes.length; ++i)  {
            const prevNote = voice.notes[i];
            prevNote.pitches.forEach((prevPitch) => {
                const prevInt = smoMusic.smoPitchToInt(prevPitch);
                if (prevInt === transInt) {
                  trans = JSON.parse(JSON.stringify(prevPitch));
                }
             });
           }
          });
          pitchar.push(trans);
          pitchIx += 1;
      });
      note.pitches = pitchar;
      return true;
    }
    return false;
  }

  // ## setPitch
  // ## Description:
  // pitches can be either an array, a single pitch, or a letter.  In the latter case,
  // the letter value appropriate for the key signature is used, e.g. c in A major becomes
  // c#
  static setPitch(selection, pitches) {
    let i = 0;
    var measure = selection.measure;
    var note = selection.note;
    if (typeof(note) === 'undefined') {
      console.warn('set Pitch on invalid note');
      return;
    }
    selection.note.makeNote();
    // TODO allow hint for octave
    var octave = note.pitches[0].octave;
    note.pitches = [];
    if (!Array.isArray(pitches)) {
      pitches = [pitches];
    }
    var earlierAccidental = (pitch) => {
      selection.measure.voices.forEach((voice) => {
        for (i = 0; i < selection.selector.tick
          && i < voice.notes.length; ++i) {
          var prevNote = voice.notes[i];
          if (prevNote === null || prevNote.pitches === null) {
            console.log('this will die null');
          }
          prevNote.pitches.forEach((prevPitch) => {
            if (prevNote.noteType === 'n' && prevPitch.letter === pitch.letter) {
              pitch.accidental = prevPitch.accidental;
            }
          });
        }
      });
    }
    pitches.forEach((pitch) => {
      var letter = pitch;
      if (typeof(pitch) === 'string') {
        var letter = smoMusic.getKeySignatureKey(pitch[0], measure.keySignature);
        pitch = {
          letter: letter[0],
          accidental: letter.length > 1 ? letter.substring(1) : '',
          octave: octave
        };
      }
      earlierAccidental(pitch);
      note.pitches.push(pitch);
    });
    return true;
  }

  // ## addPitch
  // add a pitch to a note chord, avoiding duplicates.
  static addPitch(selection, pitches) {
    var toAdd = [];
    selection.note.makeNote();
    pitches.forEach((pitch) => {
      var found = false;
      toAdd.forEach((np) => {
        if (np.accidental === pitch.accidental && np.letter === pitch.letter && np.octave === pitch.octave) {
          found = true;
        }
      });
      if (!found) {
        toAdd.push(pitch);
      }
    });
    toAdd.sort(function (a, b) {
      return smoMusic.smoPitchToInt(a) - smoMusic.smoPitchToInt(b);
    });
    selection.note.pitches = JSON.parse(JSON.stringify(toAdd));
  }

  static toggleCourtesyAccidental(selection) {
    var toBe = false;
    var i = 0;
    if (!selection.selector['pitches'] || selection.selector.pitches.length === 0) {
      var ps = [];
      selection.note.pitches.forEach((pitch) => {
        var p = JSON.parse(JSON.stringify(pitch));
        ps.push(p);
        p.cautionary = !(pitch.cautionary);
      });
      selection.note.pitches = ps;
    } else {
      toBe = !(selection.note.pitches[selection.selector.pitches[0]].cautionary);
    }
    SmoOperation.courtesyAccidental(selection, toBe);
  }

  static courtesyAccidental(pitchSelection, toBe) {
    pitchSelection.selector.pitches.forEach((pitchIx) => {
      pitchSelection.note.pitches[pitchIx].cautionary = toBe;
    });
  }

  static toggleEnharmonic(pitchSelection) {
    if (pitchSelection.selector.pitches.length === 0) {
      pitchSelection.selector.pitches.push(0);
    }
    const pitch = pitchSelection.note.pitches[pitchSelection.selector.pitches[0]];
    SmoNote.toggleEnharmonic(pitch);
  }

  static addDynamic(selection, dynamic) {
    selection.note.addModifier(dynamic);
  }

  static removeDynamic(selection, dynamic) {
    selection.note.removeModifier(dynamic);
  }

  static beamSelections(score, selections) {
    var start = selections[0].selector;
    var cur = selections[0].selector;
    var beamGroup = [];
    var ticks = 0;
    selections.forEach((selection) => {
      if (SmoSelector.sameNote(start, selection.selector) ||
        (SmoSelector.sameMeasure(selection.selector, cur) &&
         cur.tick === selection.selector.tick - 1)) {
        ticks += selection.note.tickCount;
        cur = selection.selector;
        beamGroup.push(selection.note);
      }
    });
    if (beamGroup.length) {
      beamGroup.forEach((note) => {
        note.beamBeats = ticks;
        note.endBeam = false;
      });
      beamGroup[beamGroup.length - 1].endBeam=true;
      // Make sure the last note of the previous beam is the end of this beam group.
      if (selections[0].selector.tick > 0) {
        const ps = JSON.parse(JSON.stringify(selections[0].selector));
        ps.tick -= 1;
        const previous = SmoSelection.noteFromSelector(score, ps);
        if (previous.note.tickCount < 4096) {
          previous.note.endBeam = true;
        }
      }
    }
  }

  static toggleBeamDirection(selections) {
    selections[0].note.toggleFlagState();
    selections.forEach((selection) => {
      selection.note.flagState = selections[0].note.flagState;
    });
  }

  static toggleOrnament(selection, ornament) {
    selection.note.toggleOrnament(ornament);
  }

  static toggleArticulation(selection, articulation) {
    selection.note.toggleArticulation(articulation);
  }

  static addEnding(score, parameters) {
    let m = 0;
    let s = 0;
    var startMeasure = parameters.startBar;
    var endMeasure = parameters.endBar;

    // Ending ID ties all the instances of an ending across staves
    parameters.endingId = VF.Element.newID();
    score.staves.forEach((staff) => {
      m = 0;
      staff.measures.forEach((measure) => {
        if (m === startMeasure) {
          const pp = JSON.parse(JSON.stringify(parameters));
          pp.startSelector = {
            staff: s,
            measure: startMeasure
          };
          pp.endSelector = {
            staff: s,
            measure: endMeasure
          };
          const ending = new SmoVolta(pp);
          measure.addNthEnding(ending);
        }
        m += 1;
      });
      s += 1;
    });
  }

  static removeEnding(score, ending) {
    let i = 0;
    score.staves.forEach((staff) => {
      for (i = ending.startSelector.measure; i <= ending.endSelector.measure; ++i) {
        staff.measures[i].removeNthEnding(ending.number);
      }
    });
  }

  static addScoreText(score,scoreText) {
    score.addScoreText(scoreText);
  }
  static removeScoreText(score,scoreText) {
    score.removeScoreText(scoreText);
  }

  static addTextGroup(score,textGroup) {
    score.addTextGroup(textGroup);
  }

  static removeTextGroup(score,textGroup) {
    score.removeTextGroup(textGroup);
  }

  static addMeasureText(score, selection, measureText) {
    const current = selection.measure.getMeasureText();
    // TODO: should we allow multiples per position
    current.forEach((mod) => {
        selection.measure.removeMeasureText(mod.attrs.id);
    });
    selection.measure.addMeasureText(measureText);
  }

  static removeMeasureText(score, selection, mt) {
    selection.measure.removeMeasureText(mt.attrs.id);
  }

  static addSystemText(score, selection, measureText) {
    const mm = selection.selector.measure;
    score.staves.forEach((staff) => {
      const mt = new SmoMeasureText(measureText.serialize());
      staff.measures[mm].addMeasureText(mt);
    });
  }

  static removeRehearsalMark(score, selection, rehearsalMark) {
    score.staves.forEach((staff) => {
      staff.removeRehearsalMark(selection.selector.measure);
    });
  }

  static addRehearsalMark(score, selection, rehearsalMark) {
    const mm = selection.selector.measure;
    score.staves.forEach((staff) => {
      const mt = new SmoRehearsalMark(rehearsalMark.serialize());
      staff.addRehearsalMark(selection.selector.measure, mt);
    });
  }

  static addLyric(score, selection, lyric) {
    selection.note.addLyric(lyric);
  }

  static removeLyric(score, selection, lyric) {
    selection.note.removeLyric(lyric);
  }

  static addTempo(score, selection, tempo) {
    score.staves.forEach((staff) => {
      staff.addTempo(tempo,selection.selector.measure);
    });
  }

  static removeTempo(score, selection) {
    score.staves.forEach((staff) => {
      staff.removeTempo();
    });
  }

  static setMeasureBarline(score, selection, barline) {
    var mm = selection.selector.measure;
    var ix = 0;
    score.staves.forEach((staff) => {
    var s2 = SmoSelection.measureSelection(score, ix, mm);
    s2.measure.setBarline(barline);
    ix += 1;
    });
  }

  static setRepeatSymbol(score, selection, sym) {
    var mm = selection.selector.measure;
    var ix = 0;
    score.staves.forEach((staff) => {
    var s2 = SmoSelection.measureSelection(score, ix, mm);
    s2.measure.setRepeatSymbol(sym);
    ix += 1;
    });
  }

  // ## interval
  // Add a pitch at the specified interval to the chord in the selection.
  static interval(selection, interval) {
    const measure = selection.measure;
    const note = selection.note;
    let pitch = {};

    // TODO: figure out which pitch is selected
    pitch = note.pitches[0];
    if (interval > 0) {
      pitch = note.pitches[note.pitches.length - 1];
    }
    pitch = smoMusic.getIntervalInKey(pitch, measure.keySignature, interval);
    if (pitch) {
      note.pitches.push(pitch);
      note.pitches.sort((x, y) =>
        smoMusic.smoPitchToInt(x) - smoMusic.smoPitchToInt(y)
      );
      return true;
    }
    return false;
  }

  static crescendo(fromSelection, toSelection) {
    const fromSelector = JSON.parse(JSON.stringify(fromSelection.selector));
    const toSelector = JSON.parse(JSON.stringify(toSelection.selector));
    const modifier = new SmoStaffHairpin({
      startSelector: fromSelector,
      endSelector: toSelector,
      hairpinType: SmoStaffHairpin.types.CRESCENDO,
      position: SmoStaffHairpin.positions.BELOW
    });
    fromSelection.staff.addStaffModifier(modifier);
    return modifier;
  }

  static decrescendo(fromSelection, toSelection) {
    const fromSelector = JSON.parse(JSON.stringify(fromSelection.selector));
    const toSelector = JSON.parse(JSON.stringify(toSelection.selector));
    const modifier = new SmoStaffHairpin({
      startSelector: fromSelector,
      endSelector: toSelector,
      hairpinType: SmoStaffHairpin.types.DECRESCENDO,
      position: SmoStaffHairpin.positions.BELOW
    });
    fromSelection.staff.addStaffModifier(modifier);
    return modifier;
  }
  static tie(fromSelection, toSelection) {
    // By default, just tie all the pitches to all the other pitches in order
    const lines = SmoTie.createLines(fromSelection.note, toSelection.note);
    const modifier = new SmoTie({
      startSelector: fromSelection.selector,
      endSelector: toSelection.selector,
      lines
    });
    fromSelection.staff.addStaffModifier(modifier);
    return modifier;
  }
  static slur(fromSelection, toSelection) {
    var fromSelector = JSON.parse(JSON.stringify(fromSelection.selector));
    var toSelector = JSON.parse(JSON.stringify(toSelection.selector));
    var modifier = new SmoSlur({
      startSelector: fromSelector,
      endSelector: toSelector,
      position: SmoStaffHairpin.positions.BELOW
    });
    fromSelection.staff.addStaffModifier(modifier);
    return modifier;
  }

  static addStaff(score, parameters) {
    score.addStaff(parameters);
  }
  static removeStaff(score, index) {
    score.removeStaff(index);
  }

  static transposeChords(smoNote,offset,key) {
    var chords = smoNote.getModifiers('SmoLyric');
    chords.forEach((ll) => {
      if (ll.parser === SmoLyric.parsers.chord) {
        var tx = ll.getText();
        // Look for something that looks like a key name
        if (tx.length >= 1 && (tx[0].toUpperCase() >= 'A'
          && tx[0].toUpperCase() <= 'G')) {
          // toffset is 2 if the key has b or # in it
          var toffset = 1;
          var newText = tx[0];
          if (tx.length > 0 && tx[1] === 'b' || tx[1] === '#') {
            newText += tx[1];
            toffset = 2;
          }
          // Transpose the key, as if it were a key signature (octave has no meaning)
          var nkey = smoMusic.smoIntToPitch(smoMusic.smoPitchToInt(
            smoMusic.vexToSmoKey(newText)) + offset);
          nkey = JSON.parse(JSON.stringify(smoMusic.getEnharmonicInKey(nkey,key)));
          newText = nkey.letter.toUpperCase();

          // new key may have different length, e.g. Bb to B natural
          if (nkey.accidental !== 'n') {
            newText += nkey.accidental;
          };
          newText += tx.substr(toffset,tx.length - toffset);
          ll.setText(newText);
        }
      }
    });
  }
  static changeInstrument(instrument, selections) {
    const measureHash = {};
    let newKey = '';
    selections.forEach((selection) => {
      if (!measureHash[selection.selector.measure]) {
        measureHash[selection.selector.measure] = 1;
        const netOffset = instrument.keyOffset - selection.measure.transposeIndex;
        newKey = smoMusic.pitchToVexKey(smoMusic.smoIntToPitch(
          smoMusic.smoPitchToInt(
            smoMusic.vexToSmoKey(selection.measure.keySignature)) + netOffset));
        newKey = smoMusic.toValidKeySignature(newKey);
        if (newKey.length > 1 && newKey[1] === 'n') {
          newKey = newKey[0];
        }
        newKey = newKey[0].toUpperCase() + newKey.substr(1, newKey.length)
        selection.measure.keySignature = newKey;
        selection.measure.clef = instrument.clef;
        selection.measure.transposeIndex = instrument.keyOffset;
        selection.measure.voices.forEach((voice) => {
          voice.notes.forEach((note) => {
            if (note.noteType === 'n') {
              const pitches = [];
              note.pitches.forEach((pitch) => {
                const pint = smoMusic.smoIntToPitch(smoMusic.smoPitchToInt(pitch) + netOffset);
                pitches.push(JSON.parse(JSON.stringify(smoMusic.getEnharmonicInKey(pint, newKey))));
              });
              note.pitches = pitches;
              SmoOperation.transposeChords(note, netOffset, newKey);
            }
            note.clef = instrument.clef;
          });
        });
      }
    });
  }

  static addMeasure(score, systemIndex, nmeasure) {
    score.addMeasure(systemIndex, nmeasure);
  }
}
;/////////////////
// # selections.js
// Editing operations are performed on selections.  A selection can be different things, from a single pitch
// to many notes.  These classes standardize some standard selection operations.
//
//
// ## SmoSelector
// ## Description:
// There are 2 parts to a selection: the actual musical bits that are selected, and the
// indices that define what was selected.  This is the latter.  The actual object does not
// have any methods so there is no constructor.
// eslint-disable-next-line no-unused-vars
class SmoSelector {
  // TODO:  tick in selector s/b tickIndex
  static sameNote(sel1, sel2) {
    return (sel1.staff === sel2.staff && sel1.measure === sel2.measure && sel1.voice === sel2.voice
       && sel1.tick === sel2.tick);
  }
  static sameMeasure(sel1, sel2) {
    return (sel1.staff === sel2.staff && sel1.measure === sel2.measure);
  }

  static sameStaff(sel1, sel2) {
    return sel1.staff === sel2.staff;
  }

  // ## return true if sel1 > sel2.
  static gt(sel1, sel2) {
    // Note: voice is not considered b/c it's more of a vertical component
    return sel1.staff > sel2.staff ||
      (sel1.staff === sel2.staff && sel1.measure > sel2.measure) ||
      (sel1.staff === sel2.staff && sel1.measure === sel2.measure && sel1.tick > sel2.tick);
  }

  static eq(sel1, sel2) {
    return (sel1.staff === sel2.staff && sel1.measure === sel2.measure && sel1.tick === sel2.tick);
  }
  static neq(sel1, sel2) {
    return !(SmoSelector.eq(sel1, sel2));
  }

  static lt(sel1, sel2) {
    return SmoSelector.gt(sel2, sel1);
  }

  static gteq(sel1, sel2) {
    return SmoSelector.gt(sel1, sel2) || SmoSelector.eq(sel1, sel2);
  }
  static lteq(sel1, sel2) {
    return SmoSelector.lt(sel1, sel2) || SmoSelector.eq(sel1, sel2);
  }

  // ### getNoteKey
  // Get a key useful for a hash map of notes.
  static getNoteKey(selector) {
    return '' + selector.staff + '-' + selector.measure + '-' + selector.voice + '-' + selector.tick;
  }

  static getMeasureKey(selector) {
    return '' + selector.staff + '-' + selector.measure;
  }

  // ## applyOffset
  // ### Description:
  // offset 'selector' the difference between src and target, return the result
  static applyOffset(src, target, selector) {
    const rv = JSON.parse(JSON.stringify(selector));
    rv.staff += target.staff - src.staff;
    rv.measure += target.measure - src.measure;
    rv.voice += target.voice - src.voice;
    rv.note += target.staff - src.staff;
    return rv;
  }

  // return true if testSel is contained in the selStart to selEnd range.
  static contains(testSel, selStart, selEnd) {
    const geStart =
      selStart.measure < testSel.measure ||
      (selStart.measure === testSel.measure && selStart.tick <= testSel.tick);
    const leEnd =
      selEnd.measure > testSel.measure ||
      (selEnd.measure === testSel.measure && testSel.tick <= selEnd.tick);

    return geStart && leEnd;
  }

  // create a hashmap key for a single note, used to organize modifiers
  static selectorNoteKey(selector) {
    return 'staff-' + selector.staff + '-measure-' + selector.measure + '-voice-' + selector.voice + '-tick-' + selector.tick;
  }
}

// ## SmoSelection
// ## Description:
// A selection is a selector and a set of references to musical elements, like measure etc.
// The staff and measure are always a part of the selection, and possible a voice and note,
// and one or more pitches.  Selections can also be made from the UI by clicking on an element
// or navigating to an element with the keyboard.
// eslint-disable-next-line no-unused-vars
class SmoSelection {
  // ### measureSelection
  // A selection that does not contain a specific note
  static measureSelection(score, staffIndex, measureIndex) {
    staffIndex = staffIndex !== null ? staffIndex : score.activeStaff;
    const selector = {
      staff: staffIndex,
      measure: measureIndex
    };
    if (score.staves.length <= staffIndex) {
      return null;
    }
    const staff = score.staves[staffIndex];
    if (staff.measures.length <= measureIndex) {
      return null;
    }
    const measure = staff.measures[measureIndex];

    return new SmoSelection({
      selector,
      _staff: staff,
      _measure: measure,
      type: 'measure'
    });
  }

  static measuresInColumn(score, staffIndex) {
    let i = 0;
    const rv = [];
    for (i = 0; i < score.staves.length; ++i) {
      rv.push(SmoSelection.measureSelection(score, i, staffIndex));
    }
    return rv;
  }

  static noteFromSelection(score, selection) {
    return SmoSelection(score, selection.staffIndex, selection.measureIndex, selection.voiceIndex, selection.tickIndex);
  }

  // ### noteSelection
  // a selection that specifies a note in the score
  static noteSelection(score, staffIndex, measureIndex, voiceIndex, tickIndex) {
    staffIndex = staffIndex != null ? staffIndex : score.activeStaff;
    measureIndex = typeof(measureIndex) !== 'undefined' ? measureIndex : 0;
    voiceIndex = typeof(voiceIndex) !== 'undefined' ? voiceIndex : 0;
    const staff = score.staves[staffIndex];
    if (!staff) {
      return null;
    }
    const measure = staff.measures[measureIndex];
    if (!measure) {
      return null;
    }
    if (measure.voices.length <= voiceIndex) {
      return null;
    }
    if (measure.voices[voiceIndex].notes.length <= tickIndex) {
      return null;
    }
    const note = measure.voices[voiceIndex].notes[tickIndex];
    const selector = {
      staff: staffIndex,
      measure: measureIndex,
      voice: voiceIndex,
      tick: tickIndex
    };
    return new SmoSelection({
      selector,
      _staff: staff,
      _measure: measure,
      _note: note,
      _pitches: [],
      type: 'note'
    });
  }

  static noteFromSelector(score, selector) {
    return SmoSelection.noteSelection(score,
      selector.staff, selector.measure, selector.voice, selector.tick);
  }

  // ### renderedNoteSelection
  // return the appropriate type of selection from the selector, based on the selector.
  static selectionFromSelector(score, selector) {
    if (typeof(selector.pitches) !== 'undefined' && selector.pitches.length) {
      return SmoSelection.pitchSelection(score,
        selector.staff, selector.measure, selector.voice, selector.tick, selector.pitch);
    }
    if (typeof(selector.tick) === 'number') {
      return SmoSelection.noteFromSelector(score, selector);
    }
    return SmoSelection.measureSelection(score, selector.staff, selector.measure);
  }

  // ### renderedNoteSelection
  // this is a special selection that we associated with all he rendered notes, so that we
  // can map from a place in the display to a place in the score.
  static renderedNoteSelection(score, nel, box) {
    let i = 0;
    let j = 0;
    let k = 0;
    let m = 0;
    const elementId = nel.getAttribute('id');
    for (i = 0; i < score.staves.length; ++i) {
      const staff = score.staves[i];
      for (j = 0; j < staff.measures.length; ++j) {
        const measure = staff.measures[j];
        for (k = 0; k < measure.voices.length; ++k) {
          const voice = measure.voices[k];
          for (m = 0; m < voice.notes.length; ++m) {
            const note = voice.notes[m];
            if (note.renderId === elementId) {
              const selector = {
                staff: i,
                measure: j,
                voice: k,
                tick: m,
                pitches: []
              };
              // var box = document.getElementById(nel.id).getBBox();
              const rv = new SmoSelection({
                selector,
                _staff: staff,
                _measure: measure,
                _note: note,
                _pitches: [],
                box,
                type: 'rendered'
              });

              return rv;
            }
          }
        }
      }
    }
    return null;
  }

  static pitchSelection(score, staffIndex, measureIndex, voiceIndex, tickIndex, pitches) {
    staffIndex = staffIndex !== null ? staffIndex : score.activeStaff;
    measureIndex = typeof(measureIndex) !== 'undefined' ? measureIndex : 0;
    voiceIndex = typeof(voiceIndex) !== 'undefined' ? voiceIndex : 0;
    const staff = score.staves[staffIndex];
    const measure = staff.measures[measureIndex];
    const note = measure.voices[voiceIndex].notes[tickIndex];
    pitches = typeof(pitches) !== 'undefined' ? pitches : [];
    const pa = [];
    pitches.forEach((ix) => {
      pa.push(JSON.parse(JSON.stringify(note.pitches[ix])));
    });
    const selector = {
      staff: staffIndex,
      measure: measureIndex,
      voice: voiceIndex,
      tick: tickIndex,
      pitches
    };
    return new SmoSelection({
      selector,
      _staff: staff,
      _measure: measure,
      _note: note,
      _pitches: pa,
      type: 'pitches'
    });
  }

  // ## nextNoteSelection
  // ## Description:
  // Return the next note in this measure, or the first note of the next measure, if it exists.
  static nextNoteSelection(score, staffIndex, measureIndex, voiceIndex, tickIndex) {
    const nextTick = tickIndex + 1;
    const nextMeasure = measureIndex + 1;
    const staff = score.staves[staffIndex];
    const measure = staff.measures[measureIndex];
    if (measure.voices[voiceIndex].notes.length > nextTick) {
      return SmoSelection.noteSelection(score, staffIndex, measureIndex, voiceIndex, nextTick);
    }
    if (staff.measures.length > nextMeasure) {
      return SmoSelection.noteSelection(score, staffIndex, nextMeasure, voiceIndex, 0);
    }
    return null;
  }

  static nextNoteSelectionFromSelector(score, selector) {
    return SmoSelection.nextNoteSelection(score, selector.staff, selector.measure, selector.voice, selector.tick);
  }
  static lastNoteSelectionFromSelector(score, selector) {
    return SmoSelection.lastNoteSelection(score, selector.staff, selector.measure, selector.voice, selector.tick);
  }

  // ### getMeasureList
  // Gets the list of measures in an array from the selections
  static getMeasureList(selections) {
    let i = 0;
    let cur = {};
    const rv = [];
    if (!selections.length) {
      return rv;
    }
    cur = selections[0].selector.measure;
    for (i = 0; i < selections.length; ++i) {
      const sel = selections[i];
      if (i === 0 || (sel.selector.measure !== cur)) {
        rv.push({
          selector: {
            staff: sel.selector.staff,
            measure: sel.selector.measure
          },
          staff: sel.staff,
          measure: sel.measure
        });
      }
      cur = sel.selector.measure;
    }
    return rv;
  }

  static lastNoteSelection(score, staffIndex, measureIndex, voiceIndex, tickIndex) {
    const lastTick = tickIndex - 1;
    const lastMeasure = measureIndex - 1;
    const staff = score.staves[staffIndex];
    let measure = staff.measures[measureIndex];
    if (tickIndex > 0) {
      return SmoSelection.noteSelection(score, staffIndex, measureIndex, voiceIndex, lastTick);
    }
    if (lastMeasure >= 0) {
      measure = staff.measures[lastMeasure];
      if (voiceIndex >= measure.voices.length) {
        return null;
      }
      const noteIndex = measure.voices[voiceIndex].notes.length - 1;
      return SmoSelection.noteSelection(score, staffIndex, lastMeasure, voiceIndex, noteIndex);
    }
    if (measureIndex === 0 && voiceIndex === 0 && tickIndex === 0) {
      return null;
    }
    return SmoSelection.noteSelection(score, staffIndex, 0, 0, 0);
  }

  // ### selectionsSameMeasure
  // Return true if the selections are all in the same measure.  Used to determine what
  // type of undo we need.
  static selectionsSameMeasure(selections) {
    let i = 0;
    if (selections.length < 2) {
      return true;
    }
    const sel1 = selections[0].selector;
    for (i = 1; i < selections.length; ++i) {
      if (!SmoSelector.sameMeasure(sel1, selections[i].selector)) {
        return false;
      }
    }
    return true;
  }

  static selectionsSameStaff(selections) {
    let i = 0;
    if (selections.length < 2) {
      return true;
    }
    const sel1 = selections[0].selector;
    for (i = 1; i < selections.length; ++i) {
      if (!SmoSelector.sameStaff(sel1, selections[i].selector)) {
        return false;
      }
    }
    return true;
  }

  constructor(params) {
    this.selector = {
      staff: 0,
      measure: 0,
      voice: 0,
      note: 0,
      pitches: []
    };
    this._staff = null;
    this._measure = null;
    this._note = null;
    this._pitches = [];
    this._box = svgHelpers.pointBox(0, 0);

    this.selectionGroup = {
      id: VF.Element.newID(),
      type: 'SmoSelection'
    };
    Vex.Merge(this, params);
  }

  get staff() {
    return this._staff;
  }
  get measure() {
    return this._measure;
  }

  get note() {
    return this._note;
  }
  get pitches() {
    if (this._pitches.length) {
      return this._pitches;
    } else if (this._note) {
      this._pitches = JSON.parse(JSON.stringify(this.note.pitches));
      return this._pitches;
    }
    return [];
  }
}
;class SmoDuration {
  static doubleDurationNonTuplet(selection) {
    var note = selection.note;
    var measure = selection.measure;
    var selector = selection.selector;
    var notes = measure.voices[selector.voice].notes;
    var tuplet = measure.getTupletForNote(note);
    var i;
    var nticks = note.tickCount * 2;
    var replNote = SmoNote.cloneWithDuration(note, nticks);
    var ticksUsed = note.tickCount;
    var newNotes = [];
    for (i = 0;i < selector.tick;++i) {
      newNotes.push(notes[i]);
    }
    for (i = selector.tick + 1;i < notes.length;++i) {
      var nnote = notes[i];
      ticksUsed += nnote.tickCount;
      if (ticksUsed >= nticks) {
        break;
      }
    }
    var remainder = ticksUsed - nticks;
    if (remainder < 0) {
      return;
    }
    newNotes.push(replNote);
    if (remainder > 0) {
      var lmap = smoMusic.gcdMap(remainder);
      lmap.forEach((duration) => {
        newNotes.push(SmoNote.cloneWithDuration(note,duration));
      });
    }

    for (i = i + 1;i<notes.length;++i) {
      newNotes.push(notes[i]);
    }
    measure.voices[selector.voice].notes = newNotes;
  }

  static doubleDurationTuplet(selection) {
    var notes = selection.measure.voices[selection.selector.voice].notes;
    var tuplet = selection.measure.getTupletForNote(selection.note);
    var measure = selection.measure
    var startIndex = selection.selector.tick - tuplet.startIndex;
    var tupletIndex = measure.tupletIndex(tuplet);

    var startLength = tuplet.notes.length;
    tuplet.combine(startIndex,startIndex + 1);
    if (tuplet.notes.length >= startLength) {
      return;
    }
    var newNotes = [];
    var i;

    for (i = 0;i < tuplet.startIndex;++i) {
      newNotes.push(notes[i]);
    }
    tuplet.notes.forEach((note) => {
      newNotes.push(note);
    });
    for (i = i+tuplet.notes.length+1;i<notes.length;++i) {
      newNotes.push(notes[i]);
    }
    measure.voices[selection.selector.voice].notes=newNotes;
  }
}
// this file contains utilities that change the duration of notes in a measure.

// ## SmoTickTransformer
//  Base class for duration transformations.  I call them transformations because this can
//  create and delete notes, as opposed to modifiers which act on existing notes.
class SmoTickTransformer {
  constructor(measure, actors, voiceIndex) {
    this.notes = measure.voices[voiceIndex].notes;
    this.measure = measure;
    this.voice = typeof(voiceIndex) === 'number' ?  voiceIndex : 0;
    this.vxNotes = [];
    this.actors = actors ? actors : [];
    this.keySignature = 'C';
    this.accidentalMap = [];
  }
  static nullActor(note) {
    return note;
  }
  // ## applyTransform
  // create a transform with the given actors and run it against the supplied measure
  static applyTransform(measure, actors, voiceIndex) {
    var actAr = (Array.isArray(actors)) ? actors : [actors];
    measure.clearBeamGroups();
      var transformer = new SmoTickTransformer(measure, actAr, voiceIndex);
      transformer.run();
      measure.voices[voiceIndex].notes = transformer.notes;
  }
  // ### transformNote
  // call the actors for each note, and put the result in the note array.
  // The note from the original array is copied and sent to each actor.
  //
  // Because the resulting array can have a different number of notes than the existing
  // array, the actors communicate with the transformer in the following, jquery-ish
  // but somewhat unintuitive way:
  //
  // 1. if the actor returns null, the next actor is called and the results of that actor are used
  // 2. if all the actors return null, the copy is used.
  // 3. if a note object is returned, that is used for the current tick and no more actors are called.
  // 4. if an array of notes is returned, it is concatenated to the existing note array and no more actors are called.
  //     Note that *return note;* and *return [note];* produce the same result.
  // 5. if an empty array [] is returned, that copy is not added to the result.  The note is effectively deleted.
  transformTick(tickmap, index,note) {
    var self = this;

    for (var i = 0; i < this.actors.length; ++i) {
    var actor=this.actors[i];
    var newNote = actor.transformTick(note, tickmap, index);
    if (newNote == null) {
      this.vxNotes.push(note); // no change
        continue;
      }
      if (Array.isArray(newNote)) {
        if (newNote.length === 0) {
          return;
        }
        this.vxNotes = this.vxNotes.concat(newNote);
        return;
      }
      this.vxNotes.push(newNote);
      return;
    }
  }

  run() {
    var self = this;
    var tickmap = this.measure.tickmapForVoice(this.voice);
    for (var i = 0; i < tickmap.durationMap.length; ++i) {
      this.transformTick(tickmap,i,this.measure.voices[this.voice].notes[i]);
    }
    this.notes = this.vxNotes;
    return this.vxNotes;
  }
}

// ## A note transformer is just a function that modifies a note in some way.
// Any number of transformers can be applied to a note.
class TickTransformBase {
  constructor() {}
  transformTick(note, tickmap, index) {
    return note;
  }
}

// ## VxContractActor
// Contract the duration of a note, filling in the space with another note
// or rest.
//
class SmoContractNoteActor extends TickTransformBase {
  constructor(params) {
    super();
    Vex.Merge(this, params);
  }
  transformTick(note, tickmap, index) {
    if (index == this.startIndex) {
      var notes = [];
      var noteCount = Math.floor(note.ticks.numerator / this.newTicks);
      var notes = [];
      var remainder = note.ticks.numerator;
      /**
       *  Replace 1 note with noteCOunt notes of newTIcks duration
       *      old map:
       *     d  .  d  .  .
       *     new map:
       *     d  d  d  .  .
       */
      for (var i = 0; i < noteCount; ++i) {
        // first note, retain modifiers so clone.  Otherwise just
        // retain pitches
        if (i === 0) {
          const nn = SmoNote.clone(note);
          nn.ticks = { numerator: this.newTicks, denominator: 1, remainder: 0 }
          notes.push(nn);
        } else {
          notes.push(new SmoNote({
            clef: note.clef,
            pitches: JSON.parse(JSON.stringify(note.pitches)),
            ticks: { numerator: this.newTicks, denominator: 1, remainder: 0},
            beamBeats: note.beamBeats
          }));
        }
        remainder = remainder - this.newTicks;
      }

      // make sure remnainder is not too short
      if (remainder > 0) {
        if (remainder < 128) {
          return null;
        }
        notes.push(new SmoNote({
          clef: note.clef,
          pitches: JSON.parse(JSON.stringify(note.pitches)),
          ticks: { numerator: remainder, denominator: 1, remainder: 0 },
          beamBeats: note.beamBeats
        }));
      }
      return notes;
    }
    return null;
  }
}

// ## VxStretchTupletActor
// Stretch a note in a tuplet, removing or shortening other notes in the tuplet
// ## Parameters:
//   {changeIndex:changeIndex, multiplier:multiplier,measure:measure}
//
class SmoStretchTupletActor extends TickTransformBase {
  constructor(params) {
    super();
    Vex.Merge(this, params);
    this.tuplet = this.measure.getTupletForNote(this.measure.notes[this.changeIndex]);
    this.oldLength = this.tuplet.notes.length;
    this.tupletIndex = this.measure.tupletIndex(this.tuplet);
    this.tuplet.combine(this.startIndex, this.endIndex);
    this.durationMap = this.tuplet.durationMap;
  }
  transformTick(note, tickmap, index) {
    /*
    ## Strategy:
    Before A, after C, leave alone
    At A, send all notes of the tuplet
    Between A+1 and C, return empty array for removed note

    5
    ---------
    | | | | |
    n n n n n
    A | B | C
     */

    if (index < this.tupletIndex)
        return note;
    if (index >= this.tupletIndex + this.oldLength)
        return note;
    if (index === this.tupletIndex) {
        return this.tuplet.notes;
    }
    return [];
  }
}

// ## VxContractActor
// Contract the duration of a note in a tuplet by duplicate
// notes of fractional length
//
class SmoContractTupletActor extends TickTransformBase {
  constructor(params) {
    super();
    Vex.Merge(this, params);
    this.tuplet = this.measure.getTupletForNote(this.measure.voices[this.voice].notes[this.changeIndex]);
    this.oldLength = this.tuplet.notes.length;
    this.tupletIndex = this.measure.tupletIndex(this.tuplet);
    this.splitIndex = this.changeIndex - this.tupletIndex;
    this.tuplet.split(this.splitIndex);
  }
  transformTick(note, tickmap, index, accidentalMap) {
    if (index < this.tupletIndex)
      return note;
    if (index >= this.tupletIndex + this.oldLength)
      return note;
    if (index == this.changeIndex) {
      return this.tuplet.notes;
    }
    return [];
  }
}

// ## VxUnmakeTupletActor
// Turn a tuplet into a non-tuplet of the same length
// ## Parameters:
// startIndex: start index of tuplet
// endIndex: end index of tuplet
// measure: Smo measure that the tuplet is contained in.
class SmoUnmakeTupletActor extends TickTransformBase {
  constructor(parameters) {
    super();
    Vex.Merge(this, parameters);
  }
  transformTick(note, tickmap, index, accidentalMap) {
    if (index < this.startIndex || index > this.endIndex) {
      return null;
    }
    if (index == this.startIndex) {
      var tuplet = this.measure.getTupletForNote(note);
      var ticks = tuplet.totalTicks;
      var nn = SmoNote.cloneWithDuration(note, { numerator: ticks, denominator: 1, remainder: 0 });
      nn.tuplet = {};
      this.measure.removeTupletForNote(note);
      return [nn];
    }
    return [];
  }
}

// ## VxUnmakeTupletActor
// Turn a tuplet into a non-tuplet of the same length
// parameters:
//  {tickmap:tickmap,ticks:ticks,
class SmoMakeTupletActor extends TickTransformBase {
  constructor(params) {
    super();
    Vex.Merge(this, params);
    this.measure = this.selection.measure;
    this.durationMap = [];
    var sum = 0.0; // 819.2
    for (var i = 0; i < this.numNotes; ++i) {
      this.durationMap.push(1.0);
      sum += 1.0;
    }
    this.stemTicks = SmoTuplet.calculateStemTicks(this.totalTicks, this.numNotes);
    this.rangeToSkip = this._rangeToSkip();
    this.vexDuration = smoMusic.ticksToDuration[this.stemTicks];
    this.tuplet = [];
  }
  _rangeToSkip() {
    var ticks = this.selection.measure.tickmapForVoice(this.selection.selector.voice);
    var accum = 0;
    var rv = [];
    rv.push(this.index);
    for (var i = 0; i < ticks.deltaMap.length; ++i) {
      if (i >= this.index) {
        accum += ticks.deltaMap[i];
      }
      if (accum >= this.totalTicks) {
        rv.push(i);
        break;
      }
    }
    return rv;
  }
  transformTick(note, tickmap, index) {
    // if our tuplet replaces this note, make sure we make it go away.
    if (index > this.index && index <= this.rangeToSkip[1]) {
      return [];
    }
    if (index !== this.index) {
      return null;
    }
    for (var i = 0; i < this.numNotes; ++i) {
      note = SmoNote.cloneWithDuration(note, { numerator: this.stemTicks, denominator: 1, remainder: 0 });
      // Don't clone modifiers, except for first one.
      note.textModifiers = i === 0 ? note.textModifiers : [];
      this.tuplet.push(note);
    }
    var tuplet = new SmoTuplet({
      notes: this.tuplet,
      stemTicks: this.stemTicks,
      totalTicks: this.totalTicks,
      ratioed: false,
      bracketed: true,
      startIndex: index,
      durationMap: this.durationMap,
      location: 1,
      voice: tickmap.voice
      });
    this.measure.tuplets.push(tuplet);
    return this.tuplet;
  }
}

class SmoStretchNoteActor extends TickTransformBase {
  constructor(parameters) {
    super();
    Vex.Merge(this, parameters);
    this.startTick = this.tickmap.durationMap[this.startIndex];
    var currentTicks = this.tickmap.deltaMap[this.startIndex];
    var endTick = this.tickmap.durationMap[this.startIndex] + this.newTicks;
    this.divisor = -1;
    this.durationMap = [];
    this.skipFromStart = this.startIndex + 1;
    this.skipFromEnd = this.startIndex + 1;
    this.durationMap.push(this.newTicks);

    var mapIx = this.tickmap.durationMap.indexOf(endTick);

    var remaining = this.tickmap.deltaMap.slice(this.startIndex, this.tickmap.durationMap.length).reduce((accum, x) => x + accum);
    if (remaining === this.newTicks) {
      mapIx = this.tickmap.deltaMap.length;
    }

    // If there is no tickable at the end point, try to split the next note
    /**
     *      old map:
     *     d  . d  .
     *     split map:
     *     d  .  d  d
     *     new map:
     *     d .   .  d
     */
    if (mapIx < 0) {
      var npos = this.tickmap.durationMap[this.startIndex + 1];
      var ndelta = this.tickmap.deltaMap[this.startIndex + 1];
      var needed = this.newTicks - currentTicks;
      var exp = ndelta / needed;
      // Next tick does not divide evenly into this, or next tick is shorter than this
      if (Math.round(ndelta/exp) - ndelta/exp !== 0 || ndelta < 256) {
        this.durationMap = [];
      }
      else if (ndelta / exp + this.startTick + this.newTicks <= this.tickmap.totalDuration) {
        this.durationMap.push(ndelta - (ndelta / exp));
      } else {
        // there is no way to do this...
        this.durationMap = [];
      }
    } else {
      // If this note now takes up the space of other notes, remove those notes
      for (var i = this.startIndex + 1; i < mapIx; ++i) {
          this.durationMap.push(0);
      }
    }
  }
  transformTick(note, tickmap, index) {
    if (this.durationMap.length == 0) {
      return null;
    }
    if (index >= this.startIndex && index < this.startIndex + this.durationMap.length) {
      var mapIndex = index - this.startIndex;
      var ticks = this.durationMap[mapIndex];
      if (ticks === 0) {
        return [];
      }
      var vexDuration = smoMusic.ticksToDuration[ticks];
      var note = SmoNote.cloneWithDuration(note, { numerator: ticks, denominator: 1, remainder: 0 });
      return [note];
    }
    return null;
  }
}
;// ## SmoToVex
// Simple serialize class that produced VEX note and voice objects
// for vex EasyScore (for easier bug reports and test cases)
// eslint-disable-next-line no-unused-vars
class SmoToVex {
  static convert(smoScore) {
    smoScore.staves.forEach((smoStaff) => {
      smoStaff.measures.forEach((smoMeasure) => {
        const voiceStrings = [];
        const lyricsHash = {};
        smoMeasure.voices.forEach((smoVoice, vix) => {
          let keyString = '';
          voiceStrings.push([]);
          smoVoice.notes.forEach((smoNote, nix) => {
            const noteId = 'v' + vix + 'n' + nix;
            const duration = smoMusic.ticksToDuration[smoMusic.closestDurationTickLtEq(smoNote.tickCount)];
            if (smoNote.pitches.length > 1) {
              keyString += '(';
            }
            smoNote.pitches.forEach((smoPitch) => {
              const pitch = { key: smoMusic.pitchToVexKey(smoPitch) };
              if (!smoMusic.isPitchInKeySignature(smoPitch, smoMeasure.keySignature)) {
                pitch.accidental = smoPitch.accidental;
              }
              keyString += smoMusic.pitchToEasyScore(smoPitch) + ' ';
              if (pitch.accidental) {
                keyString += pitch.accidental;
              }
            });
            if (smoNote.pitches.length > 1) {
              keyString += ')';
            }
            keyString +=  '/' + duration + "[id='" + noteId + "'],";
            smoNote.getTrueLyrics().forEach((lyric) => {
              if (typeof lyricsHash[noteId] === 'undefined') {
                lyricsHash[noteId] = [];
              }
              lyricsHash[noteId].push(lyric.getText());
            });
          });
          voiceStrings.push(keyString);
        });
        console.log(JSON.stringify(voiceStrings, null, ''));
        console.log(JSON.stringify(lyricsHash), null, '');
      });
    });
  }
}
;// ## UndoBuffer
// manage a set of undo or redo operations on a score.  The objects passed into
// undo must implement serialize()/deserialize()
// ### Buffer format:
// A buffer is one of 7 things:
// * A single measure,
// * A single staff
// * the whole score
// * a score modifier (text)
// * score attributes (layout, etc)
// * column - all the measures at one index
// * rectangle - a rectangle of measures
class UndoBuffer {
  static get bufferMax() {
    return 100;
  }

  static get bufferTypes() {
    return {
      FIRST: 1,
      MEASURE: 1, STAFF: 2, SCORE: 3, SCORE_MODIFIER: 4, COLUMN: 5, RECTANGLE: 6,
      SCORE_ATTRIBUTES: 7, STAFF_MODIFIER: 8, LAST: 8
    };
  }
  static get bufferSubtypes() {
    return {
      NONE: 0, ADD: 1, REMOVE: 2, UPDATE: 3
    };
  }
  static get bufferTypeLabel() {
    return ['INVALID', 'MEASURE', 'STAFF', 'SCORE', 'SCORE_MODIFIER', 'COLUMN', 'RECTANGLE',
      'SCORE_ATTRIBUTES', 'STAFF_MODIFIER'];
  }
  // ### serializeMeasure
  // serialize a measure, preserving the column-mapped bits which aren't serialized on a full score save.
  static serializeMeasure(measure) {
    const attrColumnHash = {};
    const attrCurrentValue  = {};
    const json = measure.serialize();
    measure.serializeColumnMapped(attrColumnHash, attrCurrentValue);
    Object.keys(attrCurrentValue).forEach((key) => {
      json[key] = attrCurrentValue[key];
    });
    return json;
  }
  constructor() {
    this.buffer = [];
    this.opCount = 0;
    this._grouping = false;
  }
  get grouping() {
    return this._grouping;
  }
  // Allows a set of operations to be bunched into a single group
  set grouping(val) {
    if (this._grouping === true && val === false) {
      const buf = this.peek();
      // If we have been grouping, indicate that the last buffer is the
      // fist part of a group
      if (buf) {
        buf.firstInGroup = true;
      }
    }
    this._grouping = val;
  }
  // ### addBuffer
  // Description:
  // Add the current state of the score required to undo the next operation we
  // are about to perform.  For instance, if we are adding a crescendo, we back up the
  // staff the crescendo will go on.
  addBuffer(title, type, selector, obj, subtype) {
    let i = 0;
    let j = 0;
    if (typeof(type) !== 'number' || type < UndoBuffer.bufferTypes.FIRST || type > UndoBuffer.bufferTypes.LAST) {
      throw 'Undo failure: illegal buffer type ' + type;
    }
    const undoObj = {
      title,
      type,
      selector,
      subtype,
      grouped: this._grouping,
      firstInGroup: false
    };
    if (type === UndoBuffer.bufferTypes.RECTANGLE) {
      // RECTANGLE obj is {score, topLeft, bottomRight}
      // where the last 2 are selectors
      const measures = [];
      for (i = obj.topLeft.staff; i <= obj.bottomRight.staff; ++i) {
        for (j = obj.topLeft.measure; j <= obj.bottomRight.measure; ++j) {
          measures.push(UndoBuffer.serializeMeasure(obj.score.staves[i].measures[j]));
        }
      }
      undoObj.json = { topLeft: JSON.parse(JSON.stringify(obj.topLeft)),
        bottomRight: JSON.parse(JSON.stringify(obj.bottomRight)),
        measures };
    } else if (type === UndoBuffer.bufferTypes.SCORE_ATTRIBUTES) {
      undoObj.json = {};
      smoSerialize.serializedMerge(SmoScore.preferences, obj, undoObj.json);
    } else if (type === UndoBuffer.bufferTypes.COLUMN) {
      // COLUMN obj is { score, measureIndex }
      const ix = obj.measureIndex;
      const measures = [];
      obj.score.staves.forEach((staff) => {
        measures.push(UndoBuffer.serializeMeasure(staff.measures[ix]));
      });
      undoObj.json = { measureIndex: ix, measures };
    } else if (type === UndoBuffer.bufferTypes.MEASURE) {
      // If this is a measure, preserve the column-mapped attributes
      undoObj.json = UndoBuffer.serializeMeasure(obj);
    } else if (type === UndoBuffer.bufferTypes.SCORE_MODIFIER ||
      type === UndoBuffer.bufferTypes.STAFF_MODIFIER) {
      // score modifier, already serialized
      undoObj.json = obj;
    } else {
      // staff or score or staffModifier
      undoObj.json = obj.serialize();
    }
    if (this.buffer.length >= UndoBuffer.bufferMax) {
      this.buffer.splice(0, 1);
    }
    this.opCount += 1;
    this.buffer.push(undoObj);
  }

  // ### _pop
  // ### Description:
  // Internal method to pop the top buffer off the stack.
  _pop() {
    if (this.buffer.length < 1) {
      return null;
    }
    const buf = this.buffer.pop();
    return buf;
  }

  // ## Before undoing, peek at the top action in the q
  // so it can be re-rendered
  peek() {
    if (this.buffer.length < 1) {
      return null;
    }
    return this.buffer[this.buffer.length - 1];
  }

  // ## undo
  // ## Description:
  // Undo the operation at the top of the undo stack.  This is done by replacing
  // the music as it existed before the change was made.
  undo(score) {
    let i = 0;
    let j = 0;
    let mix = 0;
    let buf = this._pop();
    if (!buf) {
      return score;
    }
    const grouping = buf.firstInGroup;
    while (buf) {
      if (buf.type === UndoBuffer.bufferTypes.RECTANGLE) {
        for (i = buf.json.topLeft.staff; i <= buf.json.bottomRight.staff; ++i) {
          for (j = buf.json.topLeft.measure; j <= buf.json.bottomRight.measure; ++j) {
            const measure = SmoMeasure.deserialize(buf.json.measures[mix]);
            mix += 1;
            score.replaceMeasure({ staff: i, measure: j }, measure);
          }
        }
      } else if (buf.type === UndoBuffer.bufferTypes.STAFF_MODIFIER)  {
        const modifier = StaffModifierBase.deserialize(buf.json);
        const staff = score.staves[modifier.startSelector.staff];
        const existing = staff.getModifier(modifier);
        if (existing) {
          staff.removeStaffModifier(existing);
        }
        // If we undo an add, we just remove it.
        if (buf.subtype !== UndoBuffer.bufferSubtypes.ADD) {
          staff.addStaffModifier(modifier);
        }
      } else if (buf.type === UndoBuffer.bufferTypes.SCORE_ATTRIBUTES) {
        smoSerialize.serializedMerge(SmoScore.preferences, buf.json, score);
      } else if (buf.type === UndoBuffer.bufferTypes.COLUMN) {
        for (i = 0; i < score.staves.length; ++i) {
          const measure = SmoMeasure.deserialize(buf.json.measures[i]);
          score.replaceMeasure({ staff: i, measure: buf.json.measureIndex }, measure);
        }
      } else if (buf.type === UndoBuffer.bufferTypes.MEASURE) {
        const measure = SmoMeasure.deserialize(buf.json);
        score.replaceMeasure(buf.selector, measure);
      } else if (buf.type === UndoBuffer.bufferTypes.SCORE) {
        // Score expects string, as deserialized score is how saving is done.
        score = SmoScore.deserialize(JSON.stringify(buf.json));
      } else if (buf.type === UndoBuffer.bufferTypes.SCORE_MODIFIER) {
        // Currently only one type like this: SmoTextGroup
        if (buf.json.ctor === 'SmoTextGroup') {
          const obj = SmoTextGroup.deserialize(buf.json);
          obj.attrs.id = buf.json.attrs.id;
          // undo of add is remove, undo of remove is add
          if (buf.subtype === UndoBuffer.bufferSubtypes.UPDATE || buf.subtype === UndoBuffer.bufferSubtypes.ADD) {
            score.removeTextGroup(obj);
          } if (buf.subtype === UndoBuffer.bufferSubtypes.UPDATE || buf.subtype === UndoBuffer.bufferSubtypes.REMOVE) {
            score.addTextGroup(obj);
          }
        }
      } else {
        const staff = SmoSystemStaff.deserialize(buf.json);
        score.replaceStaff(buf.selector.staff, staff);
      }
      if (grouping && this.peek() && this.peek().grouped) {
        buf = this._pop();
      } else {
        buf = null;
      }
    }
    return score;
  }
}

// ## SmoUndoable
// Convenience functions to save the score state before operations so we can undo the operation.
// Each undo-able knows which set of parameters the undo operation requires (measure, staff, score).
// eslint-disable-next-line no-unused-vars
class SmoUndoable {
  // ### undoScoreObject
  // Called when a score object is being modified.  There is no need to update the score as it contains a
  // reference to the object
  static changeTextGroup(score, undoBuffer, object, subtype) {
    undoBuffer.addBuffer('modify text',
      UndoBuffer.bufferTypes.SCORE_MODIFIER, null, object, subtype);
    if (subtype === UndoBuffer.bufferSubtypes.REMOVE) {
      SmoOperation.removeTextGroup(score, object);
    } else if (subtype === UndoBuffer.bufferSubtypes.ADD) {
      SmoOperation.addTextGroup(score, object);
    }
    // Update operation, there is nothing to do since the text is already
    // part of the score
  }
  // ### undoForSelections
  // We want to undo a bunch of selections.
  static undoForSelections(score, selections, undoBuffer, operation) {
    let staffUndo = false;
    let scoreUndo = false;
    let i = 0;
    if (!selections.length) {
      return;
    }
    const measure = selections[0].selector.measure;
    const staff = selections[0].selector.staff;
    for (i = 0; i < selections.length; ++i) {
      const sel = selections[i];
      if (sel.selector.measure !== measure) {
        staffUndo = true;
      } else if (sel.selector.staff !== staff) {
        scoreUndo = true;
        break;
      }
    }
    if (scoreUndo) {
      undoBuffer.addBuffer('score backup for ' + operation, UndoBuffer.bufferTypes.SCORE, null, score);
    } else if (staffUndo) {
      undoBuffer.addBuffer('staff backup for ' + operation, UndoBuffer.bufferTypes.STAFF, selections[0].selector, score);
    } else {
      undoBuffer.addBuffer('measure backup for ' + operation, UndoBuffer.bufferTypes.MEASURE, selections[0].selector, selections[0].measure);
    }
  }
  // Add the measure/staff/score that will cover this list of selections
  static batchDurationOperation(score, selections, operation, undoBuffer) {
    SmoUndoable.undoForSelections(score, selections, undoBuffer, operation);
    SmoOperation.batchSelectionOperation(score, selections, operation);
  }
  static multiSelectionOperation(score, selections, operation, parameter, undoBuffer) {
    SmoUndoable.undoForSelections(score, selections, undoBuffer, operation);
    SmoOperation[operation](score, selections, parameter);
  }
  static addConnectorDown(score, selections, parameters, undoBuffer) {
    SmoUndoable.undoForSelections(score, selections, undoBuffer, 'Add Connector Below');
    SmoOperation.addConnectorDown(score, selections, parameters);
  }
  static addGraceNote(selection, undoBuffer) {
    undoBuffer.addBuffer('grace note ' + JSON.stringify(selection.note.pitches, null, ' '),
      UndoBuffer.bufferTypes.MEASURE, selection.selector, selection.measure);
    const pitches = JSON.parse(JSON.stringify(selection.note.pitches));
    SmoOperation.addGraceNote(selection, new SmoGraceNote({ pitches, ticks:
      { numerator: 2048, denominator: 1, remainder: 0 } }));
  }
  static removeGraceNote(selection, params, undoBuffer) {
    undoBuffer.addBuffer('remove grace note',
      UndoBuffer.bufferTypes.MEASURE, selection.selector, selection.measure);
    SmoOperation.removeGraceNote(selection, params.index);
  }

  static slashGraceNotes(selections, undoBuffer) {
    undoBuffer.addBuffer('transpose grace note',
      UndoBuffer.bufferTypes.MEASURE, selections[0].selection.selector, selections[0].selection.measure);
    SmoOperation.slashGraceNotes(selections);
  }

  static transposeGraceNotes(selection, params, undoBuffer) {
    undoBuffer.addBuffer('transpose grace note',
      UndoBuffer.bufferTypes.MEASURE, selection.selector, selection.measure);
    SmoOperation.transposeGraceNotes(selection, params.modifiers, params.offset);
  }
  static setNoteHead(score, selections, noteHead, undoBuffer) {
    SmoUndoable.undoForSelections(score, selections, undoBuffer, 'note head');
    SmoOperation.setNoteHead(selections, noteHead);
  }

  static padMeasuresLeft(selections, padding, undoBuffer) {
    if (!Array.isArray(selections)) {
      selections = [selections];
    }
    selections.forEach((selection) => {
      undoBuffer.addBuffer('pad measure', UndoBuffer.bufferTypes.MEASURE, selection.selector, selection.measure);
      SmoOperation.padMeasureLeft(selection, padding);
    });
  }
  static doubleGraceNoteDuration(selection, modifier, undoBuffer) {
    undoBuffer.addBuffer('double grace note duration',
      UndoBuffer.bufferTypes.MEASURE, selection.selector, selection.measure);
    SmoOperation.doubleGraceNoteDuration(selection, modifier);
  }

  static halveGraceNoteDuration(selection, modifier, undoBuffer) {
    undoBuffer.addBuffer('halve grace note duration',
      UndoBuffer.bufferTypes.MEASURE, selection.selector, selection.measure);
    SmoOperation.halveGraceNoteDuration(selection, modifier);
  }
  static setPitch(selection, pitches, undoBuffer)  {
    undoBuffer.addBuffer('pitch change ' + JSON.stringify(pitches, null, ' '),
      UndoBuffer.bufferTypes.MEASURE, selection.selector, selection.measure);
    SmoOperation.setPitch(selection, pitches);
  }
  static addPitch(selection, pitches, undoBuffer)  {
    undoBuffer.addBuffer('pitch change ' + JSON.stringify(pitches, null, ' '),
      UndoBuffer.bufferTypes.MEASURE, selection.selector, selection.measure);
    SmoOperation.addPitch(selection, pitches);
  }
  static doubleDuration(selection, undoBuffer) {
    undoBuffer.addBuffer('double duration', UndoBuffer.bufferTypes.MEASURE, selection.selector, selection.measure);
    SmoOperation.doubleDuration(selection);
  }
  static halveDuration(selection, undoBuffer) {
    undoBuffer.addBuffer('halve note duration', UndoBuffer.bufferTypes.MEASURE, selection.selector, selection.measure);
    SmoOperation.halveDuration(selection);
  }
  static makeTuplet(selection, numNotes, undoBuffer) {
    undoBuffer.addBuffer(numNotes + '-let', UndoBuffer.bufferTypes.MEASURE, selection.selector, selection.measure);
    SmoOperation.makeTuplet(selection, numNotes);
  }
  static makeRest(selection, undoBuffer) {
    undoBuffer.addBuffer('make rest', UndoBuffer.bufferTypes.MEASURE, selection.selector, selection.measure);
    SmoOperation.makeRest(selection);
  }
  static makeNote(selection, undoBuffer) {
    undoBuffer.addBuffer('make note', UndoBuffer.bufferTypes.MEASURE, selection.selector, selection.measure);
    SmoOperation.makeNote(selection);
  }
  static unmakeTuplet(selection, undoBuffer) {
    undoBuffer.addBuffer('unmake tuplet', UndoBuffer.bufferTypes.MEASURE, selection.selector, selection.measure);
    SmoOperation.unmakeTuplet(selection);
  }
  static dotDuration(selection, undoBuffer) {
    undoBuffer.addBuffer('dot duration', UndoBuffer.bufferTypes.MEASURE, selection.selector, selection.measure);
    SmoOperation.dotDuration(selection);
  }
  static populateVoice(selections, voiceIx, undoBuffer) {
    const measures = SmoSelection.getMeasureList(selections);
    measures.forEach((selection) => {
      undoBuffer.addBuffer('populate voice', UndoBuffer.bufferTypes.MEASURE,
        selection.selector, selection.measure);
      SmoOperation.populateVoice(selection, voiceIx);
    });
  }

  static depopulateVoice(selections, voiceIx, undoBuffer) {
    var measures = SmoSelection.getMeasureList(selections);
    measures.forEach((selection) => {
      undoBuffer.addBuffer('populate voice', UndoBuffer.bufferTypes.MEASURE,
        selection.selector, selection.measure);
      SmoOperation.depopulateVoice(selection, voiceIx);
    });
  }
  static toggleBeamGroups(selections, undoBuffer) {
    var measureUndoHash = {};
    selections.forEach((selection) => {
      if (!measureUndoHash[selection.selector.measure]) {
        measureUndoHash[selection.selector.measure] = true;
        undoBuffer.addBuffer('toggleBeamGroups', UndoBuffer.bufferTypes.MEASURE, selection.selector, selection.measure);
      }
      SmoOperation.toggleBeamGroup(selection);
    });
  }
  static toggleBeamDirection(selections, undoBuffer) {
    undoBuffer.addBuffer('beam notes', UndoBuffer.bufferTypes.MEASURE, selections[0].selector, selections[0].measure);
    SmoOperation.toggleBeamDirection(selections);
  }
  static beamSelections(selections, undoBuffer) {
    undoBuffer.addBuffer('beam notes', UndoBuffer.bufferTypes.MEASURE, selections[0].selector, selections[0].measure);
    SmoOperation.beamSelections(selections);
  }
  static undotDuration(selection, undoBuffer) {
    undoBuffer.addBuffer('undot duration', UndoBuffer.bufferTypes.MEASURE, selection.selector, selection.measure);
    SmoOperation.undotDuration(selection);
  }
  static transpose(selection, offset, undoBuffer) {
    undoBuffer.addBuffer('transpose pitches ' + offset, UndoBuffer.bufferTypes.MEASURE, selection.selector, selection.measure);
    SmoOperation.transpose(selection, offset);
  }
  static courtesyAccidental(pitchSelection, toBe, undoBuffer) {
    undoBuffer.addBuffer('courtesy accidental ', UndoBuffer.bufferTypes.MEASURE, pitchSelection.selector, pitchSelection.measure);
    SmoOperation.courtesyAccidental(pitchSelection, toBe);
  }
  static addDynamic(selection, dynamic, undoBuffer) {
    undoBuffer.addBuffer('add dynamic', UndoBuffer.bufferTypes.MEASURE, selection.selector, selection.measure);
    SmoOperation.addDynamic(selection, dynamic);
  }
  static toggleEnharmonic(pitchSelection, undoBuffer) {
    undoBuffer.addBuffer('toggle enharmonic', UndoBuffer.bufferTypes.MEASURE, pitchSelection.selector, pitchSelection.measure);
    SmoOperation.toggleEnharmonic(pitchSelection);
  }
  static interval(selection, interval, undoBuffer) {
    undoBuffer.addBuffer('add interval ' + interval, UndoBuffer.bufferTypes.MEASURE, selection.selector, selection.measure);
    SmoOperation.interval(selection, interval);
  }
  static crescendo(fromSelection, toSelection, undoBuffer) {
    undoBuffer.addBuffer('crescendo', UndoBuffer.bufferTypes.STAFF, fromSelection.selector, fromSelection.staff);
    SmoOperation.crescendo(fromSelection, toSelection);
  }
  static decrescendo(fromSelection, toSelection, undoBuffer) {
    undoBuffer.addBuffer('decrescendo', UndoBuffer.bufferTypes.STAFF, fromSelection.selector, fromSelection.staff);
    SmoOperation.decrescendo(fromSelection, toSelection);
  }
  static slur(fromSelection, toSelection, undoBuffer) {
    undoBuffer.addBuffer('slur', UndoBuffer.bufferTypes.STAFF, fromSelection.selector, fromSelection.staff);
    SmoOperation.slur(fromSelection, toSelection);
  }
  // easy way to back up the score for a score-wide operation
  static noop(score, undoBuffer, label) {
    label = typeof(label) !== 'undefined' ? label : 'Backup';
    undoBuffer.addBuffer(label, UndoBuffer.bufferTypes.SCORE, null, score);
  }

  static measureSelectionOp(score, selection, op, params, undoBuffer, description) {
    undoBuffer.addBuffer(description, UndoBuffer.bufferTypes.MEASURE, selection.selector, selection.measure);
    SmoOperation[op](score, selection, params);
  }

  static staffSelectionOp(score, selection, op, params, undoBuffer, description) {
    undoBuffer.addBuffer(description, UndoBuffer.bufferTypes.STAFF, selection.selector, selection.staff);
    SmoOperation[op](selection, params);
  }

  static scoreSelectionOp(score, selection, op, params, undoBuffer, description) {
    undoBuffer.addBuffer(description, UndoBuffer.bufferTypes.SCORE, null, score);
    SmoOperation[op](score, selection, params);
  }
  static scoreOp(score, op, params, undoBuffer, description) {
    undoBuffer.addBuffer(description, UndoBuffer.bufferTypes.SCORE, null, score);
    SmoOperation[op](score, params);
  }

  static addKeySignature(score, selection, keySignature, undoBuffer) {
    undoBuffer.addBuffer('addKeySignature ' + keySignature, UndoBuffer.bufferTypes.SCORE, null, score);
    SmoOperation.addKeySignature(score, selection, keySignature);
  }
  static addMeasure(score, systemIndex, nmeasure, undoBuffer) {
    undoBuffer.addBuffer('add measure', UndoBuffer.bufferTypes.SCORE, null, score);
    SmoOperation.addMeasure(score, systemIndex, nmeasure);
  }
  static deleteMeasure(score, selection, undoBuffer) {
    undoBuffer.addBuffer('delete measure', UndoBuffer.bufferTypes.SCORE, null, score);
    const measureIndex = selection.selector.measure;
    score.deleteMeasure(measureIndex);
  }
  static addStaff(score, parameters, undoBuffer) {
    undoBuffer.addBuffer('add instrument', UndoBuffer.bufferTypes.SCORE, null, score);
    SmoOperation.addStaff(score, parameters);
  }
  static toggleGraceNoteCourtesyAccidental(selection, modifier, undoBuffer) {
    undoBuffer.addBuffer('toggle grace courtesy ', UndoBuffer.bufferTypes.MEASURE, selection.selector, selection.measure);
    SmoOperation.toggleGraceNoteCourtesy(selection, modifier);
  }
  static toggleCourtesyAccidental(selection, undoBuffer) {
    undoBuffer.addBuffer('toggle courtesy ', UndoBuffer.bufferTypes.MEASURE, selection.selector, selection.measure);
    SmoOperation.toggleCourtesyAccidental(selection);
  }
  static removeStaff(score, index, undoBuffer) {
    undoBuffer.addBuffer('remove instrument', UndoBuffer.bufferTypes.SCORE, null, score);
    SmoOperation.removeStaff(score, index);
  }
  static changeInstrument(instrument, selections, undoBuffer) {
    undoBuffer.addBuffer('changeInstrument', UndoBuffer.bufferTypes.STAFF, selections[0].selector, selections[0].staff);
    SmoOperation.changeInstrument(instrument, selections);
  }
  static pasteBuffer(score, pasteBuffer, selections, undoBuffer, operation) {
    SmoUndoable.undoForSelections(score, selections, undoBuffer, operation);
    const pasteTarget = selections[0].selector;
    pasteBuffer.pasteSelections(this.score, pasteTarget);
  }
}
;const ArialFont = {
  smufl: false,
  name: "Arial",
  spacing: 50,
  Description: 'Built-in sans-serif font',
  bold: true,
  italic: true,
  monospaced: false,
  serifs: false,
  "glyphs": {
    "0": {
      "x_min": 85,
      "x_max": 1041,
      "y_min": -25,
      "y_max": 1472,
      "ha": 1497,
      "leftSideBearing": 85,
      "advanceWidth": 1139
    },
    "1": {
      "x_min": 223,
      "x_max": 763,
      "y_min": 0,
      "y_max": 1472,
      "ha": 1472,
      "leftSideBearing": 223,
      "advanceWidth": 1139
    },
    "2": {
      "x_min": 61.840001123045234,
      "x_max": 1031,
      "y_min": 0,
      "y_max": 1472,
      "ha": 1472,
      "leftSideBearing": 61,
      "advanceWidth": 1139
    },
    "3": {
      "x_min": 86,
      "x_max": 1046,
      "y_min": -26,
      "y_max": 1472,
      "ha": 1498,
      "leftSideBearing": 86,
      "advanceWidth": 1139
    },
    "4": {
      "x_min": 26,
      "x_max": 1040,
      "y_min": 0,
      "y_max": 1466,
      "ha": 1466,
      "leftSideBearing": 26,
      "advanceWidth": 1139
    },
    "5": {
      "x_min": 85,
      "x_max": 1057,
      "y_min": -25,
      "y_max": 1446,
      "ha": 1471,
      "leftSideBearing": 85,
      "advanceWidth": 1139
    },
    "6": {
      "x_min": 77,
      "x_max": 1045,
      "y_min": -25,
      "y_max": 1472,
      "ha": 1497,
      "leftSideBearing": 77,
      "advanceWidth": 1139
    },
    "7": {
      "x_min": 97,
      "x_max": 1046,
      "y_min": 0,
      "y_max": 1447,
      "ha": 1447,
      "leftSideBearing": 97,
      "advanceWidth": 1139
    },
    "8": {
      "x_min": 83,
      "x_max": 1049,
      "y_min": -25,
      "y_max": 1472,
      "ha": 1497,
      "leftSideBearing": 83,
      "advanceWidth": 1139
    },
    "9": {
      "x_min": 85,
      "x_max": 1049,
      "y_min": -25,
      "y_max": 1472,
      "ha": 1497,
      "leftSideBearing": 85,
      "advanceWidth": 1139
    },
    " ": {
      "x_min": 0,
      "x_max": 0,
      "y_min": 0,
      "y_max": 0,
      "ha": 0,
      "leftSideBearing": 0,
      "advanceWidth": 569
    },
    "!": {
      "x_min": 176,
      "x_max": 399,
      "y_min": 0,
      "y_max": 1466,
      "ha": 1466,
      "leftSideBearing": 176,
      "advanceWidth": 569
    },
    "\"": {
      "x_min": 94,
      "x_max": 631,
      "y_min": 947,
      "y_max": 1466,
      "ha": 519,
      "leftSideBearing": 94,
      "advanceWidth": 727
    },
    "#": {
      "x_min": 21,
      "x_max": 1113,
      "y_min": -25,
      "y_max": 1491,
      "ha": 1516,
      "leftSideBearing": 21,
      "advanceWidth": 1139
    },
    "$": {
      "x_min": 73,
      "x_max": 1043,
      "y_min": -211,
      "y_max": 1601,
      "ha": 1812,
      "leftSideBearing": 73,
      "advanceWidth": 1139
    },
    "%": {
      "x_min": 119,
      "x_max": 1695,
      "y_min": -54,
      "y_max": 1491,
      "ha": 1545,
      "leftSideBearing": 119,
      "advanceWidth": 1821
    },
    "&": {
      "x_min": 88,
      "x_max": 1319,
      "y_min": -34,
      "y_max": 1491,
      "ha": 1525,
      "leftSideBearing": 88,
      "advanceWidth": 1366
    },
    "'": {
      "x_min": 90,
      "x_max": 295,
      "y_min": 947,
      "y_max": 1466,
      "ha": 519,
      "leftSideBearing": 90,
      "advanceWidth": 391
    },
    "(": {
      "x_min": 124,
      "x_max": 608,
      "y_min": -431,
      "y_max": 1491,
      "ha": 1922,
      "leftSideBearing": 124,
      "advanceWidth": 682
    },
    ")": {
      "x_min": 124,
      "x_max": 608,
      "y_min": -431,
      "y_max": 1491,
      "ha": 1922,
      "leftSideBearing": 124,
      "advanceWidth": 682
    },
    "*": {
      "x_min": 64,
      "x_max": 725,
      "y_min": 867,
      "y_max": 1491,
      "ha": 624,
      "leftSideBearing": 64,
      "advanceWidth": 797
    },
    "+": {
      "x_min": 114,
      "x_max": 1082,
      "y_min": 237,
      "y_max": 1206,
      "ha": 969,
      "leftSideBearing": 114,
      "advanceWidth": 1196
    },
    ",": {
      "x_min": 170,
      "x_max": 387,
      "y_min": -290,
      "y_max": 205,
      "ha": 495,
      "leftSideBearing": 170,
      "advanceWidth": 569
    },
    "-": {
      "x_min": 65,
      "x_max": 618,
      "y_min": 440,
      "y_max": 621,
      "ha": 181,
      "leftSideBearing": 65,
      "advanceWidth": 682
    },
    ".": {
      "x_min": 186,
      "x_max": 391,
      "y_min": 0,
      "y_max": 205,
      "ha": 205,
      "leftSideBearing": 186,
      "advanceWidth": 569
    },
    "/": {
      "x_min": 0,
      "x_max": 569,
      "y_min": -25,
      "y_max": 1491,
      "ha": 1516,
      "leftSideBearing": 0,
      "advanceWidth": 569
    },
    ":": {
      "x_min": 185,
      "x_max": 390,
      "y_min": 0,
      "y_max": 1062,
      "ha": 1062,
      "leftSideBearing": 185,
      "advanceWidth": 569
    },
    ";": {
      "x_min": 170,
      "x_max": 387,
      "y_min": -290,
      "y_max": 1062,
      "ha": 1352,
      "leftSideBearing": 170,
      "advanceWidth": 569
    },
    "<": {
      "x_min": 112,
      "x_max": 1083,
      "y_min": 226,
      "y_max": 1219,
      "ha": 993,
      "leftSideBearing": 112,
      "advanceWidth": 1196
    },
    "=": {
      "x_min": 114,
      "x_max": 1082,
      "y_min": 417,
      "y_max": 1030,
      "ha": 613,
      "leftSideBearing": 114,
      "advanceWidth": 1196
    },
    ">": {
      "x_min": 112,
      "x_max": 1083,
      "y_min": 226,
      "y_max": 1219,
      "ha": 993,
      "leftSideBearing": 112,
      "advanceWidth": 1196
    },
    "?": {
      "x_min": 90,
      "x_max": 1036,
      "y_min": 0,
      "y_max": 1491,
      "ha": 1491,
      "leftSideBearing": 90,
      "advanceWidth": 1139
    },
    "@": {
      "x_min": 111,
      "x_max": 2005,
      "y_min": -431,
      "y_max": 1493,
      "ha": 1924,
      "leftSideBearing": 111,
      "advanceWidth": 2079
    },
    "A": {
      "x_min": -3,
      "x_max": 1369,
      "y_min": 0,
      "y_max": 1466,
      "ha": 1466,
      "leftSideBearing": -3,
      "advanceWidth": 1366
    },
    "B": {
      "x_min": 150,
      "x_max": 1257,
      "y_min": 0,
      "y_max": 1466,
      "ha": 1466,
      "leftSideBearing": 150,
      "advanceWidth": 1366
    },
    "C": {
      "x_min": 102,
      "x_max": 1398,
      "y_min": -25,
      "y_max": 1491,
      "ha": 1516,
      "leftSideBearing": 102,
      "advanceWidth": 1479
    },
    "D": {
      "x_min": 158,
      "x_max": 1370,
      "y_min": 0,
      "y_max": 1466,
      "ha": 1466,
      "leftSideBearing": 158,
      "advanceWidth": 1479
    },
    "E": {
      "x_min": 162,
      "x_max": 1256,
      "y_min": 0,
      "y_max": 1466,
      "ha": 1466,
      "leftSideBearing": 162,
      "advanceWidth": 1366
    },
    "F": {
      "x_min": 168,
      "x_max": 1157,
      "y_min": 0,
      "y_max": 1466,
      "ha": 1466,
      "leftSideBearing": 168,
      "advanceWidth": 1251
    },
    "G": {
      "x_min": 109,
      "x_max": 1465,
      "y_min": -25,
      "y_max": 1491,
      "ha": 1516,
      "leftSideBearing": 109,
      "advanceWidth": 1593
    },
    "H": {
      "x_min": 164,
      "x_max": 1314,
      "y_min": 0,
      "y_max": 1466,
      "ha": 1466,
      "leftSideBearing": 164,
      "advanceWidth": 1479
    },
    "I": {
      "x_min": 191,
      "x_max": 385,
      "y_min": 0,
      "y_max": 1466,
      "ha": 1466,
      "leftSideBearing": 191,
      "advanceWidth": 569
    },
    "J": {
      "x_min": 58.84976474807333,
      "x_max": 865,
      "y_min": -25,
      "y_max": 1466,
      "ha": 1491,
      "leftSideBearing": 58,
      "advanceWidth": 1024
    },
    "K": {
      "x_min": 150,
      "x_max": 1362,
      "y_min": 0,
      "y_max": 1466,
      "ha": 1466,
      "leftSideBearing": 150,
      "advanceWidth": 1366
    },
    "L": {
      "x_min": 150,
      "x_max": 1066,
      "y_min": 0,
      "y_max": 1466,
      "ha": 1466,
      "leftSideBearing": 150,
      "advanceWidth": 1139
    },
    "M": {
      "x_min": 152,
      "x_max": 1551,
      "y_min": 0,
      "y_max": 1466,
      "ha": 1466,
      "leftSideBearing": 152,
      "advanceWidth": 1706
    },
    "N": {
      "x_min": 156,
      "x_max": 1311,
      "y_min": 0,
      "y_max": 1466,
      "ha": 1466,
      "leftSideBearing": 156,
      "advanceWidth": 1479
    },
    "O": {
      "x_min": 99,
      "x_max": 1501,
      "y_min": -25,
      "y_max": 1492,
      "ha": 1517,
      "leftSideBearing": 99,
      "advanceWidth": 1593
    },
    "P": {
      "x_min": 158,
      "x_max": 1277,
      "y_min": 0,
      "y_max": 1466,
      "ha": 1466,
      "leftSideBearing": 158,
      "advanceWidth": 1366
    },
    "Q": {
      "x_min": 88,
      "x_max": 1518,
      "y_min": -114,
      "y_max": 1492,
      "ha": 1606,
      "leftSideBearing": 88,
      "advanceWidth": 1593
    },
    "R": {
      "x_min": 161,
      "x_max": 1453,
      "y_min": 0,
      "y_max": 1466,
      "ha": 1466,
      "leftSideBearing": 161,
      "advanceWidth": 1479
    },
    "S": {
      "x_min": 92,
      "x_max": 1259,
      "y_min": -25,
      "y_max": 1491,
      "ha": 1516,
      "leftSideBearing": 92,
      "advanceWidth": 1366
    },
    "T": {
      "x_min": 48,
      "x_max": 1210,
      "y_min": 0,
      "y_max": 1466,
      "ha": 1466,
      "leftSideBearing": 48,
      "advanceWidth": 1251
    },
    "U": {
      "x_min": 161,
      "x_max": 1314,
      "y_min": -25,
      "y_max": 1466,
      "ha": 1491,
      "leftSideBearing": 161,
      "advanceWidth": 1479
    },
    "V": {
      "x_min": 9,
      "x_max": 1350,
      "y_min": 0,
      "y_max": 1466,
      "ha": 1466,
      "leftSideBearing": 9,
      "advanceWidth": 1366
    },
    "W": {
      "x_min": 25,
      "x_max": 1910,
      "y_min": 0,
      "y_max": 1466,
      "ha": 1466,
      "leftSideBearing": 25,
      "advanceWidth": 1933
    },
    "X": {
      "x_min": 9,
      "x_max": 1353,
      "y_min": 0,
      "y_max": 1466,
      "ha": 1466,
      "leftSideBearing": 9,
      "advanceWidth": 1366
    },
    "Y": {
      "x_min": 6,
      "x_max": 1350,
      "y_min": 0,
      "y_max": 1466,
      "ha": 1466,
      "leftSideBearing": 6,
      "advanceWidth": 1366
    },
    "Z": {
      "x_min": 41,
      "x_max": 1200,
      "y_min": 0,
      "y_max": 1466,
      "ha": 1466,
      "leftSideBearing": 41,
      "advanceWidth": 1251
    },
    "[": {
      "x_min": 139,
      "x_max": 536,
      "y_min": -407,
      "y_max": 1466,
      "ha": 1873,
      "leftSideBearing": 139,
      "advanceWidth": 569
    },
    "\\": {
      "x_min": 0,
      "x_max": 569,
      "y_min": -25,
      "y_max": 1491,
      "ha": 1516,
      "leftSideBearing": 0,
      "advanceWidth": 569
    },
    "]": {
      "x_min": 39,
      "x_max": 436,
      "y_min": -407,
      "y_max": 1466,
      "ha": 1873,
      "leftSideBearing": 39,
      "advanceWidth": 569
    },
    "^": {
      "x_min": 54,
      "x_max": 907,
      "y_min": 690,
      "y_max": 1491,
      "ha": 801,
      "leftSideBearing": 54,
      "advanceWidth": 961
    },
    "_": {
      "x_min": -31,
      "x_max": 1162,
      "y_min": -407,
      "y_max": -277,
      "ha": 130,
      "leftSideBearing": -31,
      "advanceWidth": 1139
    },
    "`": {
      "x_min": 89,
      "x_max": 465,
      "y_min": 1194,
      "y_max": 1474,
      "ha": 280,
      "leftSideBearing": 89,
      "advanceWidth": 682
    },
    "a": {
      "x_min": 74,
      "x_max": 1052,
      "y_min": -24,
      "y_max": 1086,
      "ha": 1110,
      "leftSideBearing": 74,
      "advanceWidth": 1139
    },
    "b": {
      "x_min": 134,
      "x_max": 1055,
      "y_min": -24,
      "y_max": 1466,
      "ha": 1490,
      "leftSideBearing": 134,
      "advanceWidth": 1139
    },
    "c": {
      "x_min": 80,
      "x_max": 1005,
      "y_min": -24,
      "y_max": 1086,
      "ha": 1110,
      "leftSideBearing": 80,
      "advanceWidth": 1024
    },
    "d": {
      "x_min": 70,
      "x_max": 991,
      "y_min": -24,
      "y_max": 1466,
      "ha": 1490,
      "leftSideBearing": 70,
      "advanceWidth": 1139
    },
    "e": {
      "x_min": 75,
      "x_max": 1054,
      "y_min": -24,
      "y_max": 1086,
      "ha": 1110,
      "leftSideBearing": 75,
      "advanceWidth": 1139
    },
    "f": {
      "x_min": 19,
      "x_max": 640,
      "y_min": 0,
      "y_max": 1491,
      "ha": 1491,
      "leftSideBearing": 19,
      "advanceWidth": 569
    },
    "g": {
      "x_min": 66,
      "x_max": 1002,
      "y_min": -431,
      "y_max": 1086,
      "ha": 1517,
      "leftSideBearing": 66,
      "advanceWidth": 1139
    },
    "h": {
      "x_min": 135,
      "x_max": 1000,
      "y_min": 0,
      "y_max": 1466,
      "ha": 1466,
      "leftSideBearing": 135,
      "advanceWidth": 1139
    },
    "i": {
      "x_min": 136,
      "x_max": 316,
      "y_min": 0,
      "y_max": 1466,
      "ha": 1466,
      "leftSideBearing": 136,
      "advanceWidth": 455
    },
    "j": {
      "x_min": -94,
      "x_max": 314,
      "y_min": -431,
      "y_max": 1466,
      "ha": 1897,
      "leftSideBearing": -94,
      "advanceWidth": 455
    },
    "k": {
      "x_min": 136,
      "x_max": 1016,
      "y_min": 0,
      "y_max": 1466,
      "ha": 1466,
      "leftSideBearing": 136,
      "advanceWidth": 1024
    },
    "l": {
      "x_min": 131,
      "x_max": 311,
      "y_min": 0,
      "y_max": 1466,
      "ha": 1466,
      "leftSideBearing": 131,
      "advanceWidth": 455
    },
    "m": {
      "x_min": 135,
      "x_max": 1574,
      "y_min": 0,
      "y_max": 1086,
      "ha": 1086,
      "leftSideBearing": 135,
      "advanceWidth": 1706
    },
    "n": {
      "x_min": 135,
      "x_max": 998,
      "y_min": 0,
      "y_max": 1086,
      "ha": 1086,
      "leftSideBearing": 135,
      "advanceWidth": 1139
    },
    "o": {
      "x_min": 68,
      "x_max": 1063,
      "y_min": -24,
      "y_max": 1086,
      "ha": 1110,
      "leftSideBearing": 68,
      "advanceWidth": 1139
    },
    "p": {
      "x_min": 135,
      "x_max": 1057,
      "y_min": -407,
      "y_max": 1086,
      "ha": 1493,
      "leftSideBearing": 135,
      "advanceWidth": 1139
    },
    "q": {
      "x_min": 72,
      "x_max": 992,
      "y_min": -407,
      "y_max": 1086,
      "ha": 1493,
      "leftSideBearing": 72,
      "advanceWidth": 1139
    },
    "r": {
      "x_min": 133,
      "x_max": 710,
      "y_min": 0,
      "y_max": 1086,
      "ha": 1086,
      "leftSideBearing": 133,
      "advanceWidth": 682
    },
    "s": {
      "x_min": 63,
      "x_max": 945,
      "y_min": -24,
      "y_max": 1086,
      "ha": 1110,
      "leftSideBearing": 63,
      "advanceWidth": 1024
    },
    "t": {
      "x_min": 36,
      "x_max": 554,
      "y_min": -14,
      "y_max": 1433,
      "ha": 1447,
      "leftSideBearing": 36,
      "advanceWidth": 569
    },
    "u": {
      "x_min": 131,
      "x_max": 992,
      "y_min": -24,
      "y_max": 1062,
      "ha": 1086,
      "leftSideBearing": 131,
      "advanceWidth": 1139
    },
    "v": {
      "x_min": 26,
      "x_max": 1000,
      "y_min": 0,
      "y_max": 1062,
      "ha": 1062,
      "leftSideBearing": 26,
      "advanceWidth": 1024
    },
    "w": {
      "x_min": 6,
      "x_max": 1463,
      "y_min": 0,
      "y_max": 1062,
      "ha": 1062,
      "leftSideBearing": 6,
      "advanceWidth": 1479
    },
    "x": {
      "x_min": 15,
      "x_max": 1009,
      "y_min": 0,
      "y_max": 1062,
      "ha": 1062,
      "leftSideBearing": 15,
      "advanceWidth": 1024
    },
    "y": {
      "x_min": 33,
      "x_max": 1006,
      "y_min": -431,
      "y_max": 1062,
      "ha": 1493,
      "leftSideBearing": 33,
      "advanceWidth": 1024
    },
    "z": {
      "x_min": 40,
      "x_max": 980,
      "y_min": 0,
      "y_max": 1062,
      "ha": 1062,
      "leftSideBearing": 40,
      "advanceWidth": 1024
    },
    "{": {
      "x_min": 57,
      "x_max": 636,
      "y_min": -431,
      "y_max": 1491,
      "ha": 1922,
      "leftSideBearing": 57,
      "advanceWidth": 684
    },
    "|": {
      "x_min": 188,
      "x_max": 345,
      "y_min": -431,
      "y_max": 1491,
      "ha": 1922,
      "leftSideBearing": 188,
      "advanceWidth": 532
    },
    "}": {
      "x_min": 47,
      "x_max": 626,
      "y_min": -431,
      "y_max": 1491,
      "ha": 1922,
      "leftSideBearing": 47,
      "advanceWidth": 684
    },
    "~": {
      "x_min": 87,
      "x_max": 1110,
      "y_min": 557,
      "y_max": 885,
      "ha": 328,
      "leftSideBearing": 87,
      "advanceWidth": 1196
    }
  },
  "fontFamily": "Arial",
  "resolution": 2048,
  "generatedOn": "2020-10-18T18:48:11.823Z"
};
;const Commissioner_MediumFont = {
  smufl: false,
  name: "CommissionerMedium",
  spacing: 50,
  fontFamily: "Commisioner",
  description: "Commisioner, a sans-serif font similar to Arial",
  serifs: true,
  monospaced: false,
  superscriptOffset: 0.66,
  subscriptOffset: 0.66,
  maxSizeGlyph: 'H',

  "glyphs": {
    "0": {
      "x_min": 102,
      "x_max": 1212,
      "y_min": -23,
      "y_max": 1400,
      "ha": 1423,
      "leftSideBearing": 102,
      "advanceWidth": 1314
    },
    "1": {
      "x_min": 56,
      "x_max": 676,
      "y_min": 0,
      "y_max": 1380,
      "ha": 1380,
      "leftSideBearing": 56,
      "advanceWidth": 874
    },
    "2": {
      "x_min": 86,
      "x_max": 1020,
      "y_min": 0,
      "y_max": 1400,
      "ha": 1400,
      "leftSideBearing": 86,
      "advanceWidth": 1120
    },
    "3": {
      "x_min": 84,
      "x_max": 1056,
      "y_min": -23,
      "y_max": 1401,
      "ha": 1424,
      "leftSideBearing": 84,
      "advanceWidth": 1150
    },
    "4": {
      "x_min": 56,
      "x_max": 1157,
      "y_min": 0,
      "y_max": 1373,
      "ha": 1373,
      "leftSideBearing": 56,
      "advanceWidth": 1209
    },
    "5": {
      "x_min": 84,
      "x_max": 1061,
      "y_min": -23,
      "y_max": 1373,
      "ha": 1396,
      "leftSideBearing": 84,
      "advanceWidth": 1155
    },
    "6": {
      "x_min": 102,
      "x_max": 1127,
      "y_min": -23,
      "y_max": 1400,
      "ha": 1423,
      "leftSideBearing": 102,
      "advanceWidth": 1221
    },
    "7": {
      "x_min": 50,
      "x_max": 998,
      "y_min": 0,
      "y_max": 1373,
      "ha": 1373,
      "leftSideBearing": 50,
      "advanceWidth": 1072
    },
    "8": {
      "x_min": 94,
      "x_max": 1128,
      "y_min": -23,
      "y_max": 1401,
      "ha": 1424,
      "leftSideBearing": 94,
      "advanceWidth": 1222
    },
    "9": {
      "x_min": 94,
      "x_max": 1119,
      "y_min": -23,
      "y_max": 1400,
      "ha": 1423,
      "leftSideBearing": 94,
      "advanceWidth": 1221
    },
    " ": {
      "x_min": 0,
      "x_max": 0,
      "y_min": 0,
      "y_max": 0,
      "ha": 0,
      "leftSideBearing": 0,
      "advanceWidth": 382
    },
    "!": {
      "x_min": 94,
      "x_max": 398,
      "y_min": -24,
      "y_max": 1472,
      "ha": 1496,
      "leftSideBearing": 94,
      "advanceWidth": 493
    },
    "\"": {
      "x_min": 78,
      "x_max": 674,
      "y_min": 846,
      "y_max": 1489,
      "ha": 643,
      "leftSideBearing": 78,
      "advanceWidth": 790
    },
    "#": {
      "x_min": 32,
      "x_max": 1344,
      "y_min": 0,
      "y_max": 1322,
      "ha": 1322,
      "leftSideBearing": 32,
      "advanceWidth": 1376
    },
    "$": {
      "x_min": 99,
      "x_max": 1060,
      "y_min": -274,
      "y_max": 1606,
      "ha": 1880,
      "leftSideBearing": 99,
      "advanceWidth": 1133
    },
    "%": {
      "x_min": 64,
      "x_max": 1732,
      "y_min": -24,
      "y_max": 1453,
      "ha": 1477,
      "leftSideBearing": 64,
      "advanceWidth": 1804
    },
    "&": {
      "x_min": 89,
      "x_max": 1465,
      "y_min": -21,
      "y_max": 1453,
      "ha": 1474,
      "leftSideBearing": 89,
      "advanceWidth": 1490
    },
    "'": {
      "x_min": 78,
      "x_max": 305,
      "y_min": 846,
      "y_max": 1489,
      "ha": 643,
      "leftSideBearing": 78,
      "advanceWidth": 421
    },
    "(": {
      "x_min": 108,
      "x_max": 718,
      "y_min": -250,
      "y_max": 1545,
      "ha": 1795,
      "leftSideBearing": 108,
      "advanceWidth": 790
    },
    ")": {
      "x_min": 72,
      "x_max": 682,
      "y_min": -250,
      "y_max": 1545,
      "ha": 1795,
      "leftSideBearing": 72,
      "advanceWidth": 790
    },
    "*": {
      "x_min": 52,
      "x_max": 908,
      "y_min": 578,
      "y_max": 1492,
      "ha": 914,
      "leftSideBearing": 52,
      "advanceWidth": 960
    },
    "+": {
      "x_min": 116,
      "x_max": 1068,
      "y_min": 113,
      "y_max": 1089,
      "ha": 976,
      "leftSideBearing": 116,
      "advanceWidth": 1184
    },
    ",": {
      "x_min": 49,
      "x_max": 379,
      "y_min": -314,
      "y_max": 279,
      "ha": 593,
      "leftSideBearing": 49,
      "advanceWidth": 474
    },
    "-": {
      "x_min": 116,
      "x_max": 732,
      "y_min": 503,
      "y_max": 691,
      "ha": 188,
      "leftSideBearing": 116,
      "advanceWidth": 848
    },
    ".": {
      "x_min": 94,
      "x_max": 398,
      "y_min": -24,
      "y_max": 272,
      "ha": 296,
      "leftSideBearing": 94,
      "advanceWidth": 493
    },
    "/": {
      "x_min": 49,
      "x_max": 848,
      "y_min": 0,
      "y_max": 1426,
      "ha": 1426,
      "leftSideBearing": 49,
      "advanceWidth": 897
    },
    ":": {
      "x_min": 94,
      "x_max": 398,
      "y_min": -24,
      "y_max": 1019,
      "ha": 1043,
      "leftSideBearing": 94,
      "advanceWidth": 493
    },
    ";": {
      "x_min": 67,
      "x_max": 398,
      "y_min": -314,
      "y_max": 1019,
      "ha": 1333,
      "leftSideBearing": 67,
      "advanceWidth": 493
    },
    "<": {
      "x_min": 116,
      "x_max": 1028,
      "y_min": 132,
      "y_max": 1068,
      "ha": 936,
      "leftSideBearing": 116,
      "advanceWidth": 1144
    },
    "=": {
      "x_min": 124,
      "x_max": 1020,
      "y_min": 277,
      "y_max": 925,
      "ha": 648,
      "leftSideBearing": 124,
      "advanceWidth": 1144
    },
    ">": {
      "x_min": 116,
      "x_max": 1028,
      "y_min": 132,
      "y_max": 1068,
      "ha": 936,
      "leftSideBearing": 116,
      "advanceWidth": 1144
    },
    "?": {
      "x_min": 76,
      "x_max": 782,
      "y_min": -24,
      "y_max": 1498,
      "ha": 1522,
      "leftSideBearing": 76,
      "advanceWidth": 872
    },
    "@": {
      "x_min": 91.72000000000001,
      "x_max": 1680.1678341637535,
      "y_min": -272,
      "y_max": 1366,
      "ha": 1638,
      "leftSideBearing": 91,
      "advanceWidth": 1772
    },
    "A": {
      "x_min": 53,
      "x_max": 1350,
      "y_min": 0,
      "y_max": 1426,
      "ha": 1426,
      "leftSideBearing": 53,
      "advanceWidth": 1401
    },
    "B": {
      "x_min": 168,
      "x_max": 1227,
      "y_min": 0,
      "y_max": 1426,
      "ha": 1426,
      "leftSideBearing": 168,
      "advanceWidth": 1303
    },
    "C": {
      "x_min": 91,
      "x_max": 1272,
      "y_min": -24,
      "y_max": 1453,
      "ha": 1477,
      "leftSideBearing": 91,
      "advanceWidth": 1369
    },
    "D": {
      "x_min": 169,
      "x_max": 1380,
      "y_min": 0,
      "y_max": 1426,
      "ha": 1426,
      "leftSideBearing": 169,
      "advanceWidth": 1471
    },
    "E": {
      "x_min": 168,
      "x_max": 1081,
      "y_min": 0,
      "y_max": 1426,
      "ha": 1426,
      "leftSideBearing": 168,
      "advanceWidth": 1189
    },
    "F": {
      "x_min": 169,
      "x_max": 1061,
      "y_min": 0,
      "y_max": 1426,
      "ha": 1426,
      "leftSideBearing": 169,
      "advanceWidth": 1150
    },
    "G": {
      "x_min": 91,
      "x_max": 1333,
      "y_min": -23,
      "y_max": 1453,
      "ha": 1476,
      "leftSideBearing": 91,
      "advanceWidth": 1463
    },
    "H": {
      "x_min": 169,
      "x_max": 1331,
      "y_min": 0,
      "y_max": 1426,
      "ha": 1426,
      "leftSideBearing": 169,
      "advanceWidth": 1500
    },
    "I": {
      "x_min": 173,
      "x_max": 412,
      "y_min": 0,
      "y_max": 1426,
      "ha": 1426,
      "leftSideBearing": 173,
      "advanceWidth": 585
    },
    "J": {
      "x_min": 21,
      "x_max": 430,
      "y_min": -314,
      "y_max": 1426,
      "ha": 1740,
      "leftSideBearing": 21,
      "advanceWidth": 603
    },
    "K": {
      "x_min": 169,
      "x_max": 1310,
      "y_min": 0,
      "y_max": 1426,
      "ha": 1426,
      "leftSideBearing": 169,
      "advanceWidth": 1362
    },
    "L": {
      "x_min": 169,
      "x_max": 1086,
      "y_min": 0,
      "y_max": 1426,
      "ha": 1426,
      "leftSideBearing": 169,
      "advanceWidth": 1150
    },
    "M": {
      "x_min": 122,
      "x_max": 1798,
      "y_min": 0,
      "y_max": 1426,
      "ha": 1426,
      "leftSideBearing": 122,
      "advanceWidth": 1920
    },
    "N": {
      "x_min": 169,
      "x_max": 1336,
      "y_min": 0,
      "y_max": 1426,
      "ha": 1426,
      "leftSideBearing": 169,
      "advanceWidth": 1505
    },
    "O": {
      "x_min": 91,
      "x_max": 1540,
      "y_min": -24,
      "y_max": 1453,
      "ha": 1477,
      "leftSideBearing": 91,
      "advanceWidth": 1632
    },
    "P": {
      "x_min": 168,
      "x_max": 1194,
      "y_min": 0,
      "y_max": 1426,
      "ha": 1426,
      "leftSideBearing": 168,
      "advanceWidth": 1271
    },
    "Q": {
      "x_min": 91,
      "x_max": 1540,
      "y_min": -341,
      "y_max": 1453,
      "ha": 1794,
      "leftSideBearing": 91,
      "advanceWidth": 1632
    },
    "R": {
      "x_min": 168,
      "x_max": 1304,
      "y_min": 0,
      "y_max": 1426,
      "ha": 1426,
      "leftSideBearing": 168,
      "advanceWidth": 1356
    },
    "S": {
      "x_min": 99,
      "x_max": 1110,
      "y_min": -23,
      "y_max": 1453,
      "ha": 1476,
      "leftSideBearing": 99,
      "advanceWidth": 1183
    },
    "T": {
      "x_min": 58,
      "x_max": 1227,
      "y_min": 0,
      "y_max": 1426,
      "ha": 1426,
      "leftSideBearing": 58,
      "advanceWidth": 1285
    },
    "U": {
      "x_min": 152,
      "x_max": 1306,
      "y_min": -24,
      "y_max": 1426,
      "ha": 1450,
      "leftSideBearing": 152,
      "advanceWidth": 1459
    },
    "V": {
      "x_min": 51,
      "x_max": 1338,
      "y_min": 0,
      "y_max": 1426,
      "ha": 1426,
      "leftSideBearing": 51,
      "advanceWidth": 1390
    },
    "W": {
      "x_min": 50,
      "x_max": 2010,
      "y_min": 0,
      "y_max": 1426,
      "ha": 1426,
      "leftSideBearing": 50,
      "advanceWidth": 2060
    },
    "X": {
      "x_min": 64,
      "x_max": 1316,
      "y_min": 0,
      "y_max": 1426,
      "ha": 1426,
      "leftSideBearing": 64,
      "advanceWidth": 1380
    },
    "Y": {
      "x_min": 50,
      "x_max": 1278,
      "y_min": 0,
      "y_max": 1426,
      "ha": 1426,
      "leftSideBearing": 50,
      "advanceWidth": 1325
    },
    "Z": {
      "x_min": 90,
      "x_max": 1258,
      "y_min": 0,
      "y_max": 1426,
      "ha": 1426,
      "leftSideBearing": 90,
      "advanceWidth": 1354
    },
    "[": {
      "x_min": 177,
      "x_max": 733,
      "y_min": -238,
      "y_max": 1538,
      "ha": 1776,
      "leftSideBearing": 177,
      "advanceWidth": 770
    },
    "\\": {
      "x_min": 49,
      "x_max": 848,
      "y_min": 0,
      "y_max": 1426,
      "ha": 1426,
      "leftSideBearing": 49,
      "advanceWidth": 897
    },
    "]": {
      "x_min": 37,
      "x_max": 593,
      "y_min": -238,
      "y_max": 1538,
      "ha": 1776,
      "leftSideBearing": 37,
      "advanceWidth": 770
    },
    "^": {
      "x_min": 112,
      "x_max": 1122,
      "y_min": 744,
      "y_max": 1373,
      "ha": 629,
      "leftSideBearing": 112,
      "advanceWidth": 1234
    },
    "_": {
      "x_min": -20,
      "x_max": 844,
      "y_min": -272,
      "y_max": -96,
      "ha": 176,
      "leftSideBearing": -20,
      "advanceWidth": 824
    },
    "`": {
      "x_min": 272,
      "x_max": 765,
      "y_min": 1146,
      "y_max": 1556,
      "ha": 410,
      "leftSideBearing": 272,
      "advanceWidth": 1200
    },
    "a": {
      "x_min": 94,
      "x_max": 922,
      "y_min": -21,
      "y_max": 1018,
      "ha": 1039,
      "leftSideBearing": 94,
      "advanceWidth": 1053
    },
    "b": {
      "x_min": 154,
      "x_max": 1093,
      "y_min": -24,
      "y_max": 1487,
      "ha": 1511,
      "leftSideBearing": 154,
      "advanceWidth": 1184
    },
    "c": {
      "x_min": 89,
      "x_max": 900,
      "y_min": -20,
      "y_max": 1018,
      "ha": 1038,
      "leftSideBearing": 89,
      "advanceWidth": 982
    },
    "d": {
      "x_min": 90,
      "x_max": 1030,
      "y_min": -24,
      "y_max": 1487,
      "ha": 1511,
      "leftSideBearing": 90,
      "advanceWidth": 1161
    },
    "e": {
      "x_min": 89,
      "x_max": 972,
      "y_min": -23,
      "y_max": 1018,
      "ha": 1041,
      "leftSideBearing": 89,
      "advanceWidth": 1054
    },
    "f": {
      "x_min": 44,
      "x_max": 794,
      "y_min": 0,
      "y_max": 1492,
      "ha": 1492,
      "leftSideBearing": 44,
      "advanceWidth": 801
    },
    "g": {
      "x_min": 85,
      "x_max": 1050,
      "y_min": -407,
      "y_max": 1018,
      "ha": 1425,
      "leftSideBearing": 85,
      "advanceWidth": 1089
    },
    "h": {
      "x_min": 154,
      "x_max": 1018,
      "y_min": 0,
      "y_max": 1487,
      "ha": 1487,
      "leftSideBearing": 154,
      "advanceWidth": 1150
    },
    "i": {
      "x_min": 119,
      "x_max": 408,
      "y_min": 0,
      "y_max": 1472,
      "ha": 1472,
      "leftSideBearing": 119,
      "advanceWidth": 530
    },
    "j": {
      "x_min": 0,
      "x_max": 409,
      "y_min": -391,
      "y_max": 1472,
      "ha": 1863,
      "leftSideBearing": 0,
      "advanceWidth": 526
    },
    "k": {
      "x_min": 154,
      "x_max": 1075,
      "y_min": 0,
      "y_max": 1487,
      "ha": 1487,
      "leftSideBearing": 154,
      "advanceWidth": 1108
    },
    "l": {
      "x_min": 154,
      "x_max": 368,
      "y_min": 0,
      "y_max": 1487,
      "ha": 1487,
      "leftSideBearing": 154,
      "advanceWidth": 522
    },
    "m": {
      "x_min": 154,
      "x_max": 1613,
      "y_min": 0,
      "y_max": 1019,
      "ha": 1019,
      "leftSideBearing": 154,
      "advanceWidth": 1745
    },
    "n": {
      "x_min": 154,
      "x_max": 1018,
      "y_min": 0,
      "y_max": 1019,
      "ha": 1019,
      "leftSideBearing": 154,
      "advanceWidth": 1150
    },
    "o": {
      "x_min": 89,
      "x_max": 1106,
      "y_min": -24,
      "y_max": 1019,
      "ha": 1043,
      "leftSideBearing": 89,
      "advanceWidth": 1195
    },
    "p": {
      "x_min": 154,
      "x_max": 1093,
      "y_min": -391,
      "y_max": 1019,
      "ha": 1410,
      "leftSideBearing": 154,
      "advanceWidth": 1184
    },
    "q": {
      "x_min": 90,
      "x_max": 1030,
      "y_min": -391,
      "y_max": 1019,
      "ha": 1410,
      "leftSideBearing": 90,
      "advanceWidth": 1172
    },
    "r": {
      "x_min": 154,
      "x_max": 766,
      "y_min": 0,
      "y_max": 1019,
      "ha": 1019,
      "leftSideBearing": 154,
      "advanceWidth": 808
    },
    "s": {
      "x_min": 104,
      "x_max": 839,
      "y_min": -23,
      "y_max": 1018,
      "ha": 1041,
      "leftSideBearing": 104,
      "advanceWidth": 918
    },
    "t": {
      "x_min": 44,
      "x_max": 774,
      "y_min": -24,
      "y_max": 1359,
      "ha": 1383,
      "leftSideBearing": 44,
      "advanceWidth": 829
    },
    "u": {
      "x_min": 132,
      "x_max": 990,
      "y_min": -24,
      "y_max": 1002,
      "ha": 1026,
      "leftSideBearing": 132,
      "advanceWidth": 1126
    },
    "v": {
      "x_min": 42,
      "x_max": 1006,
      "y_min": 0,
      "y_max": 1002,
      "ha": 1002,
      "leftSideBearing": 42,
      "advanceWidth": 1048
    },
    "w": {
      "x_min": 42,
      "x_max": 1581,
      "y_min": 0,
      "y_max": 1002,
      "ha": 1002,
      "leftSideBearing": 42,
      "advanceWidth": 1623
    },
    "x": {
      "x_min": 51,
      "x_max": 1043,
      "y_min": 0,
      "y_max": 1002,
      "ha": 1002,
      "leftSideBearing": 51,
      "advanceWidth": 1090
    },
    "y": {
      "x_min": 42,
      "x_max": 1016,
      "y_min": -391,
      "y_max": 1002,
      "ha": 1393,
      "leftSideBearing": 42,
      "advanceWidth": 1058
    },
    "z": {
      "x_min": 72,
      "x_max": 940,
      "y_min": 0,
      "y_max": 994,
      "ha": 994,
      "leftSideBearing": 72,
      "advanceWidth": 1007
    },
    "{": {
      "x_min": 28,
      "x_max": 802,
      "y_min": -238,
      "y_max": 1538,
      "ha": 1776,
      "leftSideBearing": 28,
      "advanceWidth": 838
    },
    "|": {
      "x_min": 177,
      "x_max": 365,
      "y_min": -316,
      "y_max": 1564,
      "ha": 1880,
      "leftSideBearing": 177,
      "advanceWidth": 542
    },
    "}": {
      "x_min": 36,
      "x_max": 810,
      "y_min": -238,
      "y_max": 1538,
      "ha": 1776,
      "leftSideBearing": 36,
      "advanceWidth": 838
    },
    "~": {
      "x_min": 116,
      "x_max": 1028,
      "y_min": 431,
      "y_max": 774,
      "ha": 343,
      "leftSideBearing": 116,
      "advanceWidth": 1144
    }
  },
  "resolution": 2000,
  "generatedOn": "2020-10-16T17:54:48.712Z"
};
;const Concert_OneFont = {
  smufl: false,
  name: "ConcertOne",
  spacing: 50,
  fontFamily: "ConcertOne",
  description: "Concert One, a sans-serif rounded title font",
  serifs: true,
  monospaced: false,
  superscriptOffset: 0.66,
  subscriptOffset: 0.66,
  maxSizeGlyph: 'H',
  "glyphs": {
    "0": {
      "x_min": 102,
      "x_max": 1016,
      "y_min": -8,
      "y_max": 1408,
      "ha": 1416,
      "leftSideBearing": 102,
      "advanceWidth": 1118
    },
    "1": {
      "x_min": 58,
      "x_max": 664,
      "y_min": 0,
      "y_max": 1400,
      "ha": 1400,
      "leftSideBearing": 58,
      "advanceWidth": 786
    },
    "2": {
      "x_min": 100,
      "x_max": 1022,
      "y_min": 0,
      "y_max": 1408,
      "ha": 1408,
      "leftSideBearing": 100,
      "advanceWidth": 1060
    },
    "3": {
      "x_min": 54,
      "x_max": 946,
      "y_min": -8,
      "y_max": 1400,
      "ha": 1408,
      "leftSideBearing": 54,
      "advanceWidth": 1026
    },
    "4": {
      "x_min": 74,
      "x_max": 906,
      "y_min": 0,
      "y_max": 1400,
      "ha": 1400,
      "leftSideBearing": 74,
      "advanceWidth": 1002
    },
    "5": {
      "x_min": 76,
      "x_max": 968,
      "y_min": -8,
      "y_max": 1400,
      "ha": 1408,
      "leftSideBearing": 76,
      "advanceWidth": 1026
    },
    "6": {
      "x_min": 122,
      "x_max": 948,
      "y_min": -8,
      "y_max": 1400,
      "ha": 1408,
      "leftSideBearing": 122,
      "advanceWidth": 992
    },
    "7": {
      "x_min": 48,
      "x_max": 966,
      "y_min": 0,
      "y_max": 1400,
      "ha": 1400,
      "leftSideBearing": 48,
      "advanceWidth": 1012
    },
    "8": {
      "x_min": 90,
      "x_max": 930,
      "y_min": -8,
      "y_max": 1408,
      "ha": 1416,
      "leftSideBearing": 90,
      "advanceWidth": 1020
    },
    "9": {
      "x_min": 46,
      "x_max": 870,
      "y_min": 0,
      "y_max": 1408,
      "ha": 1408,
      "leftSideBearing": 46,
      "advanceWidth": 992
    },
    " ": {
      "x_min": 0,
      "x_max": 0,
      "y_min": 0,
      "y_max": 0,
      "ha": 0,
      "leftSideBearing": 0,
      "advanceWidth": 798
    },
    "!": {
      "x_min": 226,
      "x_max": 556,
      "y_min": -2,
      "y_max": 1398,
      "ha": 1400,
      "leftSideBearing": 226,
      "advanceWidth": 808
    },
    "\"": {
      "x_min": 110,
      "x_max": 766,
      "y_min": 904,
      "y_max": 1404,
      "ha": 500,
      "leftSideBearing": 110,
      "advanceWidth": 898
    },
    "#": {
      "x_min": 118,
      "x_max": 1170,
      "y_min": 160,
      "y_max": 1222,
      "ha": 1062,
      "leftSideBearing": 118,
      "advanceWidth": 1268
    },
    "$": {
      "x_min": 142,
      "x_max": 904,
      "y_min": 6,
      "y_max": 1384,
      "ha": 1378,
      "leftSideBearing": 142,
      "advanceWidth": 1052
    },
    "%": {
      "x_min": 98,
      "x_max": 1384,
      "y_min": -6,
      "y_max": 1400,
      "ha": 1406,
      "leftSideBearing": 98,
      "advanceWidth": 1484
    },
    "&": {
      "x_min": 104,
      "x_max": 1178,
      "y_min": -2,
      "y_max": 1408,
      "ha": 1410,
      "leftSideBearing": 104,
      "advanceWidth": 1296
    },
    "'": {
      "x_min": 130,
      "x_max": 374,
      "y_min": 904,
      "y_max": 1404,
      "ha": 500,
      "leftSideBearing": 130,
      "advanceWidth": 522
    },
    "(": {
      "x_min": 240,
      "x_max": 814,
      "y_min": -158,
      "y_max": 1562,
      "ha": 1720,
      "leftSideBearing": 240,
      "advanceWidth": 888
    },
    ")": {
      "x_min": 74,
      "x_max": 648,
      "y_min": -158,
      "y_max": 1562,
      "ha": 1720,
      "leftSideBearing": 74,
      "advanceWidth": 888
    },
    "*": {
      "x_min": 110,
      "x_max": 1084,
      "y_min": 164,
      "y_max": 1260,
      "ha": 1096,
      "leftSideBearing": 110,
      "advanceWidth": 1194
    },
    "+": {
      "x_min": 190,
      "x_max": 920,
      "y_min": 356,
      "y_max": 1086,
      "ha": 730,
      "leftSideBearing": 190,
      "advanceWidth": 1102
    },
    ",": {
      "x_min": 134,
      "x_max": 464,
      "y_min": -164,
      "y_max": 330,
      "ha": 494,
      "leftSideBearing": 134,
      "advanceWidth": 598
    },
    "-": {
      "x_min": 108,
      "x_max": 838,
      "y_min": 480,
      "y_max": 724,
      "ha": 244,
      "leftSideBearing": 108,
      "advanceWidth": 966
    },
    ".": {
      "x_min": 134,
      "x_max": 464,
      "y_min": 0,
      "y_max": 330,
      "ha": 330,
      "leftSideBearing": 134,
      "advanceWidth": 598
    },
    "/": {
      "x_min": 70,
      "x_max": 826,
      "y_min": -26,
      "y_max": 1408,
      "ha": 1434,
      "leftSideBearing": 70,
      "advanceWidth": 906
    },
    ":": {
      "x_min": 122,
      "x_max": 454,
      "y_min": 0,
      "y_max": 854,
      "ha": 854,
      "leftSideBearing": 122,
      "advanceWidth": 572
    },
    ";": {
      "x_min": 120,
      "x_max": 452,
      "y_min": -166,
      "y_max": 852,
      "ha": 1018,
      "leftSideBearing": 120,
      "advanceWidth": 596
    },
    "<": {
      "x_min": 162,
      "x_max": 768,
      "y_min": 126,
      "y_max": 1074,
      "ha": 948,
      "leftSideBearing": 162,
      "advanceWidth": 930
    },
    "=": {
      "x_min": 180,
      "x_max": 914,
      "y_min": 290,
      "y_max": 926,
      "ha": 636,
      "leftSideBearing": 180,
      "advanceWidth": 1102
    },
    ">": {
      "x_min": 162,
      "x_max": 768,
      "y_min": 126,
      "y_max": 1074,
      "ha": 948,
      "leftSideBearing": 162,
      "advanceWidth": 930
    },
    "?": {
      "x_min": 104,
      "x_max": 1012,
      "y_min": 0,
      "y_max": 1420,
      "ha": 1420,
      "leftSideBearing": 104,
      "advanceWidth": 1122
    },
    "@": {
      "x_min": 132,
      "x_max": 1306,
      "y_min": -96,
      "y_max": 1078,
      "ha": 1174,
      "leftSideBearing": 132,
      "advanceWidth": 1494
    },
    "A": {
      "x_min": 74,
      "x_max": 1030,
      "y_min": 0,
      "y_max": 1400,
      "ha": 1400,
      "leftSideBearing": 74,
      "advanceWidth": 1104
    },
    "B": {
      "x_min": 120,
      "x_max": 1042,
      "y_min": 0,
      "y_max": 1400,
      "ha": 1400,
      "leftSideBearing": 120,
      "advanceWidth": 1104
    },
    "C": {
      "x_min": 90,
      "x_max": 1046,
      "y_min": -6,
      "y_max": 1408,
      "ha": 1414,
      "leftSideBearing": 90,
      "advanceWidth": 1110
    },
    "D": {
      "x_min": 134,
      "x_max": 1008,
      "y_min": 0,
      "y_max": 1400,
      "ha": 1400,
      "leftSideBearing": 134,
      "advanceWidth": 1094
    },
    "E": {
      "x_min": 140,
      "x_max": 912,
      "y_min": 0,
      "y_max": 1400,
      "ha": 1400,
      "leftSideBearing": 140,
      "advanceWidth": 986
    },
    "F": {
      "x_min": 140,
      "x_max": 912,
      "y_min": 0,
      "y_max": 1400,
      "ha": 1400,
      "leftSideBearing": 140,
      "advanceWidth": 938
    },
    "G": {
      "x_min": 106,
      "x_max": 1072,
      "y_min": -8,
      "y_max": 1408,
      "ha": 1416,
      "leftSideBearing": 106,
      "advanceWidth": 1156
    },
    "H": {
      "x_min": 146,
      "x_max": 1028,
      "y_min": 0,
      "y_max": 1400,
      "ha": 1400,
      "leftSideBearing": 146,
      "advanceWidth": 1166
    },
    "I": {
      "x_min": 168,
      "x_max": 500,
      "y_min": 0,
      "y_max": 1400,
      "ha": 1400,
      "leftSideBearing": 168,
      "advanceWidth": 666
    },
    "J": {
      "x_min": 46,
      "x_max": 980,
      "y_min": -8,
      "y_max": 1400,
      "ha": 1408,
      "leftSideBearing": 46,
      "advanceWidth": 1126
    },
    "K": {
      "x_min": 140,
      "x_max": 1064,
      "y_min": -8,
      "y_max": 1400,
      "ha": 1408,
      "leftSideBearing": 140,
      "advanceWidth": 1142
    },
    "L": {
      "x_min": 178,
      "x_max": 906,
      "y_min": 0,
      "y_max": 1400,
      "ha": 1400,
      "leftSideBearing": 178,
      "advanceWidth": 968
    },
    "M": {
      "x_min": 156,
      "x_max": 1430,
      "y_min": 0,
      "y_max": 1400,
      "ha": 1400,
      "leftSideBearing": 156,
      "advanceWidth": 1594
    },
    "N": {
      "x_min": 148,
      "x_max": 1222,
      "y_min": 0,
      "y_max": 1400,
      "ha": 1400,
      "leftSideBearing": 148,
      "advanceWidth": 1360
    },
    "O": {
      "x_min": 104,
      "x_max": 1026,
      "y_min": -8,
      "y_max": 1408,
      "ha": 1416,
      "leftSideBearing": 104,
      "advanceWidth": 1128
    },
    "P": {
      "x_min": 142,
      "x_max": 1066,
      "y_min": 0,
      "y_max": 1400,
      "ha": 1400,
      "leftSideBearing": 142,
      "advanceWidth": 1082
    },
    "Q": {
      "x_min": 122,
      "x_max": 1114,
      "y_min": -110,
      "y_max": 1408,
      "ha": 1518,
      "leftSideBearing": 122,
      "advanceWidth": 1156
    },
    "R": {
      "x_min": 142,
      "x_max": 1062,
      "y_min": -8,
      "y_max": 1400,
      "ha": 1408,
      "leftSideBearing": 142,
      "advanceWidth": 1142
    },
    "S": {
      "x_min": 88,
      "x_max": 950,
      "y_min": -8,
      "y_max": 1408,
      "ha": 1416,
      "leftSideBearing": 88,
      "advanceWidth": 1014
    },
    "T": {
      "x_min": 10,
      "x_max": 974,
      "y_min": 0,
      "y_max": 1400,
      "ha": 1400,
      "leftSideBearing": 10,
      "advanceWidth": 982
    },
    "U": {
      "x_min": 142,
      "x_max": 1070,
      "y_min": -8,
      "y_max": 1400,
      "ha": 1408,
      "leftSideBearing": 142,
      "advanceWidth": 1208
    },
    "V": {
      "x_min": 16,
      "x_max": 992,
      "y_min": 0,
      "y_max": 1400,
      "ha": 1400,
      "leftSideBearing": 16,
      "advanceWidth": 1000
    },
    "W": {
      "x_min": 24,
      "x_max": 1658,
      "y_min": 0,
      "y_max": 1400,
      "ha": 1400,
      "leftSideBearing": 24,
      "advanceWidth": 1666
    },
    "X": {
      "x_min": 56,
      "x_max": 1094,
      "y_min": 0,
      "y_max": 1400,
      "ha": 1400,
      "leftSideBearing": 56,
      "advanceWidth": 1146
    },
    "Y": {
      "x_min": -14,
      "x_max": 1022,
      "y_min": 0,
      "y_max": 1400,
      "ha": 1400,
      "leftSideBearing": -14,
      "advanceWidth": 1000
    },
    "Z": {
      "x_min": 70,
      "x_max": 982,
      "y_min": 0,
      "y_max": 1400,
      "ha": 1400,
      "leftSideBearing": 70,
      "advanceWidth": 1042
    },
    "[": {
      "x_min": 240,
      "x_max": 736,
      "y_min": 2,
      "y_max": 1404,
      "ha": 1402,
      "leftSideBearing": 240,
      "advanceWidth": 836
    },
    "\\": {
      "x_min": 70,
      "x_max": 826,
      "y_min": -26,
      "y_max": 1408,
      "ha": 1434,
      "leftSideBearing": 70,
      "advanceWidth": 906
    },
    "]": {
      "x_min": 140,
      "x_max": 636,
      "y_min": 2,
      "y_max": 1404,
      "ha": 1402,
      "leftSideBearing": 140,
      "advanceWidth": 836
    },
    "^": {
      "x_min": 174,
      "x_max": 782,
      "y_min": 762,
      "y_max": 1156,
      "ha": 394,
      "leftSideBearing": 174,
      "advanceWidth": 976
    },
    "_": {
      "x_min": 146,
      "x_max": 1254,
      "y_min": 2,
      "y_max": 246,
      "ha": 244,
      "leftSideBearing": 146,
      "advanceWidth": 1408
    },
    "`": {
      "x_min": 132,
      "x_max": 578,
      "y_min": 1102,
      "y_max": 1452,
      "ha": 350,
      "leftSideBearing": 132,
      "advanceWidth": 698
    },
    "a": {
      "x_min": 84,
      "x_max": 912,
      "y_min": 0,
      "y_max": 1000,
      "ha": 1000,
      "leftSideBearing": 84,
      "advanceWidth": 1020
    },
    "b": {
      "x_min": 120,
      "x_max": 948,
      "y_min": 0,
      "y_max": 1400,
      "ha": 1400,
      "leftSideBearing": 120,
      "advanceWidth": 1042
    },
    "c": {
      "x_min": 84,
      "x_max": 930,
      "y_min": 0,
      "y_max": 1000,
      "ha": 1000,
      "leftSideBearing": 84,
      "advanceWidth": 1000
    },
    "d": {
      "x_min": 82,
      "x_max": 910,
      "y_min": 0,
      "y_max": 1400,
      "ha": 1400,
      "leftSideBearing": 82,
      "advanceWidth": 1020
    },
    "e": {
      "x_min": 92,
      "x_max": 936,
      "y_min": 0,
      "y_max": 1002,
      "ha": 1002,
      "leftSideBearing": 92,
      "advanceWidth": 1020
    },
    "f": {
      "x_min": 0,
      "x_max": 724,
      "y_min": 0,
      "y_max": 1400,
      "ha": 1400,
      "leftSideBearing": 0,
      "advanceWidth": 750
    },
    "g": {
      "x_min": 92,
      "x_max": 922,
      "y_min": -400,
      "y_max": 1000,
      "ha": 1400,
      "leftSideBearing": 92,
      "advanceWidth": 1042
    },
    "h": {
      "x_min": 122,
      "x_max": 956,
      "y_min": 0,
      "y_max": 1400,
      "ha": 1400,
      "leftSideBearing": 122,
      "advanceWidth": 1042
    },
    "i": {
      "x_min": 154,
      "x_max": 460,
      "y_min": 0,
      "y_max": 1400,
      "ha": 1400,
      "leftSideBearing": 154,
      "advanceWidth": 626
    },
    "j": {
      "x_min": -44,
      "x_max": 480,
      "y_min": -400,
      "y_max": 1402,
      "ha": 1802,
      "leftSideBearing": -44,
      "advanceWidth": 626
    },
    "k": {
      "x_min": 150,
      "x_max": 920,
      "y_min": -2,
      "y_max": 1400,
      "ha": 1402,
      "leftSideBearing": 150,
      "advanceWidth": 1014
    },
    "l": {
      "x_min": 140,
      "x_max": 444,
      "y_min": 0,
      "y_max": 1400,
      "ha": 1400,
      "leftSideBearing": 140,
      "advanceWidth": 586
    },
    "m": {
      "x_min": 134,
      "x_max": 1486,
      "y_min": 0,
      "y_max": 1000,
      "ha": 1000,
      "leftSideBearing": 134,
      "advanceWidth": 1604
    },
    "n": {
      "x_min": 132,
      "x_max": 966,
      "y_min": 0,
      "y_max": 1000,
      "ha": 1000,
      "leftSideBearing": 132,
      "advanceWidth": 1082
    },
    "o": {
      "x_min": 78,
      "x_max": 912,
      "y_min": -8,
      "y_max": 1008,
      "ha": 1016,
      "leftSideBearing": 78,
      "advanceWidth": 990
    },
    "p": {
      "x_min": 132,
      "x_max": 960,
      "y_min": -400,
      "y_max": 1000,
      "ha": 1400,
      "leftSideBearing": 132,
      "advanceWidth": 1062
    },
    "q": {
      "x_min": 104,
      "x_max": 932,
      "y_min": -400,
      "y_max": 1000,
      "ha": 1400,
      "leftSideBearing": 104,
      "advanceWidth": 1062
    },
    "r": {
      "x_min": 132,
      "x_max": 770,
      "y_min": 0,
      "y_max": 998,
      "ha": 998,
      "leftSideBearing": 132,
      "advanceWidth": 792
    },
    "s": {
      "x_min": 86,
      "x_max": 836,
      "y_min": -8,
      "y_max": 1008,
      "ha": 1016,
      "leftSideBearing": 86,
      "advanceWidth": 910
    },
    "t": {
      "x_min": 60,
      "x_max": 786,
      "y_min": 0,
      "y_max": 1400,
      "ha": 1400,
      "leftSideBearing": 60,
      "advanceWidth": 870
    },
    "u": {
      "x_min": 118,
      "x_max": 952,
      "y_min": 0,
      "y_max": 1000,
      "ha": 1000,
      "leftSideBearing": 118,
      "advanceWidth": 1076
    },
    "v": {
      "x_min": 36,
      "x_max": 844,
      "y_min": 0,
      "y_max": 1000,
      "ha": 1000,
      "leftSideBearing": 36,
      "advanceWidth": 876
    },
    "w": {
      "x_min": 24,
      "x_max": 1372,
      "y_min": 0,
      "y_max": 1000,
      "ha": 1000,
      "leftSideBearing": 24,
      "advanceWidth": 1396
    },
    "x": {
      "x_min": 84,
      "x_max": 860,
      "y_min": 0,
      "y_max": 1000,
      "ha": 1000,
      "leftSideBearing": 84,
      "advanceWidth": 938
    },
    "y": {
      "x_min": 20,
      "x_max": 892,
      "y_min": -400,
      "y_max": 1004,
      "ha": 1404,
      "leftSideBearing": 20,
      "advanceWidth": 916
    },
    "z": {
      "x_min": 72,
      "x_max": 844,
      "y_min": 0,
      "y_max": 1000,
      "ha": 1000,
      "leftSideBearing": 72,
      "advanceWidth": 916
    },
    "{": {
      "x_min": 188,
      "x_max": 932,
      "y_min": -160,
      "y_max": 1566,
      "ha": 1726,
      "leftSideBearing": 188,
      "advanceWidth": 1012
    },
    "|": {
      "x_min": 180,
      "x_max": 424,
      "y_min": -160,
      "y_max": 1566,
      "ha": 1726,
      "leftSideBearing": 180,
      "advanceWidth": 604
    },
    "}": {
      "x_min": 80,
      "x_max": 824,
      "y_min": -160,
      "y_max": 1566,
      "ha": 1726,
      "leftSideBearing": 80,
      "advanceWidth": 1012
    },
    "~": {
      "x_min": 112,
      "x_max": 802,
      "y_min": 84,
      "y_max": 398,
      "ha": 314,
      "leftSideBearing": 112,
      "advanceWidth": 918
    }
  },
  "resolution": 2048,
  "generatedOn": "2020-10-16T18:00:03.708Z"
};
;MerriweatherFont = {
  name: "Merriweather-Regular",
  smufl: false,
  spacing: 50,
  fontFamily: "Merriweather",
  description: "Merriweather, a serif web font by Sorkin Type",
  serifs: true,
  monospaced: false,
  superscriptOffset: 0.66,
  subscriptOffset: 0.66,
  maxSizeGlyph: 'H',
  "glyphs": {
    "0": {
      "x_min": 62,
      "x_max": 582,
      "y_min": -9,
      "y_max": 631,
      "ha": 640,
      "leftSideBearing": 62,
      "advanceWidth": 643
    },
    "1": {
      "x_min": 39,
      "x_max": 419,
      "y_min": 0,
      "y_max": 632,
      "ha": 632,
      "leftSideBearing": 39,
      "advanceWidth": 440
    },
    "2": {
      "x_min": 47,
      "x_max": 565,
      "y_min": 0,
      "y_max": 632,
      "ha": 632,
      "leftSideBearing": 47,
      "advanceWidth": 598
    },
    "3": {
      "x_min": 57,
      "x_max": 512,
      "y_min": -161,
      "y_max": 632,
      "ha": 793,
      "leftSideBearing": 57,
      "advanceWidth": 560
    },
    "4": {
      "x_min": 37,
      "x_max": 625,
      "y_min": -161,
      "y_max": 680,
      "ha": 841,
      "leftSideBearing": 37,
      "advanceWidth": 644
    },
    "5": {
      "x_min": 91,
      "x_max": 527,
      "y_min": -161,
      "y_max": 643,
      "ha": 804,
      "leftSideBearing": 91,
      "advanceWidth": 594
    },
    "6": {
      "x_min": 76,
      "x_max": 592,
      "y_min": -11,
      "y_max": 786,
      "ha": 797,
      "leftSideBearing": 76,
      "advanceWidth": 664
    },
    "7": {
      "x_min": 48,
      "x_max": 546,
      "y_min": -173,
      "y_max": 624,
      "ha": 797,
      "leftSideBearing": 48,
      "advanceWidth": 588
    },
    "8": {
      "x_min": 65,
      "x_max": 572,
      "y_min": -10,
      "y_max": 752,
      "ha": 762,
      "leftSideBearing": 65,
      "advanceWidth": 633
    },
    "9": {
      "x_min": 70,
      "x_max": 588,
      "y_min": -167,
      "y_max": 632,
      "ha": 799,
      "leftSideBearing": 70,
      "advanceWidth": 660
    },
    " ": {
      "x_min": 0,
      "x_max": 0,
      "y_min": 0,
      "y_max": 0,
      "ha": 0,
      "leftSideBearing": 0,
      "advanceWidth": 237
    },
    "!": {
      "x_min": 107,
      "x_max": 248,
      "y_min": -10,
      "y_max": 883,
      "ha": 893,
      "leftSideBearing": 107,
      "advanceWidth": 354
    },
    "\"": {
      "x_min": 124,
      "x_max": 489,
      "y_min": 456,
      "y_max": 827,
      "ha": 371,
      "leftSideBearing": 124,
      "advanceWidth": 612
    },
    "#": {
      "x_min": 81,
      "x_max": 677,
      "y_min": 0,
      "y_max": 743,
      "ha": 743,
      "leftSideBearing": 81,
      "advanceWidth": 744
    },
    "$": {
      "x_min": 94,
      "x_max": 575,
      "y_min": -126,
      "y_max": 860,
      "ha": 986,
      "leftSideBearing": 94,
      "advanceWidth": 659
    },
    "%": {
      "x_min": 53,
      "x_max": 981,
      "y_min": 0,
      "y_max": 751,
      "ha": 751,
      "leftSideBearing": 53,
      "advanceWidth": 1037
    },
    "&": {
      "x_min": 60,
      "x_max": 739,
      "y_min": -9,
      "y_max": 752,
      "ha": 761,
      "leftSideBearing": 60,
      "advanceWidth": 756
    },
    "'": {
      "x_min": 124,
      "x_max": 230,
      "y_min": 456,
      "y_max": 827,
      "ha": 371,
      "leftSideBearing": 124,
      "advanceWidth": 353
    },
    "(": {
      "x_min": 67,
      "x_max": 360,
      "y_min": -184,
      "y_max": 828,
      "ha": 1012,
      "leftSideBearing": 67,
      "advanceWidth": 430
    },
    ")": {
      "x_min": 70,
      "x_max": 363,
      "y_min": -183,
      "y_max": 829,
      "ha": 1012,
      "leftSideBearing": 70,
      "advanceWidth": 430
    },
    "*": {
      "x_min": 76,
      "x_max": 568,
      "y_min": 310,
      "y_max": 823,
      "ha": 513,
      "leftSideBearing": 76,
      "advanceWidth": 643
    },
    "+": {
      "x_min": 105,
      "x_max": 556,
      "y_min": 84,
      "y_max": 547,
      "ha": 463,
      "leftSideBearing": 105,
      "advanceWidth": 661
    },
    ",": {
      "x_min": 99,
      "x_max": 250,
      "y_min": -224,
      "y_max": 150,
      "ha": 374,
      "leftSideBearing": 99,
      "advanceWidth": 335
    },
    "-": {
      "x_min": 112,
      "x_max": 516,
      "y_min": 284,
      "y_max": 357,
      "ha": 73,
      "leftSideBearing": 112,
      "advanceWidth": 628
    },
    ".": {
      "x_min": 63,
      "x_max": 202,
      "y_min": -10,
      "y_max": 127,
      "ha": 137,
      "leftSideBearing": 63,
      "advanceWidth": 265
    },
    "/": {
      "x_min": 36,
      "x_max": 394,
      "y_min": -177,
      "y_max": 781,
      "ha": 958,
      "leftSideBearing": 36,
      "advanceWidth": 431
    },
    ":": {
      "x_min": 102,
      "x_max": 240,
      "y_min": -10,
      "y_max": 539,
      "ha": 549,
      "leftSideBearing": 102,
      "advanceWidth": 344
    },
    ";": {
      "x_min": 99,
      "x_max": 250,
      "y_min": -224,
      "y_max": 539,
      "ha": 763,
      "leftSideBearing": 99,
      "advanceWidth": 344
    },
    "<": {
      "x_min": 82,
      "x_max": 555,
      "y_min": 27,
      "y_max": 575,
      "ha": 548,
      "leftSideBearing": 82,
      "advanceWidth": 669
    },
    "=": {
      "x_min": 102,
      "x_max": 552,
      "y_min": 127,
      "y_max": 474,
      "ha": 347,
      "leftSideBearing": 102,
      "advanceWidth": 653
    },
    ">": {
      "x_min": 114,
      "x_max": 587,
      "y_min": 27,
      "y_max": 575,
      "ha": 548,
      "leftSideBearing": 114,
      "advanceWidth": 669
    },
    "?": {
      "x_min": 42,
      "x_max": 452,
      "y_min": -10,
      "y_max": 906,
      "ha": 916,
      "leftSideBearing": 42,
      "advanceWidth": 487
    },
    "@": {
      "x_min": 93,
      "x_max": 977,
      "y_min": -253,
      "y_max": 760,
      "ha": 1013,
      "leftSideBearing": 93,
      "advanceWidth": 1078
    },
    "A": {
      "x_min": -13,
      "x_max": 705,
      "y_min": 0,
      "y_max": 749,
      "ha": 749,
      "leftSideBearing": -13,
      "advanceWidth": 692
    },
    "B": {
      "x_min": 46,
      "x_max": 649,
      "y_min": -6,
      "y_max": 751,
      "ha": 757,
      "leftSideBearing": 46,
      "advanceWidth": 685
    },
    "C": {
      "x_min": 33,
      "x_max": 617,
      "y_min": -11,
      "y_max": 751,
      "ha": 762,
      "leftSideBearing": 33,
      "advanceWidth": 653
    },
    "D": {
      "x_min": 46,
      "x_max": 725,
      "y_min": -8,
      "y_max": 751,
      "ha": 759,
      "leftSideBearing": 46,
      "advanceWidth": 758
    },
    "E": {
      "x_min": 46,
      "x_max": 630,
      "y_min": 0,
      "y_max": 743,
      "ha": 743,
      "leftSideBearing": 46,
      "advanceWidth": 651
    },
    "F": {
      "x_min": 43,
      "x_max": 588,
      "y_min": 0,
      "y_max": 743,
      "ha": 743,
      "leftSideBearing": 43,
      "advanceWidth": 619
    },
    "G": {
      "x_min": 43,
      "x_max": 721,
      "y_min": -11,
      "y_max": 751,
      "ha": 762,
      "leftSideBearing": 43,
      "advanceWidth": 740
    },
    "H": {
      "x_min": 50,
      "x_max": 777,
      "y_min": 0,
      "y_max": 743,
      "ha": 743,
      "leftSideBearing": 50,
      "advanceWidth": 828
    },
    "I": {
      "x_min": 54,
      "x_max": 348,
      "y_min": 0,
      "y_max": 743,
      "ha": 743,
      "leftSideBearing": 54,
      "advanceWidth": 403
    },
    "J": {
      "x_min": -6,
      "x_max": 343,
      "y_min": -179,
      "y_max": 743,
      "ha": 922,
      "leftSideBearing": -6,
      "advanceWidth": 381
    },
    "K": {
      "x_min": 48,
      "x_max": 727,
      "y_min": 0,
      "y_max": 743,
      "ha": 743,
      "leftSideBearing": 48,
      "advanceWidth": 726
    },
    "L": {
      "x_min": 48,
      "x_max": 616,
      "y_min": 0,
      "y_max": 743,
      "ha": 743,
      "leftSideBearing": 48,
      "advanceWidth": 634
    },
    "M": {
      "x_min": 6,
      "x_max": 984,
      "y_min": 0,
      "y_max": 743,
      "ha": 743,
      "leftSideBearing": 6,
      "advanceWidth": 990
    },
    "N": {
      "x_min": 50,
      "x_max": 774,
      "y_min": 0,
      "y_max": 743,
      "ha": 743,
      "leftSideBearing": 50,
      "advanceWidth": 799
    },
    "O": {
      "x_min": 34,
      "x_max": 689,
      "y_min": -11,
      "y_max": 751,
      "ha": 762,
      "leftSideBearing": 34,
      "advanceWidth": 722
    },
    "P": {
      "x_min": 48,
      "x_max": 624,
      "y_min": 0,
      "y_max": 750,
      "ha": 750,
      "leftSideBearing": 48,
      "advanceWidth": 649
    },
    "Q": {
      "x_min": 36,
      "x_max": 904,
      "y_min": -198,
      "y_max": 751,
      "ha": 949,
      "leftSideBearing": 36,
      "advanceWidth": 727
    },
    "R": {
      "x_min": 46,
      "x_max": 705,
      "y_min": 0,
      "y_max": 751,
      "ha": 751,
      "leftSideBearing": 46,
      "advanceWidth": 704
    },
    "S": {
      "x_min": 62,
      "x_max": 556,
      "y_min": -11,
      "y_max": 751,
      "ha": 762,
      "leftSideBearing": 62,
      "advanceWidth": 594
    },
    "T": {
      "x_min": 17,
      "x_max": 669,
      "y_min": 0,
      "y_max": 743,
      "ha": 743,
      "leftSideBearing": 17,
      "advanceWidth": 692
    },
    "U": {
      "x_min": 24,
      "x_max": 725,
      "y_min": -8,
      "y_max": 743,
      "ha": 751,
      "leftSideBearing": 24,
      "advanceWidth": 740
    },
    "V": {
      "x_min": -16,
      "x_max": 689,
      "y_min": -8,
      "y_max": 743,
      "ha": 751,
      "leftSideBearing": -16,
      "advanceWidth": 670
    },
    "W": {
      "x_min": -19,
      "x_max": 1019,
      "y_min": -5,
      "y_max": 743,
      "ha": 748,
      "leftSideBearing": -19,
      "advanceWidth": 1000
    },
    "X": {
      "x_min": 7,
      "x_max": 710,
      "y_min": 0,
      "y_max": 743,
      "ha": 743,
      "leftSideBearing": 7,
      "advanceWidth": 712
    },
    "Y": {
      "x_min": -12,
      "x_max": 658,
      "y_min": 0,
      "y_max": 743,
      "ha": 743,
      "leftSideBearing": -12,
      "advanceWidth": 644
    },
    "Z": {
      "x_min": 34,
      "x_max": 616,
      "y_min": 0,
      "y_max": 746,
      "ha": 746,
      "leftSideBearing": 34,
      "advanceWidth": 654
    },
    "[": {
      "x_min": 96,
      "x_max": 338,
      "y_min": -137,
      "y_max": 804,
      "ha": 941,
      "leftSideBearing": 96,
      "advanceWidth": 428
    },
    "\\": {
      "x_min": 30,
      "x_max": 388,
      "y_min": -177,
      "y_max": 781,
      "ha": 958,
      "leftSideBearing": 30,
      "advanceWidth": 431
    },
    "]": {
      "x_min": 90,
      "x_max": 332,
      "y_min": -137,
      "y_max": 804,
      "ha": 941,
      "leftSideBearing": 90,
      "advanceWidth": 428
    },
    "^": {
      "x_min": 86,
      "x_max": 579,
      "y_min": 133,
      "y_max": 748,
      "ha": 615,
      "leftSideBearing": 86,
      "advanceWidth": 666
    },
    "_": {
      "x_min": -10,
      "x_max": 845,
      "y_min": -183,
      "y_max": -122,
      "ha": 61,
      "leftSideBearing": -10,
      "advanceWidth": 835
    },
    "`": {
      "x_min": -7,
      "x_max": 227,
      "y_min": 653,
      "y_max": 884,
      "ha": 231,
      "leftSideBearing": -7,
      "advanceWidth": 333
    },
    "a": {
      "x_min": 45,
      "x_max": 536,
      "y_min": -11,
      "y_max": 567,
      "ha": 578,
      "leftSideBearing": 45,
      "advanceWidth": 561
    },
    "b": {
      "x_min": -2,
      "x_max": 565,
      "y_min": -11,
      "y_max": 819,
      "ha": 830,
      "leftSideBearing": -2,
      "advanceWidth": 607
    },
    "c": {
      "x_min": 33,
      "x_max": 471,
      "y_min": -11,
      "y_max": 570,
      "ha": 581,
      "leftSideBearing": 33,
      "advanceWidth": 513
    },
    "d": {
      "x_min": 42,
      "x_max": 586,
      "y_min": -11,
      "y_max": 819,
      "ha": 830,
      "leftSideBearing": 42,
      "advanceWidth": 621
    },
    "e": {
      "x_min": 43,
      "x_max": 503,
      "y_min": -11,
      "y_max": 570,
      "ha": 581,
      "leftSideBearing": 43,
      "advanceWidth": 544
    },
    "f": {
      "x_min": 31,
      "x_max": 413,
      "y_min": 0,
      "y_max": 828,
      "ha": 828,
      "leftSideBearing": 31,
      "advanceWidth": 400
    },
    "g": {
      "x_min": 41,
      "x_max": 597,
      "y_min": -270,
      "y_max": 571,
      "ha": 841,
      "leftSideBearing": 41,
      "advanceWidth": 607
    },
    "h": {
      "x_min": 15,
      "x_max": 630,
      "y_min": 0,
      "y_max": 819,
      "ha": 819,
      "leftSideBearing": 15,
      "advanceWidth": 659
    },
    "i": {
      "x_min": 42,
      "x_max": 307,
      "y_min": 0,
      "y_max": 793,
      "ha": 793,
      "leftSideBearing": 42,
      "advanceWidth": 333
    },
    "j": {
      "x_min": -11,
      "x_max": 238,
      "y_min": -243,
      "y_max": 793,
      "ha": 1036,
      "leftSideBearing": -11,
      "advanceWidth": 317
    },
    "k": {
      "x_min": 20,
      "x_max": 624,
      "y_min": 0,
      "y_max": 819,
      "ha": 819,
      "leftSideBearing": 20,
      "advanceWidth": 600
    },
    "l": {
      "x_min": 37,
      "x_max": 307,
      "y_min": 0,
      "y_max": 819,
      "ha": 819,
      "leftSideBearing": 37,
      "advanceWidth": 333
    },
    "m": {
      "x_min": 33,
      "x_max": 970,
      "y_min": 0,
      "y_max": 568,
      "ha": 568,
      "leftSideBearing": 33,
      "advanceWidth": 995
    },
    "n": {
      "x_min": 33,
      "x_max": 637,
      "y_min": 0,
      "y_max": 568,
      "ha": 568,
      "leftSideBearing": 33,
      "advanceWidth": 664
    },
    "o": {
      "x_min": 45,
      "x_max": 562,
      "y_min": -11,
      "y_max": 570,
      "ha": 581,
      "leftSideBearing": 45,
      "advanceWidth": 608
    },
    "p": {
      "x_min": 29,
      "x_max": 586,
      "y_min": -242,
      "y_max": 570,
      "ha": 812,
      "leftSideBearing": 29,
      "advanceWidth": 628
    },
    "q": {
      "x_min": 42,
      "x_max": 597,
      "y_min": -242,
      "y_max": 570,
      "ha": 812,
      "leftSideBearing": 42,
      "advanceWidth": 609
    },
    "r": {
      "x_min": 47,
      "x_max": 437,
      "y_min": 0,
      "y_max": 570,
      "ha": 570,
      "leftSideBearing": 47,
      "advanceWidth": 458
    },
    "s": {
      "x_min": 55,
      "x_max": 460,
      "y_min": -11,
      "y_max": 567,
      "ha": 578,
      "leftSideBearing": 55,
      "advanceWidth": 505
    },
    "t": {
      "x_min": 31,
      "x_max": 391,
      "y_min": -10,
      "y_max": 699,
      "ha": 709,
      "leftSideBearing": 31,
      "advanceWidth": 407
    },
    "u": {
      "x_min": 36,
      "x_max": 597,
      "y_min": -11,
      "y_max": 567,
      "ha": 578,
      "leftSideBearing": 36,
      "advanceWidth": 632
    },
    "v": {
      "x_min": -1,
      "x_max": 575,
      "y_min": -8,
      "y_max": 555,
      "ha": 563,
      "leftSideBearing": -1,
      "advanceWidth": 568
    },
    "w": {
      "x_min": -7,
      "x_max": 853,
      "y_min": -8,
      "y_max": 555,
      "ha": 563,
      "leftSideBearing": -7,
      "advanceWidth": 839
    },
    "x": {
      "x_min": 6,
      "x_max": 591,
      "y_min": 0,
      "y_max": 555,
      "ha": 555,
      "leftSideBearing": 6,
      "advanceWidth": 595
    },
    "y": {
      "x_min": -3,
      "x_max": 571,
      "y_min": -249,
      "y_max": 555,
      "ha": 804,
      "leftSideBearing": -3,
      "advanceWidth": 572
    },
    "z": {
      "x_min": 30,
      "x_max": 518,
      "y_min": 0,
      "y_max": 555,
      "ha": 555,
      "leftSideBearing": 30,
      "advanceWidth": 554
    },
    "{": {
      "x_min": 57,
      "x_max": 431,
      "y_min": -137,
      "y_max": 806,
      "ha": 943,
      "leftSideBearing": 57,
      "advanceWidth": 508
    },
    "|": {
      "x_min": 170,
      "x_max": 252,
      "y_min": -91,
      "y_max": 869,
      "ha": 960,
      "leftSideBearing": 170,
      "advanceWidth": 422
    },
    "}": {
      "x_min": 77,
      "x_max": 450,
      "y_min": -137,
      "y_max": 806,
      "ha": 943,
      "leftSideBearing": 77,
      "advanceWidth": 508
    },
    "~": {
      "x_min": 107,
      "x_max": 584,
      "y_min": 218,
      "y_max": 379,
      "ha": 161,
      "leftSideBearing": 107,
      "advanceWidth": 692
    }
  },
  "resolution": 1000,
  "generatedOn": "2020-10-16T18:04:00.805Z"
};
;const SourceSansProFont = {
  smufl: false,
  name: "Sans",
  spacing: 50,
  description: "Open-source Sans font from Adobe",
  serifs: true,
  monospaced: false,
  superscriptOffset: 0.66,
  subscriptOffset: 0.66,
  maxSizeGlyph: 'H',
  "fontFamily": "Source Sans Pro",
  "resolution": 1000,
  "generatedOn": "2020-11-01T21:31:30.347Z",
  "glyphs": {
    "0": {
      "x_min": 44,
      "x_max": 453,
      "y_min": -12,
      "y_max": 650,
      "ha": 662,
      "leftSideBearing": 44,
      "advanceWidth": 497
    },
    "1": {
      "x_min": 79,
      "x_max": 439,
      "y_min": 0,
      "y_max": 638,
      "ha": 638,
      "leftSideBearing": 79,
      "advanceWidth": 497
    },
    "2": {
      "x_min": 36,
      "x_max": 452,
      "y_min": 0,
      "y_max": 650,
      "ha": 650,
      "leftSideBearing": 36,
      "advanceWidth": 497
    },
    "3": {
      "x_min": 26,
      "x_max": 446,
      "y_min": -12,
      "y_max": 650,
      "ha": 662,
      "leftSideBearing": 26,
      "advanceWidth": 497
    },
    "4": {
      "x_min": 17,
      "x_max": 469,
      "y_min": 0,
      "y_max": 638,
      "ha": 638,
      "leftSideBearing": 17,
      "advanceWidth": 497
    },
    "5": {
      "x_min": 25,
      "x_max": 449,
      "y_min": -12,
      "y_max": 638,
      "ha": 650,
      "leftSideBearing": 25,
      "advanceWidth": 497
    },
    "6": {
      "x_min": 48,
      "x_max": 457,
      "y_min": -12,
      "y_max": 650,
      "ha": 662,
      "leftSideBearing": 48,
      "advanceWidth": 497
    },
    "7": {
      "x_min": 44,
      "x_max": 455,
      "y_min": 0,
      "y_max": 638,
      "ha": 638,
      "leftSideBearing": 44,
      "advanceWidth": 497
    },
    "8": {
      "x_min": 41,
      "x_max": 456,
      "y_min": -12,
      "y_max": 650,
      "ha": 662,
      "leftSideBearing": 41,
      "advanceWidth": 497
    },
    "9": {
      "x_min": 40,
      "x_max": 448,
      "y_min": -12,
      "y_max": 650,
      "ha": 662,
      "leftSideBearing": 40,
      "advanceWidth": 497
    },
    " ": {
      "x_min": 0,
      "x_max": 0,
      "y_min": 0,
      "y_max": 0,
      "ha": 0,
      "leftSideBearing": 0,
      "advanceWidth": 200
    },
    "!": {
      "x_min": 85,
      "x_max": 204,
      "y_min": -12,
      "y_max": 670,
      "ha": 682,
      "leftSideBearing": 85,
      "advanceWidth": 289
    },
    "\"": {
      "x_min": 80,
      "x_max": 344,
      "y_min": 431,
      "y_max": 690,
      "ha": 259,
      "leftSideBearing": 80,
      "advanceWidth": 425
    },
    "#": {
      "x_min": 35,
      "x_max": 467,
      "y_min": 0,
      "y_max": 650,
      "ha": 650,
      "leftSideBearing": 35,
      "advanceWidth": 497
    },
    "$": {
      "x_min": 52,
      "x_max": 437,
      "y_min": -110,
      "y_max": 748,
      "ha": 858,
      "leftSideBearing": 52,
      "advanceWidth": 497
    },
    "%": {
      "x_min": 35,
      "x_max": 790,
      "y_min": -12,
      "y_max": 668,
      "ha": 680,
      "leftSideBearing": 35,
      "advanceWidth": 824
    },
    "&": {
      "x_min": 32,
      "x_max": 594,
      "y_min": -12,
      "y_max": 668,
      "ha": 680,
      "leftSideBearing": 32,
      "advanceWidth": 609
    },
    "'": {
      "x_min": 80,
      "x_max": 168,
      "y_min": 431,
      "y_max": 690,
      "ha": 259,
      "leftSideBearing": 80,
      "advanceWidth": 249
    },
    "(": {
      "x_min": 82,
      "x_max": 265,
      "y_min": -176,
      "y_max": 732,
      "ha": 908,
      "leftSideBearing": 82,
      "advanceWidth": 303
    },
    ")": {
      "x_min": 38,
      "x_max": 221,
      "y_min": -176,
      "y_max": 732,
      "ha": 908,
      "leftSideBearing": 38,
      "advanceWidth": 303
    },
    "*": {
      "x_min": 58,
      "x_max": 360,
      "y_min": 420,
      "y_max": 712,
      "ha": 292,
      "leftSideBearing": 58,
      "advanceWidth": 418
    },
    "+": {
      "x_min": 34,
      "x_max": 463,
      "y_min": 104,
      "y_max": 556,
      "ha": 452,
      "leftSideBearing": 34,
      "advanceWidth": 497
    },
    ",": {
      "x_min": 47,
      "x_max": 198,
      "y_min": -170,
      "y_max": 114,
      "ha": 284,
      "leftSideBearing": 47,
      "advanceWidth": 249
    },
    "-": {
      "x_min": 41,
      "x_max": 271,
      "y_min": 219,
      "y_max": 282,
      "ha": 63,
      "leftSideBearing": 41,
      "advanceWidth": 311
    },
    ".": {
      "x_min": 65,
      "x_max": 184,
      "y_min": -12,
      "y_max": 114,
      "ha": 126,
      "leftSideBearing": 65,
      "advanceWidth": 249
    },
    "/": {
      "x_min": 10,
      "x_max": 337,
      "y_min": -160,
      "y_max": 710,
      "ha": 870,
      "leftSideBearing": 10,
      "advanceWidth": 350
    },
    ":": {
      "x_min": 65,
      "x_max": 184,
      "y_min": -12,
      "y_max": 475,
      "ha": 487,
      "leftSideBearing": 65,
      "advanceWidth": 249
    },
    ";": {
      "x_min": 47,
      "x_max": 198,
      "y_min": -170,
      "y_max": 475,
      "ha": 645,
      "leftSideBearing": 47,
      "advanceWidth": 249
    },
    "<": {
      "x_min": 34,
      "x_max": 463,
      "y_min": 131,
      "y_max": 533,
      "ha": 402,
      "leftSideBearing": 34,
      "advanceWidth": 497
    },
    "=": {
      "x_min": 34,
      "x_max": 463,
      "y_min": 193,
      "y_max": 468,
      "ha": 275,
      "leftSideBearing": 34,
      "advanceWidth": 497
    },
    ">": {
      "x_min": 34,
      "x_max": 463,
      "y_min": 131,
      "y_max": 533,
      "ha": 402,
      "leftSideBearing": 34,
      "advanceWidth": 497
    },
    "?": {
      "x_min": 38,
      "x_max": 377,
      "y_min": -12,
      "y_max": 682,
      "ha": 694,
      "leftSideBearing": 38,
      "advanceWidth": 425
    },
    "@": {
      "x_min": 51,
      "x_max": 796,
      "y_min": -155,
      "y_max": 646,
      "ha": 801,
      "leftSideBearing": 51,
      "advanceWidth": 847
    },
    "A": {
      "x_min": 3,
      "x_max": 541,
      "y_min": 0,
      "y_max": 656,
      "ha": 656,
      "leftSideBearing": 3,
      "advanceWidth": 544
    },
    "B": {
      "x_min": 90,
      "x_max": 548,
      "y_min": 0,
      "y_max": 656,
      "ha": 656,
      "leftSideBearing": 90,
      "advanceWidth": 588
    },
    "C": {
      "x_min": 52,
      "x_max": 539,
      "y_min": -12,
      "y_max": 668,
      "ha": 680,
      "leftSideBearing": 52,
      "advanceWidth": 571
    },
    "D": {
      "x_min": 90,
      "x_max": 564,
      "y_min": 0,
      "y_max": 656,
      "ha": 656,
      "leftSideBearing": 90,
      "advanceWidth": 615
    },
    "E": {
      "x_min": 90,
      "x_max": 478,
      "y_min": 0,
      "y_max": 656,
      "ha": 656,
      "leftSideBearing": 90,
      "advanceWidth": 527
    },
    "F": {
      "x_min": 90,
      "x_max": 468,
      "y_min": 0,
      "y_max": 656,
      "ha": 656,
      "leftSideBearing": 90,
      "advanceWidth": 494
    },
    "G": {
      "x_min": 52,
      "x_max": 550,
      "y_min": -12,
      "y_max": 668,
      "ha": 680,
      "leftSideBearing": 52,
      "advanceWidth": 617
    },
    "H": {
      "x_min": 90,
      "x_max": 562,
      "y_min": 0,
      "y_max": 656,
      "ha": 656,
      "leftSideBearing": 90,
      "advanceWidth": 652
    },
    "I": {
      "x_min": 90,
      "x_max": 173,
      "y_min": 0,
      "y_max": 656,
      "ha": 656,
      "leftSideBearing": 90,
      "advanceWidth": 263
    },
    "J": {
      "x_min": 31,
      "x_max": 393,
      "y_min": -12,
      "y_max": 656,
      "ha": 668,
      "leftSideBearing": 31,
      "advanceWidth": 480
    },
    "K": {
      "x_min": 90,
      "x_max": 575,
      "y_min": 0,
      "y_max": 656,
      "ha": 656,
      "leftSideBearing": 90,
      "advanceWidth": 579
    },
    "L": {
      "x_min": 90,
      "x_max": 460,
      "y_min": 0,
      "y_max": 656,
      "ha": 656,
      "leftSideBearing": 90,
      "advanceWidth": 486
    },
    "M": {
      "x_min": 90,
      "x_max": 637,
      "y_min": 0,
      "y_max": 656,
      "ha": 656,
      "leftSideBearing": 90,
      "advanceWidth": 727
    },
    "N": {
      "x_min": 90,
      "x_max": 557,
      "y_min": 0,
      "y_max": 656,
      "ha": 656,
      "leftSideBearing": 90,
      "advanceWidth": 647
    },
    "O": {
      "x_min": 52,
      "x_max": 613,
      "y_min": -12,
      "y_max": 668,
      "ha": 680,
      "leftSideBearing": 52,
      "advanceWidth": 664
    },
    "P": {
      "x_min": 90,
      "x_max": 523,
      "y_min": 0,
      "y_max": 656,
      "ha": 656,
      "leftSideBearing": 90,
      "advanceWidth": 566
    },
    "Q": {
      "x_min": 52,
      "x_max": 627,
      "y_min": -165,
      "y_max": 668,
      "ha": 833,
      "leftSideBearing": 52,
      "advanceWidth": 664
    },
    "R": {
      "x_min": 90,
      "x_max": 544,
      "y_min": 0,
      "y_max": 656,
      "ha": 656,
      "leftSideBearing": 90,
      "advanceWidth": 569
    },
    "S": {
      "x_min": 42,
      "x_max": 495,
      "y_min": -12,
      "y_max": 668,
      "ha": 680,
      "leftSideBearing": 42,
      "advanceWidth": 534
    },
    "T": {
      "x_min": 28,
      "x_max": 508,
      "y_min": 0,
      "y_max": 656,
      "ha": 656,
      "leftSideBearing": 28,
      "advanceWidth": 536
    },
    "U": {
      "x_min": 87,
      "x_max": 558,
      "y_min": -12,
      "y_max": 656,
      "ha": 668,
      "leftSideBearing": 87,
      "advanceWidth": 645
    },
    "V": {
      "x_min": 0,
      "x_max": 515,
      "y_min": 0,
      "y_max": 656,
      "ha": 656,
      "leftSideBearing": 0,
      "advanceWidth": 515
    },
    "W": {
      "x_min": 23,
      "x_max": 762,
      "y_min": 0,
      "y_max": 656,
      "ha": 656,
      "leftSideBearing": 23,
      "advanceWidth": 786
    },
    "X": {
      "x_min": 15,
      "x_max": 498,
      "y_min": 0,
      "y_max": 656,
      "ha": 656,
      "leftSideBearing": 15,
      "advanceWidth": 513
    },
    "Y": {
      "x_min": -1,
      "x_max": 477,
      "y_min": 0,
      "y_max": 656,
      "ha": 656,
      "leftSideBearing": -1,
      "advanceWidth": 476
    },
    "Z": {
      "x_min": 45,
      "x_max": 497,
      "y_min": 0,
      "y_max": 656,
      "ha": 656,
      "leftSideBearing": 45,
      "advanceWidth": 539
    },
    "[": {
      "x_min": 94,
      "x_max": 273,
      "y_min": -152,
      "y_max": 708,
      "ha": 860,
      "leftSideBearing": 94,
      "advanceWidth": 303
    },
    "\\": {
      "x_min": 14,
      "x_max": 340,
      "y_min": -160,
      "y_max": 710,
      "ha": 870,
      "leftSideBearing": 14,
      "advanceWidth": 350
    },
    "]": {
      "x_min": 31,
      "x_max": 209,
      "y_min": -152,
      "y_max": 708,
      "ha": 860,
      "leftSideBearing": 31,
      "advanceWidth": 303
    },
    "^": {
      "x_min": 60,
      "x_max": 437,
      "y_min": 284,
      "y_max": 670,
      "ha": 386,
      "leftSideBearing": 60,
      "advanceWidth": 497
    },
    "_": {
      "x_min": 12,
      "x_max": 488,
      "y_min": -126,
      "y_max": -71,
      "ha": 55,
      "leftSideBearing": 12,
      "advanceWidth": 500
    },
    "`": {
      "x_min": 128,
      "x_max": 327,
      "y_min": 573,
      "y_max": 781,
      "ha": 208,
      "leftSideBearing": 128,
      "advanceWidth": 542
    },
    "a": {
      "x_min": 52,
      "x_max": 433,
      "y_min": -12,
      "y_max": 498,
      "ha": 510,
      "leftSideBearing": 52,
      "advanceWidth": 504
    },
    "b": {
      "x_min": 82,
      "x_max": 507,
      "y_min": -12,
      "y_max": 712,
      "ha": 724,
      "leftSideBearing": 82,
      "advanceWidth": 553
    },
    "c": {
      "x_min": 46,
      "x_max": 431,
      "y_min": -12,
      "y_max": 498,
      "ha": 510,
      "leftSideBearing": 46,
      "advanceWidth": 456
    },
    "d": {
      "x_min": 47,
      "x_max": 473,
      "y_min": -12,
      "y_max": 712,
      "ha": 724,
      "leftSideBearing": 47,
      "advanceWidth": 555
    },
    "e": {
      "x_min": 46,
      "x_max": 458,
      "y_min": -12,
      "y_max": 498,
      "ha": 510,
      "leftSideBearing": 46,
      "advanceWidth": 496
    },
    "f": {
      "x_min": 30,
      "x_max": 319,
      "y_min": 0,
      "y_max": 724,
      "ha": 724,
      "leftSideBearing": 30,
      "advanceWidth": 292
    },
    "g": {
      "x_min": 45,
      "x_max": 492,
      "y_min": -224,
      "y_max": 498,
      "ha": 722,
      "leftSideBearing": 45,
      "advanceWidth": 504
    },
    "h": {
      "x_min": 82,
      "x_max": 471,
      "y_min": 0,
      "y_max": 712,
      "ha": 712,
      "leftSideBearing": 82,
      "advanceWidth": 544
    },
    "i": {
      "x_min": 67,
      "x_max": 181,
      "y_min": 0,
      "y_max": 692,
      "ha": 692,
      "leftSideBearing": 67,
      "advanceWidth": 246
    },
    "j": {
      "x_min": -40,
      "x_max": 181,
      "y_min": -217,
      "y_max": 692,
      "ha": 909,
      "leftSideBearing": -40,
      "advanceWidth": 247
    },
    "k": {
      "x_min": 82,
      "x_max": 486,
      "y_min": 0,
      "y_max": 712,
      "ha": 712,
      "leftSideBearing": 82,
      "advanceWidth": 495
    },
    "l": {
      "x_min": 82,
      "x_max": 216,
      "y_min": -12,
      "y_max": 712,
      "ha": 724,
      "leftSideBearing": 82,
      "advanceWidth": 255
    },
    "m": {
      "x_min": 82,
      "x_max": 753,
      "y_min": 0,
      "y_max": 498,
      "ha": 498,
      "leftSideBearing": 82,
      "advanceWidth": 829
    },
    "n": {
      "x_min": 82,
      "x_max": 471,
      "y_min": 0,
      "y_max": 498,
      "ha": 498,
      "leftSideBearing": 82,
      "advanceWidth": 547
    },
    "o": {
      "x_min": 46,
      "x_max": 496,
      "y_min": -12,
      "y_max": 498,
      "ha": 510,
      "leftSideBearing": 46,
      "advanceWidth": 542
    },
    "p": {
      "x_min": 82,
      "x_max": 507,
      "y_min": -205,
      "y_max": 498,
      "ha": 703,
      "leftSideBearing": 82,
      "advanceWidth": 555
    },
    "q": {
      "x_min": 47,
      "x_max": 473,
      "y_min": -205,
      "y_max": 498,
      "ha": 703,
      "leftSideBearing": 47,
      "advanceWidth": 555
    },
    "r": {
      "x_min": 82,
      "x_max": 350,
      "y_min": 0,
      "y_max": 498,
      "ha": 498,
      "leftSideBearing": 82,
      "advanceWidth": 347
    },
    "s": {
      "x_min": 28,
      "x_max": 387,
      "y_min": -12,
      "y_max": 498,
      "ha": 510,
      "leftSideBearing": 28,
      "advanceWidth": 419
    },
    "t": {
      "x_min": 24,
      "x_max": 325,
      "y_min": -12,
      "y_max": 622,
      "ha": 634,
      "leftSideBearing": 24,
      "advanceWidth": 338
    },
    "u": {
      "x_min": 75,
      "x_max": 462,
      "y_min": -12,
      "y_max": 486,
      "ha": 498,
      "leftSideBearing": 75,
      "advanceWidth": 544
    },
    "v": {
      "x_min": 12,
      "x_max": 455,
      "y_min": 0,
      "y_max": 486,
      "ha": 486,
      "leftSideBearing": 12,
      "advanceWidth": 467
    },
    "w": {
      "x_min": 24,
      "x_max": 694,
      "y_min": 0,
      "y_max": 486,
      "ha": 486,
      "leftSideBearing": 24,
      "advanceWidth": 718
    },
    "x": {
      "x_min": 14,
      "x_max": 432,
      "y_min": 0,
      "y_max": 486,
      "ha": 486,
      "leftSideBearing": 14,
      "advanceWidth": 446
    },
    "y": {
      "x_min": 12,
      "x_max": 455,
      "y_min": -209,
      "y_max": 486,
      "ha": 695,
      "leftSideBearing": 12,
      "advanceWidth": 467
    },
    "z": {
      "x_min": 31,
      "x_max": 399,
      "y_min": 0,
      "y_max": 486,
      "ha": 486,
      "leftSideBearing": 31,
      "advanceWidth": 425
    },
    "{": {
      "x_min": 34,
      "x_max": 273,
      "y_min": -152,
      "y_max": 708,
      "ha": 860,
      "leftSideBearing": 34,
      "advanceWidth": 303
    },
    "|": {
      "x_min": 92,
      "x_max": 150,
      "y_min": -250,
      "y_max": 750,
      "ha": 1000,
      "leftSideBearing": 92,
      "advanceWidth": 241
    },
    "}": {
      "x_min": 31,
      "x_max": 269,
      "y_min": -152,
      "y_max": 708,
      "ha": 860,
      "leftSideBearing": 31,
      "advanceWidth": 303
    },
    "~": {
      "x_min": 36,
      "x_max": 461,
      "y_min": 257,
      "y_max": 403,
      "ha": 146,
      "leftSideBearing": 36,
      "advanceWidth": 497
    }
  },
};
;const SourceSerifProFont = {
  smufl: false,
  name: "Serif",
  spacing: 50,
  description: "Open-source Serif font from Adobe",
  serifs: true,
  monospaced: false,
  superscriptOffset: 0.66,
  subscriptOffset: 0.66,
  maxSizeGlyph: 'H',
  "fontFamily": "Source Serif Pro",
  "resolution": 1000,
  "glyphs": {
    "0": {
      "x_min": 41,
      "x_max": 460,
      "y_min": -13,
      "y_max": 659,
      "ha": 672,
      "leftSideBearing": 41,
      "advanceWidth": 500
    },
    "1": {
      "x_min": 74,
      "x_max": 445,
      "y_min": 0,
      "y_max": 654,
      "ha": 654,
      "leftSideBearing": 74,
      "advanceWidth": 500
    },
    "2": {
      "x_min": 44,
      "x_max": 460,
      "y_min": 0,
      "y_max": 659,
      "ha": 659,
      "leftSideBearing": 44,
      "advanceWidth": 500
    },
    "3": {
      "x_min": 44,
      "x_max": 460,
      "y_min": -13,
      "y_max": 659,
      "ha": 672,
      "leftSideBearing": 44,
      "advanceWidth": 500
    },
    "4": {
      "x_min": 24,
      "x_max": 484,
      "y_min": 0,
      "y_max": 655,
      "ha": 655,
      "leftSideBearing": 24,
      "advanceWidth": 500
    },
    "5": {
      "x_min": 38,
      "x_max": 458,
      "y_min": -13,
      "y_max": 646,
      "ha": 659,
      "leftSideBearing": 38,
      "advanceWidth": 500
    },
    "6": {
      "x_min": 40,
      "x_max": 457,
      "y_min": -13,
      "y_max": 659,
      "ha": 672,
      "leftSideBearing": 40,
      "advanceWidth": 500
    },
    "7": {
      "x_min": 51,
      "x_max": 464,
      "y_min": 0,
      "y_max": 646,
      "ha": 646,
      "leftSideBearing": 51,
      "advanceWidth": 500
    },
    "8": {
      "x_min": 44,
      "x_max": 455,
      "y_min": -13,
      "y_max": 659,
      "ha": 672,
      "leftSideBearing": 44,
      "advanceWidth": 500
    },
    "9": {
      "x_min": 29,
      "x_max": 450,
      "y_min": -20,
      "y_max": 659,
      "ha": 679,
      "leftSideBearing": 29,
      "advanceWidth": 500
    },
    " ": {
      "x_min": 0,
      "x_max": 0,
      "y_min": 0,
      "y_max": 0,
      "ha": 0,
      "leftSideBearing": 0,
      "advanceWidth": 233
    },
    "!": {
      "x_min": 80,
      "x_max": 209,
      "y_min": -13,
      "y_max": 684,
      "ha": 697,
      "leftSideBearing": 80,
      "advanceWidth": 289
    },
    "\"": {
      "x_min": 40,
      "x_max": 315,
      "y_min": 429,
      "y_max": 737,
      "ha": 308,
      "leftSideBearing": 40,
      "advanceWidth": 356
    },
    "#": {
      "x_min": 25,
      "x_max": 502,
      "y_min": 0,
      "y_max": 650,
      "ha": 650,
      "leftSideBearing": 25,
      "advanceWidth": 526
    },
    "$": {
      "x_min": 51,
      "x_max": 464,
      "y_min": -115,
      "y_max": 749,
      "ha": 864,
      "leftSideBearing": 51,
      "advanceWidth": 500
    },
    "%": {
      "x_min": 69,
      "x_max": 792,
      "y_min": -25,
      "y_max": 669,
      "ha": 694,
      "leftSideBearing": 69,
      "advanceWidth": 861
    },
    "&": {
      "x_min": 27,
      "x_max": 675,
      "y_min": -13,
      "y_max": 684,
      "ha": 697,
      "leftSideBearing": 27,
      "advanceWidth": 720
    },
    "'": {
      "x_min": 40,
      "x_max": 143,
      "y_min": 429,
      "y_max": 737,
      "ha": 308,
      "leftSideBearing": 40,
      "advanceWidth": 183
    },
    "(": {
      "x_min": 80,
      "x_max": 314,
      "y_min": -192,
      "y_max": 748,
      "ha": 940,
      "leftSideBearing": 80,
      "advanceWidth": 339
    },
    ")": {
      "x_min": 25,
      "x_max": 259,
      "y_min": -192,
      "y_max": 748,
      "ha": 940,
      "leftSideBearing": 25,
      "advanceWidth": 339
    },
    "*": {
      "x_min": 20,
      "x_max": 420,
      "y_min": 363,
      "y_max": 747,
      "ha": 384,
      "leftSideBearing": 20,
      "advanceWidth": 439
    },
    "+": {
      "x_min": 29,
      "x_max": 502,
      "y_min": 77,
      "y_max": 577,
      "ha": 500,
      "leftSideBearing": 29,
      "advanceWidth": 531
    },
    ",": {
      "x_min": 6,
      "x_max": 213,
      "y_min": -224,
      "y_max": 130,
      "ha": 354,
      "leftSideBearing": 6,
      "advanceWidth": 300
    },
    "-": {
      "x_min": 40,
      "x_max": 272,
      "y_min": 218,
      "y_max": 284,
      "ha": 66,
      "leftSideBearing": 40,
      "advanceWidth": 312
    },
    ".": {
      "x_min": 79,
      "x_max": 221,
      "y_min": -13,
      "y_max": 130,
      "ha": 143,
      "leftSideBearing": 79,
      "advanceWidth": 300
    },
    "/": {
      "x_min": 2,
      "x_max": 328,
      "y_min": -160,
      "y_max": 710,
      "ha": 870,
      "leftSideBearing": 2,
      "advanceWidth": 330
    },
    ":": {
      "x_min": 79,
      "x_max": 221,
      "y_min": -13,
      "y_max": 493,
      "ha": 506,
      "leftSideBearing": 79,
      "advanceWidth": 300
    },
    ";": {
      "x_min": 6,
      "x_max": 221,
      "y_min": -224,
      "y_max": 493,
      "ha": 717,
      "leftSideBearing": 6,
      "advanceWidth": 300
    },
    "<": {
      "x_min": 57,
      "x_max": 474,
      "y_min": 81,
      "y_max": 578,
      "ha": 497,
      "leftSideBearing": 57,
      "advanceWidth": 531
    },
    "=": {
      "x_min": 29,
      "x_max": 502,
      "y_min": 201,
      "y_max": 458,
      "ha": 257,
      "leftSideBearing": 29,
      "advanceWidth": 531
    },
    ">": {
      "x_min": 57,
      "x_max": 474,
      "y_min": 81,
      "y_max": 578,
      "ha": 497,
      "leftSideBearing": 57,
      "advanceWidth": 531
    },
    "?": {
      "x_min": 66,
      "x_max": 350,
      "y_min": -13,
      "y_max": 684,
      "ha": 697,
      "leftSideBearing": 66,
      "advanceWidth": 416
    },
    "@": {
      "x_min": 36,
      "x_max": 800,
      "y_min": -155,
      "y_max": 660,
      "ha": 815,
      "leftSideBearing": 36,
      "advanceWidth": 835
    },
    "A": {
      "x_min": 5,
      "x_max": 653,
      "y_min": 0,
      "y_max": 674,
      "ha": 674,
      "leftSideBearing": 5,
      "advanceWidth": 664
    },
    "B": {
      "x_min": 44,
      "x_max": 586,
      "y_min": 0,
      "y_max": 669,
      "ha": 669,
      "leftSideBearing": 44,
      "advanceWidth": 629
    },
    "C": {
      "x_min": 47,
      "x_max": 592,
      "y_min": -15,
      "y_max": 684,
      "ha": 699,
      "leftSideBearing": 47,
      "advanceWidth": 631
    },
    "D": {
      "x_min": 44,
      "x_max": 663,
      "y_min": 0,
      "y_max": 669,
      "ha": 669,
      "leftSideBearing": 44,
      "advanceWidth": 710
    },
    "E": {
      "x_min": 44,
      "x_max": 569,
      "y_min": 0,
      "y_max": 669,
      "ha": 669,
      "leftSideBearing": 44,
      "advanceWidth": 603
    },
    "F": {
      "x_min": 44,
      "x_max": 549,
      "y_min": 0,
      "y_max": 669,
      "ha": 669,
      "leftSideBearing": 44,
      "advanceWidth": 579
    },
    "G": {
      "x_min": 47,
      "x_max": 667,
      "y_min": -15,
      "y_max": 684,
      "ha": 699,
      "leftSideBearing": 47,
      "advanceWidth": 682
    },
    "H": {
      "x_min": 44,
      "x_max": 744,
      "y_min": 0,
      "y_max": 669,
      "ha": 669,
      "leftSideBearing": 44,
      "advanceWidth": 789
    },
    "I": {
      "x_min": 44,
      "x_max": 327,
      "y_min": 0,
      "y_max": 669,
      "ha": 669,
      "leftSideBearing": 44,
      "advanceWidth": 371
    },
    "J": {
      "x_min": -43,
      "x_max": 340,
      "y_min": -163,
      "y_max": 669,
      "ha": 832,
      "leftSideBearing": -43,
      "advanceWidth": 374
    },
    "K": {
      "x_min": 44,
      "x_max": 662,
      "y_min": 0,
      "y_max": 669,
      "ha": 669,
      "leftSideBearing": 44,
      "advanceWidth": 667
    },
    "L": {
      "x_min": 44,
      "x_max": 552,
      "y_min": 0,
      "y_max": 669,
      "ha": 669,
      "leftSideBearing": 44,
      "advanceWidth": 596
    },
    "M": {
      "x_min": 39,
      "x_max": 857,
      "y_min": 0,
      "y_max": 669,
      "ha": 669,
      "leftSideBearing": 39,
      "advanceWidth": 902
    },
    "N": {
      "x_min": 39,
      "x_max": 695,
      "y_min": -7,
      "y_max": 669,
      "ha": 676,
      "leftSideBearing": 39,
      "advanceWidth": 735
    },
    "O": {
      "x_min": 47,
      "x_max": 660,
      "y_min": -15,
      "y_max": 684,
      "ha": 699,
      "leftSideBearing": 47,
      "advanceWidth": 707
    },
    "P": {
      "x_min": 44,
      "x_max": 567,
      "y_min": 0,
      "y_max": 669,
      "ha": 669,
      "leftSideBearing": 44,
      "advanceWidth": 589
    },
    "Q": {
      "x_min": 47,
      "x_max": 660,
      "y_min": -216,
      "y_max": 684,
      "ha": 900,
      "leftSideBearing": 47,
      "advanceWidth": 707
    },
    "R": {
      "x_min": 44,
      "x_max": 637,
      "y_min": -10,
      "y_max": 669,
      "ha": 679,
      "leftSideBearing": 44,
      "advanceWidth": 651
    },
    "S": {
      "x_min": 40,
      "x_max": 472,
      "y_min": -15,
      "y_max": 684,
      "ha": 699,
      "leftSideBearing": 40,
      "advanceWidth": 512
    },
    "T": {
      "x_min": 20,
      "x_max": 584,
      "y_min": 0,
      "y_max": 669,
      "ha": 669,
      "leftSideBearing": 20,
      "advanceWidth": 604
    },
    "U": {
      "x_min": 39,
      "x_max": 693,
      "y_min": -15,
      "y_max": 669,
      "ha": 684,
      "leftSideBearing": 39,
      "advanceWidth": 727
    },
    "V": {
      "x_min": 15,
      "x_max": 665,
      "y_min": -7,
      "y_max": 669,
      "ha": 676,
      "leftSideBearing": 15,
      "advanceWidth": 674
    },
    "W": {
      "x_min": 15,
      "x_max": 953,
      "y_min": -7,
      "y_max": 669,
      "ha": 676,
      "leftSideBearing": 15,
      "advanceWidth": 962
    },
    "X": {
      "x_min": 10,
      "x_max": 639,
      "y_min": 0,
      "y_max": 669,
      "ha": 669,
      "leftSideBearing": 10,
      "advanceWidth": 648
    },
    "Y": {
      "x_min": 15,
      "x_max": 623,
      "y_min": 0,
      "y_max": 669,
      "ha": 669,
      "leftSideBearing": 15,
      "advanceWidth": 633
    },
    "Z": {
      "x_min": 20,
      "x_max": 531,
      "y_min": 0,
      "y_max": 669,
      "ha": 669,
      "leftSideBearing": 20,
      "advanceWidth": 551
    },
    "[": {
      "x_min": 100,
      "x_max": 291,
      "y_min": -159,
      "y_max": 715,
      "ha": 874,
      "leftSideBearing": 100,
      "advanceWidth": 320
    },
    "\\": {
      "x_min": 2,
      "x_max": 328,
      "y_min": -160,
      "y_max": 710,
      "ha": 870,
      "leftSideBearing": 2,
      "advanceWidth": 330
    },
    "]": {
      "x_min": 29,
      "x_max": 220,
      "y_min": -159,
      "y_max": 715,
      "ha": 874,
      "leftSideBearing": 29,
      "advanceWidth": 320
    },
    "^": {
      "x_min": 88,
      "x_max": 446,
      "y_min": 208,
      "y_max": 481,
      "ha": 273,
      "leftSideBearing": 88,
      "advanceWidth": 531
    },
    "_": {
      "x_min": 40,
      "x_max": 472,
      "y_min": -66,
      "y_max": 0,
      "ha": 66,
      "leftSideBearing": 40,
      "advanceWidth": 512
    },
    "`": {
      "x_min": 75,
      "x_max": 256,
      "y_min": 557,
      "y_max": 758,
      "ha": 201,
      "leftSideBearing": 75,
      "advanceWidth": 400
    },
    "a": {
      "x_min": 45,
      "x_max": 503,
      "y_min": -13,
      "y_max": 488,
      "ha": 501,
      "leftSideBearing": 45,
      "advanceWidth": 509
    },
    "b": {
      "x_min": 25,
      "x_max": 532,
      "y_min": -13,
      "y_max": 739,
      "ha": 752,
      "leftSideBearing": 25,
      "advanceWidth": 577
    },
    "c": {
      "x_min": 42,
      "x_max": 453,
      "y_min": -13,
      "y_max": 488,
      "ha": 501,
      "leftSideBearing": 42,
      "advanceWidth": 488
    },
    "d": {
      "x_min": 45,
      "x_max": 551,
      "y_min": -13,
      "y_max": 739,
      "ha": 752,
      "leftSideBearing": 45,
      "advanceWidth": 567
    },
    "e": {
      "x_min": 45,
      "x_max": 461,
      "y_min": -13,
      "y_max": 488,
      "ha": 501,
      "leftSideBearing": 45,
      "advanceWidth": 510
    },
    "f": {
      "x_min": 34,
      "x_max": 426,
      "y_min": 0,
      "y_max": 749,
      "ha": 749,
      "leftSideBearing": 34,
      "advanceWidth": 354
    },
    "g": {
      "x_min": 36,
      "x_max": 495,
      "y_min": -239,
      "y_max": 488,
      "ha": 727,
      "leftSideBearing": 36,
      "advanceWidth": 518
    },
    "h": {
      "x_min": 25,
      "x_max": 571,
      "y_min": 0,
      "y_max": 739,
      "ha": 739,
      "leftSideBearing": 25,
      "advanceWidth": 601
    },
    "i": {
      "x_min": 29,
      "x_max": 267,
      "y_min": 0,
      "y_max": 726,
      "ha": 726,
      "leftSideBearing": 29,
      "advanceWidth": 298
    },
    "j": {
      "x_min": -83,
      "x_max": 220,
      "y_min": -249,
      "y_max": 726,
      "ha": 975,
      "leftSideBearing": -83,
      "advanceWidth": 277
    },
    "k": {
      "x_min": 25,
      "x_max": 547,
      "y_min": 0,
      "y_max": 739,
      "ha": 739,
      "leftSideBearing": 25,
      "advanceWidth": 547
    },
    "l": {
      "x_min": 25,
      "x_max": 273,
      "y_min": 0,
      "y_max": 739,
      "ha": 739,
      "leftSideBearing": 25,
      "advanceWidth": 298
    },
    "m": {
      "x_min": 34,
      "x_max": 872,
      "y_min": 0,
      "y_max": 488,
      "ha": 488,
      "leftSideBearing": 34,
      "advanceWidth": 901
    },
    "n": {
      "x_min": 34,
      "x_max": 576,
      "y_min": 0,
      "y_max": 488,
      "ha": 488,
      "leftSideBearing": 34,
      "advanceWidth": 606
    },
    "o": {
      "x_min": 45,
      "x_max": 504,
      "y_min": -13,
      "y_max": 488,
      "ha": 501,
      "leftSideBearing": 45,
      "advanceWidth": 549
    },
    "p": {
      "x_min": 35,
      "x_max": 538,
      "y_min": -239,
      "y_max": 488,
      "ha": 727,
      "leftSideBearing": 35,
      "advanceWidth": 583
    },
    "q": {
      "x_min": 45,
      "x_max": 556,
      "y_min": -239,
      "y_max": 488,
      "ha": 727,
      "leftSideBearing": 45,
      "advanceWidth": 557
    },
    "r": {
      "x_min": 34,
      "x_max": 416,
      "y_min": 0,
      "y_max": 488,
      "ha": 488,
      "leftSideBearing": 34,
      "advanceWidth": 423
    },
    "s": {
      "x_min": 47,
      "x_max": 395,
      "y_min": -13,
      "y_max": 488,
      "ha": 501,
      "leftSideBearing": 47,
      "advanceWidth": 434
    },
    "t": {
      "x_min": 9,
      "x_max": 323,
      "y_min": -13,
      "y_max": 611,
      "ha": 624,
      "leftSideBearing": 9,
      "advanceWidth": 325
    },
    "u": {
      "x_min": 25,
      "x_max": 549,
      "y_min": -13,
      "y_max": 481,
      "ha": 494,
      "leftSideBearing": 25,
      "advanceWidth": 583
    },
    "v": {
      "x_min": 0,
      "x_max": 496,
      "y_min": -6,
      "y_max": 475,
      "ha": 481,
      "leftSideBearing": 0,
      "advanceWidth": 505
    },
    "w": {
      "x_min": 0,
      "x_max": 754,
      "y_min": -6,
      "y_max": 475,
      "ha": 481,
      "leftSideBearing": 0,
      "advanceWidth": 764
    },
    "x": {
      "x_min": 10,
      "x_max": 516,
      "y_min": 0,
      "y_max": 475,
      "ha": 475,
      "leftSideBearing": 10,
      "advanceWidth": 526
    },
    "y": {
      "x_min": 0,
      "x_max": 512,
      "y_min": -249,
      "y_max": 475,
      "ha": 724,
      "leftSideBearing": 0,
      "advanceWidth": 512
    },
    "z": {
      "x_min": 29,
      "x_max": 431,
      "y_min": 0,
      "y_max": 475,
      "ha": 475,
      "leftSideBearing": 29,
      "advanceWidth": 456
    },
    "{": {
      "x_min": 40,
      "x_max": 314,
      "y_min": -159,
      "y_max": 715,
      "ha": 874,
      "leftSideBearing": 40,
      "advanceWidth": 344
    },
    "|": {
      "x_min": 96,
      "x_max": 155,
      "y_min": -250,
      "y_max": 750,
      "ha": 1000,
      "leftSideBearing": 96,
      "advanceWidth": 251
    },
    "}": {
      "x_min": 30,
      "x_max": 304,
      "y_min": -159,
      "y_max": 715,
      "ha": 874,
      "leftSideBearing": 30,
      "advanceWidth": 344
    },
    "~": {
      "x_min": 49,
      "x_max": 482,
      "y_min": 268,
      "y_max": 422,
      "ha": 154,
      "leftSideBearing": 49,
      "advanceWidth": 531
    }
  },
  "generatedOn": "2020-11-01T21:35:39.674Z"
};
;const TimesFont = {
  smufl: false,
  name: "Times New Roman",
  spacing: 50,
  Description: 'Built-in serif font',
  bold: true,
  italic: true,
  monospaced: false,
  serifs: true,

  "glyphs": {
    "0": {
      "x_min": 49,
      "x_max": 975,
      "y_min": -27,
      "y_max": 1383,
      "ha": 1410,
      "leftSideBearing": 49,
      "advanceWidth": 1024
    },
    "1": {
      "x_min": 227,
      "x_max": 811,
      "y_min": 0,
      "y_max": 1383,
      "ha": 1383,
      "leftSideBearing": 227,
      "advanceWidth": 1024
    },
    "2": {
      "x_min": 61,
      "x_max": 965,
      "y_min": 0,
      "y_max": 1383,
      "ha": 1383,
      "leftSideBearing": 61,
      "advanceWidth": 1024
    },
    "3": {
      "x_min": 88,
      "x_max": 883,
      "y_min": -27,
      "y_max": 1383,
      "ha": 1410,
      "leftSideBearing": 88,
      "advanceWidth": 1024
    },
    "4": {
      "x_min": 25,
      "x_max": 967,
      "y_min": 0,
      "y_max": 1384,
      "ha": 1384,
      "leftSideBearing": 25,
      "advanceWidth": 1024
    },
    "5": {
      "x_min": 66,
      "x_max": 898,
      "y_min": -27,
      "y_max": 1409,
      "ha": 1436,
      "leftSideBearing": 66,
      "advanceWidth": 1024
    },
    "6": {
      "x_min": 70,
      "x_max": 958,
      "y_min": -27,
      "y_max": 1401,
      "ha": 1428,
      "leftSideBearing": 70,
      "advanceWidth": 1024
    },
    "7": {
      "x_min": 41,
      "x_max": 920,
      "y_min": -16,
      "y_max": 1356,
      "ha": 1372,
      "leftSideBearing": 41,
      "advanceWidth": 1024
    },
    "8": {
      "x_min": 115,
      "x_max": 911,
      "y_min": -27,
      "y_max": 1383,
      "ha": 1410,
      "leftSideBearing": 115,
      "advanceWidth": 1024
    },
    "9": {
      "x_min": 61,
      "x_max": 940,
      "y_min": -41,
      "y_max": 1383,
      "ha": 1424,
      "leftSideBearing": 61,
      "advanceWidth": 1024
    },
    " ": {
      "x_min": 0,
      "x_max": 0,
      "y_min": 0,
      "y_max": 0,
      "ha": 0,
      "leftSideBearing": 0,
      "advanceWidth": 512
    },
    "!": {
      "x_min": 266,
      "x_max": 488,
      "y_min": -22,
      "y_max": 1383,
      "ha": 1405,
      "leftSideBearing": 266,
      "advanceWidth": 682
    },
    "\"": {
      "x_min": 157.2000021972655,
      "x_max": 678.2500021457677,
      "y_min": 881,
      "y_max": 1385,
      "ha": 504,
      "leftSideBearing": 157,
      "advanceWidth": 836
    },
    "#": {
      "x_min": 10,
      "x_max": 1016,
      "y_min": -1,
      "y_max": 1356,
      "ha": 1357,
      "leftSideBearing": 10,
      "advanceWidth": 1024
    },
    "$": {
      "x_min": 90,
      "x_max": 936,
      "y_min": -180,
      "y_max": 1492,
      "ha": 1672,
      "leftSideBearing": 90,
      "advanceWidth": 1024
    },
    "%": {
      "x_min": 125,
      "x_max": 1581,
      "y_min": -30,
      "y_max": 1388,
      "ha": 1418,
      "leftSideBearing": 125,
      "advanceWidth": 1706
    },
    "&": {
      "x_min": 86,
      "x_max": 1536,
      "y_min": -28,
      "y_max": 1383,
      "ha": 1411,
      "leftSideBearing": 86,
      "advanceWidth": 1593
    },
    "'": {
      "x_min": 97.20000219726548,
      "x_max": 273.2500021457677,
      "y_min": 881,
      "y_max": 1385,
      "ha": 504,
      "leftSideBearing": 97,
      "advanceWidth": 369
    },
    "(": {
      "x_min": 98,
      "x_max": 623,
      "y_min": -363,
      "y_max": 1383,
      "ha": 1746,
      "leftSideBearing": 98,
      "advanceWidth": 682
    },
    ")": {
      "x_min": 59,
      "x_max": 584,
      "y_min": -363,
      "y_max": 1383,
      "ha": 1746,
      "leftSideBearing": 59,
      "advanceWidth": 682
    },
    "*": {
      "x_min": 137.96078522291893,
      "x_max": 886.039214777081,
      "y_min": 543,
      "y_max": 1383,
      "ha": 840,
      "leftSideBearing": 137,
      "advanceWidth": 1024
    },
    "+": {
      "x_min": 61,
      "x_max": 1093,
      "y_min": 2,
      "y_max": 1034,
      "ha": 1032,
      "leftSideBearing": 61,
      "advanceWidth": 1155
    },
    ",": {
      "x_min": 115,
      "x_max": 399,
      "y_min": -291,
      "y_max": 208,
      "ha": 499,
      "leftSideBearing": 115,
      "advanceWidth": 512
    },
    "-": {
      "x_min": 80,
      "x_max": 584,
      "y_min": 396,
      "y_max": 525,
      "ha": 129,
      "leftSideBearing": 80,
      "advanceWidth": 682
    },
    ".": {
      "x_min": 143,
      "x_max": 371,
      "y_min": -22,
      "y_max": 205,
      "ha": 227,
      "leftSideBearing": 143,
      "advanceWidth": 512
    },
    "/": {
      "x_min": -17,
      "x_max": 586,
      "y_min": -27,
      "y_max": 1383,
      "ha": 1410,
      "leftSideBearing": -17,
      "advanceWidth": 569
    },
    ":": {
      "x_min": 166,
      "x_max": 394,
      "y_min": -22,
      "y_max": 943,
      "ha": 965,
      "leftSideBearing": 166,
      "advanceWidth": 569
    },
    ";": {
      "x_min": 164,
      "x_max": 448,
      "y_min": -290,
      "y_max": 943,
      "ha": 1233,
      "leftSideBearing": 164,
      "advanceWidth": 569
    },
    "<": {
      "x_min": 57,
      "x_max": 1098,
      "y_min": -15,
      "y_max": 1051,
      "ha": 1066,
      "leftSideBearing": 57,
      "advanceWidth": 1155
    },
    "=": {
      "x_min": 61,
      "x_max": 1093,
      "y_min": 246,
      "y_max": 791,
      "ha": 545,
      "leftSideBearing": 61,
      "advanceWidth": 1155
    },
    ">": {
      "x_min": 57,
      "x_max": 1098,
      "y_min": -15,
      "y_max": 1051,
      "ha": 1066,
      "leftSideBearing": 57,
      "advanceWidth": 1155
    },
    "?": {
      "x_min": 139,
      "x_max": 848,
      "y_min": -15,
      "y_max": 1383,
      "ha": 1398,
      "leftSideBearing": 139,
      "advanceWidth": 909
    },
    "@": {
      "x_min": 238,
      "x_max": 1657,
      "y_min": -29,
      "y_max": 1386,
      "ha": 1415,
      "leftSideBearing": 238,
      "advanceWidth": 1886
    },
    "A": {
      "x_min": 31,
      "x_max": 1445,
      "y_min": 0,
      "y_max": 1380,
      "ha": 1380,
      "leftSideBearing": 31,
      "advanceWidth": 1479
    },
    "B": {
      "x_min": 35,
      "x_max": 1214,
      "y_min": 0,
      "y_max": 1356,
      "ha": 1356,
      "leftSideBearing": 35,
      "advanceWidth": 1366
    },
    "C": {
      "x_min": 57,
      "x_max": 1296,
      "y_min": -28,
      "y_max": 1383,
      "ha": 1411,
      "leftSideBearing": 57,
      "advanceWidth": 1366
    },
    "D": {
      "x_min": 33,
      "x_max": 1403,
      "y_min": 0,
      "y_max": 1356,
      "ha": 1356,
      "leftSideBearing": 33,
      "advanceWidth": 1479
    },
    "E": {
      "x_min": 25,
      "x_max": 1222,
      "y_min": 0,
      "y_max": 1356,
      "ha": 1356,
      "leftSideBearing": 25,
      "advanceWidth": 1251
    },
    "F": {
      "x_min": 25,
      "x_max": 1119,
      "y_min": 0,
      "y_max": 1356,
      "ha": 1356,
      "leftSideBearing": 25,
      "advanceWidth": 1139
    },
    "G": {
      "x_min": 66,
      "x_max": 1452,
      "y_min": -28,
      "y_max": 1383,
      "ha": 1411,
      "leftSideBearing": 66,
      "advanceWidth": 1479
    },
    "H": {
      "x_min": 39,
      "x_max": 1438,
      "y_min": 0,
      "y_max": 1356,
      "ha": 1356,
      "leftSideBearing": 39,
      "advanceWidth": 1479
    },
    "I": {
      "x_min": 37,
      "x_max": 642,
      "y_min": 0,
      "y_max": 1356,
      "ha": 1356,
      "leftSideBearing": 37,
      "advanceWidth": 682
    },
    "J": {
      "x_min": 20,
      "x_max": 758,
      "y_min": -28,
      "y_max": 1356,
      "ha": 1384,
      "leftSideBearing": 20,
      "advanceWidth": 797
    },
    "K": {
      "x_min": 70,
      "x_max": 1479,
      "y_min": 0,
      "y_max": 1356,
      "ha": 1356,
      "leftSideBearing": 70,
      "advanceWidth": 1479
    },
    "L": {
      "x_min": 25,
      "x_max": 1224,
      "y_min": 0,
      "y_max": 1356,
      "ha": 1356,
      "leftSideBearing": 25,
      "advanceWidth": 1251
    },
    "M": {
      "x_min": 25,
      "x_max": 1768,
      "y_min": 0,
      "y_max": 1356,
      "ha": 1356,
      "leftSideBearing": 25,
      "advanceWidth": 1821
    },
    "N": {
      "x_min": 25,
      "x_max": 1450,
      "y_min": -22,
      "y_max": 1356,
      "ha": 1378,
      "leftSideBearing": 25,
      "advanceWidth": 1479
    },
    "O": {
      "x_min": 70,
      "x_max": 1409,
      "y_min": -28,
      "y_max": 1383,
      "ha": 1411,
      "leftSideBearing": 70,
      "advanceWidth": 1479
    },
    "P": {
      "x_min": 33,
      "x_max": 1110,
      "y_min": 0,
      "y_max": 1356,
      "ha": 1356,
      "leftSideBearing": 33,
      "advanceWidth": 1139
    },
    "Q": {
      "x_min": 70,
      "x_max": 1435,
      "y_min": -364.28571588721996,
      "y_max": 1383,
      "ha": 1747.28571588722,
      "leftSideBearing": 70,
      "advanceWidth": 1479
    },
    "R": {
      "x_min": 35,
      "x_max": 1347,
      "y_min": 0,
      "y_max": 1356,
      "ha": 1356,
      "leftSideBearing": 35,
      "advanceWidth": 1366
    },
    "S": {
      "x_min": 86,
      "x_max": 1006,
      "y_min": -28,
      "y_max": 1383,
      "ha": 1411,
      "leftSideBearing": 86,
      "advanceWidth": 1139
    },
    "T": {
      "x_min": 35,
      "x_max": 1214,
      "y_min": 0,
      "y_max": 1356,
      "ha": 1356,
      "leftSideBearing": 35,
      "advanceWidth": 1251
    },
    "U": {
      "x_min": 29,
      "x_max": 1444,
      "y_min": -28,
      "y_max": 1356,
      "ha": 1384,
      "leftSideBearing": 29,
      "advanceWidth": 1479
    },
    "V": {
      "x_min": 33,
      "x_max": 1428,
      "y_min": -22,
      "y_max": 1356,
      "ha": 1378,
      "leftSideBearing": 33,
      "advanceWidth": 1479
    },
    "W": {
      "x_min": 10,
      "x_max": 1906,
      "y_min": -22,
      "y_max": 1356,
      "ha": 1378,
      "leftSideBearing": 10,
      "advanceWidth": 1933
    },
    "X": {
      "x_min": 20,
      "x_max": 1449,
      "y_min": 0,
      "y_max": 1356,
      "ha": 1356,
      "leftSideBearing": 20,
      "advanceWidth": 1479
    },
    "Y": {
      "x_min": 45,
      "x_max": 1441,
      "y_min": 0,
      "y_max": 1356,
      "ha": 1356,
      "leftSideBearing": 45,
      "advanceWidth": 1479
    },
    "Z": {
      "x_min": 18,
      "x_max": 1222,
      "y_min": 0,
      "y_max": 1356,
      "ha": 1356,
      "leftSideBearing": 18,
      "advanceWidth": 1251
    },
    "[": {
      "x_min": 180,
      "x_max": 612,
      "y_min": -319,
      "y_max": 1355,
      "ha": 1674,
      "leftSideBearing": 180,
      "advanceWidth": 682
    },
    "\\": {
      "x_min": -17,
      "x_max": 586,
      "y_min": -27,
      "y_max": 1383,
      "ha": 1410,
      "leftSideBearing": -17,
      "advanceWidth": 569
    },
    "]": {
      "x_min": 70,
      "x_max": 502,
      "y_min": -319,
      "y_max": 1355,
      "ha": 1674,
      "leftSideBearing": 70,
      "advanceWidth": 682
    },
    "^": {
      "x_min": 49,
      "x_max": 914,
      "y_min": 608,
      "y_max": 1355,
      "ha": 747,
      "leftSideBearing": 49,
      "advanceWidth": 961
    },
    "_": {
      "x_min": 0,
      "x_max": 1024,
      "y_min": -255,
      "y_max": -153,
      "ha": 102,
      "leftSideBearing": 0,
      "advanceWidth": 1024
    },
    "`": {
      "x_min": 39,
      "x_max": 499,
      "y_min": 1037,
      "y_max": 1392.509803639748,
      "ha": 355.50980363974804,
      "leftSideBearing": 39,
      "advanceWidth": 682
    },
    "a": {
      "x_min": 76,
      "x_max": 905,
      "y_min": -20,
      "y_max": 942,
      "ha": 962,
      "leftSideBearing": 76,
      "advanceWidth": 909
    },
    "b": {
      "x_min": 6,
      "x_max": 958,
      "y_min": -20,
      "y_max": 1399,
      "ha": 1419,
      "leftSideBearing": 6,
      "advanceWidth": 1024
    },
    "c": {
      "x_min": 51,
      "x_max": 843,
      "y_min": -20,
      "y_max": 942,
      "ha": 962,
      "leftSideBearing": 51,
      "advanceWidth": 909
    },
    "d": {
      "x_min": 55,
      "x_max": 1006,
      "y_min": -20,
      "y_max": 1399,
      "ha": 1419,
      "leftSideBearing": 55,
      "advanceWidth": 1024
    },
    "e": {
      "x_min": 51,
      "x_max": 868,
      "y_min": -20,
      "y_max": 942,
      "ha": 962,
      "leftSideBearing": 51,
      "advanceWidth": 909
    },
    "f": {
      "x_min": 41,
      "x_max": 783,
      "y_min": 0,
      "y_max": 1399,
      "ha": 1399,
      "leftSideBearing": 41,
      "advanceWidth": 682
    },
    "g": {
      "x_min": 57,
      "x_max": 963,
      "y_min": -446,
      "y_max": 942,
      "ha": 1388,
      "leftSideBearing": 57,
      "advanceWidth": 1024
    },
    "h": {
      "x_min": 18,
      "x_max": 997,
      "y_min": 0,
      "y_max": 1399,
      "ha": 1399,
      "leftSideBearing": 18,
      "advanceWidth": 1024
    },
    "i": {
      "x_min": 33,
      "x_max": 516,
      "y_min": 0,
      "y_max": 1399,
      "ha": 1399,
      "leftSideBearing": 33,
      "advanceWidth": 569
    },
    "j": {
      "x_min": -142,
      "x_max": 397,
      "y_min": -446,
      "y_max": 1399,
      "ha": 1845,
      "leftSideBearing": -142,
      "advanceWidth": 569
    },
    "k": {
      "x_min": 14,
      "x_max": 1029,
      "y_min": 0,
      "y_max": 1399,
      "ha": 1399,
      "leftSideBearing": 14,
      "advanceWidth": 1024
    },
    "l": {
      "x_min": 39,
      "x_max": 523,
      "y_min": 0,
      "y_max": 1399,
      "ha": 1399,
      "leftSideBearing": 39,
      "advanceWidth": 569
    },
    "m": {
      "x_min": 33,
      "x_max": 1587,
      "y_min": 0,
      "y_max": 944,
      "ha": 944,
      "leftSideBearing": 33,
      "advanceWidth": 1593
    },
    "n": {
      "x_min": 33,
      "x_max": 993,
      "y_min": 0,
      "y_max": 944,
      "ha": 944,
      "leftSideBearing": 33,
      "advanceWidth": 1024
    },
    "o": {
      "x_min": 59,
      "x_max": 963,
      "y_min": -20,
      "y_max": 942,
      "ha": 962,
      "leftSideBearing": 59,
      "advanceWidth": 1024
    },
    "p": {
      "x_min": 10,
      "x_max": 964,
      "y_min": -443,
      "y_max": 944,
      "ha": 1387,
      "leftSideBearing": 10,
      "advanceWidth": 1024
    },
    "q": {
      "x_min": 49,
      "x_max": 999,
      "y_min": -443,
      "y_max": 942.0135137169275,
      "ha": 1385.0135137169275,
      "leftSideBearing": 49,
      "advanceWidth": 1024
    },
    "r": {
      "x_min": 10,
      "x_max": 685,
      "y_min": 0,
      "y_max": 944,
      "ha": 944,
      "leftSideBearing": 10,
      "advanceWidth": 682
    },
    "s": {
      "x_min": 104,
      "x_max": 713,
      "y_min": -20,
      "y_max": 942.0263161804552,
      "ha": 962.0263161804552,
      "leftSideBearing": 104,
      "advanceWidth": 797
    },
    "t": {
      "x_min": 27,
      "x_max": 572,
      "y_min": -18,
      "y_max": 1186,
      "ha": 1204,
      "leftSideBearing": 27,
      "advanceWidth": 569
    },
    "u": {
      "x_min": 18,
      "x_max": 981,
      "y_min": -21,
      "y_max": 921,
      "ha": 942,
      "leftSideBearing": 18,
      "advanceWidth": 1024
    },
    "v": {
      "x_min": 39,
      "x_max": 976,
      "y_min": -28,
      "y_max": 921,
      "ha": 949,
      "leftSideBearing": 39,
      "advanceWidth": 1024
    },
    "w": {
      "x_min": 43,
      "x_max": 1423,
      "y_min": -28,
      "y_max": 921,
      "ha": 949,
      "leftSideBearing": 43,
      "advanceWidth": 1479
    },
    "x": {
      "x_min": 35,
      "x_max": 989,
      "y_min": 0,
      "y_max": 921,
      "ha": 921,
      "leftSideBearing": 35,
      "advanceWidth": 1024
    },
    "y": {
      "x_min": 29,
      "x_max": 976,
      "y_min": -445,
      "y_max": 921,
      "ha": 1366,
      "leftSideBearing": 29,
      "advanceWidth": 1024
    },
    "z": {
      "x_min": 55,
      "x_max": 855,
      "y_min": 0,
      "y_max": 921,
      "ha": 921,
      "leftSideBearing": 55,
      "advanceWidth": 909
    },
    "{": {
      "x_min": 205,
      "x_max": 717,
      "y_min": -377,
      "y_max": 1397,
      "ha": 1774,
      "leftSideBearing": 205,
      "advanceWidth": 983
    },
    "|": {
      "x_min": 137,
      "x_max": 273,
      "y_min": -512,
      "y_max": 1535,
      "ha": 2047,
      "leftSideBearing": 137,
      "advanceWidth": 410
    },
    "}": {
      "x_min": 266,
      "x_max": 778,
      "y_min": -377,
      "y_max": 1397,
      "ha": 1774,
      "leftSideBearing": 266,
      "advanceWidth": 983
    },
    "~": {
      "x_min": 82,
      "x_max": 1028,
      "y_min": 380,
      "y_max": 666,
      "ha": 286,
      "leftSideBearing": 82,
      "advanceWidth": 1108
    }
  },
  "fontFamily": "Times",
  "resolution": 2048,
  "generatedOn": "2020-10-18T19:03:12.514Z"
};
;class SuiApplication {
  static get defaultConfig() {
    return {
      smoPath: '..',
      language: 'en',
      scoreLoadOrder: ['query', 'local', 'library'],
      scoreLoadJson: 'basicJson',
      eventsSource: 'browserEventSource',
      controller: 'suiController',
      smoDomContainer: 'smoo',
      vexDomContainer: 'boo',
      domSource:' SuiDom',
      ribbon: true,
      keyCommands: true,
      menus: true,
      title: 'Smoosic',
      languageDir: 'ltr',
      demonPollTime: 50, // how often we poll the score to see if it changed
      idleRedrawTime: 1000, // maximum time between score modification and render
    }
  }
  static configure(params) {
    var config = {};
    Vex.Merge(config, SuiApplication.defaultConfig);
    Vex.Merge(config, params);
    window.SmoConfig = config;
    SuiApplication.registerFonts();
  }

  constructor(params) {
    SuiApplication.configure(params);
    this.startApplication();
  }
  startApplication() {
    var score = null;
    for (var i = 0; i < SmoConfig.scoreLoadOrder.length; ++i) {
      const loader = SmoConfig.scoreLoadOrder[i];
      const method = loader + 'ScoreLoad';
      const ss = this[method]();
      if (ss) {
        score = ss;
        break;
      }
    }
    // var controller =
    this.createUi(score);
  }

  // ## createUi
  // ### Description:
  // Convenience constructor, taking a renderElement and a score.
  createUi(score) {
    eval(SmoConfig.domSource).createDom();
    var params = suiController.keyBindingDefaults;
    params.eventSource = new browserEventSource(); // events come from the browser UI.

    const scoreRenderer = SuiScoreRender.createScoreRenderer(document.getElementById(SmoConfig.vexDomContainer), score);
    params.eventSource.setRenderElement(scoreRenderer.renderElement);
    params.view = new SuiScoreViewOperations(scoreRenderer, score, '.musicRelief');
    if (SmoConfig.keyCommands) {
      params.keyCommands = new SuiKeyCommands(params);
    }
    if (SmoConfig.menus) {
      params.menus = new suiMenuManager(params);
    }
    params.layoutDemon = new SuiRenderDemon(params);
    var ctor = eval(SmoConfig.controller);
    var controller = new ctor(params);
    eval(SmoConfig.domSource).splash();
    this.controller = controller;
  }
  static registerFonts() {
    VF.TextFont.registerFont({
      name: ArialFont.name,
      resolution: ArialFont.resolution,
      glyphs: ArialFont.glyphs,
      family: ArialFont.fontFamily,
      serifs: false,
      monospaced: false,
      italic: true,
      bold: true,
      maxSizeGlyph: 'H',
      superscriptOffset: 0.66,
      subscriptOffset: 0.66,
      description: 'Built-in sans font',
    });
    VF.TextFont.registerFont({
      name: TimesFont.name,
      resolution: TimesFont.resolution,
      glyphs: TimesFont.glyphs,
      family: TimesFont.fontFamily,
      serifs: false,
      monospaced: false,
      italic: true,
      bold: true,
      maxSizeGlyph: 'H',
      superscriptOffset: 0.66,
      subscriptOffset: 0.66,
      description: 'Built-in serif font',
    });
    VF.TextFont.registerFont({
      name: Commissioner_MediumFont.name,
      resolution: Commissioner_MediumFont.resolution,
      glyphs: Commissioner_MediumFont.glyphs,
      family: Commissioner_MediumFont.fontFamily,
      serifs: false,
      monospaced: false,
      italic: false,
      bold: false,
      maxSizeGlyph: 'H',
      superscriptOffset: 0.66,
      subscriptOffset: 0.66,
      description: 'Low-contrast sans-serif text font',
    });
    VF.TextFont.registerFont({
      name: Concert_OneFont.name,
      resolution: Concert_OneFont.resolution,
      glyphs: Concert_OneFont.glyphs,
      family: Concert_OneFont.fontFamily,
      serifs: false,
      monospaced: false,
      italic: false,
      bold: false,
      maxSizeGlyph: 'H',
      superscriptOffset: 0.66,
      subscriptOffset: 0.66,
      description: 'Rounded grotesque typeface inspired by 19th century 3D l',
    });
    VF.TextFont.registerFont({
      name: MerriweatherFont.name,
      resolution: MerriweatherFont.resolution,
      glyphs: MerriweatherFont.glyphs,
      family: MerriweatherFont.fontFamily,
      serifs: true,
      monospaced: false,
      italic: false,
      bold: false,
      maxSizeGlyph: 'H',
      superscriptOffset: 0.66,
      subscriptOffset: 0.66,
      description: 'Serif screen font from Sorkin Type',
    });
    VF.TextFont.registerFont({
      name: SourceSansProFont.name,
      resolution: SourceSansProFont.resolution,
      glyphs: SourceSansProFont.glyphs,
      family: SourceSansProFont.fontFamily,
      serifs: false,
      monospaced: false,
      italic: false,
      bold: false,
      maxSizeGlyph: 'H',
      superscriptOffset: 0.66,
      subscriptOffset: 0.66,
      description: 'Open source Sans screen font from Adobe',
    });
    VF.TextFont.registerFont({
      name: SourceSerifProFont.name,
      resolution: SourceSerifProFont.resolution,
      glyphs: SourceSerifProFont.glyphs,
      family: SourceSerifProFont.fontFamily,
      serifs: false,
      monospaced: false,
      italic: false,
      bold: false,
      maxSizeGlyph: 'H',
      superscriptOffset: 0.66,
      subscriptOffset: 0.66,
      description: 'Open source Serif screen font from Adobe',
    });
  }

  static _nvQueryPair(str) {
    var ar = str.split('=');
    var rv = {};
    for (var i =  0;i < ar.length - 1;i += 2) {
      var name = decodeURIComponent(ar[i]);
      rv[name] = decodeURIComponent(ar[i+1]);
    }
    return rv;
  }

  localScoreLoad() {
    var score = null;
    var scoreStr = localStorage.getItem(smoSerialize.localScore);
    if (scoreStr && scoreStr.length) {
      try {
        score = SmoScore.deserialize(scoreStr);
      } catch (exp) {
        console.log('could not parse '+scoreStr);
      }
    }
    return score;
  }

  queryScoreLoad() {
    var score = null;
    if (window.location.search) {
      var cmd = window.location.search.substring(1,window.location.search.length);
      var cmds = cmd.split('&');
      cmds.forEach((cmd) => {
        var pairs = SuiApplication._nvQueryPair(cmd);
        if (pairs['score']) {
          try {
            score = SmoScore.deserialize(eval(pairs['score']));
          } catch (exp) {
            console.log('could not parse '+exp);
          }
        } else if (pairs['lang']) {
          SuiApplication._deferLanguageSelection(pairs['lang']);
        } else if (pairs['translate']) {
          SuiApplication._deferCreateTranslator(pairs['translate']);
        }
      });
    }
    return score;
  }

  static _deferCreateTranslator(lang) {
    setTimeout(() => {
      var transDom =  SmoTranslationEditor.startEditor(lang);
    }, 1);
  }

  static _deferLanguageSelection(lang) {
    setTimeout(function() {
      SmoTranslator.setLanguage(lang);
    },1);
  }

  libraryScoreLoad() {
    if (typeof(SmoConfig.scoreLoadJson) != 'undefined') {
      return SmoScore.deserialize(eval(SmoConfig.scoreLoadJson));
    }
  }

}
;

// ## suiController
// ## Description:
// Manages DOM events and binds keyboard and mouse events
// to editor and menu commands, tracker and layout manager.
// ### Event model:
// Events can come from the following sources:
// 1. menus or dialogs can send dialogDismiss or menuDismiss event, indicating a modal has been dismissed.
// 2. window resize events
// 3. keyboard, when in editor mode.  When modals or dialogs are active, wait for dismiss event
// 4. svg piano key events smo-piano-key
// 5. tracker change events tracker-selection
class suiController {

  constructor(params) {
    Vex.Merge(this, suiController.defaults);
    Vex.Merge(this, params);
    window.suiControllerInstance = this;

    this.view = params.view;
    this.eventSource = params.eventSource;
    this.view.tracker.setDialogModifier(this);
    this.tracker = this.view.tracker; // needed for key event handling
    this.keyCommands.controller = this;
    this.keyCommands.view = this.view;
    this.resizing = false;
    this.undoStatus=0;
    this.trackScrolling = false;

    this.keyHandlerObj = null;

    this.ribbon = new RibbonButtons({
      ribbons: defaultRibbonLayout.ribbons,
      ribbonButtons: defaultRibbonLayout.ribbonButtons,
      menus: this.menus,
      controller: this,
      keyCommands: this.keyCommands,
      view: this.view,
      eventSource:this.eventSource
    });

    this.menus.setController(this);

    // create globbal exception instance
    this.exhandler = new SuiExceptionHandler(this);

    this.bindEvents();

    // Only display the ribbon one time b/c it's expensive operation
    this.ribbon.display();
    this.bindResize();
    this.view.startRenderingEngine();
    this.createPiano();
  }

  static get scrollable() {
    return '.musicRelief';
  }

  static get keyboardWidget() {
    return suiController._kbWidget;
  }

  static set keyboardWidget(value) {
    suiController._kbWidget = value;
    if (suiController._kbWidget) {
      Qwerty.displayKb();
    }
  }

  get isLayoutQuiet() {
    return ((this.view.renderer.passState == SuiRenderState.passStates.clean && this.renderer.layout.dirty == false)
       || this.view.renderer.passState == SuiRenderState.passStates.replace);
  }

  handleScrollEvent(ev) {
    const self = this;
    if (self.trackScrolling) {
        return;
    }
    self.trackScrolling = true;
    setTimeout(function() {
      try {
        // wait until redraw is done to track scroll events.
        self.trackScrolling = false;
          // Thisi s a WIP...
        self.view.tracker.scroller.handleScroll($(suiController.scrollable)[0].scrollLeft, $(suiController.scrollable)[0].scrollTop);
      } catch(e) {
        SuiExceptionHandler.instance.exceptionHandler(e);
      }
    },500);
  }

  createPiano() {
    this.piano = new suiPiano(
    {
      elementId:'piano-svg',
      ribbons: defaultRibbonLayout.ribbons,
      ribbonButtons: defaultRibbonLayout.ribbonButtons,
      menus: this.menus,
      keyCommands: this.keyCommands,
      controller: this,
      view: this.view,
      eventSource:this.eventSource
    });
        // $('.close-piano').click();
  }
  _setMusicDimensions() {
    $('.musicRelief').height(window.innerHeight - $('.musicRelief').offset().top);
  }
  resizeEvent() {
    var self = this;
    if (this.resizing) {
      return;
    }
    if ($('body').hasClass('printing')) {
      return;
    }
    this.resizing = true;
    setTimeout(function () {
      console.log('resizing');
      self.resizing = false;
      self._setMusicDimensions();
      self.piano.handleResize();
    }, 500);
  }

  createModifierDialog(modifierSelection) {
    var parameters = {
      modifier: modifierSelection.modifier,
        view: this.view, eventSource:this.eventSource,
         completeNotifier:this, keyCommands:this.keyCommands
    }
    return SuiModifierDialogFactory.createDialog(modifierSelection.modifier, parameters);
  }

  // If the user has selected a modifier via the mouse/touch, bring up mod dialog
  // for that modifier
  trackerModifierSelect(ev) {
    var modSelection = this.view.tracker.getSelectedModifier();
    if (modSelection) {
      var dialog = this.createModifierDialog(modSelection);
      if (dialog) {
        // this.view.tracker.selectSuggestion(ev);
        return;
        // this.unbindKeyboardForModal(dialog);
      } else {
        this.view.tracker.advanceModifierSelection(ev);
      }
    } else {
      this.view.tracker.selectSuggestion(ev);
    }
    return;
  }

    // ### bindResize
  // This handles both resizing of the music area (scrolling) and resizing of the window.
  // The latter results in a redraw, the former just resets the client/logical map of elements
  // in the tracker.
  bindResize() {
    const self = this;
    const el = $(suiController.scrollable)[0];
    // unit test programs don't have resize html
    if (!el) {
      return;
    }
    this._setMusicDimensions();
    // $(suiController.scrollable).height(window.innerHeight - $('.musicRelief').offset().top);

    window.addEventListener('resize', function () {
      self.resizeEvent();
    });

    let scrollCallback = (ev) => {
      self.handleScrollEvent(ev);
    };
    el.onscroll = scrollCallback;
  }


  // ### renderElement
  // return render element that is the DOM parent of the svg
  get renderElement() {
    return this.view.renderer.renderElement;
  }

  // ## keyBindingDefaults
  // ### Description:
  // Different applications can create their own key bindings, these are the defaults.
  // Many editor commands can be reached by a single keystroke.  For more advanced things there
  // are menus.
  static get keyBindingDefaults() {
    var editorKeys = suiController.editorKeyBindingDefaults;
    editorKeys.forEach((key) => {
      key.module = 'keyCommands'
    });
    var trackerKeys = suiController.trackerKeyBindingDefaults;
    trackerKeys.forEach((key) => {
      key.module = 'tracker'
    });
    return trackerKeys.concat(editorKeys);
  }

  // ## editorKeyBindingDefaults
  // ## Description:
  // execute a simple command on the editor, based on a keystroke.
  static get editorKeyBindingDefaults() {
    return defaultEditorKeys.keys;
  }

  // ## trackerKeyBindingDefaults
  // ### Description:
  // Key bindings for the tracker.  The tracker is the 'cursor' in the music
  // that lets you select and edit notes.
  static get trackerKeyBindingDefaults() {
    return defaultTrackerKeys.keys;
  }
  helpControls() {
    var self = this;
    var rebind = function () {
      self.bindEvents();
    }
  }
  static set reentry(value) {
    suiController._reentry = value;
  }
  static get reentry() {
    if (typeof(suiController['_reentry']) == 'undefined') {
      suiController._reentry = false;
    }
    return suiController._reentry;
  }

  menuHelp() {
    SmoHelp.displayHelp();
  }

  static get defaults() {
    return {
      keyBind: suiController.keyBindingDefaults
    };
  }

  showModifierDialog(modSelection) {
    return SuiDialogFactory.createDialog(modSelection, this.view, this)
  }

  // ### unbindKeyboardForModal
  // Global events from keyboard and pointer are handled by this object.  Modal
  // UI elements take over the events, and then let the controller know when
  // the modals go away.
  unbindKeyboardForModal(dialog) {
    const self = this;
    layoutDebug.addDialogDebug('controller: unbindKeyboardForModal')
    const rebind = () => {
      self.bindEvents();
      layoutDebug.addDialogDebug('controller: unbindKeyboardForModal resolve')
    }
    this.eventSource.unbindKeydownHandler(this.keydownHandler);
    this.eventSource.unbindMouseMoveHandler(this.mouseMoveHandler);
    this.eventSource.unbindMouseClickHandler(this.mouseClickHandler);

    dialog.closeModalPromise.then(rebind);
  }

  evKey(evdata) {
    if ($('body').hasClass('translation-mode')) {
      return;
    }

    console.log("KeyboardEvent: key='" + evdata.key + "' | code='" +
      evdata.code + "'"
       + " shift='" + evdata.shiftKey + "' control='" + evdata.ctrlKey + "'" + " alt='" + evdata.altKey + "'");
    evdata.preventDefault();

    if (suiController.keyboardWidget) {
      Qwerty.handleKeyEvent(evdata);
    }
    const dataCopy = suiTracker.serializeEvent(evdata);
    this.view.renderer.updatePromise().then(() => {
      if (dataCopy.key == '?') {
        SmoHelp.displayHelp();
      }

      if (dataCopy.key == '/') {
        // set up menu DOM.
        this.menus.slashMenuMode(this);
      }

      if (dataCopy.key == 'Enter') {
        this.trackerModifierSelect(dataCopy);
      }

      var binding = this.keyBind.find((ev) =>
        ev.event === 'keydown' && ev.key === dataCopy.key &&
        ev.ctrlKey === dataCopy.ctrlKey &&
        ev.altKey === dataCopy.altKey && dataCopy.shiftKey === ev.shiftKey);

      if (binding) {
        try {
          this[binding.module][binding.action](dataCopy);
        } catch (e) {
          if (typeof(e) === 'string') {
            console.error(e);
          }
          this.exhandler.exceptionHandler(e);
        }
      }
    });
  }

  mouseMove(ev) {
    this.view.tracker.intersectingArtifact({
      x: ev.clientX,
      y: ev.clientY
    });
  }

  mouseClick(ev) {
    const dataCopy = suiTracker.serializeEvent(ev);
    this.view.renderer.updatePromise().then(() => {
      this.view.tracker.selectSuggestion(dataCopy);
      var modifier = this.view.tracker.getSelectedModifier();
      if (modifier) {
        this.createModifierDialog(modifier);
      }
    });
  }
  bindEvents() {
    const self = this;
    const tracker = this.view.tracker;

    $('body').off('redrawScore').on('redrawScore', function() {
      self.handleRedrawTimer();
    });
    $('body').off('forceScrollEvent').on('forceScrollEvent', function() {
      self.handleScrollEvent();
    });
    $('body').off('forceResizeEvent').on('forceResizeEvent', function() {
      self.resizeEvent();
    });
    this.mouseMoveHandler = this.eventSource.bindMouseMoveHandler(this, 'mouseMove');
    this.mouseClickHandler = this.eventSource.bindMouseClickHandler(this, 'mouseClick');
    this.keydownHandler = this.eventSource.bindKeydownHandler(this, 'evKey');

    this.helpControls();
    window.addEventListener('error', function (e) {
      SuiExceptionHandler.instance.exceptionHandler(e);
    });
  }
}
;// # Dialog base classes

// ## SuiModifierDialogFactory
// Automatic dialog constructors for dialogs without too many parameters
// that operated on a selection.
// eslint-disable-next-line no-unused-vars
class SuiModifierDialogFactory {
  static createDialog(modifier, parameters) {
    let dbType = SuiModifierDialogFactory.modifierDialogMap[modifier.attrs.type];
    if (dbType === 'SuiLyricDialog' && modifier.parser === SmoLyric.parsers.chord) {
      dbType = 'SuiChordChangeDialog';
    }
    if (typeof(dbType) === 'undefined') {
      return null;
    }
    const ctor = eval(dbType);
    return ctor.createAndDisplay({
      modifier,
      ...parameters
    });
  }
  static get modifierDialogMap() {
    return {
      SmoStaffHairpin: 'SuiHairpinAttributesDialog',
      SmoTie: 'SuiTieAttributesDialog',
      SmoSlur: 'SuiSlurAttributesDialog',
      SmoDynamicText: 'SuiDynamicModifierDialog',
      SmoVolta: 'SuiVoltaAttributeDialog',
      SmoScoreText: 'SuiTextTransformDialog',
      SmoTextGroup: 'SuiTextTransformDialog',
      SmoLoadScore: 'SuiLoadFileDialog',
      SmoLyric: 'SuiLyricDialog'
    };
  }
}

// ## SuiDialogBase
// Base class for dialogs.
// eslint-disable-next-line no-unused-vars
class SuiDialogBase {
  static get parameters() {
    return ['eventSource', 'view',
      'completeNotifier', 'keyCommands', 'modifier'];
  }
  static getStaticText(dialogElements, label) {
    const rv = dialogElements.find((x) => x.staticText).staticText.find((x) => x[label]);
    if (rv !== null && rv[label]) {
      return rv[label];
    }
    return 'text not found';
  }
  // ### SuiDialogBase ctor
  // Creates the DOM element for the dialog and gets some initial elements
  constructor(dialogElements, parameters) {
    this.id = parameters.id;
    this.boundKeyboard = false;
    this.components = [];
    this.scroller = parameters.view.tracker.scroller;

    this.closeDialogPromise = new Promise((resolve) => {
      $('body').off('dialogDismiss').on('dialogDismiss', () => {
        resolve();
      });
    });

    const staticText = dialogElements.find((xx) => xx.staticText);
    if (!staticText) {
      throw 'dialog ' + this.ctor + ' needs a static text section';
    }
    this.staticText = {};
    staticText.staticText.forEach((st) => {
      const key = Object.keys(st)[0];
      this.staticText[key] = st[key];
    });

    this.initialLeft = parameters.left;
    this.initialTop = parameters.top;

    // If this dialog was spawned by a menu, wait for the menu to dismiss
    // before continuing.
    this.startPromise = parameters.closeMenuPromise;
    this.dialogElements = dialogElements;
    SuiDialogBase.parameters.forEach((param) => {
      this[param] = parameters[param];
    });

    const top = parameters.top - this.view.tracker.scroller.netScroll.y;
    const left = parameters.left - this.view.tracker.scroller.netScroll.x;

    this.dgDom = this._constructDialog(dialogElements, {
      id: 'dialog-' + this.id,
      top,
      left,
      label: this.label
    });

    SmoTranslator.registerDialog(this.ctor);
  }

  // ### printXlate
  // print json with string labels to use as a translation file seed.
  static printTranslate(_class) {
    const output = [];
    const xx = eval(_class);
    xx.dialogElements.forEach((element) => {
      const component = {};
      if (element.label) {
        component.label = element.label;
        component.id = element.smoName;
        if (element.options) {
          component.options = [];

          element.options.forEach((option) => {
            component.options.push({ value: option.value, label: option.label });
          });
        }
      }
      if (element.staticText) {
        component.staticText = {};
        element.staticText.forEach((st) => {
          var key = Object.keys(st)[0];
          component.staticText[key] = st[key];
        });
      }
      output.push(component);
    });
    return { ctor: xx.ctor, dialogElements: output };
  }

  get closeModalPromise() {
    return this.closeDialogPromise;
  }

  // ### position
  // For dialogs based on selections, tries to place the dialog near the selection and also
  // to scroll so the dialog is in view
  static position(box, dgDom, scroller) {
    let y = (box.y + box.height) - scroller.netScroll.y;
    let x = 0;

    // TODO: adjust if db is clipped by the browser.
    const dge = $(dgDom.element).find('.attributeModal');
    const dgeHeight = $(dge).height();
    const maxY =  $('.musicRelief').height();
    const maxX = $('.musicRelief').width();
    const offset = $('.dom-container').offset();
    y = y - offset.top;

    const offsetY = dgeHeight + y > window.innerHeight ? (dgeHeight + y) -  window.innerHeight : 0;
    y = (y < 0) ? -y : y - offsetY;

    y = (y > maxY || y < 0) ? maxY / 2 : y;

    $(dge).css('top', '' + y + 'px');

    x = box.x - scroller.netScroll.x;
    x = x - offset.left;
    const w = $(dge).width();
    x = (x > window.innerWidth / 2)  ? x - (w + 25) : x + (w + 25);

    x = (x < 0 || x > maxX) ? maxX / 2 : x;
    $(dge).css('left', '' + x + 'px');
  }

  // ### position
  // Position the dialog near a selection.  If the dialog is not visible due
  // to scrolling, make sure it is visible.
  position(box) {
    SuiDialogBase.position(box, this.dgDom, this.view.tracker.scroller);
  }
  // ### build the html for the dialog, based on the instance-specific components.
  _constructDialog(dialogElements, parameters) {
    const id = parameters.id;
    const b = htmlHelpers.buildDom;
    const r = b('div').classes('attributeModal').attr('id', 'attr-modal-' + id)
      .css('top', parameters.top + 'px').css('left', parameters.left + 'px')
      .append(b('spanb').classes('draggable button').append(b('span').classes('icon icon-move jsDbMove')))
      .append(b('h2').classes('dialog-label').text(this.staticText.label));

    var ctrl = b('div').classes('smoControlContainer');
    dialogElements.filter((de) => de.control).forEach((de) => {
      var ctor = eval(de.control);
      var control = new ctor(this, de);
      this.components.push(control);
      ctrl.append(control.html);
    });
    r.append(ctrl);
    r.append(
      b('div').classes('buttonContainer').append(
        b('button').classes('ok-button button-left').text('OK')).append(
        b('button').classes('cancel-button button-center').text('Cancel')).append(
        b('button').classes('remove-button button-right').text('Remove').append(
          b('span').classes('icon icon-cancel-circle'))));
    $('.attributeDialog').html('');

    $('.attributeDialog').append(r.dom());

    const trapper = htmlHelpers.inputTrapper('.attributeDialog');
    $('.attributeDialog').find('.cancel-button').focus();
    return {
      element: $('.attributeDialog'),
      trapper
    };
  }
  // ### Complete
  // Dialogs take over the keyboard, so release that and trigger an event
  // that the dialog is closing that can resolve any outstanding promises.
  complete() {
    if (this.boundKeyboard) {
      this.eventSource.unbindKeydownHandler(this.keydownHandler);
    }
    $('body').removeClass('showAttributeDialog');
    $('body').trigger('dialogDismiss');
    this.dgDom.trapper.close();
  }

  // ### _bindComponentNames
  // helper method to give components class names based on their static configuration
  _bindComponentNames() {
    this.components.forEach((component) => {
      var nm = component.smoName + 'Ctrl';
      this[nm] = component;
    });
  }

  // ### display
  // make3 the modal visible.  bind events and elements.
  display() {
    $('body').addClass('showAttributeDialog');
    this.components.forEach((component) => {
      component.bind();
    });
    this._bindElements();
    if (this.modifier && this.modifier.renderedBox) {
      this.position(this.modifier.renderedBox);
    }
    this.view.tracker.scroller.scrollVisibleBox(
      svgHelpers.smoBox($(this.dgDom.element)[0].getBoundingClientRect())
    );

    const cb = () => {};
    htmlHelpers.draggable({
      parent: $(this.dgDom.element).find('.attributeModal'),
      handle: $(this.dgDom.element).find('.jsDbMove'),
      animateDiv: '.draganime',
      cb,
      moveParent: true
    });
  }

  // ### handleKeydown
  // allow a dialog to be dismissed by esc.
  evKey(evdata) {
    if (evdata.key === 'Escape') {
      $(this.dgDom.element).find('.cancel-button').click();
      evdata.preventDefault();
    }
  }

  // ### bindKeyboard
  // generic logic to grab keyboard elements for modal
  bindKeyboard() {
    this.boundKeyboard = true;
    this.keydownHandler = this.eventSource.bindKeydownHandler(this, 'evKey');
  }
}
;// # dbComponents - components of modal dialogs.
// eslint-disable-next-line no-unused-vars
class SuiComponentBase {
  constructor(parameters) {
    this.changeFlag = false;
    this.css = parameters.classes;
  }
  handleChanged() {
    this.changeFlag = true;
    this.dialog.changed();
    this.changeFlag = false;
  }
  // ### makeClasses
  // Allow specific dialogs to add css to components so they can
  // be conditionally displayed
  makeClasses(classes) {
    if (this.css) {
      return classes + ' ' + this.css;
    }
    return classes;
  }
}

// ## SuiRockerComponent
// A numeric input box with +- buttons.   Adjustable type and scale
// eslint-disable-next-line no-unused-vars
class SuiRockerComponent extends SuiComponentBase {
  static get dataTypes() {
    return ['int', 'float', 'percent'];
  }
  static get increments() {
    return { 'int': 1, 'float': 0.1, 'percent': 10 };
  }
  static get parsers() {
    return { 'int': '_getIntValue', 'float': '_getFloatValue', 'percent': '_getPercentValue' };
  }
  constructor(dialog, parameter) {
    super(parameter);
    smoSerialize.filteredMerge(
      ['parameterName', 'smoName', 'defaultValue', 'control', 'label', 'increment', 'type'], parameter, this);
    if (!this.defaultValue) {
      this.defaultValue = 0;
    }
    if (!this.type) {
      this.type = 'int';
    }
    if (!this.increment) {
      this.increment = SuiRockerComponent.increments[this.type];
    }
    if (SuiRockerComponent.dataTypes.indexOf(this.type) < 0) {
      throw new Error('dialog element invalid type ' + this.type);
    }

    this.id = this.id ? this.id : '';

    if (this.type === 'percent') {
      this.defaultValue = 100 * this.defaultValue;
    }
    this.parser = SuiRockerComponent.parsers[this.type];
    this.dialog = dialog;
  }

  get html() {
    const b = htmlHelpers.buildDom;
    const id = this.parameterId;
    const r = b('div').classes(this.makeClasses('rockerControl smoControl')).attr('id', id).attr('data-param', this.parameterName)
      .append(
        b('button').classes('increment').append(
          b('span').classes('icon icon-circle-up'))).append(
        b('button').classes('decrement').append(
          b('span').classes('icon icon-circle-down'))).append(
        b('input').attr('type', 'text').classes('rockerInput')
          .attr('id', id + '-input')).append(
        b('label').attr('for', id + '-input').text(this.label));
    return r;
  }

  get parameterId() {
    return this.dialog.id + '-' + this.parameterName;
  }
  handleChange() {
    this.changeFlag = true;
    this.dialog.changed();
    this.changeFlag = false;
  }

  bind() {
    const pid = this.parameterId;
    const input = this._getInputElement();
    let val = 0;
    this.setValue(this.defaultValue);
    const self = this;
    $('#' + pid).find('button.increment').off('click').on('click',
      () => {
        val = self[self.parser]();
        if (self.type === 'percent') {
          val = 100 * val;
        }
        $(input).val(val + self.increment);
        self.handleChanged();
      }
    );
    $('#' + pid).find('button.decrement').off('click').on('click',
      () => {
        val = self[self.parser]();
        if (self.type === 'percent') {
          val = 100 * val;
        }
        $(input).val(val - self.increment);
        self.handleChanged();
      }
    );
    $(input).off('blur').on('blur',
      () => {
        self.handleChanged();
      }
    );
  }

  _getInputElement() {
    const pid = this.parameterId;
    return $(this.dialog.dgDom.element).find('#' + pid).find('input');
  }
  _getIntValue() {
    let val = parseInt(this._getInputElement().val(), 10);
    val = isNaN(val) ? 0 : val;
    return val;
  }
  _getFloatValue() {
    let val = parseFloat(this._getInputElement().val(), 10);
    val = isNaN(val) ? 1.0 : val;
    return val;
  }
  _getPercentValue() {
    let val = parseFloat(this._getInputElement().val(), 10);
    val = isNaN(val) ? 1 : val;
    return val / 100;
  }
  _setIntValue(val) {
    this._getInputElement().val(val);
  }
  setValue(value) {
    if (this.type === 'percent') {
      value = value * 100;
    }
    this._setIntValue(value);
  }
  getValue() {
    return this[this.parser]();
  }
}

// ## SuiFileDownloadComponent
// Download a test file using the file input.
// eslint-disable-next-line no-unused-vars
class SuiFileDownloadComponent extends SuiComponentBase {
  constructor(dialog, parameter) {
    super(parameter);
    smoSerialize.filteredMerge(
      ['parameterName', 'smoName', 'defaultValue', 'control', 'label'], parameter, this);
    if (!this.defaultValue) {
      this.defaultValue = 0;
    }
    this.dialog = dialog;
    this.value = '';
  }
  get parameterId() {
    return this.dialog.id + '-' + this.parameterName;
  }
  get html() {
    const b = htmlHelpers.buildDom;
    const id = this.parameterId;
    var r = b('div').classes(this.makeClasses('select-file')).attr('id', this.parameterId).attr('data-param', this.parameterName)
      .append(b('input').attr('type', 'file').classes('file-button')
        .attr('id', id + '-input')).append(
        b('label').attr('for', id + '-input').text(this.label));
    return r;
  }

  _handleUploadedFiles(evt)  {
    const reader = new FileReader();
    const self = this;
    reader.onload = (file) => {
      self.value = file.target.result;
      self.handleChanged();
    };
    reader.readAsText(evt.target.files[0]);
  }
  getValue() {
    return this.value;
  }
  bind() {
    const self = this;
    $('#' + this.parameterId).find('input').off('change').on('change', (e) => {
      self._handleUploadedFiles(e);
    });
  }
}

// ## SuiToggleComponent
// Simple on/off behavior
// eslint-disable-next-line no-unused-vars
class SuiToggleComponent extends SuiComponentBase {
  constructor(dialog, parameter) {
    super(parameter);
    smoSerialize.filteredMerge(
      ['parameterName', 'smoName', 'defaultValue', 'control', 'label'], parameter, this);
    if (!this.defaultValue) {
      this.defaultValue = 0;
    }
    this.dialog = dialog;
  }
  get html() {
    const b = htmlHelpers.buildDom;
    const id = this.parameterId;
    const r = b('div').classes(this.makeClasses('toggleControl smoControl')).attr('id', this.parameterId).attr('data-param', this.parameterName)
      .append(b('input').attr('type', 'checkbox').classes('toggleInput')
        .attr('id', id + '-input')).append(
        b('label').attr('for', id + '-input').text(this.label));
    return r;
  }
  _getInputElement() {
    const pid = this.parameterId;
    return $(this.dialog.dgDom.element).find('#' + pid).find('input');
  }
  get parameterId() {
    return this.dialog.id + '-' + this.parameterName;
  }

  setValue(value) {
    $(this._getInputElement()).prop('checked', value);
  }
  getValue() {
    return $(this._getInputElement()).prop('checked');
  }

  bind() {
    const input = this._getInputElement();
    this.setValue(this.defaultValue);
    const self = this;
    $(input).off('change').on('change',
      () => {
        self.handleChanged();
      });
  }
}

// ## SuiToggleComponent
// Simple on/off behavior
// eslint-disable-next-line no-unused-vars
class SuiButtonComponent extends SuiComponentBase {
  constructor(dialog, parameter) {
    super(parameter);
    smoSerialize.filteredMerge(
      ['parameterName', 'smoName', 'defaultValue', 'control', 'label', 'additionalClasses', 'icon'], parameter, this);
    if (!this.defaultValue) {
      this.defaultValue = 0;
    }
    this.dialog = dialog;
  }
  get html() {
    const b = htmlHelpers.buildDom;
    const id = this.parameterId;
    this.icon = typeof(this.icon) === 'undefined' ? '' : this.icon;
    const r = b('div').classes(this.makeClasses('buttonControl smoControl')).attr('id', this.parameterId).attr('data-param', this.parameterName)
      .append(b('button').attr('type', 'button').classes(this.icon)
        .attr('id', id + '-input')).append(
        b('label').attr('for', id + '-input').text(this.label));
    return r;
  }
  _getInputElement() {
    var pid = this.parameterId;
    return $(this.dialog.dgDom.element).find('#' + pid).find('button');
  }
  get parameterId() {
    return this.dialog.id + '-' + this.parameterName;
  }

  setValue() {
  }
  getValue() {
    return null;
  }

  bind() {
    const input = this._getInputElement();
    this.setValue(this.defaultValue);
    const self = this;
    $(input).off('click').on('click',
      () => {
        self.handleChanged();
      });
  }
}

// ### SuiDropdownComponent
// simple dropdown select list.
// eslint-disable-next-line no-unused-vars
class SuiDropdownComponent extends SuiComponentBase {
  constructor(dialog, parameter) {
    super(parameter);
    smoSerialize.filteredMerge(
      ['parameterName', 'smoName', 'defaultValue', 'options', 'control', 'label', 'dataType'], parameter, this);
    if (!this.defaultValue) {
      this.defaultValue = 0;
    }
    if (!this.dataType) {
      this.dataType = 'string';
    }
    this.dialog = dialog;
  }

  get parameterId() {
    return this.dialog.id + '-' + this.parameterName;
  }

  get html() {
    const b = htmlHelpers.buildDom;
    const id = this.parameterId;
    const r = b('div').classes(this.makeClasses('dropdownControl smoControl')).attr('id', id).attr('data-param', this.parameterName);
    const s = b('select');
    this.options.forEach((option) => {
      s.append(
        b('option').attr('value', option.value).text(option.label));
    });
    r.append(s).append(
      b('label').attr('for', id + '-input').text(this.label));
    return r;
  }

  unselect() {
    $(this._getInputElement())[0].selectedIndex = -1;
    $(this._getInputElement()).blur();
  }

  _getInputElement() {
    var pid = this.parameterId;
    return $(this.dialog.dgDom.element).find('#' + pid).find('select');
  }
  getValue() {
    const input = this._getInputElement();
    const option = input.find('option:selected');
    let val = $(option).val();
    val = (this.dataType.toLowerCase() === 'int') ?  parseInt(val, 10) : val;
    val = (this.dataType.toLowerCase() === 'float') ?  parseFloat(val, 10) : val;
    if (typeof(val) === 'undefined') {
      val = $(input).find('option:first').val();
      $(input).find('option:first').prop('selected', true);
    }
    return val;
  }
  setValue(value) {
    const input = this._getInputElement();
    $(input).val(value);
  }

  bind() {
    const input = this._getInputElement();
    this.setValue(this.defaultValue);
    const self = this;
    $(input).off('change').on('change',
      () => {
        self.handleChanged();
      });
  }
}

// ### SuiDropdownComposite
// Dropdown component that can be part of a composite control.
// eslint-disable-next-line no-unused-vars
class SuiDropdownComposite extends SuiDropdownComponent {
  constructor(dialog, parameters) {
    super(dialog, parameters);
    this.parentControl = parameters.parentControl;
  }

  handleChanged() {
    this.changeFlag = true;
    this.parentControl.changed();
    this.changeFlag = false;
  }
}

// ### SuiToggleComposite
// Dropdown component that can be part of a composite control.
// eslint-disable-next-line no-unused-vars
class SuiToggleComposite extends SuiToggleComponent {
  constructor(dialog, parameters) {
    super(dialog, parameters);
    this.parentControl = parameters.parentControl;
  }

  handleChanged() {
    this.changeFlag = true;
    this.parentControl.changed();
    this.changeFlag = false;
  }
}

// ### SuiButtonComposite
// Dropdown component that can be part of a composite control.
// eslint-disable-next-line no-unused-vars
class SuiButtonComposite extends SuiButtonComponent {
  constructor(dialog, parameters) {
    super(dialog, parameters);
    this.parentControl = parameters.parentControl;
  }

  handleChanged() {
    this.changeFlag = true;
    this.parentControl.changed();
    this.changeFlag = false;
  }
}

// eslint-disable-next-line no-unused-vars
class SuiRockerComposite extends SuiRockerComponent {
  constructor(dialog, parameters) {
    super(dialog, parameters);
    this.parentControl = parameters.parentControl;
  }

  handleChanged() {
    this.changeFlag = true;
    this.parentControl.changed();
    this.changeFlag = false;
  }
}

// ## SuiTextInputComponent
// Just get text from an input, such as a filename.
// Note: this is HTML input, not for SVG/score editing
// eslint-disable-next-line no-unused-vars
class SuiTextInputComponent extends SuiComponentBase {
  constructor(dialog, parameter) {
    super(parameter);
    smoSerialize.filteredMerge(
      ['parameterName', 'smoName', 'defaultValue', 'control', 'label'], parameter, this);
    if (!this.defaultValue) {
      this.defaultValue = 0;
    }
    this.dialog = dialog;
    this.value = '';
  }
  get parameterId() {
    return this.dialog.id + '-' + this.parameterName;
  }
  get html() {
    const b = htmlHelpers.buildDom;
    const id = this.parameterId;
    const r = b('div').classes(this.makeClasses('text-input smoControl')).attr('id', this.parameterId).attr('data-param', this.parameterName)
      .append(b('input').attr('type', 'text').classes('file-name')
        .attr('id', id + '-input')).append(
        b('label').attr('for', id + '-input').text(this.label));
    return r;
  }

  getValue() {
    return this.value;
  }
  setValue(val) {
    this.value = val;
    $('#' + this.parameterId).find('input').val(val);
  }
  _getInputElement() {
    const pid = this.parameterId;
    return $(this.dialog.dgDom.element).find('#' + pid).find('input');
  }
  bind() {
    const self = this;
    $('#' + this.parameterId).find('input').off('change').on('change', () => {
      self.value = $(this._getInputElement()).val();
      self.handleChanged();
    });
  }
}

// eslint-disable-next-line no-unused-vars
class SuiTextInputComposite extends SuiTextInputComponent {
  constructor(dialog, parameters) {
    super(dialog, parameters);
    this.parentControl = parameters.parentControl;
  }

  handleChanged() {
    this.changeFlag = true;
    this.parentControl.changed();
    this.changeFlag = false;
  }
}
;// eslint-disable-next-line no-unused-vars
class SuiFileDialog extends SuiDialogBase {
  constructor(parameters) {
    var p = parameters;
    var ctor = eval(parameters.ctor);
    p.label = parameters.label ? parameters.label : 'Dialog Box';
    p.id = 'dialog-file';
    p.top = (p.view.score.layout.pageWidth / 2) - 200;
    p.left = (p.view.score.layout.pageHeight / 2) - 200;

    super(ctor.dialogElements, p);
    this.value = '';
  }
  display() {
    $('body').addClass('showAttributeDialog');
    this.components.forEach((component) => {
      component.bind();
    });
    this._bindElements();

    // make sure keyboard is unbound or we get dupicate key events.
    const getKeys = () => {
      this.completeNotifier.unbindKeyboardForModal(this);
    };
    this.startPromise.then(getKeys);
    this.position($(this.dgDom.element)[0].getBoundingClientRect());
  }

  _bindElements() {
    const dgDom = this.dgDom;

    $(dgDom.element).find('.ok-button').off('click').on('click', () => {
      this.commit();
    });

    $(dgDom.element).find('.cancel-button').off('click').on('click', () => {
      this.complete();
    });

    $(dgDom.element).find('.remove-button').remove();
    this.bindKeyboard();
  }
  position(box) {
    var y = (window.innerHeight / 3  + box.height);
    // TODO: adjust if db is clipped by the browser.
    var dge = $(this.dgDom.element).find('.attributeModal');

    $(dge).css('top', '' + y + 'px');
    const x = window.innerWidth - box.width / 2;
    $(dge).css('left', '' + x + 'px');
  }
}
// eslint-disable-next-line no-unused-vars
class SuiLoadFileDialog extends SuiFileDialog {
  static get ctor() {
    return 'SuiLoadFileDialog';
  }
  get ctor() {
    return SuiLoadFileDialog.ctor;
  }

  static get dialogElements() {
    SuiLoadFileDialog._dialogElements = SuiLoadFileDialog._dialogElements ? SuiLoadFileDialog._dialogElements :
      [{
        smoName: 'loadFile',
        parameterName: 'jsonFile',
        defaultValue: '',
        control: 'SuiFileDownloadComponent',
        label: ''
      }, { staticText: [
        { label: 'Load File' }
      ] }
      ];
    return SuiLoadFileDialog._dialogElements;
  }
  changed() {
    this.value = this.components[0].getValue();
    $(this.dgDom.element).find('.ok-button').prop('disabled', false);
  }
  commit() {
    let scoreWorks = false;
    if (this.value) {
      try {
        const score = SmoScore.deserialize(this.value);
        scoreWorks = true;
        this.view.changeScore(score);
        this.complete();
      } catch (e) {
        console.warn('unable to score ' + e);
      }
      if (!scoreWorks) {
        this.complete();
      }
    }
  }
  static createAndDisplay(params) {
    const dg = new SuiLoadFileDialog(params);
    dg.display();
    // disable until file is selected
    $(dg.dgDom.element).find('.ok-button').prop('disabled', true);
  }
  constructor(parameters) {
    parameters.ctor = 'SuiLoadFileDialog';
    super(parameters);
  }
}

// eslint-disable-next-line no-unused-vars
class SuiLoadMxmlDialog extends SuiFileDialog {
  static get ctor() {
    return 'SuiLoadMxmlDialog';
  }
  get ctor() {
    return SuiLoadMxmlDialog.ctor;
  }

  static get dialogElements() {
    SuiLoadMxmlDialog._dialogElements = SuiLoadMxmlDialog._dialogElements ? SuiLoadMxmlDialog._dialogElements :
      [{
        smoName: 'loadFile',
        parameterName: 'jsonFile',
        defaultValue: '',
        control: 'SuiFileDownloadComponent',
        label: ''
      }, { staticText: [
        { label: 'Load File' }
      ] }
      ];
    return SuiLoadMxmlDialog._dialogElements;
  }
  changed() {
    this.value = this.components[0].getValue();
    $(this.dgDom.element).find('.ok-button').prop('disabled', false);
  }
  commit() {
    let scoreWorks = false;
    if (this.value) {
      try {
        const parser = new DOMParser();
        const xml = parser.parseFromString(this.value, 'text/xml');
        const score = mxmlScore.smoScoreFromXml(xml);
        scoreWorks = true;
        this.view.changeScore(score);
        this.complete();
      } catch (e) {
        console.warn('unable to score ' + e);
      }
      if (!scoreWorks) {
        this.complete();
      }
    }
  }
  static createAndDisplay(params) {
    const dg = new SuiLoadMxmlDialog(params);
    dg.display();
    // disable until file is selected
    $(dg.dgDom.element).find('.ok-button').prop('disabled', true);
  }
  constructor(parameters) {
    parameters.ctor = 'SuiLoadMxmlDialog';
    super(parameters);
  }
}

// eslint-disable-next-line no-unused-vars
class SuiLoadActionsDialog extends SuiFileDialog {
  static get ctor() {
    return 'SuiLoadActionsDialog';
  }
  get ctor() {
    return SuiLoadActionsDialog.ctor;
  }

  static get dialogElements() {
    SuiLoadActionsDialog._dialogElements = SuiLoadActionsDialog._dialogElements ? SuiLoadActionsDialog._dialogElements :
      [{
        smoName: 'loadFile',
        parameterName: 'jsonFile',
        defaultValue: '',
        control: 'SuiFileDownloadComponent',
        label: ''
      }, { staticText: [
        { label: 'Load Action File' }
      ] }
      ];
    return SuiLoadActionsDialog._dialogElements;
  }
  changed() {
    this.value = this.loadFileCtrl.getValue();
    $(this.dgDom.element).find('.ok-button').prop('disabled', false);
  }
  commit() {
    let scoreWorks = false;
    if (this.value) {
      try {
        const json = JSON.parse(this.value);
        this.view.playActions(json);
        scoreWorks = true;
        this.complete();
      } catch (e) {
        console.warn('unable to score ' + e);
      }
      if (!scoreWorks) {
        this.complete();
      }
    }
  }
  static createAndDisplay(params) {
    const dg = new SuiLoadActionsDialog(params);
    dg.display();
    dg._bindComponentNames();
    // disable until file is selected
    $(dg.dgDom.element).find('.ok-button').prop('disabled', true);
  }
  constructor(parameters) {
    parameters.ctor = 'SuiLoadActionsDialog';
    super(parameters);
  }
}

// eslint-disable-next-line no-unused-vars
class SuiPrintFileDialog extends SuiFileDialog {
  static get ctor() {
    return 'SuiPrintFileDialog';
  }
  get ctor() {
    return SuiPrintFileDialog.ctor;
  }
  static get label() {
    SuiPrintFileDialog._label = typeof(SuiPrintFileDialog._label) !== 'undefined' ? SuiPrintFileDialog._label :
      'Print Complete';
    return SuiPrintFileDialog._label;
  }
  static set label(value) {
    SuiPrintFileDialog._label = value;
  }

  static get dialogElements() {
    return [
      { staticText: [
        { label: 'Print Complete' }
      ] }];
  }
  static createAndDisplay(params) {
    var dg = new SuiPrintFileDialog(params);
    dg.display();
  }
  constructor(parameters) {
    parameters.ctor = 'SuiPrintFileDialog';
    super(parameters);
  }
  changed() {}
  _bindElements() {
    const dgDom = this.dgDom;
    $(dgDom.element).find('.ok-button').off('click').on('click', () => {
      $('body').removeClass('printing');
      this.view.renderer.restoreLayoutAfterPrint();
      window.dispatchEvent(new Event('resize'));
      this.complete();
    });

    $(dgDom.element).find('.cancel-button').remove();
    $(dgDom.element).find('.remove-button').remove();
  }
}
// eslint-disable-next-line no-unused-vars
class SuiSaveFileDialog extends SuiFileDialog {
  static get ctor() {
    return 'SuiSaveFileDialog';
  }
  get ctor() {
    return SuiSaveFileDialog.ctor;
  }

  static get dialogElements() {
    SuiSaveFileDialog._dialogElements = typeof(SuiSaveFileDialog._dialogElements) !== 'undefined' ?
      SuiSaveFileDialog._dialogElements :
      [{
        smoName: 'saveFileName',
        parameterName: 'saveFileName',
        defaultValue: '',
        control: 'SuiTextInputComponent',
        label: 'File Name'
      },
      {
        staticText: [
          { label: 'Save Score' }
        ]
      }];
    return SuiSaveFileDialog._dialogElements;
  }

  changed() {
    this.value = this.components[0].getValue();
  }
  commit() {
    let filename = this.value;
    if (!filename) {
      filename = 'myScore.json';
    }
    if (filename.indexOf('.json') < 0) {
      filename = filename + '.json';
    }
    this.view.score.scoreInfo.version += 1;
    this.view.saveScore(filename);
    this.complete();
  }
  display() {
    super.display();
    this._bindComponentNames();
    this.saveFileNameCtrl.setValue(this.value);
  }
  static createName(score) {
    return score.scoreInfo.name + '-' + score.scoreInfo.version + '.json';
  }
  static createAndDisplay(params) {
    var dg = new SuiSaveFileDialog(params);
    dg.display();
  }
  constructor(parameters) {
    parameters.ctor = 'SuiSaveFileDialog';
    super(parameters);
    this.value = SuiSaveFileDialog.createName(this.view.score);
  }
}

// eslint-disable-next-line no-unused-vars
class SuiSaveXmlDialog extends SuiFileDialog {
  static get ctor() {
    return 'SuiSaveXmlDialog';
  }
  get ctor() {
    return SuiSaveXmlDialog.ctor;
  }

  static get dialogElements() {
    SuiSaveXmlDialog._dialogElements = typeof(SuiSaveXmlDialog._dialogElements) !== 'undefined' ?
      SuiSaveXmlDialog._dialogElements :
      [{
        smoName: 'saveFileName',
        parameterName: 'saveFileName',
        defaultValue: '',
        control: 'SuiTextInputComponent',
        label: 'File Name'
      },
      {
        staticText: [
          { label: 'Save Score' }
        ]
      }];
    return SuiSaveXmlDialog._dialogElements;
  }

  changed() {
    this.value = this.components[0].getValue();
  }
  commit() {
    let filename = this.value;
    if (!filename) {
      filename = 'myScore.xml';
    }
    if (filename.indexOf('.xml') < 0) {
      filename = filename + '.xml';
    }
    this.view.score.scoreInfo.version += 1;
    this.view.saveXml(filename);
    this.complete();
  }
  display() {
    super.display();
    this._bindComponentNames();
    this.saveFileNameCtrl.setValue(this.value);
  }
  static createName(score) {
    return score.scoreInfo.name + '-' + score.scoreInfo.version + '.xml';
  }
  static createAndDisplay(params) {
    var dg = new SuiSaveXmlDialog(params);
    dg.display();
  }
  constructor(parameters) {
    parameters.ctor = 'SuiSaveXmlDialog';
    super(parameters);
    this.value = SuiSaveXmlDialog.createName(this.view.score);
  }
}

// eslint-disable-next-line no-unused-vars
class SuiSaveActionsDialog extends SuiFileDialog {
  static get ctor() {
    return 'SuiSaveActionsDialog';
  }
  get ctor() {
    return SuiSaveActionsDialog.ctor;
  }

  static get dialogElements() {
    SuiSaveActionsDialog._dialogElements = typeof(SuiSaveActionsDialog._dialogElements) !== 'undefined' ?
      SuiSaveActionsDialog._dialogElements :
      [{
        smoName: 'saveFileName',
        parameterName: 'saveFileName',
        defaultValue: '',
        control: 'SuiTextInputComponent',
        label: 'File Name'
      },
      {
        staticText: [
          { label: 'Save Score' }
        ]
      }];
    return SuiSaveActionsDialog._dialogElements;
  }

  changed() {
    this.value = this.components[0].getValue();
  }
  commit() {
    let filename = this.value;
    if (!filename) {
      filename = 'myScore.json';
    }
    if (filename.indexOf('.json') < 0) {
      filename = filename + '.json';
    }
    this.view.score.scoreInfo.version += 1;
    this.view.saveActions(filename);
    this.complete();
  }
  display() {
    super.display();
    this._bindComponentNames();
    this.saveFileNameCtrl.setValue(this.value);
  }
  static createName(score) {
    return score.scoreInfo.name + '-' + score.scoreInfo.version + '-actions.json';
  }
  static createAndDisplay(params) {
    var dg = new SuiSaveActionsDialog(params);
    dg.display();
  }
  constructor(parameters) {
    parameters.ctor = 'SuiSaveActionsDialog';
    super(parameters);
    this.value = SuiSaveActionsDialog.createName(this.view.score);
  }
}
;// ## SuiFontComponent
// Dialog component that lets user choose and customize fonts.
// eslint-disable-next-line no-unused-vars
class SuiFontComponent extends SuiComponentBase {
  constructor(dialog, parameter) {
    super(parameter);
    smoSerialize.filteredMerge(
      ['parameterName', 'smoName', 'defaultValue', 'options', 'control', 'label', 'dataType'], parameter, this);
    if (!this.defaultValue) {
      this.defaultValue = 0;
    }
    if (!this.dataType) {
      this.dataType = 'string';
    }
    this.dialog = dialog;
    this.familyPart = new SuiDropdownComposite(this.dialog,
      {
        smoName: 'fontFamily',
        parameterName: 'fontFamily',
        classes: 'hide-when-editing hide-when-moving',
        defaultValue: SmoScoreText.fontFamilies.times,
        control: 'SuiDropdownComponent',
        label: 'Font Family',
        startRow: true,
        parentControl: this,
        options: [
          { label: 'Arial', value: 'Arial' },
          { label: 'Times New Roman', value: 'Times New Roman' },
          { label: 'Serif', value: SourceSerifProFont.fontFamily },
          { label: 'Sans', value: SourceSansProFont.fontFamily },
          { label: 'Roboto Slab', value: 'Roboto Slab' },
          { label: 'Petaluma', value: 'Petaluma Script' },
          { label: 'Commissioner', value: 'Commissioner' },
          { label: 'Concert One', value: 'ConcertOne' },
          { label: 'Merriweather', value: 'Merriweather' }
        ]
      });
    this.sizePart = new SuiRockerComposite(
      this.dialog,
      {
        smoName: 'fontSize',
        parameterName: 'fontSize',
        defaultValue: 1,
        parentControl: this,
        classes: 'hide-when-editing hide-when-moving',
        control: 'SuiRockerComponent',
        label: 'Font Size',
        type: 'float',
        increment: 0.1
      },
    );
    this.italicsCtrl = new SuiToggleComposite(
      this.dialog,
      {
        smoName: 'italics',
        parameterName: 'italics',
        defaultValue: false,
        parentControl: this,
        classes: 'hide-when-editing hide-when-moving',
        control: 'SuiToggleComponent',
        label: 'Italics'
      }
    );
    this.boldCtrl = new SuiToggleComposite(
      this.dialog,
      {
        smoName: 'bold',
        parameterName: 'bold',
        parentControl: this,
        defaultValue: false,
        classes: 'hide-when-editing hide-when-moving',
        control: 'SuiToggleComponent',
        label: 'Bold'
      }
    );
  }
  changed() {
    this.handleChanged();
  }

  get parameterId() {
    return this.dialog.id + '-' + this.parameterName;
  }

  get html() {
    const b = htmlHelpers.buildDom;
    const q = b('div').classes(this.makeClasses('multiControl smoControl'));
    q.append(this.familyPart.html);
    q.append(this.sizePart.html);
    q.append(this.boldCtrl.html);
    q.append(this.italicsCtrl.html);

    return q;
  }

  _getInputElement() {
    var pid = this.parameterId;
    return $(this.dialog.dgDom.element).find('#' + pid).find('select');
  }
  getValue() {
    return {
      family: this.familyPart.getValue(),
      size: this.sizePart.getValue(),
      weight: this.boldCtrl.getValue() ? 'bold' : 'normal',
      style: this.italicsCtrl.getValue() ? 'italics' : 'normal'
    };
  }
  setValue(value) {
    let italics = false;
    // upconvert font size, all font sizes now in points.
    if (typeof(value.size) !== 'number') {
      value.size = SmoScoreText.fontPointSize(value.size);
    }
    if (value.style && value.style === 'italics') {
      italics = true;
    }
    const boldString = SmoScoreText.weightString(value.weight);
    const bold = boldString === 'bold';
    this.boldCtrl.setValue(bold);
    this.italicsCtrl.setValue(italics);
    this.familyPart.setValue(value.family);
    this.sizePart.setValue(value.size);
  }

  bind() {
    this.familyPart.bind();
    this.sizePart.bind();
    this.boldCtrl.bind();
    this.italicsCtrl.bind();
  }
}

// eslint-disable-next-line no-unused-vars
class SuiTextBlockComponent extends SuiComponentBase {
  constructor(dialog, parameter) {
    super(parameter);
    smoSerialize.filteredMerge(
      ['parameterName', 'smoName', 'defaultValue', 'options', 'control', 'label', 'dataType'], parameter, this);
    this.dialog = dialog;
    this.addBlockCtrl = new SuiButtonComposite(this.dialog,
      {
        smoName: 'addBlock',
        parameterName: 'addBlock',
        parentControl: this,
        defaultValue: false,
        icon: 'icon-plus',
        classes: 'hide-when-editing hide-when-moving',
        control: 'SuiButtonComponent',
        label: 'Add Text Block'
      });

    this.toggleBlockCtrl = new SuiButtonComposite(this.dialog,
      {
        smoName: 'toggleBlock',
        parameterName: 'toggleBlock',
        parentControl: this,
        defaultValue: false,
        icon: 'icon-arrow-right',
        classes: 'hide-when-editing hide-when-moving',
        control: 'SuiButtonComponent',
        label: 'Next Block'
      });

    this.removeBlockCtrl = new SuiButtonComposite(this.dialog,
      {
        smoName: 'removeBlock',
        parameterName: 'removeBlock',
        parentControl: this,
        defaultValue: false,
        icon: 'icon-minus',
        classes: 'hide-when-editing hide-when-moving',
        control: 'SuiButtonComponent',
        label: 'Remove Block'
      });
    this.relativePositionCtrl = new SuiDropdownComposite(
      this.dialog,
      {
        smoName: 'relativePosition',
        parameterName: 'relativePosition',
        parentControl: this,
        defaultValue: SmoScoreText.justifications.left,
        classes: 'hide-when-editing hide-when-moving',
        control: 'SuiDropdownComponent',
        label: 'Block Positions',
        startRow: true,
        options: [{
          value: SmoTextGroup.relativePositions.ABOVE,
          label: 'Above'
        }, {
          value: SmoTextGroup.relativePositions.BELOW,
          label: 'Below'
        }, {
          value: SmoTextGroup.relativePositions.LEFT,
          label: 'Left'
        }, {
          value: SmoTextGroup.relativePositions.RIGHT,
          label: 'Right'
        }]
      }
    );
    this.justificationCtrl = new SuiDropdownComposite(
      this.dialog,
      {
        smoName: 'justification',
        parameterName: 'justification',
        parentControl: this,
        defaultValue: SmoScoreText.justifications.left,
        classes: 'hide-when-editing hide-when-moving',
        control: 'SuiDropdownComponent',
        label: 'Justification',
        options: [{
          value: SmoTextGroup.justifications.LEFT,
          label: 'Left'
        }, {
          value: SmoTextGroup.justifications.RIGHT,
          label: 'Right'
        }, {
          value: SmoTextGroup.justifications.CENTER,
          label: 'Center'
        }]
      });
    this.spacingCtrl = new SuiRockerComposite(
      this.dialog,
      {
        smoName: 'spacing',
        parameterName: 'spacing',
        defaultValue: 0,
        parentControl: this,
        classes: 'hide-when-editing hide-when-moving',
        control: 'SuiRockerComponent',
        label: 'Spacing',
        type: 'float',
        increment: 0.1
      },
    );
    this.modifier = this.dialog.modifier;
    this.activeScoreText = this.dialog.activeScoreText;
  }
  changed() {
    if (this.addBlockCtrl.changeFlag) {
      const nt = new SmoScoreText(this.activeScoreText);
      this.modifier.addScoreText(nt);
      this.activeScoreText = nt;
      this.modifier.setActiveBlock(nt);
      this._updateMultiiFields();
    }
    if (this.relativePositionCtrl.changeFlag) {
      this.modifier.setRelativePosition(parseInt(this.relativePositionCtrl.getValue(), 10));
    }
    if (this.justificationCtrl.changeFlag) {
      this.modifier.justification = parseInt(this.justificationCtrl.getValue(), 10);
    }
    if (this.removeBlockCtrl.changeFlag) {
      this.modifier.removeBlock(this.activeScoreText);
      this.activeScoreText = this.modifier.firstBlock();
      this._updateMultiiFields();
    }
    if (this.toggleBlockCtrl.changeFlag) {
      const curIx = this.modifier.indexOf(this.activeScoreText);
      const newIx = (curIx + 1) % this.modifier.textBlocks.length;
      this.activeScoreText = this.modifier.textBlocks[newIx].text;
      this.modifier.setActiveBlock(this.activeScoreText);
    }
    if (this.spacingCtrl.changeFlag) {
      const val = this.spacingCtrl.getValue();
      if (val >= 0) {
        this.modifier.spacing = val;
      }
    }
    this.handleChanged();
  }

  get parameterId() {
    return this.dialog.id + '-' + this.parameterName;
  }

  get html() {
    const b = htmlHelpers.buildDom;
    const q = b('div').classes(this.makeClasses('multiControl smoControl'));
    q.append(this.addBlockCtrl.html);
    q.append(this.removeBlockCtrl.html);
    q.append(this.toggleBlockCtrl.html);
    q.append(this.relativePositionCtrl.html);
    q.append(this.justificationCtrl.html);
    q.append(this.spacingCtrl.html);

    return q;
  }

  _getInputElement() {
    return $(this.dialog.dgDom.element).find('#' + pid);
  }
  getValue() {
    return {
      activeScoreText: this.activeScoreText,
      modifier: this.modifier
    };
  }
  _updateMultiiFields() {
    const fields = [this.justificationCtrl, this.relativePositionCtrl,
      this.removeBlockCtrl, this.toggleBlockCtrl, this.spacingCtrl];
    fields.forEach((field) => {
      if (this.modifier.textBlocks.length < 2) {
        $('#' + field.parameterId).addClass('hide');
      } else {
        $('#' + field.parameterId).removeClass('hide');
      }
    });
  }
  setValue(value) {
    this.activeScoreText = value.activeScoreText;
    this.modifier = value.modifier;
    this.relativePositionCtrl.setValue(this.modifier.relativePosition);
    this._updateMultiiFields();
    this.justificationCtrl.setValue(this.modifier.justification);
    this.spacingCtrl.setValue(this.modifier.spacing);
  }

  bind() {
    this.addBlockCtrl.bind();
    this.relativePositionCtrl.bind();
    this.justificationCtrl.bind();
    this.removeBlockCtrl.bind();
    this.toggleBlockCtrl.bind();
    this.spacingCtrl.bind();
  }
}
;// ## measureDialogs.js
// This file contains dialogs that affect all measures at a certain position,
// such as tempo or time signature.
// eslint-disable-next-line no-unused-vars
class SuiMeasureDialog extends SuiDialogBase {
  static get attributes() {
    return ['pickupMeasure', 'makePickup', 'padLeft', 'padAllInSystem',
      'measureText', 'measureTextPosition'];
  }
  static get ctor() {
    return 'SuiMeasureDialog';
  }
  get ctor() {
    return SuiMeasureDialog.ctor;
  }
  static get dialogElements() {
    SuiMeasureDialog._dialogElements = typeof(SuiMeasureDialog._dialogElements) !== 'undefined' ? SuiMeasureDialog._dialogElements :
      [{
        staticText: [
          { label: 'Measure Properties' }]
      },
      {
        smoName: 'pickup',
        parameterName: 'pickup',
        defaultValue: '',
        control: CheckboxDropdownComponent,
        label: 'Pickup',
        toggleElement: {
          smoName: 'makePickup',
          parameterName: 'makePickup',
          defaultValue: false,
          control: 'SuiToggleComponent',
          label: 'Convert to Pickup Measure'
        },
        dropdownElement: {
          smoName: 'pickupMeasure',
          parameterName: 'pickupMeasure',
          defaultValue: 2048,
          control: 'SuiDropdownComponent',
          label: 'Pickup Measure',
          options: [{
            value: 2048,
            label: 'Eighth Note'
          }, {
            value: 4096,
            label: 'Quarter Note'
          }, {
            value: 6144,
            label: 'Dotted Quarter'
          }, {
            value: 8192,
            label: 'Half Note'
          }]
        }
      }, {
        parameterName: 'padLeft',
        smoName: 'padLeft',
        defaultValue: 0,
        control: 'SuiRockerComponent',
        label: 'Pad Left (px)'
      }, {
        parameterName: 'customStretch',
        smoName: 'customStretch',
        defaultValue: 0,
        control: 'SuiRockerComponent',
        label: 'Stretch Contents'
      }, {
        parameterName: 'customProportion',
        smoName: 'customProportion',
        defaultValue: SmoMeasure.defaults.customProportion,
        control: 'SuiRockerComponent',
        increment: 10,
        label: 'Adjust Proportional Spacing'
      }, {
        smoName: 'padAllInSystem',
        parameterName: 'padAllInSystem',
        defaultValue: false,
        control: 'SuiToggleComponent',
        label: 'Pad all measures in system'
      }, {
        smoName: 'autoJustify',
        parameterName: 'autoJustify',
        defaultValue: true,
        control: 'SuiToggleComponent',
        label: 'Justify Columns'
      }, {
        smoName: 'noteFormatting',
        parameterName: 'noteFormatting',
        defaultValue: 0,
        control: 'SuiDropdownComponent',
        label: 'Collision Avoidance',
        options: [{
          value: 0,
          label: 'Off'
        }, {
          value: 1,
          label: '1x'
        }, {
          value: 2,
          label: '2x'
        }, {
          value: 5,
          label: '5x'
        }, {
          value: 10,
          label: '10x'
        }]
      }, {
        smoName: 'measureTextPosition',
        parameterName: 'measureTextPosition',
        defaultValue: SmoMeasureText.positions.above,
        control: 'SuiDropdownComponent',
        label: 'Text Position',
        options: [{
          value: SmoMeasureText.positions.left,
          label: 'Left'
        }, {
          value: SmoMeasureText.positions.right,
          label: 'Right'
        }, {
          value: SmoMeasureText.positions.above,
          label: 'Above'
        }, {
          value: SmoMeasureText.positions.below,
          label: 'Below'
        }]
      }, {
        smoName: 'systemBreak',
        parameterName: 'systemBreak',
        defaultValue: false,
        control: 'SuiToggleComponent',
        label: 'System break before this measure'
      }];
    return SuiMeasureDialog._dialogElements;
  }
  static createAndDisplay(parameters) {
    // SmoUndoable.scoreSelectionOp(score,selection,'addTempo',
    //      new SmoTempoText({bpm:144}),undo,'tempo test 1.3');
    parameters.selection = parameters.view.tracker.selections[0];
    const dg = new SuiMeasureDialog(parameters);
    dg.display();
    return dg;
  }
  changed() {
    this.edited = true;
    if (this.pickupCtrl.changeFlag) {
      if (this.pickupCtrl.toggleCtrl.getValue() === false) {
        this.view.createPickup(smoMusic.timeSignatureToTicks(this.measure.timeSignature));
      } else {
        this.view.createPickup(this.pickupCtrl.dropdownCtrl.getValue());
      }
    }
    if (this.customStretchCtrl.changeFlag) {
      this.view.setMeasureStretch(this.customStretchCtrl.getValue());
    }
    if (this.customProportionCtrl.changeFlag) {
      this.view.setMeasureProportion(this.customProportionCtrl.getValue());
    }
    if (this.systemBreakCtrl.changeFlag) {
      this.view.forceSystemBreak(this.systemBreakCtrl.getValue());
    }
    if (this.autoJustifyCtrl.changeFlag) {
      this.view.setAutoJustify(this.autoJustifyCtrl.getValue());
    }
    if (this.noteFormattingCtrl.changeFlag) {
      this.view.setCollisionAvoidance(parseInt(this.noteFormattingCtrl.getValue(), 10));
    }
    if (this.padLeftCtrl.changeFlag || this.padAllInSystemCtrl.changeFlag) {
      this.view.padMeasure(this.padLeftCtrl.getValue(), this.padAllInSystemCtrl.getValue());
    }
    //
    this._updateConditionals();
  }
  constructor(parameters) {
    if (!parameters.selection) {
      throw new Error('measure dialogmust have measure and selection');
    }

    super(SuiMeasureDialog.dialogElements, {
      id: 'dialog-measure',
      top: parameters.selection.measure.renderedBox.y,
      left: parameters.selection.measure.renderedBox.x,
      label: 'Measure Properties',
      ...parameters
    });
    this.view.groupUndo(true);
    this.edited = false;
    this.startPromise = parameters.closeMenuPromise;
    if (!this.startPromise) {
      this.startPromise = new Promise((resolve) => {
        resolve();
      });
    }

    this.refresh = false;
    Vex.Merge(this, parameters);

    // The 'modifier' that this dialog acts on is a measure.
    this.measure = this.selection.measure;
    this.modifier = this.measure;
  }
  display() {
    super.display();
    const getKeys = () => {
      this.completeNotifier.unbindKeyboardForModal(this);
    };
    this.startPromise.then(getKeys);
  }
  _updateConditionals() {
    if (this.padLeftCtrl.getValue() !== 0 || this.padLeftCtrl.changeFlag) {
      $('.attributeDialog .attributeModal').addClass('pad-left-select');
    } else {
      $('.attributeDialog .attributeModal').removeClass('pad-left-select');
    }
  }
  populateInitial() {
    this.padLeftCtrl.setValue(this.measure.padLeft);
    this.autoJustifyCtrl.setValue(this.measure.autoJustify);
    const isPickup = this.measure.isPickup();
    this.customStretchCtrl.setValue(this.measure.customStretch);
    this.customProportionCtrl.setValue(this.measure.customProportion);
    this.noteFormattingCtrl.setValue(this.measure.getFormattingIterations());
    this.pickupCtrl.toggleCtrl.setValue(isPickup);
    if (isPickup) {
      this.pickupCtrl.dropdownCtrl.setValue(this.measure.getTicksFromVoice(0));
    }

    const isSystemBreak = this.measure.getForceSystemBreak();
    this.systemBreakCtrl.setValue(isSystemBreak);
    this._updateConditionals();

    // TODO: handle multiples (above/below)
    this.measure.getMeasureText();
  }
  _bindElements() {
    const dgDom = this.dgDom;
    this.bindKeyboard();
    this._bindComponentNames();
    this.populateInitial();

    $(dgDom.element).find('.ok-button').off('click').on('click', () => {
      this.view.groupUndo(false);
      this.complete();
    });
    $(dgDom.element).find('.cancel-button').off('click').on('click', () => {
      this.view.groupUndo(false);
      if (this.edited) {
        this.view.undo();
      }
      this.complete();
    });
    $(dgDom.element).find('.remove-button').off('click').on('click', () => {
      this.groupUndo(false);
      this.complete();
    });
  }
}

// eslint-disable-next-line no-unused-vars
class SuiInstrumentDialog extends SuiDialogBase {
  static get ctor() {
    return 'SuiInstrumentDialog';
  }
  get ctor() {
    return SuiInstrumentDialog.ctor;
  }
  static get applyTo() {
    return {
      score: 0, selected: 1, remaining: 3
    };
  }
  static get dialogElements() {
    SuiInstrumentDialog._dialogElements = typeof(SuiInstrumentDialog._dialogElements) !== 'undefined' ?
      SuiInstrumentDialog._dialogElements :
      [{
        staticText: [
          { label: 'Instrument Properties' }
        ]
      },
      {
        smoName: 'transposeIndex',
        parameterName: 'transposeIndex',
        defaultValue: 0,
        control: 'SuiRockerComponent',
        label: 'Transpose Index (1/2 steps)',
      }, {
        smoName: 'applyTo',
        parameterName: 'applyTo',
        defaultValue: SuiInstrumentDialog.applyTo.score,
        control: 'SuiDropdownComponent',
        label: 'Apply To',
        options: [{
          value: SuiInstrumentDialog.applyTo.score,
          label: 'Score'
        }, {
          value: SuiInstrumentDialog.applyTo.selected,
          label: 'Selected Measures'
        }, {
          value: SuiInstrumentDialog.applyTo.remaining,
          label: 'Remaining Measures'
        }]
      }];
    return SuiInstrumentDialog._dialogElements;
  }
  static createAndDisplay(parameters) {
    var db = new SuiInstrumentDialog(parameters);
    db.display();
    return db;
  }
  display() {
    $('body').addClass('showAttributeDialog');
    this.components.forEach((component) => {
      component.bind();
    });
    this._bindComponentNames();
    this._bindElements();
    this.position(this.measure.renderedBox);
    this.view.tracker.scroller.scrollVisibleBox(
      svgHelpers.smoBox($(this.dgDom.element)[0].getBoundingClientRect())
    );

    const cb = () => {};
    htmlHelpers.draggable({
      parent: $(this.dgDom.element).find('.attributeModal'),
      handle: $(this.dgDom.element).find('.jsDbMove'),
      animateDiv: '.draganime',
      cb,
      moveParent: true
    });
    this.completeNotifier.unbindKeyboardForModal(this);
  }
  populateInitial() {
    const ix = this.measure.transposeIndex;
    this.transposeIndexCtrl.setValue(ix);
  }

  changed() {
    let i = 0;
    const staffIx = this.measure.measureNumber.staffId;
    const xpose = this.transposeIndexCtrl.getValue();
    const selections = [];
    for (i = 0; i < this.score.staves[staffIx].measures.length; ++i) {
      selections.push(SmoSelection.measureSelection(this.score, staffIx, i));
    }
    this.view.changeInstrument(
      {
        instrumentName: 'Treble Instrument',
        keyOffset: xpose,
        clef: this.measure.clef
      },
      selections,
      this.undoBuffer
    );
  }

  constructor(parameters) {
    const selection = parameters.view.tracker.selections[0];
    const measure = selection.measure;

    parameters = { selection, measure, ...parameters };

    super(SuiInstrumentDialog.dialogElements, {
      id: 'time-signature-measure',
      top: measure.renderedBox.y,
      left: measure.renderedBox.x,
      ...parameters
    });
    this.measure = measure;
    this.score = this.keyCommands.score;
    this.refresh = false;
    this.startPromise = parameters.closeMenuPromise;
    Vex.Merge(this, parameters);
  }
  _bindElements() {
    var dgDom = this.dgDom;
    this.populateInitial();

    $(dgDom.element).find('.ok-button').off('click').on('click', () => {
      this.complete();
    });

    $(dgDom.element).find('.cancel-button').off('click').on('click', () => {
      this.complete();
    });
    $(dgDom.element).find('.remove-button').off('click').on('click', () => {
      this.complete();
    });
  }
}

// eslint-disable-next-line no-unused-vars
class SuiInsertMeasures extends SuiDialogBase {
  static get ctor() {
    return 'SuiInsertMeasures';
  }
  get ctor() {
    return SuiInsertMeasures.ctor;
  }

  static get dialogElements() {
    SuiInsertMeasures._dialogElements = typeof(SuiInsertMeasures._dialogElements) !== 'undefined' ?
      SuiInsertMeasures._dialogElements :
      [{
        staticText: [
          { label: 'Insert Measures' }
        ]
      }, {
        smoName: 'measureCount',
        parameterName: 'measureCount',
        defaultValue: 0,
        control: 'SuiRockerComponent',
        label: 'Measures to Insert',
      }, {
        smoName: 'append',
        parameterName: 'append',
        defaultValue: true,
        control: 'SuiToggleComponent',
        label: 'Append to Selection'
      }];
    return SuiInsertMeasures._dialogElements;
  }
  static createAndDisplay(parameters) {
    var db = new SuiInsertMeasures(parameters);
    db.display();
    return db;
  }
  display() {
    $('body').addClass('showAttributeDialog');
    this.components.forEach((component) => {
      component.bind();
    });
    this._bindComponentNames();
    this._bindElements();
    this.position(this.measure.renderedBox);
    this.view.tracker.scroller.scrollVisibleBox(
      svgHelpers.smoBox($(this.dgDom.element)[0].getBoundingClientRect())
    );

    const cb = () => {};
    htmlHelpers.draggable({
      parent: $(this.dgDom.element).find('.attributeModal'),
      handle: $(this.dgDom.element).find('.jsDbMove'),
      animateDiv: '.draganime',
      cb,
      moveParent: true
    });
    const getKeys = () => {
      this.completeNotifier.unbindKeyboardForModal(this);
    };
    this.startPromise.then(getKeys);
  }
  populateInitial() {
    this.measureCountCtrl.setValue(1);
  }

  // noop
  changed() {
  }

  constructor(parameters) {
    const selection = parameters.view.tracker.selections[0];
    const measure = selection.measure;
    parameters = { selection, measure, ...parameters };
    super(SuiInsertMeasures.dialogElements, {
      id: 'time-signature-measure',
      top: measure.renderedBox.y,
      left: measure.renderedBox.x,
      ...parameters
    });
    this.measure = measure;
    Vex.Merge(this, parameters);
    if (!this.startPromise) {
      this.startPromise = new Promise((resolve) => {
        resolve();
      });
    }
  }
  _bindElements() {
    var dgDom = this.dgDom;
    this.populateInitial();
    $(dgDom.element).find('.ok-button').off('click').on('click', () => {
      this.view.addMeasures(this.appendCtrl.getValue(), this.measureCountCtrl.getValue());
      this.complete();
    });
    $(dgDom.element).find('.cancel-button').off('click').on('click', () => {
      this.complete();
    });
    $(dgDom.element).find('.remove-button').remove();
  }
}

// eslint-disable-next-line no-unused-vars
class SuiTimeSignatureDialog extends SuiDialogBase {
  static get ctor() {
    return 'SuiTimeSignatureDialog';
  }
  get ctor() {
    return SuiTimeSignatureDialog.ctor;
  }

  static get dialogElements() {
    SuiTimeSignatureDialog._dialogElements = SuiTimeSignatureDialog._dialogElements ? SuiTimeSignatureDialog._dialogElements :
      [
        { staticText: [
          { label: 'Custom Time Signature' }
        ] },
        {
          smoName: 'numerator',
          parameterName: 'numerator',
          defaultValue: 3,
          control: 'SuiRockerComponent',
          label: 'Beats/Measure',
        },
        {
          parameterName: 'denominator',
          smoName: 'denominator',
          defaultValue: 8,
          dataType: 'int',
          control: 'SuiDropdownComponent',
          label: 'Beat Value',
          options: [{
            value: 8,
            label: '8',
          }, {
            value: 4,
            label: '4'
          }, {
            value: 2,
            label: '2'
          }]
        }];
    return SuiTimeSignatureDialog._dialogElements;
  }
  populateInitial() {
    const nd = this.measure.timeSignature.split('/');
    const num = parseInt(nd[0], 10);
    const den = parseInt(nd[1], 10);
    this.numeratorCtrl.setValue(num);
    this.denominatorCtrl.setValue(den);
  }

  changed() {
    // no dynamic change for time  signatures
  }
  static createAndDisplay(params) {
    var dg = new SuiTimeSignatureDialog(
      params
    );
    dg.display();
    return dg;
  }

  changeTimeSignature() {
    const ts = '' + this.numeratorCtrl.getValue() + '/' + this.denominatorCtrl.getValue();
    this.view.setTimeSignature(ts);
  }
  _bindElements() {
    const dgDom = this.dgDom;
    this.numeratorCtrl = this.components.find((comp) => comp.smoName === 'numerator');
    this.denominatorCtrl = this.components.find((comp) => comp.smoName === 'denominator');
    this.populateInitial();
    $(dgDom.element).find('.ok-button').off('click').on('click', () => {
      this.changeTimeSignature();
      this.complete();
    });
    $(dgDom.element).find('.cancel-button').off('click').on('click', () => {
      this.complete();
    });
    $(dgDom.element).find('.remove-button').off('click').on('click', () => {
      this.complete();
    });
  }
  display() {
    $('body').addClass('showAttributeDialog');
    this.components.forEach((component) => {
      component.bind();
    });
    this._bindElements();
    this.position(this.measure.renderedBox);
    this.view.tracker.scroller.scrollVisibleBox(
      svgHelpers.smoBox($(this.dgDom.element)[0].getBoundingClientRect())
    );

    const cb = () => {};
    htmlHelpers.draggable({
      parent: $(this.dgDom.element).find('.attributeModal'),
      handle: $(this.dgDom.element).find('.jsDbMove'),
      animateDiv: '.draganime',
      cb,
      moveParent: true
    });

    const getKeys = () => {
      this.completeNotifier.unbindKeyboardForModal(this);
    };
    this.startPromise.then(getKeys);
  }
  constructor(parameters) {
    const measure = parameters.view.tracker.selections[0].measure;

    super(SuiTimeSignatureDialog.dialogElements, {
      id: 'time-signature-measure',
      top: measure.renderedBox.y,
      left: measure.renderedBox.x,
      label: 'Custom Time Signature',
      ...parameters
    });
    this.measure = measure;
    this.refresh = false;
    this.startPromise = parameters.closeMenuPromise;
    Vex.Merge(this, parameters);
  }
}

// ## SuiTempoDialog
// Allow user to choose a tempo or tempo change.
// eslint-disable-next-line no-unused-vars
class SuiTempoDialog extends SuiDialogBase {
  static get ctor() {
    return 'SuiTempoDialog';
  }
  get ctor() {
    return SuiTempoDialog.ctor;
  }
  static get attributes() {
    return ['tempoMode', 'bpm', 'beatDuration', 'tempoText', 'yOffset'];
  }
  static get dialogElements() {
    SuiTempoDialog._dialogElements = SuiTempoDialog._dialogElements ? SuiTempoDialog._dialogElements :
      [
        { staticText: [
          { label: 'Tempo Properties' }
        ]
        },
        {
          smoName: 'tempoMode',
          parameterName: 'tempoMode',
          defaultValue: SmoTempoText.tempoModes.durationMode,
          control: 'SuiDropdownComponent',
          label: 'Tempo Mode',
          options: [{
            value: 'duration',
            label: 'Duration (Beats/Minute)'
          }, {
            value: 'text',
            label: 'Tempo Text'
          }, {
            value: 'custom',
            label: 'Specify text and duration'
          }
          ]
        },
        {
          smoName: 'customText',
          parameterName: 'customText',
          defaultValue: '',
          control: 'SuiTextInputComponent',
          label: 'Custom Text',
          classes: 'hide-when-text-mode'
        },
        {
          parameterName: 'bpm',
          smoName: 'bpm',
          defaultValue: 120,
          control: 'SuiRockerComponent',
          label: 'Notes/Minute'
        },
        {
          parameterName: 'duration',
          smoName: 'beatDuration',
          defaultValue: 4096,
          dataType: 'int',
          control: 'SuiDropdownComponent',
          label: 'Unit for Beat',
          options: [{
            value: 4096,
            label: 'Quarter Note',
          }, {
            value: 2048,
            label: '1/8 note'
          }, {
            value: 6144,
            label: 'Dotted 1/4 note'
          }, {
            value: 8192,
            label: '1/2 note'
          }
          ]
        },
        {
          smoName: 'tempoText',
          parameterName: 'tempoText',
          defaultValue: SmoTempoText.tempoTexts.allegro,
          control: 'SuiDropdownComponent',
          label: 'Tempo Text',
          classes: 'hide-when-not-text-mode',
          options: [{
            value: SmoTempoText.tempoTexts.larghissimo,
            label: 'Larghissimo'
          }, {
            value: SmoTempoText.tempoTexts.grave,
            label: 'Grave'
          }, {
            value: SmoTempoText.tempoTexts.lento,
            label: 'Lento'
          }, {
            value: SmoTempoText.tempoTexts.largo,
            label: 'Largo'
          }, {
            value: SmoTempoText.tempoTexts.larghetto,
            label: 'Larghetto'
          }, {
            value: SmoTempoText.tempoTexts.adagio,
            label: 'Adagio'
          }, {
            value: SmoTempoText.tempoTexts.adagietto,
            label: 'Adagietto'
          }, {
            value: SmoTempoText.tempoTexts.andante_moderato,
            label: 'Andante moderato'
          }, {
            value: SmoTempoText.tempoTexts.andante,
            label: 'Andante'
          }, {
            value: SmoTempoText.tempoTexts.andantino,
            label: 'Andantino'
          }, {
            value: SmoTempoText.tempoTexts.moderator,
            label: 'Moderato'
          }, {
            value: SmoTempoText.tempoTexts.allegretto,
            label: 'Allegretto',
          }, {
            value: SmoTempoText.tempoTexts.allegro,
            label: 'Allegro'
          }, {
            value: SmoTempoText.tempoTexts.vivace,
            label: 'Vivace'
          }, {
            value: SmoTempoText.tempoTexts.presto,
            label: 'Presto'
          }, {
            value: SmoTempoText.tempoTexts.prestissimo,
            label: 'Prestissimo'
          }
          ]
        }, {
          smoName: 'applyToAll',
          parameterName: 'applyToAll',
          defaultValue: false,
          control: 'SuiToggleComponent',
          label: 'Apply to all future measures?'
        }, {
          smoName: 'display',
          parameterName: 'display',
          defaultValue: true,
          control: 'SuiToggleComponent',
          label: 'Display Tempo'
        }, {
          smoName: 'yOffset',
          parameterName: 'yOffset',
          defaultValue: 0,
          control: 'SuiRockerComponent',
          label: 'Y Offset'
        }
      ];
    return SuiTempoDialog._dialogElements;
  }
  static createAndDisplay(parameters) {
    parameters.measures = SmoSelection.getMeasureList(parameters.view.tracker.selections)
      .map((sel) => sel.measure);
    const measure = parameters.measures[0];

    // All measures have a default tempo, but it is not explicitly set unless it is
    // non-default
    parameters.modifier = measure.getTempo();
    if (!parameters.modifier) {
      parameters.modifier = new SmoTempoText();
    }
    if (!parameters.modifier.renderedBox) {
      parameters.modifier.renderedBox = svgHelpers.copyBox(measure.renderedBox);
    }
    const dg = new SuiTempoDialog(parameters);
    dg.display();
    dg._bindComponentNames();
    return dg;
  }
  constructor(parameters) {
    if (!parameters.modifier || !parameters.measures) {
      throw new Error('modifier attribute dialog must have modifier and selection');
    }

    super(SuiTempoDialog.dialogElements, {
      id: 'dialog-tempo',
      top: parameters.modifier.renderedBox.y,
      left: parameters.modifier.renderedBox.x,
      ...parameters
    });
    this.refresh = false;
    Vex.Merge(this, parameters);
  }
  populateInitial() {
    SmoTempoText.attributes.forEach((attr) => {
      var comp = this.components.find((cc) => cc.smoName === attr);
      if (comp) {
        comp.setValue(this.modifier[attr]);
      }
    });
    this._updateModeClass();
  }
  _updateModeClass() {
    if (this.modifier.tempoMode === SmoTempoText.tempoModes.textMode) {
      $('.attributeModal').addClass('tempoTextMode');
      $('.attributeModal').removeClass('tempoDurationMode');
    } else if (this.modifier.tempoMode === SmoTempoText.tempoModes.durationMode) {
      $('.attributeModal').addClass('tempoDurationMode');
      $('.attributeModal').removeClass('tempoTextMode');
    } else {
      $('.attributeModal').removeClass('tempoDurationMode');
      $('.attributeModal').removeClass('tempoTextMode');
    }
  }
  changed() {
    this.components.forEach((component) => {
      if (SmoTempoText.attributes.indexOf(component.smoName) >= 0) {
        this.modifier[component.smoName] = component.getValue();
      }
    });
    if (this.modifier.tempoMode === SmoTempoText.tempoModes.textMode) {
      this.modifier.bpm = SmoTempoText.bpmFromText[this.modifier.tempoText];
    }
    if (this.customTextCtrl.changeFlag) {
      this.modifier.customText = this.customTextCtrl.getValue();
    }
    this._updateModeClass();
    this.view.updateTempoScore(this.modifier, this.applyToAllCtrl.getValue());
  }
  // ### handleRemove
  // Removing a tempo change is like changing the measure to the previous measure's tempo.
  // If this is the first measure, use the default value.
  handleRemove() {
    this.view.removeTempo(this.applyToAllCtrl.getValue());
  }
  // ### Populate the initial values and bind to the buttons.
  _bindElements() {
    this.populateInitial();
    const dgDom = this.dgDom;
    // Create promise to release the keyboard when dialog is closed
    this.closeDialogPromise = new Promise((resolve) => {
      $(dgDom.element).find('.cancel-button').remove();
      $(dgDom.element).find('.ok-button').off('click').on('click', () => {
        this.complete();
        resolve();
      });
      $(dgDom.element).find('.remove-button').off('click').on('click', () => {
        this.handleRemove();
        this.complete();
        resolve();
      });
    });
    this.completeNotifier.unbindKeyboardForModal(this);
  }
}
;// ## SuiScoreViewDialog
// decide which rows of the score to look at
// eslint-disable-next-line no-unused-vars
class SuiScoreViewDialog extends SuiDialogBase {
  static get ctor() {
    return 'SuiScoreViewDialog';
  }
  get ctor() {
    return SuiScoreViewDialog.ctor;
  }
  static get dialogElements() {
    SuiScoreViewDialog._dialogElements = typeof(SuiScoreViewDialog._dialogElements) !== 'undefined' ? SuiScoreViewDialog._dialogElements :
      [{
        smoName: 'scoreView',
        parameterName: 'scoreView',
        defaultValue: [],
        control: 'StaffCheckComponent',
        label: 'Show staff',
      }, {
        staticText: [
          { label: 'Score View' }
        ]
      }];
    return SuiScoreViewDialog._dialogElements;
  }
  static createAndDisplay(parameters) {
    const dg = new SuiScoreViewDialog(parameters);
    dg.display();
  }
  display() {
    $('body').addClass('showAttributeDialog');
    this.components.forEach((component) => {
      component.bind();
    });
    const cb = () => {};
    htmlHelpers.draggable({
      parent: $(this.dgDom.element).find('.attributeModal'),
      handle: $(this.dgDom.element).find('.icon-move'),
      animateDiv: '.draganime',
      cb,
      moveParent: true
    });

    const getKeys = () => {
      this.completeNotifier.unbindKeyboardForModal(this);
    };
    this.startPromise.then(getKeys);
    this._bindElements();
    this.scoreViewCtrl.setValue(this.view.getView());
    const box = svgHelpers.boxPoints(250, 250, 1, 1);
    SuiDialogBase.position(box, this.dgDom, this.view.tracker.scroller);
  }
  _bindElements() {
    const self = this;
    const dgDom = this.dgDom;
    this._bindComponentNames();
    $(dgDom.element).find('.ok-button').off('click').on('click', () => {
      self.complete();
    });

    $(dgDom.element).find('.cancel-button').off('click').on('click', () => {
      self.view.viewAll();
      self.complete();
    });

    $(dgDom.element).find('.remove-button').remove();
    this.bindKeyboard();
  }

  changed() {
    this.view.setView(this.scoreViewCtrl.getValue());
  }
  constructor(parameters) {
    var p = parameters;
    super(SuiScoreViewDialog.dialogElements, {
      id: 'dialog-layout',
      top: (p.view.score.layout.pageWidth / 2) - 200,
      left: (p.view.score.layout.pageHeight / 2) - 200,
      ...parameters
    });
    this.startPromise = p.startPromise;
  }
}

// ## SuiScorePreferencesDialog
// change editor and formatting defaults for this score.
// eslint-disable-next-line no-unused-vars
class SuiScorePreferencesDialog extends SuiDialogBase {
  static get ctor() {
    return 'SuiScorePreferencesDialog';
  }
  get ctor() {
    return SuiScorePreferencesDialog.ctor;
  }
  static get dialogElements() {
    SuiScorePreferencesDialog._dialogElements = typeof(SuiScorePreferencesDialog._dialogElements)
      !== 'undefined' ? SuiScorePreferencesDialog._dialogElements :
      [{
        smoName: 'scoreName',
        parameterName: 'scoreName',
        defaultValue: [],
        control: 'SuiTextInputComponent',
        label: 'Score Name',
      }, {
        smoName: 'autoPlay',
        parameterName: 'autoPlay',
        defaultValue: [],
        control: 'SuiToggleComponent',
        label: 'Play Selections',
      }, {
        smoName: 'autoAdvance',
        parameterName: 'autoAdvance',
        defaultValue: [],
        control: 'SuiToggleComponent',
        label: 'Auto-Advance Cursor',
      }, {
        smoName: 'customProportion',
        parameterName: 'customProportion',
        defaultValue: SmoScore.defaults.preferences.customProportion,
        control: 'SuiRockerComponent',
        type: 'int',
        increment: 10,
        label: 'Adjust Proportional Spacing'
      }, {
        staticText: [
          { label: 'Score Preferences' }
        ]
      }];
    return SuiScorePreferencesDialog._dialogElements;
  }
  static createAndDisplay(parameters) {
    const dg = new SuiScorePreferencesDialog(parameters);
    dg.display();
  }
  display() {
    $('body').addClass('showAttributeDialog');
    this.components.forEach((component) => {
      component.bind();
    });
    const cb = () => {};
    htmlHelpers.draggable({
      parent: $(this.dgDom.element).find('.attributeModal'),
      handle: $(this.dgDom.element).find('.icon-move'),
      animateDiv: '.draganime',
      cb,
      moveParent: true
    });
    const getKeys = () => {
      this.completeNotifier.unbindKeyboardForModal(this);
    };
    this.startPromise.then(getKeys);
    this._bindElements();
    this.scoreNameCtrl.setValue(this.view.score.scoreInfo.name);
    this.autoPlayCtrl.setValue(this.view.score.preferences.autoPlay);
    this.autoAdvanceCtrl.setValue(this.view.score.preferences.autoAdvance);
    this.customProportionCtrl.setValue(this.view.score.preferences.customProportion);
    const box = svgHelpers.boxPoints(250, 250, 1, 1);
    SuiDialogBase.position(box, this.dgDom, this.view.tracker.scroller);
  }
  _bindElements() {
    const dgDom = this.dgDom;
    this._bindComponentNames();
    $(dgDom.element).find('.ok-button').off('click').on('click', () => {
      this.complete();
    });

    $(dgDom.element).find('.cancel-button').off('click').on('click', () => {
      this.complete();
    });

    $(dgDom.element).find('.remove-button').remove();
    this.bindKeyboard();
  }

  changed() {
    if (this.scoreNameCtrl.changeFlag) {
      const newInfo = JSON.parse(JSON.stringify(this.view.score.scoreInfo));
      newInfo.name = this.scoreNameCtrl.getValue();
      this.view.updateScoreInfo(newInfo);
      return;
    }
    if (this.autoPlayCtrl.changeFlag) {
      this.view.score.preferences.autoPlay = this.autoPlayCtrl.getValue();
    }
    if (this.autoAdvanceCtrl.changeFlag) {
      this.view.score.preferences.autoAdvance = this.autoAdvanceCtrl.getValue();
    }
    if  (this.customProportionCtrl.changeFlag) {
      // changing this means we update all the measures in the score with the
      // new default value
      const oldDefault = this.view.score.preferences.customProportion;
      const newValue = this.customProportionCtrl.getValue();
      if (oldDefault !== newValue) {
        this.view.updateProportionDefault(oldDefault, newValue);
        return;
      }
    }
    this.view.updateScorePreferences();
  }
  constructor(parameters) {
    var p = parameters;
    super(SuiScorePreferencesDialog.dialogElements, {
      id: 'dialog-layout',
      top: (p.view.score.layout.pageWidth / 2) - 200,
      left: (p.view.score.layout.pageHeight / 2) - 200,
      ...parameters
    });
    this.startPromise = p.startPromise;
  }
}

// ## SuiScorePreferencesDialog
// change editor and formatting defaults for this score.
// eslint-disable-next-line no-unused-vars
class SuiScoreIdentificationDialog extends SuiDialogBase {
  static get ctor() {
    return 'SuiScoreIdentificationDialog';
  }
  get ctor() {
    return SuiScoreIdentificationDialog.ctor;
  }
  static get dialogElements() {
    SuiScoreIdentificationDialog._dialogElements = typeof(SuiScoreIdentificationDialog._dialogElements)
      !== 'undefined' ? SuiScoreIdentificationDialog._dialogElements :
      [{
        smoName: 'title',
        parameterName: 'title',
        defaultValue: '',
        control: 'TextCheckComponent',
        label: 'Title',
      }, {
        smoName: 'subTitle',
        parameterName: 'subTitle',
        defaultValue: [],
        control: 'TextCheckComponent',
        label: 'Sub Title',
      }, {
        smoName: 'composer',
        parameterName: 'composer',
        defaultValue: [],
        control: 'TextCheckComponent',
        label: 'Composer',
      }, {
        smoName: 'copyright',
        parameterName: 'copyright',
        defaultValue: SmoScore.defaults.preferences.customProportion,
        control: 'TextCheckComponent',
        label: 'Copyright'
      }, {
        staticText: [
          { label: 'Score Preferences' },
          { titleText: 'Title' },
          { subTitleText: 'Sub-title' },
          { copyrightText: 'Copyright' },
          { composerText: 'Composer' },
          { show: 'Show' }
        ]
      }];
    return SuiScoreIdentificationDialog._dialogElements;
  }
  get purposeToFont() {
    const rv = {};
    rv[SmoTextGroup.purposes.TITLE] = {
      fontFamily: 'Merriweather',
      fontSize: 18,
      justification: SmoTextGroup.justifications.CENTER,
      xPlacement: 0.5,
      yOffset: 4
    };
    rv[SmoTextGroup.purposes.SUBTITLE] = {
      fontFamily: 'Merriweather',
      fontSize: 16,
      justification: SmoTextGroup.justifications.CENTER,
      xPlacement: 0.5,
      yOffset: 20,
    };
    rv[SmoTextGroup.purposes.COMPOSER] = {
      fontFamily: 'Merriweather',
      fontSize: 12,
      justification: SmoTextGroup.justifications.RIGHT,
      xPlacement: 0.8,
      yOffset: 10
    };
    rv[SmoTextGroup.purposes.COPYRIGHT] = {
      fontFamily: 'Merriweather',
      fontSize: 12,
      xPlacement: 0.5,
      justification: SmoTextGroup.justifications.CENTER,
      yOffset: -12
    };
    return rv;
  }
  static createAndDisplay(parameters) {
    const dg = new SuiScoreIdentificationDialog(parameters);
    dg.display();
  }
  _setInitialValues() {
    const titleText = this.score.getTextGroups().find((tg) => tg.purpose === SmoTextGroup.purposes.TITLE);
    const subText = this.score.getTextGroups().find((tg) => tg.purpose === SmoTextGroup.purposes.SUBTITLE);
    const composerText = this.score.getTextGroups().find((tg) => tg.purpose === SmoTextGroup.purposes.COMPOSER);
    const copyrightText = this.score.getTextGroups().find((tg) => tg.purpose === SmoTextGroup.purposes.COPYRIGHT);
    this.titleCtrl.setValue({ text: this.scoreInfo.title, checked: titleText !== null });
    this.subTitleCtrl.setValue({ text: this.scoreInfo.subTitle, checked: subText !== null });
    this.composerCtrl.setValue({ text: this.scoreInfo.composer, checked: composerText !== null });
    this.copyrightCtrl.setValue({ text: this.scoreInfo.copyright, checked: copyrightText !== null });
  }
  _createText(purpose, text) {
    const existing = this.score.getTextGroups().find((tg) => tg.purpose === purpose);
    if (existing) {
      const copy = SmoTextGroup.deserialize(existing.serialize());
      copy.attrs.id = existing.attrs.id;
      copy.firstBlock().text = text;
      this.view.updateTextGroup(existing, copy);
      return;
    }
    const tg = SmoTextGroup.createTextForLayout(purpose, text, this.score.layout);
    this.view.addTextGroup(tg);
  }
  _removeText(purpose) {
    const existing = this.score.getTextGroups().find((tg) => tg.purpose === purpose);
    if (existing) {
      this.view.removeTextGroup(existing);
    }
  }
  display() {
    $('body').addClass('showAttributeDialog');
    this.components.forEach((component) => {
      component.bind();
    });
    const cb = () => {};
    htmlHelpers.draggable({
      parent: $(this.dgDom.element).find('.attributeModal'),
      handle: $(this.dgDom.element).find('.icon-move'),
      animateDiv: '.draganime',
      cb,
      moveParent: true
    });
    const getKeys = () => {
      this.completeNotifier.unbindKeyboardForModal(this);
    };
    this.startPromise.then(getKeys);
    this._bindElements();
    this._setInitialValues();
    const box = svgHelpers.boxPoints(250, 250, 1, 1);
    SuiDialogBase.position(box, this.dgDom, this.view.tracker.scroller);
  }
  _bindElements() {
    const dgDom = this.dgDom;
    this._bindComponentNames();
    $(dgDom.element).find('.ok-button').off('click').on('click', () => {
      this.complete();
    });

    $(dgDom.element).find('.cancel-button').off('click').on('click', () => {
      this.complete();
    });

    $(dgDom.element).find('.remove-button').remove();
    this.bindKeyboard();
  }

  changed() {
    const params = [
      { control: 'titleCtrl', purpose: SmoTextGroup.purposes.TITLE, scoreField: 'title' },
      { control: 'subTitleCtrl', purpose: SmoTextGroup.purposes.SUBTITLE, scoreField: 'subTitle' },
      { control: 'composerCtrl', purpose: SmoTextGroup.purposes.COMPOSER, scoreField: 'composer' },
      { control: 'copyrightCtrl', purpose: SmoTextGroup.purposes.COPYRIGHT, scoreField: 'copyright' },
    ];
    params.forEach((param) => {
      if (this[param.control].changeFlag) {
        const val = this[param.control].getValue();
        if (val.checked === true) {
          this._createText(param.purpose, val.text);
        } else {
          this._removeText(param.purpose, val.text);
        }
        const scoreInfo = JSON.parse(JSON.stringify(this.scoreInfo));
        scoreInfo.name = scoreInfo.title;
        scoreInfo[param.scoreField] = val.text;
        this.view.updateScoreInfo(scoreInfo);
        this.scoreInfo = this.score.scoreInfo;
      }
    });
  }
  constructor(parameters) {
    var p = parameters;
    super(SuiScoreIdentificationDialog.dialogElements, {
      id: 'dialog-layout',
      top: (p.view.score.layout.pageWidth / 2) - 200,
      left: (p.view.score.layout.pageHeight / 2) - 200,
      ...parameters
    });
    this.startPromise = p.startPromise;
    this.scoreInfo = this.view.score.scoreInfo;
    this.score = this.view.score;
  }
}

// ## SuiLayoutDialog
// The layout dialog has page layout and zoom logic.  It is not based on a selection but score-wide
// eslint-disable-next-line no-unused-vars
class SuiLayoutDialog extends SuiDialogBase {
  static get ctor() {
    return 'SuiLayoutDialog';
  }
  get ctor() {
    return SuiLayoutDialog.ctor;
  }

  // ### dialogElements
  // all dialogs have elements define the controls of the dialog.
  static get dialogElements() {
    SuiLayoutDialog._dialogElements = typeof(SuiLayoutDialog._dialogElements) !== 'undefined' ? SuiLayoutDialog._dialogElements :
      [{
        smoName: 'pageSize',
        parameterName: 'pageSize',
        defaultValue: SmoScore.pageSizes.letter,
        control: 'SuiDropdownComponent',
        label: 'Page Size',
        options: [
          {
            value: 'letter',
            label: 'Letter'
          }, {
            value: 'tabloid',
            label: 'Tabloid (11x17)'
          }, {
            value: 'A4',
            label: 'A4'
          }, {
            value: 'custom',
            label: 'Custom'
          }]
      }, {
        smoName: 'pageWidth',
        parameterName: 'pageWidth',
        defaultValue: SmoScore.defaults.layout.pageWidth,
        control: 'SuiRockerComponent',
        label: 'Page Width (px)'
      }, {
        smoName: 'pageHeight',
        parameterName: 'pageHeight',
        defaultValue: SmoScore.defaults.layout.pageHeight,
        control: 'SuiRockerComponent',
        label: 'Page Height (px)'
      }, {
        smoName: 'orientation',
        parameterName: 'orientation',
        defaultValue: SmoScore.orientations.portrait,
        control: 'SuiDropdownComponent',
        label: 'Orientation',
        dataType: 'int',
        options: [{
          value: SmoScore.orientations.portrait,
          label: 'Portrait'
        }, {
          value: SmoScore.orientations.landscape,
          label: 'Landscape'
        }]
      }, {
        smoName: 'engravingFont',
        parameterName: 'engravingFont',
        defaultValue: SmoScore.engravingFonts.Bravura,
        control: 'SuiDropdownComponent',
        label: 'Engraving Font',
        options: [{
          value: 'Bravura',
          label: 'Bravura'
        }, {
          value: 'Gonville',
          label: 'Gonville'
        }, {
          value: 'Petaluma',
          label: 'Petaluma'
        }, {
          value: 'Leland',
          label: 'Leland'
        }]
      }, {
        smoName: 'leftMargin',
        parameterName: 'leftMargin',
        defaultValue: SmoScore.defaults.layout.leftMargin,
        control: 'SuiRockerComponent',
        label: 'Left Margin (px)'
      }, {
        smoName: 'rightMargin',
        parameterName: 'rightMargin',
        defaultValue: SmoScore.defaults.layout.rightMargin,
        control: 'SuiRockerComponent',
        label: 'Right Margin (px)'
      }, {
        smoName: 'topMargin',
        parameterName: 'topMargin',
        defaultValue: SmoScore.defaults.layout.topMargin,
        control: 'SuiRockerComponent',
        label: 'Top Margin (px)'
      }, {
        smoName: 'interGap',
        parameterName: 'interGap',
        defaultValue: SmoScore.defaults.layout.interGap,
        control: 'SuiRockerComponent',
        label: 'Inter-System Margin'
      }, {
        smoName: 'intraGap',
        parameterName: 'intraGap',
        defaultValue: SmoScore.defaults.layout.intraGap,
        control: 'SuiRockerComponent',
        label: 'Intra-System Margin'
      }, {
        smoName: 'noteSpacing',
        parameterName: 'noteSpacing',
        defaultValue: SmoScore.defaults.layout.noteSpacing,
        control: 'SuiRockerComponent',
        type: 'percent',
        label: 'Note Spacing'
      }, {
        smoName: 'zoomScale',
        parameterName: 'zoomScale',
        defaultValue: SmoScore.defaults.layout.zoomScale,
        control: 'SuiRockerComponent',
        label: '% Zoom',
        type: 'percent'
      }, {
        smoName: 'svgScale',
        parameterName: 'svgScale',
        defaultValue: SmoScore.defaults.layout.svgScale,
        control: 'SuiRockerComponent',
        label: '% Note size',
        type: 'percent'
      }, {
        staticText: [
          { label: 'Score Layout' }
        ]
      }];
    return SuiLayoutDialog._dialogElements;
  }

  // ### backupOriginal
  // backup the original layout parameters for trial period
  backupOriginal() {
    this.backup = JSON.parse(JSON.stringify(this.modifier));
  }
  display() {
    $('body').addClass('showAttributeDialog');
    this.components.forEach((component) => {
      component.bind();
    });
    this.components.forEach((component) => {
      const val = this.modifier[component.parameterName];
      component.setValue(val);
    });
    this._bindComponentNames();
    this._setPageSizeDefault();
    this._bindElements();
    const engraving = this.view.score.fonts.find((ff) => ff.name === 'engraving');
    this.engravingFontCtrl.setValue(engraving.family);

    const cb = () => {};
    htmlHelpers.draggable({
      parent: $(this.dgDom.element).find('.attributeModal'),
      handle: $(this.dgDom.element).find('.icon-move'),
      animateDiv: '.draganime',
      cb,
      moveParent: true
    });
    const getKeys = () => {
      this.completeNotifier.unbindKeyboardForModal(this);
    };
    this.startPromise.then(getKeys);

    const box = svgHelpers.boxPoints(250, 250, 1, 1);
    SuiDialogBase.position(box, this.dgDom, this.view.tracker.scroller);
  }
  // ### _updateLayout
  // even if the layout is not changed, we re-render the entire score by resetting
  // the svg context.
  _updateLayout() {
    this.view.renderer.rerenderAll();
  }
  _handleCancel() {
    this.view.score.setLayout(this.backup);
    this._updateLayout();
    this.complete();
  }
  _bindElements() {
    const self = this;
    const dgDom = this.dgDom;
    this.bindKeyboard();
    $(dgDom.element).find('.ok-button').off('click').on('click', () => {
      // TODO:  allow user to select a zoom mode.
      self.view.score.layout.zoomMode = SmoScore.zoomModes.zoomScale;
      self._updateLayout();
      self.complete();
    });

    $(dgDom.element).find('.cancel-button').off('click').on('click', () => {
      self._handleCancel();
    });

    $(dgDom.element).find('.remove-button').remove();
  }
  _setPageSizeDefault() {
    let value = 'custom';
    const scoreDims = this.view.score.layout;
    SmoScore.pageSizes.forEach((sz) => {
      const dim = SmoScore.pageDimensions[sz];
      if (scoreDims.pageWidth === dim.width && scoreDims.pageHeight === dim.height) {
        value = sz;
      } else if (scoreDims.pageHeight === dim.width && scoreDims.pageWidth === dim.height) {
        value = sz;
      }
    });
    const orientation = scoreDims.pageWidth > scoreDims.pageHeight ?
      SmoScore.orientations.landscape : SmoScore.orientations.portrait;
    this.orientationCtrl.setValue(orientation);
    this.pageSizeCtrl.setValue(value);
    this._handlePageSizeChange();
  }
  // ### _handlePageSizeChange
  // see if the dimensions have changed.
  _handlePageSizeChange() {
    const sel = this.pageSizeCtrl.getValue();
    if (sel === 'custom') {
      $('.attributeModal').addClass('customPage');
    } else {
      $('.attributeModal').removeClass('customPage');
      const dim = SmoScore.pageDimensions[sel];
      this.pageHeightCtrl.setValue(dim.height);
      this.pageWidthCtrl.setValue(dim.width);
    }
  }

  // ### changed
  // One of the components has had a changed value.
  changed() {
    this._handlePageSizeChange();
    const layout = JSON.parse(JSON.stringify(this.view.score.layout));
    this.components.forEach((component) => {
      if (typeof(layout[component.smoName]) !== 'undefined') {
        layout[component.smoName] = component.getValue();
      }
    });
    if (this.engravingFontCtrl.changeFlag)  {
      this.view.setEngravingFontFamily(this.engravingFontCtrl.getValue());
    }
    this.view.setScoreLayout(layout);
  }

  // ### createAndDisplay
  // static method to create the object and then display it.
  static createAndDisplay(parameters) {
    const dg = new SuiLayoutDialog(parameters);
    dg.display();
  }
  constructor(parameters) {
    var p = parameters;
    super(SuiLayoutDialog.dialogElements, {
      id: 'dialog-layout',
      top: (p.view.score.layout.pageWidth / 2) - 200,
      left: (p.view.score.layout.pageHeight / 2) - 200,
      ...parameters
    });
    this.score = p.view.score;
    this.modifier = this.view.score.layout;
    this.startPromise = p.startPromise;
    this.backupOriginal();
  }
}
;// ## CheckboxDropdownComponent
// A checkbox that enables a dropdown component, for optional or dependent parameter
// eslint-disable-next-line no-unused-vars
class CheckboxDropdownComponent extends SuiComponentBase {
  // { dropdownElement: {...}, toggleElement: }
  constructor(dialog, parameter) {
    super(parameter);
    smoSerialize.filteredMerge(
      ['parameterName', 'smoName', 'defaultValue', 'options', 'control', 'label', 'dataType'], parameter, this);
    this.dialog = dialog;
    parameter.toggleElement.parentControl = this;
    parameter.dropdownElement.parentControl = this;
    this.toggleCtrl = new SuiToggleComposite(this.dialog, parameter.toggleElement);
    this.dropdownCtrl = new SuiDropdownComposite(this.dialog, parameter.dropdownElement);
  }
  get html() {
    const b = htmlHelpers.buildDom;
    const q = b('div').classes(this.makeClasses('multiControl smoControl checkboxDropdown'))
      .attr('id', this.parameterId);
    q.append(this.toggleCtrl.html);
    q.append(this.dropdownCtrl.html);
    return q;
  }
  get parameterId() {
    return this.dialog.id + '-' + this.parameterName;
  }
  bind() {
    this.toggleCtrl.bind();
    this.dropdownCtrl.bind();
  }
  changed() {
    if (this.toggleCtrl.getValue()) {
      $('#' + this.parameterId).addClass('checked');
    } else {
      $('#' + this.parameterId).removeClass('checked');
    }
    this.handleChanged();
  }
}

// ## TieMappingComponent
// Represent the pitches in 2 notes that can be individually tied together
// eslint-disable-next-line no-unused-vars
class TieMappingComponent extends SuiComponentBase {
  // { dropdownElement: {...}, toggleElement: }
  constructor(dialog, parameter) {
    let i = 0;
    super(parameter);
    this.dialog = dialog;
    this.startSelection = SmoSelection.noteFromSelector(
      this.dialog.view.score, this.dialog.modifier.startSelector);
    this.endSelection = SmoSelection.noteFromSelector(
      this.dialog.view.score, this.dialog.modifier.endSelector);
    const pitchCount = Math.max(this.startSelection.note.pitches.length, this.endSelection.note.pitches.length);

    smoSerialize.filteredMerge(
      ['parameterName', 'smoName', 'defaultValue', 'options', 'control', 'label', 'dataType'], parameter, this);
    this.controlRows = [];
    for (i = 0; i < pitchCount; ++i) {
      const smoName = 'Line-' + (i + 1);
      const defaultValue = -1;
      const leftControl = new SuiDropdownComposite(this.dialog, {
        smoName: smoName + '-left',
        parameterName: smoName + '-left',
        classes: 'leftControl',
        defaultValue,
        label: SuiDialogBase.getStaticText(SuiTieAttributesDialog.dialogElements, 'fromNote'),
        options: this._generateOptions(this.startSelection.note),
        parentControl: this
      });
      const rightControl = new SuiDropdownComposite(this.dialog, {
        smoName: smoName + '-right',
        parameterName: smoName + '-right',
        classes: 'rightControl',
        label: SuiDialogBase.getStaticText(SuiTieAttributesDialog.dialogElements, 'toNote'),
        defaultValue,
        options: this._generateOptions(this.endSelection.note),
        parentControl: this
      });
      this.controlRows.push({ leftControl, rightControl });
    }
  }
  bind() {
    this.controlRows.forEach((row) => {
      row.rightControl.bind();
      row.leftControl.bind();
    });
  }

  _generateOptions(note) {
    const options = [];
    let index = 0;
    let label = '';
    options.push({ value: -1, label: 'No Line' });
    note.pitches.forEach((pitch) => {
      const value = index;
      label = pitch.letter.toUpperCase();
      if (pitch.accidental !== 'n') {
        label += pitch.accidental;
      }
      label += pitch.octave;
      options.push({ value, label });
      index += 1;
    });
    return options;
  }
  getValue() {
    const lines = [];
    this.controlRows.forEach((row) => {
      const left = row.leftControl.getValue();
      const right = row.rightControl.getValue();
      if (left >= 0 && right >= 0) {
        lines.push({ from: left, to: right });
      }
    });
    return lines;
  }
  setValue(modifier) {
    let i = 0;
    for (i = 0; i < this.controlRows.length; ++i) {
      const row = this.controlRows[i];
      if (modifier.lines.length > i) {
        row.leftControl.setValue(modifier.lines[i].from);
        row.rightControl.setValue(modifier.lines[i].to);
      }
    }
  }
  changed() {
    this.handleChanged();
  }
  get html() {
    const b = htmlHelpers.buildDom;
    const q = b('div').classes(this.makeClasses('multiControl smoControl dropdownPair'))
      .attr('id', this.parameterId);
    this.controlRows.forEach((row) => {
      q.append(row.leftControl.html).append(row.rightControl.html);
    });
    return q;
  }
}
// eslint-disable-next-line no-unused-vars
class StaffAddRemoveComponent extends SuiComponentBase {
  get parameterId() {
    return this.dialog.id + '-' + this.parameterName;
  }
  constructor(dialog, parameter) {
    super(parameter);
    smoSerialize.filteredMerge(
      ['parameterName', 'smoName', 'defaultValue', 'options', 'control', 'label', 'dataType'], parameter, this);

    this.dialog = dialog;
    this.view = this.dialog.view;
    this.createdShell = false;
    this.staffRows = [];
    this.label = SuiDialogBase.getStaticText(SuiStaffGroupDialog.dialogElements, 'includeStaff');
  }
  setControlRows() {
    let i = this.modifier.startSelector.staff;
    this.staffRows = [];
    this.view.storeScore.staves.forEach((staff) => {
      const name = this.label + ' ' + (staff.staffId + 1);
      const id = 'show-' + i;
      // Toggle add of last row + 1
      if (staff.staffId === this.modifier.endSelector.staff + 1) {
        const rowElement = new SuiToggleComposite(this.dialog, {
          smoName: id,
          parameterName: id,
          defaultValue: false,
          classes: 'toggle-add-row',
          control: 'SuiToggleComponent',
          label: name
        });
        rowElement.parentControl = this;
        this.staffRows.push({
          showCtrl: rowElement
        });
      } else if (staff.staffId > this.modifier.startSelector.staff &&
        staff.staffId === this.modifier.endSelector.staff) {
        // toggle remove of ultimate row, other than first row
        const rowElement = new SuiToggleComposite(this.dialog, {
          smoName: id,
          parameterName: id,
          defaultValue: true,
          classes: 'toggle-remove-row',
          control: 'SuiToggleComponent',
          label: name
        });
        rowElement.parentControl = this;
        this.staffRows.push({
          showCtrl: rowElement
        });
      } else if ((staff.staffId <= this.modifier.endSelector.staff) &&
        (staff.staffId >= this.modifier.startSelector.staff)) {
        // toggle remove of ultimate row, other than first row
        const rowElement = new SuiToggleComponent(this.dialog, {
          smoName: id,
          parameterName: id,
          defaultValue: true,
          classes: 'toggle-disabled',
          control: 'SuiToggleComponent',
          label: name
        });
        rowElement.parentControl = this;
        this.staffRows.push({
          showCtrl: rowElement
        });
      }
      i += 1;
    });
  }
  get html() {
    const b = htmlHelpers.buildDom;
    // a little hacky.  The first time we create an empty html shell for the control
    // subsequent times, we fill the html with the row information
    if (!this.createdShell) {
      this.createdShell = true;
      const q = b('div').classes(this.makeClasses('multiControl smoControl staffContainer')).attr('id', this.parameterId);
      return q;
    } else {
      const q = b('div').classes(this.makeClasses('smoControl'));
      this.staffRows.forEach((row) => {
        q.append(row.showCtrl.html);
      });
      return q;
    }
  }
  getInputElement() {
    var pid = this.parameterId;
    return $('#' + pid);
  }
  getValue() {
    let nextStaff = this.modifier.startSelector.staff;
    const maxMeasure = this.modifier.endSelector.measure;
    this.modifier.endSelector = JSON.parse(JSON.stringify(this.modifier.startSelector));
    this.staffRows.forEach((staffRow) => {
      if (staffRow.showCtrl.getValue()) {
        this.modifier.endSelector = { staff: nextStaff, measure: maxMeasure };
        nextStaff += 1;
      }
    });
    return this.modifier;
  }
  setValue(staffGroup) {
    this.modifier = staffGroup; // would this be used?
    this.setControlRows();
  }
  changed() {
    this.getValue(); // update modifier
    this.handleChanged();
    this.setControlRows();
  }
  bind() {
    this.staffRows.forEach((row) => {
      row.showCtrl.bind();
    });
  }
}

// eslint-disable-next-line no-unused-vars
class StaffCheckComponent extends SuiComponentBase {
  constructor(dialog, parameter) {
    super(parameter);
    smoSerialize.filteredMerge(
      ['parameterName', 'smoName', 'defaultValue', 'options', 'control', 'label', 'dataType'], parameter, this);
    this.dialog = dialog;
    this.view = this.dialog.view;
    this.staffRows = [];
    this.view.storeScore.staves.forEach((staff) => {
      const name = 'View Staff ' + (staff.staffId + 1);
      const id = 'show-' + staff.staffId;
      const rowElement = new SuiToggleComponent(this.dialog, {
        smoName: id,
        parameterName: id,
        defaultValue: true,
        classes: 'hide-when-editing',
        control: 'SuiToggleComponent',
        label: name
      });
      this.staffRows.push({
        showCtrl: rowElement
      });
    });
  }
  get html() {
    const b = htmlHelpers.buildDom;
    const q = b('div').classes(this.makeClasses('multiControl smoControl staffContainer'));
    this.staffRows.forEach((row) => {
      q.append(row.showCtrl.html);
    });
    return q;
  }
  // Is this used for compound controls?
  _getInputElement() {
    var pid = this.parameterId;
    return $(this.dialog.dgDom.element).find('#' + pid).find('.staffContainer');
  }
  getValue() {
    const rv = [];
    let i = 0;
    for (i = 0; i < this.staffRows.length; ++i) {
      const show = this.staffRows[i].showCtrl.getValue();
      rv.push({ show });
    }
    return rv;
  }
  setValue(rows) {
    let i = 0;
    rows.forEach((row) => {
      this.staffRows[i].showCtrl.setValue(row.show);
      i += 1;
    });
  }
  changed() {
    this.handleChanged();
  }
  bind() {
    this.staffRows.forEach((row) => {
      row.showCtrl.bind();
    });
  }
}

// eslint-disable-next-line no-unused-vars
class TextCheckComponent extends SuiComponentBase {
  constructor(dialog, parameter) {
    super(parameter);
    smoSerialize.filteredMerge(
      ['parameterName', 'smoName', 'defaultValue', 'options', 'control', 'label', 'dataType'], parameter, this);
    this.dialog = dialog;
    this.view = this.dialog.view;
    const toggleName = this.smoName + 'Toggle';
    const textName = this.smoName + 'Text';
    const label = this.dialog.staticText[textName];
    const show = this.dialog.staticText.show;
    this.toggleCtrl = new SuiToggleComposite(this.dialog, {
      smoName: toggleName,
      parameterName: toggleName,
      defaultValue: false,
      control: 'SuiToggleComposite',
      label: show,
      parentControl: this
    });
    this.textCtrl = new SuiTextInputComposite(this.dialog, {
      smoName: textName,
      parameterName: textName,
      defaultValue: this.defaultValue,
      control: 'SuiTextInputComposite',
      label,
      parentControl: this
    });
  }
  get html() {
    const b = htmlHelpers.buildDom;
    const q = b('div').classes(this.makeClasses('multiControl smoControl textCheckContainer'))
      .attr('id', this.parameterId);
    q.append(this.textCtrl.html);
    q.append(this.toggleCtrl.html);
    return q;
  }
  getInputElement() {
    var pid = this.parameterId;
    return $('#' + pid);
  }
  getValue() {
    return {
      checked: this.toggleCtrl.getValue(),
      text: this.textCtrl.getValue()
    };
  }
  setValue(val) {
    this.toggleCtrl.setValue(val.checked);
    this.textCtrl.setValue(val.text);
  }
  changed() {
    this.handleChanged();
  }
  bind() {
    this.toggleCtrl.bind();
    this.textCtrl.bind();
  }
}
;// ## SuiStaffModifierDialog
// Edit the attributes of a staff modifier (connects notes in the same staff)
// eslint-disable-next-line no-unused-vars
class SuiStaffModifierDialog extends SuiDialogBase {
  constructor(elements, params) {
    super(elements, params);
    this.original = StaffModifierBase.deserialize(params.modifier);
    this.edited = false;
    this.view.groupUndo(true);
  }

  handleRemove() {
    this.view.removeStaffModifier(this.modifier);
  }

  changed() {
    this.edited = true;
    this.components.forEach((component) => {
      this.modifier[component.smoName] = component.getValue();
    });
    this.view.addOrUpdateStaffModifier(this.original, this.modifier);
    this.original = this.modifier;
  }

  // ### _bindElements
  // bing the generic controls in most dialogs.
  _bindElements() {
    var dgDom = this.dgDom;
    this.bindKeyboard();

    $(dgDom.element).find('.ok-button').off('click').on('click', () => {
      this.view.groupUndo(false);
      this.complete();
    });

    $(dgDom.element).find('.cancel-button').off('click').on('click', () => {
      this.view.groupUndo(false);
      if (this.edited) {
        this.view.undo();
      }
      this.complete();
    });
    $(dgDom.element).find('.remove-button').off('click').on('click', () => {
      this.view.groupUndo(false);
      this.handleRemove();
      this.complete();
    });
  }
}

// eslint-disable-next-line no-unused-vars
class SuiSlurAttributesDialog extends SuiStaffModifierDialog {
  get ctor() {
    return SuiSlurAttributesDialog.ctor;
  }
  static get ctor() {
    return 'SuiSlurAttributesDialog';
  }

  static get dialogElements() {
    SuiSlurAttributesDialog._dialogElements = SuiSlurAttributesDialog._dialogElements ? SuiSlurAttributesDialog._dialogElements :
      [{
        staticText: [
          { label: 'Slur Properties' }
        ]
      }, {
        parameterName: 'spacing',
        smoName: 'spacing',
        defaultValue: 2,
        control: 'SuiRockerComponent',
        label: 'Spacing'
      }, {
        smoName: 'thickness',
        parameterName: 'thickness',
        defaultValue: 2,
        control: 'SuiRockerComponent',
        label: 'Thickness'
      }, {
        smoName: 'xOffset',
        parameterName: 'xOffset',
        defaultValue: 0,
        control: 'SuiRockerComponent',
        label: 'X Offset'
      }, {
        smoName: 'yOffset',
        parameterName: 'yOffset',
        defaultValue: 10,
        control: 'SuiRockerComponent',
        label: 'Y Offset'
      }, {
        smoName: 'position',
        parameterName: 'position',
        defaultValue: SmoSlur.positions.HEAD,
        options: [{
          value: SmoSlur.positions.HEAD,
          label: 'Head'
        }, {
          value: SmoSlur.positions.TOP,
          label: 'Top'
        }],
        control: 'SuiDropdownComponent',
        label: 'Start Position'
      }, {
        smoName: 'position_end',
        parameterName: 'position_end',
        defaultValue: SmoSlur.positions.HEAD,
        options: [{
          value: SmoSlur.positions.HEAD,
          label: 'Head'
        }, {
          value: SmoSlur.positions.TOP,
          label: 'Top'
        }],
        control: 'SuiDropdownComponent',
        label: 'End Position'
      }, {
        smoName: 'invert',
        parameterName: 'invert',
        defaultValue: false,
        control: 'SuiToggleComponent',
        label: 'Invert'
      }, {
        parameterName: 'cp1x',
        smoName: 'cp1x',
        defaultValue: 0,
        control: 'SuiRockerComponent',
        label: 'Control Point 1 X'
      }, {
        parameterName: 'cp1y',
        smoName: 'cp1y',
        defaultValue: 40,
        control: 'SuiRockerComponent',
        label: 'Control Point 1 Y'
      }, {
        parameterName: 'cp2x',
        smoName: 'cp2x',
        defaultValue: 0,
        control: 'SuiRockerComponent',
        label: 'Control Point 2 X'
      }, {
        parameterName: 'cp2y',
        smoName: 'cp2y',
        defaultValue: 40,
        control: 'SuiRockerComponent',
        label: 'Control Point 2 Y'
      }];
    return SuiSlurAttributesDialog._dialogElements;
  }
  static createAndDisplay(parameters) {
    var dg = new SuiSlurAttributesDialog(parameters);
    dg.display();
    return dg;
  }
  constructor(parameters) {
    if (!parameters.modifier) {
      throw new Error('modifier attribute dialog must have modifier');
    }

    super(SuiSlurAttributesDialog.dialogElements, {
      id: 'dialog-' + parameters.modifier.attrs.id,
      top: parameters.modifier.renderedBox.y,
      left: parameters.modifier.renderedBox.x,
      label: 'Slur Properties',
      ...parameters
    });
    Vex.Merge(this, parameters);
    this.completeNotifier.unbindKeyboardForModal(this);
  }
  populateInitial() {
    this.components.forEach((comp) => {
      if (typeof(this.modifier[comp.smoName]) !== 'undefined') {
        comp.setValue(this.modifier[comp.smoName]);
      }
    });
  }
  display() {
    super.display();
    this.populateInitial();
  }
}

// eslint-disable-next-line no-unused-vars
class SuiTieAttributesDialog extends SuiStaffModifierDialog {
  get ctor() {
    return SuiTieAttributesDialog.ctor;
  }
  static get ctor() {
    return 'SuiTieAttributesDialog';
  }

  static get dialogElements() {
    SuiTieAttributesDialog._dialogElements = SuiTieAttributesDialog._dialogElements ? SuiTieAttributesDialog._dialogElements :
      [{
        staticText: [
          { label: 'Tie Properties' },
          { fromNote: 'From Note' },
          { toNote: 'To Note' }
        ]
      }, {
        parameterName: 'lines',
        smoName: 'lines',
        defaultValue: [],
        control: 'TieMappingComponent',
        label: 'Lines'
      }];
    return SuiTieAttributesDialog._dialogElements;
  }
  static createAndDisplay(parameters) {
    var dg = new SuiTieAttributesDialog(parameters);
    dg.display();
    return dg;
  }
  staticText(label) {
    return SuiDialogBase.getStaticText(SuiTieAttributesDialog.dialogElements, label);
  }
  constructor(parameters) {
    if (!parameters.modifier) {
      throw new Error('modifier attribute dialog must have modifier');
    }

    super(SuiTieAttributesDialog.dialogElements, {
      id: 'dialog-' + parameters.modifier.attrs.id,
      top: parameters.modifier.renderedBox.y,
      left: parameters.modifier.renderedBox.x,
      label: 'Slur Properties',
      ...parameters
    });
    Vex.Merge(this, parameters);
    this.completeNotifier.unbindKeyboardForModal(this);
  }
  populateInitial() {
    this.linesCtrl.setValue(this.modifier);
  }
  changed() {
    if (this.linesCtrl.changeFlag) {
      this.modifier.lines = JSON.parse(JSON.stringify(this.linesCtrl.getValue()));
      this.view.addOrUpdateStaffModifier(this.original, this.modifier);
      this.original = this.modifier;
      this.edited = true;
    }
  }
  display() {
    super.display();
    this._bindComponentNames();
    this.populateInitial();
  }
}

// ## SuiVoltaAttributeDialog
// aka first and second endings
// eslint-disable-next-line no-unused-vars
class SuiVoltaAttributeDialog extends SuiStaffModifierDialog {
  get ctor() {
    return SuiVoltaAttributeDialog.ctor;
  }
  static get ctor() {
    return 'SuiVoltaAttributeDialog';
  }
  static get label() {
    SuiVoltaAttributeDialog._label = SuiVoltaAttributeDialog._label ?
      SuiVoltaAttributeDialog._label : 'Volta Properties';
    return SuiVoltaAttributeDialog._label;
  }
  static set label(value) {
    SuiVoltaAttributeDialog._label = value;
  }

  static get dialogElements() {
    SuiVoltaAttributeDialog._dialogElements = SuiVoltaAttributeDialog._dialogElements ? SuiVoltaAttributeDialog._dialogElements :
      [{
        staticText: [
          { label: 'Volta Properties' }
        ]
      }, {
        parameterName: 'number',
        smoName: 'number',
        defaultValue: 1,
        control: 'SuiRockerComponent',
        label: 'number'
      }, {
        smoName: 'xOffsetStart',
        parameterName: 'xOffsetStart',
        defaultValue: 0,
        control: 'SuiRockerComponent',
        label: 'X1 Offset'
      }, {
        smoName: 'xOffsetEnd',
        parameterName: 'xOffsetEnd',
        defaultValue: 0,
        control: 'SuiRockerComponent',
        label: 'X2 Offset'
      }, {
        smoName: 'yOffset',
        parameterName: 'yOffset',
        defaultValue: 0,
        control: 'SuiRockerComponent',
        label: 'Y Offset'
      }];
    return SuiVoltaAttributeDialog._dialogElements;
  }
  static createAndDisplay(parameters) {
    const dg = new SuiVoltaAttributeDialog(parameters);
    dg.display();
    return dg;
  }
  handleRemove() {
    this.view.removeEnding(this.modifier);
  }
  changed() {
    this.components.forEach((component) => {
      this.modifier[component.smoName] = component.getValue();
    });
    this.view.updateEnding(this.modifier);
  }
  constructor(parameters) {
    if (!parameters.modifier) {
      throw new Error('modifier attribute dialog must have modifier');
    }

    super(SuiVoltaAttributeDialog.dialogElements, {
      id: 'dialog-' + parameters.modifier.attrs.id,
      top: parameters.modifier.renderedBox.y,
      left: parameters.modifier.renderedBox.x,
      ...parameters
    });
    Vex.Merge(this, parameters);
    this.selection = SmoSelection.measureSelection(this.view.score, this.modifier.startSelector.staff, this.modifier.startSelector.measure);

    SmoVolta.editableAttributes.forEach((attr) => {
      const comp = this.components.find((cc) => cc.smoName === attr);
      if (comp) {
        comp.defaultValue = this.modifier[attr];
      }
    });

    this.completeNotifier.unbindKeyboardForModal(this);
  }
}
// eslint-disable-next-line no-unused-vars
class SuiHairpinAttributesDialog extends SuiStaffModifierDialog {
  get ctor() {
    return SuiHairpinAttributesDialog.ctor;
  }
  static get ctor() {
    return 'SuiHairpinAttributesDialog';
  }

  static get label() {
    SuiHairpinAttributesDialog._label = SuiHairpinAttributesDialog._label ? SuiHairpinAttributesDialog._label
      : 'Hairpin Properties';
    return SuiHairpinAttributesDialog._label;
  }
  static set label(value) {
    SuiHairpinAttributesDialog._label = value;
  }
  static get dialogElements() {
    SuiHairpinAttributesDialog._dialogElements = SuiHairpinAttributesDialog._dialogElements ? SuiHairpinAttributesDialog._dialogElements :
      [{
        staticText: [
          { label: 'Hairpin Properties' }
        ]
      }, {
        parameterName: 'height',
        smoName: 'height',
        defaultValue: 10,
        control: 'SuiRockerComponent',
        label: 'Height'
      }, {
        smoName: 'yOffset',
        parameterName: 'y_shift',
        defaultValue: 0,
        control: 'SuiRockerComponent',
        label: 'Y Shift'
      }, {
        smoName: 'xOffsetRight',
        parameterName: 'right_shift_px',
        defaultValue: 0,
        control: 'SuiRockerComponent',
        label: 'Right Shift'
      }, {
        smoName: 'xOffsetLeft',
        parameterName: 'left_shift_px',
        defaultValue: 0,
        control: 'SuiRockerComponent',
        label: 'Left Shift'
      }];

    return SuiHairpinAttributesDialog._dialogElements;
  }
  static createAndDisplay(parameters) {
    var dg = new SuiHairpinAttributesDialog(parameters);
    dg.display();
    return dg;
  }
  constructor(parameters) {
    if (!parameters.modifier) {
      throw new Error('modifier attribute dialog must have modifier');
    }

    super(SuiHairpinAttributesDialog.dialogElements, {
      id: 'dialog-' + parameters.modifier.attrs.id,
      top: parameters.modifier.renderedBox.y,
      left: parameters.modifier.renderedBox.x,
      ...parameters
    });
    Vex.Merge(this, parameters);
    SmoStaffHairpin.editableAttributes.forEach((attr) => {
      var comp = this.components.find((cc) => cc.smoName === attr);
      if (comp) {
        comp.defaultValue = this.modifier[attr];
      }
    });
    this.completeNotifier.unbindKeyboardForModal(this);
  }
}
// ## SuiStaffGroupDialog
// A staff group is a grouping of staves that can be bracketed and justified
// eslint-disable-next-line no-unused-vars
class SuiStaffGroupDialog extends SuiDialogBase {
  static get ctor() {
    return 'SuiStaffGroupDialog';
  }
  get ctor() {
    return SuiStaffGroupDialog.ctor;
  }
  static get dialogElements() {
    SuiStaffGroupDialog._dialogElements = typeof(SuiStaffGroupDialog._dialogElements)
      !== 'undefined' ? SuiStaffGroupDialog._dialogElements :
      [{
        smoName: 'staffGroups',
        parameterName: 'staffGroups',
        defaultValue: {},
        control: 'StaffAddRemoveComponent',
        label: 'Staves in Group',
      }, {
        smoName: 'leftConnector',
        parameterName: 'leftConnector',
        defaultValue: SmoScore.pageSizes.letter,
        control: 'SuiDropdownComponent',
        label: 'Left Connector',
        options: [
          {
            value: SmoSystemGroup.connectorTypes.bracket,
            label: 'Bracket'
          }, {
            value: SmoSystemGroup.connectorTypes.brace,
            label: 'Brace'
          }, {
            value: SmoSystemGroup.connectorTypes.single,
            label: 'Single'
          }, {
            value: SmoSystemGroup.connectorTypes.double,
            label: 'Double'
          }]
      }, {
        staticText: [
          { label: 'Staff Group' },
          { includeStaff: 'Include Staff' }
        ]
      }];
    return SuiStaffGroupDialog._dialogElements;
  }
  static createAndDisplay(parameters) {
    const dg = new SuiStaffGroupDialog(parameters);
    dg.display();
  }
  display() {
    $('body').addClass('showAttributeDialog');
    this.components.forEach((component) => {
      component.bind();
    });
    const cb = () => {};
    htmlHelpers.draggable({
      parent: $(this.dgDom.element).find('.attributeModal'),
      handle: $(this.dgDom.element).find('.icon-move'),
      animateDiv: '.draganime',
      cb,
      moveParent: true
    });
    const getKeys = () => {
      this.completeNotifier.unbindKeyboardForModal(this);
    };
    this.startPromise.then(getKeys);
    this._bindElements();
    this.staffGroupsCtrl.setValue(this.modifier);
    this.leftConnectorCtrl.setValue(this.modifier.leftConnector);
    this._updateGroupMembership();
    const box = svgHelpers.boxPoints(250, 250, 1, 1);
    SuiDialogBase.position(box, this.dgDom, this.view.tracker.scroller);
  }
  _bindElements() {
    const dgDom = this.dgDom;

    this._bindComponentNames();
    $(dgDom.element).find('.ok-button').off('click').on('click', () => {
      this.complete();
    });

    $(dgDom.element).find('.cancel-button').off('click').on('click', () => {
      this.complete();
    });

    $(dgDom.element).find('.remove-button').remove();
    this.bindKeyboard();
  }
  _updateGroupMembership() {
    const updateEl = this.staffGroupsCtrl.getInputElement();
    this.staffGroupsCtrl.setControlRows();
    $(updateEl).html('');
    $(updateEl).append(this.staffGroupsCtrl.html.dom());
    this.staffGroupsCtrl.bind();
    $(this.staffGroupsCtrl.getInputElement()).find('input').prop('disabled', false);
    $(this.staffGroupsCtrl.getInputElement()).find('.toggle-disabled input').prop('disabled', true);
  }

  changed() {
    if (this.leftConnectorCtrl.changeFlag) {
      this.modifier.leftConnector = parseInt(this.leftConnectorCtrl.getValue(), 10);
    }
    if (this.staffGroupsCtrl.changeFlag) {
      // Recreate the new staff group with updated values
      this._updateGroupMembership();
    }
    this.view.addOrUpdateStaffGroup(this.modifier);
  }
  constructor(parameters) {
    var p = parameters;
    super(SuiStaffGroupDialog.dialogElements, {
      id: 'dialog-layout',
      top: (p.view.score.layout.pageWidth / 2) - 200,
      left: (p.view.score.layout.pageHeight / 2) - 200,
      ...parameters
    });
    this.startPromise = p.startPromise;
    const measureCount = this.view.score.staves[0].measures.length;
    const selection = this.view.tracker.selections[0];
    // Reset the view so we can see all the staves
    this.view.setView(this.view.defaultStaffMap);
    this.modifier = this.view.score.getSystemGroupForStaff(selection);
    if (!this.modifier) {
      this.modifier = new SmoSystemGroup({
        mapType: SmoSystemGroup.mapTypes.allMeasures,
        startSelector: { staff: selection.selector.staff, measure: 0 },
        endSelector: { staff: selection.selector.staff, measure: measureCount - 1 }
      });
    }
  }
}
;
// ## textComponents module
// This has the text editing dialog components.  Unlike components that are
// actual dialog controls, these actually run a text editing session of some kind.
//
// The heirarchy of text editing objects goes:
// dialog -> component -> session -> editor
//
// ### editor
//  handles low-level events and renders the preview using one
// of the text layout objects.
//
// ### session
// creates and destroys editors, e.g. for lyrics that have a Different
// editor instance for each note.
//
// ### component
// is defined in the dialog, and creates/destroys the session based on input from
// the dialog
//
// ### dialog
// manages the coponent session, as well as other components of the text like font etc.
//
// ## SuiTextInPlace
// Edit the text in an SVG element, in the same scale etc. as the text in the score SVG DOM.
// This component just manages the text editing component of hte renderer.
class SuiTextInPlace extends SuiComponentBase {
  constructor(dialog, parameter) {
    super(parameter);
    this.scroller = dialog.scroller;
    smoSerialize.filteredMerge(
        ['parameterName', 'smoName', 'defaultValue', 'control', 'label'], parameter, this);
    if (!this.defaultValue) {
        this.defaultValue = 0;
    }
    this.editMode=false;
    this.dialog = dialog;
    this.value='';
    var modifier = this.dialog.modifier;

    this.value = modifier;
    this.altLabel = SuiTextTransformDialog.getStaticText('editorLabel');
  }

  get html() {
    var b = htmlHelpers.buildDom;
    var id = this.parameterId;
    var r = b('div').classes(this.makeClasses('cbTextInPlace smoControl')).attr('id', this.parameterId).attr('data-param', this.parameterName)
      .append(b('button').attr('type', 'checkbox').classes('toggleTextEdit')
        .attr('id', id + '-input').append(
        b('span').classes('icon icon-pencil'))
        .append(
        b('label').attr('for', id + '-input').text(this.label)));
    return r;
  }
  get parameterId() {
    return this.dialog.id + '-' + this.parameterName;
  }
  endSession() {
    var self = this;
    $(this._getInputElement()).find('label').text(this.label);
    const button = document.getElementById(this.parameterId);
    $(button).find('span.icon').removeClass('icon-checkmark').addClass('icon-pencil');

    this.dialog.modifier.skipRender = false;

    var render = () => {
      this.dialog.view.renderer.setRefresh();
    }
    if (this.session) {
      this.session.textGroup.tryParseUnicode();
      this.value = this.session.textGroup;
      this.session.stopSession().then(render);
    }
    $('body').removeClass('text-edit');
    this.handleChanged();
  }
  get isRunning() {
    return this.session && this.session.isRunning;
  }
  getValue() {
    return this.value;
  }
  _getInputElement() {
    var pid = this.parameterId;
    return $(this.dialog.dgDom.element).find('#' + pid).find('button');
  }
  mouseMove(ev) {
    if (this.session && this.session.isRunning) {
      this.session.handleMouseEvent(ev);
    }
  }

  mouseClick(ev) {
    if (this.session && this.session.isRunning) {
      this.session.handleMouseEvent(ev);
    }
  }
  _renderInactiveBlocks() {
    const modifier = this.dialog.modifier;
    const context = this.dialog.view.renderer.context;
    context.save();
    context.setFillStyle('#ddd');
    modifier.textBlocks.forEach((block) => {
      const st = block.text;
      if (st.attrs.id !== this.dialog.activeScoreText.attrs.id) {
        const svgText = SuiInlineText.fromScoreText(st, context, this.scroller);
        if (st.logicalBox) {
          svgText.startX += st.logicalBox.x - st.x;
          svgText.startY += (st.y - st.logicalBox.y) - st.logicalBox.height / 2;
        }
        const sgrp = context.openGroup();
        sgrp.classList.add('inactive-text');
        sgrp.classList.add('suiInlineText');
        svgText.render();
        context.closeGroup();
      }
    });
    context.restore();
  }
  startEditSession() {
    var self=this;
    $(this._getInputElement()).find('label').text(this.altLabel);
    var modifier = this.dialog.modifier;
    modifier.skipRender = true;
    $(this.dialog.view.renderer.context.svg).find('#'+modifier.attrs.id).remove();
    this._renderInactiveBlocks();
    const ul = modifier.ul();

    // this.textElement=$(this.dialog.layout.svg).find('.'+modifier.attrs.id)[0];
    this.session = new SuiTextSession({ renderer : this.dialog.view.renderer,
      scroller: this.dialog.view.tracker.scroller,
      x: ul.x,
      y: ul.y,
      textGroup: modifier,
      scoreText: this.dialog.activeScoreText
    });
    $('body').addClass('text-edit');
    this.value = this.session.textGroup;
    var button = document.getElementById(this.parameterId);
    $(button).find('span.icon').removeClass('icon-pencil').addClass('icon-checkmark');
    this.session.startSession();
    // blur the button so key events don't get passed to it.
    $(this._getInputElement()).blur();
  }
  evKey(evdata) {
    if (this.session) {
      this.session.evKey(evdata);
    }
  }

  bind() {
    var self=this;
    this.fontInfo = JSON.parse(JSON.stringify(this.dialog.activeScoreText.fontInfo));
    this.value = this.dialog.modifier;
    $(this._getInputElement()).off('click').on('click',function(ev) {
      if (self.session && self.session.isRunning) {
        self.endSession();
      } else {
        self.startEditSession();
      }
    });
  }
}

// ## SuiNoteTextComponent
// Base class for text editor components that navigate to
// different notes.
class SuiNoteTextComponent extends SuiComponentBase {
  constructor(dialog, parameter) {
    super(parameter);

    this.selection = dialog.view.tracker.selections[0];
    this.selector = JSON.parse(JSON.stringify(this.selection.selector));
    this.dialog = dialog;
  }
  get parameterId() {
    return this.dialog.id + '-' + this.parameterName;
  }
  setView(eventSource, view) {
    this.eventSource = eventSource;
    this.view = view;
  }
  mouseMove(ev) {
    if (this.session && this.session.isRunning) {
      this.session.handleMouseEvent(ev);
    }
  }

  mouseClick(ev) {
    if (this.session && this.session.isRunning) {
      this.session.handleMouseEvent(ev);
    }
  }
  _getInputElement() {
    var pid = this.parameterId;
    return $(this.dialog.dgDom.element).find('#' + pid).find('button');
  }
  get running() {
    return this.session && this.session.isRunning;
  }
  evKey(evdata) {
    if (this.session) {
      return this.session.evKey(evdata);
    }
    return false;
  }
  setDialogLyric() {
    if (this.session && this.session.lyric) {
      this.dialog.setLyric(this.session.lyric);
    }
  }

  moveSelectionRight() {
    this.session.advanceSelection(false);
    this.setDialogLyric();
  }
  moveSelectionLeft() {
    this.session.advanceSelection(true);
    this.setDialogLyric();
  }
  removeText() {
    this.session.removeLyric();
  }

  _bind() {
    var self=this;
    $(this._getInputElement()).off('click').on('click',function(ev) {
      if (self.session && self.session.isRunning) {
        self.endSession();
      } else {
        self.startEditSession();
      }
    });
    var self=this;
    $('#' + this.parameterId+'-left').off('click').on('click',function() {
      self.moveSelectionLeft();
    });
    $('#' + this.parameterId+'-right').off('click').on('click',function() {
      self.moveSelectionRight();
    });
    $('#' + this.parameterId+'-remove').off('click').on('click',function() {
      self.removeText();
    });
  }
  getValue() {
    return this.value;
  }
}

// ## SuiLyricComponent
// manage a lyric session that moves from note to note and adds lyrics.
class SuiLyricComponent extends SuiNoteTextComponent {
  constructor(dialog, parameter) {
    super(dialog, parameter);
    smoSerialize.filteredMerge(
        ['parameterName', 'smoName', 'defaultValue', 'control', 'label'], parameter, this);
    if (!this.defaultValue) {
        this.defaultValue = 0;
    }
    this.session = null;
    this.altLabel = SuiLyricDialog.getStaticText('doneEditing');
    if (!this.verse) {
      this.verse = 0;
    }
    this.started = false;
  }

  get html() {
    var b = htmlHelpers.buildDom;
    var id = this.parameterId;
    var r = b('div').classes(this.makeClasses('cbLyricEdit smoControl')).attr('id', this.parameterId).attr('data-param', this.parameterName)
      .append(b('div').classes('toggleEdit')
        .append(b('button').classes('toggleTextEdit')
          .attr('id', id + '-toggleInput').append(
          b('span').classes('icon icon-pencil'))).append(
          b('label').attr('for', id + '-toggleInput').text(this.label)))
      .append(b('div').classes('show-when-editing')
        .append(b('span')
          .append(
            b('button').attr('id', id + '-left').classes('icon-arrow-left buttonComponent')))
        .append(b('span')
          .append(
            b('button').attr('id', id + '-right').classes('icon-arrow-right buttonComponent')))
        .append(b('span')
          .append(
            b('button').attr('id', id + '-remove').classes('icon-cross buttonComponent')))
      );
    return r;
  }

  endSession() {
    var self = this;
    this.started = false;
    console.log('ending text session');
    $(this._getInputElement()).find('label').text(this.label);
    const button = document.getElementById(this.parameterId);
    $(button).find('span.icon').removeClass('icon-checkmark').addClass('icon-pencil');
    if (this.session) {
      this.value = this.session.textGroup;
      this.session.stopSession();
    }
    $('body').removeClass('text-edit');
  }

  startEditSession() {
    $(this._getInputElement()).find('label').text(this.altLabel);
    console.log('starting text session');
    if (this.started) {
      return;
    }
    // this.textElement=$(this.dialog.layout.svg).find('.'+modifier.attrs.id)[0];
    this.session = new SuiLyricSession({
       renderer : this.dialog.view.renderer,
       selector: this.selector,
       scroller: this.dialog.view.tracker.scroller,
       verse: this.verse,
       score: this.dialog.view.score,
       view: this.view
       }
     );
    this.started = true;
    $('body').addClass('text-edit');
    var button = document.getElementById(this.parameterId);
    $(button).find('span.icon').removeClass('icon-pencil').addClass('icon-checkmark');
    this.session.startSession();
    this.setDialogLyric();
  }

  bind() {
    this._bind();
  }
}

// ## SuiChordComponent
// manage a chord editing session that moves from note to note and adds chord symbols.
class SuiChordComponent extends SuiNoteTextComponent {
  constructor(dialog,parameter) {
    super(dialog, parameter);
    smoSerialize.filteredMerge(
      ['parameterName', 'smoName', 'defaultValue', 'control', 'label'], parameter, this);
    if (!this.defaultValue) {
        this.defaultValue = 0;
    }
    this.session = null;
    this.dialog = dialog;

    this.selection = dialog.view.tracker.selections[0];
    this.selector = JSON.parse(JSON.stringify(this.selection.selector));
    this.altLabel = SuiLyricDialog.getStaticText('doneEditing');
    if (!this.verse) {
      this.verse = 0;
    }
  }

  get html() {
    const b = htmlHelpers.buildDom;
    const id = this.parameterId;
    const r = b('div').classes(this.makeClasses('cbChordEdit smoControl')).attr('id', this.parameterId).attr('data-param', this.parameterName)
      .append(b('div').classes('toggleEdit')
        .append(b('button').classes('toggleTextEdit')
          .attr('id', id + '-toggleInput').append(
          b('span').classes('icon icon-pencil'))).append(
          b('label').attr('for', id + '-toggleInput').text(this.label)))

      .append(b('div').classes('show-when-editing')
        .append(b('span')
          .append(
            b('button').attr('id', id + '-left').classes('icon-arrow-left buttonComponent')))
        .append(b('span')
          .append(
            b('button').attr('id', id + '-right').classes('icon-arrow-right buttonComponent')))
        .append(b('span')
          .append(
            b('button').attr('id', id + '-remove').classes('icon-cross buttonComponent')))
      );
    return r;
  }

  endSession() {
    var self = this;
    $(this._getInputElement()).find('label').text(this.label);
    const button = document.getElementById(this.parameterId);
    $(button).find('span.icon').removeClass('icon-checkmark').addClass('icon-pencil');

    var render = () => {
      this.dialog.view.renderer.setRefresh();
    }
    if (this.session) {
      this.value=this.session.textGroup;
      this.session.stopSession().then(render);
    }
    $('body').removeClass('text-edit');
  }
  startEditSession() {
    var self=this;
    $(this._getInputElement()).find('label').text(this.altLabel);
    var modifier = this.dialog.modifier;

    // this.textElement=$(this.dialog.layout.svg).find('.'+modifier.attrs.id)[0];
    this.session = new SuiChordSession({
       renderer : this.dialog.view.renderer,
       selector: this.selector,
       scroller: this.dialog.view.tracker.scroller,
       verse: 0,
       view: this.view,
       score: this.dialog.view.score
       }
     );
    $('body').addClass('text-edit');
    var button = document.getElementById(this.parameterId);
    $(button).find('span.icon').removeClass('icon-pencil').addClass('icon-checkmark');
    this.session.startSession();
  }
  bind() {
    this._bind();
  }
  setTextType(type) {
    this.session.textType = parseInt(type, 10);
  }
  getTextType(type) {
    return this.session.textType;
  }
}

// ## SuiDragText
// A component that lets you drag the text you are editing to anywhere on the score.
// The text is not really part of the dialog but the location of the text appears
// in other dialog fields.
class SuiDragText extends SuiComponentBase {
  constructor(dialog,parameter) {
    super(parameter);
    smoSerialize.filteredMerge(
        ['parameterName', 'smoName', 'defaultValue', 'control', 'label'], parameter, this);
    if (!this.defaultValue) {
        this.defaultValue = 0;
    }
    this.dragging = false;
    this.running = false;

    this.dialog = dialog;
    this.altLabel = SuiTextTransformDialog.getStaticText('draggerLabel');
    this.value='';
  }

  get html() {
    var b = htmlHelpers.buildDom;
    var id = this.parameterId;
    var r = b('div').classes(this.makeClasses('cbDragTextDialog smoControl')).attr('id', this.parameterId).attr('data-param', this.parameterName)
      .append(b('button').attr('type', 'checkbox').classes('toggleTextEdit')
        .attr('id', id + '-input').append(
        b('span').classes('icon icon-move'))
        .append(
        b('label').attr('for', id + '-input').text(this.label)));
    return r;
  }
  get parameterId() {
    return this.dialog.id + '-' + this.parameterName;
  }

  getValue() {
    return this.dialog.modifier;
  }
  _getInputElement() {
    var pid = this.parameterId;
    return $(this.dialog.dgDom.element).find('#' + pid).find('button');
  }
  stopEditSession() {
    $('body').removeClass('text-move');
    $(this._getInputElement()).find('span.icon').removeClass('icon-checkmark').addClass('icon-move');
    if (this.session && this.session.dragging) {
      this.session.dragging = false;
    }
    this.running = false;
  }
  startEditSession() {
    $('body').addClass('text-move');
    this.session = new SuiDragSession({
      textGroup: this.dialog.modifier,
      context: this.dialog.view.renderer.context,
      scroller: this.dialog.view.tracker.scroller
    });
    $(this._getInputElement()).find('label').text(this.altLabel);
    $(this._getInputElement()).find('span.icon').removeClass('icon-enlarge').addClass('icon-checkmark');
    this.running = true;
  }
  mouseMove(e) {
    if (this.session && this.session.dragging) {
      this.session.mouseMove(e);
    }
  }
  mouseDown(e) {
    if (this.session && !this.session.dragging) {
      this.session.startDrag(e);
      this.dragging = true;
    }
  }
  mouseUp(e) {
    if (this.session && this.session.dragging) {
      this.session.endDrag(e);
      this.dragging = false;
      this.handleChanged();
    }
  }

  bind() {
    var self=this;
    $(this._getInputElement()).off('click').on('click',function(ev) {
      if (self.running) {
        self.stopEditSession();
      } else {
        self.startEditSession();
      }
    });
  }
}
;// eslint-disable-next-line no-unused-vars
class SuiLyricDialog extends SuiDialogBase {
  static get ctor() {
    return 'SuiLyricDialog';
  }
  get ctor() {
    return SuiLyricDialog.ctor;
  }
  static get idleLyricTime() {
    return 5000;
  }
  static createAndDisplay(parameters) {
    const dg = new SuiLyricDialog(parameters);
    dg.display();
    return dg;
  }
  static get dialogElements() {
    SuiLyricDialog._dialogElements = SuiLyricDialog._dialogElements ? SuiLyricDialog._dialogElements :
      [{
        smoName: 'verse',
        parameterName: 'verse',
        defaultValue: 0,
        control: 'SuiDropdownComponent',
        label: 'Verse',
        classes: 'hide-when-editing',
        startRow: true,
        options: [{
          value: 0,
          label: '1'
        }, {
          value: 1,
          label: '2'
        }, {
          value: 2,
          label: '3'
        }, {
          value: 3,
          label: '4'
        }
        ] }, {
        smoName: 'translateY',
        parameterName: 'translateY',
        classes: 'hide-when-editing',
        defaultValue: 0,
        control: 'SuiRockerComponent',
        label: 'Y Adjustment (Px)',
        type: 'int'
      }, {
        smoName: 'font',
        parameterName: 'font',
        classes: 'hide-when-editing',
        defaultValue: 0,
        control: 'SuiFontComponent',
        label: 'Font'
      }, {
        smoName: 'lyricEditor',
        parameterName: 'text',
        defaultValue: 0,
        classes: 'show-always',
        control: 'SuiLyricComponent',
        label: 'Edit Lyrics',
        options: []
      }, {
        staticText: [
          { doneEditing: 'Done Editing Lyrics' },
          { undo: 'Undo Lyrics' },
          { label: 'Lyric Editor' }
        ]
      }];

    return SuiLyricDialog._dialogElements;
  }

  // ### getStaticText
  // given 'foo' return dialogElements.staticText value that has key of 'foo'
  static getStaticText(label) {
    return SuiLyricDialog.dialogElements.find((x) => x.staticText).staticText.find((x) => x[label])[label];
  }

  constructor(parameters) {
    parameters.ctor = typeof(parameters.ctor) !== 'undefined' ? parameters.ctor : 'SuiLyricDialog';
    const p = parameters;
    const _class = eval(p.ctor);
    const dialogElements = _class.dialogElements;

    super(dialogElements, {
      id: 'dialog-lyrics',
      top: (p.view.score.layout.pageWidth / 2) - 200,
      left: (p.view.score.layout.pageHeight / 2) - 200,
      ...p
    });
    this.originalRefreshTimer = SmoConfig.idleRedrawTime;
    SmoConfig.idleRedrawTime = SuiLyricDialog.idleLyricTime;

    // If we are editing existing lyrics, make sure it is the same type of session.
    // Note: the actual lyric (modifier) is picked later from the selection. We just
    // need to keep track of which type of thing we are editing.
    if (parameters.modifier) {
      this.parser = parameters.modifier.parser;
    } else {
      this.parser = parameters.parser; // lyrics or chord changes
    }
  }
  display() {
    $('body').addClass('showAttributeDialog');
    $('body').addClass('textEditor');
    this.components.forEach((component) => {
      component.bind();
    });

    this._bindComponentNames();

    // this.editor = this.components.find((c) => c.smoName === 'textEditor');
    this.verse = this.components.find((c) => c.smoName === 'verse');
    this._bindElements();

    // make sure keyboard is unbound or we get dupicate key events.
    this.completeNotifier.unbindKeyboardForModal(this);

    $(this.dgDom.element).find('.smoControl').each((ix, ctrl) => {
      if (!$(ctrl).hasClass('cbLyricEdit')) {
        $(ctrl).addClass('fold-textedit');
      }
    });
    this.position(this.view.tracker.selections[0].note.renderedBox);
    const cb = () => {};
    htmlHelpers.draggable({
      parent: $(this.dgDom.element).find('.attributeModal'),
      handle: $(this.dgDom.element).find('.jsDbMove'),
      animateDiv: '.draganime',
      cb,
      moveParent: true
    });
    this.mouseMoveHandler = this.eventSource.bindMouseMoveHandler(this, 'mouseMove');
    this.mouseClickHandler = this.eventSource.bindMouseClickHandler(this, 'mouseClick');

    if (this.lyricEditorCtrl && this.lyricEditorCtrl.session && this.lyricEditorCtrl.session.lyric) {
      const lyric = this.lyricEditorCtrl.session.lyric;
      this.fontCtrl.setValue({
        family: lyric.fontInfo.family,
        size: lyric.fontInfo.size,
      });
    }
    this.bindKeyboard();
  }
  setLyric(lyric) {
    this.lyric = lyric;
    this.translateYCtrl.setValue(lyric.translateY);
  }
  _focusSelection() {
    if (this.lyricEditorCtrl.editor.selection &&
      this.lyricEditorCtrl.editor.selection.note &&
      this.lyricEditorCtrl.editor.selection.note.renderedBox) {
      this.view.scroller.scrollVisibleBox(this.lyricEditorCtrl.editor.selection.note.renderedBox);
    }
  }
  changed() {
    this.lyricEditorCtrl.verse = parseInt(this.verse.getValue(), 10);

    // TODO: make these undoable
    if (this.fontCtrl.changeFlag) {
      const fontInfo = this.fontCtrl.getValue();
      this.view.setLyricFont({ 'family': fontInfo.family, size: fontInfo.size });
    }
    if (this.translateYCtrl && this.lyric) {
      this.lyric.translateY = this.translateYCtrl.getValue();
    }
  }
  _bindElements() {
    const dgDom = this.dgDom;

    $(dgDom.element).find('.ok-button').off('click').on('click', () => {
      this._complete();
    });
    $(dgDom.element).find('.cancel-button').off('click').on('click', () => {
      this._complete();
    });
    $(dgDom.element).find('.remove-button').remove();
    this.lyricEditorCtrl.eventSource = this.eventSource;
    this.lyricEditorCtrl.setView(this.eventSource, this.view);
    this.lyricEditorCtrl.startEditSession();
  }
  // ### handleKeydown
  // allow a dialog to be dismissed by esc.
  evKey(evdata) {
    if (evdata.key === 'Escape') {
      $(this.dgDom.element).find('.cancel-button').click();
      evdata.preventDefault();
    } else {
      if (!this.lyricEditorCtrl.running) {
        return;
      }
      const edited = this.lyricEditorCtrl.evKey(evdata);
      if (edited) {
        evdata.stopPropagation();
      }
    }
  }

  _complete() {
    if (this.lyricEditorCtrl.running) {
      this.lyricEditorCtrl.endSession();
    }
    this.eventSource.unbindMouseMoveHandler(this.mouseMoveHandler);
    this.eventSource.unbindMouseClickHandler(this.mouseClickHandler);
    $('body').removeClass('showAttributeDialog');
    $('body').removeClass('textEditor');
    SmoConfig.idleRedrawTime = this.originalRefreshTimer;
    this.complete();
  }

  mouseMove(ev) {
    if (this.lyricEditorCtrl && this.lyricEditorCtrl.running) {
      this.lyricEditorCtrl.mouseMove(ev);
    }
  }

  mouseClick(ev) {
    if (this.lyricEditorCtrl && this.lyricEditorCtrl.running) {
      this.lyricEditorCtrl.mouseClick(ev);
      ev.stopPropagation();
    }
  }
}
// eslint-disable-next-line no-unused-vars
class SuiChordChangeDialog  extends SuiDialogBase {
  static get ctor() {
    return 'SuiChordChangeDialog';
  }
  get ctor() {
    return SuiChordChangeDialog.ctor;
  }
  static createAndDisplay(parameters) {
    var dg = new SuiChordChangeDialog(parameters);
    dg.display();
    return dg;
  }
  constructor(parameters) {
    parameters.ctor = 'SuiChordChangeDialog';
    const p = parameters;
    const _class = eval(p.ctor);
    const dialogElements = _class.dialogElements;

    super(dialogElements, {
      id: 'dialog-chords',
      top: (p.view.score.layout.pageWidth / 2) - 200,
      left: (p.view.score.layout.pageHeight / 2) - 200,
      ...p
    });
  }
  static get dialogElements() {
    SuiChordChangeDialog._dialogElements = SuiChordChangeDialog._dialogElements ? SuiChordChangeDialog._dialogElements :
      [{
        smoName: 'verse',
        parameterName: 'verse',
        defaultValue: 0,
        control: 'SuiDropdownComponent',
        label: 'Ordinality',
        classes: 'hide-when-editing',
        startRow: true,
        options: [{
          value: 0,
          label: '1'
        }, {
          value: 1,
          label: '2'
        }, {
          value: 2,
          label: '3'
        }]
      }, {
        smoName: 'translateY',
        parameterName: 'translateY',
        defaultValue: 0,
        classes: 'hide-when-editing',
        control: 'SuiRockerComponent',
        label: 'Y Adjustment (Px)',
        type: 'int'
      }, {
        smoName: 'chordEditor',
        parameterName: 'text',
        defaultValue: 0,
        classes: 'show-always',
        control: 'SuiChordComponent',
        label: 'Edit Text',
        options: []
      }, {
        smoName: 'chordSymbol',
        parameterName: 'chordSymbol',
        defaultValue: '',
        classes: 'show-when-editing',
        control: 'SuiDropdownComponent',
        label: 'Chord Symbol',
        startRow: true,
        options: [{
          value: 'csymDiminished',
          label: 'Dim'
        }, {
          value: 'csymHalfDiminished',
          label: 'Half dim'
        }, {
          value: 'csymDiagonalArrangementSlash',
          label: 'Slash'
        }, {
          value: 'csymMajorSeventh',
          label: 'Maj7'
        }]
      }, {
        smoName: 'textPosition',
        parameterName: 'textPosition',
        defaultValue: SuiInlineText.textTypes.normal,
        classes: 'show-when-editing',
        control: 'SuiDropdownComponent',
        label: 'Text Position',
        startRow: true,
        options: [{
          value: SuiInlineText.textTypes.superScript,
          label: 'Superscript'
        }, {
          value: SuiInlineText.textTypes.subScript,
          label: 'Subscript'
        }, {
          value: SuiInlineText.textTypes.normal,
          label: 'Normal'
        }]
      }, {
        smoName: 'font',
        parameterName: 'font',
        classes: 'hide-when-editing',
        defaultValue: 0,
        control: 'SuiFontComponent',
        label: 'Font'
      }, {
        smoName: 'adjustWidth',
        parameterName: 'adjustNoteWidth',
        defaultValue: true,
        classes: 'hide-when-editing',
        control: 'SuiToggleComponent',
        label: 'Adjust Note Width',
        options: []
      }, {
        staticText: [
          { label: 'Edit Chord Symbol' },
          { undo: 'Undo Chord Symbols' },
          { doneEditing: 'Done Editing Chord Symbols' }
        ]
      }];

    return SuiChordChangeDialog._dialogElements;
  }
  changed() {
    let val = '';
    if (this.chordSymbolCtrl.changeFlag && this.chordEditorCtrl.running)   {
      val = '@' + this.chordSymbolCtrl.getValue() + '@';
      this.chordEditorCtrl.evKey({
        key: val
      });
      // Move focus outside the element so it doesn't intercept keys
      this.chordSymbolCtrl.unselect();
    }
    if (this.textPositionCtrl.changeFlag && this.chordEditorCtrl.running) {
      this.chordEditorCtrl.setTextType(this.textPositionCtrl.getValue());
      $(this.textPositionCtrl._getInputElement())[0].selectedIndex = -1;
      $(this.textPositionCtrl._getInputElement()).blur();
    }
    if (this.fontCtrl.changeFlag) {
      const fontInfo = this.fontCtrl.getValue();
      this.view.score.setChordFont(
        { 'family': fontInfo.family, size: fontInfo.size });
    }
    if (this.adjustWidthCtrl.changeFlag) {
      this.view.score.setChordAdjustWidth(this.adjustWidthCtrl.getValue());
    }
  }
  setLyric(lyric) {
    this.lyric = lyric;
    this.translateYCtrl.setValue(lyric.translateY);
  }
  display() {
    $('body').addClass('showAttributeDialog');
    $('body').addClass('textEditor');
    this.components.forEach((component) => {
      component.bind();
    });

    this._bindComponentNames();

    // this.editor = this.components.find((c) => c.smoName === 'textEditor');
    this.verse = this.components.find((c) => c.smoName === 'verse');
    this._bindElements();

    // make sure keyboard is unbound or we get dupicate key events.
    this.completeNotifier.unbindKeyboardForModal(this);

    $(this.dgDom.element).find('.smoControl').each((ix, ctrl) => {
      if (!$(ctrl).hasClass('cbLyricEdit')) {
        $(ctrl).addClass('fold-textedit');
      }
    });

    this.position(this.view.tracker.selections[0].note.renderedBox);

    const cb = () => {};
    htmlHelpers.draggable({
      parent: $(this.dgDom.element).find('.attributeModal'),
      handle: $(this.dgDom.element).find('.jsDbMove'),
      animateDiv: '.draganime',
      cb,
      moveParent: true
    });
    this.mouseMoveHandler = this.eventSource.bindMouseMoveHandler(this, 'mouseMove');
    this.mouseClickHandler = this.eventSource.bindMouseClickHandler(this, 'mouseClick');
    if (this.chordEditorCtrl && this.chordEditorCtrl.session && this.chordEditorCtrl.session.lyric) {
      const lyric = this.chordEditorCtrl.session.lyric;
      this.adjustWidthCtrl.setValue(lyric.adjustNoteWidth);
      this.fontCtrl.setValue({
        family: lyric.fontInfo.family,
        size: lyric.fontInfo.size
      });
    }
    this.bindKeyboard();
  }

  _bindElements() {
    const dgDom = this.dgDom;

    $(dgDom.element).find('.ok-button').off('click').on('click', () => {
      this._complete();
    });
    $(dgDom.element).find('.cancel-button').off('click').on('click', () => {
      this._complete();
    });
    $(dgDom.element).find('.remove-button').remove();
    this.chordEditorCtrl.setView(this.eventSource, this.view);
    this.chordEditorCtrl.startEditSession();
  }

  // ### handleKeydown
  // allow a dialog to be dismissed by esc.
  evKey(evdata) {
    if (evdata.key === 'Escape') {
      $(this.dgDom.element).find('.cancel-button').click();
      evdata.preventDefault();
    } else {
      if (!this.chordEditorCtrl.running) {
        return;
      }
      const edited = this.chordEditorCtrl.evKey(evdata);
      if (edited) {
        evdata.stopPropagation();
      }
    }
  }

  _complete() {
    if (this.chordEditorCtrl.running) {
      this.chordEditorCtrl.endSession();
    }
    this.view.renderer.setDirty();
    this.eventSource.unbindMouseMoveHandler(this.mouseMoveHandler);
    this.eventSource.unbindMouseClickHandler(this.mouseClickHandler);
    $('body').removeClass('showAttributeDialog');
    $('body').removeClass('textEditor');
    this.complete();
  }

  mouseMove(ev) {
    if (this.chordEditorCtrl && this.chordEditorCtrl.running) {
      this.chordEditorCtrl.mouseMove(ev);
    }
  }

  mouseClick(ev) {
    if (this.chordEditorCtrl && this.chordEditorCtrl.running) {
      this.chordEditorCtrl.mouseClick(ev);
      ev.stopPropagation();
    }
  }
}
// eslint-disable-next-line no-unused-vars
class SuiTextTransformDialog  extends SuiDialogBase {
  static createAndDisplay(parameters) {
    const dg = new SuiTextTransformDialog(parameters);
    dg.display();
    return dg;
  }

  static get ctor() {
    return 'SuiTextTransformDialog';
  }
  get ctor() {
    return SuiTextTransformDialog.ctor;
  }
  static get dialogElements() {
    SuiTextTransformDialog._dialogElements = SuiTextTransformDialog._dialogElements ? SuiTextTransformDialog._dialogElements :
      [{
        smoName: 'textEditor',
        parameterName: 'text',
        defaultValue: 0,
        control: 'SuiTextInPlace',
        classes: 'show-always hide-when-moving',
        label: 'Edit Text',
        options: []
      }, {
        smoName: 'insertCode',
        parameterName: 'insertCode',
        defaultValue: false,
        classes: 'show-when-editing hide-when-moving',
        control: 'SuiDropdownComponent',
        label: 'Insert Special',
        options: [
          { value: '@@@', label: 'Pages' },
          { value: '###', label: 'Page Number' }
        ] }, {
        smoName: 'textDragger',
        parameterName: 'textLocation',
        classes: 'hide-when-editing show-when-moving',
        defaultValue: 0,
        control: 'SuiDragText',
        label: 'Move Text',
        options: []
      }, {
        smoName: 'x',
        parameterName: 'x',
        defaultValue: 0,
        classes: 'hide-when-editing hide-when-moving',
        control: 'SuiRockerComponent',
        label: 'X Position (Px)',
        type: 'int'
      }, {
        smoName: 'y',
        parameterName: 'y',
        defaultValue: 0,
        classes: 'hide-when-editing hide-when-moving',
        control: 'SuiRockerComponent',
        label: 'Y Position (Px)',
        type: 'int'
      }, {
        smoName: 'font',
        parameterName: 'font',
        classes: 'hide-when-editing hide-when-moving',
        defaultValue: SmoScoreText.fontFamilies.times,
        control: 'SuiFontComponent',
        label: 'Font Information'
      },
      {
        smoName: 'textBlock',
        parameterName: 'textBlock',
        classes: 'hide-when-editing hide-when-moving',
        defaultValue: '',
        control: 'SuiTextBlockComponent',
        label: 'Text Block Properties'
      },
      { // {every:'every',even:'even',odd:'odd',once:'once'}
        smoName: 'pagination',
        parameterName: 'pagination',
        defaultValue: SmoScoreText.paginations.every,
        classes: 'hide-when-editing hide-when-moving',
        control: 'SuiDropdownComponent',
        label: 'Page Behavior',
        startRow: true,
        options: [{ value: SmoTextGroup.paginations.ONCE, label: 'Once' },
          { value: SmoTextGroup.paginations.EVERY, label: 'Every' },
          { value: SmoTextGroup.paginations.EVEN, label: 'Even' },
          { value: SmoTextGroup.paginations.ODD, label: 'Odd' },
          { value: SmoTextGroup.paginations.SUBSEQUENT, label: 'Subsequent' }
        ]
      }, {
        smoName: 'attachToSelector',
        parameterName: 'attachToSelector',
        defaultValue: false,
        parentControl: this,
        classes: 'hide-when-editing hide-when-moving',
        control: 'SuiToggleComponent',
        label: 'Attach to Selection'
      }, {
        staticText: [
          { label: 'Text Properties' },
          { editorLabel: 'Done Editing Text' },
          { draggerLabel: 'Done Dragging Text' }
        ]
      }];
    return SuiTextTransformDialog._dialogElements;
  }
  static getStaticText(label) {
    return SuiTextTransformDialog.dialogElements.find((x) => x.staticText).staticText.find((x) => x[label])[label];
  }

  display() {
    this.textElement = $(this.view.renderer.context.svg).find('.' + this.modifier.attrs.id)[0];

    $('body').addClass('showAttributeDialog');
    $('body').addClass('textEditor');
    this._bindComponentNames();

    this.components.forEach((component) => {
      component.bind();
    });
    this.textBlockCtrl.setValue({
      activeScoreText: this.activeScoreText,
      modifier: this.modifier
    });

    const fontFamily = this.activeScoreText.fontInfo.family;
    const fontSize = this.activeScoreText.fontInfo.size;
    this.fontCtrl.setValue({
      family: fontFamily,
      size: fontSize,
      style: this.activeScoreText.fontInfo.style,
      weight: this.activeScoreText.fontInfo.weight
    });

    this.attachToSelectorCtrl.setValue(this.modifier.attachToSelector);

    this.paginationsComponent = this.components.find((c) => c.smoName === 'pagination');
    this.paginationsComponent.setValue(this.modifier.pagination);

    this._bindElements();
    if (!this.modifier.renderedBox) {
      this.view.renderer.renderTextGroup(this.modifier);
    }
    this.position(this.modifier.renderedBox);
    const ul = this.modifier.ul();
    this.xCtrl.setValue(ul.x);
    this.yCtrl.setValue(ul.y);

    const cb = () => {};
    htmlHelpers.draggable({
      parent: $(this.dgDom.element).find('.attributeModal'),
      handle: $(this.dgDom.element).find('span.jsDbMove'),
      animateDiv: '.draganime',
      cb,
      moveParent: true
    });

    // If this control has not been edited this session, assume they want to
    // edit the text and just right into that.
    if (!this.modifier.edited) {
      this.modifier.edited = true;
      layoutDebug.addDialogDebug('text transform db: startEditSession');
      this.textEditorCtrl.startEditSession();
    }
    this.mouseMoveHandler = this.eventSource.bindMouseMoveHandler(this, 'mouseMove');
    this.mouseUpHandler = this.eventSource.bindMouseUpHandler(this, 'mouseUp');
    this.mouseDownHandler = this.eventSource.bindMouseDownHandler(this, 'mouseDown');
    this.mouseClickHandler = this.eventSource.bindMouseClickHandler(this, 'mouseClick');
  }
  _resetAttachToSelector() {
    this.modifier.attachToSelector = false;
    this.modifier.selector = SmoTextGroup.defaults.selector;
    this.modifier.musicXOffset = SmoTextGroup.defaults.musicXOffset;
    this.modifier.musicYOffset = SmoTextGroup.defaults.musicYOffset;
  }
  _activateAttachToSelector() {
    this.modifier.attachToSelector = true;
    this.modifier.selector = JSON.parse(JSON.stringify(this.view.tracker.selections[0].selector));
    this.modifier.musicXOffset = this.modifier.logicalBox.x - this.view.tracker.selections[0].measure.logicalBox.x;
    this.modifier.musicYOffset = this.modifier.logicalBox.y - this.view.tracker.selections[0].measure.logicalBox.y;
  }

  changed() {
    this.edited = true;
    if (this.insertCodeCtrl.changeFlag && this.textEditorCtrl.session) {
      const val = this.insertCodeCtrl.getValue().split('');
      val.forEach((key) => {
        this.evKey({ key });
      });
      this.insertCodeCtrl.unselect();
    }

    if (this.textBlockCtrl.changeFlag) {
      const nval = this.textBlockCtrl.getValue();
      this.activeScoreText = nval.activeScoreText;
      this.textEditorCtrl.activeScoreText = this.activeScoreText;
    }

    if (this.attachToSelectorCtrl.changeFlag) {
      const toSet = this.attachToSelectorCtrl.getValue();
      if (toSet) {
        this._activateAttachToSelector();
        this.paginationsComponent.setValue(SmoTextGroup.paginations.ONCE);
        this.modifier.pagination = SmoTextGroup.paginations.ONCE;
      } else {
        this._resetAttachToSelector();
      }
    }

    const pos = this.modifier.ul();

    // position can change from drag or by dialog - only update from
    // dialog entries if that changed.
    if (this.xCtrl.changeFlag) {
      this.modifier.offsetX(this.xCtrl.getValue() - pos.x);
    }
    if (this.yCtrl.changeFlag) {
      this.modifier.offsetY(this.yCtrl.getValue() - pos.y);
    }
    if (this.textDraggerCtrl.changeFlag) {
      this.xCtrl.setValue(pos.x);
      this.yCtrl.setValue(pos.y);
    }

    if (this.paginationsComponent.changeFlag) {
      this.modifier.pagination = parseInt(this.paginationsComponent.getValue(), 10);
      // Pagination and attach to measure don't mix.
      this._resetAttachToSelector();
      this.attachToSelectorCtrl.setValue(false);
    }

    if (this.fontCtrl.changeFlag) {
      const fontInfo = this.fontCtrl.getValue();
      this.activeScoreText.fontInfo.family = fontInfo.family;
      // transitioning away from non-point-based font size units
      this.activeScoreText.fontInfo.size = fontInfo.size;
      this.activeScoreText.fontInfo.weight = fontInfo.weight;
      this.activeScoreText.fontInfo.style = fontInfo.style;
    }
    // Use layout context because render may have reset svg.
    this.view.updateTextGroup(this.previousModifier, this.modifier);
    this.previousModifier = this.modifier.serialize();
  }

  // ### handleKeydown
  // allow a dialog to be dismissed by esc.
  evKey(evdata) {
    if (evdata.key === 'Escape') {
      $(this.dgDom.element).find('.cancel-button').click();
      evdata.preventDefault();
    } else {
      this.textEditorCtrl.evKey(evdata);
    }
  }

  // ### Event handlers, passed from dialog
  mouseUp() {
    if (this.textResizerCtrl && this.textResizerCtrl.running) {
      this.textResizerCtrl.mouseUp();
    } else if (this.textDraggerCtrl && this.textDraggerCtrl.running) {
      this.textDraggerCtrl.mouseUp();
    }
  }

  mouseMove(ev) {
    if (this.textResizerCtrl && this.textResizerCtrl.running) {
      this.textResizerCtrl.mouseMove(ev);
    }  else if (this.textDraggerCtrl && this.textDraggerCtrl.running) {
      this.textDraggerCtrl.mouseMove(ev);
    } else if (this.textEditorCtrl && this.textEditorCtrl.isRunning) {
      this.textEditorCtrl.mouseMove(ev);
    }
  }

  mouseClick(ev) {
    if (this.textEditorCtrl && this.textEditorCtrl.isRunning) {
      this.textEditorCtrl.mouseClick(ev);
      ev.stopPropagation();
    }
  }

  mouseDown(ev) {
    if (this.textResizerCtrl && this.textResizerCtrl.running) {
      this.textResizerCtrl.mouseDown(ev);
    } else if (this.textDraggerCtrl && this.textDraggerCtrl.running) {
      this.textDraggerCtrl.mouseDown(ev);
    }
  }

  constructor(parameters) {
    let edited = false;
    const tracker = parameters.view.tracker;
    const layout = parameters.view.score.layout;

    // Create a new text modifier, if this is new text.   Else use selection
    if (!parameters.modifier) {
      const newText =  new SmoScoreText({ position: SmoScoreText.positions.custom });
      newText.y += tracker.scroller.netScroll.y;
      if (tracker.selections.length > 0) {
        const sel = tracker.selections[0].measure;
        if (typeof(sel.logicalBox) !== 'undefined') {
          if (sel.logicalBox.y >= newText.y) {
            newText.y = sel.logicalBox.y;
            newText.x = sel.logicalBox.x;
          }
        }
      }
      const newGroup = new SmoTextGroup({ blocks: [newText] });
      parameters.modifier = newGroup;
      parameters.modifier.setActiveBlock(newText);
      parameters.view.addTextGroup(parameters.modifier);
      edited = true;
    } else {
      // Make sure there is a score text to start the editing.
      parameters.modifier.setActiveBlock(parameters.modifier.textBlocks[0].text);
    }
    const scrollPosition = tracker.scroller.absScroll;
    scrollPosition.y = scrollPosition.y / (layout.svgScale * layout.zoomScale);
    scrollPosition.x = scrollPosition.x / (layout.svgScale * layout.zoomScale);
    super(SuiTextTransformDialog.dialogElements, {
      id: 'dialog-' + parameters.modifier.attrs.id,
      top: scrollPosition.y + 100,
      left: scrollPosition.x + 100,
      ...parameters
    });
    this.edited = edited;
    this.view.groupUndo(true);
    this.previousModifier = this.modifier.serialize();
    this.activeScoreText = this.modifier.getActiveBlock();
    Vex.Merge(this, parameters);
    this.completeNotifier.unbindKeyboardForModal(this);
  }

  _complete() {
    this.view.groupUndo(false);
    this.modifier.setActiveBlock(null);
    this.view.tracker.updateMap(); // update the text map
    this.view.renderer.setDirty();
    this.eventSource.unbindMouseDownHandler(this.mouseDownHandler);
    this.eventSource.unbindMouseUpHandler(this.mouseUpHandler);
    this.eventSource.unbindMouseMoveHandler(this.mouseMoveHandler);
    this.eventSource.unbindMouseClickHandler(this.mouseClickHandler);
    $('body').removeClass('showAttributeDialog');
    $('body').removeClass('textEditor');
    this.complete();
  }
  _removeText() {
    this.view.removeTextGroup(this.modifier);
  }

  _bindElements() {
    this.bindKeyboard();
    const dgDom = this.dgDom;

    $(dgDom.element).find('.ok-button').off('click').on('click', () => {
      this._complete();
    });

    $(dgDom.element).find('.cancel-button').off('click').on('click', () => {
      this.view.groupUndo(false);
      if (this.edited) {
        this.view.undo();
      }
      this._complete();
    });
    $(dgDom.element).find('.remove-button').off('click').on('click', () => {
      this._removeText();
      this._complete();
    });
  }
}

// ## SuiDynamicModifierDialog
// This is a poorly named class, it just allows you to placeText
// dynamic text so it doesn't collide with something.
// eslint-disable-next-line no-unused-vars
class SuiDynamicModifierDialog extends SuiDialogBase {
  static get ctor() {
    return 'SuiDynamicModifierDialog';
  }
  get ctor() {
    return SuiDynamicModifierDialog.ctor;
  }
  static get label() {
    SuiDynamicModifierDialog._label = SuiDynamicModifierDialog._label ? SuiDynamicModifierDialog._label :
      'Dynamics Properties';
    return SuiDynamicModifierDialog._label;
  }
  static set label(value) {
    SuiDynamicModifierDialog._label = value;
  }

  static get dialogElements() {
    SuiDynamicModifierDialog._dialogElements = SuiDynamicModifierDialog._dialogElements ? SuiDynamicModifierDialog._dialogElements :
      [{
        smoName: 'yOffsetLine',
        parameterName: 'yOffsetLine',
        defaultValue: 11,
        control: 'SuiRockerComponent',
        label: 'Y Line'
      }, {
        smoName: 'yOffsetPixels',
        parameterName: 'yOffsetPixels',
        defaultValue: 0,
        control: 'SuiRockerComponent',
        label: 'Y Offset Px'
      }, {
        smoName: 'xOffset',
        parameterName: 'yOffset',
        defaultValue: 0,
        control: 'SuiRockerComponent',
        label: 'X Offset'
      }, {
        smoName: 'text',
        parameterName: 'text',
        defaultValue: SmoDynamicText.dynamics.P,
        options: [{
          value: SmoDynamicText.dynamics.P,
          label: 'Piano'
        }, {
          value: SmoDynamicText.dynamics.PP,
          label: 'Pianissimo'
        }, {
          value: SmoDynamicText.dynamics.MP,
          label: 'Mezzo-Piano'
        }, {
          value: SmoDynamicText.dynamics.MF,
          label: 'Mezzo-Forte'
        }, {
          value: SmoDynamicText.dynamics.F,
          label: 'Forte'
        }, {
          value: SmoDynamicText.dynamics.FF,
          label: 'Fortissimo'
        }, {
          value: SmoDynamicText.dynamics.SFZ,
          label: 'Sforzando'
        }],
        control: 'SuiDropdownComponent',
        label: 'Text'
      },
      { staticText: [
        { label: 'Dynamics Properties' }
      ] }
      ];
    return SuiDynamicModifierDialog._dialogElements;
  }
  static createAndDisplay(parameters) {
    const dg = new SuiDynamicModifierDialog(parameters);
    dg.display();
    return dg;
  }

  constructor(parameters) {
    super(SuiDynamicModifierDialog.dialogElements, {
      id: 'dialog-' + parameters.modifier.id,
      top: parameters.modifier.renderedBox.y,
      left: parameters.modifier.renderedBox.x,
      ...parameters
    });
    Vex.Merge(this, parameters);
    this.edited = false;
    this.view.groupUndo(true);
    this.components.find((x) => x.parameterName === 'text').defaultValue = parameters.modifier.text;
  }
  display() {
    super.display();
    // make sure keyboard is unbound or we get dupicate key events.
    this.completeNotifier.unbindKeyboardForModal(this);
    this._bindComponentNames();
    this.textCtrl.setValue(this.modifier.text);
    this.xOffsetCtrl.setValue(this.modifier.xOffset);
    this.yOffsetLineCtrl.setValue(this.modifier.yOffsetLine);
    this.yOffsetPixelsCtrl.setValue(this.modifier.yOffsetPixels);
  }
  // ### _bindElements
  // bing the generic controls in most dialogs.
  _bindElements() {
    var dgDom = this.dgDom;
    this.bindKeyboard();

    $(dgDom.element).find('.ok-button').off('click').on('click', () => {
      this.view.groupUndo(false);
      this.complete();
    });

    $(dgDom.element).find('.cancel-button').off('click').on('click', () => {
      this.view.groupUndo(false);
      if (this.edited) {
        this.view.undo();
      }
      this.complete();
    });
    $(dgDom.element).find('.remove-button').off('click').on('click', () => {
      this.view.groupUndo(false);
      this.handleRemove();
      this.complete();
    });
  }
  handleRemove() {
    this.view.removeDynamic(this.modifier);
  }
  changed() {
    this.edited = true;
    this.components.forEach((component) => {
      this.modifier[component.smoName] = component.getValue();
    });
    this.view.addDynamic(this.modifier);
  }
}
// eslint-disable-next-line no-unused-vars
class helpModal {
  static createAndDisplay() {
    SmoHelp.displayHelp();
    return htmlHelpers.closeDialogPromise();
  }
}
;
class SuiDom {

  static splash() {
    var b = htmlHelpers.buildDom;
    var logoPath = SmoConfig.smoPath + '/styles/images/logo.png'
    var r = b('div').classes('bug-modal').append(
        b('img').attr('src', logoPath).classes('splash-logo'))
      .append(b('button').classes('icon icon-cross bug-dismiss-button'))
      .append(b('span').classes('splash-title').text('Sm'))
      .append(b('span').classes('splash-shine').text('ooooooooo'))
      .append(b('span').classes('splash-title').text('sic'));
    $('.bugDialog').append(r.dom());
    $('body').addClass('splashScreen modal');
    setTimeout(function () {
      $('body').removeClass('splashScreen modal');
    }, 1000);
  }

	static createDom(title) {
    if (title) {
  	  $('h1.testTitle').text(title);
  	}

    var b = htmlHelpers.buildDom;
    var smoId = SmoConfig.smoDomContainer;
    var vexId = SmoConfig.vexDomContainer;
    var r=b('div').classes('dom-container')
      .append(b('div').classes('modes'))
      .append(b('div').classes('overlay'))
      .append(b('div').classes('draganime hide'))
      .append(b('div').classes('textEdit hide'))
      .append(b('div').classes('translation-editor'))
      .append(b('div').classes('attributeDialog'))
      .append(b('progress').attr('id','renderProgress').attr('value','0').attr('max','100'))
      .append(b('div').classes('qwertyKb'))
      .append(b('div').classes('saveLink'))
      .append(b('div').classes('bugDialog'))
      .append(b('div').classes('printFrame'))
      .append(b('div').classes('menuContainer'))
      .append(b('div').classes('workspace language-dir').attr('dir',SmoConfig.languageDir)
        .append(b('div').classes('helpDialog'))
        .append(b('div').classes('control-bar')
          .append(b('div').classes('titleText').text('Smoosic'))
          .append(b('div').classes('piano-container')
            .append(b('div').classes('key-left-ctrl'))
            .append(b('div').classes('piano-keys'))
            .append(b('div').classes('key-right-ctrl')))
          .append(b('div').classes('controls-top')))
        .append(b('div').classes('media')
          .append(b('div').classes('controls-left'))
          .append(b('div').classes('controls-menu-message'))
          .append(b('div').classes('musicRelief')
            .append(b('div').classes('musicContainer').attr('id',vexId)
            .attr('dir','ltr')))));
    $('#'+smoId).append(r.dom());
    var pianoDom=$('.piano-keys')[0];
    var svg=document.createElementNS(svgHelpers.namespace,'svg');
    svg.id='piano-svg';
    svg.setAttributeNS('','width',''+suiPiano.owidth*suiPiano.dimensions.octaves);
    svg.setAttributeNS('','height',''+suiPiano.dimensions.wheight);
    svg.setAttributeNS('','viewBox','0 0 '+suiPiano.owidth*suiPiano.dimensions.octaves+' '+suiPiano.dimensions.wheight);
    pianoDom.appendChild(svg);
	}


}

class UtDom {
  	static createDom() {
      var smoId = SmoConfig.smoDomContainer;
      var vexId = SmoConfig.vexDomContainer
  		var b = htmlHelpers.buildDom;
  		$('#'+smoId).html('');
  		var r = b('div').classes('dom-container')
  			.append(b('div').classes('modes'))
  			.append(b('div').classes('overlay'))
  			.append(b('div').classes('attributeDialog'))
  			.append(b('div').classes('helpDialog'))
  			.append(b('div').classes('menuContainer'))
  			.append(b('h1').classes('testTitle').text('Smoosic'))
  			.append(b('h2').classes('subTitle'))
  			.append(b('div').classes('piano-container')
          .append(b('div').classes('key-left-ctrl'))
  				.append(b('div').classes('piano-keys'))
          .append(b('div').classes('key-right-ctrl')))
  			.append(b('div').classes('workspace-container')
  				.append(b('div').classes('workspace').attr('dir',SmoConfig.languageDir)
  					.append(b('div').classes('controls-top'))
  					.append(b('div').classes('controls-left'))
  					.append(b('div').classes('musicRelief')
  						.append(b('div')
              .classes('musicContainer')
              .attr('id', vexId)
              .attr('dir','ltr')))));
  		$('#'+smoId).append(r.dom());
  	}

    static splash() {
      return;
    }
}
;

// ##browserEventSource
// Handle registration for events.  Can be used for automated testing, so all
// the events are consolidated in one place so they can be simulated or recorded
class browserEventSource {
  constructor(evMask) {
    this.keydownHandlers = [];
    this.mouseMoveHandlers = [];
    this.mouseClickHandlers = [];
    this.mouseUpHandlers = [];
    this.mouseDownHandlers = [];
    this.domTriggers = [];
    this.scrollers = [];
    this.handleKeydown = this.evKey.bind(this);
    this.vexContext = null;
    window.addEventListener("keydown", this.handleKeydown, true);
  }

  evKey(event) {
    this.keydownHandlers.forEach((handler) => {
      handler.sink[handler.method](event);
    });
  }

  mouseMove(event) {
    this.mouseMoveHandlers.forEach((handler) => {
      handler.sink[handler.method](event);
    });
  }

  mouseClick(event) {
    this.mouseClickHandlers.forEach((handler) => {
      handler.sink[handler.method](event);
    });
  }

  mouseDown(event) {
    this.mouseDownHandlers.forEach((handler) => {
      handler.sink[handler.method](event);
    });
  }

  mouseUp(event) {
    this.mouseUpHandlers.forEach((handler) => {
      handler.sink[handler.method](event);
    });
  }

  setRenderElement(renderElement) {
    this.renderElement = renderElement;
    var self = this;
    this.handleMouseMove = this.mouseMove.bind(this);
    this.handleMouseClick = this.mouseClick.bind(this);
    this.handleMouseUp = this.mouseUp.bind(this);
    this.handleMouseDown = this.mouseDown.bind(this);
    $(document)[0].addEventListener("mousemove",this.handleMouseMove);
    $(this.renderElement)[0].addEventListener("click",this.handleMouseClick);
    $(document)[0].addEventListener("mouseup",this.handleMouseUp);
    $(document)[0].addEventListener("mousedown",this.handleMouseDown);
  }

  _unbindHandlerArray(arSrc,arDest,handler) {
    arSrc.forEach((htest) => {
      if (handler.symbol !== htest.symbol) {
        arDest.push(htest);
      }
    });
  }

  unbindMouseMoveHandler(handler) {
    var handlers = [];
    this._unbindHandlerArray(this.mouseMoveHandlers,handlers,handler);
    this.mouseMoveHandlers = handlers;
  }
  unbindMouseDownHandler(handler) {
    var handlers = [];
    this._unbindHandlerArray(this.mouseDownHandlers,handlers,handler);
    this.mouseDownHandlers = handlers;
  }
  unbindMouseUpHandler(handler) {
    var handlers = [];
    this._unbindHandlerArray(this.mouseUpHandlers,handlers,handler);
    this.mouseUpHandlers = handlers;
  }
  unbindMouseClickHandler(handler) {
    var handlers = [];
    this._unbindHandlerArray(this.mouseClickHandlers,handlers,handler);
    this.mouseClickHandlers = handlers;
  }

  unbindKeydownHandler(handler) {
    var handlers = [];
    this._unbindHandlerArray(this.keydownHandlers,handlers,handler);
    this.keydownHandlers = handlers;
  }

  bindScroller(sink,method) {}

  // ### bindKeydownHandler
  // add a handler for the evKey event, for keyboard data.
  bindKeydownHandler(sink,method) {
    var handler = {};
    handler.symbol = Symbol();
    handler.sink = sink;
    handler.method = method;
    this.keydownHandlers.push(handler);
    return handler;
  }

  bindMouseMoveHandler(sink, method) {
    var handler = {symbol: Symbol(), sink, method};
    this.mouseMoveHandlers.push(handler);
    return handler;
  }

  bindMouseUpHandler(sink, method) {
    var handler = {symbol: Symbol(), sink, method};
    this.mouseUpHandlers.push(handler);
    return handler;
  }

  bindMouseDownHandler(sink, method) {
    var handler = {symbol: Symbol(), sink, method};
    this.mouseDownHandlers.push(handler);
    return handler;
  }

  bindMouseClickHandler(sink, method) {
    var handler = {symbol: Symbol(), sink, method};
    this.mouseClickHandlers.push(handler);
    return handler;
  }

  domClick(selector,sink,method,args) {
    $(selector).off('click').on('click',function(ev) {
      sink[method](ev,args);
    });
  }
}
;
class SuiExceptionHandler {
  constructor(params) {
    this.view = params.view;
    this.thrown = false;
	  SuiExceptionHandler._instance = this;
  }
	static get instance() {
		return SuiExceptionHandler._instance;
	}
  exceptionHandler(e) {
    var self = this;
    if (this.thrown) {
      return;
    }
    this.thrown = true;
    if (window['suiController'] && window['suiController'].reentry) {
      return;
    }

    if (window['suiController']) {
      suiController.reentry = true;
    }
    var scoreString = 'Could not serialize score.';
    try {
      scoreString = this.view.score.serialize();
    } catch (e) {
      scoreString += ' ' + e.message;
    }
    var message = e.message;
    var stack = 'No stack trace available';

    try {
      if (e.error && e.error.stack) {
        stack = e.error.stack;
      } else if (e['stack']) {
  	     stack = e.stack;
      }
    } catch (e2) {
      stack = 'Error with stack: ' + e2.message;
    }
    var doing = 'Last operation not available.';

    var lastOp = this.view.undoBuffer.peek();
    if (lastOp) {
      doing = lastOp.title;
    }
    var url = 'https://github.com/AaronDavidNewman/Smoosic/issues';
    var bodyObject = JSON.stringify({
        message: message,
        stack: stack,
        lastOperation: doing,
        scoreString: scoreString
      }, null, ' ');

    var b = htmlHelpers.buildDom;
    var r = b('div').classes('bug-modal').append(
      b('img').attr('src', '../styles/images/logo.png').classes('bug-logo'))
        .append(b('button').classes('icon icon-cross bug-dismiss-button'))
        .append(b('span').classes('bug-title').text('oh nooooo!  You\'ve found a bug'))
        .append(b('p').text('It would be helpful if you would submit a bug report, and copy the data below into an issue'))
        .append(b('div')
            .append(b('textarea').attr('id', 'bug-text-area').text(bodyObject))
            .append(
                b('div').classes('button-container').append(b('button').classes('bug-submit-button').text('Submit Report'))));

    $('.bugDialog').html('');
    $('.bugDialog').append(r.dom());

    $('.bug-dismiss-button').off('click').on('click', function () {
        $('body').removeClass('bugReport');
        if (lastOp) {
            self.view.undoBuffer.undo(self.view.score);
            self.view.renderer.render();
            suiController.reentry = false;
        }
    });
    $('.bug-submit-button').off('click').on('click', function () {
      var data = {
        title: "automated bug report",
        body: encodeURIComponent(bodyObject)
      };
      $('#bug-text-area').select();
      document.execCommand('copy');
      window.open(url, 'Report Smoosic issues');
    });
    $('body').addClass('bugReport');
    if (!this.thrown) {
      this.thrown = true;
      throw(e);
    }
  }
}
;

class SmoHelp {

  static displayHelp() {
    $('body').addClass('showHelpDialog');
    $('.helpDialog').html('');
    var b = htmlHelpers.buildDom;
    SmoHelp.helpHtml.forEach((cat) => {
      var r = SmoHelp._buildElements(cat);
      $('.helpDialog').append(r.dom());
    });
    $('.helpDialog').append(SmoHelp.closeButton.dom());
		$('button.help-title').off('click').on('click',function(ev) {
			$(this).closest('div.helpLine').toggleClass('showSection');
			$(this).find('span.icon').toggleClass('icon-plus');
			$(this).find('span.icon').toggleClass('icon-minus');
		});
    $('.helpDialog button.icon-cross').off('click').on('click', function () {
        $('body').removeClass('showHelpDialog');
        $('.workspace').css("height",'');
    });
    var wsh = window.innerHeight;
    $('.workspace').css("height",''+wsh+'px');
  }

  static get closeButton() {
      var b = htmlHelpers.buildDom;
      var r = b('div').classes('help-closer').append(
        b('button').classes('icon-cross close'));
      return r;
  }

  static _buildElements(helps) {
    var b = htmlHelpers.buildDom;
    var r = b('div').classes('helpLine')
      .append(b('div').classes('help-category-button')
        .append(b('button')
          .append(b('span').classes('icon icon-plus')).classes('help-title')
          .append(b('span').classes('help-category-text').text(helps.title))))
      .append(b('div').classes('help-content').html(helps.html));

    return r;
  }

  static get helpHtml() {
    return [
      {title:'Quick Start',html:SmoLanguage.getHelpFile('quickStartHtml')},
      {title:'Selections and Selecting Things',html:SmoLanguage.getHelpFile('selectionHtml')},
      {title:'Entering Music (Pitches)',html:SmoLanguage.getHelpFile('enterPitchesHtml')},
      {title:'Entering Music (Durations)',html:SmoLanguage.getHelpFile('enterDurationsHtml')},
      {title:'Working with Text, Lyrics, Chords',html:SmoLanguage.getHelpFile('workingWithText')}
    ];
  }
}
;
var smoLanguageStringAr = `[
 {
  "ctor": "SuiLoadFileDialog",
  "dialogElements": [
   {
    "staticText": [
     {
      "label": "Load File"
     }
    ]
   }
  ]
 },
 {
  "ctor": "SuiSaveFileDialog",
  "dialogElements": [
   {
    "staticText": [
     {
      "label": "Save Score"
     }
    ]
   }
  ]
 },
 {
  "ctor": "SuiPrintFileDialog",
  "dialogElements": [
   {
    "staticText": [
     {
      "label": "Print Complete"
     }
    ]
   }
  ]
 },
 {
  "ctor": "SuiMeasureDialog",
  "dialogElements": [
   {
    "staticText": [
     {
      "label": "Measure Properties"
     }
    ]
   },
   {
    "id": "pickupMeasure",
    "label": "Pickup Measure",
    "options": [
     {
      "value": "2048",
      "label": "Eighth Note"
     },
     {
      "value": "4096",
      "label": "Quarter Note"
     },
     {
      "value": "6144",
      "label": "Dotted Quarter"
     },
     {
      "value": "8192",
      "label": "Half Note"
     }
    ]
   },
   {
    "id": "measureTextPosition",
    "label": "Text Position",
    "options": [
     {
      "value": "2",
      "label": "Left"
     },
     {
      "value": "3",
      "label": "Right"
     },
     {
      "value": "0",
      "label": "Above"
     },
     {
      "value": "1",
      "label": "Below"
     }
    ]
   }
  ]
 },
 {
  "ctor": "SuiTempoDialog",
  "dialogElements": [
   {
    "staticText": [
     {
      "label": "Tempo Properties"
     }
    ]
   },
   {
    "id": "tempoMode",
    "label": " ",
    "options": [
     {
      "value": "duration",
      "label": "Duration (Beats/Minute)"
     },
     {
      "value": "text",
      "label": "Tempo Text"
     },
     {
      "value": "custom",
      "label": "Specify text and duration"
     }
    ]
   },
   {
    "id": "beatDuration",
    "label": "  ",
    "options": [
     {
      "value": "4096",
      "label": "Quarter Note"
     },
     {
      "value": "2048",
      "label": "1/8 note"
     },
     {
      "value": "6144",
      "label": "Dotted 1/4 note"
     },
     {
      "value": "8192",
      "label": "1/2 note"
     }
    ]
   },
   {
    "id": "tempoText",
    "label": "Tempo Text",
    "options": [
     {
      "value": "Larghissimo",
      "label": "Larghissimo"
     },
     {
      "value": "Grave",
      "label": "Grave"
     },
     {
      "value": "Lento",
      "label": "Lento"
     },
     {
      "value": "Largo",
      "label": "Largo"
     },
     {
      "value": "Larghetto",
      "label": "Larghetto"
     },
     {
      "value": "Adagio",
      "label": "Adagio"
     },
     {
      "value": "Adagietto",
      "label": "Adagietto"
     },
     {
      "value": "Andante moderato",
      "label": "Andante moderato"
     },
     {
      "value": "Andante",
      "label": "Andante"
     },
     {
      "value": "Andantino",
      "label": "Andantino"
     },
     {
      "value": "Moderato",
      "label": "Moderato"
     },
     {
      "value": "Allegretto",
      "label": "Allegretto"
     },
     {
      "value": "Allegro",
      "label": "Allegro"
     },
     {
      "value": "Vivace",
      "label": "Vivace"
     },
     {
      "value": "Presto",
      "label": "Presto"
     },
     {
      "value": "Prestissimo",
      "label": "Prestissimo"
     }
    ]
   }
  ]
 },
 {
  "ctor": "SuiInstrumentDialog",
  "dialogElements": [
   {
    "staticText": [
     {
      "label": "Instrument Properties"
     }
    ]
   },
   {
    "id": "applyTo",
    "label": "Apply To",
    "options": [
     {
      "value": "0",
      "label": "Score"
     },
     {
      "value": "1",
      "label": "Selected Measures"
     },
     {
      "value": "3",
      "label": "Remaining Measures"
     }
    ]
   }
  ]
 },
 {
  "ctor": "SuiTimeSignatureDialog",
  "dialogElements": [
   {
    "staticText": [
     {
      "label": "Custom Time Signature"
     }
    ]
   },
   {
    "id": "denominator",
    "label": "Beat Value",
    "options": [
     {
      "value": "8",
      "label": "8"
     },
     {
      "value": "4",
      "label": "4"
     },
     {
      "value": "2",
      "label": "2"
     }
    ]
   }
  ]
 },
 {
  "ctor": "SuiLayoutDialog",
  "dialogElements": [
   {
    "id": "pageSize",
    "label": "Page Size",
    "options": [
     {
      "value": "letter",
      "label": "Letter"
     },
     {
      "value": "tabloid",
      "label": "Tabloid (11x17)"
     },
     {
      "value": "A4",
      "label": "A4"
     },
     {
      "value": "custom",
      "label": "Custom"
     }
    ]
   },
   {
    "id": "orientation",
    "label": "Orientation",
    "options": [
     {
      "value": "0",
      "label": "Portrait"
     },
     {
      "value": "1",
      "label": "Landscape"
     }
    ]
   },
   {
    "id": "engravingFont",
    "label": "Engraving Font",
    "options": [
     {
      "value": "Bravura",
      "label": "Bravura"
     },
     {
      "value": "Gonville",
      "label": "Gonville"
     },
     {
      "value": "Petaluma",
      "label": "Petaluma"
     }
    ]
   },
   {
    "staticText": [
     {
      "label": "Score Layout"
     }
    ]
   }
  ]
 },
 {
  "ctor": "SuiDynamicModifierDialog",
  "dialogElements": [
   {
    "id": "text",
    "label": "Text",
    "options": [
     {
      "value": "p",
      "label": "Piano"
     },
     {
      "value": "pp",
      "label": "Pianissimo"
     },
     {
      "value": "mp",
      "label": "Mezzo-Piano"
     },
     {
      "value": "mf",
      "label": "Mezzo-Forte"
     },
     {
      "value": "f",
      "label": "Forte"
     },
     {
      "value": "ff",
      "label": "Fortissimo"
     },
     {
      "value": "sfz",
      "label": "Sforzando"
     }
    ]
   },
   {
    "staticText": [
     {
      "label": "Dynamics Properties"
     }
    ]
   }
  ]
 },
 {
  "ctor": "SuiSlurAttributesDialog",
  "dialogElements": [
   {
    "staticText": [
     {
      "label": "Slur Properties"
     }
    ]
   },
   {
    "id": "position",
    "label": "Start Position",
    "options": [
     {
      "value": "1",
      "label": "Head"
     },
     {
      "value": "2",
      "label": "Top"
     }
    ]
   },
   {
    "id": "position_end",
    "label": "End Position",
    "options": [
     {
      "value": "1",
      "label": "Head"
     },
     {
      "value": "2",
      "label": "Top"
     }
    ]
   }
  ]
 },
 {
  "ctor": "SuiVoltaAttributeDialog",
  "dialogElements": [
   {
    "staticText": [
     {
      "label": "Volta Properties"
     }
    ]
   }
  ]
 },
 {
  "ctor": "SuiHairpinAttributesDialog",
  "dialogElements": [
   {
    "staticText": [
     {
      "label": "Hairpin Properties"
     }
    ]
   }
  ]
 },
 {
  "ctor": "SuiLyricDialog",
  "dialogElements": [
   {
    "id": "verse",
    "label": "Verse",
    "options": [
     {
      "value": "0",
      "label": "1"
     },
     {
      "value": "1",
      "label": "2"
     },
     {
      "value": "2",
      "label": "3"
     }
    ]
   },
   {
    "id": "textEditor",
    "label": "Edit Text",
    "options": []
   },
   {
    "staticText": [
     {
      "doneEditing": "Done Editing Lyrics"
     },
     {
      "undo": "Undo Lyrics"
     },
     {
      "label": "Lyric Editor"
     }
    ]
   }
  ]
 },
 {
  "ctor": "SuiChordChangeDialog",
  "dialogElements": [
   {
    "id": "verse",
    "label": "Verse",
    "options": [
     {
      "value": "0",
      "label": "1"
     },
     {
      "value": "1",
      "label": "2"
     },
     {
      "value": "2",
      "label": "3"
     }
    ]
   },
   {
    "id": "textEditor",
    "label": "Edit Text",
    "options": []
   },
   {
    "staticText": [
     {
      "doneEditing": "Done Editing Lyrics"
     },
     {
      "undo": "Undo Lyrics"
     },
     {
      "label": "Lyric Editor"
     }
    ]
   }
  ]
 },
 {
  "ctor": "SuiTextTransformDialog",
  "dialogElements": [
   {
    "id": "textEditor",
    "label": "Edit Text",
    "options": []
   },
   {
    "id": "textDragger",
    "label": "Move Text",
    "options": []
   },
   {
    "id": "textResizer",
    "label": "Resize Text",
    "options": []
   },
   {
    "id": "justification",
    "label": "Justification",
    "options": [
     {
      "value": "left",
      "label": "Left"
     },
     {
      "value": "right",
      "label": "Right"
     },
     {
      "value": "center",
      "label": "Center"
     }
    ]
   },
   {
    "id": "fontFamily",
    "label": "Font Family",
    "options": [
     {
      "value": "Merriweather,serif",
      "label": "Serif"
     },
     {
      "value": "Roboto,sans-serif",
      "label": "Sans-Serif"
     },
     {
      "value": "monospace",
      "label": "Monospace"
     },
     {
      "value": "cursive",
      "label": "Cursive"
     },
     {
      "value": "Merriweather",
      "label": "times"
     },
     {
      "value": "Arial",
      "label": "arial"
     },
     {
      "value": "Helvetica",
      "label": "Helvetica"
     }
    ]
   },
   {
    "id": "fontUnit",
    "label": "Units",
    "options": [
     {
      "value": "em",
      "label": "em"
     },
     {
      "value": "px",
      "label": "px"
     },
     {
      "value": "pt",
      "label": "pt"
     }
    ]
   },
   {
    "id": "pagination",
    "label": "Page Behavior",
    "options": [
     {
      "value": "once",
      "label": "Once"
     },
     {
      "value": "every",
      "label": "Every"
     },
     {
      "value": "even",
      "label": "Even"
     },
     {
      "value": "odd",
      "label": "Odd"
     },
     {
      "value": "subsequent",
      "label": "Subsequent"
     }
    ]
   },
   {
    "staticText": [
     {
      "label": "Text Properties"
     }
    ]
   }
  ]
 },
 {
  "ctor": "SuiAddStaffMenu",
  "label": "",
  "menuItems": [
   {
    "value": "trebleInstrument",
    "text": "  "
   },
   {
    "value": "bassInstrument",
    "text": "  "
   },
   {
    "value": "altoInstrument",
    "text": "  "
   },
   {
    "value": "tenorInstrument",
    "text": "  "
   },
   {
    "value": "remove",
    "text": " "
   },
   {
    "value": "cancel",
    "text": ""
   }
  ]
 },
 {
  "ctor": "SuiMeasureMenu",
  "label": "Measure",
  "menuItems": [
   {
    "value": "addMenuBeforeCmd",
    "text": "Add Measure Before"
   },
   {
    "value": "addMenuAfterCmd",
    "text": "Add Measure After"
   },
   {
    "value": "deleteSelected",
    "text": "Delete Selected Measures"
   },
   {
    "value": "formatMeasureDialog",
    "text": "Format Measure"
   },
   {
    "value": "cancel",
    "text": "Cancel"
   }
  ]
 },
 {
  "ctor": "SuiFileMenu",
  "label": "",
  "menuItems": [
   {
    "value": "newFile",
    "text": "e"
   },
   {
    "value": "openFile",
    "text": ""
   },
   {
    "value": "saveFile",
    "text": ""
   },
   {
    "value": "quickSave",
    "text": "Quick Save"
   },
   {
    "value": "printScore",
    "text": ""
   },
   {
    "value": "bach",
    "text": "Bach Invention"
   },
   {
    "value": "bambino",
    "text": "Jesu Bambino"
   },
   {
    "value": "microtone",
    "text": "Microtone Sample"
   },
   {
    "value": "preciousLord",
    "text": "Precious Lord"
   },
   {
    "value": "yamaJson",
    "text": "Yama"
   },
   {
    "value": "cancel",
    "text": ""
   }
  ]
 },
 {
  "ctor": "SuiTimeSignatureMenu",
  "label": " ",
  "menuItems": [
   {
    "value": "6/8",
    "text": "6/8"
   },
   {
    "value": "3/4",
    "text": "3/4"
   },
   {
    "value": "2/4",
    "text": "2/4"
   },
   {
    "value": "12/8",
    "text": "12/8"
   },
   {
    "value": "7/8",
    "text": "7/8"
   },
   {
    "value": "5/8",
    "text": "5/8"
   },
   {
    "value": "TimeSigOther",
    "text": "Other"
   },
   {
    "value": "cancel",
    "text": "Cancel"
   }
  ]
 },
 {
  "ctor": "SuiKeySignatureMenu",
  "label": "",
  "menuItems": [
   {
    "value": "KeyOfC",
    "text": "C Major"
   },
   {
    "value": "KeyOfF",
    "text": "F Major"
   },
   {
    "value": "KeyOfG",
    "text": "G Major"
   },
   {
    "value": "KeyOfBb",
    "text": "Bb Major"
   },
   {
    "value": "KeyOfD",
    "text": "D Major"
   },
   {
    "value": "KeyOfEb",
    "text": "Eb Major"
   },
   {
    "value": "KeyOfA",
    "text": "A Major"
   },
   {
    "value": "KeyOfAb",
    "text": "Ab Major"
   },
   {
    "value": "KeyOfE",
    "text": "E Major"
   },
   {
    "value": "KeyOfDb",
    "text": "Db Major"
   },
   {
    "value": "KeyOfB",
    "text": "B Major"
   },
   {
    "value": "KeyOfF#",
    "text": "F# Major"
   },
   {
    "value": "KeyOfC#",
    "text": "C# Major"
   },
   {
    "value": "cancel",
    "text": "Cancel"
   }
  ]
 },
 {
  "ctor": "SuiTimeSignatureMenu",
  "label": " ",
  "menuItems": [
   {
    "value": "6/8",
    "text": "6/8"
   },
   {
    "value": "3/4",
    "text": "3/4"
   },
   {
    "value": "2/4",
    "text": "2/4"
   },
   {
    "value": "12/8",
    "text": "12/8"
   },
   {
    "value": "7/8",
    "text": "7/8"
   },
   {
    "value": "5/8",
    "text": "5/8"
   },
   {
    "value": "TimeSigOther",
    "text": "Other"
   },
   {
    "value": "cancel",
    "text": ""
   }
  ]
 },
 {
  "ctor": "SuiKeySignatureMenu",
  "label": "",
  "menuItems": [
   {
    "value": "KeyOfC",
    "text": "C Major"
   },
   {
    "value": "KeyOfF",
    "text": "F Major"
   },
   {
    "value": "KeyOfG",
    "text": "G Major"
   },
   {
    "value": "KeyOfBb",
    "text": "Bb Major"
   },
   {
    "value": "KeyOfD",
    "text": "D Major"
   },
   {
    "value": "KeyOfEb",
    "text": "Eb Major"
   },
   {
    "value": "KeyOfA",
    "text": "A Major"
   },
   {
    "value": "KeyOfAb",
    "text": "Ab Major"
   },
   {
    "value": "KeyOfE",
    "text": "E Major"
   },
   {
    "value": "KeyOfDb",
    "text": "Db Major"
   },
   {
    "value": "KeyOfB",
    "text": "B Major"
   },
   {
    "value": "KeyOfF#",
    "text": "F# Major"
   },
   {
    "value": "KeyOfC#",
    "text": "C# Major"
   },
   {
    "value": "cancel",
    "text": "Cancel"
   }
  ]
 },
 {
  "ctor": "SuiStaffModifierMenu",
  "label": "",
  "menuItems": [
   {
    "value": "crescendo",
    "text": ""
   },
   {
    "value": "decrescendo",
    "text": ""
   },
   {
    "value": "slur",
    "text": " / "
   },
   {
    "value": "ending",
    "text": " "
   },
   {
    "value": "cancel",
    "text": ""
   }
  ]
 },
 {
  "ctor": "SuiDynamicsMenu",
  "label": "Dynamics",
  "menuItems": [
   {
    "value": "pp",
    "text": "Pianissimo"
   },
   {
    "value": "p",
    "text": "Piano"
   },
   {
    "value": "mp",
    "text": "Mezzo-piano"
   },
   {
    "value": "mf",
    "text": "Mezzo-forte"
   },
   {
    "value": "f",
    "text": "Forte"
   },
   {
    "value": "ff",
    "text": "Fortissimo"
   },
   {
    "value": "sfz",
    "text": "sfortzando"
   },
   {
    "value": "cancel",
    "text": "Cancel"
   }
  ]
 }
]`;


var quickStartHtmlar = `(Arabic)
    <h3 id="quick-start-guide">Quick start guide</h3>
<p>If you don&#39;t like to read instructions, this cook&#39;s tour of Smoosic was made for you.</p>
<ul>
<li><p>One of buttons on the left is called &#39;File&#39;.  Click on it. The menu items before &#39;cancel&#39; are pre-canned projects that you can use as a template to get you started.</p>
</li>
<li><p>The cursor keys will navigate you to the different notes.</p>
</li>
<li><p>Letters a-g on the computer keyboard change the note to those pitches</p>
</li>
<li><p>&#39;Insert&#39; adds a new, blank measure.</p>
</li>
<li><p>The ribbon of thick blue buttons on the top expand to button groups, that contain most of the functionality of Smoosic.  </p>
</li>
<li><p>The buttons on the left bring up menus or dialogs that do basically what the buttons say.</p>
</li>
<li><p>There are a few &#39;instant gratification&#39; buttons for playing the music, refreshing the screen or changing the zoom level on the left part of the ribbon.</p>
</li>
<li><p>The piano tool is an alternate way of entering music, or can be dismissed by the close button in the lower left.</p>
</li>
</ul>
<p><img src="https://imgur.com/nP16PMI.gif" alt="" width="640" height="480"></p>
`;


var selectionHtmlar = `(Arabic)
<h3 id="selecting-things">Selecting things</h3>
<p>Almost all operations in Smoosic act on the selected music.  You can select notes in different ways:</p>
<ol>
<li>with the computer mouse</li>
<li>with the keyboard&#39;s navigation keys</li>
<li>with the navigation keys on the ribbon</li>
<li>with the piano tool, to some extent.</li>
</ol>
<p><img src="https://imgur.com/q1qK3Pn.gif" alt=""></p>
<p>You can select multiple things with the keyboard navigation keys, by selecting &#39;shift-arrow&#39;, just like many applications.  There is a similar control for selection in the navigation ribbon.  Some operations, like changing pitch for instance, act on all the selected notes.</p>
<p>Sometimes a selection of one line affects all the measures in that column (or all the measures of the system, if you like).  When you change the key, for instance, the selection determines where the key change starts.  If you have multiple measures selected, it applies to those measures, and then changes back to whatever it was before.</p>
`;


var enterDurationsHtmlar = `(Arabic)
<p>Note duration in Smoosic is done by changing the duration of an existing note.  Usually, doubling the duration or cutting it in two, or adding a dot - duration to a note.  You can also create tuplets for uneven sets of notes (3, 5, or 7).</p>
<p>There are actually 3 ways to do many duration operations - using the piano tool, using the computer keyboard, or using the button ribbon.  Like with many things, you should find entering duration using the keyboard fastest, once you have some experience with Smoosic.  But the ribbon or the </p>
<h2 id="changing-note-length-with-the-keyboard">Changing note length with the keyboard</h2>
<p>You can change the length of notes using the &#39;,&#39; and &#39;.&#39; (comma and period) keys, which halve and double the note lengths, respectively.  You can add a dot to the length of the note (multiplying length by 3/2 for the first dot, and 3/4 for the second dot, if you like to think of it that way) or remove a dot, using the &#39;&gt;&#39; and &#39;&lt;&#39;.  The mnemonic device for these is &#39;&gt;&#39; makes note duration greater.  &#39;&lt;&#39; makes note duration...less.  (On most QWERTY keyboards, comma shifted is &#39;&lt;&#39; and period shifted is &#39;&gt;&#39;).</p>
<p><img src="https://imgur.com/5ZWq2Xe.gif" alt=""></p>
<p>Note how the selection is preserved as the notes get shorter.  When you change something, Smoosic will try to keep the selection as close as possible to what you had.  You can use the cursor navigation keys to move to a specific selected note.</p>
<p><img src="https://imgur.com/woMw4RH.gif" alt=""></p>
<p>When you increase the length of a note, Smoosic always &#39;borrows&#39; from the next note in the measure that is eligible.  So when you double the length of the 8th note, it combines the 16th, and 2 32nd notes, and collapses them into a single quarter.  If Smoosic can&#39;t honor the request, it does nothing.  For instance, it can&#39;t remove the dot from a note with no dot, and it can&#39;t extend beyond the length of the measure.</p>
<p>You can create tuplets from the keyboard by typing Ctrl-3, Ctrl-5 or Ctrl-7 for triplets, quintuplets, and septuplets, respectively.  Individual notes in a tuplet can be doubled and halved with the duration keys &#39;-&#39; (minus) and &#39;=&#39; (equals), just like non-tuplets.  You &#39;untupletify&#39; a tuplet by Ctrl-0.</p>
<p><img src="https://imgur.com/uBpQwXD.gif" alt=""></p>
<h2 id="changing-note-length-with-piano-widget">Changing note length with piano widget</h2>
<p>The piano widget is shown when the application starts, and can be restored from the left menu &#39;Piano&#39; button when closed.</p>
<p>You can double or halve note duration, or add dot duration, to a note using the piano tool. </p>
<p><img src="https://imgur.com/Rw4yDxP.gif" alt=""></p>
<h2 id="changing-note-length-from-the-button-ribbon">Changing note length from the button ribbon</h2>
<p>All the duration commands can be accomplished from the ribbon buttons.  </p>
<p><img src="https://imgur.com/n9bmamg.gif" alt=""></p>
<p>Note that the equivalent keyboard commands are also indicated on the right of each button, when it&#39;s available.  (there are only so many keys, so there are some ribbon buttons with no key shortcut). </p>
`;


var enterPitchesHtmlar = `(Arabic)
<p>There are a few ways to enter notes in Smoosic.  You can click on the piano widget keys, or you can enter notes directly from the keyboard.</p>
<h2 id="your-first-smoosical-notes">Your first Smoosical notes</h2>
<h3 id="notes-from-the-keyboard">Notes from the keyboard</h3>
<p>The keys a-g on the computer keyboard will enter a corresponding note, A-G, on the staff (Most key commands in Smoosic have a mnemonic device).  The default behavior is for the cursor to advance when a note is entered in this way.  (Future behavior, auto-advance can be overridden). You navigate to the notes using the keyboard navigation arrows.</p>
<p><img src="https://imgur.com/lxR0NI7.gif" alt=""></p>
<p>You change the octave from the keyboard using the &#39;_&#39; and &#39;+&#39; (underscore, aka shift-minus, and plus), and change notes chromatically using &#39;-&#39; and &#39;=&#39; key.  The mnemonic device for this is &#39;plus and minus&#39; for raising and lowering pitches.  You can change the enharmonic spelling of the note using the &#39;Shift-E&#39; (mnemonic: E for enharmonic - get it?).  And Shift-F gives you a courtesy, or cautionary, accidental (mnemonic - F comes after E).</p>
<p><img src="https://imgur.com/1tC94sV.gif" alt=""></p>
<p>You can create chords and intervals using the number keys along the top of the keyboard.  The &#39;3&#39; key makes a third, the &#39;4&#39; key a fourth, and so on.  Shift+number gives you the interval down.</p>
<p><img src="https://imgur.com/IwoeWi3.gif" alt=""></p>
<p>Note that the interval starts from the highest note in the chord, for intervals going up, and the lowest note in the chord, for intervals going down.  You can select individual pitches in the chord using &#39;Shift-Up Arrow&#39; as shown.  This is similar to how modifiers like dynamics are selected.  Once you have the pitch selected, you can change it using the up-down commands shows above, or change the enharmonic spelling.</p>
<p>There is currently no way to remove a single pitch from the chord.  If you want to collapse the chord, just type a letter a-g on the keyboard, and it will be replaced with a single note.</p>
<h3 id="notes-from-the-piano-tool">Notes from the piano tool</h3>
<p>You can also add notes to your score with the piano tool, by clicking on the corresponding notes.</p>
<p><img src="https://imgur.com/MOMlIg3.gif" alt=""></p>
<p>Clicking on the piano gives the selected note the piano pitch.  The octave of the note is based on the clef, so for treble clef, the &#39;C&#39; is middle &#39;C&#39;.  You can change the octave of the note, and move the pitch up and down.  The top buttons affect the pitch, and the bottom buttons navigate or change the length of the note.  Clicking on the chord button acts like a &#39;sustain&#39; that puts additional notes in chords.</p>
<p>Everything that can be done from the piano widget, and most things in Smoosic generally, can be done more efficiently with keyboard commands. Once you are comfortable with the computer keyboard, you can free up some screen real-estate by closing the piano widget (cross control in lower left).  You can bring it up again with the piano menu button on the left.</p>
`;
;
var smoLanguageStringDe = `[
 {
  "ctor": "SuiLoadFileDialog",
  "dialogElements": [
   {
    "staticText": [
     {
      "label": "Datei laden"
     }
    ]
   }
  ]
 },
 {
  "ctor": "SuiSaveFileDialog",
  "dialogElements": [
   {
    "staticText": [
     {
      "label": "Score speichern"
     }
    ]
   }
  ]
 },
 {
  "ctor": "SuiPrintFileDialog",
  "dialogElements": [
   {
    "staticText": [
     {
      "label": "Druck abgeschlossen"
     }
    ]
   }
  ]
 },
 {
  "ctor": "SuiMeasureDialog",
  "dialogElements": [
   {
    "staticText": [
     {
      "label": "Takt Voreinstellungen"
     }
    ]
   },
   {
    "id": "pickupMeasure",
    "label": "Takt Pickup",
    "options": [
     {
      "value": "2048",
      "label": "Eighth Note"
     },
     {
      "value": "4096",
      "label": "Quarter Note"
     },
     {
      "value": "6144",
      "label": "Dotted Quarter"
     },
     {
      "value": "8192",
      "label": "Half Note"
     }
    ]
   },
   {
    "id": "measureTextPosition",
    "label": "Text Position",
    "options": [
     {
      "value": "2",
      "label": "Left"
     },
     {
      "value": "3",
      "label": "Right"
     },
     {
      "value": "0",
      "label": "Above"
     },
     {
      "value": "1",
      "label": "Below"
     }
    ]
   }
  ]
 },
 {
  "ctor": "SuiTempoDialog",
  "dialogElements": [
   {
    "staticText": [
     {
      "label": "Tempo Voreinstellungen"
     }
    ]
   },
   {
    "id": "tempoMode",
    "label": "Tempo Modus",
    "options": [
     {
      "value": "duration",
      "label": "Dauer (Beats/Minute)"
     },
     {
      "value": "text",
      "label": "Tempo Text"
     },
     {
      "value": "custom",
      "label": "Text und Dauer festlegen"
     }
    ]
   },
   {
    "id": "beatDuration",
    "label": "Einheit fr Beat",
    "options": [
     {
      "value": "4096",
      "label": "Quarter Note"
     },
     {
      "value": "2048",
      "label": "1/8 note"
     },
     {
      "value": "6144",
      "label": "Dotted 1/4 note"
     },
     {
      "value": "8192",
      "label": "1/2 note"
     }
    ]
   },
   {
    "id": "tempoText",
    "label": "Tempo Text",
    "options": [
     {
      "value": "Larghissimo",
      "label": "Larghissimo"
     },
     {
      "value": "Grave",
      "label": "Grave"
     },
     {
      "value": "Lento",
      "label": "Lento"
     },
     {
      "value": "Largo",
      "label": "Largo"
     },
     {
      "value": "Larghetto",
      "label": "Larghetto"
     },
     {
      "value": "Adagio",
      "label": "Adagio"
     },
     {
      "value": "Adagietto",
      "label": "Adagietto"
     },
     {
      "value": "Andante moderato",
      "label": "Andante moderato"
     },
     {
      "value": "Andante",
      "label": "Andante"
     },
     {
      "value": "Andantino",
      "label": "Andantino"
     },
     {
      "value": "Moderato",
      "label": "Moderato"
     },
     {
      "value": "Allegretto",
      "label": "Allegretto"
     },
     {
      "value": "Allegro",
      "label": "Allegro"
     },
     {
      "value": "Vivace",
      "label": "Vivace"
     },
     {
      "value": "Presto",
      "label": "Presto"
     },
     {
      "value": "Prestissimo",
      "label": "Prestissimo"
     }
    ]
   }
  ]
 },
 {
  "ctor": "SuiInstrumentDialog",
  "dialogElements": [
   {
    "staticText": [
     {
      "label": "Instrument Properties"
     }
    ]
   },
   {
    "id": "applyTo",
    "label": "Apply To",
    "options": [
     {
      "value": "0",
      "label": "Score"
     },
     {
      "value": "1",
      "label": "Selected Measures"
     },
     {
      "value": "3",
      "label": "Remaining Measures"
     }
    ]
   }
  ]
 },
 {
  "ctor": "SuiTimeSignatureDialog",
  "dialogElements": [
   {
    "staticText": [
     {
      "label": "Custom Time Signature"
     }
    ]
   },
   {
    "id": "denominator",
    "label": "Beat Value",
    "options": [
     {
      "value": "8",
      "label": "8"
     },
     {
      "value": "4",
      "label": "4"
     },
     {
      "value": "2",
      "label": "2"
     }
    ]
   }
  ]
 },
 {
  "ctor": "SuiLayoutDialog",
  "dialogElements": [
   {
    "id": "pageSize",
    "label": "Seitengre",
    "options": [
     {
      "value": "letter",
      "label": "Brief"
     },
     {
      "value": "tabloid",
      "label": "Tabloid (11x17)"
     },
     {
      "value": "A4",
      "label": "A4"
     },
     {
      "value": "custom",
      "label": "benutzerdefiniert"
     }
    ]
   },
   {
    "id": "orientation",
    "label": "Ausrichtung",
    "options": [
     {
      "value": "0",
      "label": "Portrait"
     },
     {
      "value": "1",
      "label": "Landscape"
     }
    ]
   },
   {
    "id": "engravingFont",
    "label": "Schriftart",
    "options": [
     {
      "value": "Bravura",
      "label": "Bravura"
     },
     {
      "value": "Gonville",
      "label": "Gonville"
     },
     {
      "value": "Petaluma",
      "label": "Petaluma"
     }
    ]
   },
   {
    "staticText": [
     {
      "label": "Score Layout"
     }
    ]
   }
  ]
 },
 {
  "ctor": "SuiDynamicModifierDialog",
  "dialogElements": [
   {
    "id": "text",
    "label": "Text",
    "options": [
     {
      "value": "p",
      "label": "Piano"
     },
     {
      "value": "pp",
      "label": "Pianissimo"
     },
     {
      "value": "mp",
      "label": "Mezzo-Piano"
     },
     {
      "value": "mf",
      "label": "Mezzo-Forte"
     },
     {
      "value": "f",
      "label": "Forte"
     },
     {
      "value": "ff",
      "label": "Fortissimo"
     },
     {
      "value": "sfz",
      "label": "Sforzando"
     }
    ]
   },
   {
    "staticText": [
     {
      "label": "Dynamics Properties"
     }
    ]
   }
  ]
 },
 {
  "ctor": "SuiSlurAttributesDialog",
  "dialogElements": [
   {
    "staticText": [
     {
      "label": "Slur Properties"
     }
    ]
   },
   {
    "id": "position",
    "label": "Startposition",
    "options": [
     {
      "value": "1",
      "label": "Head"
     },
     {
      "value": "2",
      "label": "Top"
     }
    ]
   },
   {
    "id": "position_end",
    "label": "Endposition",
    "options": [
     {
      "value": "1",
      "label": "Head"
     },
     {
      "value": "2",
      "label": "Top"
     }
    ]
   }
  ]
 },
 {
  "ctor": "SuiVoltaAttributeDialog",
  "dialogElements": [
   {
    "staticText": [
     {
      "label": "Volta Properties"
     }
    ]
   }
  ]
 },
 {
  "ctor": "SuiHairpinAttributesDialog",
  "dialogElements": [
   {
    "staticText": [
     {
      "label": "Hairpin Properties"
     }
    ]
   }
  ]
 },
 {
  "ctor": "SuiLyricDialog",
  "dialogElements": [
   {
    "id": "verse",
    "label": "Verse",
    "options": [
     {
      "value": "0",
      "label": "1"
     },
     {
      "value": "1",
      "label": "2"
     },
     {
      "value": "2",
      "label": "3"
     }
    ]
   },
   {
    "id": "textEditor",
    "label": "Edit Text",
    "options": []
   },
   {
    "staticText": [
     {
      "doneEditing": "Done Editing Lyrics"
     },
     {
      "undo": "Undo Lyrics"
     },
     {
      "label": "Lyric Editor"
     }
    ]
   }
  ]
 },
 {
  "ctor": "SuiChordChangeDialog",
  "dialogElements": [
   {
    "id": "verse",
    "label": "Verse",
    "options": [
     {
      "value": "0",
      "label": "1"
     },
     {
      "value": "1",
      "label": "2"
     },
     {
      "value": "2",
      "label": "3"
     }
    ]
   },
   {
    "id": "textEditor",
    "label": "Edit Text",
    "options": []
   },
   {
    "staticText": [
     {
      "doneEditing": "Done Editing Lyrics"
     },
     {
      "undo": "Undo Lyrics"
     },
     {
      "label": "Lyric Editor"
     }
    ]
   }
  ]
 },
 {
  "ctor": "SuiTextTransformDialog",
  "dialogElements": [
   {
    "id": "textEditor",
    "label": "Edit Text",
    "options": []
   },
   {
    "id": "textDragger",
    "label": "Move Text",
    "options": []
   },
   {
    "id": "textResizer",
    "label": "Resize Text",
    "options": []
   },
   {
    "id": "justification",
    "label": "Justification",
    "options": [
     {
      "value": "left",
      "label": "Left"
     },
     {
      "value": "right",
      "label": "Right"
     },
     {
      "value": "center",
      "label": "Center"
     }
    ]
   },
   {
    "id": "fontFamily",
    "label": "Font Family",
    "options": [
     {
      "value": "Merriweather,serif",
      "label": "Serif"
     },
     {
      "value": "Roboto,sans-serif",
      "label": "Sans-Serif"
     },
     {
      "value": "monospace",
      "label": "Monospace"
     },
     {
      "value": "cursive",
      "label": "Cursive"
     },
     {
      "value": "Merriweather",
      "label": "times"
     },
     {
      "value": "Arial",
      "label": "arial"
     },
     {
      "value": "Helvetica",
      "label": "Helvetica"
     }
    ]
   },
   {
    "id": "fontUnit",
    "label": "Units",
    "options": [
     {
      "value": "em",
      "label": "em"
     },
     {
      "value": "px",
      "label": "px"
     },
     {
      "value": "pt",
      "label": "pt"
     }
    ]
   },
   {
    "id": "pagination",
    "label": "Page Behavior",
    "options": [
     {
      "value": "once",
      "label": "Once"
     },
     {
      "value": "every",
      "label": "Every"
     },
     {
      "value": "even",
      "label": "Even"
     },
     {
      "value": "odd",
      "label": "Odd"
     },
     {
      "value": "subsequent",
      "label": "Subsequent"
     }
    ]
   },
   {
    "staticText": [
     {
      "label": "Text Properties"
     }
    ]
   }
  ]
 },
 {
  "ctor": "SuiAddStaffMenu",
  "label": "Notenschlssel",
  "menuItems": [
   {
    "value": "trebleInstrument",
    "text": "Violinschlssel"
   },
   {
    "value": "bassInstrument",
    "text": "Basschlssel"
   },
   {
    "value": "altoInstrument",
    "text": "Altschlssel"
   },
   {
    "value": "tenorInstrument",
    "text": "Tenorschlssel"
   },
   {
    "value": "remove",
    "text": "Notenschlssel entfernen"
   },
   {
    "value": "cancel",
    "text": "Abbrechen"
   }
  ]
 },
 {
  "ctor": "SuiMeasureMenu",
  "label": "Measure",
  "menuItems": [
   {
    "value": "addMenuBeforeCmd",
    "text": "Add Measure Before"
   },
   {
    "value": "addMenuAfterCmd",
    "text": "Add Measure After"
   },
   {
    "value": "deleteSelected",
    "text": "Delete Selected Measures"
   },
   {
    "value": "formatMeasureDialog",
    "text": "Format Measure"
   },
   {
    "value": "cancel",
    "text": "Cancel"
   }
  ]
 },
 {
  "ctor": "SuiFileMenu",
  "label": "Datei",
  "menuItems": [
   {
    "value": "newFile",
    "text": "Neu"
   },
   {
    "value": "openFile",
    "text": "ffnen"
   },
   {
    "value": "saveFile",
    "text": "Speichern"
   },
   {
    "value": "quickSave",
    "text": "Schnellspeichern"
   },
   {
    "value": "printScore",
    "text": "Drucken"
   },
   {
    "value": "bach",
    "text": "Bach Invention"
   },
   {
    "value": "bambino",
    "text": "Jesu Bambino"
   },
   {
    "value": "microtone",
    "text": "Microtone Sample"
   },
   {
    "value": "preciousLord",
    "text": "Precious Lord"
   },
   {
    "value": "yamaJson",
    "text": "Yama"
   },
   {
    "value": "cancel",
    "text": "Abbrechen"
   }
  ]
 },
 {
  "ctor": "SuiTimeSignatureMenu",
  "label": "Taktzeit",
  "menuItems": [
   {
    "value": "6/8",
    "text": "6/8"
   },
   {
    "value": "3/4",
    "text": "3/4"
   },
   {
    "value": "2/4",
    "text": "2/4"
   },
   {
    "value": "12/8",
    "text": "12/8"
   },
   {
    "value": "7/8",
    "text": "7/8"
   },
   {
    "value": "5/8",
    "text": "5/8"
   },
   {
    "value": "TimeSigOther",
    "text": "benutzerdefiniert"
   },
   {
    "value": "cancel",
    "text": "Abbrechen"
   }
  ]
 },
 {
  "ctor": "SuiKeySignatureMenu",
  "label": "Tonlage",
  "menuItems": [
   {
    "value": "KeyOfC",
    "text": "C Major"
   },
   {
    "value": "KeyOfF",
    "text": "F Major"
   },
   {
    "value": "KeyOfG",
    "text": "G Major"
   },
   {
    "value": "KeyOfBb",
    "text": "Bb Major"
   },
   {
    "value": "KeyOfD",
    "text": "D Major"
   },
   {
    "value": "KeyOfEb",
    "text": "Eb Major"
   },
   {
    "value": "KeyOfA",
    "text": "A Major"
   },
   {
    "value": "KeyOfAb",
    "text": "Ab Major"
   },
   {
    "value": "KeyOfE",
    "text": "E Major"
   },
   {
    "value": "KeyOfDb",
    "text": "Db Major"
   },
   {
    "value": "KeyOfB",
    "text": "B Major"
   },
   {
    "value": "KeyOfF#",
    "text": "F# Major"
   },
   {
    "value": "KeyOfC#",
    "text": "C# Major"
   },
   {
    "value": "cancel",
    "text": "Abbrechen"
   }
  ]
 },
 {
  "ctor": "SuiTimeSignatureMenu",
  "label": "Taktzeit",
  "menuItems": [
   {
    "value": "6/8",
    "text": "6/8"
   },
   {
    "value": "3/4",
    "text": "3/4"
   },
   {
    "value": "2/4",
    "text": "2/4"
   },
   {
    "value": "12/8",
    "text": "12/8"
   },
   {
    "value": "7/8",
    "text": "7/8"
   },
   {
    "value": "5/8",
    "text": "5/8"
   },
   {
    "value": "TimeSigOther",
    "text": "benutzerdefiniert"
   },
   {
    "value": "cancel",
    "text": "Abbrechen"
   }
  ]
 },
 {
  "ctor": "SuiKeySignatureMenu",
  "label": "Tonlage",
  "menuItems": [
   {
    "value": "KeyOfC",
    "text": "C Major"
   },
   {
    "value": "KeyOfF",
    "text": "F Major"
   },
   {
    "value": "KeyOfG",
    "text": "G Major"
   },
   {
    "value": "KeyOfBb",
    "text": "Bb Major"
   },
   {
    "value": "KeyOfD",
    "text": "D Major"
   },
   {
    "value": "KeyOfEb",
    "text": "Eb Major"
   },
   {
    "value": "KeyOfA",
    "text": "A Major"
   },
   {
    "value": "KeyOfAb",
    "text": "Ab Major"
   },
   {
    "value": "KeyOfE",
    "text": "E Major"
   },
   {
    "value": "KeyOfDb",
    "text": "Db Major"
   },
   {
    "value": "KeyOfB",
    "text": "B Major"
   },
   {
    "value": "KeyOfF#",
    "text": "F# Major"
   },
   {
    "value": "KeyOfC#",
    "text": "C# Major"
   },
   {
    "value": "cancel",
    "text": "Abbrechen"
   }
  ]
 },
 {
  "ctor": "SuiStaffModifierMenu",
  "label": "Lines",
  "menuItems": [
   {
    "value": "crescendo",
    "text": "Crescendo"
   },
   {
    "value": "decrescendo",
    "text": "Decrescendo"
   },
   {
    "value": "slur",
    "text": "Bogen/Bindung"
   },
   {
    "value": "ending",
    "text": "nth Ende"
   },
   {
    "value": "cancel",
    "text": "Abbrechen"
   }
  ]
 },
 {
  "ctor": "SuiDynamicsMenu",
  "label": "Dynamics",
  "menuItems": [
   {
    "value": "pp",
    "text": "Pianissimo"
   },
   {
    "value": "p",
    "text": "Piano"
   },
   {
    "value": "mp",
    "text": "Mezzo-piano"
   },
   {
    "value": "mf",
    "text": "Mezzo-forte"
   },
   {
    "value": "f",
    "text": "Forte"
   },
   {
    "value": "ff",
    "text": "Fortissimo"
   },
   {
    "value": "sfz",
    "text": "sfortzando"
   },
   {
    "value": "cancel",
    "text": "Abbrechen"
   }
  ]
 },
 {
  "ctor": "SuiLanguageMenu",
  "label": "Language",
  "menuItems": [
   {
    "value": "en",
    "text": "English"
   },
   {
    "value": "de",
    "text": "Deutsch"
   },
   {
    "value": "ar",
    "text": ""
   },
   {
    "value": "cancel",
    "text": "Cancel"
   }
  ]
 },
 {
  "ribbonText": [
   {
    "buttonId": "helpDialog",
    "buttonText": "(de)Help"
   },
   {
    "buttonId": "languageMenu",
    "buttonText": "Language"
   },
   {
    "buttonId": "fileMenu",
    "buttonText": "File"
   },
   {
    "buttonId": "addStaffMenu",
    "buttonText": "Staves"
   },
   {
    "buttonId": "measureModal",
    "buttonText": "Measure"
   },
   {
    "buttonId": "tempoModal",
    "buttonText": "Tempo"
   },
   {
    "buttonId": "timeSignatureMenu",
    "buttonText": "Time Signature"
   },
   {
    "buttonId": "keyMenu",
    "buttonText": "Key"
   },
   {
    "buttonId": "staffModifierMenu",
    "buttonText": "Lines"
   },
   {
    "buttonId": "instrumentModal",
    "buttonText": "Instrument"
   },
   {
    "buttonId": "pianoModal",
    "buttonText": "Piano"
   },
   {
    "buttonId": "layoutModal",
    "buttonText": "Layout"
   },
   {
    "buttonId": "UpOctaveButton",
    "buttonText": "8va"
   },
   {
    "buttonId": "DownOctaveButton",
    "buttonText": "8vb"
   },
   {
    "buttonId": "moreNavButtons",
    "buttonText": "..."
   },
   {
    "buttonId": "dcAlCoda",
    "buttonText": "DC Al Coda"
   },
   {
    "buttonId": "dsAlCoda",
    "buttonText": "DS Al Coda"
   },
   {
    "buttonId": "dcAlFine",
    "buttonText": "DC Al Fine"
   },
   {
    "buttonId": "dsAlFine",
    "buttonText": "DS Al Fine"
   },
   {
    "buttonId": "toCoda",
    "buttonText": "to "
   },
   {
    "buttonId": "fine",
    "buttonText": "Fine"
   },
   {
    "buttonId": "moreStaffButtons",
    "buttonText": "..."
   }
  ]
 }
]`;
;
var smoLanguageStringEn = `[
 {
  "ctor": "SuiLoadFileDialog",
  "dialogElements": [
   {
    "staticText": [
     {
      "label": "Load File"
     }
    ]
   }
  ]
 },
 {
  "ctor": "SuiSaveFileDialog",
  "dialogElements": [
   {
    "staticText": [
     {
      "label": "Save Score"
     }
    ]
   }
  ]
 },
 {
  "ctor": "SuiPrintFileDialog",
  "dialogElements": [
   {
    "staticText": [
     {
      "label": "Print Complete"
     }
    ]
   }
  ]
 },
 {
  "ctor": "SuiMeasureDialog",
  "dialogElements": [
   {
    "staticText": [
     {
      "label": "Measure Properties"
     }
    ]
   },
   {
    "id": "pickupMeasure",
    "label": "Pickup Measure",
    "options": [
     {
      "value": "2048",
      "label": "Eighth Note"
     },
     {
      "value": "4096",
      "label": "Quarter Note"
     },
     {
      "value": "6144",
      "label": "Dotted Quarter"
     },
     {
      "value": "8192",
      "label": "Half Note"
     }
    ]
   },
   {
    "id": "measureTextPosition",
    "label": "Text Position",
    "options": [
     {
      "value": "2",
      "label": "Left"
     },
     {
      "value": "3",
      "label": "Right"
     },
     {
      "value": "0",
      "label": "Above"
     },
     {
      "value": "1",
      "label": "Below"
     }
    ]
   }
  ]
 },
 {
  "ctor": "SuiTempoDialog",
  "dialogElements": [
   {
    "staticText": [
     {
      "label": "Tempo Properties"
     }
    ]
   },
   {
    "id": "tempoMode",
    "label": "Tempo Mode",
    "options": [
     {
      "value": "duration",
      "label": "Duration (Beats/Minute)"
     },
     {
      "value": "text",
      "label": "Tempo Text"
     },
     {
      "value": "custom",
      "label": "Specify text and duration"
     }
    ]
   },
   {
    "id": "beatDuration",
    "label": "Unit for Beat",
    "options": [
     {
      "value": "4096",
      "label": "Quarter Note"
     },
     {
      "value": "2048",
      "label": "1/8 note"
     },
     {
      "value": "6144",
      "label": "Dotted 1/4 note"
     },
     {
      "value": "8192",
      "label": "1/2 note"
     }
    ]
   },
   {
    "id": "tempoText",
    "label": "Tempo Text",
    "options": [
     {
      "value": "Larghissimo",
      "label": "Larghissimo"
     },
     {
      "value": "Grave",
      "label": "Grave"
     },
     {
      "value": "Lento",
      "label": "Lento"
     },
     {
      "value": "Largo",
      "label": "Largo"
     },
     {
      "value": "Larghetto",
      "label": "Larghetto"
     },
     {
      "value": "Adagio",
      "label": "Adagio"
     },
     {
      "value": "Adagietto",
      "label": "Adagietto"
     },
     {
      "value": "Andante moderato",
      "label": "Andante moderato"
     },
     {
      "value": "Andante",
      "label": "Andante"
     },
     {
      "value": "Andantino",
      "label": "Andantino"
     },
     {
      "value": "Moderato",
      "label": "Moderato"
     },
     {
      "value": "Allegretto",
      "label": "Allegretto"
     },
     {
      "value": "Allegro",
      "label": "Allegro"
     },
     {
      "value": "Vivace",
      "label": "Vivace"
     },
     {
      "value": "Presto",
      "label": "Presto"
     },
     {
      "value": "Prestissimo",
      "label": "Prestissimo"
     }
    ]
   }
  ]
 },
 {
  "ctor": "SuiInstrumentDialog",
  "dialogElements": [
   {
    "staticText": [
     {
      "label": "Instrument Properties"
     }
    ]
   },
   {
    "id": "applyTo",
    "label": "Apply To",
    "options": [
     {
      "value": "0",
      "label": "Score"
     },
     {
      "value": "1",
      "label": "Selected Measures"
     },
     {
      "value": "3",
      "label": "Remaining Measures"
     }
    ]
   }
  ]
 },
 {
  "ctor": "SuiTimeSignatureDialog",
  "dialogElements": [
   {
    "staticText": [
     {
      "label": "Custom Time Signature"
     }
    ]
   },
   {
    "id": "denominator",
    "label": "Beat Value",
    "options": [
     {
      "value": "8",
      "label": "8"
     },
     {
      "value": "4",
      "label": "4"
     },
     {
      "value": "2",
      "label": "2"
     }
    ]
   }
  ]
 },
 {
  "ctor": "SuiLayoutDialog",
  "dialogElements": [
   {
    "id": "pageSize",
    "label": "Page Size",
    "options": [
     {
      "value": "letter",
      "label": "Letter"
     },
     {
      "value": "tabloid",
      "label": "Tabloid (11x17)"
     },
     {
      "value": "A4",
      "label": "A4"
     },
     {
      "value": "custom",
      "label": "Custom"
     }
    ]
   },
   {
    "id": "orientation",
    "label": "Orientation",
    "options": [
     {
      "value": "0",
      "label": "Portrait"
     },
     {
      "value": "1",
      "label": "Landscape"
     }
    ]
   },
   {
    "id": "engravingFont",
    "label": "Engraving Font",
    "options": [
     {
      "value": "Bravura",
      "label": "Bravura"
     },
     {
      "value": "Gonville",
      "label": "Gonville"
     },
     {
      "value": "Petaluma",
      "label": "Petaluma"
     }
    ]
   },
   {
    "staticText": [
     {
      "label": "Score Layout"
     }
    ]
   }
  ]
 },
 {
  "ctor": "SuiDynamicModifierDialog",
  "dialogElements": [
   {
    "id": "text",
    "label": "Text",
    "options": [
     {
      "value": "p",
      "label": "Piano"
     },
     {
      "value": "pp",
      "label": "Pianissimo"
     },
     {
      "value": "mp",
      "label": "Mezzo-Piano"
     },
     {
      "value": "mf",
      "label": "Mezzo-Forte"
     },
     {
      "value": "f",
      "label": "Forte"
     },
     {
      "value": "ff",
      "label": "Fortissimo"
     },
     {
      "value": "sfz",
      "label": "Sforzando"
     }
    ]
   },
   {
    "staticText": [
     {
      "label": "Dynamics Properties"
     }
    ]
   }
  ]
 },
 {
  "ctor": "SuiSlurAttributesDialog",
  "dialogElements": [
   {
    "staticText": [
     {
      "label": "Slur Properties"
     }
    ]
   },
   {
    "id": "position",
    "label": "Start Position",
    "options": [
     {
      "value": "1",
      "label": "Head"
     },
     {
      "value": "2",
      "label": "Top"
     }
    ]
   },
   {
    "id": "position_end",
    "label": "End Position",
    "options": [
     {
      "value": "1",
      "label": "Head"
     },
     {
      "value": "2",
      "label": "Top"
     }
    ]
   }
  ]
 },
 {
  "ctor": "SuiVoltaAttributeDialog",
  "dialogElements": [
   {
    "staticText": [
     {
      "label": "Volta Properties"
     }
    ]
   }
  ]
 },
 {
  "ctor": "SuiHairpinAttributesDialog",
  "dialogElements": [
   {
    "staticText": [
     {
      "label": "Hairpin Properties"
     }
    ]
   }
  ]
 },
 {
  "ctor": "SuiLyricDialog",
  "dialogElements": [
   {
    "id": "verse",
    "label": "Verse",
    "options": [
     {
      "value": "0",
      "label": "1"
     },
     {
      "value": "1",
      "label": "2"
     },
     {
      "value": "2",
      "label": "3"
     }
    ]
   },
   {
    "id": "textEditor",
    "label": "Edit Text",
    "options": []
   },
   {
    "staticText": [
     {
      "doneEditing": "Done Editing Lyrics"
     },
     {
      "undo": "Undo Lyrics"
     },
     {
      "label": "Lyric Editor"
     }
    ]
   }
  ]
 },
 {
  "ctor": "SuiChordChangeDialog",
  "dialogElements": [
   {
    "id": "verse",
    "label": "Verse",
    "options": [
     {
      "value": "0",
      "label": "1"
     },
     {
      "value": "1",
      "label": "2"
     },
     {
      "value": "2",
      "label": "3"
     }
    ]
   },
   {
    "id": "textEditor",
    "label": "Edit Text",
    "options": []
   },
   {
    "staticText": [
     {
      "doneEditing": "Done Editing Lyrics"
     },
     {
      "undo": "Undo Lyrics"
     },
     {
      "label": "Lyric Editor"
     }
    ]
   }
  ]
 },
 {
  "ctor": "SuiTextTransformDialog",
  "dialogElements": [
   {
    "id": "textEditor",
    "label": "Edit Text",
    "options": []
   },
   {
    "id": "textDragger",
    "label": "Move Text",
    "options": []
   },
   {
    "id": "textResizer",
    "label": "Resize Text",
    "options": []
   },
   {
    "id": "justification",
    "label": "Justification",
    "options": [
     {
      "value": "left",
      "label": "Left"
     },
     {
      "value": "right",
      "label": "Right"
     },
     {
      "value": "center",
      "label": "Center"
     }
    ]
   },
   {
    "id": "fontFamily",
    "label": "Font Family",
    "options": [
     {
      "value": "Merriweather,serif",
      "label": "Serif"
     },
     {
      "value": "Roboto,sans-serif",
      "label": "Sans-Serif"
     },
     {
      "value": "monospace",
      "label": "Monospace"
     },
     {
      "value": "cursive",
      "label": "Cursive"
     },
     {
      "value": "Merriweather",
      "label": "times"
     },
     {
      "value": "Arial",
      "label": "arial"
     },
     {
      "value": "Helvetica",
      "label": "Helvetica"
     }
    ]
   },
   {
    "id": "fontUnit",
    "label": "Units",
    "options": [
     {
      "value": "em",
      "label": "em"
     },
     {
      "value": "px",
      "label": "px"
     },
     {
      "value": "pt",
      "label": "pt"
     }
    ]
   },
   {
    "id": "pagination",
    "label": "Page Behavior",
    "options": [
     {
      "value": "once",
      "label": "Once"
     },
     {
      "value": "every",
      "label": "Every"
     },
     {
      "value": "even",
      "label": "Even"
     },
     {
      "value": "odd",
      "label": "Odd"
     },
     {
      "value": "subsequent",
      "label": "Subsequent"
     }
    ]
   },
   {
    "staticText": [
     {
      "label": "Text Properties"
     }
    ]
   }
  ]
 },
 {
  "ctor": "SuiAddStaffMenu",
  "label": "Staves",
  "menuItems": [
   {
    "value": "trebleInstrument",
    "text": "Treble Clef Staff"
   },
   {
    "value": "bassInstrument",
    "text": "Bass Clef Staff"
   },
   {
    "value": "altoInstrument",
    "text": "Alto Clef Staff"
   },
   {
    "value": "tenorInstrument",
    "text": "Tenor Clef Staff"
   },
   {
    "value": "remove",
    "text": "Remove Staff"
   },
   {
    "value": "cancel",
    "text": "Cancel"
   }
  ]
 },
 {
  "ctor": "SuiMeasureMenu",
  "label": "Measure",
  "menuItems": [
   {
    "value": "addMenuBeforeCmd",
    "text": "Add Measure Before"
   },
   {
    "value": "addMenuAfterCmd",
    "text": "Add Measure After"
   },
   {
    "value": "deleteSelected",
    "text": "Delete Selected Measures"
   },
   {
    "value": "formatMeasureDialog",
    "text": "Format Measure"
   },
   {
    "value": "cancel",
    "text": "Cancel"
   }
  ]
 },
 {
  "ctor": "SuiFileMenu",
  "label": "File",
  "menuItems": [
   {
    "value": "newFile",
    "text": "New Score"
   },
   {
    "value": "openFile",
    "text": "Open"
   },
   {
    "value": "saveFile",
    "text": "Save"
   },
   {
    "value": "quickSave",
    "text": "Quick Save"
   },
   {
    "value": "printScore",
    "text": "Print"
   },
   {
    "value": "bach",
    "text": "Bach Invention"
   },
   {
    "value": "bambino",
    "text": "Jesu Bambino"
   },
   {
    "value": "microtone",
    "text": "Microtone Sample"
   },
   {
    "value": "preciousLord",
    "text": "Precious Lord"
   },
   {
    "value": "yamaJson",
    "text": "Yama"
   },
   {
    "value": "cancel",
    "text": "Cancel"
   }
  ]
 },
 {
  "ctor": "SuiTimeSignatureMenu",
  "label": "Time Signature",
  "menuItems": [
   {
    "value": "6/8",
    "text": "6/8"
   },
   {
    "value": "3/4",
    "text": "3/4"
   },
   {
    "value": "2/4",
    "text": "2/4"
   },
   {
    "value": "12/8",
    "text": "12/8"
   },
   {
    "value": "7/8",
    "text": "7/8"
   },
   {
    "value": "5/8",
    "text": "5/8"
   },
   {
    "value": "TimeSigOther",
    "text": "Other"
   },
   {
    "value": "cancel",
    "text": "Cancel"
   }
  ]
 },
 {
  "ctor": "SuiKeySignatureMenu",
  "label": "Key",
  "menuItems": [
   {
    "value": "KeyOfC",
    "text": "C Major"
   },
   {
    "value": "KeyOfF",
    "text": "F Major"
   },
   {
    "value": "KeyOfG",
    "text": "G Major"
   },
   {
    "value": "KeyOfBb",
    "text": "Bb Major"
   },
   {
    "value": "KeyOfD",
    "text": "D Major"
   },
   {
    "value": "KeyOfEb",
    "text": "Eb Major"
   },
   {
    "value": "KeyOfA",
    "text": "A Major"
   },
   {
    "value": "KeyOfAb",
    "text": "Ab Major"
   },
   {
    "value": "KeyOfE",
    "text": "E Major"
   },
   {
    "value": "KeyOfDb",
    "text": "Db Major"
   },
   {
    "value": "KeyOfB",
    "text": "B Major"
   },
   {
    "value": "KeyOfF#",
    "text": "F# Major"
   },
   {
    "value": "KeyOfC#",
    "text": "C# Major"
   },
   {
    "value": "cancel",
    "text": "Cancel"
   }
  ]
 },
 {
  "ctor": "SuiTimeSignatureMenu",
  "label": "Time Signature",
  "menuItems": [
   {
    "value": "6/8",
    "text": "6/8"
   },
   {
    "value": "3/4",
    "text": "3/4"
   },
   {
    "value": "2/4",
    "text": "2/4"
   },
   {
    "value": "12/8",
    "text": "12/8"
   },
   {
    "value": "7/8",
    "text": "7/8"
   },
   {
    "value": "5/8",
    "text": "5/8"
   },
   {
    "value": "TimeSigOther",
    "text": "Other"
   },
   {
    "value": "cancel",
    "text": "Cancel"
   }
  ]
 },
 {
  "ctor": "SuiKeySignatureMenu",
  "label": "Key",
  "menuItems": [
   {
    "value": "KeyOfC",
    "text": "C Major"
   },
   {
    "value": "KeyOfF",
    "text": "F Major"
   },
   {
    "value": "KeyOfG",
    "text": "G Major"
   },
   {
    "value": "KeyOfBb",
    "text": "Bb Major"
   },
   {
    "value": "KeyOfD",
    "text": "D Major"
   },
   {
    "value": "KeyOfEb",
    "text": "Eb Major"
   },
   {
    "value": "KeyOfA",
    "text": "A Major"
   },
   {
    "value": "KeyOfAb",
    "text": "Ab Major"
   },
   {
    "value": "KeyOfE",
    "text": "E Major"
   },
   {
    "value": "KeyOfDb",
    "text": "Db Major"
   },
   {
    "value": "KeyOfB",
    "text": "B Major"
   },
   {
    "value": "KeyOfF#",
    "text": "F# Major"
   },
   {
    "value": "KeyOfC#",
    "text": "C# Major"
   },
   {
    "value": "cancel",
    "text": "Cancel"
   }
  ]
 },
 {
  "ctor": "SuiStaffModifierMenu",
  "label": "Lines",
  "menuItems": [
   {
    "value": "crescendo",
    "text": "Crescendo"
   },
   {
    "value": "decrescendo",
    "text": "Decrescendo"
   },
   {
    "value": "slur",
    "text": "Slur/Tie"
   },
   {
    "value": "ending",
    "text": "nth ending"
   },
   {
    "value": "cancel",
    "text": "Cancel"
   }
  ]
 },
 {
  "ctor": "SuiDynamicsMenu",
  "label": "Dynamics",
  "menuItems": [
   {
    "value": "pp",
    "text": "Pianissimo"
   },
   {
    "value": "p",
    "text": "Piano"
   },
   {
    "value": "mp",
    "text": "Mezzo-piano"
   },
   {
    "value": "mf",
    "text": "Mezzo-forte"
   },
   {
    "value": "f",
    "text": "Forte"
   },
   {
    "value": "ff",
    "text": "Fortissimo"
   },
   {
    "value": "sfz",
    "text": "sfortzando"
   },
   {
    "value": "cancel",
    "text": "Cancel"
   }
  ]
 },
 {
  "ctor": "SuiLanguageMenu",
  "label": "Language",
  "menuItems": [
   {
    "value": "en",
    "text": "English"
   },
   {
    "value": "de",
    "text": "Deutsch"
   },
   {
    "value": "ar",
    "text": ""
   },
   {
    "value": "cancel",
    "text": "Cancel"
   }
  ]
 },
 {
  "ribbonText": [
   {
    "buttonId": "helpDialog",
    "buttonText": "Help"
   },
   {
    "buttonId": "languageMenu",
    "buttonText": "Language"
   },
   {
    "buttonId": "fileMenu",
    "buttonText": "File"
   },
   {
    "buttonId": "addStaffMenu",
    "buttonText": "Staves"
   },
   {
    "buttonId": "measureModal",
    "buttonText": "Measure"
   },
   {
    "buttonId": "tempoModal",
    "buttonText": "Tempo"
   },
   {
    "buttonId": "timeSignatureMenu",
    "buttonText": "Time Signature"
   },
   {
    "buttonId": "keyMenu",
    "buttonText": "Key"
   },
   {
    "buttonId": "staffModifierMenu",
    "buttonText": "Lines"
   },
   {
    "buttonId": "instrumentModal",
    "buttonText": "Instrument"
   },
   {
    "buttonId": "pianoModal",
    "buttonText": "Piano"
   },
   {
    "buttonId": "layoutModal",
    "buttonText": "Layout"
   },
   {
    "buttonId": "UpOctaveButton",
    "buttonText": "8va"
   },
   {
    "buttonId": "DownOctaveButton",
    "buttonText": "8vb"
   },
   {
    "buttonId": "moreNavButtons",
    "buttonText": "..."
   },
   {
    "buttonId": "dcAlCoda",
    "buttonText": "DC Al Coda"
   },
   {
    "buttonId": "dsAlCoda",
    "buttonText": "DS Al Coda"
   },
   {
    "buttonId": "dcAlFine",
    "buttonText": "DC Al Fine"
   },
   {
    "buttonId": "dsAlFine",
    "buttonText": "DS Al Fine"
   },
   {
    "buttonId": "toCoda",
    "buttonText": "to "
   },
   {
    "buttonId": "fine",
    "buttonText": "Fine"
   },
   {
    "buttonId": "moreStaffButtons",
    "buttonText": "..."
   }
  ]
 }
]`;

var quickStartHtmlen = `
    <h3 id="quick-start-guide">Quick start guide</h3>
<p>If you don&#39;t like to read instructions, this cook&#39;s tour of Smoosic was made for you.</p>
<ul>
<li><p>One of buttons on the left is called &#39;File&#39;.  Click on it. The menu items before &#39;cancel&#39; are pre-canned projects that you can use as a template to get you started.</p>
</li>
<li><p>The cursor keys will navigate you to the different notes.</p>
</li>
<li><p>Letters a-g on the computer keyboard change the note to those pitches</p>
</li>
<li><p>&#39;Insert&#39; adds a new, blank measure.</p>
</li>
<li><p>The ribbon of thick blue buttons on the top expand to button groups, that contain most of the functionality of Smoosic.  </p>
</li>
<li><p>The buttons on the left bring up menus or dialogs that do basically what the buttons say.</p>
</li>
<li><p>There are a few &#39;instant gratification&#39; buttons for playing the music, refreshing the screen or changing the zoom level on the left part of the ribbon.</p>
</li>
<li><p>The piano tool is an alternate way of entering music, or can be dismissed by the close button in the lower left.</p>
</li>
</ul>
<p><img src="https://imgur.com/nP16PMI.gif" alt="" width="640" height="480"></p>
`;


var selectionHtmlen = `
<h3 id="selecting-things">Selecting things</h3>
<p>Almost all operations in Smoosic act on the selected music.  You can select notes in different ways:</p>
<ol>
<li>with the computer mouse</li>
<li>with the keyboard&#39;s navigation keys</li>
<li>with the navigation keys on the ribbon</li>
<li>with the piano tool, to some extent.</li>
</ol>
<p><img src="https://imgur.com/q1qK3Pn.gif" alt=""></p>
<p>You can select multiple things with the keyboard navigation keys, by selecting &#39;shift-arrow&#39;, just like many applications.  There is a similar control for selection in the navigation ribbon.  Some operations, like changing pitch for instance, act on all the selected notes.</p>
<p>Sometimes a selection of one line affects all the measures in that column (or all the measures of the system, if you like).  When you change the key, for instance, the selection determines where the key change starts.  If you have multiple measures selected, it applies to those measures, and then changes back to whatever it was before.</p>
`;


var enterDurationsHtmlen = `
<p>Note duration in Smoosic is done by changing the duration of an existing note.  Usually, doubling the duration or cutting it in two, or adding a dot - duration to a note.  You can also create tuplets for uneven sets of notes (3, 5, or 7).</p>
<p>There are actually 3 ways to do many duration operations - using the piano tool, using the computer keyboard, or using the button ribbon.  Like with many things, you should find entering duration using the keyboard fastest, once you have some experience with Smoosic.  But the ribbon or the </p>
<h2 id="changing-note-length-with-the-keyboard">Changing note length with the keyboard</h2>
<p>You can change the length of notes using the &#39;,&#39; and &#39;.&#39; (comma and period) keys, which halve and double the note lengths, respectively.  You can add a dot to the length of the note (multiplying length by 3/2 for the first dot, and 3/4 for the second dot, if you like to think of it that way) or remove a dot, using the &#39;&gt;&#39; and &#39;&lt;&#39;.  The mnemonic device for these is &#39;&gt;&#39; makes note duration greater.  &#39;&lt;&#39; makes note duration...less.  (On most QWERTY keyboards, comma shifted is &#39;&lt;&#39; and period shifted is &#39;&gt;&#39;).</p>
<p><img src="https://imgur.com/5ZWq2Xe.gif" alt=""></p>
<p>Note how the selection is preserved as the notes get shorter.  When you change something, Smoosic will try to keep the selection as close as possible to what you had.  You can use the cursor navigation keys to move to a specific selected note.</p>
<p><img src="https://imgur.com/woMw4RH.gif" alt=""></p>
<p>When you increase the length of a note, Smoosic always &#39;borrows&#39; from the next note in the measure that is eligible.  So when you double the length of the 8th note, it combines the 16th, and 2 32nd notes, and collapses them into a single quarter.  If Smoosic can&#39;t honor the request, it does nothing.  For instance, it can&#39;t remove the dot from a note with no dot, and it can&#39;t extend beyond the length of the measure.</p>
<p>You can create tuplets from the keyboard by typing Ctrl-3, Ctrl-5 or Ctrl-7 for triplets, quintuplets, and septuplets, respectively.  Individual notes in a tuplet can be doubled and halved with the duration keys &#39;-&#39; (minus) and &#39;=&#39; (equals), just like non-tuplets.  You &#39;untupletify&#39; a tuplet by Ctrl-0.</p>
<p><img src="https://imgur.com/uBpQwXD.gif" alt=""></p>
<h2 id="changing-note-length-with-piano-widget">Changing note length with piano widget</h2>
<p>The piano widget is shown when the application starts, and can be restored from the left menu &#39;Piano&#39; button when closed.</p>
<p>You can double or halve note duration, or add dot duration, to a note using the piano tool. </p>
<p><img src="https://imgur.com/Rw4yDxP.gif" alt=""></p>
<h2 id="changing-note-length-from-the-button-ribbon">Changing note length from the button ribbon</h2>
<p>All the duration commands can be accomplished from the ribbon buttons.  </p>
<p><img src="https://imgur.com/n9bmamg.gif" alt=""></p>
<p>Note that the equivalent keyboard commands are also indicated on the right of each button, when it&#39;s available.  (there are only so many keys, so there are some ribbon buttons with no key shortcut). </p>
`;


var enterPitchesHtmlen = `
<p>There are a few ways to enter notes in Smoosic.  You can click on the piano widget keys, or you can enter notes directly from the keyboard.</p>
<h2 id="your-first-smoosical-notes">Your first Smoosical notes</h2>
<h3 id="notes-from-the-keyboard">Notes from the keyboard</h3>
<p>The keys a-g on the computer keyboard will enter a corresponding note, A-G, on the staff (Most key commands in Smoosic have a mnemonic device).  The default behavior is for the cursor to advance when a note is entered in this way.  (Future behavior, auto-advance can be overridden). You navigate to the notes using the keyboard navigation arrows.</p>
<p><img src="https://imgur.com/lxR0NI7.gif" alt=""></p>
<p>You change the octave from the keyboard using the &#39;_&#39; and &#39;+&#39; (underscore, aka shift-minus, and plus), and change notes chromatically using &#39;-&#39; and &#39;=&#39; key.  The mnemonic device for this is &#39;plus and minus&#39; for raising and lowering pitches.  You can change the enharmonic spelling of the note using the &#39;Shift-E&#39; (mnemonic: E for enharmonic - get it?).  And Shift-F gives you a courtesy, or cautionary, accidental (mnemonic - F comes after E).</p>
<p><img src="https://imgur.com/1tC94sV.gif" alt=""></p>
<p>You can create chords and intervals using the number keys along the top of the keyboard.  The &#39;3&#39; key makes a third, the &#39;4&#39; key a fourth, and so on.  Shift+number gives you the interval down.</p>
<p><img src="https://imgur.com/IwoeWi3.gif" alt=""></p>
<p>Note that the interval starts from the highest note in the chord, for intervals going up, and the lowest note in the chord, for intervals going down.  You can select individual pitches in the chord using &#39;Shift-Up Arrow&#39; as shown.  This is similar to how modifiers like dynamics are selected.  Once you have the pitch selected, you can change it using the up-down commands shows above, or change the enharmonic spelling.</p>
<p>There is currently no way to remove a single pitch from the chord.  If you want to collapse the chord, just type a letter a-g on the keyboard, and it will be replaced with a single note.</p>
<h3 id="notes-from-the-piano-tool">Notes from the piano tool</h3>
<p>You can also add notes to your score with the piano tool, by clicking on the corresponding notes.</p>
<p><img src="https://imgur.com/MOMlIg3.gif" alt=""></p>
<p>Clicking on the piano gives the selected note the piano pitch.  The octave of the note is based on the clef, so for treble clef, the &#39;C&#39; is middle &#39;C&#39;.  You can change the octave of the note, and move the pitch up and down.  The top buttons affect the pitch, and the bottom buttons navigate or change the length of the note.  Clicking on the chord button acts like a &#39;sustain&#39; that puts additional notes in chords.</p>
<p>Everything that can be done from the piano widget, and most things in Smoosic generally, can be done more efficiently with keyboard commands. Once you are comfortable with the computer keyboard, you can free up some screen real-estate by closing the piano widget (cross control in lower left).  You can bring it up again with the piano menu button on the left.</p>
`;

var workingWithTexten = `
<h2 id="text-modes-in-smoosic">Text Modes in Smoosic</h2>
<p>Working with text in Smoosic is slightly different experience than editing music notation.  While you are entering, moving. or resizing the text, normal navigation with the cursor keys and music entry is suspended, and only the text you are working with is fully visible.  There is a dialog box with a few limited options, such as exiting text-entry mode.  This is true of text block, lyrics, and chords.  Once you finish entering the text, you get a different dialog box similar to the one you can use to edit modifiers such as slurs, crescendos, etc.</p>
<p><img src="https://imgur.com/EKDIUi5.png" alt=""></p>
<h2 id="text-blocks">Text Blocks</h2>
<p>Text blocks, also called &#39;Score text&#39; because it is not tied to a musical element, is free-form text that can be placed anywhere.  It can be used for titles, credits, etc.  It can also be set up for pagination using escape sequences. <strong>**</strong>  Unicode characters are also allowed.</p>
<p>You create a text block by selecting the big &#39;T&#39; on the text ribbon, with the cursor symbol (diagram).  You enter the text as you like it (only a single line is supported right now, if you want multiple lines you have to stack them).  </p>
<p><img src="https://imgur.com/kSMHoDl.png" alt=""></p>
<h2 id="lyrics">Lyrics</h2>
<p>Lyrics are entered by clicking on the lyrics button (do-re-mi).  Lyrics are entered per note.  When you hit space bar or - sign, the focus is advanced to the next note/lyric.  A &#39;-&#39; sign by itself in a lyric gives you a horizontal line.  When you want to leave lyric editing mode, just like other text entry modes, click on the &#39;Done editing&#39; button on the dialog. Note that the dialog can be moved around if it interferes with the music you are trying to edit.  (This is true of all dialog boxes in Smoosic.)  The final dialog box allows you to switch to a different verse.</p>
<p><img src="https://imgur.com/FfKOUUQ.png" alt=""></p>
<h2 id="chord-changes">Chord changes</h2>
<p>Chord changes button is in the same ribbon group as lyrics, and the editing experience is pretty similar.  There are some magic key strokes:</p>
<ul>
<li>^ (shift-6) starts or ends superscript mode</li>
<li>%  (shift-5) starts or ends subscript mode</li>
<li>If you immediately follow subscript mode by superscript mode, the scripts are &#39;stacked&#39;.</li>
<li>b, #, + , (, ) , &#39;/&#39; result in their respective symbols.</li>
</ul>
<p>Right now chord symbol entry is not too WYSIWYG - the actual chord rendering is done when the editing mode is done, which is a bit annoying.  I will be improving this as time goes on.</p>
<p><img src="https://imgur.com/a2ldLDX" alt=""></p>`;
;
class SmoTranslator {
  static get dialogs() {
    SmoTranslator._dialogs =  SmoTranslator._dialogs ? SmoTranslator._dialogs : {};
    return SmoTranslator._dialogs;
  }

  static get menus() {
    SmoTranslator._menus =  SmoTranslator._menus ? SmoTranslator._menus : {};
    return SmoTranslator._menus;
  }

  static registerMenu(_class) {
    if (!SmoTranslator.menus[_class]) {
      SmoTranslator.menus[_class] = true;
    }
  }


  static registerDialog(_class) {
    if (!SmoTranslator.dialogs[_class]) {
      SmoTranslator.dialogs[_class] = true;
    }
  }

  static printLanguages() {
    var translatables = [];
    SmoTranslator.allDialogs.forEach((key) => {
      SmoTranslator.registerDialog(key);
      translatables.push(SuiDialogBase.printTranslate(key));
    });
    SmoTranslator.allMenus.forEach((key) => {
      SmoTranslator.registerMenu(key);
      translatables.push(suiMenuBase.printTranslate(key));
    });

    console.log(JSON.stringify(translatables,null,' '));
  }

  static _updateDialog(dialogStrings,_dialogClass,dialogClass) {
    if (!dialogStrings) {
      console.log('no strings for Dialog '+dialogClass);
      return;
    }
    _dialogClass['label'] = dialogStrings.label;
    var staticText = dialogStrings.dialogElements.find((ds) => ds.staticText);
    _dialogClass['dialogElements'].forEach((component) => {
      var componentStrings = dialogStrings.dialogElements.find((ds) => {
        return ds.id === component.smoName;
      });
      if (component.staticText && staticText) {
        component.staticText.forEach((st) => {
          const trans = staticText.staticText.find((dst) => Object.keys(dst)[0] == Object.keys(st)[0]);
          if (trans) {
            const key = Object.keys(st)[0];
            st[key] = trans[key];
          }
        });
      }  else if (componentStrings) {
        component.label = componentStrings.label;
        if (component['options']) {
          component['options'].forEach((option) => {
            var optionString = componentStrings.options.find((cs) => cs.value === option.value);
            if (!optionString) {
              console.log('no string for option '+ option.value+' in component '+component.smoName+' in dialog ' + dialogClass);
            } else {
              option.label = optionString.label;
            }
          });
        }
      } else {
        console.log('Untranslated component in  ' + dialogClass);
      }
    });
  }

  static _updateMenu(menuStrings,_menuClass,menuClass) {
    if (!menuStrings) {
      console.log('no strings for Menu '+menuClass);
      return;
    }

    _menuClass['defaults'].menuItems.forEach((menuItem) => {
      var val = menuItem.value;
      var nvPair = menuStrings.menuItems.find((ff) => ff.value === val);
      if (!nvPair) {
        console.log('no xlate for '+ val+' in menu '+menuClass);
      } else {
        menuItem.text = nvPair.text;
        console.log('setting menu item value '+val+' to '+nvPair.text);
      }
    });
  }

  static setLanguage(language) {
    if (!SmoLanguage[language]) {
      return; // no xlate exists
    }
    var trans = SmoLanguage[language];
    // Set the text in all the menus
    SmoTranslator.allMenus.forEach((menuClass) => {
      var _class = eval(menuClass);
      var menuStrings = trans.strings.find((mm) => {
        return mm.ctor == menuClass;
      });
      SmoTranslator._updateMenu(menuStrings,_class,menuClass);

      // Set text in ribbon buttons that invoke menus
      var menuButton = $('.ribbonButtonContainer button.'+menuClass).find('.left-text .text-span');
      if (menuButton.length && menuStrings) {
        $(menuButton).text(menuStrings.label);
      }
    });

    SmoTranslator.allDialogs.forEach((dialogClass) => {
      var _class = eval(dialogClass);
      var dialogStrings = trans.strings.find((mm) => {
        return mm.ctor == dialogClass;
      });
      // Set text in ribbon buttons that invoke menus
      var dialogButton = $('.ribbonButtonContainer button.'+dialogClass).find('.left-text .text-span');
      if (dialogButton.length && dialogStrings) {
        $(dialogButton).text(dialogStrings.label);
      }

      SmoTranslator._updateDialog(dialogStrings,_class,dialogClass);
    });

    // Translate the buttons on the ribbon
    const langButtons = trans.strings.find((buttonObj) => buttonObj.ribbonText);
    if (langButtons) {
      RibbonButtons.translateButtons.forEach((button) => {
        var domButton = $(button);
        var langButton = langButtons.ribbonText.find((lb) => lb.buttonId === button.buttonId);
        if (langButton) {
          var buttonDom = $('.ribbonButtonContainer #'+button.buttonId);
          if (buttonDom.length) {
            $(buttonDom).find('.left-text').text(langButton.buttonText);
          }
        }
      });
    }
    // Handle rtl languages
    $('body').find('.language-dir').each((ix,dd) => {$(dd).attr('dir',trans.dir)});
  }

  static get allMenus() {
    return [
      'SuiAddStaffMenu',
      'SuiMeasureMenu',
      'SuiFileMenu',
      'SuiTimeSignatureMenu',
      'SuiKeySignatureMenu',
      'SuiTimeSignatureMenu',
      'SuiKeySignatureMenu',
      'SuiStaffModifierMenu',
      'SuiDynamicsMenu',
      'SuiLanguageMenu',
      'SuiScoreMenu'
    ]
  }

  static get allDialogs() {
    return [
      'SuiLoadFileDialog',
      'SuiSaveFileDialog',
      'SuiPrintFileDialog',
      'SuiMeasureDialog',
      'SuiTempoDialog',
      'SuiInstrumentDialog',
      'SuiTimeSignatureDialog',
      'SuiLayoutDialog',
      'SuiDynamicModifierDialog',
      'SuiSlurAttributesDialog',
      'SuiVoltaAttributeDialog',
      'SuiHairpinAttributesDialog',
      'SuiLyricDialog',
      'SuiChordChangeDialog',
      'SuiTextTransformDialog',
      'SuiScoreViewDialog',
      'SuiScorePreferencesDialog',
      'SuiLyricDialog',
      'SuiChordChangeDialog',
    ]
  }
  static get allHelpFiles() {
    return [
      'quickStartHtml',
      'selectionHtml',
      'enterPitchesHtml',
      'enterDurationsHtml'
    ];
  }
}

class SmoLanguage {
  static getHelpFile(category) {
    return eval(category + SmoConfig.language);
  }
  static get en() {
    var strings = JSON.parse(smoLanguageStringEn);
    var rv = {dir:'ltr',strings:strings,helpHtml:{}};
    return rv;
   }

   static get ar() {
     var strings = JSON.parse(smoLanguageStringAr);
     var rv = {dir:'rtl',strings:strings,helpHtml:{}};
     return rv;
   }

   static get de() {
     var strings = JSON.parse(smoLanguageStringDe);
     var rv = {dir:'ltr',strings:strings,helpHtml:{}};
     return rv;
   }
}
;//

// ## SmoTranslationEditor
// Create a somewhat user-friendly editor DOM to translate SMO
// dialogs and menus, and any subset, into other languages.
class SmoTranslationEditor {

   // ### _getHtmlTextInput
   // All the editable text elements contain: the code label or value from the
   // UI element, the En string, and  the translated string, or a copy of the
   // EN string if the string has not been translated.
    static _getHtmlTextInput(dbLabel,enLabel,langLabel,labelType,labelId) {
      var b = htmlHelpers.buildDom;

      const compHtml = b('div').classes('dialog-element-container')
        .attr('data-'+labelType,labelId).append(
          b('div').classes('dialog-component-label').append(
            b('span').classes('trans-label').append(
              b('span').classes('trans-db-text').text(dbLabel)
            ).append(
              b('span').classes('trans-en-text').text(enLabel)
            ).append(
              b('input').classes('trans-label-input')
            ).append(
              b('span').classes('plaintext-translate hide').text(langLabel)
            )
          )
        ).dom();
      return compHtml;
    }

    // ### _getMenuTextDialogHtml
    // Get all the menu item labels for translation
    static _getMenuTextDialogHtml(menuCtor,enStrings,langStrings) {
      const menuClass = eval(menuCtor);
      const menuItems = menuClass['defaults'].menuItems;
      var enMenu = enStrings.find((mn) => mn.ctor === menuCtor);

      // Get the JSON EN menu, or copy the DB strings if it doesn't exist
      if (!enMenu) {
        enMenu = JSON.parse(JSON.stringify(menuClass['defaults']));
        enMenu.ctor = menuCtor;
      }
      // Get the JSON language menu strings, or copy the EN strings if it doesn't exist
      var langMenu = langStrings.find((mn) => mn.ctor === menuCtor);
      if (!langMenu) {
        langMenu = JSON.parse(JSON.stringify(menuClass['defaults']));
        langMenu.ctor = menuCtor;
      }

      // create the DOM menu container
      var b = htmlHelpers.buildDom;
      const container = b('div').classes('menu-translate-container')
        .attr('data-menucontainer',menuCtor).append(
          b('button').classes('icon-plus trans-expander')).append(
            b('span').classes('menu-translate-title').text(menuCtor)
        ).dom();
      const menuItemsDom = b('div').classes('menu-element-container').dom();

      // create the label editor
      const menuLabel = SmoTranslationEditor._getHtmlTextInput(menuClass['defaults'].label,enMenu.label,langMenu.label,
        'menulabel',menuCtor);
      $(menuItemsDom).append(menuLabel);
      $(container).append(menuItemsDom);

      // create the editor for each item
      menuItems.forEach((item) => {
        var enItem  = enMenu.menuItems.find((mi) => mi.value === item.value);
        if (!enItem) {
          enItem = JSON.parse(JSON.stringify(item));
        }
        var langItem = langMenu.menuItems.find((mi) => mi.value === item.value);
        if (!langItem) {
          langItem = JSON.parse(JSON.stringify(item));
        }
        const menuItemDom = b('div').classes('menu-item-container').dom();
        const itemEditDom = SmoTranslationEditor._getHtmlTextInput(
          item.value,enItem.text,langItem.text,
          'itemtext',item.value);
        $(menuItemDom).append(itemEditDom);
        $(menuItemsDom).append(menuItemDom);
      });
      return container;
    }
    static getStaticText(dialogElements,label) {
      return dialogElements.find((x) => x.staticText).staticText.find((x) => x[label]);
    }
    static getButtonTranslateHtml(enStrings,langStrings,transContainer) {
      var b = htmlHelpers.buildDom;
      var buttonDom = b('div').classes('ribbon-translate-container')
        .attr('data-ribbon-translate','buttons').append(
          b('button').classes('icon-plus trans-expander')).append(
          b('span').classes('ribbon-translate-title').text('Button Text')
      ).dom();

      var enKeys = enStrings.find((enString) => enString.ribbonButtonText);
      if (!enKeys) {
        enKeys = JSON.parse(JSON.stringify(RibbonButtons.translateButtons));
      }
      var langKeys = langStrings.find((langString) => langString.ribbonText);
      if (!langKeys) {
        langKeys = JSON.parse(JSON.stringify(RibbonButtons.translateButtons));
      } else {
        langKeys = langKeys.ribbonText;
      }
      RibbonButtons.translateButtons.forEach((button) => {
        const langObj  = langKeys.find((langText) => langText.buttonId === button.buttonId);
        const enObj = enKeys.find((enText) => enText.buttonId === button.buttonId);
        const enString  = enObj ? enObj .buttonText: button.buttonText;
        const langString = langObj ? langObj.buttonText : button.buttonText;
        var buttonContainer = b('div').classes('ribbon-button-container')
          .attr('data-buttoncontainer',button.id).dom();
        $(buttonContainer).append(
           SmoTranslationEditor._getHtmlTextInput(button.buttonId,enString,langString,'ribbon-button',button.buttonId)
        );
        $(buttonDom).append(buttonContainer);
      });
      $(transContainer).append(buttonDom);
    }

    // ### _getStaticTextDialogHtml
    // create DOM for the static text section of the dialogs.
    static _getStaticTextDialogHtml(dialogCtor,element,enDb,langDb,htmlContainer) {
      var b = htmlHelpers.buildDom;

      const dbObj = element.staticText;
      var enStNode = enDb.find((st) => st.staticText);
      if (!enStNode) {
        const enStString = JSON.parse(JSON.stringify(element.staticText));
        enStNode = { staticText:enStString };
        enDb.push({ staticText:enStString });
      }
      var langStNode = langDb.find((st) => st.staticText);
      if (!langStNode|| !langStNode.staticText) {
        const langStString = JSON.parse(JSON.stringify(element.staticText));
        langStNode = { staticText: langStString};
        langDb.push(langStNode);
      }
      const enObj = enStNode.staticText;
      const langObj = langStNode.staticText;
      const nodeContainer = b('div')
        .classes('dialog-element-container')
        .attr('data-component','staticText')
        .dom();
      $(htmlContainer).append(nodeContainer);
      const elKeys = dbObj.map((st) => Object.keys(st)[0]);
      elKeys.forEach((elKey) => {
        var dbVal = dbObj.find((st) => st[elKey]);
        var enVal = enObj.find((st) => st[elKey]);
        var langVal = langObj.find((st) => st[elKey]);
        if (!enVal) {
          enVal = dbVal;
        }
        if (!langVal) {
          langVal = dbVal;
        }
        const translateElement = SmoTranslationEditor._getHtmlTextInput(
          elKey,enVal[elKey],langVal[elKey],'statictext',elKey);
        $(nodeContainer).append(translateElement);
      });
    }

    static _getDialogComponentHtml(dialogCtor,element,enDb,langDb,container) {
      var b = htmlHelpers.buildDom;

      var label = element.label;
      var smoName = element.smoName;
      var enComponent = enDb.find((st) => st.id === smoName);
      if (!enComponent) {
        enComponent = JSON.parse(JSON.stringify(element))
      }
      var langComponent = langDb.find((st) => st.id === smoName);
      if (!langComponent) {
        langComponent = JSON.parse(JSON.stringify(element));
      }
      const enLabel = enComponent.label ? enComponent.label : label;
      const langLabel = langComponent.label ? langComponent.label : label;
      const compHtml = SmoTranslationEditor._getHtmlTextInput(
        label,enLabel,langLabel,'component',smoName);

      if (element.options) {
        const optionsHtml = b('div').classes('dialog-component-options').dom();
        $(compHtml).append(optionsHtml);
        if (!enComponent.options) {
          enComponent.options = JSON.parse(JSON.stringify(element.options));
        }
        if (!langComponent.options) {
          langComponent.options = JSON.parse(JSON.stringify(element.options));
        }

        element.options.forEach((option) => {
          var enOption = enComponent.options.find((op) => op.value === option.value);
          var langOption = langComponent.options.find((op) => op.value === option.value);
          if (!enOption || !enOption.label) {
            enOption = JSON.parse(JSON.stringify(option));
          }
          if (!langOption || !langOption.label) {
            langOption = JSON.parse(JSON.stringify(option));
          }
          const optionHtml =  SmoTranslationEditor._getHtmlTextInput(
            option.value,enOption.label,langOption.label,'component-option',option.value);
            $(optionsHtml).append(optionHtml)
        });
        $(container).append(compHtml);
      }
    }

    static getDialogTranslationHtml(dialogCtor,enStrings,langStrings) {
      var b = htmlHelpers.buildDom;
      var container = b('div').classes('db-translate-container').attr('data-dbcontainer',dialogCtor)
        .append(b('button').classes('icon-plus trans-expander'))
        .append(b('span').classes('db-translate-title').text(dialogCtor)).dom();
      var ctor = eval(dialogCtor);
      var elements = ctor.dialogElements;
      var enDb = enStrings.find((dbStr) => dbStr.ctor === dialogCtor);
      if (!enDb) {
        enDb = JSON.parse(JSON.stringify(elements));
      } else {
        enDb = enDb.dialogElements;
      }
      var langDb = langStrings.find((dbStr) => dbStr.ctor === dialogCtor);
      if (!langDb) {
        langDb = JSON.parse(JSON.stringify(elements));
      } else {
        langDb = langDb.dialogElements;
      }
      elements.forEach((element) => {
        if (element.staticText) {
          SmoTranslationEditor._getStaticTextDialogHtml(dialogCtor,element,enDb,langDb,container);
        } else if (element.smoName) {
          SmoTranslationEditor._getDialogComponentHtml(dialogCtor,element,enDb,langDb,container);
        }
      });
      return container;
    }
    static getAllTranslationHtml(lang) {
      var enStr = SmoLanguage.en.strings
      var langStr = SmoLanguage[lang].strings;
      var b = htmlHelpers.buildDom;
      var container = b('div').classes('top-translate-container')
        .attr('dir',SmoLanguage[lang].dir).dom();
      SmoTranslator.allDialogs.forEach((dialog) => {
        $(container).append(SmoTranslationEditor.getDialogTranslationHtml(dialog,enStr,langStr))
      });
      SmoTranslator.allMenus.forEach((menu) => {
        $(container).append(SmoTranslationEditor._getMenuTextDialogHtml(menu,enStr,langStr));
      });
      SmoTranslationEditor.getButtonTranslateHtml(enStr,langStr,container);
      var resultDom = b('div').classes('translation-json-container').append(
        b('textarea').classes('translation-json-text')).append(
        b('div').append(
          b('button').classes('translate-submit-button').text('Submit')
        )
      ).dom();

      $(container).append(resultDom);

      return container;
    }
    static parseDom() {
      var json = [];
      // $('.top-translate-container .db-translate-container[data-dbcontainer] [data-component="staticText"]')
       $('.top-translate-container .db-translate-container[data-dbcontainer]').each((ix,dbEl) => {
         var db = $(dbEl).attr('data-dbcontainer');
         var obj = {ctor: db};
         var elements = [];
         var domComponents = $(dbEl).find('[data-component]');
         $(domComponents).each(function(ix,domComponent) {
           const compType = $(domComponent).attr('data-component');

           if (compType === 'staticText') {
             var stElements=[];
             $(domComponent).find('[data-statictext]').each((ix,stDom) => {
               const key=$(stDom).attr('data-statictext');
               const value = $(stDom).find('input.trans-label-input').val();
               const stNode = JSON.parse('{"'+key+'":"'+value+'"}');
               stElements.push(stNode);
             });
             elements.push({staticText:stElements});
           } else {
             var dbComponent = {id:compType};
             dbComponent.label = $(domComponent).find('input.trans-label-input').val();
             var compOptions = [];
             $(domComponent).find('[data-component-option]').each(function(ix,optionDom) {
               const value = $(optionDom).find('.trans-db-text').text();
               const label = $(optionDom).find('input.trans-label-input').val();
               compOptions.push({value:value,label:label});
             });
             dbComponent.options = compOptions;
             elements.push(dbComponent);
           }
         });
         obj.dialogElements = elements;
         json.push(obj);

       });
       $('.menu-translate-container[data-menucontainer]').each((ix,menuEl) => {
         var menuId = $(menuEl).attr('data-menucontainer');
         var obj = {ctor:menuId};
         const menuLabel = $(menuEl)
           .find('.dialog-element-container[data-menulabel] .trans-label-input')
           .val();
         obj.label = menuLabel;
         var menuItems = [];
         var itemsDom = $(menuEl).find('.menu-item-container .dialog-element-container');
         $(itemsDom).each((ix,itemDom) => {
           const value = $(itemDom).find('.trans-db-text').text();
           const text = $(itemDom).find('input.trans-label-input').val();
           menuItems.push({value:value,text:text});
         });
         obj.menuItems = menuItems;
         json.push(obj);
       });
       var ribbonText = [];
       $('.ribbon-translate-container .ribbon-button-container').each((ix,buttonEl) => {
         const buttonId = $(buttonEl).find('.trans-db-text').text();
         const buttonText = $(buttonEl).find('input.trans-label-input').val();
         ribbonText.push({buttonId: buttonId,buttonText:buttonText});
       });
       json.push({ribbonText:ribbonText});
      return json;
    }
    static startEditor(lang) {
      var transDom =  SmoTranslationEditor.getAllTranslationHtml(lang);
      $('.translation-editor').append(transDom);
      $('body').addClass('translation-mode');
      $('.plaintext-translate').each(function(ix,el) {
        var txt = $(this).text();
        var input = $(this).closest('.trans-label').find('input.trans-label-input').val(txt);
      });

      $('.db-translate-container button.trans-expander').off('click').on('click', function() {
        var exp = $(this).closest('.db-translate-container');
        if ($(exp).hasClass('expanded')) {
          $(exp).removeClass('expanded');
          $(this).removeClass('icon-minus');
          $(this).addClass('icon-plus');
        } else {
          $(exp).addClass('expanded');
          $(this).addClass('icon-minus');
          $(this).removeClass('icon-plus');
        }
      });
      $('.menu-translate-container button.trans-expander').off('click').on('click', function() {
        var exp = $(this).closest('.menu-translate-container');
        if ($(exp).hasClass('expanded')) {
          $(exp).removeClass('expanded');
          $(this).removeClass('icon-minus');
          $(this).addClass('icon-plus');
        } else {
          $(exp).addClass('expanded');
          $(this).addClass('icon-minus');
          $(this).removeClass('icon-plus');
        }
      });
      $('.ribbon-translate-container button.trans-expander').off('click').on('click', function() {
        var exp = $(this).closest('.ribbon-translate-container');
        if ($(exp).hasClass('expanded')) {
          $(exp).removeClass('expanded');
          $(this).removeClass('icon-minus');
          $(this).addClass('icon-plus');
        } else {
          $(exp).addClass('expanded');
          $(this).addClass('icon-minus');
          $(this).removeClass('icon-plus');
        }
      });
      $('.translate-submit-button').off('click').on('click',(ev) => {
        var json = SmoTranslationEditor.parseDom();
        $('.translation-json-text').val(JSON.stringify(json,null,' '));
      });


    }

}
;class defaultEditorKeys {

  static get keys() {
    return [{
        event: "keydown",
        key: "=",
        ctrlKey: false,
        altKey: false,
        shiftKey: false,
        action: "transposeUp"
      }, {
        event: "keydown",
        key: "-",
        ctrlKey: false,
        altKey: false,
        shiftKey: false,
        action: "transposeDown"
      }, {
        event: "keydown",
        key: "+",
        ctrlKey: false,
        altKey: false,
        shiftKey: true,
        action: "upOctave"
      }, {
        event: "keydown",
        key: "_",
        ctrlKey:false,
        altKey: false,
        shiftKey: true,
        action: "downOctave"
      }, {
        event: "keydown",
        key: "F",
        ctrlKey: false,
        altKey: false,
        shiftKey: true,
        action: "toggleCourtesyAccidental"
      }, {
        event: "keydown",
        key: ".",
        ctrlKey: false,
        altKey: false,
        shiftKey: false,
        action: "doubleDuration"
      }, {
        event: "keydown",
        key: ",",
        ctrlKey: false,
        altKey: false,
        shiftKey: false,
        action: "halveDuration"
      }, {
        event: "keydown",
        key: ">",
        ctrlKey: false,
        altKey: false,
        shiftKey: true,
        action: "dotDuration"
      }, {
        event: "keydown",
        key: "<",
        ctrlKey: false,
        altKey: false,
        shiftKey: true,
        action: "undotDuration"
      }, {
        event: "keydown",
        key: "a",
        ctrlKey: false,
        altKey: false,
        shiftKey: false,
        action: "setPitch"
      }, {
        event: "keydown",
        key: "A",
        ctrlKey: false,
        altKey: false,
        shiftKey: true,
        action: "slashGraceNotes"
      }, {
        event: "keydown",
        key: "b",
        ctrlKey: false,
        altKey: false,
        shiftKey: false,
        action: "setPitch"
      }, {
        event: "keydown",
        key: "G",
        ctrlKey: false,
        altKey: false,
        shiftKey: true,
        action: "addGraceNote"
      }, {
        event: "keydown",
        key: "g",
        ctrlKey: false,
        altKey: true,
        shiftKey: false,
        action: "removeGraceNote"
      }, {
        event: "keydown",
        key: "c",
        ctrlKey: false,
        altKey: false,
        shiftKey: false,
        action: "setPitch"
      }, {
        event: "keydown",
        key: "d",
        ctrlKey: false,
        altKey: false,
        shiftKey: false,
        action: "setPitch"
      }, {
        event: "keydown",
        key: "e",
        ctrlKey: false,
        altKey: false,
        shiftKey: false,
        action: "setPitch"
      }, {
        event: "keydown",
        key: "f",
        ctrlKey: false,
        altKey: false,
        shiftKey: false,
        action: "setPitch"
      }, {
        event: "keydown",
        key: "g",
        ctrlKey: false,
        altKey: false,
        shiftKey: false,
        action: "setPitch"
      }, {
        event: "keydown",
        key: "r",
        ctrlKey: false,
        altKey: false,
        shiftKey: false,
        action: "makeRest"
      }, {
        event: "keydown",
        key: "r",
        ctrlKey: false,
        altKey: true,
        shiftKey: false,
        action: "rerender"
      }, {
        event: "keydown",
        key: "p",
        ctrlKey: false,
        altKey: false,
        shiftKey: false,
        action: "playScore"
      }, {
        event: "keydown",
        key: "P",
        ctrlKey: false,
        altKey: false,
        shiftKey: true,
        action: "pausePlayer"
      },
            {
        event: "keydown",
        key: "s",
        ctrlKey: false,
        altKey: false,
        shiftKey: false,
        action: "stopPlayer"
      },             {
        event: "keydown",
        key: "t",
        ctrlKey: false,
        altKey: false,
        shiftKey: false,
        action: "tempoDialog"
      },
      {
        event: "keydown",
        key: "3",
        ctrlKey: true,
        altKey: false,
        shiftKey: false,
        action: "makeTuplet"
      }, {
        event: "keydown",
        key: "5",
        ctrlKey: true,
        altKey: false,
        shiftKey: false,
        action: "makeTuplet"
      }, {
        event: "keydown",
        key: "7",
        ctrlKey: true,
        altKey: false,
        shiftKey: false,
        action: "makeTuplet"
      },
      // interval commands
      {
        event: "keydown",
        key: "2",
        ctrlKey: false,
        altKey: false,
        shiftKey: false,
        action: "interval"
      }, {
        event: "keydown",
        key: "3",
        ctrlKey: false,
        altKey: false,
        shiftKey: false,
        action: "interval"
      }, {
        event: "keydown",
        key: "4",
        ctrlKey: false,
        altKey: false,
        shiftKey: false,
        action: "interval"
      }, {
        event: "keydown",
        key: "5",
        ctrlKey: false,
        altKey: false,
        shiftKey: false,
        action: "interval"
      }, {
        event: "keydown",
        key: "6",
        ctrlKey: false,
        altKey: false,
        shiftKey: false,
        action: "interval"
      }, {
        event: "keydown",
        key: "7",
        ctrlKey: false,
        altKey: false,
        shiftKey: false,
        action: "interval"
      }, {
        event: "keydown",
        key: "8",
        ctrlKey: false,
        altKey: false,
        shiftKey: false,
        action: "interval"
      }, {
        event: "keydown",
        key: "@",
        ctrlKey: false,
        altKey: false,
        shiftKey: true,
        action: "interval"
      }, {
        event: "keydown",
        key: "$",
        ctrlKey: false,
        altKey: false,
        shiftKey: true,
        action: "interval"
      }, {
        event: "keydown",
        key: "#",
        ctrlKey: false,
        altKey: false,
        shiftKey: true,
        action: "interval"
      }, {
        event: "keydown",
        key: "%",
        ctrlKey: false,
        altKey: false,
        shiftKey: true,
        action: "interval"
      }, {
        event: "keydown",
        key: "^",
        ctrlKey: false,
        altKey: false,
        shiftKey: true,
        action: "interval"
      }, {
        event: "keydown",
        key: "&",
        ctrlKey: false,
        altKey: false,
        shiftKey: true,
        action: "interval"
      }, {
        event: "keydown",
        key: "*",
        ctrlKey: false,
        altKey: false,
        shiftKey: true,
        action: "interval"
      }, {
        event: "keydown",
        key: "8",
        ctrlKey: false,
        altKey: false,
        shiftKey: true,
        action: "interval"
      }, {
        event: "keydown",
        key: "0",
        ctrlKey: true,
        altKey: false,
        shiftKey: false,
        action: "unmakeTuplet"
      }, {
        event: "keydown",
        key: "Insert",
        ctrlKey: false,
        altKey: false,
        shiftKey: false,
        action: "addMeasure"
      },{
        event: "keydown",
        key: "Insert",
        ctrlKey: false,
        altKey: false,
        shiftKey: true,
        action: "addMeasure"
      }, {
        event: "keydown",
        key: "i",
        ctrlKey: true,
        altKey: false,
        shiftKey: false,
        action: "addMeasure"
      }, {
        event: "keydown",
        key: "I",
        ctrlKey: true,
        altKey: false,
        shiftKey: true,
        action: "addMeasure"
      }, {
        event: "keydown",
        key: "B",
        ctrlKey: false,
        altKey: false,
        shiftKey: true,
        action: "toggleBeamDirection"
      }, {
        event: "keydown",
        key: "Delete",
        ctrlKey: false,
        altKey: false,
        shiftKey: false,
        action: "deleteNote"
      }, {
        event: "keydown",
        key: "d",
        ctrlKey: true,
        altKey: false,
        shiftKey: false,
        action: "deleteNote"
      }, {
        event: "keydown",
        key: "z",
        ctrlKey: true,
        altKey: false,
        shiftKey: false,
        action: "undo"
      }, {
        event: "keydown",
        key: "c",
        ctrlKey: true,
        altKey: false,
        shiftKey: false,
        action: "copy"
      }, {
        event: "keydown",
        key: "x",
        ctrlKey: false,
        altKey: false,
        shiftKey: false,
        action: "toggleBeamGroup"
      }, {
        event: "keydown",
        key: "X",
        ctrlKey: false,
        altKey: false,
        shiftKey: true,
        action: "beamSelections"
      },{
        event: "keydown",
        key: "v",
        ctrlKey: true,
        altKey: false,
        shiftKey: false,
        action: "paste"
      }, {
        event: "keydown",
        key: "h",
        ctrlKey: false,
        altKey: false,
        shiftKey: false,
        action: "addRemoveArticulation"
      }, {
        event: "keydown",
        key: "i",
        ctrlKey: false,
        altKey: false,
        shiftKey: false,
        action: "addRemoveArticulation"
      }, {
        event: "keydown",
        key: "j",
        ctrlKey: false,
        altKey: false,
        shiftKey: false,
        action: "addRemoveArticulation"
      }, {
        event: "keydown",
        key: "k",
        ctrlKey: false,
        altKey: false,
        shiftKey: false,
        action: "addRemoveArticulation"
      }, {
        event: "keydown",
        key: "l",
        ctrlKey: false,
        altKey: false,
        shiftKey: false,
        action: "addRemoveArticulation"
      }, {
        event: "keydown",
        key: "H",
        ctrlKey: false,
        altKey: false,
        shiftKey: true,
        action: "addRemoveArticulation"
      }, {
        event: "keydown",
        key: "I",
        ctrlKey: false,
        altKey: false,
        shiftKey: true,
        action: "addRemoveArticulation"
      }, {
        event: "keydown",
        key: "J",
        ctrlKey: false,
        altKey: false,
        shiftKey: true,
        action: "addRemoveArticulation"
      }, {
        event: "keydown",
        key: "K",
        ctrlKey: false,
        altKey: false,
        shiftKey: true,
        action: "addRemoveArticulation"
      }, {
        event: "keydown",
        key: "L",
        ctrlKey: false,
        altKey: false,
        shiftKey: true,
        action: "addRemoveArticulation"
      },{
        event: "keydown",
        key: "E",
        ctrlKey: false,
        altKey: false,
        shiftKey: true,
        action: "toggleEnharmonic"
      }
    ];
  }

}
;
class defaultTrackerKeys {

  static get keys() {
    return [{
        event: "keydown",
        key: "Home",
        ctrlKey: false,
        altKey: false,
        shiftKey: false,
        action: "moveHome"
      }, {
        event: "keydown",
        key: "Home",
        ctrlKey: true,
        altKey: false,
        shiftKey: false,
        action: "moveHome"
      }, {
        event: "keydown",
        key: "Home",
        ctrlKey: false,
        altKey: false,
        shiftKey: true,
        action: "moveHome"
      }, {
        event: "keydown",
        key: "Home",
        ctrlKey: true,
        altKey: false,
        shiftKey: true,
        action: "moveHome"
      }, {
        event: "keydown",
        key: "End",
        ctrlKey: false,
        altKey: false,
        shiftKey: false,
        action: "moveEnd"
      }, {
        event: "keydown",
        key: "End",
        ctrlKey: false,
        altKey: false,
        shiftKey: true,
        action: "moveHome"
      }, {
        event: "keydown",
        key: "End",
        ctrlKey: true,
        altKey: false,
        shiftKey: false,
        action: "moveEnd"
      }, {
        event: "keydown",
        key: "End",
        ctrlKey: true,
        altKey: false,
        shiftKey: true,
        action: "moveEnd"
      }, {
        event: "keydown",
        key: "ArrowRight",
        ctrlKey: false,
        altKey: false,
        shiftKey: false,
        action: "moveSelectionRight"
      }, {
        event: "keydown",
        key: "ArrowRight",
        ctrlKey: false,
        altKey: true,
        shiftKey: false,
        action: "advanceModifierSelection"
      }, {
        event: "keydown",
        key: "ArrowLeft",
        ctrlKey: false,
        altKey: true,
        shiftKey: false,
        action: "advanceModifierSelection"
      },{
        event: "keydown",
        key: "ArrowLeft",
        ctrlKey: false,
        altKey: false,
        shiftKey: false,
        action: "moveSelectionLeft"
      }, {
        event: "keydown",
        key: "ArrowRight",
        ctrlKey: false,
        altKey: false,
        shiftKey: true,
        action: "growSelectionRight"
      }, {
        event: "keydown",
        key: "ArrowRight",
        ctrlKey: true,
        altKey: false,
        shiftKey: true,
        action: "growSelectionRightMeasure"
      }, {
        event: "keydown",
        key: "ArrowLeft",
        ctrlKey: false,
        altKey: false,
        shiftKey: true,
        action: "growSelectionLeft"
      }, {
        event: "keydown",
        key: "ArrowUp",
        ctrlKey: false,
        altKey: false,
        shiftKey: false,
        action: "moveSelectionUp"
      }, {
        event: "keydown",
        key: "ArrowDown",
        ctrlKey: false,
        altKey: false,
        shiftKey: false,
        action: "moveSelectionDown"
      }, {
        event: "keydown",
        key: "ArrowRight",
        ctrlKey: true,
        altKey: false,
        shiftKey: false,
        action: "moveSelectionRightMeasure"
      }, {
        event: "keydown",
        key: "ArrowLeft",
        ctrlKey: true,
        altKey: false,
        shiftKey: false,
        action: "moveSelectionLeftMeasure"
      },{
        event: "keydown",
        key: "ArrowUp",
        ctrlKey: false,
        altKey: false,
        shiftKey: true,
        action: "moveSelectionPitchUp"
      },{
        event: "keydown",
        key: "ArrowDown",
        ctrlKey: false,
        altKey: false,
        shiftKey: true,
        action: "moveSelectionPitchDown"
      }
      ];
  }
}
;

// ## suiEditor
// KeyCommands object handles key events and converts them into commands, updating the score and
// display
class SuiKeyCommands {
  constructor(params) {
    Vex.Merge(this, params);
    this.slashMode = false;
  }

  tempoDialog() {
    SuiTempoDialog.createAndDisplay(
      {
        buttonElement: this.buttonElement,
        buttonData: this.buttonData,
        completeNotifier: this.controller,
        view: this.view,
        eventSource: this.eventSource,
        editor: this
      }
    );
  }

  get score() {
    return this.view.score;
  }

  undo() {
    this.view.undo();
  }

  copy() {
    this.view.copy();
  }
  paste() {
    this.view.paste();
  }
  toggleBeamGroup() {
    this.view.toggleBeamGroup();
  }

  beamSelections() {
    this.view.beamSelections();
  }
  toggleBeamDirection() {
    this.view.toggleBeamDirection();
  }

  collapseChord() {
    this.view.collapseChord();
  }

  playScore() {
    var mm = this.view.tracker.getExtremeSelection(-1);
    if (suiAudioPlayer.playingInstance && suiAudioPlayer.playingInstance.paused) {
      suiAudioPlayer.playingInstance.play();
      return;
    }
    new suiAudioPlayer({ score: this.view.score, startIndex: mm.selector.measure, tracker: this.view.tracker }).play();
  }

  stopPlayer() {
    suiAudioPlayer.stopPlayer();
  }
  pausePlayer() {
    suiAudioPlayer.pausePlayer();
  }

  intervalAdd(interval, direction) {
    this.view.setInterval(direction * interval);
  }

  interval(keyEvent) {
    // code='Digit3'
    var interval = parseInt(keyEvent.keyCode) - 49;  // 48 === '0', 0 indexed
    if (isNaN(interval) || interval < 1 || interval > 7) {
      return;
    }
    this.intervalAdd(interval, keyEvent.shiftKey ? -1 : 1);
  }

  transpose(offset) {
    this.view.transposeSelections(offset);
  }
  transposeDown() {
    this.transpose(-1);
  }
  transposeUp() {
    this.transpose(1);
  }
  upOctave() {
    this.transpose(12);
  }
  downOctave() {
    this.transpose(-12);
  }
  makeRest() {
    this.view.makeRest();
  }

  setPitchCommand(letter) {
    this.view.setPitch(letter);
  }

  setPitch(keyEvent) {
    this.setPitchCommand(keyEvent.key.toLowerCase());
  }

  dotDuration(keyEvent) {
    this.view.batchDurationOperation('dotDuration');
  }

  undotDuration(keyEvent) {
    this.view.batchDurationOperation('undotDuration');
  }

  doubleDuration(keyEvent) {
    this.view.batchDurationOperation('doubleDuration');
  }

  halveDuration(keyEvent) {
    this.view.batchDurationOperation('halveDuration');
  }

  addMeasure(keyEvent) {
    this.view.addMeasure(keyEvent.shiftKey);
  }
  deleteNote() {
   this.view.deleteNote();
  }

  toggleCourtesyAccidental() {
    this.view.toggleCourtesyAccidentals();
  }
  toggleEnharmonic() {
    this.view.toggleEnharmonic();
  }

  makeTupletCommand(numNotes) {
    this.view.makeTuplet(numNotes);
  }
  makeTuplet(keyEvent) {
    var numNotes = parseInt(keyEvent.key);
    this.makeTupletCommand(numNotes);
  }

  unmakeTuplet(keyEvent) {
    this.view.unmakeTuplet();
  }
  setNoteHead(keyEvent) {
    this.view.setNoteHead('x2');
  }
  removeGraceNote(keyEvent) {
    this.view.removeGraceNote();
  }
  addGraceNote(keyEvent) {
    this.view.addGraceNote();
  }
  slashGraceNotes(keyEvent) {
    this.view.slashGraceNotes();
  }

  toggleArticulationCommand(articulation, ctor) {
    this.view.toggleArticulation(articulation, ctor);
  }

  addRemoveArticulation(keyEvent) {
    if (this.view.tracker.selections.length < 1) {
      return;
    }
    var atyp = SmoArticulation.articulations.accent;

    if (keyEvent.key.toLowerCase() === 'h') {
      atyp = SmoArticulation.articulations.accent;
    }
    if (keyEvent.key.toLowerCase() === 'i') {
      atyp = SmoArticulation.articulations.tenuto;
    }
    if (keyEvent.key.toLowerCase() === 'j') {
      atyp = SmoArticulation.articulations.staccato;
    }
    if (keyEvent.key.toLowerCase() === 'k') {
      atyp = SmoArticulation.articulations.marcato;
    }
    if (keyEvent.key.toLowerCase() === 'l') {
      atyp = SmoArticulation.articulations.pizzicato;
    }
    this.toggleArticulationCommand(atyp, 'SmoArticulation');
  }
}
;class suiMenuBase {
  constructor(params) {
    Vex.Merge(this, params);
    this.focusIndex = -1;
    SmoTranslator.registerMenu(this.ctor);
  }
  get closeModalPromise() {
    return this.closePromise();
  }
  static printTranslate(_class) {
    const xx = eval(_class);
    const items = [];
    xx.defaults.menuItems.forEach((item) => {
      items.push({ value: item.value, text: item.text });
    });
    return { ctor: xx.ctor, label: xx.label, menuItems: items };
  }

  complete() {
    $('body').trigger('menuDismiss');
  }
  // Most menus don't process their own events
  keydown() {}
}

// eslint-disable-next-line no-unused-vars
class suiMenuManager {
  constructor(params) {
    Vex.Merge(this, suiMenuManager.defaults);
    Vex.Merge(this, params);
    this.eventSource = params.eventSource;
    this.view = params.view;
    this.bound = false;
    this.hotkeyBindings = {};
  }

  static get defaults() {
    return {
      menuBind: suiMenuManager.menuKeyBindingDefaults,
      menuContainer: '.menuContainer'
    };
  }

  get closeModalPromise() {
    return this.closeMenuPromise;
  }

  setController(c) {
    this.controller = c;
  }

  get score() {
    return this.view.score;
  }

  // ### Description:
  // slash ('/') menu key bindings.  The slash key followed by another key brings up
  // a menu.
  static get menuKeyBindingDefaults() {
    return [
      {
        event: 'keydown',
        key: 'n',
        ctrlKey: false,
        altKey: false,
        shiftKey: false,
        action: 'SuiLanguageMenu'
      }, {
        event: 'keydown',
        key: 'k',
        ctrlKey: false,
        altKey: false,
        shiftKey: false,
        action: 'SuiKeySignatureMenu'
      }, {
        event: 'keydown',
        key: 'l',
        ctrlKey: false,
        altKey: false,
        shiftKey: false,
        action: 'SuiStaffModifierMenu'
      }, {
        event: 'keydown',
        key: 'd',
        ctrlKey: false,
        altKey: false,
        shiftKey: false,
        action: 'SuiDynamicsMenu'
      }, {
        event: 'keydown',
        key: 's',
        ctrlKey: false,
        altKey: false,
        shiftKey: false,
        action: 'SuiAddStaffMenu'
      }, {
        event: 'keydown',
        key: 'f',
        ctrlKey: false,
        altKey: false,
        shiftKey: false,
        action: 'SuiFileMenu'
      }, {
        event: 'keydown',
        key: 'L',
        ctrlKey: false,
        altKey: false,
        shiftKey: false,
        action: 'SuiLibraryMenu'
      }, {
        event: 'keydown',
        key: 'm',
        ctrlKey: false,
        altKey: false,
        shiftKey: false,
        action: 'SuiTimeSignatureMenu'
      }, {
        event: 'keydown',
        key: 'a',
        ctrlKey: false,
        altKey: false,
        shiftKey: false,
        action: 'SuiMeasureMenu'
      }
    ];
  }
  _advanceSelection(inc) {
    const options = $('.menuContainer ul.menuElement li.menuOption');
    inc = inc < 0 ? options.length - 1 : 1;
    this.menu.focusIndex = (this.menu.focusIndex + inc) % options.length;
    $(options[this.menu.focusIndex]).find('button').focus();
  }

  get menuBindings() {
    return this.menuBind;
  }

  unattach() {
    this.eventSource.unbindKeydownHandler(this.keydownHandler);
    $('body').removeClass('modal');
    $(this.menuContainer).html('');
    $('body').off('dismissMenu');
    this.bound = false;
    this.menu = null;
  }

  attach() {
    let hotkey = 0;

    $(this.menuContainer).html('');
    $(this.menuContainer).attr('z-index', '12');
    const b = htmlHelpers.buildDom;
    const r = b('ul').classes('menuElement').attr('size', this.menu.menuItems.length)
      .css('left', '' + this.menuPosition.x + 'px')
      .css('top', '' + this.menuPosition.y + 'px');
    this.menu.menuItems.forEach((item) => {
      var vkey = (hotkey < 10) ? String.fromCharCode(48 + hotkey) :
        String.fromCharCode(87 + hotkey);

      r.append(
        b('li').classes('menuOption').append(
          b('button').attr('data-value', item.value).append(
            b('span').classes('menuText').text(item.text))
            .append(b('span').classes('icon icon-' + item.icon))
            .append(b('span').classes('menu-key').text('' + vkey))));
      item.hotkey = vkey;
      hotkey += 1;
    });
    $(this.menuContainer).append(r.dom());
    $('body').addClass('modal');
    this.bindEvents();
  }

  slashMenuMode(completeNotifier) {
    var self = this;
    this.bindEvents();
    layoutDebug.addDialogDebug('slash menu creating closeMenuPromise');
    // A menu asserts this event when it is done.
    this.closeMenuPromise = new Promise((resolve) => {
      $('body').off('menuDismiss').on('menuDismiss', () => {
        layoutDebug.addDialogDebug('menuDismiss received, resolve closeMenuPromise');
        self.unattach();
        $('body').removeClass('slash-menu');
        resolve();
      });
    });
    // take over the keyboard
    completeNotifier.unbindKeyboardForModal(this);
  }

  dismiss() {
    $('body').trigger('menuDismiss');
  }

  createMenu(action) {
    this.menuPosition = { x: 250, y: 40, width: 1, height: 1 };
    // If we were called from the ribbon, we notify the controller that we are
    // taking over the keyboard.  If this was a key-based command we already did.
    layoutDebug.addDialogDebug('createMenu creating ' + action);
    const ctor = eval(action);
    this.menu = new ctor({
      position: this.menuPosition,
      tracker: this.tracker,
      keyCommands: this.keyCommands,
      score: this.score,
      completeNotifier: this.controller,
      closePromise: this.closeMenuPromise,
      view: this.view,
      eventSource: this.eventSource,
      undoBuffer: this.undoBuffer
    });
    this.attach(this.menuContainer);
    this.menu.menuItems.forEach((item) => {
      if (typeof(item.hotkey) !== 'undefined') {
        this.hotkeyBindings[item.hotkey] = item.value;
      }
    });
  }

  // ### evKey
  // We have taken over menu commands from controller.  If there is a menu active, send the key
  // to it.  If there is not, see if the keystroke creates one.  If neither, dismissi the menu.
  evKey(event) {
    if (['Tab', 'Enter'].indexOf(event.code) >= 0) {
      return;
    }
    event.preventDefault();
    if (event.code === 'Escape') {
      this.dismiss();
    }
    if (this.menu) {
      if (event.code === 'ArrowUp') {
        this._advanceSelection(-1);
      } else if (event.code === 'ArrowDown') {
        this._advanceSelection(1);
      } else  if (this.hotkeyBindings[event.key]) {
        $('button[data-value="' + this.hotkeyBindings[event.key] + '"]').click();
      } else {
        this.menu.keydown(event);
      }
      return;
    }
    const binding = this.menuBind.find((ev) =>
      ev.key === event.key
    );
    if (!binding) {
      this.dismiss();
      return;
    }
    this.createMenu(binding.action);
  }

  bindEvents() {
    const self = this;
    this.hotkeyBindings = { };
    $('body').addClass('slash-menu');
    // We need to keep track of is bound, b/c the menu can be created from
    // different sources.
    if (!this.bound) {
      this.keydownHandler = this.eventSource.bindKeydownHandler(this, 'evKey');
      this.bound = true;
    }
    $(this.menuContainer).find('button').off('click').on('click', (ev) => {
      if ($(ev.currentTarget).attr('data-value') === 'cancel') {
        self.menu.complete();
        return;
      }
      self.menu.selection(ev);
    });
  }
}

// eslint-disable-next-line no-unused-vars
class SuiScoreMenu extends suiMenuBase {
  static get defaults() {
    SuiScoreMenu._defaults = typeof(SuiScoreMenu._defaults) !== 'undefined' ? SuiScoreMenu._defaults : {
      label: 'Score Settings',
      menuItems: [{
        icon: '',
        text: 'Layout',
        value: 'layout'
      }, {
        icon: '',
        text: 'View',
        value: 'view'
      }, {
        icon: '',
        text: 'Score Info',
        value: 'identification'
      }, {
        icon: '',
        text: 'Preferences',
        value: 'preferences'
      }, {
        icon: '',
        text: 'Cancel',
        value: 'cancel'
      }]
    };
    return SuiScoreMenu._defaults;
  }
  constructor(params) {
    params = (typeof(params) !== 'undefined' ? params : {});
    Vex.Merge(params, SuiScoreMenu.defaults);
    super(params);
  }

  execView() {
    SuiScoreViewDialog.createAndDisplay(
      {
        eventSource: this.eventSource,
        keyCommands: this.keyCommands,
        completeNotifier: this.completeNotifier,
        view: this.view,
        startPromise: this.closePromise
      });
  }
  execScoreId() {
    SuiScoreIdentificationDialog.createAndDisplay(
      {
        eventSource: this.eventSource,
        keyCommands: this.keyCommands,
        completeNotifier: this.completeNotifier,
        view: this.view,
        startPromise: this.closePromise
      });
  }
  execLayout() {
    SuiLayoutDialog.createAndDisplay(
      {
        eventSource: this.eventSource,
        keyCommands: this.keyCommands,
        completeNotifier: this.completeNotifier,
        view: this.view,
        startPromise: this.closePromise
      });
  }
  execPreferences() {
    SuiScorePreferencesDialog.createAndDisplay(
      {
        eventSource: this.eventSource,
        keyCommands: this.keyCommands,
        completeNotifier: this.completeNotifier,
        view: this.view,
        startPromise: this.closePromise
      });
  }
  selection(ev) {
    const text = $(ev.currentTarget).attr('data-value');
    if (text === 'view') {
      this.execView();
    } else if (text === 'layout') {
      this.execLayout();
    } else if (text === 'preferences') {
      this.execPreferences();
    } else if (text === 'identification') {
      this.execScoreId();
    }
    this.complete();
  }
  keydown() {}
}
// eslint-disable-next-line no-unused-vars
class SuiFileMenu extends suiMenuBase {
  constructor(params) {
    params = (typeof(params) !== 'undefined' ? params : {});
    Vex.Merge(params, SuiFileMenu.defaults);
    super(params);
  }
  static get ctor() {
    return 'SuiFileMenu';
  }
  get ctor() {
    return SuiFileMenu.ctor;
  }
  static get defaults() {
    SuiFileMenu._defaults = typeof(SuiFileMenu._defaults) !== 'undefined' ? SuiFileMenu._defaults : {
      label: 'File',
      menuItems: [{
        icon: 'folder-new',
        text: 'New Score',
        value: 'newFile'
      }, {
        icon: 'folder-open',
        text: 'Open',
        value: 'openFile'
      }, {
        icon: '',
        text: 'Quick Save',
        value: 'quickSave'
      }, {
        icon: 'folder-save',
        text: 'Save',
        value: 'saveFile'
      }, {
        icon: '',
        text: 'Print',
        value: 'printScore'
      }, {
        icon: '',
        text: 'Import MusicXML',
        value: 'importMxml'
      }, {
        icon: '',
        text: 'Export MusicXML',
        value: 'exportXml'
      }, {
        icon: 'folder-save',
        text: 'Save Actions',
        value: 'saveActions'
      }, {
        icon: 'icon-play3',
        text: 'Play Actions',
        value: 'playActions'
      }, {
        icon: '',
        text: 'Cancel',
        value: 'cancel'
      }]
    };
    return SuiFileMenu._defaults;
  }
  systemPrint() {
    const self = this;
    window.print();
    SuiPrintFileDialog.createAndDisplay({
      view: self.view,
      completeNotifier: self.completeNotifier,
      closeMenuPromise: self.closePromise,
      tracker: self.tracker,
      undoBuffer: self.undoBuffer,
    });
  }
  selection(ev) {
    const text = $(ev.currentTarget).attr('data-value');
    const self = this;
    if (text === 'saveFile') {
      SuiSaveFileDialog.createAndDisplay({
        completeNotifier: this.completeNotifier,
        tracker: this.tracker,
        undoBuffer: this.keyCommands.undoBuffer,
        eventSource: this.eventSource,
        keyCommands: this.keyCommands,
        view: this.view,
        closeMenuPromise: this.closePromise
      });
    } else if (text === 'saveActions') {
      SuiSaveActionsDialog.createAndDisplay({
        completeNotifier: this.completeNotifier,
        tracker: this.tracker,
        undoBuffer: this.keyCommands.undoBuffer,
        eventSource: this.eventSource,
        keyCommands: this.keyCommands,
        view: this.view,
        closeMenuPromise: this.closePromise
      });
    }  else if (text === 'playActions') {
      SuiLoadActionsDialog.createAndDisplay({
        completeNotifier: this.completeNotifier,
        tracker: this.tracker,
        undoBuffer: this.keyCommands.undoBuffer,
        eventSource: this.eventSource,
        keyCommands: this.keyCommands,
        view: this.view,
        closeMenuPromise: this.closePromise
      });
    } else if (text === 'openFile') {
      SuiLoadFileDialog.createAndDisplay({
        completeNotifier: this.completeNotifier,
        tracker: this.tracker,
        undoBuffer: this.undoBuffer,
        eventSource: this.eventSource,
        editor: this.keyCommands,
        view: this.view,
        closeMenuPromise: this.closePromise
      });
    } else if (text === 'newFile') {
      const score = SmoScore.getDefaultScore();
      this.view.changeScore(score);
    } else if (text === 'quickSave') {
      this.view.quickSave();
    } else if (text === 'printScore') {
      const systemPrint = () => {
        self.systemPrint();
      };
      this.view.renderer.renderForPrintPromise().then(systemPrint);
    } else if (text === 'exportXml') {
      SuiSaveXmlDialog.createAndDisplay({
        completeNotifier: this.completeNotifier,
        tracker: this.tracker,
        undoBuffer: this.undoBuffer,
        eventSource: this.eventSource,
        editor: this.keyCommands,
        view: this.view,
        closeMenuPromise: this.closePromise
      });
    } else if (text === 'importMxml') {
      SuiLoadMxmlDialog.createAndDisplay({
        completeNotifier: this.completeNotifier,
        tracker: this.tracker,
        undoBuffer: this.undoBuffer,
        eventSource: this.eventSource,
        editor: this.keyCommands,
        view: this.view,
        closeMenuPromise: this.closePromise
      });
    }
    this.complete();
  }
  keydown() {}
}

// eslint-disable-next-line no-unused-vars
class SuiLibraryMenu extends suiMenuBase {
  constructor(params) {
    params = (typeof(params) !== 'undefined' ? params : {});
    Vex.Merge(params, SuiLibraryMenu.defaults);
    super(params);
  }
  static get ctor() {
    return 'SuiFileMenu';
  }
  get ctor() {
    return SuiFileMenu.ctor;
  }
  static get defaults() {
    SuiLibraryMenu._defaults = typeof(SuiLibraryMenu._defaults) !== 'undefined' ? SuiLibraryMenu._defaults : {
      label: 'Score',
      menuItems: [{
        icon: '',
        text: 'Bach Invention',
        value: 'bach'
      }, {
        icon: '',
        text: 'Postilion-Lied',
        value: 'postillion'
      }, {
        icon: '',
        text: 'Jesu Bambino',
        value: 'bambino'
      }, {
        icon: '',
        text: 'Handel Messiah 1-1',
        value: 'handel'
      }, {
        icon: '',
        text: 'Precious Lord',
        value: 'preciousLord'
      }, {
        icon: '',
        text: 'In Its Delightful Shade',
        value: 'shade'
      }, {
        icon: '',
        text: 'Yama',
        value: 'yamaJson'
      }, {
        icon: '',
        text: 'Dichterliebe (xml)',
        value: 'dichterliebe'
      }, {
        icon: '',
        text: 'Beethoven - An die ferne Gliebte (xml)',
        value: 'beethoven'
      }, {
        icon: '',
        text: 'Mozart - An Chloe (xml)',
        value: 'mozart'
      }, {
        icon: '',
        text: 'Joplin - The Entertainer (xml)',
        value: 'joplin'
      }, {
        icon: '',
        text: 'Cancel',
        value: 'cancel'
      }]
    };
    return SuiLibraryMenu._defaults;
  }
  _loadJsonAndComplete(path) {
    const req = new XMLHttpRequest();
    req.addEventListener('load', () => {
      const score = SmoScore.deserialize(req.responseText);
      this.view.changeScore(score);
      this.complete();
    });
    req.open('GET', path);
    req.send();
  }
  _loadXmlAndComplete(path) {
    const req = new XMLHttpRequest();
    req.addEventListener('load', () => {
      const parser = new DOMParser();
      const xml = parser.parseFromString(req.responseText, 'text/xml');
      const score = mxmlScore.smoScoreFromXml(xml);
      this.view.changeScore(score);
      this.complete();
    });
    req.open('GET', path);
    req.send();
  }

  selection(ev) {
    const text = $(ev.currentTarget).attr('data-value');
    if (text === 'bach') {
      this._loadJsonAndComplete('https://aarondavidnewman.github.io/Smoosic/release/library/BachInvention.json');
    } else if (text === 'yamaJson') {
      this._loadJsonAndComplete('https://aarondavidnewman.github.io/Smoosic/release/library/Yama2.json');
    } else if (text === 'handel') {
      this._loadJsonAndComplete('https://aarondavidnewman.github.io/Smoosic/release/library/Messiah Pt 1-1.json');
    } else if (text === 'bambino') {
      this._loadJsonAndComplete('https://aarondavidnewman.github.io/Smoosic/release/library/Gesu Bambino.json');
    } else if (text === 'shade') {
      this._loadJsonAndComplete('https://aarondavidnewman.github.io/Smoosic/release/library/Shade.json');
    } else if (text === 'postillion') {
      this._loadJsonAndComplete('https://aarondavidnewman.github.io/Smoosic/release/library/Postillionlied.json');
    } else if (text === 'preciousLord') {
      this._loadJsonAndComplete('https://aarondavidnewman.github.io/Smoosic/release/library/Precious Lord.json');
    } else if (text === 'dichterliebe') {
      this._loadXmlAndComplete('https://aarondavidnewman.github.io/Smoosic/release/library/Dichterliebe01.xml');
    } else if (text === 'beethoven') {
      this._loadXmlAndComplete('https://aarondavidnewman.github.io/Smoosic/release/library/Beethoven_AnDieFerneGeliebte.xml');
    } else if (text === 'mozart') {
      this._loadXmlAndComplete('https://aarondavidnewman.github.io/Smoosic/release/library/Mozart_AnChloe.xml');
    } else if (text === 'joplin') {
      this._loadXmlAndComplete('https://aarondavidnewman.github.io/Smoosic/release/library/ScottJoplin_The_Entertainer.xml');
    }
    this.complete();
  }
  keydown() {}
}

// eslint-disable-next-line no-unused-vars
class SuiDynamicsMenu extends suiMenuBase {
  constructor(params) {
    params = (typeof(params) !== 'undefined' ? params : {});
    Vex.Merge(params, SuiDynamicsMenu.defaults);
    super(params);
  }
  static get ctor() {
    return 'SuiDynamicsMenu';
  }
  get ctor() {
    return SuiDynamicsMenu.ctor;
  }
  static get defaults() {
    SuiDynamicsMenu._defaults = SuiDynamicsMenu._defaults ? SuiDynamicsMenu._defaults :
      {
        label: 'Dynamics',
        menuItems: [{
          icon: 'pianissimo',
          text: 'Pianissimo',
          value: 'pp'
        }, {
          icon: 'piano',
          text: 'Piano',
          value: 'p'
        }, {
          icon: 'mezzopiano',
          text: 'Mezzo-piano',
          value: 'mp'
        }, {
          icon: 'mezzoforte',
          text: 'Mezzo-forte',
          value: 'mf'
        }, {
          icon: 'forte',
          text: 'Forte',
          value: 'f'
        }, {
          icon: 'fortissimo',
          text: 'Fortissimo',
          value: 'ff'
        }, {
          icon: 'sfz',
          text: 'sfortzando',
          value: 'sfz'
        }, {
          icon: '',
          text: 'Cancel',
          value: 'cancel'
        }]
      };
    return SuiDynamicsMenu._defaults;
  }

  selection(ev) {
    const text = $(ev.currentTarget).attr('data-value');
    this.view.addDynamic(text);
    this.complete();
  }
  keydown() {}
}

// eslint-disable-next-line no-unused-vars
class SuiTimeSignatureMenu extends suiMenuBase {
  constructor(params) {
    params = (typeof(params) !== 'undefined' ? params : {});
    Vex.Merge(params, SuiTimeSignatureMenu.defaults);
    super(params);
  }
  static get ctor() {
    return 'SuiTimeSignatureMenu';
  }
  get ctor() {
    return SuiTimeSignatureMenu.ctor;
  }
  static get defaults() {
    SuiTimeSignatureMenu._defaults = SuiTimeSignatureMenu._defaults ? SuiTimeSignatureMenu._defaults :
      {
        label: 'Time Sig',
        menuItems: [{
          icon: 'sixeight',
          text: '6/8',
          value: '6/8',
        }, {
          icon: 'fourfour',
          text: '4/4',
          value: '4/4',
        }, {
          icon: 'threefour',
          text: '3/4',
          value: '3/4',
        }, {
          icon: 'twofour',
          text: '2/4',
          value: '2/4',
        }, {
          icon: 'twelveeight',
          text: '12/8',
          value: '12/8',
        }, {
          icon: 'seveneight',
          text: '7/8',
          value: '7/8',
        }, {
          icon: 'fiveeight',
          text: '5/8',
          value: '5/8',
        }, {
          icon: '',
          text: 'Other',
          value: 'TimeSigOther',
        }, {
          icon: '',
          text: 'Cancel',
          value: 'cancel'
        }]
      };
    return SuiTimeSignatureMenu._defaults;
  }

  selection(ev) {
    var text = $(ev.currentTarget).attr('data-value');

    if (text === 'TimeSigOther') {
      SuiTimeSignatureDialog.createAndDisplay({
        view: this.view,
        completeNotifier: this.completeNotifier,
        closeMenuPromise: this.closePromise,
        undoBuffer: this.view.undoBuffer,
        eventSource: this.eventSource
      });
      this.complete();
      return;
    }
    this.view.setTimeSignature(text);
    this.complete();
  }

  keydown() {}
}

// eslint-disable-next-line no-unused-vars
class SuiKeySignatureMenu extends suiMenuBase {
  constructor(params) {
    params = (typeof(params) !== 'undefined' ? params : {});
    Vex.Merge(params, SuiKeySignatureMenu.defaults);
    super(params);
  }
  static get ctor() {
    return 'SuiKeySignatureMenu';
  }
  get ctor() {
    return SuiKeySignatureMenu.ctor;
  }
  static get defaults() {
    SuiKeySignatureMenu._defaults = typeof(SuiKeySignatureMenu._defaults) !== 'undefined'
      ? SuiKeySignatureMenu._defaults :
      {
        label: 'Key',
        menuItems: [{
          icon: 'key-sig-c',
          text: 'C Major',
          value: 'KeyOfC',
        }, {
          icon: 'key-sig-f',
          text: 'F Major',
          value: 'KeyOfF',
        }, {
          icon: 'key-sig-g',
          text: 'G Major',
          value: 'KeyOfG',
        }, {
          icon: 'key-sig-bb',
          text: 'Bb Major',
          value: 'KeyOfBb'
        }, {
          icon: 'key-sig-d',
          text: 'D Major',
          value: 'KeyOfD'
        }, {
          icon: 'key-sig-eb',
          text: 'Eb Major',
          value: 'KeyOfEb'
        }, {
          icon: 'key-sig-a',
          text: 'A Major',
          value: 'KeyOfA'
        }, {
          icon: 'key-sig-ab',
          text: 'Ab Major',
          value: 'KeyOfAb'
        }, {
          icon: 'key-sig-e',
          text: 'E Major',
          value: 'KeyOfE'
        }, {
          icon: 'key-sig-bd',
          text: 'Db Major',
          value: 'KeyOfDb'
        }, {
          icon: 'key-sig-b',
          text: 'B Major',
          value: 'KeyOfB'
        }, {
          icon: 'key-sig-fs',
          text: 'F# Major',
          value: 'KeyOfF#'
        }, {
          icon: 'key-sig-cs',
          text: 'C# Major',
          value: 'KeyOfC#'
        },
        {
          icon: '',
          text: 'Cancel',
          value: 'cancel'
        }],
        menuContainer: '.menuContainer'
      };
    return SuiKeySignatureMenu._defaults;
  }

  selection(ev) {
    let keySig = $(ev.currentTarget).attr('data-value');
    keySig = (keySig === 'cancel' ? keySig : keySig.substring(5, keySig.length));
    if (keySig === 'cancel') {
      return;
    }
    this.view.addKeySignature(keySig);
    this.complete();
  }
  keydown() {}
}

// eslint-disable-next-line no-unused-vars
class SuiStaffModifierMenu extends suiMenuBase {
  constructor(params) {
    params = (typeof(params) !== 'undefined' ? params : {});
    Vex.Merge(params, SuiStaffModifierMenu.defaults);
    super(params);
  }
  static get ctor() {
    return 'SuiStaffModifierMenu';
  }
  get ctor() {
    return SuiStaffModifierMenu.ctor;
  }

  static get defaults() {
    SuiStaffModifierMenu._defaults = typeof(SuiStaffModifierMenu._defaults) !== 'undefined' ? SuiStaffModifierMenu._defaults :
      {
        label: 'Lines',
        menuItems: [{
          icon: 'cresc',
          text: 'Crescendo',
          value: 'crescendo'
        }, {
          icon: 'decresc',
          text: 'Decrescendo',
          value: 'decrescendo'
        }, {
          icon: 'slur',
          text: 'Slur',
          value: 'slur'
        }, {
          icon: 'slur',
          text: 'Tie',
          value: 'tie'
        }, {
          icon: 'ending',
          text: 'nth ending',
          value: 'ending'
        },
        {
          icon: '',
          text: 'Cancel',
          value: 'cancel'
        }],
        menuContainer: '.menuContainer'
      };
    return SuiStaffModifierMenu._defaults;
  }
  selection(ev) {
    var op = $(ev.currentTarget).attr('data-value');
    if (op === 'ending') {
      this.view.addEnding();
    } else if (op === 'slur') {
      this.view.slur();
    }  else if (op === 'tie') {
      this.view.tie();
    } else if (op === 'crescendo') {
      this.view.crescendo();
    } else if (op === 'decrescendo') {
      this.view.decrescendo();
    }
    // else cancel...
    this.complete();
  }
  keydown() {
  }
}

// eslint-disable-next-line no-unused-vars
class SuiLanguageMenu extends suiMenuBase {
  constructor(params) {
    params = (typeof(params) !== 'undefined') ? params : {};
    Vex.Merge(params, SuiLanguageMenu.defaults);
    super(params);
  }
  static get ctor() {
    return 'SuiLanguageMenu';
  }
  get ctor() {
    return SuiLanguageMenu.ctor;
  }
  static get defaults() {
    SuiLanguageMenu._defaults = SuiLanguageMenu._defaults ? SuiLanguageMenu._defaults :
      {
        label: 'Language',
        menuItems: [{
          icon: '',
          text: 'English',
          value: 'en'
        }, {
          icon: '',
          text: 'Deutsch',
          value: 'de'
        }, {
          icon: '',
          text: '',
          value: 'ar'
        }, {
          icon: '',
          text: 'Cancel',
          value: 'cancel'
        }],
        menuContainer: '.menuContainer'
      };
    return SuiLanguageMenu._defaults;
  }
  selection(ev) {
    var op = $(ev.currentTarget).attr('data-value');

    SmoTranslator.setLanguage(op);
    this.complete();
  }
  keydown() {
  }
}
// eslint-disable-next-line no-unused-vars
class SuiMeasureMenu extends suiMenuBase {
  static get defaults() {
    SuiMeasureMenu._defaults = SuiMeasureMenu._defaults ? SuiMeasureMenu._defaults : {
      label: 'Measure',
      menuItems: [
        {
          icon: '',
          text: 'Add Measures',
          value: 'addMenuCmd'
        }, {
          icon: 'icon-cross',
          text: 'Delete Selected Measures',
          value: 'deleteSelected'
        }, {
          icon: '',
          text: 'Format Measure',
          value: 'formatMeasureDialog'
        }, {
          icon: '',
          text: 'Cancel',
          value: 'cancel'
        }
      ]
    };
    return SuiMeasureMenu._defaults;
  }
  static get ctor() {
    return 'SuiMeasureMenu';
  }
  get ctor() {
    return SuiMeasureMenu.ctor;
  }

  constructor(params) {
    params = (typeof(params) !== 'undefined') ? params : {};
    Vex.Merge(params, SuiMeasureMenu.defaults);
    super(params);
  }
  selection(ev) {
    const text = $(ev.currentTarget).attr('data-value');
    if (text === 'formatMeasureDialog') {
      SuiMeasureDialog.createAndDisplay({
        view: this.view,
        completeNotifier: this.completeNotifier,
        closeMenuPromise: this.closePromise,
        eventSource: this.eventSource
      });
      this.complete();
      return;
    }
    if (text === 'addMenuCmd') {
      SuiInsertMeasures.createAndDisplay({
        view: this.view,
        completeNotifier: this.completeNotifier,
        closeMenuPromise: this.closePromise,
        eventSource: this.eventSource
      });
      this.complete();
    }
    if (text === 'addMenuAfterCmd') {
      this.keyCommands.addMeasure({ shiftKey: true });
      this.complete();
    }
    if (text === 'deleteSelected') {
      this.view.deleteMeasure();
    }
    this.complete();
  }
}

// eslint-disable-next-line no-unused-vars
class SuiAddStaffMenu extends suiMenuBase {
  constructor(params) {
    params = (typeof(params) !== 'undefined' ? params : {});
    Vex.Merge(params, SuiAddStaffMenu.defaults);
    super(params);
  }
  static get ctor() {
    return 'SuiAddStaffMenu';
  }
  get ctor() {
    return SuiAddStaffMenu.ctor;
  }

  static get defaults() {
    SuiAddStaffMenu._defaults = SuiAddStaffMenu._defaults ? SuiAddStaffMenu._defaults : {
      label: 'Add Staff',
      menuItems: [
        {
          icon: 'treble',
          text: 'Treble Clef Staff',
          value: 'trebleInstrument'
        }, {
          icon: 'bass',
          text: 'Bass Clef Staff',
          value: 'bassInstrument'
        }, {
          icon: 'alto',
          text: 'Alto Clef Staff',
          value: 'altoInstrument'
        }, {
          icon: 'tenor',
          text: 'Tenor Clef Staff',
          value: 'tenorInstrument'
        }, {
          icon: '',
          text: 'Staff Groups',
          value: 'staffGroups'
        }, {
          icon: 'cancel-circle',
          text: 'Remove Staff',
          value: 'remove'
        }, {
          icon: '',
          text: 'Cancel',
          value: 'cancel'
        }
      ],
      menuContainer: '.menuContainer'
    };
    return SuiAddStaffMenu._defaults;
  }
  static get instrumentMap() {
    return {
      'trebleInstrument': {
        instrumentInfo: {
          instrumentName: 'Treble Clef Staff',
          keyOffset: 0,
          clef: 'treble'
        }
      },
      'bassInstrument': {
        instrumentInfo: {
          instrumentName: 'Bass Clef Staff',
          keyOffset: 0,
          clef: 'bass'
        }
      },
      'altoInstrument': {
        instrumentInfo: {
          instrumentName: 'Alto Clef Staff',
          keyOffset: 0,
          clef: 'alto'
        }
      },
      'tenorInstrument': {
        instrumentInfo: {
          instrumentName: 'Tenor Clef Staff',
          keyOffset: 0,
          clef: 'tenor'
        }
      },
      'remove': {
        instrumentInfo: {
          instrumentName: 'Remove clef',
          keyOffset: 0,
          clef: 'tenor'
        }
      }
    };
  }
  execStaffGroups() {
    SuiStaffGroupDialog.createAndDisplay(
      {
        eventSource: this.eventSource,
        keyCommands: this.keyCommands,
        completeNotifier: this.completeNotifier,
        view: this.view,
        startPromise: this.closePromise
      }
    );
  }

  selection(ev) {
    const op = $(ev.currentTarget).attr('data-value');
    if (op === 'remove') {
      this.view.removeStaff();
      this.complete();
    } else if (op === 'staffGroups') {
      this.execStaffGroups();
      this.complete();
    } else if (op === 'cancel') {
      this.complete();
    } else {
      const instrument = SuiAddStaffMenu.instrumentMap[op];
      this.view.addStaff(instrument);
      this.complete();
    }
  }
  keydown() {}
}
;
class Qwerty {
  static get navigationElements() {

    var kbRows =
    [
      { row: '1234567890-=',shifted:'!@#$%^&*()_+'},
      { row: 'QWERTYUIOP[]',shifted:'QWERTYIOP{}'},
      { row:"ASDFGHJKL;'", shifted:'ASDFGHJKL:"'},
      { row:'ZXCVBNM,./',shifted:'ZXCVBNM<>?'}
    ];
    var arrows = [
      {icon: 'icon-arrow-left',text:'', shifted:'',classes:'helpKey',dataKey:'ArrowLeft'},
      {icon: 'icon-arrow-right',text:'', shifted:'',classes:'helpKey',dataKey:'ArrowRight'},
      {icon:'',text:'Space',classes:'wideKey',shifted:'',dataKey:'Space'},
      {icon: 'icon-arrow-up',text:'', shifted:'',classes:'helpKey',dataKey:'ArrowUp'},
      {icon: 'icon-arrow-down' ,text:'', shifted:'',classes:'helpKey',dataKey:'ArrowDown'},
      {icon: '' ,text:'Ins', shifted:'',classes:'helpKey',dataKey:'Insert'},
      {icon: '' ,text:'Del', shifted:'',classes:'helpKey',dataKey:'Delete'}
    ];
    var keyRows = {};
    var labels = ['topNumbers','keys1','keys2','keys3','arrows'];
    var j = 0;

    kbRows.forEach((kbRow) => {
      var str = kbRow.row;
      var shifted = kbRow.shifted;
      var keys = [];
      for (var i = 0;i < str.length;++i) {
        if (j === 2 && i === 0) {
          keys.push({icon:'',text:'Shift',classes:'wideKey',dataKey:'shift'});
        }
        if (j === 3 && i === 0) {
          keys.push({icon:'',text:'Ctrl',classes:'wideKey',dataKey:'ctrl'});
          keys.push({icon:'',text:'Alt',classes:'helpKey',dataKey:'alt'});
        }
        keys.push({icon:'', text:str[i],shifted:shifted[i],classes:'helpKey',dataKey:str[i]});
      }
      keyRows[labels[j]] = {id:labels[j],rows:keys};
      j += 1;
    });
    keyRows[labels[j]] = {id:labels[j],rows:arrows};
    return keyRows;
  }
  static flashShift() {
    if (Qwerty._shiftTime) {
      Qwerty._shiftTime = 0;
      setTimeout(function() {
        Qwerty.flashShift();
      },1000);
    } else {
      $('.kb-float').removeClass('shifted');
    }
  }

  static displayForDuration() {
    Qwerty.displayAll();
    $('#row-0').hide();
    $('#row-1').hide();
    $('#row-4').hide();
  }

  static displayForTuplet() {
    Qwerty.displayAll();
    $('#row-1').hide();
    $('#row-2').hide();
  }

  static displayAll() {
    $('#row-0').show();
    $('#row-1').show();
    $('#row-2').show();
    $('#row-3').show();
    $('#row-4').show();
  }

  static _flashButton(key) {
    var e = $('[data-key="'+key+'"]');
    if (!e.length) {
       e = $('[data-shift="'+key+'"]');
    }
    if (e.length) {
      $(e).removeClass('transition-button');
      $(e).addClass('reverse-button');
      setTimeout(function() {
        $(e).removeClass('reverse-button');
        $(e).addClass('transition-button');
      },750);
    }
  }
  static get editingKeys()  {
    return ['ArrowLeft','ArrowRight','ArrowUp','ArrowDown','Insert','Delete'];
  }
  static handleKeyEvent(evdata) {
    if (Qwerty.editingKeys.indexOf(evdata.code) >= 0) {
      Qwerty._flashButton(evdata.code);
    } else if (evdata.key.length === 1
      && evdata.key.charCodeAt(0) > 32
      && evdata.key.charCodeAt(0) < 127) {
      Qwerty._flashButton(evdata.key.toUpperCase());
    }
    if (evdata.code === 'Space') {
      Qwerty._flashButton('Space');
    }
    if (evdata.ctrlKey) {
      Qwerty._flashButton('ctrl');
    }
    if (evdata.shiftKey) {
      Qwerty._flashButton('shift');
      $('.kb-float').addClass('shifted');
      Qwerty._shiftTime = 1;
      Qwerty.flashShift();
    }
    if (evdata.altKey) {
      Qwerty._flashButton('alt');
    }
  }

  static _kbButton(buttons) {
    var b = htmlHelpers.buildDom;
    var r = b('span').classes('keyContainer');
    buttons.rows.forEach((button) => {
      var text = button.text;
      var shiftedText = button.shifted ? button.shifted : text;
      r.append(b('span').classes(button.icon + ' ' + button.classes)
        .attr('data-key',button.dataKey).attr('data-shift',shiftedText)
          .append(b('span').classes('button-text').text(text))
          .append(b('span').classes('button-shifted').text(shiftedText))
      );
    });
    return r;
  }
  static _buttonBlock(buttons,id) {
    var b = htmlHelpers.buildDom;
    var r = b('div').classes('keyBlock').attr('id', id);
    r.append(Qwerty._kbButton(buttons));
    return r;
  }

  static _buildElements(rows) {
    var b = htmlHelpers.buildDom;
    var r = b('div').classes('buttonLine')
      .append(b('span').classes('icon icon-move'));
    var keys = Object.keys(rows);
    var rowIx = 0;
    keys.forEach((key) => {
      var row = rows[key];
      r.append(Qwerty._buttonBlock(row,'row-'+rowIx));
      rowIx += 1;
    });
    return r;
  }
  static displayKb() {
    $('body').addClass('showQwerty');
    $('.qwertyKb').html('');
    var b = htmlHelpers.buildDom;
    var r = b('div').classes('kb-float');
    r.append(Qwerty._buildElements(Qwerty.navigationElements));
    $('.qwertyKb').append(r.dom());

    var cb = function (x, y) {}
    htmlHelpers.draggable({
      parent: $('.qwertyKb'),
      handle: $('.qwertyKb').find('.icon-move'),
      animateDiv:'.draganime',
      cb: cb,
      moveParent: true
    });
  }


}
;//# sourceMappingURL=../src/ui/ribbon.js

// ## RibbonButtons
// Render the ribbon buttons based on group, function, and underlying UI handler.
// Also handles UI events.
// ### RibbonButton methods
// ---
class RibbonButtons {
  static get paramArray() {
    return ['ribbonButtons', 'ribbons', 'keyCommands', 'controller', 'menus', 'eventSource', 'view'];
  }
  static _buttonHtml(containerClass, buttonId, buttonClass, buttonText, buttonIcon, buttonKey) {
    const b = htmlHelpers.buildDom;
    const r = b('div').classes(containerClass).append(b('button').attr('id', buttonId).classes(buttonClass).append(
      b('span').classes('left-text').append(
        b('span').classes('text-span').text(buttonText)).append(
        b('span').classes('ribbon-button-text icon ' + buttonIcon))).append(
      b('span').classes('ribbon-button-hotkey').text(buttonKey)));
    return r.dom();
  }
  static get translateButtons() {
    if (!RibbonButtons._translateButtons) {
      RibbonButtons._translateButtons = [];
    }
    return RibbonButtons._translateButtons;
  }
  constructor(parameters) {
    smoSerialize.filteredMerge(RibbonButtons.paramArray, parameters, this);
    this.ribbonButtons = parameters.ribbonButtons;
    this.ribbons = parameters.ribbons;
    this.collapsables = [];
    this.collapseChildren = [];
  }
  _executeButtonModal(buttonElement, buttonData) {
    const ctor = eval(buttonData.ctor);
    ctor.createAndDisplay(
      {
        undoBuffer: this.keyCommands.undoBuffer,
        eventSource: this.eventSource,
        keyCommands: this.keyCommands,
        completeNotifier: this.controller,
        view: this.view
      }
    );
  }
  _executeButtonMenu(buttonElement, buttonData) {
    this.menus.slashMenuMode(this.controller);
    this.menus.createMenu(buttonData.ctor);
  }
  _rebindController() {
    this.controller.render();
    this.controller.bindEvents();
  }
  _executeButton(buttonElement, buttonData) {
    if (buttonData.action === 'modal') {
      this._executeButtonModal(buttonElement, buttonData);
      return;
    }
    if (buttonData.action === 'menu' || buttonData.action === 'collapseChildMenu') {
      this._executeButtonMenu(buttonElement, buttonData);
    }
  }

  _bindButton(buttonElement, buttonData) {
    this.eventSource.domClick(buttonElement, this, '_executeButton', buttonData);
  }
  _createCollapsibleButtonGroups(selector) {
    let containerClass = {};
    // Now all the button elements have been bound.  Join child and parent buttons
    // For all the children of a button group, add it to the parent group
    this.collapseChildren.forEach((b) => {
      containerClass = 'ribbonButtonContainer';
      if (b.action === 'collapseGrandchild') {
        containerClass = 'ribbonButtonContainerMore';
      }
      const buttonHtml = RibbonButtons._buttonHtml(
        containerClass, b.id, b.classes, b.leftText, b.icon, b.rightText);
      if (b.dataElements) {
        const bkeys = Object.keys(b.dataElements);
        bkeys.forEach((bkey) => {
          var de = b.dataElements[bkey];
          $(buttonHtml).find('button').attr('data-' + bkey, de);
        });
      }
      // Bind the child button actions
      const parent = $(selector).find('.collapseContainer[data-group="' + b.group + '"]');
      $(parent).append(buttonHtml);
      const el = $(selector).find('#' + b.id);
      this._bindButton(el, b);
    });

    this.collapsables.forEach((cb) => {
      // Bind the events of the parent button
      cb.bind();
    });
  }

  static isCollapsible(action) {
    return ['collapseChild', 'collapseChildMenu', 'collapseGrandchild', 'collapseMore'].indexOf(action) >= 0;
  }

  static isBindable(action) {
    return ['collapseChildMenu', 'menu', 'modal'].indexOf(action) >= 0;
  }

  // ### _createButtonHtml
  // For each button, create the html and bind the events based on
  // the button's configured action.
  _createRibbonHtml(buttonAr, selector) {
    let buttonClass = '';
    buttonAr.forEach((buttonId) => {
      const buttonData = this.ribbonButtons.find((e) =>
        e.id === buttonId
      );
      if (buttonData) {
        if (buttonData.leftText) {
          RibbonButtons.translateButtons.push({ buttonId: buttonData.id, buttonText: buttonData.leftText });
        }
        // collapse child is hidden until the parent button is selected, exposing the button group
        if (RibbonButtons.isCollapsible(buttonData.action)) {
          this.collapseChildren.push(buttonData);
        }
        if (buttonData.action !== 'collapseChild') {
          // else the button has a specific action, such as a menu or dialog, or a parent button
          // for translation, add the menu name to the button class
          buttonClass = buttonData.classes;
          if (buttonData.action === 'menu' || buttonData.action === 'modal') {
            buttonClass += ' ' + buttonData.ctor;
          }
          const buttonHtml = RibbonButtons._buttonHtml('ribbonButtonContainer',
            buttonData.id, buttonClass, buttonData.leftText, buttonData.icon, buttonData.rightText);
          $(buttonHtml).attr('data-group', buttonData.group);
          $(selector).append(buttonHtml);
          const buttonElement = $('#' + buttonData.id);
          // If this is a collabsable button, create it, otherwise bind its execute function.
          if (buttonData.action === 'collapseParent') {
            $(buttonHtml).addClass('collapseContainer');
            // collapseParent
            this.collapsables.push(new CollapseRibbonControl({
              ribbonButtons: this.ribbonButtons,
              view: this.view,
              menus: this.menus,
              eventSource: this.eventSource,
              controller: this.controller,
              keyCommands: this.keyCommands,
              buttonElement,
              buttonData
            }));
          } else {
            this.eventSource.domClick(buttonElement, this, '_executeButton', buttonData);
          }
        }
      }
    });
  }

  createRibbon(buttonDataArray, parentElement) {
    this._createRibbonHtml(buttonDataArray, parentElement);
    this._createCollapsibleButtonGroups(parentElement);
  }

  display() {
    $('body .controls-left').html('');
    $('body .controls-top').html('');

    const lbuttons = this.ribbons.left;
    this.createRibbon(lbuttons, 'body .controls-left');

    const tbuttons = this.ribbons.top;
    this.createRibbon(tbuttons, 'body .controls-top');
  }
}

// eslint-disable-next-line no-unused-vars
class DebugButtons {
  constructor(parameters) {
    this.buttonElement = parameters.buttonElement;
    this.buttonData = parameters.buttonData;
    this.keyCommands = parameters.keyCommands;
  }
  bind() {
    $(this.buttonElement).off('click').on('click', () => {
      $('body').trigger('redrawScore');
    });
  }
}

// ## ExtendedCollapseParent
// Muse-style '...' buttons for less-common operations
// eslint-disable-next-line no-unused-vars
class ExtendedCollapseParent {
  constructor(parameters) {
    this.buttonElement = parameters.buttonElement;
    this.buttonData = parameters.buttonData;
    this.keyCommands = parameters.keyCommands;
  }
  bind() {
    $(this.buttonElement).off('click').on('click', () => {
      $(this.buttonElement).closest('.collapseContainer').toggleClass('expanded-more');
    });
  }
}
// eslint-disable-next-line no-unused-vars
class BeamButtons {
  constructor(parameters) {
    this.buttonElement = parameters.buttonElement;
    this.buttonData = parameters.buttonData;
    this.keyCommands = parameters.keyCommands;
  }
  operation() {
    if (this.buttonData.id === 'breakBeam') {
      this.keyCommands.toggleBeamGroup();
    } else if (this.buttonData.id === 'beamSelections') {
      this.keyCommands.beamSelections();
    } else if (this.buttonData.id === 'toggleBeamDirection') {
      this.keyCommands.toggleBeamDirection();
    }
  }
  bind() {
    $(this.buttonElement).off('click').on('click', () => {
      this.operation();
    });
  }
}
// eslint-disable-next-line no-unused-vars
class MicrotoneButtons {
  constructor(parameters) {
    this.buttonElement = parameters.buttonElement;
    this.buttonData = parameters.buttonData;
    this.keyCommands = parameters.keyCommands;
    this.view = parameters.view;
  }
  applyButton(el) {
    let pitch = 0;
    if (this.view.tracker.selections.length === 1 &&
      this.view.tracker.selections[0].selector.pitches &&
      this.view.tracker.selections[0].selector.pitches.length
    ) {
      pitch = this.view.tracker.selections[0].selector.pitches[0];
    }
    const tn = new SmoMicrotone({ tone: el.id, pitch });
    this.view.addRemoveMicrotone(tn);
    suiOscillator.playSelectionNow(this.view.tracker.selections[0]);
  }
  bind() {
    var self = this;
    $(this.buttonElement).off('click').on('click', () => {
      self.applyButton(self.buttonData);
    });
  }
}

// eslint-disable-next-line no-unused-vars
class DurationButtons {
  constructor(parameters) {
    this.buttonElement = parameters.buttonElement;
    this.buttonData = parameters.buttonData;
    this.keyCommands = parameters.keyCommands;
  }
  setDuration() {
    if (this.buttonData.id === 'GrowDuration') {
      this.keyCommands.doubleDuration();
    } else if (this.buttonData.id === 'LessDuration') {
      this.keyCommands.halveDuration();
    } else if (this.buttonData.id === 'GrowDurationDot') {
      this.keyCommands.dotDuration();
    } else if (this.buttonData.id === 'LessDurationDot') {
      this.keyCommands.undotDuration();
    } else if (this.buttonData.id === 'TripletButton') {
      this.keyCommands.makeTupletCommand(3);
    } else if (this.buttonData.id === 'QuintupletButton') {
      this.keyCommands.makeTupletCommand(5);
    } else if (this.buttonData.id === 'SeptupletButton') {
      this.keyCommands.makeTupletCommand(7);
    } else if (this.buttonData.id === 'NoTupletButton') {
      this.keyCommands.unmakeTuplet();
    }
  }
  bind() {
    var self = this;
    $(this.buttonElement).off('click').on('click', () => {
      self.setDuration();
    });
  }
}

// eslint-disable-next-line no-unused-vars
class VoiceButtons {
  constructor(parameters) {
    this.buttonElement = parameters.buttonElement;
    this.buttonData = parameters.buttonData;
    this.view = parameters.view;
  }
  doAction() {
    let voiceIx = 0;
    if (this.buttonData.id === 'V2Button') {
      voiceIx = 1;
    } else if (this.buttonData.id === 'V3Button') {
      voiceIx = 2;
    } else if (this.buttonData.id === 'V4Button') {
      voiceIx = 3;
    } else if (this.buttonData.id === 'VXButton') {
      this.view.depopulateVoice();
      return;
    }
    this.view.populateVoice(voiceIx);
  }
  bind() {
    $(this.buttonElement).off('click').on('click', () => {
      this.doAction();
    });
  }
}
// eslint-disable-next-line no-unused-vars
class NoteButtons {
  constructor(parameters) {
    this.buttonElement = parameters.buttonElement;
    this.buttonData = parameters.buttonData;
    this.keyCommands = parameters.keyCommands;
  }
  setPitch() {
    if (this.buttonData.id === 'UpNoteButton') {
      this.keyCommands.transposeUp();
    } else if (this.buttonData.id === 'DownNoteButton') {
      this.keyCommands.transposeDown();
    } else if (this.buttonData.id === 'UpOctaveButton') {
      this.keyCommands.upOctave();
    } else if (this.buttonData.id === 'DownOctaveButton') {
      this.keyCommands.downOctave();
    } else if (this.buttonData.id === 'ToggleAccidental') {
      this.keyCommands.toggleEnharmonic();
    } else if (this.buttonData.id === 'ToggleCourtesy') {
      this.keyCommands.toggleCourtesyAccidental();
    } else if (this.buttonData.id === 'ToggleRestButton') {
      this.keyCommands.makeRest();
    } else if (this.buttonData.id === 'AddGraceNote') {
      this.keyCommands.addGraceNote();
    } else if (this.buttonData.id === 'SlashGraceNote') {
      this.keyCommands.slashGraceNotes();
    } else if (this.buttonData.id === 'RemoveGraceNote') {
      this.keyCommands.removeGraceNote();
    } else if (this.buttonData.id === 'XNoteHead') {
      this.keyCommands.setNoteHead();
    } else {
      this.keyCommands.setPitchCommand(this.buttonData.rightText);
    }
  }
  bind() {
    var self = this;
    $(this.buttonElement).off('click').on('click', () => {
      self.setPitch();
    });
  }
}

// eslint-disable-next-line no-unused-vars
class ChordButtons {
  constructor(parameters) {
    this.buttonElement = parameters.buttonElement;
    this.buttonData = parameters.buttonData;
    this.keyCommands = parameters.keyCommands;
    this.view = parameters.view;
    this.interval = parseInt($(this.buttonElement).attr('data-interval'), 10);
    this.direction = parseInt($(this.buttonElement).attr('data-direction'), 10);
  }
  collapseChord() {
    this.keyCommands.collapseChord();
  }
  setInterval() {
    this.keyCommands.intervalAdd(this.interval, this.direction);
  }
  bind() {
    $(this.buttonElement).off('click').on('click', () => {
      if ($(this.buttonElement).attr('id') === 'CollapseChordButton') {
        this.collapseChord();
        return;
      }
      self.setInterval();
    });
  }
}

// eslint-disable-next-line no-unused-vars
class StaveButtons {
  constructor(parameters) {
    Vex.Merge(this, parameters);
  }
  addClef(clef, clefName) {
    var instrument = {
      instrumentName: clefName,
      keyOffset: 0,
      clef
    };
    this.view.changeInstrument(instrument);
  }
  clefTreble() {
    this.addClef('treble', 'Treble Instrument');
  }
  clefBass() {
    this.addClef('bass', 'Bass Instrument');
  }
  clefAlto() {
    this.addClef('alto', 'Alto Instrument');
  }
  clefTenor() {
    this.addClef('tenor', 'Tenor Instrument');
  }
  _clefMove(index) {
    this.view.moveStaffUpDown(index);
  }
  clefMoveUp() {
    this._clefMove(-1, 'up');
  }
  clefMoveDown() {
    this._clefMove(1, 'down');
  }
  _addStaffGroup(type) {
    this.view.addStaffGroupDown(type);
  }
  staffBraceLower() {
    this._addStaffGroup(SmoSystemGroup.connectorTypes.brace);
  }
  staffBracketLower() {
    this._addStaffGroup(SmoSystemGroup.connectorTypes.bracket);
  }
  bind() {
    const self = this;
    $(this.buttonElement).off('click').on('click', () => {
      const id = self.buttonData.id;
      if (typeof(self[id]) === 'function') {
        self[id]();
      }
    });
  }
}

// eslint-disable-next-line no-unused-vars
class MeasureButtons {
  constructor(parameters) {
    Vex.Merge(this, parameters);
  }
  endRepeat() {
    this.view.setBarline(SmoBarline.positions.end, SmoBarline.barlines.endRepeat);
  }
  startRepeat() {
    this.view.setBarline(SmoBarline.positions.start, SmoBarline.barlines.startRepeat);
  }
  singleBarStart() {
    this.view.setBarline(SmoBarline.positions.start, SmoBarline.barlines.singleBar);
  }
  singleBarEnd() {
    this.view.setBarline(SmoBarline.positions.end, SmoBarline.barlines.singleBar);
  }
  doubleBar() {
    this.view.setBarline(SmoBarline.positions.end, SmoBarline.barlines.doubleBar);
  }
  endBar() {
    this.view.setBarline(SmoBarline.positions.end, SmoBarline.barlines.endBar);
  }
  coda() {
    this.view.setRepeatSymbol(SmoRepeatSymbol.positions.end, SmoRepeatSymbol.symbols.Coda);
  }
  toCoda() {
    this.view.setRepeatSymbol(SmoRepeatSymbol.positions.end, SmoRepeatSymbol.symbols.ToCoda);
  }
  segno() {
    this.view.setRepeatSymbol(SmoRepeatSymbol.positions.end, SmoRepeatSymbol.symbols.Segno);
  }
  dsAlCoda() {
    this.view.setRepeatSymbol(SmoRepeatSymbol.positions.end, SmoRepeatSymbol.symbols.DsAlCoda);
  }
  dcAlCoda() {
    this.view.setRepeatSymbol(SmoRepeatSymbol.positions.end, SmoRepeatSymbol.symbols.DcAlCoda);
  }
  dsAlFine() {
    this.view.setRepeatSymbol(SmoRepeatSymbol.positions.end, SmoRepeatSymbol.symbols.DsAlFine);
  }
  dcAlFine() {
    this.view.setRepeatSymbol(SmoRepeatSymbol.positions.end, SmoRepeatSymbol.symbols.DcAlFine);
  }
  fine() {
    this.view.setRepeatSymbol(SmoRepeatSymbol.positions.end, SmoRepeatSymbol.symbols.Fine);
  }
  nthEnding() {
    this.view.addEnding();
  }
  handleEvent(event, method) {
    this[method]();
  }
  bind() {
    this.eventSource.domClick(this.buttonElement, this, 'handleEvent', this.buttonData.id);
  }
}

// eslint-disable-next-line no-unused-vars
class PlayerButtons {
  constructor(parameters) {
    Vex.Merge(this, parameters);
  }
  playButton() {
    this.keyCommands.playScore();
  }
  stopButton() {
    this.keyCommands.stopPlayer();
  }
  pauseButton() {
    this.keyCommands.pausePlayer();
  }
  bind() {
    this.eventSource.domClick(this.buttonElement, this, this.buttonData.id);
  }
}

// eslint-disable-next-line no-unused-vars
class DisplaySettings {
  constructor(parameters) {
    Vex.Merge(this, parameters);
  }

  refresh() {
    this.view.refreshViewport();
  }
  zoomout() {
    this.view.score.layout.zoomMode = SmoScore.zoomModes.zoomScale;
    this.view.score.layout.zoomScale = this.view.score.layout.zoomScale * 1.1;
    this.view.renderer.setViewport();
    this.view.renderer.setRefresh();
  }
  zoomin() {
    this.view.score.layout.zoomMode = SmoScore.zoomModes.zoomScale;
    this.view.score.layout.zoomScale = this.view.score.layout.zoomScale / 1.1;
    this.view.renderer.setViewport();
    this.view.renderer.setRefresh();
  }
  playButton2() {
    this.keyCommands.playScore();
  }
  stopButton2() {
    this.keyCommands.stopPlayer();
  }
  bind() {
    this.eventSource.domClick(this.buttonElement, this, this.buttonData.id);
  }
}
// eslint-disable-next-line no-unused-vars
class TextButtons {
  constructor(parameters) {
    Vex.Merge(this, parameters);
    this.menus = this.controller.menus;
  }
  lyrics() {
    SuiLyricDialog.createAndDisplay(
      {
        buttonElement: this.buttonElement,
        buttonData: this.buttonData,
        completeNotifier: this.controller,
        view: this.view,
        undoBuffer: this.keyCommands.undoBuffer,
        eventSource: this.eventSource,
        keyCommands: this.keyCommands,
        parser: SmoLyric.parsers.lyric
      }
    );
    // tracker, selection, controller
  }
  chordChanges() {
    SuiChordChangeDialog.createAndDisplay(
      {
        buttonElement: this.buttonElement,
        buttonData: this.buttonData,
        completeNotifier: this.controller,
        view: this.view,
        eventSource: this.eventSource,
        keyCommands: this.keyCommands,
        parser: SmoLyric.parsers.chord
      }
    );
  }
  rehearsalMark() {
    this.view.toggleRehearsalMark();
  }
  _invokeMenu(cmd) {
    this.menus.slashMenuMode(this.controller);
    this.menus.createMenu(cmd);
  }

  addTextMenu() {
    SuiTextTransformDialog.createAndDisplay(
      {
        buttonElement: this.buttonElement,
        buttonData: this.buttonData,
        completeNotifier: this.controller,
        tracker: this.view.tracker,
        view: this.view,
        eventSource: this.eventSource,
        keyCommands: this.keyCommands
      });
  }
  addDynamicsMenu() {
    this._invokeMenu('SuiDynamicsMenu');
  }
  bind() {
    this.eventSource.domClick(this.buttonElement, this, this.buttonData.id);
  }
}

// eslint-disable-next-line no-unused-vars
class NavigationButtons {
  static get directionsTrackerMap() {
    return {
      navLeftButton: 'moveSelectionLeft',
      navRightButton: 'moveSelectionRight',
      navUpButton: 'moveSelectionUp',
      navDownButton: 'moveSelectionDown',
      navFastForward: 'moveSelectionRightMeasure',
      navRewind: 'moveSelectionLeftMeasure',
      navGrowLeft: 'growSelectionLeft',
      navGrowRight: 'growSelectionRight'
    };
  }
  constructor(parameters) {
    Vex.Merge(this, parameters);
  }

  _moveTracker() {
    this.view.tracker[NavigationButtons.directionsTrackerMap[this.buttonData.id]]();
  }
  bind() {
    this.eventSource.domClick(this.buttonElement, this, '_moveTracker');
  }
}
// eslint-disable-next-line no-unused-vars
class ArticulationButtons {
  static get articulationIdMap() {
    return {
      accentButton: SmoArticulation.articulations.accent,
      tenutoButton: SmoArticulation.articulations.tenuto,
      staccatoButton: SmoArticulation.articulations.staccato,
      marcatoButton: SmoArticulation.articulations.marcato,
      pizzicatoButton: SmoArticulation.articulations.pizzicato,
      fermataButton: SmoArticulation.articulations.fermata,
      mordentButton: SmoOrnament.ornaments.mordent,
      mordentInvertedButton: SmoOrnament.ornaments.mordentInverted,
      trillButton: SmoOrnament.ornaments.trill,
      scoopButton: SmoOrnament.ornaments.scoop,
      dropButton: SmoOrnament.ornaments.fall_short,
      dropLongButton: SmoOrnament.ornaments.dropLong,
      doitButton: SmoOrnament.ornaments.doit,
      doitLongButton: SmoOrnament.ornaments.doitLong,
      flipButton: SmoOrnament.ornaments.flip,
      smearButton: SmoOrnament.ornaments.smear
    };
  }
  static get constructors() {
    return {
      accentButton: 'SmoArticulation',
      tenutoButton: 'SmoArticulation',
      staccatoButton: 'SmoArticulation',
      marcatoButton: 'SmoArticulation',
      pizzicatoButton: 'SmoArticulation',
      fermataButton: 'SmoArticulation',
      mordentButton: 'SmoOrnament',
      mordentInvertedButton: 'SmoOrnament',
      trillButton: 'SmoOrnament',
      scoopButton: 'SmoOrnament',
      dropButton: 'SmoOrnament',
      dropLongButton: 'SmoOrnament',
      doitButton: 'SmoOrnament',
      doitLongButton: 'SmoOrnament',
      flipButton: 'SmoOrnament',
      smearButton: 'SmoOrnament'
    };
  }
  constructor(parameters) {
    this.buttonElement = parameters.buttonElement;
    this.buttonData = parameters.buttonData;
    this.keyCommands = parameters.keyCommands;
    this.articulation = ArticulationButtons.articulationIdMap[this.buttonData.id];
    this.eventSource = parameters.eventSource;
    this.ctor = ArticulationButtons.constructors[this.buttonData.id];
  }
  _toggleArticulation() {
    this.showState = !this.showState;
    this.keyCommands.toggleArticulationCommand(this.articulation, this.ctor);
  }
  bind() {
    this.eventSource.domClick(this.buttonElement, this, '_toggleArticulation');
  }
}

// eslint-disable-next-line no-unused-vars
class CollapseRibbonControl {
  static get paramArray() {
    return ['ribbonButtons', 'keyCommands', 'controller', 'view', 'menus', 'buttonData', 'buttonElement',
      'eventSource'];
  }
  constructor(parameters) {
    smoSerialize.filteredMerge(CollapseRibbonControl.paramArray, parameters, this);
    this.childButtons = parameters.ribbonButtons.filter((cb) =>
      cb.group === this.buttonData.group &&
        RibbonButtons.isCollapsible(cb.action)
    );
  }
  _toggleExpand() {
    this.childButtons.forEach((cb) => {
      const el = $('#' + cb.id);
      $(el).toggleClass('collapsed');
      $(el).toggleClass('expanded');
    });

    this.buttonElement.closest('div').toggleClass('expanded');
    this.buttonElement.toggleClass('expandedChildren');
    if (this.buttonElement.hasClass('expandedChildren')) {
      const leftSpan = $(this.buttonElement).find('.ribbon-button-text');
      $(leftSpan).text('');
      $(leftSpan).removeClass(this.buttonData.icon);
      $(this.buttonElement).addClass('icon icon-circle-left');
    } else {
      $(this.buttonElement).removeClass('icon-circle-left');
      const leftSpan = $(this.buttonElement).find('.ribbon-button-text');
      $(leftSpan).addClass(this.buttonData.icon);
      $(leftSpan).text(this.buttonData.leftText);
    }
    // Expand may change music dom, redraw
    $('body').trigger('forceScrollEvent');
  }
  bind() {
    $(this.buttonElement).closest('div').addClass('collapseContainer');
    this.eventSource.domClick(this.buttonElement, this, '_toggleExpand');
    this.childButtons.forEach((cb) => {
      const ctor = eval(cb.ctor);
      const el = $('#' + cb.id);
      const btn = new ctor({
        buttonData: cb,
        buttonElement: el,
        keyCommands: this.keyCommands,
        view: this.view,
        controller: this.controller,
        eventSource: this.eventSource
      });
      if (typeof(btn.bind) === 'function') {
        btn.bind();
      }
    });
  }
}
;

class defaultRibbonLayout {

  static get ribbons() {
    var left = defaultRibbonLayout.leftRibbonIds;
    var top = defaultRibbonLayout.displayIds.concat(defaultRibbonLayout.noteButtonIds).concat(defaultRibbonLayout.navigateButtonIds)
        .concat(defaultRibbonLayout.articulateButtonIds).concat(defaultRibbonLayout.microtoneIds)
        .concat(defaultRibbonLayout.durationIds)
            .concat(defaultRibbonLayout.beamIds).concat(defaultRibbonLayout.measureIds).concat(defaultRibbonLayout.staveIds)
              .concat(defaultRibbonLayout.textIds).concat(defaultRibbonLayout.playerIds)
              .concat(defaultRibbonLayout.voiceButtonIds).concat(defaultRibbonLayout.debugIds);

    return {
      left: left,
      top:top
    };
  }

  static get ribbonButtons() {
    return defaultRibbonLayout.leftRibbonButtons.concat(
      defaultRibbonLayout.navigationButtons).concat(
      defaultRibbonLayout.noteRibbonButtons).concat(
      defaultRibbonLayout.articulationButtons).concat(
            defaultRibbonLayout.microtoneButtons).concat(
      defaultRibbonLayout.chordButtons).concat(
      defaultRibbonLayout.durationRibbonButtons).concat(defaultRibbonLayout.beamRibbonButtons).concat(defaultRibbonLayout.measureRibbonButtons)
      .concat(defaultRibbonLayout.staveRibbonButtons)
            .concat(defaultRibbonLayout.textRibbonButtons).concat(defaultRibbonLayout.playerButtons)
            .concat(defaultRibbonLayout.voiceRibbonButtons).concat(defaultRibbonLayout.displayButtons).concat(defaultRibbonLayout.debugRibbonButtons);
  }

  static get leftRibbonIds() {
    return ['helpDialog','languageMenu', 'fileMenu','libraryMenu',
    'addStaffMenu','measureModal','tempoModal','timeSignatureMenu','keyMenu', 'staffModifierMenu', 'staffModifierMenu2',
    'instrumentModal','pianoModal','layoutMenu'];
  }
  static get noteButtonIds() {
    return ['NoteButtons',
            'UpNoteButton', 'DownNoteButton','AddGraceNote','RemoveGraceNote','SlashGraceNote','XNoteHead',
        'UpOctaveButton', 'DownOctaveButton', 'ToggleRest','ToggleAccidental', 'ToggleCourtesy'];
  }
  static get voiceButtonIds() {
      return ['VoiceButtons','V1Button','V2Button','V3Button','V4Button','VXButton'];
  }
  static get navigateButtonIds()  {
    return ['NavigationButtons', 'navLeftButton', 'navRightButton', 'navUpButton', 'navDownButton', 'moreNavButtons','navFastForward', 'navRewind',
        'navGrowLeft', 'navGrowRight'];
  }
  static get articulateButtonIds()  {
    return ['articulationButtons', 'accentButton', 'tenutoButton', 'staccatoButton', 'marcatoButton', 'fermataButton', 'pizzicatoButton','mordentButton','mordentInvertedButton','trillButton'
      ,'scoopButton','dropButton','dropLongButton','doitButton','doitLongButton','flipButton','smearButton'];
  }

  static get intervalIds()  {
    return ['CreateChordButtons', 'SecondUpButton', 'SecondDownButton', 'ThirdUpButton', 'ThirdDownButton', 'FourthUpButton', 'FourthDownButton',
        'FifthUpButton', 'FifthDownButton','SixthUpButton', 'SixthDownButton'
        ,'SeventhUpButton', 'SeventhDownButton','OctaveUpButton','OctaveDownButton','CollapseChordButton'];
  }

  static get debugIds() {
    return ['DebugGroup','DebugButton2'];
  }
  static get durationIds() {
    return ['DurationButtons','GrowDuration','LessDuration','GrowDurationDot','LessDurationDot','TripletButton','QuintupletButton','SeptupletButton','NoTupletButton'];
  }
  static get measureIds() {
    return ['MeasureButtons','endRepeat','startRepeat','endBar','doubleBar','singleBarEnd','singleBarStart','nthEnding','dcAlCoda','dsAlCoda','dcAlFine','dsAlFine','coda','toCoda','segno','toSegno','fine'];
  }

    static get textIds() {
    return ['TextButtons','addTextMenu','rehearsalMark','lyrics','chordChanges','addDynamicsMenu'];
  }

    static get beamIds() {
    return ['BeamButtons','breakBeam','beamSelections','toggleBeamDirection'];
  }
    static get staveIds() {
    return ['StaveButtons','clefTreble','clefBass','clefAddRemove','clefMoveUp','clefMoveDown','moreStaffButtons',
        'clefTenor','clefAlto',
           'staffBracketLower','staffBraceLower','staffDoubleConnectorLower','staffSingleConnectorLower'];
  }

  static get playerIds() {
      return ['playerButtons','playButton','pauseButton','stopButton'];
  }

  static get microtoneIds() {
      return ['MicrotoneButtons','flat75sz','flat25sz','flat25ar','flat125ar','sharp75','sharp125','sharp25','sori','koron'];
  }

  static get displayIds() {
      return ['displaySettings','refresh','zoomout','zoomin','playButton2','stopButton2'];
  }


  static get textRibbonButtons() {
    return [
      {
        leftText: '',
        rightText: '',
        classes: 'icon  collapseParent measure',
        icon: 'icon-text',
        action: 'collapseParent',
        ctor: 'CollapseRibbonControl',
        group: 'textEdit',
        id: 'TextButtons'
      }, {
        leftText: '',
        rightText: '/t',
        classes: 'icon collapsed textButton',
        icon: 'icon-textBasic',
        action: 'collapseChild',
        ctor: 'TextButtons',
        group: 'textEdit',
        id: 'addTextMenu'
      },{
        leftText: '',
        rightText: '',
        classes: 'icon collapsed textButton',
        icon: 'icon-rehearsemark',
        action: 'collapseChild',
        ctor: 'TextButtons',
        group: 'textEdit',
        id: 'rehearsalMark'
      },{
        leftText: '',
        rightText: '',
        classes: 'icon collapsed textButton',
        icon: 'icon-lyric',
        action: 'collapseChild',
        ctor: 'TextButtons',
        group: 'textEdit',
        id: 'lyrics'
      },  {
        leftText: '',
        rightText: '',
        classes: 'icon collapsed textButton',
        icon: 'icon-chordSymbol',
        action: 'collapseChild',
        ctor: 'TextButtons',
        group: 'textEdit',
        id: 'chordChanges'
      }, {
        leftText: '',
        rightText: '/d',
        classes: 'icon collapsed textButton',
        icon: 'icon-mezzopiano',
        action: 'collapseChild',
        ctor: 'TextButtons',
        group: 'textEdit',
        id: 'addDynamicsMenu'
      }
    ];
  }
  static get displayButtons() {
    return [{
      leftText: '',
      rightText: '',
      classes: 'icon  hide',
      icon: 'icon-zoomplus',
      action: 'collapseParent',
      ctor: 'CollapseRibbonControl',
      group: 'displaySettings',
      id: 'displaySettings'
    },{
      leftText: '',
      rightText: '',
      classes: 'icon   refresh',
      icon: 'icon-refresh',
      action: 'collapseChild',
      ctor: 'DisplaySettings',
      group: 'displaySettings',
      id: 'refresh'
    },{
      leftText: '',
      rightText: '',
      classes: 'icon   refresh',
      icon: 'icon-zoomplus',
      action: 'collapseChild',
      ctor: 'DisplaySettings',
      group: 'displaySettings',
      id: 'zoomout'
    },{
      leftText: '',
      rightText: '',
      classes: 'icon   refresh',
      icon: 'icon-zoomminus',
      action: 'collapseChild',
      ctor: 'DisplaySettings',
      group: 'displaySettings',
      id: 'zoomin'
    },{
      leftText: '',
      rightText: '',
      classes: 'icon   play',
      icon: 'icon-play3',
      action: 'collapseChild',
      ctor: 'DisplaySettings',
      group: 'displaySettings',
      id: 'playButton2'
    },{
      leftText: '',
      rightText: '',
      classes: 'icon   stop2',
      icon: 'icon-stop2',
      action: 'collapseChild',
      ctor: 'DisplaySettings',
      group: 'displaySettings',
      id: 'stopButton2'
    }
  ];
  }

    static get microtoneButtons() {
        return [{
      leftText: '',
        rightText: '',
        classes: 'icon  collapseParent microtones',
        icon: 'icon-microtone',
        action: 'collapseParent',
        ctor: 'CollapseRibbonControl',
        group: 'microtone',
        id: 'MicrotoneButtons'
    }, {
            leftText: '',
        rightText: '',
        classes: 'icon  collapsed microtones',
        icon: 'icon-flat25sz',
        action: 'collapseChild',
        ctor: 'MicrotoneButtons',
        group: 'microtone',
        id: 'flat25sz'
        }, {
            leftText: '',
        rightText: '',
        classes: 'icon  collapsed microtones',
        icon: 'icon-flat75sz',
        action: 'collapseChild',
        ctor: 'MicrotoneButtons',
        group: 'microtone',
        id: 'flat75sz'
        },{
            leftText: '',
        rightText: '',
        classes: 'icon  collapsed microtones',
        icon: 'icon-flat25ar',
        action: 'collapseChild',
        ctor: 'MicrotoneButtons',
        group: 'microtone',
        id: 'flat25ar'
        },{
            leftText: '',
        rightText: '',
        classes: 'icon  collapsed microtones',
        icon: 'icon-sharp75',
        action: 'collapseChild',
        ctor: 'MicrotoneButtons',
        group: 'microtone',
        id: 'sharp75'
        },{
            leftText: '',
        rightText: '',
        classes: 'icon  collapsed microtones',
        icon: 'icon-sharp125',
        action: 'collapseChild',
        ctor: 'MicrotoneButtons',
        group: 'microtone',
        id: 'sharp125'
        },{
            leftText: '',
        rightText: '',
        classes: 'icon  collapsed microtones',
        icon: 'icon-sharp25',
        action: 'collapseChild',
        ctor: 'MicrotoneButtons',
        group: 'microtone',
        id: 'sharp25'
        },{
            leftText: '',
        rightText: '',
        classes: 'icon  collapsed microtones',
        icon: 'icon-sori',
        action: 'collapseChild',
        ctor: 'MicrotoneButtons',
        group: 'microtone',
        id: 'sori'
        },{
            leftText: '',
        rightText: '',
        classes: 'icon  collapsed microtones',
        icon: 'icon-koron',
        action: 'collapseChild',
        ctor: 'MicrotoneButtons',
        group: 'microtone',
        id: 'koron'
        }];
    }

  static get staveRibbonButtons() {
    return [{
      leftText: '',
        rightText: '',
        classes: 'icon  collapseParent staves',
        icon: 'icon-treble',
        action: 'collapseParent',
        ctor: 'CollapseRibbonControl',
        group: 'staves',
        id: 'StaveButtons'
    },{
      leftText: '',
        rightText: '',
        classes: 'icon  collapsed staves',
        icon: 'icon-treble',
        action: 'collapseChild',
        ctor: 'StaveButtons',
        group: 'staves',
        id: 'clefTreble'
    },{
      leftText: '',
        rightText: '',
        classes: 'icon  collapsed staves',
        icon: 'icon-bass',
        action: 'collapseChild',
        ctor: 'StaveButtons',
        group: 'staves',
        id: 'clefBass'
    }
        ,{
      leftText: '',
        rightText: '',
        classes: 'icon  collapsed staves',
        icon: 'icon-plus',
        action: 'collapseChildMenu',
        ctor: 'SuiAddStaffMenu',
        group: 'staves',
        id: 'clefAddRemove'
    },
        {
      leftText: '',
        rightText: '',
        classes: 'icon  collapsed staves',
        icon: 'icon-arrow-up',
        action: 'collapseChild',
        ctor: 'StaveButtons',
        group: 'staves',
        id: 'clefMoveUp'
    },{
      leftText: '',
        rightText: '',
        classes: 'icon  collapsed staves',
        icon: 'icon-arrow-down',
        action: 'collapseChild',
        ctor: 'StaveButtons',
        group: 'staves',
        id: 'clefMoveDown'
    },
        {
            leftText: '...',
            rightText: '',
            icon: 'icon-circle-left',
            classes: 'collapsed expander',
            action: 'collapseMore',
            ctor: 'ExtendedCollapseParent',
            group: 'staves',
            id: 'moreStaffButtons'
        },{
      leftText: '',
        rightText: '',
        classes: 'icon  collapsed staves',
        icon: 'icon-tenor',
        action: 'collapseGrandchild',
        ctor: 'StaveButtons',
        group: 'staves',
        id: 'clefTenor'
    },{
      leftText: '',
        rightText: '',
        classes: 'icon  collapsed staves',
        icon: 'icon-alto',
        action: 'collapseGrandchild',
        ctor: 'StaveButtons',
        group: 'staves',
        id: 'clefAlto'
    },{
      leftText: '',
        rightText: '',
        classes: 'icon  collapsed staves',
        icon: 'icon-brace',
        action: 'collapseGrandchild',
        ctor: 'StaveButtons',
        group: 'staves',
        id: 'staffBraceLower'
    },{
      leftText: '',
        rightText: '',
        classes: 'icon  collapsed staves',
        icon: 'icon-bracket',
        action: 'collapseGrandchild',
        ctor: 'StaveButtons',
        group: 'staves',
        id: 'staffBracketLower'
    }

    ];
  }

    static get beamRibbonButtons() {
        return [{
      leftText: '',
        rightText: '',
        classes: 'icon  collapseParent beams',
        icon: 'icon-flag',
        action: 'collapseParent',
        ctor: 'CollapseRibbonControl',
        group: 'beams',
        id: 'BeamButtons'
    },{
        leftText: '',
        rightText: 'x',
        icon: 'icon-beamBreak',
        classes: 'collapsed beams',
        action: 'collapseChild',
        ctor: 'BeamButtons',
        group: 'beams',
        id: 'breakBeam'
      },
            {
        leftText: '',
        rightText: 'Shift-X',
        icon: 'icon-beam',
        classes: 'collapsed beams',
        action: 'collapseChild',
        ctor: 'BeamButtons',
        group: 'beams',
        id: 'beamSelections'
      },
            {
        leftText: '',
        rightText: 'Shift-B',
        icon: 'icon-flagFlip',
        classes: 'collapsed beams',
        action: 'collapseChild',
        ctor: 'BeamButtons',
        group: 'beams',
        id: 'toggleBeamDirection'
      }
        ];
    }

  static get measureRibbonButtons() {
    return [{
      leftText: '',
        rightText: '',
        classes: 'icon  collapseParent measure',
        icon: 'icon-end_rpt',
        action: 'collapseParent',
        ctor: 'CollapseRibbonControl',
        group: 'measure',
        id: 'MeasureButtons'
    },{
        leftText: '',
        rightText: '',
        icon: 'icon-end_rpt',
        classes: 'collapsed duration',
        action: 'collapseChild',
        ctor: 'MeasureButtons',
        group: 'measure',
        id: 'endRepeat'
      },
      {
        leftText: '',
        rightText: '',
        icon: 'icon-start_rpt',
        classes: 'collapsed duration',
        action: 'collapseChild',
        ctor: 'MeasureButtons',
        group: 'measure',
        id: 'startRepeat'
      }
      ,
      {
        leftText: '',
        rightText: '',
        icon: 'icon-end_bar',
        classes: 'collapsed duration',
        action: 'collapseChild',
        ctor: 'MeasureButtons',
        group: 'measure',
        id: 'endBar'
      },
      {
        leftText: '',
        rightText: '',
        icon: 'icon-double_bar',
        classes: 'collapsed duration',
        action: 'collapseChild',
        ctor: 'MeasureButtons',
        group: 'measure',
        id: 'doubleBar'
      },
      {
        leftText: '',
        rightText: '',
        icon: 'icon-single_bar',
        classes: 'collapsed duration',
        action: 'collapseChild',
        ctor: 'MeasureButtons',
        group: 'measure',
        id: 'singleBarEnd'
      },
      {
        leftText: '',
        rightText: '',
        icon: 'icon-single_bar_start',
        classes: 'collapsed duration',
        action: 'collapseChild',
        ctor: 'MeasureButtons',
        group: 'measure',
        id: 'singleBarStart'
      },
      {
        leftText: '',
        rightText: '',
        icon: 'icon-ending',
        classes: 'collapsed duration',
        action: 'collapseChild',
        ctor: 'MeasureButtons',
        group: 'measure',
        id: 'nthEnding'
      },
      {
        leftText: 'DC Al Coda',
        rightText: '',
        icon: '',
        classes: 'collapsed repetext',
        action: 'collapseChild',
        ctor: 'MeasureButtons',
        group: 'measure',
        id: 'dcAlCoda'
      },
      {
        leftText: 'DS Al Coda',
        rightText: '',
        icon: '',
        classes: 'collapsed repetext',
        action: 'collapseChild',
        ctor: 'MeasureButtons',
        group: 'measure',
        id: 'dsAlCoda'
      },
      {
        leftText: 'DC Al Fine',
        rightText: '',
        icon: '',
        classes: 'collapsed repetext',
        action: 'collapseChild',
        ctor: 'MeasureButtons',
        group: 'measure',
        id: 'dcAlFine'
      },
      {
        leftText: 'DS Al Fine',
        rightText: '',
        icon: '',
        classes: 'collapsed repetext',
        action: 'collapseChild',
        ctor: 'MeasureButtons',
        group: 'measure',
        id: 'dsAlFine'
      },
      {
        leftText: '',
        rightText: '',
        icon: 'icon-coda',
        classes: 'collapsed duration',
        action: 'collapseChild',
        ctor: 'MeasureButtons',
        group: 'measure',
        id: 'coda'
      },
      {
        leftText: 'to ',
        rightText: '',
        icon: 'icon-coda',
        classes: 'collapsed duration',
        action: 'collapseChild',
        ctor: 'MeasureButtons',
        group: 'measure',
        id: 'toCoda'
      },
      {
        leftText: '',
        rightText: '',
        icon: 'icon-segno',
        classes: 'collapsed duration',
        action: 'collapseChild',
        ctor: 'MeasureButtons',
        group: 'measure',
        id: 'segno'
      },
      {
        leftText: 'Fine',
        rightText: '',
        icon: '',
        classes: 'collapsed repetext',
        action: 'collapseChild',
        ctor: 'MeasureButtons',
        group: 'measure',
        id: 'fine'
      }
    ];
  }
  static get debugRibbonButtons() {
    return [{
        leftText: '',
        rightText: '',
        classes: 'icon  collapseParent',
        icon: 'icon-new-tab',
        action: 'collapseParent',
        ctor: 'CollapseRibbonControl',
        group: 'debug',
        id: 'DebugGroup'
      },{
        leftText: '',
        rightText: '',
        classes: 'icon  collapsed',
        icon: 'icon-new-tab',
        action: 'collapseChild',
        ctor: 'DebugButtons',
        group: 'debug',
        id: 'DebugButton2'
      }];
  }

  static get durationRibbonButtons() {
    return [{
        leftText: '',
        rightText: '',
        classes: 'icon  collapseParent duration',
        icon: 'icon-duration',
        action: 'collapseParent',
        ctor: 'CollapseRibbonControl',
        group: 'duration',
        id: 'DurationButtons'
      },{
        leftText: '',
        rightText: '.',
        icon: 'icon-duration_grow',
        classes: 'collapsed duration',
        action: 'collapseChild',
        ctor: 'DurationButtons',
        group: 'duration',
        id: 'GrowDuration'
      },{
        leftText: '',
        rightText: ',',
        icon: 'icon-duration_less',
        classes: 'collapsed duration',
        action: 'collapseChild',
        ctor: 'DurationButtons',
        group: 'duration',
        id: 'LessDuration'
      },{
        leftText: '',
        rightText: '>',
        icon: 'icon-duration_grow_dot',
        classes: 'collapsed duration',
        action: 'collapseChild',
        ctor: 'DurationButtons',
        group: 'duration',
        id: 'GrowDurationDot'
      },{
        leftText: '',
        rightText: '<',
        icon: 'icon-duration_less_dot',
        classes: 'collapsed duration',
        action: 'collapseChild',
        ctor: 'DurationButtons',
        group: 'duration',
        id: 'LessDurationDot'
      },{
        leftText: '',
        rightText: 'Ctrl-3',
        icon: 'icon-triplet',
        classes: 'collapsed duration tuplet',
        action: 'collapseChild',
        ctor: 'DurationButtons',
        group: 'duration',
        id: 'TripletButton'
      },{
        leftText: '',
        rightText: 'Ctrl-5',
        icon: 'icon-quint',
        classes: 'collapsed duration tuplet',
        action: 'collapseChild',
        ctor: 'DurationButtons',
        group: 'duration',
        id: 'QuintupletButton'
      },{
        leftText: '',
        rightText: 'Ctrl-7',
        icon: 'icon-septuplet',
        classes: 'collapsed duration tuplet',
        action: 'collapseChild',
        ctor: 'DurationButtons',
        group: 'duration',
        id: 'SeptupletButton'
      },
      {
        leftText: '',
        rightText: 'Ctrl-0',
        icon: 'icon-no_tuplet',
        classes: 'collapsed duration tuplet',
        action: 'collapseChild',
        ctor: 'DurationButtons',
        group: 'duration',
        id: 'NoTupletButton'
      }
      ];
  }

    static get voiceRibbonButtons() {
        return [{
                leftText: '',
                rightText: '',
                classes: 'icon  collapseParent',
                icon: 'icon-Vo',
                action: 'collapseParent',
                ctor: 'CollapseRibbonControl',
                group: 'voices',
                id: 'VoiceButtons'
            }, {
                leftText: '',
                rightText: '',
                icon: 'icon-V1',
                classes: 'collapsed',
                action: 'collapseChild',
                ctor: 'VoiceButtons',
                group: 'voices',
                id: 'V1Button'
            }, {
                leftText: '',
                rightText: '',
                icon: 'icon-V2',
                classes: 'collapsed',
                action: 'collapseChild',
                ctor: 'VoiceButtons',
                group: 'voices',
                id: 'V2Button'
            }, {
                leftText: '',
                rightText: '',
                icon: 'icon-V3',
                classes: 'collapsed',
                action: 'collapseChild',
                ctor: 'VoiceButtons',
                group: 'voices',
                id: 'V3Button'
            }, {
                leftText: '',
                rightText: '',
                icon: 'icon-V4',
                classes: 'collapsed',
                action: 'collapseChild',
                ctor: 'VoiceButtons',
                group: 'voices',
                id: 'V4Button'
            }, {
                leftText: '',
                rightText: '',
                icon: 'icon-Vx',
                classes: 'collapsed',
                action: 'collapseChild',
                ctor: 'VoiceButtons',
                group: 'voices',
                id: 'VXButton'
            }
        ];
    }
  static get noteRibbonButtons() {
    return [{
        leftText: '',
        rightText: '',
        classes: 'icon  collapseParent',
        icon: 'icon-note',
        action: 'collapseParent',
        ctor: 'CollapseRibbonControl',
        group: 'notes',
        id: 'NoteButtons'
      }, {
        leftText: 'A',
        rightText: 'a',
        icon: '',
        classes: 'collapsed',
        action: 'collapseChild',
        ctor: 'NoteButtons',
        group: 'notes',
        id: 'ANoteButton'
      }, {
        leftText: 'B',
        rightText: 'b',
        icon: '',
        classes: 'collapsed',
        action: 'collapseChild',
        ctor: 'NoteButtons',
        group: 'notes',
        id: 'BNoteButton'
      }, {
        leftText: 'C',
        rightText: 'c',
        icon: '',
        classes: 'collapsed',
        action: 'collapseChild',
        ctor: 'NoteButtons',
        group: 'notes',
        id: 'CNoteButton'
      }, {
        leftText: 'D',
        rightText: 'd',
        icon: '',
        classes: 'collapsed',
        action: 'collapseChild',
        ctor: 'NoteButtons',
        group: 'notes',
        id: 'DNoteButton'
      }, {
        leftText: 'E',
        rightText: 'e',
        icon: '',
        classes: 'collapsed',
        action: 'collapseChild',
        ctor: 'NoteButtons',
        group: 'notes',
        id: 'ENoteButton'
      }, {
        leftText: 'F',
        rightText: 'f',
        icon: '',
        classes: 'collapsed',
        action: 'collapseChild',
        ctor: 'NoteButtons',
        group: 'notes',
        id: 'FNoteButton'
      }, {
        leftText: 'G',
        rightText: 'g',
        icon: '',
        classes: 'collapsed',
        action: 'collapseChild',
        ctor: 'NoteButtons',
        group: 'notes',
        id: 'GNoteButton'
      }, {
        leftText: '',
        rightText: '-',
        icon: 'icon-sharp',
        classes: 'collapsed',
        action: 'collapseChild',
        ctor: 'NoteButtons',
        group: 'notes',
        id: 'UpNoteButton'
      }, {
        leftText: '',
        rightText: '=',
        icon: 'icon-flat',
        classes: 'collapsed',
        action: 'collapseChild',
        ctor: 'NoteButtons',
        group: 'notes',
        id: 'DownNoteButton'
      }, {
        leftText: '',
        rightText: 'r',
        icon: 'icon-rest',
        classes: 'collapsed',
        action: 'collapseChild',
        ctor: 'NoteButtons',
        group: 'notes',
        id: 'ToggleRestButton'
      },{
        leftText: '...',
        rightText: '',
        icon: 'icon-circle-left',
        classes: 'collapsed expander',
        action: 'collapseMore',
        ctor: 'ExtendedCollapseParent',
        group: 'notes',
        id: 'moreNoteButtons'
      }, {
        leftText: '',
        rightText: 'G',
        icon: 'icon-grace_note',
        classes: 'collapsed graceIcon',
        action: 'collapseChild',
        ctor: 'NoteButtons',
        group: 'notes',
        id: 'AddGraceNote'
      }, {
        leftText: '',
        rightText: '',
        icon: 'icon-grace_slash',
        classes: 'collapsed graceIcon',
        action: 'collapseChild',
        ctor: 'NoteButtons',
        group: 'notes',
        id: 'SlashGraceNote'
      },{
        leftText: '',
        rightText: 'alt-g',
        icon: 'icon-grace_remove',
        classes: 'collapsed graceIcon',
        action: 'collapseChild',
        ctor: 'NoteButtons',
        group: 'notes',
        id: 'RemoveGraceNote'
      },{
        leftText: '',
        rightText: '',
        icon: 'icon-notex',
        classes: 'collapsed graceIcon',
        action: 'collapseChild',
        ctor: 'NoteButtons',
        group: 'notes',
        id: 'XNoteHead'
      },{
        leftText: '8va',
        rightText: 'Shift=',
        icon: '',
        classes: 'collapsed',
        action: 'collapseChild',
        ctor: 'NoteButtons',
        group: 'notes',
        id: 'UpOctaveButton'
      }, {
        leftText: '8vb',
        rightText: 'Shift-',
        icon: '',
        classes: 'collapsed',
        action: 'collapseChild',
        ctor: 'NoteButtons',
        group: 'notes',
        id: 'DownOctaveButton'
      }, {
        leftText: '',
        rightText: 'ShiftE',
        icon: 'icon-accident',
        classes: 'collapsed',
        action: 'collapseChild',
        ctor: 'NoteButtons',
        group: 'notes',
        id: 'ToggleAccidental'
      }, {
        leftText: '',
        rightText: 'ShiftF',
        icon: 'icon-courtesy',
        classes: 'collapsed',
        action: 'collapseChild',
        ctor: 'NoteButtons',
        group: 'notes',
        id: 'ToggleCourtesy'
      }

    ];
  }
  static get playerButtons() {
        // .icon-play3
        return [{
        leftText: '',
        rightText: '',
        icon: 'icon-equalizer2',
        classes: 'icon collapseParent player',
        action: 'collapseParent',
        ctor: 'CollapseRibbonControl',
        group: 'playerButtons',
        id: 'playerButtons'
      }, {
        leftText: '',
        rightText: 'p',
        icon: 'icon-play3',
        classes: 'icon collapsed player',
        action: 'collapseChild',
        ctor: 'PlayerButtons',
        group: 'playerButtons',
        id: 'playButton'
      },
            {
        leftText: '',
        rightText: 's',
        icon: 'icon-stop2',
        classes: 'icon collapsed player',
        action: 'collapseChild',
        ctor: 'PlayerButtons',
        group: 'playerButtons',
        id: 'stopButton'
      },
            {
        leftText: '',
        rightText: 'P',
        icon: 'icon-pause2',
        classes: 'icon collapsed player',
        action: 'collapseChild',
        ctor: 'PlayerButtons',
        group: 'playerButtons',
        id: 'pauseButton'
      }];
    }
    static get articulationButtons() {
    return [{
        leftText: '',
        rightText: '',
        icon: 'icon-articulation',
        classes: 'icon collapseParent articulation',
        action: 'collapseParent',
        ctor: 'CollapseRibbonControl',
        group: 'articulations',
        id: 'articulationButtons'
      }, {
        leftText: '',
        rightText: 'h',
        icon: 'icon-accent_above',
        classes: 'icon collapsed articulation',
        action: 'collapseChild',
        ctor: 'ArticulationButtons',
        group: 'articulations',
        id: 'accentButton'
      },{
        leftText: '',
        rightText: 'i',
        icon: 'icon-tenuto_above',
        classes: 'icon collapsed articulation',
        action: 'collapseChild',
        ctor: 'ArticulationButtons',
        group: 'articulations',
        id: 'tenutoButton'
      }, {
        leftText: '',
        rightText: 'j',
        icon: 'icon-staccato_above',
        classes: 'icon collapsed articulation',
        action: 'collapseChild',
        ctor: 'ArticulationButtons',
        group: 'articulations',
        id: 'staccatoButton'
      }, {
        leftText: '',
        rightText: 'k',
        icon: 'icon-marcato_above',
        classes: 'icon collapsed articulation',
        action: 'collapseChild',
        ctor: 'ArticulationButtons',
        group: 'articulations',
        id: 'marcatoButton'
      }, {
        leftText: '',
        rightText: '',
        icon: 'icon-fermata',
        classes: 'icon collapsed articulation',
        action: 'collapseChild',
        ctor: 'ArticulationButtons',
        group: 'articulations',
        id: 'fermataButton'
      },  {
        leftText: '',
        rightText: 'l',
        icon: 'icon-pitz_above',
        classes: 'icon collapsed articulation',
        action: 'collapseChild',
        ctor: 'ArticulationButtons',
        group: 'articulations',
        id: 'pizzicatoButton'
      }, {
        leftText: '',
        rightText: '',
        icon: 'icon-mordent-inv',
        classes: 'icon collapsed articulation',
        action: 'collapseChild',
        ctor: 'ArticulationButtons',
        group: 'articulations',
        id: 'mordentInvertedButton'
      }, {
        leftText: '',
        rightText: '',
        icon: 'icon-mordent',
        classes: 'icon collapsed articulation',
        action: 'collapseChild',
        ctor: 'ArticulationButtons',
        group: 'articulations',
        id: 'mordentButton'
      }, {
        leftText: '',
        rightText: '',
        icon: 'icon-trill',
        classes: 'icon collapsed articulation',
        action: 'collapseChild',
        ctor: 'ArticulationButtons',
        group: 'articulations',
        id: 'trillButton'
      }, {
        leftText: '',
        rightText: '',
        icon: 'icon-scoop',
        classes: 'icon collapsed articulation',
        action: 'collapseChild',
        ctor: 'ArticulationButtons',
        group: 'articulations',
        id: 'scoopButton'
      },
      {
        leftText: '',
        rightText: '',
        icon: 'icon-drop',
        classes: 'icon collapsed articulation',
        action: 'collapseChild',
        ctor: 'ArticulationButtons',
        group: 'articulations',
        id: 'dropButton'
      },
      {
        leftText: '',
        rightText: '',
        icon: 'icon-drop-long',
        classes: 'icon collapsed articulation',
        action: 'collapseChild',
        ctor: 'ArticulationButtons',
        group: 'articulations',
        id: 'dropLongButton'
      },
      {
        leftText: '',
        rightText: '',
        icon: 'icon-doit',
        classes: 'icon collapsed articulation',
        action: 'collapseChild',
        ctor: 'ArticulationButtons',
        group: 'articulations',
        id: 'doitButton'
      },
      {
        leftText: '',
        rightText: '',
        icon: 'icon-doit-long',
        classes: 'icon collapsed articulation',
        action: 'collapseChild',
        ctor: 'ArticulationButtons',
        group: 'articulations',
        id: 'doitLongButton'
      },
      {
        leftText: '',
        rightText: '',
        icon: 'icon-flip',
        classes: 'icon collapsed articulation',
        action: 'collapseChild',
        ctor: 'ArticulationButtons',
        group: 'articulations',
        id: 'flipButton'
      },
      {
        leftText: '',
        rightText: '',
        icon: 'icon-smear',
        classes: 'icon collapsed articulation',
        action: 'collapseChild',
        ctor: 'ArticulationButtons',
        group: 'articulations',
        id: 'smearButton'
      }
    ];
  }
  static get navigationButtons() {
    return [{
        leftText: '',
        rightText: '',
        classes: 'icon  collapseParent',
        icon: 'icon-navigate',
        action: 'collapseParent',
        ctor: 'CollapseRibbonControl',
        group: 'navigation',
        id: 'NavigationButtons'
      }, {
        leftText: '',
        rightText: '',
        icon: 'icon-arrow-left',
        classes: 'collapsed',
        action: 'collapseChild',
        ctor: 'NavigationButtons',
        group: 'navigation',
        id: 'navLeftButton'
      }, {
        leftText: '',
        rightText: '',
        icon: 'icon-arrow-right',
        classes: 'collapsed',
        action: 'collapseChild',
        ctor: 'NavigationButtons',
        group: 'navigation',
        id: 'navRightButton'
      }, {
        leftText: '',
        rightText: '',
        icon: 'icon-arrow-up',
        classes: 'collapsed',
        action: 'collapseChild',
        ctor: 'NavigationButtons',
        group: 'navigation',
        id: 'navUpButton'
      }, {
        leftText: '',
        rightText: '',
        icon: 'icon-arrow-down',
        classes: 'collapsed',
        action: 'collapseChild',
        ctor: 'NavigationButtons',
        group: 'navigation',
        id: 'navDownButton'
      }, {
        leftText: '...',
        rightText: '',
        icon: '',
        classes: 'collapsed expander',
        action: 'collapseMore',
        ctor: 'ExtendedCollapseParent',
        group: 'navigation',
        id: 'moreNavButtons'
      },{
        leftText: '',
        rightText: '',
        icon: 'icon-fforward',
        classes: 'collapsed',
        action: 'collapseGrandchild',
        ctor: 'NavigationButtons',
        group: 'navigation',
        id: 'navFastForward'
      }, {
        leftText: '',
        rightText: '',
        icon: 'icon-rewind',
        classes: 'collapsed',
        action: 'collapseGrandchild',
        ctor: 'NavigationButtons',
        group: 'navigation',
        id: 'navRewind'
      }, {
        leftText: '',
        rightText: '',
        icon: 'icon-note_select_left',
        classes: 'collapsed selection-icon',
        action: 'collapseGrandchild',
        ctor: 'NavigationButtons',
        group: 'navigation',
        id: 'navGrowLeft'
      }, {
        leftText: '',
        rightText: '',
        icon: 'icon-note_select_right',
        classes: 'collapsed selection-icon',
        action: 'collapseGrandchild',
        ctor: 'NavigationButtons',
        group: 'navigation',
        id: 'navGrowRight'
      }
    ];
  }
  static get chordButtons() {
    return [{
        icon: 'icon-chords',
        leftText: '',
        rightText: '',
        classes: 'icon collapseParent',
        action: 'collapseParent',
        ctor: 'CollapseRibbonControl',
        group: 'chords',
        id: 'CreateChordButtons'
      }, {
        icon: 'icon-arrow-up',
        leftText: '2nd',
        rightText: '2',
        classes: 'collapsed addChord',
        action: 'collapseChild',
        dataElements: {
          interval: '1',
          direction: '1'
        },
        ctor: 'ChordButtons',
        group: 'chords',
        id: 'SecondUpButton'
      }, {
        icon: 'icon-arrow-down',
        leftText: '2nd',
        rightText: 'Shift 2',
        classes: 'collapsed addChord dirdown',
        action: 'collapseChild',
        dataElements: {
          interval: '1',
          direction: '1'
        },
        ctor: 'ChordButtons',
        group: 'chords',
        id: 'SecondDownButton'
      }, {
        icon: 'icon-arrow-up',
        leftText: '3rd',
        rightText: '3',
        classes: 'collapsed addChord',
        action: 'collapseChild',
        dataElements: {
          interval: '2',
          direction: '1'
        },
        ctor: 'ChordButtons',
        group: 'chords',
        id: 'ThirdUpButton'
      }, {
        icon: 'icon-arrow-down',
        leftText: '3rd',
        rightText: 'Shift 3',
        classes: 'collapsed addChord dirdown',
        action: 'collapseChild',
        dataElements: {
          interval: '2',
          direction: '-1'
        },
        ctor: 'ChordButtons',
        group: 'chords',
        id: 'ThirdDownButton'
      }, {
        icon: 'icon-arrow-up',
        leftText: '4th',
        rightText: '4',
        classes: 'collapsed addChord',
        action: 'collapseChild',
        dataElements: {
          interval: '3',
          direction: '1'
        },
        ctor: 'ChordButtons',
        group: 'chords',
        id: 'FourthUpButton'
      }, {
        icon: 'icon-arrow-down',
        leftText: '4th',
        rightText: 'Shift 4',
        classes: 'collapsed addChord dirdown',
        action: 'collapseChild',
        dataElements: {
          interval: '3',
          direction: '-1'
        },
        ctor: 'ChordButtons',
        group: 'chords',
        id: 'FourthDownButton'
      }, {
        icon: 'icon-arrow-up',
        leftText: '5th',
        rightText: '5',
        classes: 'collapsed addChord dirdown',
        action: 'collapseChild',
        dataElements: {
          interval: '4',
          direction: '1'
        },
        ctor: 'ChordButtons',
        group: 'chords',
        id: 'FifthUpButton'
      }, {
        icon: 'icon-arrow-down',
        leftText: '5th',
        rightText: 'Shift 5',
        classes: 'collapsed addChord dirdown',
        action: 'collapseChild',
        dataElements: {
          interval: '4',
          direction: '-1'
        },
        ctor: 'ChordButtons',
        group: 'chords',
        id: 'FifthDownButton'
      }, {
        icon: 'icon-arrow-up',
        leftText: '6th',
        rightText: '6',
        classes: 'collapsed addChord dirdown',
        action: 'collapseChild',
        dataElements: {
          interval: '5',
          direction: '1'
        },
        ctor: 'ChordButtons',
        group: 'chords',
        id: 'SixthUpButton'
      }, {
        icon: 'icon-arrow-down',
        leftText: '6th',
        rightText: 'Shift 6',
        classes: 'collapsed addChord dirdown',
        action: 'collapseChild',
        dataElements: {
          interval: '5',
          direction: '-1'
        },
        ctor: 'ChordButtons',
        group: 'chords',
        id: 'SixthDownButton'
      }, {
        icon: 'icon-arrow-up',
        leftText: '7th',
        rightText: '7',
        classes: 'collapsed addChord dirdown',
        action: 'collapseChild',
        dataElements: {
          interval: '6',
          direction: '1'
        },
        ctor: 'ChordButtons',
        group: 'chords',
        id: 'SeventhUpButton'
      }, {
        icon: 'icon-arrow-down',
        leftText: '7th',
        rightText: 'Shift 7',
        classes: 'collapsed addChord dirdown',
        action: 'collapseChild',
        dataElements: {
          interval: '6',
          direction: '-1'
        },
        ctor: 'ChordButtons',
        group: 'chords',
        id: 'SeventhDownButton'
      }, {
        icon: 'icon-arrow-up',
        leftText: '8va',
        rightText: '8',
        classes: 'collapsed addChord dirdown',
        action: 'collapseChild',
        dataElements: {
          interval: '7',
          direction: '1'
        },
        ctor: 'ChordButtons',
        group: 'chords',
        id: 'OctaveUpButton'
      }, {
        icon: 'icon-arrow-down',
        leftText: '7th',
        rightText: 'Shift 7',
        classes: 'collapsed addChord dirdown',
        action: 'collapseChild',
        dataElements: {
          interval: '7',
          direction: '-1'
        },
        ctor: 'ChordButtons',
        group: 'chords',
        id: 'OctaveDownButton'
      }, {
        icon: '',
        leftText: 'Collapse',
        rightText: '',
        classes: 'collapsed addChord dirdown',
        action: 'collapseChild',
        ctor: 'ChordButtons',
        group: 'chords',
        id: 'CollapseChordButton'
      }
    ];
  }

  static get leftRibbonButtons() {
    return [{
        icon: '',
        leftText: 'Help',
        rightText: '?',
        classes: 'help-button',
        action: 'modal',
        ctor: 'helpModal',
        group: 'scoreEdit',
        id: 'helpDialog'
      }, {
        leftText: 'Language',
        rightText: '/n',
        icon: '',
        classes: 'language-select menu-select',
        action: 'menu',
        ctor: 'SuiLanguageMenu',
        group: 'scoreEdit',
        id: 'languageMenu'
      }, {
        leftText: 'File',
        rightText: '/f',
        icon: '',
        classes: 'file-modify menu-select',
        action: 'menu',
        ctor: 'SuiFileMenu',
        group: 'scoreEdit',
        id: 'fileMenu'
      }, {
        leftText: 'Library',
        rightText: '/L',
        icon: '',
        classes: 'file-modify menu-select',
        action: 'menu',
        ctor: 'SuiLibraryMenu',
        group: 'scoreEdit',
        id: 'libraryMenu'
      }, {
        leftText: 'Tempo',
        rightText: 't',
        icon: '',
        classes: 'icon ',
        action: 'modal',
        ctor: 'SuiTempoDialog',
        group: 'scoreEdit',
        id: 'tempoModal'
      },{
        leftText: 'Time Signature',
        rightText: '/m',
        icon: '',
        classes: 'staff-modify menu-select',
        action: 'menu',
        ctor: 'SuiTimeSignatureMenu',
        group: 'scoreEdit',
        id: 'timeSignatureMenu'
      }, {
        leftText: 'Staves',
        rightText: '/s',
        icon: '',
        classes: 'staff-modify',
        action: 'menu',
        ctor: 'SuiAddStaffMenu',
        group: 'scoreEdit',
        id: 'addStaffMenu'
      },
      {
         leftText: 'Measure',
         rightText: '/a',
         icon: '',
         classes: 'icon menu-select',
         action: 'menu',
         ctor: 'SuiMeasureMenu',
         group: 'scoreEdit',
         id: 'measureModal'
      },
      {
        leftText: 'Key',
        rightText: '/k',
        icon: '',
        classes: 'note-modify menu-select',
        action: 'menu',
        ctor: 'SuiKeySignatureMenu',
        group: 'scoreEdit',
        id: 'keyMenu'
      },
      {
       leftText: 'Instrument',
       rightText: '',
       icon: '',
       classes: 'icon',
       action: 'modal',
       ctor: 'SuiInstrumentDialog',
       group: 'scoreEdit',
       id: 'instrumentModal'
     },
      {
        leftText: 'Lines',
        rightText: '/l',
        icon: '',
        classes: 'icon note-modify menu-select',
        action: 'menu',
        ctor: 'SuiStaffModifierMenu',
        group: 'scoreEdit',
        id: 'staffModifierMenu'
      },
       {
        leftText: 'Piano',
        rightText: '',
        icon: '',
        classes: 'icon keyboard',
        action: 'modal',
        ctor: 'suiPiano',
        group: 'scoreEdit',
        id: 'pianoModal'
      },
       {
        leftText: 'Score',
        rightText: '',
        icon: '',
        classes: 'icon ',
        action: 'menu',
        ctor: 'SuiScoreMenu',
        group: 'scoreEdit',
        id: 'layoutMenu'
      }
    ];
  }
}
;
// ## utController
// a simple controller object to render the unit test cases.
class utController {

	constructor(params) {

		Vex.Merge(this, utController.defaults);
		Vex.Merge(this, params);
		this.bindEvents();
    this.score = params.view.renderer.score;
		this.undoBuffer = new UndoBuffer();
    this.layoutDemon.undoBuffer = this.undoBuffer;
    this.exhandler = new SuiExceptionHandler(this);
    SmoMeasure.emptyMeasureNoteType='n';

    this.layoutDemon.startDemon();
	}

	get renderElement() {
		return this.layout.renderElement;
	}

	static get defaults() {
		return {};
	}

	detach() {
		this.layout = null;
	}

	render() {
    var ix = 0;
    this.view.renderer.layout()
	}

	bindEvents() {}

}

//# sourceMappingURL=smoosic.js.map